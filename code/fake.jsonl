{"code": "void irc_ctcp_recv_dcc ( struct t_irc_server * server , const char * nick , const char * arguments , char * message ) {\n char * dcc_args , * pos , * pos_file , * pos_addr , * pos_port , * pos_size ;\n char * pos_start_resume , * filename ;\n struct t_infolist * infolist ;\n struct t_infolist_item * item ;\n char charset_modifier [ 256 ] ;\n if ( ! arguments || ! arguments [ 0 ] ) return ;\n if ( strncmp ( arguments , \"SEND \" , 5 ) == 0 ) {\n arguments += 5 ;\n while ( arguments [ 0 ] == ' ' ) {\n arguments ++ ;\n }\n dcc_args = strdup ( arguments ) ;\n if ( ! dcc_args ) {\n weechat_printf ( server -> buffer , _ ( \"%s%s: not enough memory for \\\"%s\\\" command\" ) , weechat_prefix ( \"error\" ) , IRC_PLUGIN_NAME , \"privmsg\" ) ;\n return ;\n }\n pos_file = dcc_args ;\n while ( pos_file [ 0 ] == ' ' ) {\n pos_file ++ ;\n }\n pos_size = strrchr ( pos_file , ' ' ) ;\n if ( ! pos_size ) {\n weechat_printf ( server -> buffer , _ ( \"%s%s: cannot parse \\\"%s\\\" command\" ) , weechat_prefix ( \"error\" ) , IRC_PLUGIN_NAME , \"privmsg\" ) ;\n free ( dcc_args ) ;\n return ;\n }\n pos = pos_size ;\n pos_size ++ ;\n while ( pos [ 0 ] == ' ' ) {\n pos -- ;\n }\n pos [ 1 ] = '\\0' ;\n pos_port = strrchr ( pos_file , ' ' ) ;\n if ( ! pos_port ) {\n weechat_printf ( server -> buffer , _ ( \"%s%s: cannot parse \\\"%s\\\" command\" ) , weechat_prefix ( \"error\" ) , IRC_PLUGIN_NAME , \"privmsg\" ) ;\n free ( dcc_args ) ;\n return ;\n }\n pos = pos_port ;\n pos_port ++ ;\n while ( pos [ 0 ] == ' ' ) {\n pos -- ;\n }\n pos [ 1 ] = '\\0' ;\n pos_addr = strrchr ( pos_file , ' ' ) ;\n if ( ! pos_addr ) {\n weechat_printf ( server -> buffer , _ ( \"%s%s: cannot parse \\\"%s\\\" command\" ) , weechat_prefix ( \"error\" ) , IRC_PLUGIN_NAME , \"privmsg\" ) ;\n free ( dcc_args ) ;\n return ;\n }\n pos = pos_addr ;\n pos_addr ++ ;\n while ( pos [ 0 ] == ' ' ) {\n pos -- ;\n }\n pos [ 1 ] = '\\0' ;\n filename = irc_ctcp_dcc_filename_without_quotes ( pos_file ) ;\n infolist = weechat_infolist_new ( ) ;\n if ( infolist ) {\n item = weechat_infolist_new_item ( infolist ) ;\n if ( item ) {\n weechat_infolist_new_var_string ( item , \"plugin_name\" , weechat_plugin -> name ) ;\n weechat_infolist_new_var_string ( item , \"plugin_id\" , server -> name ) ;\n weechat_infolist_new_var_string ( item , \"type_string\" , \"file_recv\" ) ;\n weechat_infolist_new_var_string ( item , \"protocol_string\" , \"dcc\" ) ;\n weechat_infolist_new_var_string ( item , \"remote_nick\" , nick ) ;\n weechat_infolist_new_var_string ( item , \"local_nick\" , server -> nick ) ;\n weechat_infolist_new_var_string ( item , \"filename\" , ( filename ) ? filename : pos_file ) ;\n weechat_infolist_new_var_string ( item , \"size\" , pos_size ) ;\n weechat_infolist_new_var_string ( item , \"proxy\" , IRC_SERVER_OPTION_STRING ( server , IRC_SERVER_OPTION_PROXY ) ) ;\n weechat_infolist_new_var_string ( item , \"remote_address\" , pos_addr ) ;\n weechat_infolist_new_var_integer ( item , \"port\" , atoi ( pos_port ) ) ;\n ( void ) weechat_hook_signal_send ( \"xfer_add\" , WEECHAT_HOOK_SIGNAL_POINTER , infolist ) ;\n }\n weechat_infolist_free ( infolist ) ;\n }\n ( void ) weechat_hook_signal_send ( \"irc_dcc\" , WEECHAT_HOOK_SIGNAL_STRING , message ) ;\n if ( filename ) free ( filename ) ;\n free ( dcc_args ) ;\n }\n else if ( strncmp ( arguments , \"RESUME \" , 7 ) == 0 ) {\n arguments += 7 ;\n while ( arguments [ 0 ] == ' ' ) {\n arguments ++ ;\n }\n dcc_args = strdup ( arguments ) ;\n if ( ! dcc_args ) {\n weechat_printf ( server -> buffer , _ ( \"%s%s: not enough memory for \\\"%s\\\" command\" ) , weechat_prefix ( \"error\" ) , IRC_PLUGIN_NAME , \"privmsg\" ) ;\n return ;\n }\n pos_file = dcc_args ;\n while ( pos_file [ 0 ] == ' ' ) {\n pos_file ++ ;\n }\n pos_start_resume = strrchr ( pos_file , ' ' ) ;\n if ( ! pos_start_resume ) {\n weechat_printf ( server -> buffer , _ ( \"%s%s: cannot parse \\\"%s\\\" command\" ) , weechat_prefix ( \"error\" ) , IRC_PLUGIN_NAME , \"privmsg\" ) ;\n free ( dcc_args ) ;\n return ;\n }\n pos = pos_start_resume ;\n pos_start_resume ++ ;\n while ( pos [ 0 ] == ' ' ) {\n pos -- ;\n }\n pos [ 1 ] = '\\0' ;\n pos_port = strrchr ( pos_file , ' ' ) ;\n if ( ! pos_port ) {\n weechat_printf ( server -> buffer , _ ( \"%s%s: cannot parse \\\"%s\\\" command\" ) , weechat_prefix ( \"error\" ) , IRC_PLUGIN_NAME , \"privmsg\" ) ;\n free ( dcc_args ) ;\n return ;\n }\n pos = pos_port ;\n pos_port ++ ;\n while ( pos [ 0 ] == ' ' ) {\n pos -- ;\n }\n pos [ 1 ] = '\\0' ;\n filename = irc_ctcp_dcc_filename_without_quotes ( pos_file ) ;\n infolist = weechat_infolist_new ( ) ;\n if ( infolist ) {\n item = weechat_infolist_new_item ( infolist ) ;\n if ( item ) {\n weechat_infolist_new_var_string ( item , \"plugin_name\" , weechat_plugin -> name ) ;\n weechat_infolist_new_var_string ( item , \"plugin_id\" , server -> name ) ;\n weechat_infolist_new_var_string ( item , \"type_string\" , \"file_recv\" ) ;\n weechat_infolist_new_var_string ( item , \"filename\" , ( filename ) ? filename : pos_file ) ;\n weechat_infolist_new_var_integer ( item , \"port\" , atoi ( pos_port ) ) ;\n weechat_infolist_new_var_string ( item , \"start_resume\" , pos_start_resume ) ;\n ( void ) weechat_hook_signal_send ( \"xfer_accept_resume\" , WEECHAT_HOOK_SIGNAL_POINTER , infolist ) ;\n }\n weechat_infolist_free ( infolist ) ;\n }\n ( void ) weechat_hook_signal_send ( \"irc_dcc\" , WEECHAT_HOOK_SIGNAL_STRING , message ) ;\n if ( filename ) free ( filename ) ;\n free ( dcc_args ) ;\n }\n else if ( strncmp ( arguments , \"ACCEPT \" , 7 ) == 0 ) {\n arguments += 7 ;\n while ( arguments [ 0 ] == ' ' ) {\n arguments ++ ;\n }\n dcc_args = strdup ( arguments ) ;\n if ( ! dcc_args ) {\n weechat_printf ( server -> buffer , _ ( \"%s%s: not enough memory for \\\"%s\\\" command\" ) , weechat_prefix ( \"error\" ) , IRC_PLUGIN_NAME , \"privmsg\" ) ;\n return ;\n }\n pos_file = dcc_args ;\n while ( pos_file [ 0 ] == ' ' ) {\n pos_file ++ ;\n }\n pos_start_resume = strrchr ( pos_file , ' ' ) ;\n if ( ! pos_start_resume ) {\n weechat_printf ( server -> buffer , _ ( \"%s%s: cannot parse \\\"%s\\\" command\" ) , weechat_prefix ( \"error\" ) , IRC_PLUGIN_NAME , \"privmsg\" ) ;\n free ( dcc_args ) ;\n return ;\n }\n pos = pos_start_resume ;\n pos_start_resume ++ ;\n while ( pos [ 0 ] == ' ' ) {\n pos -- ;\n }\n pos [ 1 ] = '\\0' ;\n pos_port = strrchr ( pos_file , ' ' ) ;\n if ( ! pos_port ) {\n weechat_printf ( server -> buffer , _ ( \"%s%s: cannot parse \\\"%s\\\" command\" ) , weechat_prefix ( \"error\" ) , IRC_PLUGIN_NAME , \"privmsg\" ) ;\n free ( dcc_args ) ;\n return ;\n }\n pos = pos_port ;\n pos_port ++ ;\n while ( pos [ 0 ] == ' ' ) {\n pos -- ;\n }\n pos [ 1 ] = '\\0' ;\n filename = irc_ctcp_dcc_filename_without_quotes ( pos_file ) ;\n infolist = weechat_infolist_new ( ) ;\n if ( infolist ) {\n item = weechat_infolist_new_item ( infolist ) ;\n if ( item ) {\n weechat_infolist_new_var_string ( item , \"plugin_name\" , weechat_plugin -> name ) ;\n weechat_infolist_new_var_string ( item , \"plugin_id\" , server -> name ) ;\n weechat_infolist_new_var_string ( item , \"type_string\" , \"file_recv\" ) ;\n weechat_infolist_new_var_string ( item , \"filename\" , ( filename ) ? filename : pos_file ) ;\n weechat_infolist_new_var_integer ( item , \"port\" , atoi ( pos_port ) ) ;\n weechat_infolist_new_var_string ( item , \"start_resume\" , pos_start_resume ) ;\n ( void ) weechat_hook_signal_send ( \"xfer_start_resume\" , WEECHAT_HOOK_SIGNAL_POINTER , infolist ) ;\n }\n weechat_infolist_free ( infolist ) ;\n }\n ( void ) weechat_hook_signal_send ( \"irc_dcc\" , WEECHAT_HOOK_SIGNAL_STRING , message ) ;\n if ( filename ) free ( filename ) ;\n free ( dcc_args ) ;\n }\n else if ( strncmp ( arguments , \"CHAT \" , 5 ) == 0 ) {\n arguments += 5 ;\n while ( arguments [ 0 ] == ' ' ) {\n arguments ++ ;\n }\n dcc_args = strdup ( arguments ) ;\n if ( ! dcc_args ) {\n weechat_printf ( server -> buffer , _ ( \"%s%s: not enough memory for \\\"%s\\\" command\" ) , weechat_prefix ( \"error\" ) , IRC_PLUGIN_NAME , \"privmsg\" ) ;\n return ;\n }\n pos_file = dcc_args ;\n while ( pos_file [ 0 ] == ' ' ) {\n pos_file ++ ;\n }\n pos_addr = strchr ( pos_file , ' ' ) ;\n if ( ! pos_addr ) {\n weechat_printf ( server -> buffer , _ ( \"%s%s: cannot parse \\\"%s\\\" command\" ) , weechat_prefix ( \"error\" ) , IRC_PLUGIN_NAME , \"privmsg\" ) ;\n free ( dcc_args ) ;\n return ;\n }\n pos_addr [ 0 ] = '\\0' ;\n pos_addr ++ ;\n while ( pos_addr [ 0 ] == ' ' ) {\n pos_addr ++ ;\n }\n pos_port = strchr ( pos_addr , ' ' ) ;\n if ( ! pos_port ) {\n weechat_printf ( server -> buffer , _ ( \"%s%s: cannot parse \\\"%s\\\" command\" ) , weechat_prefix ( \"error\" ) , IRC_PLUGIN_NAME , \"privmsg\" ) ;\n free ( dcc_args ) ;\n return ;\n }\n pos_port [ 0 ] = '\\0' ;\n pos_port ++ ;\n while ( pos_port [ 0 ] == ' ' ) {\n pos_port ++ ;\n }\n if ( weechat_strcasecmp ( pos_file , \"chat\" ) != 0 ) {\n weechat_printf ( server -> buffer , _ ( \"%s%s: unknown DCC CHAT type received from %s%s%s: \\\"%s\\\"\" ) , weechat_prefix ( \"error\" ) , IRC_PLUGIN_NAME , irc_nick_color_for_msg ( server , 0 , NULL , nick ) , nick , IRC_COLOR_RESET , pos_file ) ;\n free ( dcc_args ) ;\n return ;\n }\n infolist = weechat_infolist_new ( ) ;\n if ( infolist ) {\n item = weechat_infolist_new_item ( infolist ) ;\n if ( item ) {\n weechat_infolist_new_var_string ( item , \"plugin_name\" , weechat_plugin -> name ) ;\n weechat_infolist_new_var_string ( item , \"plugin_id\" , server -> name ) ;\n weechat_infolist_new_var_string ( item , \"type_string\" , \"chat_recv\" ) ;\n weechat_infolist_new_var_string ( item , \"remote_nick\" , nick ) ;\n weechat_infolist_new_var_string ( item , \"local_nick\" , server -> nick ) ;\n snprintf ( charset_modifier , sizeof ( charset_modifier ) , \"irc.%s.%s\" , server -> name , nick ) ;\n weechat_infolist_new_var_string ( item , \"charset_modifier\" , charset_modifier ) ;\n weechat_infolist_new_var_string ( item , \"proxy\" , IRC_SERVER_OPTION_STRING ( server , IRC_SERVER_OPTION_PROXY ) ) ;\n weechat_infolist_new_var_string ( item , \"remote_address\" , pos_addr ) ;\n weechat_infolist_new_var_integer ( item , \"port\" , atoi ( pos_port ) ) ;\n ( void ) weechat_hook_signal_send ( \"xfer_add\" , WEECHAT_HOOK_SIGNAL_POINTER , infolist ) ;\n }\n weechat_infolist_free ( infolist ) ;\n }\n ( void ) weechat_hook_signal_send ( \"irc_dcc\" , WEECHAT_HOOK_SIGNAL_STRING , message ) ;\n free ( dcc_args ) ;\n }\n }", "target": 0}
{"code": "int tls_construct_server_key_exchange(SSL *s)\n{\n#ifndef OPENSSL_NO_DH\n    EVP_PKEY *pkdh = NULL;\n#endif\n#ifndef OPENSSL_NO_EC\n    unsigned char *encodedPoint = NULL;\n    int encodedlen = 0;\n    int curve_id = 0;\n#endif\n    EVP_PKEY *pkey;\n    const EVP_MD *md = NULL;\n    unsigned char *p, *d;\n    int al, i;\n    unsigned long type;\n    int n;\n    const BIGNUM *r[4];\n    int nr[4], kn;\n    BUF_MEM *buf;\n    EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n\n    if (md_ctx == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n        al = SSL_AD_INTERNAL_ERROR;\n        goto f_err;\n    }\n\n    type = s->s3->tmp.new_cipher->algorithm_mkey;\n\n    buf = s->init_buf;\n\n    r[0] = r[1] = r[2] = r[3] = NULL;\n    n = 0;\n#ifndef OPENSSL_NO_PSK\n    if (type & SSL_PSK) {\n        /*\n         * reserve size for record length and PSK identity hint\n         */\n        n += 2;\n        if (s->cert->psk_identity_hint)\n            n += strlen(s->cert->psk_identity_hint);\n    }\n    /* Plain PSK or RSAPSK nothing to do */\n    if (type & (SSL_kPSK | SSL_kRSAPSK)) {\n    } else\n#endif                          /* !OPENSSL_NO_PSK */\n#ifndef OPENSSL_NO_DH\n    if (type & (SSL_kDHE | SSL_kDHEPSK)) {\n        CERT *cert = s->cert;\n\n        EVP_PKEY *pkdhp = NULL;\n        DH *dh;\n\n        if (s->cert->dh_tmp_auto) {\n            DH *dhp = ssl_get_auto_dh(s);\n            pkdh = EVP_PKEY_new();\n            if (pkdh == NULL || dhp == NULL) {\n                DH_free(dhp);\n                al = SSL_AD_INTERNAL_ERROR;\n                SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto f_err;\n            }\n            EVP_PKEY_assign_DH(pkdh, dhp);\n            pkdhp = pkdh;\n        } else {\n            pkdhp = cert->dh_tmp;\n        }\n        if ((pkdhp == NULL) && (s->cert->dh_tmp_cb != NULL)) {\n            DH *dhp = s->cert->dh_tmp_cb(s, 0, 1024);\n            pkdh = ssl_dh_to_pkey(dhp);\n            if (pkdh == NULL) {\n                al = SSL_AD_INTERNAL_ERROR;\n                SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto f_err;\n            }\n            pkdhp = pkdh;\n        }\n        if (pkdhp == NULL) {\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE,\n                   SSL_R_MISSING_TMP_DH_KEY);\n            goto f_err;\n        }\n        if (!ssl_security(s, SSL_SECOP_TMP_DH,\n                          EVP_PKEY_security_bits(pkdhp), 0, pkdhp)) {\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE,\n                   SSL_R_DH_KEY_TOO_SMALL);\n            goto f_err;\n        }\n        if (s->s3->tmp.pkey != NULL) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE,\n                   ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        s->s3->tmp.pkey = ssl_generate_pkey(pkdhp, NID_undef);\n\n        if (s->s3->tmp.pkey == NULL) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE, ERR_R_EVP_LIB);\n            goto err;\n        }\n\n        dh = EVP_PKEY_get0_DH(s->s3->tmp.pkey);\n\n        EVP_PKEY_free(pkdh);\n        pkdh = NULL;\n\n        DH_get0_pqg(dh, &r[0], NULL, &r[1]);\n        DH_get0_key(dh, &r[2], NULL);\n    } else\n#endif\n#ifndef OPENSSL_NO_EC\n    if (type & (SSL_kECDHE | SSL_kECDHEPSK)) {\n        int nid;\n\n        if (s->s3->tmp.pkey != NULL) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE,\n                   ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        /* Get NID of appropriate shared curve */\n        nid = tls1_shared_curve(s, -2);\n        curve_id = tls1_ec_nid2curve_id(nid);\n        if (curve_id == 0) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE,\n                   SSL_R_UNSUPPORTED_ELLIPTIC_CURVE);\n            goto err;\n        }\n        s->s3->tmp.pkey = ssl_generate_pkey(NULL, nid);\n        /* Generate a new key for this curve */\n        if (s->s3->tmp.pkey == NULL) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE, ERR_R_EVP_LIB);\n            goto f_err;\n        }\n\n        /* Encode the public key. */\n        encodedlen = EC_KEY_key2buf(EVP_PKEY_get0_EC_KEY(s->s3->tmp.pkey),\n                                    POINT_CONVERSION_UNCOMPRESSED,\n                                    &encodedPoint, NULL);\n\n        if (encodedlen == 0) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE, ERR_R_EC_LIB);\n            goto err;\n        }\n\n        /*\n         * We only support named (not generic) curves in ECDH ephemeral key\n         * exchanges. In this situation, we need four additional bytes to\n         * encode the entire ServerECDHParams structure.\n         */\n        n += 4 + encodedlen;\n\n        /*\n         * We'll generate the serverKeyExchange message explicitly so we\n         * can set these to NULLs\n         */\n        r[0] = NULL;\n        r[1] = NULL;\n        r[2] = NULL;\n        r[3] = NULL;\n    } else\n#endif                          /* !OPENSSL_NO_EC */\n#ifndef OPENSSL_NO_SRP\n    if (type & SSL_kSRP) {\n        if ((s->srp_ctx.N == NULL) ||\n            (s->srp_ctx.g == NULL) ||\n            (s->srp_ctx.s == NULL) || (s->srp_ctx.B == NULL)) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE,\n                   SSL_R_MISSING_SRP_PARAM);\n            goto err;\n        }\n        r[0] = s->srp_ctx.N;\n        r[1] = s->srp_ctx.g;\n        r[2] = s->srp_ctx.s;\n        r[3] = s->srp_ctx.B;\n    } else\n#endif\n    {\n        al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE,\n               SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);\n        goto f_err;\n    }\n    for (i = 0; i < 4 && r[i] != NULL; i++) {\n        nr[i] = BN_num_bytes(r[i]);\n#ifndef OPENSSL_NO_SRP\n        if ((i == 2) && (type & SSL_kSRP))\n            n += 1 + nr[i];\n        else\n#endif\n            n += 2 + nr[i];\n    }\n\n    if (!(s->s3->tmp.new_cipher->algorithm_auth & (SSL_aNULL|SSL_aSRP))\n        && !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_PSK)) {\n        if ((pkey = ssl_get_sign_pkey(s, s->s3->tmp.new_cipher, &md))\n            == NULL) {\n            al = SSL_AD_DECODE_ERROR;\n            goto f_err;\n        }\n        kn = EVP_PKEY_size(pkey);\n        /* Allow space for signature algorithm */\n        if (SSL_USE_SIGALGS(s))\n            kn += 2;\n        /* Allow space for signature length */\n        kn += 2;\n    } else {\n        pkey = NULL;\n        kn = 0;\n    }\n\n    if (!BUF_MEM_grow_clean(buf, n + SSL_HM_HEADER_LENGTH(s) + kn)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE, ERR_LIB_BUF);\n        goto err;\n    }\n    d = p = ssl_handshake_start(s);\n\n#ifndef OPENSSL_NO_PSK\n    if (type & SSL_PSK) {\n        /* copy PSK identity hint */\n        if (s->cert->psk_identity_hint) {\n            size_t len = strlen(s->cert->psk_identity_hint);\n            if (len > PSK_MAX_IDENTITY_LEN) {\n                /*\n                 * Should not happen - we already checked this when we set\n                 * the identity hint\n                 */\n                SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            s2n(len, p);\n            memcpy(p, s->cert->psk_identity_hint, len);\n            p += len;\n        } else {\n            s2n(0, p);\n        }\n    }\n#endif\n\n    for (i = 0; i < 4 && r[i] != NULL; i++) {\n#ifndef OPENSSL_NO_SRP\n        if ((i == 2) && (type & SSL_kSRP)) {\n            *p = nr[i];\n            p++;\n        } else\n#endif\n            s2n(nr[i], p);\n        BN_bn2bin(r[i], p);\n        p += nr[i];\n    }\n\n#ifndef OPENSSL_NO_EC\n    if (type & (SSL_kECDHE | SSL_kECDHEPSK)) {\n        /*\n         * XXX: For now, we only support named (not generic) curves. In\n         * this situation, the serverKeyExchange message has: [1 byte\n         * CurveType], [2 byte CurveName] [1 byte length of encoded\n         * point], followed by the actual encoded point itself\n         */\n        *p = NAMED_CURVE_TYPE;\n        p += 1;\n        *p = 0;\n        p += 1;\n        *p = curve_id;\n        p += 1;\n        *p = encodedlen;\n        p += 1;\n        memcpy(p, encodedPoint, encodedlen);\n        OPENSSL_free(encodedPoint);\n        encodedPoint = NULL;\n        p += encodedlen;\n    }\n#endif\n\n    /* not anonymous */\n    if (pkey != NULL) {\n        /*\n         * n is the length of the params, they start at &(d[4]) and p\n         * points to the space at the end.\n         */\n        if (md) {\n            /* send signature algorithm */\n            if (SSL_USE_SIGALGS(s)) {\n                if (!tls12_get_sigandhash(p, pkey, md)) {\n                    /* Should never happen */\n                    al = SSL_AD_INTERNAL_ERROR;\n                    SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE,\n                           ERR_R_INTERNAL_ERROR);\n                    goto f_err;\n                }\n                p += 2;\n            }\n#ifdef SSL_DEBUG\n            fprintf(stderr, \"Using hash %s\\n\", EVP_MD_name(md));\n#endif\n            if (EVP_SignInit_ex(md_ctx, md, NULL) <= 0\n                    || EVP_SignUpdate(md_ctx, &(s->s3->client_random[0]),\n                                      SSL3_RANDOM_SIZE) <= 0\n                    || EVP_SignUpdate(md_ctx, &(s->s3->server_random[0]),\n                                      SSL3_RANDOM_SIZE) <= 0\n                    || EVP_SignUpdate(md_ctx, d, n) <= 0\n                    || EVP_SignFinal(md_ctx, &(p[2]),\n                               (unsigned int *)&i, pkey) <= 0) {\n                SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE, ERR_LIB_EVP);\n                al = SSL_AD_INTERNAL_ERROR;\n                goto f_err;\n            }\n            s2n(i, p);\n            n += i + 2;\n            if (SSL_USE_SIGALGS(s))\n                n += 2;\n        } else {\n            /* Is this error check actually needed? */\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE,\n                   SSL_R_UNKNOWN_PKEY_TYPE);\n            goto f_err;\n        }\n    }\n\n    if (!ssl_set_handshake_header(s, SSL3_MT_SERVER_KEY_EXCHANGE, n)) {\n        al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    }\n\n    EVP_MD_CTX_free(md_ctx);\n    return 1;\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n#ifndef OPENSSL_NO_DH\n    EVP_PKEY_free(pkdh);\n#endif\n#ifndef OPENSSL_NO_EC\n    OPENSSL_free(encodedPoint);\n#endif\n    EVP_MD_CTX_free(md_ctx);\n    ossl_statem_set_error(s);\n    return 0;\n}", "target": 0, "bug_location": 0}
{"code": "static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,\n\n                                       int *mb_type)\n\n{\n\n    int b8_stride = 2;\n\n    int b4_stride = h->b_stride;\n\n    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;\n\n    int mb_type_col[2];\n\n    const int16_t (*l1mv0)[2], (*l1mv1)[2];\n\n    const int8_t *l1ref0, *l1ref1;\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    unsigned int sub_mb_type = MB_TYPE_L0L1;\n\n    int i8, i4;\n\n    int ref[2];\n\n    int mv[2];\n\n    int list;\n\n\n\n    assert(sl->ref_list[1][0].reference & 3);\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent,\n\n                           sl->mb_y + !!IS_INTERLACED(*mb_type));\n\n\n\n#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \\\n\n                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)\n\n\n\n    /* ref = min(neighbors) */\n\n    for (list = 0; list < 2; list++) {\n\n        int left_ref     = sl->ref_cache[list][scan8[0] - 1];\n\n        int top_ref      = sl->ref_cache[list][scan8[0] - 8];\n\n        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];\n\n        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];\n\n        if (refc == PART_NOT_AVAILABLE) {\n\n            refc = sl->ref_cache[list][scan8[0] - 8 - 1];\n\n            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];\n\n        }\n\n        ref[list] = FFMIN3((unsigned)left_ref,\n\n                           (unsigned)top_ref,\n\n                           (unsigned)refc);\n\n        if (ref[list] >= 0) {\n\n            /* This is just pred_motion() but with the cases removed that\n\n             * cannot happen for direct blocks. */\n\n            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];\n\n            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];\n\n\n\n            int match_count = (left_ref == ref[list]) +\n\n                              (top_ref  == ref[list]) +\n\n                              (refc     == ref[list]);\n\n\n\n            if (match_count > 1) { // most common\n\n                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),\n\n                                      mid_pred(A[1], B[1], C[1]));\n\n            } else {\n\n                assert(match_count == 1);\n\n                if (left_ref == ref[list])\n\n                    mv[list] = AV_RN32A(A);\n\n                else if (top_ref == ref[list])\n\n                    mv[list] = AV_RN32A(B);\n\n                else\n\n                    mv[list] = AV_RN32A(C);\n\n            }\n\n        } else {\n\n            int mask = ~(MB_TYPE_L0 << (2 * list));\n\n            mv[list]  = 0;\n\n            ref[list] = -1;\n\n            if (!is_b8x8)\n\n                *mb_type &= mask;\n\n            sub_mb_type &= mask;\n\n        }\n\n    }\n\n    if (ref[0] < 0 && ref[1] < 0) {\n\n        ref[0] = ref[1] = 0;\n\n        if (!is_b8x8)\n\n            *mb_type |= MB_TYPE_L0L1;\n\n        sub_mb_type |= MB_TYPE_L0L1;\n\n    }\n\n\n\n    if (!(is_b8x8 | mv[0] | mv[1])) {\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n        return;\n\n    }\n\n\n\n    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL\n\n        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL\n\n            mb_y  = (sl->mb_y & ~1) + sl->col_parity;\n\n            mb_xy = sl->mb_x +\n\n                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;\n\n            b8_stride = 0;\n\n        } else {\n\n            mb_y  += sl->col_fieldoff;\n\n            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity\n\n        }\n\n        goto single_col;\n\n    } else {                                             // AFL/AFR/FR/FL -> AFR/FR\n\n        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR\n\n            mb_y           =  sl->mb_y & ~1;\n\n            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;\n\n            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];\n\n            b8_stride      = 2 + 4 * h->mb_stride;\n\n            b4_stride     *= 6;\n\n            if (IS_INTERLACED(mb_type_col[0]) !=\n\n                IS_INTERLACED(mb_type_col[1])) {\n\n                mb_type_col[0] &= ~MB_TYPE_INTERLACED;\n\n                mb_type_col[1] &= ~MB_TYPE_INTERLACED;\n\n            }\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&\n\n                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&\n\n                !is_b8x8) {\n\n                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */\n\n            } else {\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        } else {                                         //     AFR/FR    -> AFR/FR\n\nsingle_col:\n\n            mb_type_col[0] =\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {\n\n                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */\n\n            } else if (!is_b8x8 &&\n\n                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {\n\n                *mb_type |= MB_TYPE_DIRECT2 |\n\n                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));\n\n            } else {\n\n                if (!h->sps.direct_8x8_inference_flag) {\n\n                    /* FIXME: Save sub mb types from previous frames (or derive\n\n                     * from MVs) so we know exactly what block size to use. */\n\n                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */\n\n                }\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        }\n\n    }\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);\n\n\n\n    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];\n\n    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];\n\n    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];\n\n    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];\n\n    if (!b8_stride) {\n\n        if (sl->mb_y & 1) {\n\n            l1ref0 += 2;\n\n            l1ref1 += 2;\n\n            l1mv0  += 2 * b4_stride;\n\n            l1mv1  += 2 * b4_stride;\n\n        }\n\n    }\n\n\n\n    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            int x8  = i8 & 1;\n\n            int y8  = i8 >> 1;\n\n            int xy8 = x8     + y8 * b8_stride;\n\n            int xy4 = x8 * 3 + y8 * b4_stride;\n\n            int a, b;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                ((l1ref0[xy8] == 0 &&\n\n                  FFABS(l1mv0[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv0[xy4][1]) <= 1) ||\n\n                 (l1ref0[xy8] < 0 &&\n\n                  l1ref1[xy8] == 0 &&\n\n                  FFABS(l1mv1[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv1[xy4][1]) <= 1))) {\n\n                a =\n\n                b = 0;\n\n                if (ref[0] > 0)\n\n                    a = mv[0];\n\n                if (ref[1] > 0)\n\n                    b = mv[1];\n\n                n++;\n\n            } else {\n\n                a = mv[0];\n\n                b = mv[1];\n\n            }\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);\n\n        }\n\n        if (!is_b8x8 && !(n & 3))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    } else if (IS_16X16(*mb_type)) {\n\n        int a, b;\n\n\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n            ((l1ref0[0] == 0 &&\n\n              FFABS(l1mv0[0][0]) <= 1 &&\n\n              FFABS(l1mv0[0][1]) <= 1) ||\n\n             (l1ref0[0] < 0 && !l1ref1[0] &&\n\n              FFABS(l1mv1[0][0]) <= 1 &&\n\n              FFABS(l1mv1[0][1]) <= 1 &&\n\n              h->x264_build > 33U))) {\n\n            a = b = 0;\n\n            if (ref[0] > 0)\n\n                a = mv[0];\n\n            if (ref[1] > 0)\n\n                b = mv[1];\n\n        } else {\n\n            a = mv[0];\n\n            b = mv[1];\n\n        }\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);\n\n    } else {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            const int x8 = i8 & 1;\n\n            const int y8 = i8 >> 1;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n\n\n            assert(b8_stride == 2);\n\n            /* col_zero_flag */\n\n            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                (l1ref0[i8] == 0 ||\n\n                 (l1ref0[i8] < 0 &&\n\n                  l1ref1[i8] == 0 &&\n\n                  h->x264_build > 33U))) {\n\n                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;\n\n                if (IS_SUB_8X8(sub_mb_type)) {\n\n                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];\n\n                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                        if (ref[0] == 0)\n\n                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        if (ref[1] == 0)\n\n                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        n += 4;\n\n                    }\n\n                } else {\n\n                    int m = 0;\n\n                    for (i4 = 0; i4 < 4; i4++) {\n\n                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +\n\n                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];\n\n                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                            if (ref[0] == 0)\n\n                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);\n\n                            if (ref[1] == 0)\n\n                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);\n\n                            m++;\n\n                        }\n\n                    }\n\n                    if (!(m & 3))\n\n                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;\n\n                    n += m;\n\n                }\n\n            }\n\n        }\n\n        if (!is_b8x8 && !(n & 15))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    }\n\n}\n", "target": 0}
