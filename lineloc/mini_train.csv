,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,flaw_line,flaw_line_index,func_after,func_before,index,lang,lines_after,lines_before,parentID,patch,processed_func,project,project_after,project_before,target,vul_func_with_fix
30,None,Remote,Not required,Complete,CVE-2016-1639,https://www.cvedetails.com/cve/CVE-2016-1639/,,Low,Complete,Complete,,2016-03-05,10.0,Use-after-free vulnerability in browser/extensions/api/webrtc_audio_private/webrtc_audio_private_api.cc in the WebRTC Audio Private API implementation in Google Chrome before 49.0.2623.75 allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging incorrect reliance on the resource context pointer.,2016-12-02,DoS ,1.0,https://github.com/chromium/chromium/commit/c66b1fc49870c514b1c1e8b53498153176d7ec2b,c66b1fc49870c514b1c1e8b53498153176d7ec2b,"cros: Check initial auth type when showing views login.

Bug: 859611
Change-Id: I0298db9bbf4aed6bd40600aef2e1c5794e8cd058
Reviewed-on: https://chromium-review.googlesource.com/1123056
Reviewed-by: Xiaoyin Hu <xiaoyinh@chromium.org>
Commit-Queue: Jacob Dufault <jdufault@chromium.org>
Cr-Commit-Position: refs/heads/master@{#572224}",1.0,chrome/browser/chromeos/login/screens/user_selection_screen.cc,"{""sha"": ""65a2a1a67c6a6f44cf394a7d832d622a9e97e424"", ""filename"": ""ash/login/ui/lock_contents_view.cc"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 9, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c66b1fc49870c514b1c1e8b53498153176d7ec2b/ash/login/ui/lock_contents_view.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c66b1fc49870c514b1c1e8b53498153176d7ec2b/ash/login/ui/lock_contents_view.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/login/ui/lock_contents_view.cc?ref=c66b1fc49870c514b1c1e8b53498153176d7ec2b"", ""patch"": ""@@ -233,8 +233,14 @@ views::View* LockContentsView::TestApi::main_view() const {\n   return view_->main_view_;\n }\n \n-LockContentsView::UserState::UserState(AccountId account_id)\n-    : account_id(account_id) {}\n+LockContentsView::UserState::UserState(const mojom::LoginUserInfoPtr& user_info)\n+    : account_id(user_info->basic_user_info->account_id) {\n+  fingerprint_state = user_info->allow_fingerprint_unlock\n+                          ? mojom::FingerprintUnlockState::AVAILABLE\n+                          : mojom::FingerprintUnlockState::UNAVAILABLE;\n+  if (user_info->auth_type == proximity_auth::mojom::AuthType::ONLINE_SIGN_IN)\n+    force_online_sign_in = true;\n+}\n \n LockContentsView::UserState::UserState(UserState&&) = default;\n \n@@ -405,13 +411,8 @@ void LockContentsView::OnUsersChanged(\n   }\n \n   // Build user state list.\n-  for (const mojom::LoginUserInfoPtr& user : users) {\n-    UserState state(user->basic_user_info->account_id);\n-    state.fingerprint_state = user->allow_fingerprint_unlock\n-                                  ? mojom::FingerprintUnlockState::AVAILABLE\n-                                  : mojom::FingerprintUnlockState::UNAVAILABLE;\n-    users_.push_back(std::move(state));\n-  }\n+  for (const mojom::LoginUserInfoPtr& user : users)\n+    users_.push_back(UserState(user));\n \n   auto box_layout =\n       std::make_unique<views::BoxLayout>(views::BoxLayout::kHorizontal);""}<_**next**_>{""sha"": ""c679213e18fa8deb286d626db2836576c8d5808b"", ""filename"": ""ash/login/ui/lock_contents_view.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c66b1fc49870c514b1c1e8b53498153176d7ec2b/ash/login/ui/lock_contents_view.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c66b1fc49870c514b1c1e8b53498153176d7ec2b/ash/login/ui/lock_contents_view.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/login/ui/lock_contents_view.h?ref=c66b1fc49870c514b1c1e8b53498153176d7ec2b"", ""patch"": ""@@ -189,7 +189,7 @@ class ASH_EXPORT LockContentsView\n  private:\n   class UserState {\n    public:\n-    explicit UserState(AccountId account_id);\n+    explicit UserState(const mojom::LoginUserInfoPtr& user_info);\n     UserState(UserState&&);\n     ~UserState();\n ""}<_**next**_>{""sha"": ""123991b160e74df3bc9d56ccb73c072a43c69bc9"", ""filename"": ""chrome/browser/chromeos/login/screens/user_selection_screen.cc"", ""status"": ""modified"", ""additions"": 69, ""deletions"": 86, ""changes"": 155, ""blob_url"": ""https://github.com/chromium/chromium/blob/c66b1fc49870c514b1c1e8b53498153176d7ec2b/chrome/browser/chromeos/login/screens/user_selection_screen.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c66b1fc49870c514b1c1e8b53498153176d7ec2b/chrome/browser/chromeos/login/screens/user_selection_screen.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chromeos/login/screens/user_selection_screen.cc?ref=c66b1fc49870c514b1c1e8b53498153176d7ec2b"", ""patch"": ""@@ -99,7 +99,7 @@ bool GetEnterpriseDomain(std::string* out_domain) {\n // Get locales information of public account user.\n // Returns a list of available locales.\n // |public_session_recommended_locales|: This can be nullptr if we don't have\n-// recommanded locales.\n+// recommended locales.\n // |out_selected_locale|: Output value of the initially selected locale.\n // |out_multiple_locales|: Output value indicates whether we have multiple\n // recommended locales.\n@@ -362,7 +362,7 @@ void UserSelectionScreen::InitEasyUnlock() {\n \n // static\n void UserSelectionScreen::FillUserDictionary(\n-    user_manager::User* user,\n+    const user_manager::User* user,\n     bool is_owner,\n     bool is_signin_to_add,\n     proximity_auth::mojom::AuthType auth_type,\n@@ -397,7 +397,7 @@ void UserSelectionScreen::FillUserDictionary(\n \n // static\n void UserSelectionScreen::FillMultiProfileUserPrefs(\n-    user_manager::User* user,\n+    const user_manager::User* user,\n     base::DictionaryValue* user_dict,\n     bool is_signin_to_add) {\n   if (!is_signin_to_add) {\n@@ -487,56 +487,6 @@ ash::mojom::UserAvatarPtr UserSelectionScreen::BuildMojoUserAvatarForUser(\n   return avatar;\n }\n \n-// static\n-void UserSelectionScreen::FillUserMojoStruct(\n-    const user_manager::User* user,\n-    bool is_owner,\n-    bool is_signin_to_add,\n-    proximity_auth::mojom::AuthType auth_type,\n-    const std::vector<std::string>* public_session_recommended_locales,\n-    ash::mojom::LoginUserInfo* user_info) {\n-  user_info->basic_user_info = ash::mojom::UserInfo::New();\n-  user_info->basic_user_info->type = user->GetType();\n-  user_info->basic_user_info->account_id = user->GetAccountId();\n-  user_info->basic_user_info->display_name =\n-      base::UTF16ToUTF8(user->GetDisplayName());\n-  user_info->basic_user_info->display_email = user->display_email();\n-  user_info->basic_user_info->avatar = BuildMojoUserAvatarForUser(user);\n-  user_info->auth_type = auth_type;\n-  user_info->is_signed_in = user->is_logged_in();\n-  user_info->is_device_owner = is_owner;\n-  user_info->can_remove = CanRemoveUser(user);\n-  user_info->allow_fingerprint_unlock = AllowFingerprintForUser(user);\n-\n-  // Fill multi-profile data.\n-  if (!is_signin_to_add) {\n-    user_info->is_multiprofile_allowed = true;\n-  } else {\n-    GetMultiProfilePolicy(user, &user_info->is_multiprofile_allowed,\n-                          &user_info->multiprofile_policy);\n-  }\n-\n-  // Fill public session data.\n-  if (user->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT) {\n-    user_info->public_account_info = ash::mojom::PublicAccountInfo::New();\n-    std::string domain;\n-    if (GetEnterpriseDomain(&domain))\n-      user_info->public_account_info->enterprise_domain = domain;\n-\n-    std::string selected_locale;\n-    bool has_multiple_locales;\n-    std::unique_ptr<base::ListValue> available_locales =\n-        GetPublicSessionLocales(public_session_recommended_locales,\n-                                &selected_locale, &has_multiple_locales);\n-    DCHECK(available_locales);\n-    user_info->public_account_info->available_locales =\n-        lock_screen_utils::FromListValueToLocaleItem(\n-            std::move(available_locales));\n-    user_info->public_account_info->default_locale = selected_locale;\n-    user_info->public_account_info->show_advanced_view = has_multiple_locales;\n-  }\n-}\n-\n void UserSelectionScreen::SetHandler(LoginDisplayWebUIHandler* handler) {\n   handler_ = handler;\n \n@@ -561,8 +511,7 @@ void UserSelectionScreen::Init(const user_manager::UserList& users) {\n }\n \n void UserSelectionScreen::OnBeforeUserRemoved(const AccountId& account_id) {\n-  for (user_manager::UserList::iterator it = users_.begin(); it != users_.end();\n-       ++it) {\n+  for (auto it = users_.cbegin(); it != users_.cend(); ++it) {\n     if ((*it)->GetAccountId() == account_id) {\n       users_.erase(it);\n       break;\n@@ -607,23 +556,22 @@ const user_manager::UserList UserSelectionScreen::PrepareUserListForSending(\n   size_t max_non_owner_users = has_owner ? kMaxUsers - 1 : kMaxUsers;\n   size_t non_owner_count = 0;\n \n-  for (user_manager::UserList::const_iterator it = users.begin();\n-       it != users.end(); ++it) {\n-    bool is_owner = ((*it)->GetAccountId() == owner);\n+  for (user_manager::User* user : users) {\n+    bool is_owner = user->GetAccountId() == owner;\n     bool is_public_account =\n-        ((*it)->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT);\n+        user->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT;\n \n     if ((is_public_account && !is_signin_to_add) || is_owner ||\n         (!is_public_account && non_owner_count < max_non_owner_users)) {\n       if (!is_owner)\n         ++non_owner_count;\n       if (is_owner && users_to_send.size() > kMaxUsers) {\n         // Owner is always in the list.\n-        users_to_send.insert(users_to_send.begin() + (kMaxUsers - 1), *it);\n+        users_to_send.insert(users_to_send.begin() + (kMaxUsers - 1), user);\n         while (users_to_send.size() > kMaxUsers)\n           users_to_send.erase(users_to_send.begin() + kMaxUsers);\n       } else if (users_to_send.size() < kMaxUsers) {\n-        users_to_send.push_back(*it);\n+        users_to_send.push_back(user);\n       }\n     }\n   }\n@@ -803,16 +751,15 @@ UserSelectionScreen::UpdateAndReturnUserListForWebUI() {\n \n   user_auth_type_map_.clear();\n \n-  for (user_manager::UserList::const_iterator it = users_to_send_.begin();\n-       it != users_to_send_.end(); ++it) {\n-    const AccountId& account_id = (*it)->GetAccountId();\n+  for (const user_manager::User* user : users_to_send_) {\n+    const AccountId& account_id = user->GetAccountId();\n     bool is_owner = (account_id == owner);\n     const bool is_public_account =\n-        ((*it)->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT);\n+        user->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT;\n     const proximity_auth::mojom::AuthType initial_auth_type =\n         is_public_account\n             ? proximity_auth::mojom::AuthType::EXPAND_THEN_USER_CLICK\n-            : (ShouldForceOnlineSignIn(*it)\n+            : (ShouldForceOnlineSignIn(user)\n                    ? proximity_auth::mojom::AuthType::ONLINE_SIGN_IN\n                    : proximity_auth::mojom::AuthType::OFFLINE_PASSWORD);\n     user_auth_type_map_[account_id] = initial_auth_type;\n@@ -823,9 +770,9 @@ UserSelectionScreen::UpdateAndReturnUserListForWebUI() {\n                 public_session_recommended_locales_.end()\n             ? nullptr\n             : &public_session_recommended_locales_[account_id];\n-    FillUserDictionary(*it, is_owner, is_signin_to_add, initial_auth_type,\n+    FillUserDictionary(user, is_owner, is_signin_to_add, initial_auth_type,\n                        public_session_recommended_locales, user_dict.get());\n-    user_dict->SetBoolean(kKeyCanRemove, CanRemoveUser(*it));\n+    user_dict->SetBoolean(kKeyCanRemove, CanRemoveUser(user));\n     users_list->Append(std::move(user_dict));\n   }\n \n@@ -842,39 +789,75 @@ UserSelectionScreen::UpdateAndReturnUserListForMojo() {\n \n   user_auth_type_map_.clear();\n \n-  for (user_manager::UserList::const_iterator it = users_to_send_.begin();\n-       it != users_to_send_.end(); ++it) {\n-    const AccountId& account_id = (*it)->GetAccountId();\n+  for (const user_manager::User* user : users_to_send_) {\n+    const AccountId& account_id = user->GetAccountId();\n     bool is_owner = owner == account_id;\n     const bool is_public_account =\n-        ((*it)->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT);\n+        user->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT;\n     const proximity_auth::mojom::AuthType initial_auth_type =\n         is_public_account\n             ? proximity_auth::mojom::AuthType::EXPAND_THEN_USER_CLICK\n-            : (ShouldForceOnlineSignIn(*it)\n+            : (ShouldForceOnlineSignIn(user)\n                    ? proximity_auth::mojom::AuthType::ONLINE_SIGN_IN\n                    : proximity_auth::mojom::AuthType::OFFLINE_PASSWORD);\n     user_auth_type_map_[account_id] = initial_auth_type;\n \n-    ash::mojom::LoginUserInfoPtr login_user_info =\n-        ash::mojom::LoginUserInfo::New();\n-    const std::vector<std::string>* public_session_recommended_locales =\n-        public_session_recommended_locales_.find(account_id) ==\n-                public_session_recommended_locales_.end()\n-            ? nullptr\n-            : &public_session_recommended_locales_[account_id];\n-    FillUserMojoStruct(*it, is_owner, is_signin_to_add, initial_auth_type,\n-                       public_session_recommended_locales,\n-                       login_user_info.get());\n-    login_user_info->can_remove = CanRemoveUser(*it);\n+    ash::mojom::LoginUserInfoPtr user_info = ash::mojom::LoginUserInfo::New();\n+    user_info->basic_user_info = ash::mojom::UserInfo::New();\n+    user_info->basic_user_info->type = user->GetType();\n+    user_info->basic_user_info->account_id = user->GetAccountId();\n+    user_info->basic_user_info->display_name =\n+        base::UTF16ToUTF8(user->GetDisplayName());\n+    user_info->basic_user_info->display_email = user->display_email();\n+    user_info->basic_user_info->avatar = BuildMojoUserAvatarForUser(user);\n+    user_info->auth_type = initial_auth_type;\n+    user_info->is_signed_in = user->is_logged_in();\n+    user_info->is_device_owner = is_owner;\n+    user_info->can_remove = CanRemoveUser(user);\n+    user_info->allow_fingerprint_unlock = AllowFingerprintForUser(user);\n+\n+    // Fill multi-profile data.\n+    if (!is_signin_to_add) {\n+      user_info->is_multiprofile_allowed = true;\n+    } else {\n+      GetMultiProfilePolicy(user, &user_info->is_multiprofile_allowed,\n+                            &user_info->multiprofile_policy);\n+    }\n+\n+    // Fill public session data.\n+    if (user->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT) {\n+      user_info->public_account_info = ash::mojom::PublicAccountInfo::New();\n+      std::string domain;\n+      if (GetEnterpriseDomain(&domain))\n+        user_info->public_account_info->enterprise_domain = domain;\n+\n+      const std::vector<std::string>* public_session_recommended_locales =\n+          public_session_recommended_locales_.find(account_id) ==\n+                  public_session_recommended_locales_.end()\n+              ? nullptr\n+              : &public_session_recommended_locales_[account_id];\n+      std::string selected_locale;\n+      bool has_multiple_locales;\n+      std::unique_ptr<base::ListValue> available_locales =\n+          GetPublicSessionLocales(public_session_recommended_locales,\n+                                  &selected_locale, &has_multiple_locales);\n+      DCHECK(available_locales);\n+      user_info->public_account_info->available_locales =\n+          lock_screen_utils::FromListValueToLocaleItem(\n+              std::move(available_locales));\n+      user_info->public_account_info->default_locale = selected_locale;\n+      user_info->public_account_info->show_advanced_view = has_multiple_locales;\n+    }\n+\n+    user_info->can_remove = CanRemoveUser(user);\n \n     // Send a request to get keyboard layouts for default locale.\n     if (is_public_account && LoginScreenClient::HasInstance()) {\n       LoginScreenClient::Get()->RequestPublicSessionKeyboardLayouts(\n-          account_id, login_user_info->public_account_info->default_locale);\n+          account_id, user_info->public_account_info->default_locale);\n     }\n \n-    user_info_list.push_back(std::move(login_user_info));\n+    user_info_list.push_back(std::move(user_info));\n   }\n \n   return user_info_list;""}<_**next**_>{""sha"": ""44685abf8f9e4354d58b8ead92f333ce5ab616ae"", ""filename"": ""chrome/browser/chromeos/login/screens/user_selection_screen.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 12, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/c66b1fc49870c514b1c1e8b53498153176d7ec2b/chrome/browser/chromeos/login/screens/user_selection_screen.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c66b1fc49870c514b1c1e8b53498153176d7ec2b/chrome/browser/chromeos/login/screens/user_selection_screen.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chromeos/login/screens/user_selection_screen.h?ref=c66b1fc49870c514b1c1e8b53498153176d7ec2b"", ""patch"": ""@@ -98,15 +98,15 @@ class UserSelectionScreen\n \n   // Fills |user_dict| with information about |user|.\n   static void FillUserDictionary(\n-      user_manager::User* user,\n+      const user_manager::User* user,\n       bool is_owner,\n       bool is_signin_to_add,\n       proximity_auth::mojom::AuthType auth_type,\n       const std::vector<std::string>* public_session_recommended_locales,\n       base::DictionaryValue* user_dict);\n \n   // Fills |user_dict| with |user| multi-profile related preferences.\n-  static void FillMultiProfileUserPrefs(user_manager::User* user,\n+  static void FillMultiProfileUserPrefs(const user_manager::User* user,\n                                         base::DictionaryValue* user_dict,\n                                         bool is_signin_to_add);\n \n@@ -118,15 +118,6 @@ class UserSelectionScreen\n   static ash::mojom::UserAvatarPtr BuildMojoUserAvatarForUser(\n       const user_manager::User* user);\n \n-  // Fills |user_info| with information about |user|.\n-  static void FillUserMojoStruct(\n-      const user_manager::User* user,\n-      bool is_owner,\n-      bool is_signin_to_add,\n-      proximity_auth::mojom::AuthType auth_type,\n-      const std::vector<std::string>* public_session_recommended_locales,\n-      ash::mojom::LoginUserInfo* user_info);\n-\n   std::unique_ptr<base::ListValue> UpdateAndReturnUserListForWebUI();\n   std::vector<ash::mojom::LoginUserInfoPtr> UpdateAndReturnUserListForMojo();\n   void SetUsersLoaded(bool loaded);\n@@ -158,7 +149,7 @@ class UserSelectionScreen\n   // Set of Users that are visible.\n   user_manager::UserList users_;\n \n-  // Map of accounnt ids to their current authentication type. If a user is not\n+  // Map of account ids to their current authentication type. If a user is not\n   // contained in the map, it is using the default authentication type.\n   std::map<AccountId, proximity_auth::mojom::AuthType> user_auth_type_map_;\n ""}<_**next**_>{""sha"": ""fc13ca523fbb24ebc96a4996ad1f1f1d775439c6"", ""filename"": ""chrome/browser/chromeos/login/ui/login_display_host_webui.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/c66b1fc49870c514b1c1e8b53498153176d7ec2b/chrome/browser/chromeos/login/ui/login_display_host_webui.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c66b1fc49870c514b1c1e8b53498153176d7ec2b/chrome/browser/chromeos/login/ui/login_display_host_webui.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chromeos/login/ui/login_display_host_webui.cc?ref=c66b1fc49870c514b1c1e8b53498153176d7ec2b"", ""patch"": ""@@ -39,7 +39,6 @@\n #include \""chrome/browser/chromeos/login/login_wizard.h\""\n #include \""chrome/browser/chromeos/login/screens/core_oobe_view.h\""\n #include \""chrome/browser/chromeos/login/screens/gaia_view.h\""\n-#include \""chrome/browser/chromeos/login/signin/token_handle_util.h\""\n #include \""chrome/browser/chromeos/login/startup_utils.h\""\n #include \""chrome/browser/chromeos/login/ui/input_events_blocker.h\""\n #include \""chrome/browser/chromeos/login/ui/login_display_host_mojo.h\""""}","    user_manager::User* user,",1," void UserSelectionScreen::FillMultiProfileUserPrefs(
    const user_manager::User* user,
     base::DictionaryValue* user_dict,
     bool is_signin_to_add) {
   if (!is_signin_to_add) {
    user_dict->SetBoolean(kKeyMultiProfilesAllowed, true);
    return;
  }

  bool is_user_allowed;
  ash::mojom::MultiProfileUserBehavior policy;
  GetMultiProfilePolicy(user, &is_user_allowed, &policy);
  user_dict->SetBoolean(kKeyMultiProfilesAllowed, is_user_allowed);
  user_dict->SetInteger(kKeyMultiProfilesPolicy, static_cast<int>(policy));
}
"," void UserSelectionScreen::FillMultiProfileUserPrefs(
    user_manager::User* user,
     base::DictionaryValue* user_dict,
     bool is_signin_to_add) {
   if (!is_signin_to_add) {
    user_dict->SetBoolean(kKeyMultiProfilesAllowed, true);
    return;
  }

  bool is_user_allowed;
  ash::mojom::MultiProfileUserBehavior policy;
  GetMultiProfilePolicy(user, &is_user_allowed, &policy);
  user_dict->SetBoolean(kKeyMultiProfilesAllowed, is_user_allowed);
  user_dict->SetInteger(kKeyMultiProfilesPolicy, static_cast<int>(policy));
}
",186167.0,C,"    const user_manager::User* user,
","    user_manager::User* user,
",,"@@ -99,7 +99,7 @@ bool GetEnterpriseDomain(std::string* out_domain) {
 // Get locales information of public account user.
 // Returns a list of available locales.
 // |public_session_recommended_locales|: This can be nullptr if we don't have
-// recommanded locales.
+// recommended locales.
 // |out_selected_locale|: Output value of the initially selected locale.
 // |out_multiple_locales|: Output value indicates whether we have multiple
 // recommended locales.
@@ -362,7 +362,7 @@ void UserSelectionScreen::InitEasyUnlock() {
 
 // static
 void UserSelectionScreen::FillUserDictionary(
-    user_manager::User* user,
+    const user_manager::User* user,
     bool is_owner,
     bool is_signin_to_add,
     proximity_auth::mojom::AuthType auth_type,
@@ -397,7 +397,7 @@ void UserSelectionScreen::FillUserDictionary(
 
 // static
 void UserSelectionScreen::FillMultiProfileUserPrefs(
-    user_manager::User* user,
+    const user_manager::User* user,
     base::DictionaryValue* user_dict,
     bool is_signin_to_add) {
   if (!is_signin_to_add) {
@@ -487,56 +487,6 @@ ash::mojom::UserAvatarPtr UserSelectionScreen::BuildMojoUserAvatarForUser(
   return avatar;
 }
 
-// static
-void UserSelectionScreen::FillUserMojoStruct(
-    const user_manager::User* user,
-    bool is_owner,
-    bool is_signin_to_add,
-    proximity_auth::mojom::AuthType auth_type,
-    const std::vector<std::string>* public_session_recommended_locales,
-    ash::mojom::LoginUserInfo* user_info) {
-  user_info->basic_user_info = ash::mojom::UserInfo::New();
-  user_info->basic_user_info->type = user->GetType();
-  user_info->basic_user_info->account_id = user->GetAccountId();
-  user_info->basic_user_info->display_name =
-      base::UTF16ToUTF8(user->GetDisplayName());
-  user_info->basic_user_info->display_email = user->display_email();
-  user_info->basic_user_info->avatar = BuildMojoUserAvatarForUser(user);
-  user_info->auth_type = auth_type;
-  user_info->is_signed_in = user->is_logged_in();
-  user_info->is_device_owner = is_owner;
-  user_info->can_remove = CanRemoveUser(user);
-  user_info->allow_fingerprint_unlock = AllowFingerprintForUser(user);
-
-  // Fill multi-profile data.
-  if (!is_signin_to_add) {
-    user_info->is_multiprofile_allowed = true;
-  } else {
-    GetMultiProfilePolicy(user, &user_info->is_multiprofile_allowed,
-                          &user_info->multiprofile_policy);
-  }
-
-  // Fill public session data.
-  if (user->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT) {
-    user_info->public_account_info = ash::mojom::PublicAccountInfo::New();
-    std::string domain;
-    if (GetEnterpriseDomain(&domain))
-      user_info->public_account_info->enterprise_domain = domain;
-
-    std::string selected_locale;
-    bool has_multiple_locales;
-    std::unique_ptr<base::ListValue> available_locales =
-        GetPublicSessionLocales(public_session_recommended_locales,
-                                &selected_locale, &has_multiple_locales);
-    DCHECK(available_locales);
-    user_info->public_account_info->available_locales =
-        lock_screen_utils::FromListValueToLocaleItem(
-            std::move(available_locales));
-    user_info->public_account_info->default_locale = selected_locale;
-    user_info->public_account_info->show_advanced_view = has_multiple_locales;
-  }
-}
-
 void UserSelectionScreen::SetHandler(LoginDisplayWebUIHandler* handler) {
   handler_ = handler;
 
@@ -561,8 +511,7 @@ void UserSelectionScreen::Init(const user_manager::UserList& users) {
 }
 
 void UserSelectionScreen::OnBeforeUserRemoved(const AccountId& account_id) {
-  for (user_manager::UserList::iterator it = users_.begin(); it != users_.end();
-       ++it) {
+  for (auto it = users_.cbegin(); it != users_.cend(); ++it) {
     if ((*it)->GetAccountId() == account_id) {
       users_.erase(it);
       break;
@@ -607,23 +556,22 @@ const user_manager::UserList UserSelectionScreen::PrepareUserListForSending(
   size_t max_non_owner_users = has_owner ? kMaxUsers - 1 : kMaxUsers;
   size_t non_owner_count = 0;
 
-  for (user_manager::UserList::const_iterator it = users.begin();
-       it != users.end(); ++it) {
-    bool is_owner = ((*it)->GetAccountId() == owner);
+  for (user_manager::User* user : users) {
+    bool is_owner = user->GetAccountId() == owner;
     bool is_public_account =
-        ((*it)->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT);
+        user->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT;
 
     if ((is_public_account && !is_signin_to_add) || is_owner ||
         (!is_public_account && non_owner_count < max_non_owner_users)) {
       if (!is_owner)
         ++non_owner_count;
       if (is_owner && users_to_send.size() > kMaxUsers) {
         // Owner is always in the list.
-        users_to_send.insert(users_to_send.begin() + (kMaxUsers - 1), *it);
+        users_to_send.insert(users_to_send.begin() + (kMaxUsers - 1), user);
         while (users_to_send.size() > kMaxUsers)
           users_to_send.erase(users_to_send.begin() + kMaxUsers);
       } else if (users_to_send.size() < kMaxUsers) {
-        users_to_send.push_back(*it);
+        users_to_send.push_back(user);
       }
     }
   }
@@ -803,16 +751,15 @@ UserSelectionScreen::UpdateAndReturnUserListForWebUI() {
 
   user_auth_type_map_.clear();
 
-  for (user_manager::UserList::const_iterator it = users_to_send_.begin();
-       it != users_to_send_.end(); ++it) {
-    const AccountId& account_id = (*it)->GetAccountId();
+  for (const user_manager::User* user : users_to_send_) {
+    const AccountId& account_id = user->GetAccountId();
     bool is_owner = (account_id == owner);
     const bool is_public_account =
-        ((*it)->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT);
+        user->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT;
     const proximity_auth::mojom::AuthType initial_auth_type =
         is_public_account
             ? proximity_auth::mojom::AuthType::EXPAND_THEN_USER_CLICK
-            : (ShouldForceOnlineSignIn(*it)
+            : (ShouldForceOnlineSignIn(user)
                    ? proximity_auth::mojom::AuthType::ONLINE_SIGN_IN
                    : proximity_auth::mojom::AuthType::OFFLINE_PASSWORD);
     user_auth_type_map_[account_id] = initial_auth_type;
@@ -823,9 +770,9 @@ UserSelectionScreen::UpdateAndReturnUserListForWebUI() {
                 public_session_recommended_locales_.end()
             ? nullptr
             : &public_session_recommended_locales_[account_id];
-    FillUserDictionary(*it, is_owner, is_signin_to_add, initial_auth_type,
+    FillUserDictionary(user, is_owner, is_signin_to_add, initial_auth_type,
                        public_session_recommended_locales, user_dict.get());
-    user_dict->SetBoolean(kKeyCanRemove, CanRemoveUser(*it));
+    user_dict->SetBoolean(kKeyCanRemove, CanRemoveUser(user));
     users_list->Append(std::move(user_dict));
   }
 
@@ -842,39 +789,75 @@ UserSelectionScreen::UpdateAndReturnUserListForMojo() {
 
   user_auth_type_map_.clear();
 
-  for (user_manager::UserList::const_iterator it = users_to_send_.begin();
-       it != users_to_send_.end(); ++it) {
-    const AccountId& account_id = (*it)->GetAccountId();
+  for (const user_manager::User* user : users_to_send_) {
+    const AccountId& account_id = user->GetAccountId();
     bool is_owner = owner == account_id;
     const bool is_public_account =
-        ((*it)->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT);
+        user->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT;
     const proximity_auth::mojom::AuthType initial_auth_type =
         is_public_account
             ? proximity_auth::mojom::AuthType::EXPAND_THEN_USER_CLICK
-            : (ShouldForceOnlineSignIn(*it)
+            : (ShouldForceOnlineSignIn(user)
                    ? proximity_auth::mojom::AuthType::ONLINE_SIGN_IN
                    : proximity_auth::mojom::AuthType::OFFLINE_PASSWORD);
     user_auth_type_map_[account_id] = initial_auth_type;
 
-    ash::mojom::LoginUserInfoPtr login_user_info =
-        ash::mojom::LoginUserInfo::New();
-    const std::vector<std::string>* public_session_recommended_locales =
-        public_session_recommended_locales_.find(account_id) ==
-                public_session_recommended_locales_.end()
-            ? nullptr
-            : &public_session_recommended_locales_[account_id];
-    FillUserMojoStruct(*it, is_owner, is_signin_to_add, initial_auth_type,
-                       public_session_recommended_locales,
-                       login_user_info.get());
-    login_user_info->can_remove = CanRemoveUser(*it);
+    ash::mojom::LoginUserInfoPtr user_info = ash::mojom::LoginUserInfo::New();
+    user_info->basic_user_info = ash::mojom::UserInfo::New();
+    user_info->basic_user_info->type = user->GetType();
+    user_info->basic_user_info->account_id = user->GetAccountId();
+    user_info->basic_user_info->display_name =
+        base::UTF16ToUTF8(user->GetDisplayName());
+    user_info->basic_user_info->display_email = user->display_email();
+    user_info->basic_user_info->avatar = BuildMojoUserAvatarForUser(user);
+    user_info->auth_type = initial_auth_type;
+    user_info->is_signed_in = user->is_logged_in();
+    user_info->is_device_owner = is_owner;
+    user_info->can_remove = CanRemoveUser(user);
+    user_info->allow_fingerprint_unlock = AllowFingerprintForUser(user);
+
+    // Fill multi-profile data.
+    if (!is_signin_to_add) {
+      user_info->is_multiprofile_allowed = true;
+    } else {
+      GetMultiProfilePolicy(user, &user_info->is_multiprofile_allowed,
+                            &user_info->multiprofile_policy);
+    }
+
+    // Fill public session data.
+    if (user->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT) {
+      user_info->public_account_info = ash::mojom::PublicAccountInfo::New();
+      std::string domain;
+      if (GetEnterpriseDomain(&domain))
+        user_info->public_account_info->enterprise_domain = domain;
+
+      const std::vector<std::string>* public_session_recommended_locales =
+          public_session_recommended_locales_.find(account_id) ==
+                  public_session_recommended_locales_.end()
+              ? nullptr
+              : &public_session_recommended_locales_[account_id];
+      std::string selected_locale;
+      bool has_multiple_locales;
+      std::unique_ptr<base::ListValue> available_locales =
+          GetPublicSessionLocales(public_session_recommended_locales,
+                                  &selected_locale, &has_multiple_locales);
+      DCHECK(available_locales);
+      user_info->public_account_info->available_locales =
+          lock_screen_utils::FromListValueToLocaleItem(
+              std::move(available_locales));
+      user_info->public_account_info->default_locale = selected_locale;
+      user_info->public_account_info->show_advanced_view = has_multiple_locales;
+    }
+
+    user_info->can_remove = CanRemoveUser(user);
 
     // Send a request to get keyboard layouts for default locale.
     if (is_public_account && LoginScreenClient::HasInstance()) {
       LoginScreenClient::Get()->RequestPublicSessionKeyboardLayouts(
-          account_id, login_user_info->public_account_info->default_locale);
+          account_id, user_info->public_account_info->default_locale);
     }
 
-    user_info_list.push_back(std::move(login_user_info));
+    user_info_list.push_back(std::move(user_info));
   }
 
   return user_info_list;","void UserSelectionScreen::FillMultiProfileUserPrefs(
    user_manager::User* user,
base::DictionaryValue* user_dict,
bool is_signin_to_add) {
if (!is_signin_to_add) {
user_dict->SetBoolean(kKeyMultiProfilesAllowed, true);
return;
}

bool is_user_allowed;
ash::mojom::MultiProfileUserBehavior policy;
GetMultiProfilePolicy(user, &is_user_allowed, &policy);
user_dict->SetBoolean(kKeyMultiProfilesAllowed, is_user_allowed);
user_dict->SetInteger(kKeyMultiProfilesPolicy, static_cast<int>(policy));
}
",Chrome,c66b1fc49870c514b1c1e8b53498153176d7ec2b,8541637904013cfeca56a4700ba82ee8c463594f,1.0," void UserSelectionScreen::FillMultiProfileUserPrefs(
//flaw_line_below:
    user_manager::User* user,
//fix_flaw_line_below:
//    const user_manager::User* user,
     base::DictionaryValue* user_dict,
     bool is_signin_to_add) {
   if (!is_signin_to_add) {
    user_dict->SetBoolean(kKeyMultiProfilesAllowed, true);
    return;
  }

  bool is_user_allowed;
  ash::mojom::MultiProfileUserBehavior policy;
  GetMultiProfilePolicy(user, &is_user_allowed, &policy);
  user_dict->SetBoolean(kKeyMultiProfilesAllowed, is_user_allowed);
  user_dict->SetInteger(kKeyMultiProfilesPolicy, static_cast<int>(policy));
}
"
36,None,Remote,Not required,Partial,CVE-2012-2888,https://www.cvedetails.com/cve/CVE-2012-2888/,CWE-399,Low,Partial,Partial,,2012-09-26,7.5,Use-after-free vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving SVG text references.,2018-10-30,DoS ,0.0,https://github.com/chromium/chromium/commit/3b0d77670a0613f409110817455d2137576b485a,3b0d77670a0613f409110817455d2137576b485a,"Revert 143656 - Add an IPC channel between the NaCl loader process and the renderer.
BUG=116317
TEST=ppapi, nacl tests, manual testing for experimental IPC proxy.
Review URL: https://chromiumcodereview.appspot.com/10641016

TBR=bbudge@chromium.org
Review URL: https://chromiumcodereview.appspot.com/10625007

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143665 0039d316-1c4b-4281-b951-d872f2087c98",2.0,chrome/renderer/pepper/ppb_nacl_private_impl.cc,"{""sha"": ""1def1feeb05ae8bcdf429026b4f87d7eee2bbdd8"", ""filename"": ""chrome/browser/nacl_host/nacl_process_host.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 20, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/browser/nacl_host/nacl_process_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/browser/nacl_host/nacl_process_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/nacl_host/nacl_process_host.cc?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -145,9 +145,6 @@ NaClProcessHost::NaClProcessHost(const GURL& manifest_url, bool off_the_record)\n       getenv(\""NACL_UNTRUSTED_EXCEPTION_HANDLING\"") != NULL) {\n     enable_exception_handling_ = true;\n   }\n-\n-  enable_ipc_proxy_ = CommandLine::ForCurrentProcess()->HasSwitch(\n-      switches::kEnableNaClIPCProxy);\n }\n \n NaClProcessHost::~NaClProcessHost() {\n@@ -540,8 +537,6 @@ bool NaClProcessHost::OnMessageReceived(const IPC::Message& msg) {\n     IPC_MESSAGE_HANDLER_DELAY_REPLY(NaClProcessMsg_AttachDebugExceptionHandler,\n                                     OnAttachDebugExceptionHandler)\n #endif\n-    IPC_MESSAGE_HANDLER(NaClProcessHostMsg_PpapiChannelCreated,\n-                        OnPpapiChannelCreated)\n     IPC_MESSAGE_UNHANDLED(handled = false)\n   IPC_END_MESSAGE_MAP()\n   return handled;\n@@ -561,8 +556,7 @@ void NaClProcessHost::OnResourcesReady() {\n   }\n }\n \n-bool NaClProcessHost::ReplyToRenderer(\n-    const IPC::ChannelHandle& channel_handle) {\n+bool NaClProcessHost::ReplyToRenderer() {\n   std::vector<nacl::FileDescriptor> handles_for_renderer;\n   for (size_t i = 0; i < internal_->sockets_for_renderer.size(); i++) {\n #if defined(OS_WIN)\n@@ -606,7 +600,7 @@ bool NaClProcessHost::ReplyToRenderer(\n #endif\n \n   ChromeViewHostMsg_LaunchNaCl::WriteReplyParams(\n-      reply_msg_, handles_for_renderer, channel_handle);\n+      reply_msg_, handles_for_renderer);\n   chrome_render_message_filter_->Send(reply_msg_);\n   chrome_render_message_filter_ = NULL;\n   reply_msg_ = NULL;\n@@ -624,7 +618,6 @@ bool NaClProcessHost::StartNaClExecution() {\n   params.enable_exception_handling = enable_exception_handling_;\n   params.enable_debug_stub =\n       CommandLine::ForCurrentProcess()->HasSwitch(switches::kEnableNaClDebug);\n-  params.enable_ipc_proxy = enable_ipc_proxy_;\n \n   base::PlatformFile irt_file = nacl_browser->IrtFile();\n   CHECK_NE(irt_file, base::kInvalidPlatformFileValue);\n@@ -672,17 +665,7 @@ bool NaClProcessHost::StartNaClExecution() {\n }\n \n bool NaClProcessHost::SendStart() {\n-  if (!enable_ipc_proxy_) {\n-    if (!ReplyToRenderer(IPC::ChannelHandle()))\n-      return false;\n-  }\n-  return StartNaClExecution();\n-}\n-\n-void NaClProcessHost::OnPpapiChannelCreated(\n-    const IPC::ChannelHandle& channel_handle) {\n-  DCHECK(enable_ipc_proxy_);\n-  ReplyToRenderer(channel_handle);\n+  return ReplyToRenderer() && StartNaClExecution();\n }\n \n bool NaClProcessHost::StartWithLaunchedProcess() {""}<_**next**_>{""sha"": ""4ab9413ae469b1419383dbd00b86ea91d31c00d5"", ""filename"": ""chrome/browser/nacl_host/nacl_process_host.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 6, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/browser/nacl_host/nacl_process_host.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/browser/nacl_host/nacl_process_host.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/nacl_host/nacl_process_host.h?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -17,7 +17,6 @@\n #include \""chrome/common/nacl_types.h\""\n #include \""content/public/browser/browser_child_process_host_delegate.h\""\n #include \""googleurl/src/gurl.h\""\n-#include \""ipc/ipc_channel_handle.h\""\n \n class ChromeRenderMessageFilter;\n class CommandLine;\n@@ -87,7 +86,7 @@ class NaClProcessHost : public content::BrowserChildProcessHostDelegate {\n \n   // Sends the reply message to the renderer who is waiting for the plugin\n   // to load. Returns true on success.\n-  bool ReplyToRenderer(const IPC::ChannelHandle& channel_handle);\n+  bool ReplyToRenderer();\n \n   // Sends the message to the NaCl process to load the plugin. Returns true\n   // on success.\n@@ -114,8 +113,6 @@ class NaClProcessHost : public content::BrowserChildProcessHostDelegate {\n                                    IPC::Message* reply_msg);\n #endif\n \n-  void OnPpapiChannelCreated(const IPC::ChannelHandle& channel_handle);\n-\n   GURL manifest_url_;\n \n #if defined(OS_WIN)\n@@ -155,8 +152,6 @@ class NaClProcessHost : public content::BrowserChildProcessHostDelegate {\n \n   bool off_the_record_;\n \n-  bool enable_ipc_proxy_;\n-\n   DISALLOW_COPY_AND_ASSIGN(NaClProcessHost);\n };\n ""}<_**next**_>{""sha"": ""7a6f012902b76580de0dc77e463e7292d5f9d907"", ""filename"": ""chrome/common/nacl_messages.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 8, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/common/nacl_messages.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/common/nacl_messages.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/nacl_messages.h?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -7,7 +7,6 @@\n // Multiply-included message file, no traditional include guard.\n #include \""base/process.h\""\n #include \""chrome/common/nacl_types.h\""\n-#include \""ipc/ipc_channel_handle.h\""\n #include \""ipc/ipc_message_macros.h\""\n \n #define IPC_MESSAGE_START NaClMsgStart\n@@ -19,7 +18,6 @@ IPC_STRUCT_TRAITS_BEGIN(nacl::NaClStartParams)\n   IPC_STRUCT_TRAITS_MEMBER(version)\n   IPC_STRUCT_TRAITS_MEMBER(enable_exception_handling)\n   IPC_STRUCT_TRAITS_MEMBER(enable_debug_stub)\n-  IPC_STRUCT_TRAITS_MEMBER(enable_ipc_proxy)\n IPC_STRUCT_TRAITS_END()\n \n //-----------------------------------------------------------------------------\n@@ -74,9 +72,3 @@ IPC_SYNC_MESSAGE_CONTROL1_1(NaClProcessMsg_QueryKnownToValidate,\n // database in the browser.\n IPC_MESSAGE_CONTROL1(NaClProcessMsg_SetKnownToValidate,\n                      std::string /* A validation signature */)\n-\n-// Notify the browser process that the server side of the PPAPI channel was\n-// created successfully.\n-IPC_MESSAGE_CONTROL1(NaClProcessHostMsg_PpapiChannelCreated,\n-                     IPC::ChannelHandle /* channel_handle */)\n-""}<_**next**_>{""sha"": ""86ed0d0fe7c82f44c1685018d001a4b0256b02b6"", ""filename"": ""chrome/common/nacl_types.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/common/nacl_types.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/common/nacl_types.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/nacl_types.h?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -55,7 +55,6 @@ struct NaClStartParams {\n \n   bool enable_exception_handling;\n   bool enable_debug_stub;\n-  bool enable_ipc_proxy;\n };\n \n }  // namespace nacl""}<_**next**_>{""sha"": ""ff023cf748466c8f4dd1fd6d74cc9ccf75da3c10"", ""filename"": ""chrome/common/render_messages.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/common/render_messages.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/common/render_messages.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/render_messages.h?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -26,7 +26,6 @@\n #include \""chrome/common/translate_errors.h\""\n #include \""content/public/common/common_param_traits.h\""\n #include \""content/public/common/webkit_param_traits.h\""\n-#include \""ipc/ipc_channel_handle.h\""\n #include \""ipc/ipc_message_macros.h\""\n #include \""ipc/ipc_platform_file.h\""\n #include \""third_party/skia/include/core/SkBitmap.h\""\n@@ -486,14 +485,12 @@ IPC_MESSAGE_ROUTED3(ChromeViewHostMsg_ForwardMessageToExternalHost,\n \n // A renderer sends this to the browser process when it wants to start\n // a new instance of the Native Client process. The browser will launch\n-// the process and return an IPC channel handle. This handle will only\n-// be valid if the NaCl IPC proxy is enabled.\n-IPC_SYNC_MESSAGE_CONTROL2_2(ChromeViewHostMsg_LaunchNaCl,\n+// the process and return a handle to an IMC channel.\n+IPC_SYNC_MESSAGE_CONTROL2_1(ChromeViewHostMsg_LaunchNaCl,\n                             GURL /* manifest_url */,\n                             int /* socket count */,\n                             std::vector<nacl::FileDescriptor>\n-                                /* imc channel handles */,\n-                            IPC::ChannelHandle /* ipc_channel_handle */)\n+                                /* imc channel handles */)\n \n // Notification that the page has an OpenSearch description document\n // associated with it.""}<_**next**_>{""sha"": ""f76fa0dea06b15d754960c885bf4eaed531dbe13"", ""filename"": ""chrome/nacl/nacl_ipc_adapter.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/nacl/nacl_ipc_adapter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/nacl/nacl_ipc_adapter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/nacl/nacl_ipc_adapter.cc?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -74,7 +74,6 @@ ssize_t NaClDescCustomRecvMsg(void* handle, NaClImcTypedMsgHdr* msg,\n                               int /* flags */) {\n   if (msg->iov_length != 1)\n     return -1;\n-  msg->ndesc_length = 0;  // Messages with descriptors aren't supported yet.\n   return static_cast<ssize_t>(\n       ToAdapter(handle)->BlockingReceive(static_cast<char*>(msg->iov[0].base),\n                                          msg->iov[0].length));\n@@ -282,12 +281,6 @@ NaClDesc* NaClIPCAdapter::MakeNaClDesc() {\n   return MakeNaClDescCustom(this);\n }\n \n-#if defined(OS_POSIX)\n-int NaClIPCAdapter::TakeClientFileDescriptor() {\n-  return io_thread_data_.channel_->TakeClientFileDescriptor();\n-}\n-#endif\n-\n bool NaClIPCAdapter::OnMessageReceived(const IPC::Message& message) {\n   {\n     base::AutoLock lock(lock_);""}<_**next**_>{""sha"": ""12500cdc9a87c5f8dc504d24c9124232ce94e8b1"", ""filename"": ""chrome/nacl/nacl_ipc_adapter.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/nacl/nacl_ipc_adapter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/nacl/nacl_ipc_adapter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/nacl/nacl_ipc_adapter.h?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -77,10 +77,6 @@ class NaClIPCAdapter : public base::RefCountedThreadSafe<NaClIPCAdapter>,\n   // NaClDesc is reference-counted, and a reference is returned.\n   NaClDesc* MakeNaClDesc();\n \n-#if defined(OS_POSIX)\n-  int TakeClientFileDescriptor();\n-#endif\n-\n   // Listener implementation.\n   virtual bool OnMessageReceived(const IPC::Message& message) OVERRIDE;\n   virtual void OnChannelConnected(int32 peer_pid) OVERRIDE;""}<_**next**_>{""sha"": ""a5433dc284dfa4f04ffdd496378a203865be38d5"", ""filename"": ""chrome/nacl/nacl_listener.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 26, ""changes"": 27, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/nacl/nacl_listener.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/nacl/nacl_listener.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/nacl/nacl_listener.cc?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -13,19 +13,13 @@\n #include \""base/message_loop.h\""\n #include \""base/rand_util.h\""\n #include \""chrome/common/nacl_messages.h\""\n-#include \""chrome/nacl/nacl_ipc_adapter.h\""\n #include \""chrome/nacl/nacl_validation_db.h\""\n #include \""chrome/nacl/nacl_validation_query.h\""\n-#include \""ipc/ipc_channel_handle.h\""\n-#include \""ipc/ipc_switches.h\""\n #include \""ipc/ipc_sync_channel.h\""\n #include \""ipc/ipc_sync_message_filter.h\""\n+#include \""ipc/ipc_switches.h\""\n #include \""native_client/src/trusted/service_runtime/sel_main_chrome.h\""\n \n-#if defined(OS_POSIX)\n-#include \""base/file_descriptor_posix.h\""\n-#endif\n-\n #if defined(OS_LINUX)\n #include \""content/public/common/child_process_sandbox_support_linux.h\""\n #endif\n@@ -194,25 +188,6 @@ void NaClListener::OnMsgStart(const nacl::NaClStartParams& params) {\n     return;\n   }\n \n-  if (params.enable_ipc_proxy) {\n-    // Create the server side of the channel and notify the process host so it\n-    // can reply to the renderer, which will connect as client.\n-    IPC::ChannelHandle channel_handle =\n-        IPC::Channel::GenerateVerifiedChannelID(\""nacl\"");\n-\n-    scoped_refptr<NaClIPCAdapter> ipc_adapter(new NaClIPCAdapter(\n-        channel_handle, io_thread_.message_loop_proxy()));\n-    args->initial_ipc_desc = ipc_adapter.get()->MakeNaClDesc();\n-\n-#if defined(OS_POSIX)\n-    channel_handle.socket = base::FileDescriptor(\n-        ipc_adapter.get()->TakeClientFileDescriptor(), true);\n-#endif\n-\n-    if (!Send(new NaClProcessHostMsg_PpapiChannelCreated(channel_handle)))\n-      LOG(ERROR) << \""Failed to send IPC channel handle to renderer.\"";\n-  }\n-\n   std::vector<nacl::FileDescriptor> handles = params.handles;\n \n #if defined(OS_LINUX) || defined(OS_MACOSX)""}<_**next**_>{""sha"": ""b64606594702ea0baf7d5f900d4333fc77c34ceb"", ""filename"": ""chrome/renderer/pepper/ppb_nacl_private_impl.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 179, ""changes"": 184, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/renderer/pepper/ppb_nacl_private_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/renderer/pepper/ppb_nacl_private_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/pepper/ppb_nacl_private_impl.cc?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -9,74 +9,35 @@\n #include \""base/command_line.h\""\n #include \""base/lazy_instance.h\""\n #include \""base/logging.h\""\n-#include \""base/message_loop.h\""\n #include \""base/rand_util.h\""\n-#include \""chrome/common/chrome_switches.h\""\n #include \""chrome/common/render_messages.h\""\n-#include \""content/public/common/content_client.h\""\n #include \""content/public/common/content_switches.h\""\n-#include \""content/public/common/sandbox_init.h\""\n #include \""content/public/renderer/render_thread.h\""\n-#include \""content/public/renderer/render_view.h\""\n #include \""ipc/ipc_sync_message_filter.h\""\n #include \""ppapi/c/private/ppb_nacl_private.h\""\n #include \""ppapi/native_client/src/trusted/plugin/nacl_entry_points.h\""\n-#include \""ppapi/proxy/host_dispatcher.h\""\n-#include \""ppapi/proxy/proxy_channel.h\""\n-#include \""ppapi/shared_impl/ppapi_preferences.h\""\n-#include \""third_party/WebKit/Source/WebKit/chromium/public/WebDocument.h\""\n-#include \""third_party/WebKit/Source/WebKit/chromium/public/WebElement.h\""\n-#include \""third_party/WebKit/Source/WebKit/chromium/public/WebFrame.h\""\n-#include \""third_party/WebKit/Source/WebKit/chromium/public/WebPluginContainer.h\""\n-#include \""third_party/WebKit/Source/WebKit/chromium/public/WebView.h\""\n-#include \""webkit/plugins/ppapi/host_globals.h\""\n-#include \""webkit/plugins/ppapi/plugin_module.h\""\n-#include \""webkit/plugins/ppapi/ppapi_plugin_instance.h\""\n \n-using content::RenderThread;\n-using content::RenderView;\n-using webkit::ppapi::HostGlobals;\n-using webkit::ppapi::PluginInstance;\n-using webkit::ppapi::PluginDelegate;\n-using WebKit::WebView;\n+#if defined(OS_WIN)\n+#include \""content/public/common/sandbox_init.h\""\n+#endif\n \n namespace {\n \n base::LazyInstance<scoped_refptr<IPC::SyncMessageFilter> >\n     g_background_thread_sender = LAZY_INSTANCE_INITIALIZER;\n \n-typedef std::map<PP_Instance, IPC::ChannelHandle> ChannelHandleMap;\n-\n-base::LazyInstance<ChannelHandleMap> g_channel_handle_map =\n-    LAZY_INSTANCE_INITIALIZER;\n-\n // Launch NaCl's sel_ldr process.\n PP_Bool LaunchSelLdr(PP_Instance instance,\n-                     const char* alleged_url,\n-                     int socket_count,\n+                     const char* alleged_url, int socket_count,\n                      void* imc_handles) {\n   std::vector<nacl::FileDescriptor> sockets;\n   IPC::Sender* sender = content::RenderThread::Get();\n   if (sender == NULL)\n     sender = g_background_thread_sender.Pointer()->get();\n \n-  IPC::ChannelHandle channel_handle;\n   if (!sender->Send(new ChromeViewHostMsg_LaunchNaCl(\n-          GURL(alleged_url), socket_count, &sockets,\n-          &channel_handle))) {\n+          GURL(alleged_url), socket_count, &sockets)))\n     return PP_FALSE;\n-  }\n-\n-  // Don't save invalid channel handles.\n-  bool invalid_handle = channel_handle.name.empty();\n-\n-#if defined(OS_POSIX)\n-  if (!invalid_handle)\n-    invalid_handle = (channel_handle.socket.fd == -1);\n-#endif\n-\n-  if (!invalid_handle)\n-    g_channel_handle_map.Get()[instance] = channel_handle;\n \n   CHECK(static_cast<int>(sockets.size()) == socket_count);\n   for (int i = 0; i < socket_count; i++) {\n@@ -87,142 +48,7 @@ PP_Bool LaunchSelLdr(PP_Instance instance,\n   return PP_TRUE;\n }\n \n-class ProxyChannelDelegate\n-    : public ppapi::proxy::ProxyChannel::Delegate {\n- public:\n-  ProxyChannelDelegate();\n-  virtual ~ProxyChannelDelegate();\n-\n-  // ProxyChannel::Delegate implementation.\n-  virtual base::MessageLoopProxy* GetIPCMessageLoop() OVERRIDE;\n-  virtual base::WaitableEvent* GetShutdownEvent() OVERRIDE;\n-  virtual IPC::PlatformFileForTransit ShareHandleWithRemote(\n-      base::PlatformFile handle,\n-      const IPC::SyncChannel& channel,\n-      bool should_close_source) OVERRIDE;\n- private:\n-  // TODO(bbudge) Modify the content public API so we can get\n-  // the renderer process's shutdown event.\n-  base::WaitableEvent shutdown_event_;\n-};\n-\n-ProxyChannelDelegate::ProxyChannelDelegate()\n-    : shutdown_event_(true, false) {\n-}\n-\n-ProxyChannelDelegate::~ProxyChannelDelegate() {\n-}\n-\n-base::MessageLoopProxy* ProxyChannelDelegate::GetIPCMessageLoop() {\n-  return RenderThread::Get()->GetIOMessageLoopProxy().get();\n-}\n-\n-base::WaitableEvent* ProxyChannelDelegate::GetShutdownEvent() {\n-  return &shutdown_event_;\n-}\n-\n-IPC::PlatformFileForTransit ProxyChannelDelegate::ShareHandleWithRemote(\n-    base::PlatformFile handle,\n-    const IPC::SyncChannel& channel,\n-    bool should_close_source) {\n-  return content::BrokerGetFileHandleForProcess(handle, channel.peer_pid(),\n-                                                should_close_source);\n-}\n-\n-// Stubbed out SyncMessageStatusReceiver, required by HostDispatcher.\n-// TODO(bbudge) Use a content::PepperHungPluginFilter instead.\n-class SyncMessageStatusReceiver\n-    : public ppapi::proxy::HostDispatcher::SyncMessageStatusReceiver {\n- public:\n-  SyncMessageStatusReceiver() {}\n-\n-  // SyncMessageStatusReceiver implementation.\n-  virtual void BeginBlockOnSyncMessage() OVERRIDE {}\n-  virtual void EndBlockOnSyncMessage() OVERRIDE {}\n-\n- private:\n-  virtual ~SyncMessageStatusReceiver() {}\n-};\n-\n-class OutOfProcessProxy : public PluginDelegate::OutOfProcessProxy {\n- public:\n-  OutOfProcessProxy() {}\n-  virtual ~OutOfProcessProxy() {}\n-\n-  bool Init(const IPC::ChannelHandle& channel_handle,\n-            PP_Module pp_module,\n-            PP_GetInterface_Func local_get_interface,\n-            const ppapi::Preferences& preferences,\n-            SyncMessageStatusReceiver* status_receiver) {\n-    dispatcher_delegate_.reset(new ProxyChannelDelegate);\n-    dispatcher_.reset(new ppapi::proxy::HostDispatcher(\n-        pp_module, local_get_interface, status_receiver));\n-\n-    if (!dispatcher_->InitHostWithChannel(dispatcher_delegate_.get(),\n-                                          channel_handle,\n-                                          true,  // Client.\n-                                          preferences)) {\n-      dispatcher_.reset();\n-      dispatcher_delegate_.reset();\n-      return false;\n-    }\n-\n-    return true;\n-  }\n-\n-  // OutOfProcessProxy implementation.\n-  virtual const void* GetProxiedInterface(const char* name) OVERRIDE {\n-    return dispatcher_->GetProxiedInterface(name);\n-  }\n-  virtual void AddInstance(PP_Instance instance) OVERRIDE {\n-    ppapi::proxy::HostDispatcher::SetForInstance(instance, dispatcher_.get());\n-  }\n-  virtual void RemoveInstance(PP_Instance instance) OVERRIDE {\n-    ppapi::proxy::HostDispatcher::RemoveForInstance(instance);\n-  }\n-\n- private:\n-  scoped_ptr<ppapi::proxy::HostDispatcher> dispatcher_;\n-  scoped_ptr<ppapi::proxy::ProxyChannel::Delegate> dispatcher_delegate_;\n-};\n-\n PP_Bool StartPpapiProxy(PP_Instance instance) {\n-  if (CommandLine::ForCurrentProcess()->HasSwitch(\n-          switches::kEnableNaClIPCProxy)) {\n-    ChannelHandleMap& map = g_channel_handle_map.Get();\n-    ChannelHandleMap::iterator it = map.find(instance);\n-    if (it == map.end())\n-      return PP_FALSE;\n-    IPC::ChannelHandle channel_handle = it->second;\n-    map.erase(it);\n-\n-    webkit::ppapi::PluginInstance* plugin_instance =\n-        content::GetHostGlobals()->GetInstance(instance);\n-    if (!plugin_instance)\n-      return PP_FALSE;\n-\n-    WebView* web_view =\n-        plugin_instance->container()->element().document().frame()->view();\n-    RenderView* render_view = content::RenderView::FromWebView(web_view);\n-\n-    webkit::ppapi::PluginModule* plugin_module = plugin_instance->module();\n-\n-    scoped_refptr<SyncMessageStatusReceiver>\n-        status_receiver(new SyncMessageStatusReceiver());\n-    scoped_ptr<OutOfProcessProxy> out_of_process_proxy(new OutOfProcessProxy);\n-    if (out_of_process_proxy->Init(\n-            channel_handle,\n-            plugin_module->pp_module(),\n-            webkit::ppapi::PluginModule::GetLocalGetInterfaceFunc(),\n-            ppapi::Preferences(render_view->GetWebkitPreferences()),\n-            status_receiver.get())) {\n-      plugin_module->InitAsProxiedNaCl(\n-          out_of_process_proxy.PassAs<PluginDelegate::OutOfProcessProxy>(),\n-          instance);\n-      return PP_TRUE;\n-    }\n-  }\n-\n   return PP_FALSE;\n }\n ""}<_**next**_>{""sha"": ""37233944fac68aa18af52c66ca6a901cff9bb7a0"", ""filename"": ""ppapi/native_client/src/trusted/plugin/nacl_entry_points.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/ppapi/native_client/src/trusted/plugin/nacl_entry_points.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/ppapi/native_client/src/trusted/plugin/nacl_entry_points.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ppapi/native_client/src/trusted/plugin/nacl_entry_points.h?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -21,7 +21,10 @@ typedef bool (*LaunchNaClProcessFunc)(PP_Instance instance,\n                                       int socket_count,\n                                       nacl::Handle* result_sockets);\n \n+typedef bool (*StartPpapiProxyFunc)(PP_Instance instance);\n+\n \n extern LaunchNaClProcessFunc launch_nacl_process;\n+extern StartPpapiProxyFunc start_ppapi_proxy;\n \n #endif  // NATIVE_CLIENT_SRC_TRUSTED_PLUGIN_NACL_ENTRY_POINTS_H_""}<_**next**_>{""sha"": ""891df69100b5741bc66c53b161d217ef3237493e"", ""filename"": ""ppapi/native_client/src/trusted/plugin/plugin.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 30, ""changes"": 32, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/ppapi/native_client/src/trusted/plugin/plugin.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/ppapi/native_client/src/trusted/plugin/plugin.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ppapi/native_client/src/trusted/plugin/plugin.cc?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -34,7 +34,6 @@\n #include \""native_client/src/trusted/desc/nacl_desc_wrapper.h\""\n #include \""native_client/src/trusted/nonnacl_util/sel_ldr_launcher.h\""\n #include \""native_client/src/trusted/plugin/json_manifest.h\""\n-#include \""native_client/src/trusted/plugin/nacl_entry_points.h\""\n #include \""native_client/src/trusted/plugin/nacl_subprocess.h\""\n #include \""native_client/src/trusted/plugin/nexe_arch.h\""\n #include \""native_client/src/trusted/plugin/plugin_error.h\""\n@@ -55,7 +54,6 @@\n #include \""ppapi/c/ppp_input_event.h\""\n #include \""ppapi/c/ppp_instance.h\""\n #include \""ppapi/c/ppp_mouse_lock.h\""\n-#include \""ppapi/c/private/ppb_nacl_private.h\""\n #include \""ppapi/c/private/ppb_uma_private.h\""\n #include \""ppapi/cpp/dev/find_dev.h\""\n #include \""ppapi/cpp/dev/printing_dev.h\""\n@@ -122,13 +120,6 @@ const int64_t kSizeKBMin = 1;\n const int64_t kSizeKBMax = 512*1024;     // very large .nexe\n const uint32_t kSizeKBBuckets = 100;\n \n-const PPB_NaCl_Private* GetNaclInterface() {\n-  pp::Module *module = pp::Module::Get();\n-  CHECK(module);\n-  return static_cast<const PPB_NaCl_Private*>(\n-      module->GetBrowserInterface(PPB_NACL_PRIVATE_INTERFACE));\n-}\n-\n const PPB_UMA_Private* GetUMAInterface() {\n   pp::Module *module = pp::Module::Get();\n   CHECK(module);\n@@ -612,25 +603,12 @@ bool Plugin::LoadNaClModuleCommon(nacl::DescWrapper* wrapper,\n   }\n \n   bool service_runtime_started =\n-      new_service_runtime->Start(wrapper,\n-                                 error_info,\n-                                 manifest_base_url());\n+      new_service_runtime->Start(wrapper, error_info, manifest_base_url());\n   PLUGIN_PRINTF((\""Plugin::LoadNaClModuleCommon (service_runtime_started=%d)\\n\"",\n                  service_runtime_started));\n   if (!service_runtime_started) {\n     return false;\n   }\n-\n-  // Try to start the Chrome IPC-based proxy.\n-  const PPB_NaCl_Private* ppb_nacl = GetNaclInterface();\n-  if (ppb_nacl->StartPpapiProxy(pp_instance())) {\n-    using_ipc_proxy_ = true;\n-    // We need to explicitly schedule this here. It is normally called in\n-    // response to starting the SRPC proxy.\n-    CHECK(init_done_cb.pp_completion_callback().func != NULL);\n-    PLUGIN_PRINTF((\""Plugin::LoadNaClModuleCommon, started ipc proxy.\\n\""));\n-    pp::Module::Get()->core()->CallOnMainThread(0, init_done_cb, PP_OK);\n-  }\n   return true;\n }\n \n@@ -653,11 +631,6 @@ bool Plugin::LoadNaClModule(nacl::DescWrapper* wrapper,\n }\n \n bool Plugin::LoadNaClModuleContinuationIntern(ErrorInfo* error_info) {\n-  // If we are using the IPC proxy, StartSrpcServices and StartJSObjectProxy\n-  // don't makes sense. Return 'true' so that the plugin continues loading.\n-  if (using_ipc_proxy_)\n-    return true;\n-\n   if (!main_subprocess_.StartSrpcServices()) {\n     error_info->SetReport(ERROR_SRPC_CONNECTION_FAIL,\n                           \""SRPC connection failure for \"" +\n@@ -889,8 +862,7 @@ Plugin::Plugin(PP_Instance pp_instance)\n       init_time_(0),\n       ready_time_(0),\n       nexe_size_(0),\n-      time_of_last_progress_event_(0),\n-      using_ipc_proxy_(false) {\n+      time_of_last_progress_event_(0) {\n   PLUGIN_PRINTF((\""Plugin::Plugin (this=%p, pp_instance=%\""\n                  NACL_PRId32\"")\\n\"", static_cast<void*>(this), pp_instance));\n   callback_factory_.Initialize(this);""}<_**next**_>{""sha"": ""cd79517192aeef11df486a87ef294240105fffc9"", ""filename"": ""ppapi/native_client/src/trusted/plugin/plugin.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/ppapi/native_client/src/trusted/plugin/plugin.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/ppapi/native_client/src/trusted/plugin/plugin.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ppapi/native_client/src/trusted/plugin/plugin.h?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -517,9 +517,6 @@ class Plugin : public pp::InstancePrivate {\n   const FileDownloader* FindFileDownloader(PP_Resource url_loader) const;\n \n   int64_t time_of_last_progress_event_;\n-\n-  // Whether we are using IPC-based PPAPI proxy.\n-  bool using_ipc_proxy_;\n };\n \n }  // namespace plugin""}<_**next**_>{""sha"": ""a16f79aa0b470f3794100946649b62c4c6900c51"", ""filename"": ""webkit/plugins/ppapi/plugin_module.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 13, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/webkit/plugins/ppapi/plugin_module.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/webkit/plugins/ppapi/plugin_module.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/plugins/ppapi/plugin_module.cc?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -419,8 +419,7 @@ PluginModule::PluginModule(const std::string& name,\n       library_(NULL),\n       name_(name),\n       path_(path),\n-      reserve_instance_id_(NULL),\n-      nacl_ipc_proxy_(false) {\n+      reserve_instance_id_(NULL) {\n   // Ensure the globals object is created.\n   if (!host_globals)\n     host_globals = new HostGlobals;\n@@ -497,13 +496,9 @@ void PluginModule::InitAsProxied(\n }\n \n void PluginModule::InitAsProxiedNaCl(\n-    scoped_ptr<PluginDelegate::OutOfProcessProxy> out_of_process_proxy,\n+    PluginDelegate::OutOfProcessProxy* out_of_process_proxy,\n     PP_Instance instance) {\n-  // TODO(bbudge) We need to switch the mode of the PluginModule on a\n-  // per-instance basis. Fix this so out_of_process_proxy and other\n-  // state is stored in a map, indexed by instance.\n-  nacl_ipc_proxy_ = true;\n-  InitAsProxied(out_of_process_proxy.release());\n+  InitAsProxied(out_of_process_proxy);\n   // InitAsProxied (for the trusted/out-of-process case) initializes only the\n   // module, and one or more instances are added later. In this case, the\n   // PluginInstance was already created as in-process, so we missed the proxy\n@@ -565,11 +560,6 @@ void PluginModule::InstanceDeleted(PluginInstance* instance) {\n   if (out_of_process_proxy_.get())\n     out_of_process_proxy_->RemoveInstance(instance->pp_instance());\n   instances_.erase(instance);\n-\n-  if (nacl_ipc_proxy_) {\n-    out_of_process_proxy_.reset();\n-    reserve_instance_id_ = NULL;\n-  }\n }\n \n scoped_refptr< ::ppapi::CallbackTracker> PluginModule::GetCallbackTracker() {""}<_**next**_>{""sha"": ""d9b016234d991032f67d6d0eaaf42c99e95cc80f"", ""filename"": ""webkit/plugins/ppapi/plugin_module.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/webkit/plugins/ppapi/plugin_module.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/webkit/plugins/ppapi/plugin_module.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/plugins/ppapi/plugin_module.h?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -90,7 +90,7 @@ class WEBKIT_PLUGINS_EXPORT PluginModule :\n   // Initializes this module for the given NaCl proxy. This takes\n   // ownership of the given pointer, even in the failure case.\n   void InitAsProxiedNaCl(\n-      scoped_ptr<PluginDelegate::OutOfProcessProxy> out_of_process_proxy,\n+      PluginDelegate::OutOfProcessProxy* out_of_process_proxy,\n       PP_Instance instance);\n \n   static const PPB_Core* GetCore();\n@@ -203,8 +203,6 @@ class WEBKIT_PLUGINS_EXPORT PluginModule :\n \n   PP_Bool (*reserve_instance_id_)(PP_Module, PP_Instance);\n \n-  bool nacl_ipc_proxy_;\n-\n   DISALLOW_COPY_AND_ASSIGN(PluginModule);\n };\n ""}",  return RenderThread::Get()->GetIOMessageLoopProxy().get();/~/},"1,2","base::MessageLoopProxy* ProxyChannelDelegate::GetIPCMessageLoop() {
","base::MessageLoopProxy* ProxyChannelDelegate::GetIPCMessageLoop() {
  return RenderThread::Get()->GetIOMessageLoopProxy().get();
}
",184307.0,C,,"  return RenderThread::Get()->GetIOMessageLoopProxy().get();
}
",,"@@ -9,74 +9,35 @@
 #include ""base/command_line.h""
 #include ""base/lazy_instance.h""
 #include ""base/logging.h""
-#include ""base/message_loop.h""
 #include ""base/rand_util.h""
-#include ""chrome/common/chrome_switches.h""
 #include ""chrome/common/render_messages.h""
-#include ""content/public/common/content_client.h""
 #include ""content/public/common/content_switches.h""
-#include ""content/public/common/sandbox_init.h""
 #include ""content/public/renderer/render_thread.h""
-#include ""content/public/renderer/render_view.h""
 #include ""ipc/ipc_sync_message_filter.h""
 #include ""ppapi/c/private/ppb_nacl_private.h""
 #include ""ppapi/native_client/src/trusted/plugin/nacl_entry_points.h""
-#include ""ppapi/proxy/host_dispatcher.h""
-#include ""ppapi/proxy/proxy_channel.h""
-#include ""ppapi/shared_impl/ppapi_preferences.h""
-#include ""third_party/WebKit/Source/WebKit/chromium/public/WebDocument.h""
-#include ""third_party/WebKit/Source/WebKit/chromium/public/WebElement.h""
-#include ""third_party/WebKit/Source/WebKit/chromium/public/WebFrame.h""
-#include ""third_party/WebKit/Source/WebKit/chromium/public/WebPluginContainer.h""
-#include ""third_party/WebKit/Source/WebKit/chromium/public/WebView.h""
-#include ""webkit/plugins/ppapi/host_globals.h""
-#include ""webkit/plugins/ppapi/plugin_module.h""
-#include ""webkit/plugins/ppapi/ppapi_plugin_instance.h""
 
-using content::RenderThread;
-using content::RenderView;
-using webkit::ppapi::HostGlobals;
-using webkit::ppapi::PluginInstance;
-using webkit::ppapi::PluginDelegate;
-using WebKit::WebView;
+#if defined(OS_WIN)
+#include ""content/public/common/sandbox_init.h""
+#endif
 
 namespace {
 
 base::LazyInstance<scoped_refptr<IPC::SyncMessageFilter> >
     g_background_thread_sender = LAZY_INSTANCE_INITIALIZER;
 
-typedef std::map<PP_Instance, IPC::ChannelHandle> ChannelHandleMap;
-
-base::LazyInstance<ChannelHandleMap> g_channel_handle_map =
-    LAZY_INSTANCE_INITIALIZER;
-
 // Launch NaCl's sel_ldr process.
 PP_Bool LaunchSelLdr(PP_Instance instance,
-                     const char* alleged_url,
-                     int socket_count,
+                     const char* alleged_url, int socket_count,
                      void* imc_handles) {
   std::vector<nacl::FileDescriptor> sockets;
   IPC::Sender* sender = content::RenderThread::Get();
   if (sender == NULL)
     sender = g_background_thread_sender.Pointer()->get();
 
-  IPC::ChannelHandle channel_handle;
   if (!sender->Send(new ChromeViewHostMsg_LaunchNaCl(
-          GURL(alleged_url), socket_count, &sockets,
-          &channel_handle))) {
+          GURL(alleged_url), socket_count, &sockets)))
     return PP_FALSE;
-  }
-
-  // Don't save invalid channel handles.
-  bool invalid_handle = channel_handle.name.empty();
-
-#if defined(OS_POSIX)
-  if (!invalid_handle)
-    invalid_handle = (channel_handle.socket.fd == -1);
-#endif
-
-  if (!invalid_handle)
-    g_channel_handle_map.Get()[instance] = channel_handle;
 
   CHECK(static_cast<int>(sockets.size()) == socket_count);
   for (int i = 0; i < socket_count; i++) {
@@ -87,142 +48,7 @@ PP_Bool LaunchSelLdr(PP_Instance instance,
   return PP_TRUE;
 }
 
-class ProxyChannelDelegate
-    : public ppapi::proxy::ProxyChannel::Delegate {
- public:
-  ProxyChannelDelegate();
-  virtual ~ProxyChannelDelegate();
-
-  // ProxyChannel::Delegate implementation.
-  virtual base::MessageLoopProxy* GetIPCMessageLoop() OVERRIDE;
-  virtual base::WaitableEvent* GetShutdownEvent() OVERRIDE;
-  virtual IPC::PlatformFileForTransit ShareHandleWithRemote(
-      base::PlatformFile handle,
-      const IPC::SyncChannel& channel,
-      bool should_close_source) OVERRIDE;
- private:
-  // TODO(bbudge) Modify the content public API so we can get
-  // the renderer process's shutdown event.
-  base::WaitableEvent shutdown_event_;
-};
-
-ProxyChannelDelegate::ProxyChannelDelegate()
-    : shutdown_event_(true, false) {
-}
-
-ProxyChannelDelegate::~ProxyChannelDelegate() {
-}
-
-base::MessageLoopProxy* ProxyChannelDelegate::GetIPCMessageLoop() {
-  return RenderThread::Get()->GetIOMessageLoopProxy().get();
-}
-
-base::WaitableEvent* ProxyChannelDelegate::GetShutdownEvent() {
-  return &shutdown_event_;
-}
-
-IPC::PlatformFileForTransit ProxyChannelDelegate::ShareHandleWithRemote(
-    base::PlatformFile handle,
-    const IPC::SyncChannel& channel,
-    bool should_close_source) {
-  return content::BrokerGetFileHandleForProcess(handle, channel.peer_pid(),
-                                                should_close_source);
-}
-
-// Stubbed out SyncMessageStatusReceiver, required by HostDispatcher.
-// TODO(bbudge) Use a content::PepperHungPluginFilter instead.
-class SyncMessageStatusReceiver
-    : public ppapi::proxy::HostDispatcher::SyncMessageStatusReceiver {
- public:
-  SyncMessageStatusReceiver() {}
-
-  // SyncMessageStatusReceiver implementation.
-  virtual void BeginBlockOnSyncMessage() OVERRIDE {}
-  virtual void EndBlockOnSyncMessage() OVERRIDE {}
-
- private:
-  virtual ~SyncMessageStatusReceiver() {}
-};
-
-class OutOfProcessProxy : public PluginDelegate::OutOfProcessProxy {
- public:
-  OutOfProcessProxy() {}
-  virtual ~OutOfProcessProxy() {}
-
-  bool Init(const IPC::ChannelHandle& channel_handle,
-            PP_Module pp_module,
-            PP_GetInterface_Func local_get_interface,
-            const ppapi::Preferences& preferences,
-            SyncMessageStatusReceiver* status_receiver) {
-    dispatcher_delegate_.reset(new ProxyChannelDelegate);
-    dispatcher_.reset(new ppapi::proxy::HostDispatcher(
-        pp_module, local_get_interface, status_receiver));
-
-    if (!dispatcher_->InitHostWithChannel(dispatcher_delegate_.get(),
-                                          channel_handle,
-                                          true,  // Client.
-                                          preferences)) {
-      dispatcher_.reset();
-      dispatcher_delegate_.reset();
-      return false;
-    }
-
-    return true;
-  }
-
-  // OutOfProcessProxy implementation.
-  virtual const void* GetProxiedInterface(const char* name) OVERRIDE {
-    return dispatcher_->GetProxiedInterface(name);
-  }
-  virtual void AddInstance(PP_Instance instance) OVERRIDE {
-    ppapi::proxy::HostDispatcher::SetForInstance(instance, dispatcher_.get());
-  }
-  virtual void RemoveInstance(PP_Instance instance) OVERRIDE {
-    ppapi::proxy::HostDispatcher::RemoveForInstance(instance);
-  }
-
- private:
-  scoped_ptr<ppapi::proxy::HostDispatcher> dispatcher_;
-  scoped_ptr<ppapi::proxy::ProxyChannel::Delegate> dispatcher_delegate_;
-};
-
 PP_Bool StartPpapiProxy(PP_Instance instance) {
-  if (CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kEnableNaClIPCProxy)) {
-    ChannelHandleMap& map = g_channel_handle_map.Get();
-    ChannelHandleMap::iterator it = map.find(instance);
-    if (it == map.end())
-      return PP_FALSE;
-    IPC::ChannelHandle channel_handle = it->second;
-    map.erase(it);
-
-    webkit::ppapi::PluginInstance* plugin_instance =
-        content::GetHostGlobals()->GetInstance(instance);
-    if (!plugin_instance)
-      return PP_FALSE;
-
-    WebView* web_view =
-        plugin_instance->container()->element().document().frame()->view();
-    RenderView* render_view = content::RenderView::FromWebView(web_view);
-
-    webkit::ppapi::PluginModule* plugin_module = plugin_instance->module();
-
-    scoped_refptr<SyncMessageStatusReceiver>
-        status_receiver(new SyncMessageStatusReceiver());
-    scoped_ptr<OutOfProcessProxy> out_of_process_proxy(new OutOfProcessProxy);
-    if (out_of_process_proxy->Init(
-            channel_handle,
-            plugin_module->pp_module(),
-            webkit::ppapi::PluginModule::GetLocalGetInterfaceFunc(),
-            ppapi::Preferences(render_view->GetWebkitPreferences()),
-            status_receiver.get())) {
-      plugin_module->InitAsProxiedNaCl(
-          out_of_process_proxy.PassAs<PluginDelegate::OutOfProcessProxy>(),
-          instance);
-      return PP_TRUE;
-    }
-  }
-
   return PP_FALSE;
 }
 ","base::MessageLoopProxy* ProxyChannelDelegate::GetIPCMessageLoop() {
  return RenderThread::Get()->GetIOMessageLoopProxy().get();
}
",Chrome,3b0d77670a0613f409110817455d2137576b485a,4d4ee4c3db819fb3f46381e99608a156458e3ecb,1.0,"base::MessageLoopProxy* ProxyChannelDelegate::GetIPCMessageLoop() {
//flaw_line_below:
  return RenderThread::Get()->GetIOMessageLoopProxy().get();
//flaw_line_below:
}
"
38,None,Remote,Not required,Partial,CVE-2016-3839,https://www.cvedetails.com/cve/CVE-2016-3839/,CWE-284,Medium,None,None,,2016-08-05,4.3,"Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210.",2016-11-28,DoS ,1.0,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,472271b153c5dc53c28beac55480a8d8434b2d5c,"DO NOT MERGE Fix potential DoS caused by delivering signal to BT process

Bug: 28885210
Change-Id: I63866d894bfca47464d6e42e3fb0357c4f94d360

 Conflicts:
	btif/co/bta_hh_co.c
	btif/src/btif_core.c
Merge conflict resolution of ag/1161415 (referencing ag/1164670)
- Directly into mnc-mr2-release
",1.0,osi/test/atomic_test.cpp,"{""filename"": ""audio_a2dp_hw/audio_a2dp_hw.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/audio_a2dp_hw/audio_a2dp_hw.c"", ""patch"": ""@@ -244,7 +244,7 @@\n\n \n     ts_log(\""skt_read recv\"", len, NULL);\n \n-    if ((read = recv(fd, p, len, MSG_NOSIGNAL)) == -1)\n+    if ((read = TEMP_FAILURE_RETRY(recv(fd, p, len, MSG_NOSIGNAL))) == -1)\n     {\n         ERROR(\""write failed with errno=%d\\n\"", errno);\n         return -1;\n@@ -266,12 +266,12 @@\n\n     /* poll for 500 ms */\n \n     /* send time out */\n-    if (poll(&pfd, 1, 500) == 0)\n+    if (TEMP_FAILURE_RETRY(poll(&pfd, 1, 500)) == 0)\n         return 0;\n \n     ts_log(\""skt_write\"", len, NULL);\n \n-    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)\n+    if ((sent = TEMP_FAILURE_RETRY(send(fd, p, len, MSG_NOSIGNAL))) == -1)\n     {\n         ERROR(\""write failed with errno=%d\\n\"", errno);\n         return -1;\n@@ -302,14 +302,14 @@\n\n \n static int a2dp_ctrl_receive(struct a2dp_stream_common *common, void* buffer, int length)\n {\n-    int ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL);\n+    int ret = TEMP_FAILURE_RETRY(recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL));\n     if (ret < 0)\n     {\n         ERROR(\""ack failed (%s)\"", strerror(errno));\n         if (errno == EINTR)\n         {\n             /* retry again */\n-            ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL);\n+            ret = TEMP_FAILURE_RETRY(recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL));\n             if (ret < 0)\n             {\n                ERROR(\""ack failed (%s)\"", strerror(errno));\n@@ -336,7 +336,7 @@\n\n     DEBUG(\""A2DP COMMAND %s\"", dump_a2dp_ctrl_event(cmd));\n \n     /* send command */\n-    if (send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL) == -1)\n+    if (TEMP_FAILURE_RETRY(send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL)) == -1)\n     {\n         ERROR(\""cmd failed (%s)\"", strerror(errno));\n         skt_disconnect(common->ctrl_fd);\n@@ -409,13 +409,13 @@\n\n                 break;\n \n             ERROR(\""error : a2dp not ready, wait 250 ms and retry\"");\n-            usleep(250000);\n+            TEMP_FAILURE_RETRY(usleep(250000));\n             skt_disconnect(common->ctrl_fd);\n             common->ctrl_fd = AUDIO_SKT_DISCONNECTED;\n         }\n \n         /* ctrl channel not ready, wait a bit */\n-        usleep(250000);\n+        TEMP_FAILURE_RETRY(usleep(250000));\n     }\n }\n \n@@ -578,7 +578,7 @@\n\n \n             DEBUG(\""emulate a2dp write delay (%d us)\"", us_delay);\n \n-            usleep(us_delay);\n+            TEMP_FAILURE_RETRY(usleep(us_delay));\n             pthread_mutex_unlock(&out->common.lock);\n             return -1;\n         }\n@@ -985,7 +985,7 @@\n\n \n             DEBUG(\""emulate a2dp read delay (%d us)\"", us_delay);\n \n-            usleep(us_delay);\n+            TEMP_FAILURE_RETRY(usleep(us_delay));\n             pthread_mutex_unlock(&in->common.lock);\n             return -1;\n         }\n@@ -1114,7 +1114,7 @@\n\n     DEBUG(\""success\"");\n     /* Delay to ensure Headset is in proper state when START is initiated\n        from DUT immediately after the connection due to ongoing music playback. */\n-    usleep(250000);\n+    TEMP_FAILURE_RETRY(usleep(250000));\n     return 0;\n \n err_open:\n""}<_**next**_>{""filename"": ""btif/co/bta_hh_co.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/co/bta_hh_co.c"", ""patch"": ""@@ -58,8 +58,7 @@\n\n /*Internal function to perform UHID write and error checking*/\n static int uhid_write(int fd, const struct uhid_event *ev)\n {\n-    ssize_t ret = write(fd, ev, sizeof(*ev));\n-\n+    ssize_t ret = TEMP_FAILURE_RETRY(write(fd, ev, sizeof(*ev)));\n     if (ret < 0){\n         int rtn = -errno;\n         APPL_TRACE_ERROR(\""%s: Cannot write to uhid:%s\"",\n@@ -85,7 +84,7 @@\n\n         APPL_TRACE_ERROR(\""%s: Device not found\"",__FUNCTION__)\n         return -1;\n     }\n-    ret = read(p_dev->fd, &ev, sizeof(ev));\n+    ret = TEMP_FAILURE_RETRY(read(p_dev->fd, &ev, sizeof(ev)));\n     if (ret == 0) {\n         APPL_TRACE_ERROR(\""%s: Read HUP on uhid-cdev %s\"", __FUNCTION__,\n                                                  strerror(errno));\n@@ -206,7 +205,7 @@\n\n     uhid_set_non_blocking(p_dev->fd);\n \n     while(p_dev->hh_keep_polling){\n-        ret = poll(pfds, 1, 50);\n+        ret = TEMP_FAILURE_RETRY(poll(pfds, 1, 50));\n         if (ret < 0) {\n             APPL_TRACE_ERROR(\""%s: Cannot poll for fds: %s\\n\"", __FUNCTION__, strerror(errno));\n             break;\n@@ -300,7 +299,7 @@\n\n                                   __FUNCTION__, p_dev->attr_mask, p_dev->sub_class, p_dev->app_id);\n \n             if(p_dev->fd<0) {\n-                p_dev->fd = open(dev_path, O_RDWR | O_CLOEXEC);\n+                p_dev->fd = TEMP_FAILURE_RETRY(open(dev_path, O_RDWR | O_CLOEXEC));\n                 if (p_dev->fd < 0){\n                     APPL_TRACE_ERROR(\""%s: Error: failed to open uhid, err:%s\"",\n                                                                     __FUNCTION__,strerror(errno));\n@@ -329,7 +328,7 @@\n\n \n                 btif_hh_cb.device_num++;\n                 // This is a new device,open the uhid driver now.\n-                p_dev->fd = open(dev_path, O_RDWR | O_CLOEXEC);\n+                p_dev->fd = TEMP_FAILURE_RETRY(open(dev_path, O_RDWR | O_CLOEXEC));\n                 if (p_dev->fd < 0){\n                     APPL_TRACE_ERROR(\""%s: Error: failed to open uhid, err:%s\"",\n                                                                     __FUNCTION__,strerror(errno));\n""}<_**next**_>{""filename"": ""btif/co/bta_hl_co.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/co/bta_hl_co.c"", ""patch"": ""@@ -34,6 +34,7 @@\n\n #include <fcntl.h>\n #include <ctype.h>\n #include <cutils/sockets.h>\n+#include <unistd.h>\n #include \""bta_api.h\""\n #include \""btm_api.h\""\n #include \""bta_sys.h\""\n@@ -384,7 +385,7 @@\n\n             {\n                 BTIF_TRACE_DEBUG(\""app_idx=%d mcl_idx=0x%x mdl_idx=0x%x data_size=%d\"",\n                                   app_idx, mcl_idx, mdl_idx, data_size);\n-                r = send(p_dcb->p_scb->socket_id[1], p_dcb->p_rx_pkt, data_size, 0);\n+                r = TEMP_FAILURE_RETRY(send(p_dcb->p_scb->socket_id[1], p_dcb->p_rx_pkt, data_size, 0));\n \n                 if (r == data_size)\n                 {\n""}<_**next**_>{""filename"": ""btif/src/btif_core.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_core.c"", ""patch"": ""@@ -29,6 +29,7 @@\n\n #include <ctype.h>\n #include <cutils/properties.h>\n #include <dirent.h>\n+#include <errno.h>\n #include <fcntl.h>\n #include <hardware/bluetooth.h>\n #include <stdlib.h>\n@@ -344,10 +345,10 @@\n\n \n         BTIF_TRACE_DEBUG(\""%s, local bdaddr is stored in %s\"", __func__, val);\n \n-        if ((addr_fd = open(val, O_RDONLY)) != -1)\n+        if ((addr_fd = TEMP_FAILURE_RETRY(open(val, O_RDONLY))) != -1)\n         {\n             memset(val, 0, sizeof(val));\n-            read(addr_fd, val, FACTORY_BT_BDADDR_STORAGE_LEN);\n+            TEMP_FAILURE_RETRY(read(addr_fd, val, FACTORY_BT_BDADDR_STORAGE_LEN));\n             /* If this is not a reserved/special bda, then use it */\n             if ((string_to_bdaddr(val, local_addr)) &&\n                 (memcmp(local_addr->address, null_bdaddr, BD_ADDR_LEN) != 0))\n""}<_**next**_>{""filename"": ""btif/src/btif_dm.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_dm.c"", ""patch"": ""@@ -28,6 +28,7 @@\n\n #define LOG_TAG \""bt_btif_dm\""\n \n #include <assert.h>\n+#include <errno.h>\n #include <signal.h>\n #include <stdio.h>\n #include <stdlib.h>\n@@ -1782,7 +1783,7 @@\n\n             BTIF_TRACE_ERROR(\""Received H/W Error. \"");\n             /* Flush storage data */\n             btif_config_flush();\n-            usleep(100000); /* 100milliseconds */\n+            TEMP_FAILURE_RETRY(usleep(100000)); /* 100milliseconds */\n             /* Killing the process to force a restart as part of fault tolerance */\n             kill(getpid(), SIGKILL);\n             break;\n""}<_**next**_>{""filename"": ""btif/src/btif_hh.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_hh.c"", ""patch"": ""@@ -234,7 +234,7 @@\n\n     BTIF_TRACE_DEBUG(\""%s:  %x %x %x\"", __FUNCTION__,\n          hidreport[6], hidreport[7], hidreport[8]);\n     bta_hh_co_write(fd , hidreport, sizeof(hidreport));\n-    usleep(200000);\n+    TEMP_FAILURE_RETRY(usleep(200000));\n     memset(hidreport,0,9);\n     hidreport[0]=1;\n     BTIF_TRACE_DEBUG(\""Writing hidreport #2 to os: \""\\\n@@ -329,7 +329,7 @@\n\n         BTIF_TRACE_DEBUG(\""%s: Sending hid report to kernel \""\\\n             \""indicating lock key state 0x%x\"",__FUNCTION__,\n             keylockstates);\n-        usleep(200000);\n+        TEMP_FAILURE_RETRY(usleep(200000));\n         toggle_os_keylockstates(p_dev->fd, keylockstates);\n     }\n     else\n""}<_**next**_>{""filename"": ""btif/src/btif_hl.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_hl.c"", ""patch"": ""@@ -4795,8 +4795,8 @@\n\n                 }\n                 p_dcb->p_tx_pkt = btif_hl_get_buf (p_dcb->mtu);\n                 if (p_dcb) {\n-                    int r = (int)recv(p_scb->socket_id[1], p_dcb->p_tx_pkt,\n-                            p_dcb->mtu, MSG_DONTWAIT);\n+                    int r = (int)TEMP_FAILURE_RETRY(recv(p_scb->socket_id[1], p_dcb->p_tx_pkt,\n+                            p_dcb->mtu, MSG_DONTWAIT));\n                     if (r > 0) {\n                         BTIF_TRACE_DEBUG(\""btif_hl_select_monitor_callback send data r =%d\"", r);\n                         p_dcb->tx_size = r;\n@@ -4852,7 +4852,7 @@\n\n static inline int btif_hl_select_wakeup(void){\n     char sig_on = btif_hl_signal_select_wakeup;\n     BTIF_TRACE_DEBUG(\""btif_hl_select_wakeup\"");\n-    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);\n+    return TEMP_FAILURE_RETRY(send(signal_fds[1], &sig_on, sizeof(sig_on), 0));\n }\n \n /*******************************************************************************\n@@ -4867,7 +4867,7 @@\n\n static inline int btif_hl_select_close_connected(void){\n     char sig_on = btif_hl_signal_select_close_connected;\n     BTIF_TRACE_DEBUG(\""btif_hl_select_close_connected\"");\n-    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);\n+    return TEMP_FAILURE_RETRY(send(signal_fds[1], &sig_on, sizeof(sig_on), 0));\n }\n \n /*******************************************************************************\n@@ -4884,7 +4884,7 @@\n\n     int result = 0;\n     char sig_on = btif_hl_signal_select_exit;\n     BTIF_TRACE_DEBUG(\""btif_hl_signal_select_exit\"");\n-    result = send(signal_fds[1], &sig_on, sizeof(sig_on), 0);\n+    result = TEMP_FAILURE_RETRY(send(signal_fds[1], &sig_on, sizeof(sig_on), 0));\n     if (btif_is_enabled())\n     {\n         /* Wait for the select_thread_id to exit if BT is still enabled\n@@ -4911,7 +4911,7 @@\n\n     char sig_recv = 0;\n \n     BTIF_TRACE_DEBUG(\""btif_hl_select_wake_reset\"");\n-    recv(signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);\n+    TEMP_FAILURE_RETRY(recv(signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL));\n     return(int)sig_recv;\n }\n /*******************************************************************************\n@@ -4972,7 +4972,7 @@\n\n         BTIF_TRACE_DEBUG(\""set curr_set = org_set \"");\n         curr_set = org_set;\n         max_curr_s = max_org_s;\n-        int ret = select((max_curr_s + 1), &curr_set, NULL, NULL, NULL);\n+        int ret = TEMP_FAILURE_RETRY(select((max_curr_s + 1), &curr_set, NULL, NULL, NULL));\n         BTIF_TRACE_DEBUG(\""select unblocked ret=%d\"", ret);\n         if (ret == -1)\n         {\n""}<_**next**_>{""filename"": ""btif/src/btif_pan.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_pan.c"", ""patch"": ""@@ -312,7 +312,7 @@\n\n     //set mac addr\n     memset(&ifr, 0, sizeof(ifr));\n     strncpy(ifr.ifr_name, devname, IFNAMSIZ - 1);\n-    err = ioctl(sk, SIOCGIFHWADDR, &ifr);\n+    err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCGIFHWADDR, &ifr));\n     if (err < 0)\n     {\n         BTIF_TRACE_ERROR(\""Could not get network hardware for interface:%s, errno:%s\"", devname, strerror(errno));\n@@ -333,7 +333,7 @@\n\n         ifr.ifr_hwaddr.sa_data[0] &= ~0x01;\n     }\n \n-    err = ioctl(sk, SIOCSIFHWADDR, (caddr_t)&ifr);\n+    err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFHWADDR, (caddr_t)&ifr));\n \n     if (err < 0) {\n         BTIF_TRACE_ERROR(\""Could not set bt address for interface:%s, errno:%s\"", devname, strerror(errno));\n@@ -348,7 +348,7 @@\n\n     ifr.ifr_flags |= IFF_UP;\n     ifr.ifr_flags |= IFF_MULTICAST;\n \n-    err = ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);\n+    err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr));\n \n \n     if (err < 0) {\n@@ -375,7 +375,7 @@\n\n \n     ifr.ifr_flags &= ~IFF_UP;\n \n-    ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);\n+    TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr));\n \n     close(sk);\n \n@@ -401,7 +401,7 @@\n\n \n     /* open the clone device */\n \n-    if ((fd = open(clonedev, O_RDWR)) < 0)\n+    if ((fd = TEMP_FAILURE_RETRY(open(clonedev, O_RDWR))) < 0)\n     {\n         BTIF_TRACE_DEBUG(\""could not open %s, err:%d\"", clonedev, errno);\n         return fd;\n@@ -413,7 +413,7 @@\n\n     strncpy(ifr.ifr_name, TAP_IF_NAME, IFNAMSIZ);\n \n     /* try to create the device */\n-    if ((err = ioctl(fd, TUNSETIFF, (void *) &ifr)) < 0)\n+    if ((err = TEMP_FAILURE_RETRY(ioctl(fd, TUNSETIFF, (void *) &ifr))) < 0)\n     {\n         BTIF_TRACE_DEBUG(\""ioctl error:%d, errno:%s\"", err, strerror(errno));\n         close(fd);\n@@ -421,8 +421,8 @@\n\n     }\n     if (tap_if_up(TAP_IF_NAME, controller_get_interface()->get_address()) == 0)\n     {\n-        int flags = fcntl(fd, F_GETFL, 0);\n-        fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n+        int flags = TEMP_FAILURE_RETRY(fcntl(fd, F_GETFL, 0));\n+        TEMP_FAILURE_RETRY(fcntl(fd, F_SETFL, flags | O_NONBLOCK));\n         return fd;\n     }\n     BTIF_TRACE_ERROR(\""can not bring up tap interface:%s\"", TAP_IF_NAME);\n@@ -451,7 +451,7 @@\n\n         memcpy(packet + sizeof(tETH_HDR), buf, len);\n \n         /* Send data to network interface */\n-        int ret = write(tap_fd, packet, len + sizeof(tETH_HDR));\n+        int ret = TEMP_FAILURE_RETRY(write(tap_fd, packet, len + sizeof(tETH_HDR)));\n         BTIF_TRACE_DEBUG(\""ret:%d\"", ret);\n         return ret;\n     }\n@@ -740,7 +740,7 @@\n\n         // We save it in the congest_packet right away in case we can't deliver it in this\n         // attempt.\n         if (!btpan_cb.congest_packet_size) {\n-            ssize_t ret = read(fd, btpan_cb.congest_packet, sizeof(btpan_cb.congest_packet));\n+            ssize_t ret = TEMP_FAILURE_RETRY(read(fd, btpan_cb.congest_packet, sizeof(btpan_cb.congest_packet)));\n             switch (ret) {\n                 case -1:\n                     BTIF_TRACE_ERROR(\""%s unable to read from driver: %s\"", __func__, strerror(errno));\n@@ -784,7 +784,7 @@\n\n         ufd.fd = fd;\n         ufd.events = POLLIN;\n         ufd.revents = 0;\n-        if (poll(&ufd, 1, 0) <= 0 || IS_EXCEPTION(ufd.revents))\n+        if (TEMP_FAILURE_RETRY(poll(&ufd, 1, 0)) <= 0 || IS_EXCEPTION(ufd.revents))\n             break;\n     }\n     //add fd back to monitor thread\n""}<_**next**_>{""filename"": ""btif/src/btif_rc.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_rc.c"", ""patch"": ""@@ -24,6 +24,7 @@\n\n  *  Description:   Bluetooth AVRC implementation\n  *\n  *****************************************************************************/\n+#include <errno.h>\n #include <hardware/bluetooth.h>\n #include <fcntl.h>\n #include <string.h>\n@@ -213,7 +214,7 @@\n\n     event.code  = code;\n     event.value = value;\n \n-    return write(fd, &event, sizeof(event));\n+    return TEMP_FAILURE_RETRY(write(fd, &event, sizeof(event)));\n }\n \n void send_key (int fd, uint16_t key, int pressed)\n@@ -252,7 +253,7 @@\n\n \n     for(x=0; x < MAX_UINPUT_PATHS; x++)\n     {\n-        fd = open(uinput_dev_path[x], O_RDWR);\n+        fd = TEMP_FAILURE_RETRY(open(uinput_dev_path[x], O_RDWR));\n         if (fd < 0)\n             continue;\n         break;\n@@ -270,20 +271,20 @@\n\n     dev.id.product = 0x0000;\n     dev.id.version = 0x0000;\n \n-    if (write(fd, &dev, sizeof(dev)) < 0) {\n+    if (TEMP_FAILURE_RETRY(write(fd, &dev, sizeof(dev))) < 0) {\n         BTIF_TRACE_ERROR(\""%s Unable to write device information\"", __FUNCTION__);\n         close(fd);\n         return -1;\n     }\n \n-    ioctl(fd, UI_SET_EVBIT, EV_KEY);\n-    ioctl(fd, UI_SET_EVBIT, EV_REL);\n-    ioctl(fd, UI_SET_EVBIT, EV_SYN);\n+    TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_EVBIT, EV_KEY));\n+    TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_EVBIT, EV_REL));\n+    TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_EVBIT, EV_SYN));\n \n     for (x = 0; key_map[x].name != NULL; x++)\n-        ioctl(fd, UI_SET_KEYBIT, key_map[x].mapped_id);\n+        TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_KEYBIT, key_map[x].mapped_id));\n \n-    if (ioctl(fd, UI_DEV_CREATE, NULL) < 0) {\n+    if (TEMP_FAILURE_RETRY(ioctl(fd, UI_DEV_CREATE, NULL)) < 0) {\n         BTIF_TRACE_ERROR(\""%s Unable to create uinput device\"", __FUNCTION__);\n         close(fd);\n         return -1;\n@@ -311,7 +312,7 @@\n\n {\n     BTIF_TRACE_DEBUG(\""%s\"", __FUNCTION__);\n     if (uinput_fd > 0) {\n-        ioctl(uinput_fd, UI_DEV_DESTROY);\n+        TEMP_FAILURE_RETRY(ioctl(uinput_fd, UI_DEV_DESTROY));\n \n         close(uinput_fd);\n         uinput_fd = -1;\n""}<_**next**_>{""filename"": ""btif/src/btif_sock_l2cap.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_sock_l2cap.c"", ""patch"": ""@@ -968,7 +968,7 @@\n\n     uint32_t len;\n \n     while (packet_get_head_l(sock, &buf, &len)) {\n-        int sent = send(sock->our_fd, buf, len, MSG_DONTWAIT);\n+        int sent = TEMP_FAILURE_RETRY(send(sock->our_fd, buf, len, MSG_DONTWAIT));\n \n         if (sent == (signed)len)\n             osi_free(buf);\n@@ -1002,7 +1002,7 @@\n\n             if (sock->connected) {\n                 int size = 0;\n \n-                if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (ioctl(sock->our_fd, FIONREAD, &size)\n+                if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (TEMP_FAILURE_RETRY(ioctl(sock->our_fd, FIONREAD, &size))\n                         == 0 && size)) {\n                     uint8_t *buffer = osi_malloc(L2CAP_MAX_SDU_LENGTH);\n                     //uint8_t *buffer = (uint8_t*)GKI_getbuf(L2CAP_MAX_SDU_LENGTH);\n@@ -1028,8 +1028,8 @@\n\n                          * UPDATE: Since we are responsible for freeing the buffer in the\n                          * write_complete_ind, it is OK to use malloc. */\n \n-                        int count = recv(fd, buffer, L2CAP_MAX_SDU_LENGTH,\n-                                MSG_NOSIGNAL | MSG_DONTWAIT);\n+                        int count = TEMP_FAILURE_RETRY(recv(fd, buffer, L2CAP_MAX_SDU_LENGTH,\n+                                MSG_NOSIGNAL | MSG_DONTWAIT));\n                         APPL_TRACE_DEBUG(\""btsock_l2cap_signaled - %d bytes received from socket\"",\n                                 count);\n                         if (sock->fixed_chan) {\n@@ -1061,7 +1061,7 @@\n\n         }\n         if (drop_it || (flags & SOCK_THREAD_FD_EXCEPTION)) {\n             int size = 0;\n-            if (drop_it || ioctl(sock->our_fd, FIONREAD, &size) != 0 || size == 0)\n+            if (drop_it || TEMP_FAILURE_RETRY(ioctl(sock->our_fd, FIONREAD, &size)) != 0 || size == 0)\n                 btsock_l2cap_free_l(sock);\n         }\n     }\n""}<_**next**_>{""filename"": ""btif/src/btif_sock_rfc.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_sock_rfc.c"", ""patch"": ""@@ -720,7 +720,7 @@\n\n   if (p_buf->len == 0)\n     return SENT_ALL;\n \n-  ssize_t sent = send(fd, p_buf->data + p_buf->offset, p_buf->len, MSG_DONTWAIT);\n+  ssize_t sent = TEMP_FAILURE_RETRY(send(fd, p_buf->data + p_buf->offset, p_buf->len, MSG_DONTWAIT));\n \n   if (sent == -1) {\n     if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)\n@@ -783,11 +783,9 @@\n\n     if (slot->f.connected) {\n       // Make sure there's data pending in case the peer closed the socket.\n       int size = 0;\n-      if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (ioctl(slot->fd, FIONREAD, &size) == 0 && size))\n-        //unlock before BTA_JvRfcommWrite to avoid deadlock on concurrnet multi rfcomm connectoins\n-        //concurrnet multi rfcomm connectoins\n-        pthread_mutex_unlock(&slot_lock);\n+      if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (TEMP_FAILURE_RETRY(ioctl(slot->fd, FIONREAD, &size)) == 0 && size)) {\n         BTA_JvRfcommWrite(slot->rfc_handle, slot->id);\n+      }\n     } else {\n       LOG_ERROR(\""%s socket signaled for read while disconnected, slot: %d, channel: %d\"", __func__, slot->id, slot->scn);\n       need_close = true;\n@@ -805,7 +803,7 @@\n\n   if (need_close || (flags & SOCK_THREAD_FD_EXCEPTION)) {\n     // Clean up if there's no data pending.\n     int size = 0;\n-    if (need_close || ioctl(slot->fd, FIONREAD, &size) != 0 || !size)\n+    if (need_close || TEMP_FAILURE_RETRY(ioctl(slot->fd, FIONREAD, &size)) != 0 || !size)\n       cleanup_rfc_slot(slot);\n   }\n \n@@ -859,7 +857,7 @@\n\n   if (!slot)\n     goto out;\n \n-  if (ioctl(slot->fd, FIONREAD, size) == 0) {\n+  if (TEMP_FAILURE_RETRY(ioctl(slot->fd, FIONREAD, size)) == 0) {\n     ret = true;\n   } else {\n     LOG_ERROR(\""%s unable to determine bytes remaining to be read on fd %d: %s\"", __func__, slot->fd, strerror(errno));\n@@ -880,7 +878,7 @@\n\n   if (!slot)\n     goto out;\n \n-  int received = recv(slot->fd, buf, size, 0);\n+  int received = TEMP_FAILURE_RETRY(recv(slot->fd, buf, size, 0));\n   if(received == size) {\n     ret = true;\n   } else {\n""}<_**next**_>{""filename"": ""btif/src/btif_sock_thread.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_sock_thread.c"", ""patch"": ""@@ -114,12 +114,12 @@\n\n static inline void set_socket_blocking(int s, int blocking)\n {\n     int opts;\n-    opts = fcntl(s, F_GETFL);\n+    opts = TEMP_FAILURE_RETRY(fcntl(s, F_GETFL));\n     if (opts<0) APPL_TRACE_ERROR(\""set blocking (%s)\"", strerror(errno));\n     if(blocking)\n         opts &= ~O_NONBLOCK;\n     else opts |= O_NONBLOCK;\n-    if (fcntl(s, F_SETFL, opts) < 0)\n+    if (TEMP_FAILURE_RETRY(fcntl(s, F_SETFL, opts)) < 0)\n         APPL_TRACE_ERROR(\""set blocking (%s)\"", strerror(errno));\n }\n \n@@ -161,7 +161,7 @@\n\n {\n     struct sockaddr_un client_address;\n     socklen_t clen;\n-    int fd = accept(s, (struct sockaddr*)&client_address, &clen);\n+    int fd = TEMP_FAILURE_RETRY(accept(s, (struct sockaddr*)&client_address, &clen));\n     APPL_TRACE_DEBUG(\""accepted fd:%d for server fd:%d\"", fd, s);\n     return fd;\n }\n@@ -325,7 +325,7 @@\n\n     }\n     sock_cmd_t cmd = {CMD_ADD_FD, fd, type, flags, user_id};\n     APPL_TRACE_DEBUG(\""adding fd:%d, flags:0x%x\"", fd, flags);\n-    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);\n+    return TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd);\n }\n \n bool btsock_thread_remove_fd_and_close(int thread_handle, int fd)\n@@ -342,7 +342,7 @@\n\n     }\n \n     sock_cmd_t cmd = {CMD_REMOVE_FD, fd, 0, 0, 0};\n-    return send(ts[thread_handle].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);\n+    return TEMP_FAILURE_RETRY(send(ts[thread_handle].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd);\n }\n \n int btsock_thread_post_cmd(int h, int type, const unsigned char* data, int size, uint32_t user_id)\n@@ -376,7 +376,7 @@\n\n             return FALSE;\n         }\n     }\n-    return send(ts[h].cmd_fdw, cmd_send, size_send, 0) == size_send;\n+    return TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, cmd_send, size_send, 0)) == size_send;\n }\n int btsock_thread_wakeup(int h)\n {\n@@ -391,7 +391,7 @@\n\n         return FALSE;\n     }\n     sock_cmd_t cmd = {CMD_WAKEUP, 0, 0, 0, 0};\n-    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);\n+    return TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd);\n }\n int btsock_thread_exit(int h)\n {\n@@ -406,7 +406,7 @@\n\n         return FALSE;\n     }\n     sock_cmd_t cmd = {CMD_EXIT, 0, 0, 0, 0};\n-    if(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd))\n+    if(TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd))\n     {\n         pthread_join(ts[h].thread_id, 0);\n         pthread_mutex_lock(&thread_slot_lock);\n@@ -501,7 +501,7 @@\n\n {\n     sock_cmd_t cmd = {-1, 0, 0, 0, 0};\n     int fd = ts[h].cmd_fdr;\n-    if(recv(fd, &cmd, sizeof(cmd), MSG_WAITALL) != sizeof(cmd))\n+    if(TEMP_FAILURE_RETRY(recv(fd, &cmd, sizeof(cmd), MSG_WAITALL)) != sizeof(cmd))\n     {\n         APPL_TRACE_ERROR(\""recv cmd errno:%d\"", errno);\n         return FALSE;\n@@ -608,7 +608,7 @@\n\n     for(;;)\n     {\n         prepare_poll_fds(h, pfds);\n-        int ret = poll(pfds, ts[h].poll_count, -1);\n+        int ret = TEMP_FAILURE_RETRY(poll(pfds, ts[h].poll_count, -1));\n         if(ret == -1)\n         {\n             APPL_TRACE_ERROR(\""poll ret -1, exit the thread, errno:%d, err:%s\"", errno, strerror(errno));\n""}<_**next**_>{""filename"": ""btif/src/btif_sock_util.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_sock_util.c"", ""patch"": ""@@ -74,7 +74,7 @@\n\n     int ret;\n     while(s)\n     {\n-        do ret = send(sock_fd, buf, s, 0);\n+        do ret = TEMP_FAILURE_RETRY(send(sock_fd, buf, s, 0));\n         while(ret < 0 && errno == EINTR);\n         if(ret <= 0)\n         {\n@@ -92,7 +92,7 @@\n\n     int ret = -1;\n     while(r)\n     {\n-        do ret = recv(sock_fd, buf, r, MSG_WAITALL);\n+        do ret = TEMP_FAILURE_RETRY(recv(sock_fd, buf, r, MSG_WAITALL));\n         while(ret < 0 && errno == EINTR);\n         if(ret <= 0)\n         {\n@@ -140,7 +140,7 @@\n\n         msg.msg_iovlen = 1;\n \n         do {\n-            ret = sendmsg(sock_fd, &msg, MSG_NOSIGNAL);\n+            ret = TEMP_FAILURE_RETRY(sendmsg(sock_fd, &msg, MSG_NOSIGNAL));\n         } while (ret < 0 && errno == EINTR);\n \n         if (ret < 0) {\n""}<_**next**_>{""filename"": ""gki/ulinux/gki_ulinux.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/gki/ulinux/gki_ulinux.c"", ""patch"": ""@@ -76,7 +76,7 @@\n\n \n   int err;\n   do {\n-    err = nanosleep(&delay, &delay);\n+    err = TEMP_FAILURE_RETRY(nanosleep(&delay, &delay));\n   } while (err == -1 && errno == EINTR);\n }\n \n""}<_**next**_>{""filename"": ""hci/src/btsnoop.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/hci/src/btsnoop.c"", ""patch"": ""@@ -169,14 +169,14 @@\n\n         LOG_ERROR(\""%s unable to rename '%s' to '%s': %s\"", __func__, log_path, last_log_path, strerror(errno));\n     }\n \n-    logfile_fd = open(log_path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);\n+    logfile_fd = TEMP_FAILURE_RETRY(open(log_path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH));\n     if (logfile_fd == INVALID_FD) {\n       LOG_ERROR(\""%s unable to open '%s': %s\"", __func__, log_path, strerror(errno));\n       is_logging = false;\n       return;\n     }\n \n-    write(logfile_fd, \""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea\"", 16);\n+    TEMP_FAILURE_RETRY(write(logfile_fd, \""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea\"", 16));\n   } else {\n     if (logfile_fd != INVALID_FD)\n       close(logfile_fd);\n@@ -188,7 +188,7 @@\n\n \n static void btsnoop_write(const void *data, size_t length) {\n   if (logfile_fd != INVALID_FD)\n-    write(logfile_fd, data, length);\n+    TEMP_FAILURE_RETRY(write(logfile_fd, data, length));\n \n   btsnoop_net_write(data, length);\n }\n""}<_**next**_>{""filename"": ""hci/src/btsnoop_net.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/hci/src/btsnoop_net.c"", ""patch"": ""@@ -77,7 +77,7 @@\n\n \n   pthread_mutex_lock(&client_socket_lock_);\n   if (client_socket_ != -1) {\n-    if (send(client_socket_, data, length, 0) == -1 && errno == ECONNRESET) {\n+    if (TEMP_FAILURE_RETRY(send(client_socket_, data, length, 0)) == -1 && errno == ECONNRESET) {\n       safe_close_(&client_socket_);\n     }\n   }\n@@ -115,7 +115,7 @@\n\n   }\n \n   for (;;) {\n-    int client_socket = accept(listen_socket_, NULL, NULL);\n+    int client_socket = TEMP_FAILURE_RETRY(accept(listen_socket_, NULL, NULL));\n     if (client_socket == -1) {\n       if (errno == EINVAL || errno == EBADF) {\n         break;\n@@ -129,7 +129,7 @@\n\n     pthread_mutex_lock(&client_socket_lock_);\n     safe_close_(&client_socket_);\n     client_socket_ = client_socket;\n-    send(client_socket_, \""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea\"", 16, 0);\n+    TEMP_FAILURE_RETRY(send(client_socket_, \""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea\"", 16, 0));\n     pthread_mutex_unlock(&client_socket_lock_);\n   }\n \n""}<_**next**_>{""filename"": ""hci/src/hci_hal_h4.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/hci/src/hci_hal_h4.c"", ""patch"": ""@@ -153,7 +153,7 @@\n\n \n   uint16_t transmitted_length = 0;\n   while (length > 0) {\n-    ssize_t ret = write(uart_fd, data + transmitted_length, length);\n+    ssize_t ret = TEMP_FAILURE_RETRY(write(uart_fd, data + transmitted_length, length));\n     switch (ret) {\n       case -1:\n         LOG_ERROR(\""In %s, error writing to the uart serial port: %s\"", __func__, strerror(errno));\n""}<_**next**_>{""filename"": ""hci/src/hci_hal_mct.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/hci/src/hci_hal_mct.c"", ""patch"": ""@@ -159,7 +159,7 @@\n\n \n   uint16_t transmitted_length = 0;\n   while (length > 0) {\n-    ssize_t ret = write(fd, data + transmitted_length, length);\n+    ssize_t ret = TEMP_FAILURE_RETRY(write(fd, data + transmitted_length, length));\n     switch (ret) {\n       case -1:\n         LOG_ERROR(\""In %s, error writing to the serial port with fd %d: %s\"", __func__, fd, strerror(errno));\n""}<_**next**_>{""filename"": ""hci/src/hci_layer.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/hci/src/hci_layer.c"", ""patch"": ""@@ -20,6 +20,7 @@\n\n \n #include <assert.h>\n #include <cutils/properties.h>\n+#include <errno.h>\n #include <string.h>\n #include <signal.h>\n #include <string.h>\n@@ -517,7 +518,7 @@\n\n   }\n \n   LOG_ERROR(\""%s restarting the bluetooth process.\"", __func__);\n-  usleep(10000);\n+  TEMP_FAILURE_RETRY(usleep(10000));\n   kill(getpid(), SIGKILL);\n }\n \n""}<_**next**_>{""filename"": ""hci/test/hci_hal_h4_test.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/hci/test/hci_hal_h4_test.cpp"", ""patch"": ""@@ -183,26 +183,26 @@\n\n     fd_set read_fds;\n     FD_ZERO(&read_fds);\n     FD_SET(fd, &read_fds);\n-    select(fd + 1, &read_fds, NULL, NULL, NULL);\n+    TEMP_FAILURE_RETRY(select(fd + 1, &read_fds, NULL, NULL, NULL));\n \n     char byte;\n-    read(fd, &byte, 1);\n+    TEMP_FAILURE_RETRY(read(fd, &byte, 1));\n \n     EXPECT_EQ(i == 0 ? first_byte : data[i - 1], byte);\n   }\n }\n \n static void write_packet(int fd, char first_byte, char *data) {\n-  write(fd, &first_byte, 1);\n-  write(fd, data, strlen(data));\n+  TEMP_FAILURE_RETRY(write(fd, &first_byte, 1));\n+  TEMP_FAILURE_RETRY(write(fd, data, strlen(data)));\n }\n \n static void write_packet_reentry(int fd, char first_byte, char *data) {\n-  write(fd, &first_byte, 1);\n+  TEMP_FAILURE_RETRY(write(fd, &first_byte, 1));\n \n   int length = strlen(data);\n   for (int i = 0; i < length; i++) {\n-    write(fd, &data[i], 1);\n+    TEMP_FAILURE_RETRY(write(fd, &data[i], 1));\n     semaphore_wait(reentry_semaphore);\n   }\n }\n@@ -252,7 +252,7 @@\n\n   reset_for(type_byte_only);\n \n   char byte = DATA_TYPE_ACL;\n-  write(sockfd[1], &byte, 1);\n+  TEMP_FAILURE_RETRY(write(sockfd[1], &byte, 1));\n \n   fd_set read_fds;\n \n@@ -265,6 +265,6 @@\n\n     timeout.tv_sec = 0;\n     timeout.tv_usec = 0;\n \n-    select(sockfd[0] + 1, &read_fds, NULL, NULL, &timeout);\n+    TEMP_FAILURE_RETRY(select(sockfd[0] + 1, &read_fds, NULL, NULL, &timeout));\n   } while(FD_ISSET(sockfd[0], &read_fds));\n }\n""}<_**next**_>{""filename"": ""hci/test/hci_hal_mct_test.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/hci/test/hci_hal_mct_test.cpp"", ""patch"": ""@@ -186,23 +186,23 @@\n\n     fd_set read_fds;\n     FD_ZERO(&read_fds);\n     FD_SET(fd, &read_fds);\n-    select(fd + 1, &read_fds, NULL, NULL, NULL);\n+    TEMP_FAILURE_RETRY(select(fd + 1, &read_fds, NULL, NULL, NULL));\n \n     char byte;\n-    read(fd, &byte, 1);\n+    TEMP_FAILURE_RETRY(read(fd, &byte, 1));\n \n     EXPECT_EQ(data[i], byte);\n   }\n }\n \n static void write_packet(int fd, char *data) {\n-  write(fd, data, strlen(data));\n+  TEMP_FAILURE_RETRY(write(fd, data, strlen(data)));\n }\n \n static void write_packet_reentry(int fd, char *data) {\n   int length = strlen(data);\n   for (int i = 0; i < length; i++) {\n-    write(fd, &data[i], 1);\n+    TEMP_FAILURE_RETRY(write(fd, &data[i], 1));\n     semaphore_wait(reentry_semaphore);\n   }\n }\n""}<_**next**_>{""filename"": ""osi/src/config.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/src/config.c"", ""patch"": ""@@ -21,10 +21,13 @@\n\n #include <assert.h>\n #include <ctype.h>\n #include <errno.h>\n+#include <fcntl.h>\n+#include <libgen.h>\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n #include <sys/stat.h>\n+#include <sys/types.h>\n \n #include \""osi/include/allocator.h\""\n #include \""osi/include/config.h\""\n@@ -275,16 +278,39 @@\n\n   assert(filename != NULL);\n   assert(*filename != '\\0');\n \n-  char *temp_filename = osi_calloc(strlen(filename) + 5);\n-  if (!temp_filename) {\n-    LOG_ERROR(\""%s unable to allocate memory for filename.\"", __func__);\n-    return false;\n+  // Steps to ensure content of config file gets to disk:\n+  //\n+  // 1) Open and write to temp file (e.g. bt_config.conf.new).\n+  // 2) Sync the temp file to disk with fsync().\n+  // 3) Rename temp file to actual config file (e.g. bt_config.conf).\n+  //    This ensures atomic update.\n+  // 4) Sync directory that has the conf file with fsync().\n+  //    This ensures directory entries are up-to-date.\n+  int dir_fd = -1;\n+  FILE *fp = NULL;\n+\n+  // Build temp config file based on config file (e.g. bt_config.conf.new).\n+  static const char *temp_file_ext = \"".new\"";\n+  const int filename_len = strlen(filename);\n+  const int temp_filename_len = filename_len + strlen(temp_file_ext) + 1;\n+  char *temp_filename = osi_calloc(temp_filename_len);\n+  snprintf(temp_filename, temp_filename_len, \""%s%s\"", filename, temp_file_ext);\n+\n+  // Extract directory from file path (e.g. /data/misc/bluedroid).\n+  char *temp_dirname = osi_strdup(filename);\n+  const char *directoryname = dirname(temp_dirname);\n+  if (!directoryname) {\n+    LOG_ERROR(\""%s error extracting directory from '%s': %s\"", __func__, filename, strerror(errno));\n+    goto error;\n   }\n \n-  strcpy(temp_filename, filename);\n-  strcat(temp_filename, \"".new\"");\n+  dir_fd = TEMP_FAILURE_RETRY(open(directoryname, O_RDONLY));\n+  if (dir_fd < 0) {\n+    LOG_ERROR(\""%s unable to open dir '%s': %s\"", __func__, directoryname, strerror(errno));\n+    goto error;\n+  }\n \n-  FILE *fp = fopen(temp_filename, \""wt\"");\n+  fp = fopen(temp_filename, \""wt\"");\n   if (!fp) {\n     LOG_ERROR(\""%s unable to write file '%s': %s\"", __func__, temp_filename, strerror(errno));\n     goto error;\n@@ -292,20 +318,38 @@\n\n \n   for (const list_node_t *node = list_begin(config->sections); node != list_end(config->sections); node = list_next(node)) {\n     const section_t *section = (const section_t *)list_node(node);\n-    fprintf(fp, \""[%s]\\n\"", section->name);\n+    if (fprintf(fp, \""[%s]\\n\"", section->name) < 0) {\n+      LOG_ERROR(\""%s unable to write to file '%s': %s\"", __func__, temp_filename, strerror(errno));\n+      goto error;\n+    }\n \n     for (const list_node_t *enode = list_begin(section->entries); enode != list_end(section->entries); enode = list_next(enode)) {\n       const entry_t *entry = (const entry_t *)list_node(enode);\n-      fprintf(fp, \""%s = %s\\n\"", entry->key, entry->value);\n+      if (fprintf(fp, \""%s = %s\\n\"", entry->key, entry->value) < 0) {\n+        LOG_ERROR(\""%s unable to write to file '%s': %s\"", __func__, temp_filename, strerror(errno));\n+        goto error;\n+      }\n     }\n \n     // Only add a separating newline if there are more sections.\n-    if (list_next(node) != list_end(config->sections))\n-      fputc('\\n', fp);\n+    if (list_next(node) != list_end(config->sections)) {\n+      if (fputc('\\n', fp) == EOF) {\n+        LOG_ERROR(\""%s unable to write to file '%s': %s\"", __func__, temp_filename, strerror(errno));\n+        goto error;\n+      }\n+    }\n   }\n \n-  fflush(fp);\n-  fclose(fp);\n+  // Sync written temp file out to disk. fsync() is blocking until data makes it to disk.\n+  if (fsync(fileno(fp)) < 0) {\n+    LOG_WARN(\""%s unable to fsync file '%s': %s\"", __func__, temp_filename, strerror(errno));\n+  }\n+\n+  if (fclose(fp) == EOF) {\n+    LOG_ERROR(\""%s unable to close file '%s': %s\"", __func__, temp_filename, strerror(errno));\n+    goto error;\n+  }\n+  fp = NULL;\n \n   // Change the file's permissions to Read/Write by User and Group\n   if (chmod(temp_filename, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP) == -1) {\n@@ -313,17 +357,35 @@\n\n     goto error;\n   }\n \n+  // Rename written temp file to the actual config file.\n   if (rename(temp_filename, filename) == -1) {\n     LOG_ERROR(\""%s unable to commit file '%s': %s\"", __func__, filename, strerror(errno));\n     goto error;\n   }\n \n+  // This should ensure the directory is updated as well.\n+  if (fsync(dir_fd) < 0) {\n+    LOG_WARN(\""%s unable to fsync dir '%s': %s\"", __func__, directoryname, strerror(errno));\n+  }\n+\n+  if (close(dir_fd) < 0) {\n+    LOG_ERROR(\""%s unable to close dir '%s': %s\"", __func__, directoryname, strerror(errno));\n+    goto error;\n+  }\n+\n   osi_free(temp_filename);\n+  osi_free(temp_dirname);\n   return true;\n \n-error:;\n+error:\n+  // This indicates there is a write issue.  Unlink as partial data is not acceptable.\n   unlink(temp_filename);\n+  if (fp)\n+    fclose(fp);\n+  if (dir_fd != -1)\n+    close(dir_fd);\n   osi_free(temp_filename);\n+  osi_free(temp_dirname);\n   return false;\n }\n \n""}<_**next**_>{""filename"": ""osi/src/eager_reader.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/src/eager_reader.c"", ""patch"": ""@@ -228,7 +228,7 @@\n\n   timeout.tv_sec = 0;\n   timeout.tv_usec = 0;\n \n-  select(reader->bytes_available_fd + 1, &read_fds, NULL, NULL, &timeout);\n+  TEMP_FAILURE_RETRY(select(reader->bytes_available_fd + 1, &read_fds, NULL, NULL, &timeout));\n   return FD_ISSET(reader->bytes_available_fd, &read_fds);\n }\n \n@@ -244,7 +244,7 @@\n\n   buffer->length = 0;\n   buffer->offset = 0;\n \n-  int bytes_read = read(reader->inbound_fd, buffer->data, reader->buffer_size);\n+  int bytes_read = TEMP_FAILURE_RETRY(read(reader->inbound_fd, buffer->data, reader->buffer_size));\n   if (bytes_read > 0) {\n     // Save the data for later\n     buffer->length = bytes_read;\n""}<_**next**_>{""filename"": ""osi/src/reactor.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/src/reactor.c"", ""patch"": ""@@ -241,7 +241,7 @@\n\n \n     int ret;\n     do {\n-      ret = epoll_wait(reactor->epoll_fd, events, MAX_EVENTS, -1);\n+      ret = TEMP_FAILURE_RETRY(epoll_wait(reactor->epoll_fd, events, MAX_EVENTS, -1));\n     } while (ret == -1 && errno == EINTR);\n \n     if (ret == -1) {\n""}<_**next**_>{""filename"": ""osi/src/semaphore.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/src/semaphore.c"", ""patch"": ""@@ -73,12 +73,12 @@\n\n   assert(semaphore != NULL);\n   assert(semaphore->fd != INVALID_FD);\n \n-  int flags = fcntl(semaphore->fd, F_GETFL);\n+  int flags = TEMP_FAILURE_RETRY(fcntl(semaphore->fd, F_GETFL));\n   if (flags == -1) {\n     LOG_ERROR(\""%s unable to get flags for semaphore fd: %s\"", __func__, strerror(errno));\n     return false;\n   }\n-  if (fcntl(semaphore->fd, F_SETFL, flags | O_NONBLOCK) == -1) {\n+  if (TEMP_FAILURE_RETRY(fcntl(semaphore->fd, F_SETFL, flags | O_NONBLOCK)) == -1) {\n     LOG_ERROR(\""%s unable to set O_NONBLOCK for semaphore fd: %s\"", __func__, strerror(errno));\n     return false;\n   }\n@@ -87,7 +87,7 @@\n\n   if (eventfd_read(semaphore->fd, &value) == -1)\n     return false;\n \n-  if (fcntl(semaphore->fd, F_SETFL, flags) == -1)\n+  if (TEMP_FAILURE_RETRY(fcntl(semaphore->fd, F_SETFL, flags)) == -1)\n     LOG_ERROR(\""%s unable to resetore flags for semaphore fd: %s\"", __func__, strerror(errno));\n   return true;\n }\n""}<_**next**_>{""filename"": ""osi/src/socket.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/src/socket.c"", ""patch"": ""@@ -121,7 +121,7 @@\n\n socket_t *socket_accept(const socket_t *socket) {\n   assert(socket != NULL);\n \n-  int fd = accept(socket->fd, NULL, NULL);\n+  int fd = TEMP_FAILURE_RETRY(accept(socket->fd, NULL, NULL));\n   if (fd == INVALID_FD) {\n     LOG_ERROR(\""%s unable to accept socket: %s\"", __func__, strerror(errno));\n     return NULL;\n@@ -142,14 +142,14 @@\n\n   assert(socket != NULL);\n   assert(buf != NULL);\n \n-  return recv(socket->fd, buf, count, MSG_DONTWAIT);\n+  return TEMP_FAILURE_RETRY(recv(socket->fd, buf, count, MSG_DONTWAIT));\n }\n \n ssize_t socket_write(const socket_t *socket, const void *buf, size_t count) {\n   assert(socket != NULL);\n   assert(buf != NULL);\n \n-  return send(socket->fd, buf, count, MSG_DONTWAIT);\n+  return TEMP_FAILURE_RETRY(send(socket->fd, buf, count, MSG_DONTWAIT));\n }\n \n ssize_t socket_write_and_transfer_fd(const socket_t *socket, const void *buf, size_t count, int fd) {\n@@ -179,7 +179,7 @@\n\n   header->cmsg_len = CMSG_LEN(sizeof(int));\n   *(int *)CMSG_DATA(header) = fd;\n \n-  ssize_t ret = sendmsg(socket->fd, &msg, MSG_DONTWAIT);\n+  ssize_t ret = TEMP_FAILURE_RETRY(sendmsg(socket->fd, &msg, MSG_DONTWAIT));\n   close(fd);\n   return ret;\n }\n@@ -188,7 +188,7 @@\n\n   assert(socket != NULL);\n \n   int size = 0;\n-  if (ioctl(socket->fd, FIONREAD, &size) == -1)\n+  if (TEMP_FAILURE_RETRY(ioctl(socket->fd, FIONREAD, &size)) == -1)\n     return -1;\n   return size;\n }\n""}<_**next**_>{""filename"": ""osi/test/alarm_test.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/test/alarm_test.cpp"", ""patch"": ""@@ -32,7 +32,7 @@\n\n static const uint64_t EPSILON_MS = 5;\n \n static void msleep(uint64_t ms) {\n-  usleep(ms * 1000);\n+  TEMP_FAILURE_RETRY(usleep(ms * 1000));\n }\n \n class AlarmTest : public AlarmTestHarness {\n""}<_**next**_>{""filename"": ""osi/test/atomic_test.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/test/atomic_test.cpp"", ""patch"": ""@@ -17,7 +17,7 @@\n\n void *atomic_thread(void *context) {\n   struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;\n   for (int i = 0; i < at->max_val; i++) {\n-    usleep(1);\n+    TEMP_FAILURE_RETRY(usleep(1));\n     atomic_inc_prefix_s32(&at->data[i]);\n   }\n   return NULL;\n@@ -26,9 +26,9 @@\n\n void *atomic_thread_inc_dec(void *context) {\n   struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;\n   for (int i = 0; i < at->max_val; i++) {\n-    usleep(1);\n+    TEMP_FAILURE_RETRY(usleep(1));\n     atomic_inc_prefix_s32(&at->data[i]);\n-    usleep(1);\n+    TEMP_FAILURE_RETRY(usleep(1));\n     atomic_dec_prefix_s32(&at->data[i]);\n   }\n   return NULL;\n""}<_**next**_>{""filename"": ""osi/test/eager_reader_test.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/test/eager_reader_test.cpp"", ""patch"": ""@@ -126,7 +126,7 @@\n\n   thread_t *read_thread = thread_new(\""read_thread\"");\n   eager_reader_register(reader, thread_get_reactor(read_thread), expect_data, (void *)small_data);\n \n-  write(pipefd[1], small_data, strlen(small_data));\n+  TEMP_FAILURE_RETRY(write(pipefd[1], small_data, strlen(small_data)));\n \n   semaphore_wait(done);\n   eager_reader_free(reader);\n@@ -139,7 +139,7 @@\n\n   thread_t *read_thread = thread_new(\""read_thread\"");\n   eager_reader_register(reader, thread_get_reactor(read_thread), expect_data_multibyte, (void *)large_data);\n \n-  write(pipefd[1], large_data, strlen(large_data));\n+  TEMP_FAILURE_RETRY(write(pipefd[1], large_data, strlen(large_data)));\n \n   semaphore_wait(done);\n   eager_reader_free(reader);\n""}<_**next**_>{""filename"": ""osi/test/reactor_test.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/test/reactor_test.cpp"", ""patch"": ""@@ -64,7 +64,7 @@\n\n   reactor_t *reactor = reactor_new();\n \n   spawn_reactor_thread(reactor);\n-  usleep(50 * 1000);\n+  TEMP_FAILURE_RETRY(usleep(50 * 1000));\n   EXPECT_TRUE(thread_running);\n \n   reactor_stop(reactor);\n@@ -108,7 +108,7 @@\n\n \n   reactor_object_t *object = reactor_register(reactor, fd, NULL, NULL, NULL);\n   spawn_reactor_thread(reactor);\n-  usleep(50 * 1000);\n+  TEMP_FAILURE_RETRY(usleep(50 * 1000));\n   reactor_unregister(object);\n \n   reactor_stop(reactor);\n""}<_**next**_>{""filename"": ""test/suite/support/callbacks.h"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/test/suite/support/callbacks.h"", ""patch"": ""@@ -20,12 +20,14 @@\n\n \n #include \""base.h\""\n \n+#include <errno.h>\n #include <semaphore.h>\n+#include <unistd.h>\n \n #define WAIT(callback) \\\n   do { \\\n     sem_t *semaphore = callbacks_get_semaphore(#callback); \\\n-    sem_wait(semaphore); \\\n+    TEMP_FAILURE_RETRY(sem_wait(semaphore)); \\\n   } while (0)\n \n #define CALL_AND_WAIT(expression, callback) \\\n@@ -33,7 +35,7 @@\n\n     sem_t *semaphore = callbacks_get_semaphore(#callback); \\\n     while (!sem_trywait(semaphore)); \\\n     expression; \\\n-    sem_wait(semaphore); \\\n+    TEMP_FAILURE_RETRY(sem_wait(semaphore)); \\\n   } while(0)\n \n // To be called from every exit point of the callback. This macro\n""}<_**next**_>{""filename"": ""tools/hci/main.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/tools/hci/main.c"", ""patch"": ""@@ -1,3 +1,4 @@\n\n+#include <errno.h>\n #include <hardware/bluetooth.h>\n #include <netinet/in.h>\n #include <stdio.h>\n@@ -149,16 +150,16 @@\n\n   addr.sin_family = AF_INET;\n   addr.sin_addr.s_addr = htonl(0x7F000001);\n   addr.sin_port = htons(8873);\n-  if (connect(sock, (const struct sockaddr *)&addr, sizeof(addr)) == -1)\n+  if (TEMP_FAILURE_RETRY(connect(sock, (const struct sockaddr *)&addr, sizeof(addr))) == -1)\n     goto error;\n \n-  if (send(sock, &type, 1, 0) != 1)\n+  if (TEMP_FAILURE_RETRY(send(sock, &type, 1, 0)) != 1)\n     goto error;\n \n-  if (send(sock, &length, 2, 0) != 2)\n+  if (TEMP_FAILURE_RETRY(send(sock, &length, 2, 0)) != 2)\n     goto error;\n \n-  if (send(sock, packet, length, 0) != (ssize_t)length)\n+  if (TEMP_FAILURE_RETRY(send(sock, packet, length, 0)) != (ssize_t)length)\n     goto error;\n \n   close(sock);\n""}<_**next**_>{""filename"": ""udrv/ulinux/uipc.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/udrv/ulinux/uipc.c"", ""patch"": ""@@ -184,7 +184,7 @@\n\n     pfd.fd = sfd;\n     pfd.events = POLLIN;\n \n-    if (poll(&pfd, 1, 0) == 0)\n+    if (TEMP_FAILURE_RETRY(poll(&pfd, 1, 0)) == 0)\n     {\n         BTIF_TRACE_EVENT(\""accept poll timeout\"");\n         return -1;\n@@ -192,7 +192,7 @@\n\n \n     //BTIF_TRACE_EVENT(\""poll revents 0x%x\"", pfd.revents);\n \n-    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)\n+    if ((fd = TEMP_FAILURE_RETRY(accept(sfd, (struct sockaddr *)&remote, &len))) == -1)\n     {\n          BTIF_TRACE_ERROR(\""sock accept failed (%s)\"", strerror(errno));\n          return -1;\n@@ -330,7 +330,7 @@\n\n     {\n         char sig_recv = 0;\n         //BTIF_TRACE_EVENT(\""UIPC INTERRUPT\"");\n-        recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);\n+        TEMP_FAILURE_RETRY(recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL));\n     }\n }\n \n@@ -338,7 +338,7 @@\n\n {\n     char sig_on = 1;\n     BTIF_TRACE_EVENT(\""UIPC SEND WAKE UP\"");\n-    send(uipc_main.signal_fds[1], &sig_on, sizeof(sig_on), 0);\n+    TEMP_FAILURE_RETRY(send(uipc_main.signal_fds[1], &sig_on, sizeof(sig_on), 0));\n }\n \n static int uipc_setup_server_locked(tUIPC_CH_ID ch_id, char *name, tUIPC_RCV_CBACK *cback)\n@@ -394,7 +394,7 @@\n\n \n     while (1)\n     {\n-        ret = poll(&pfd, 1, 1);\n+        ret = TEMP_FAILURE_RETRY(poll(&pfd, 1, 1));\n         BTIF_TRACE_VERBOSE(\""%s() - polling fd %d, revents: 0x%x, ret %d\"",\n                 __FUNCTION__, pfd.fd, pfd.revents, ret);\n \n@@ -412,7 +412,7 @@\n\n \n         /* read sufficiently large buffer to ensure flush empties socket faster than\n            it is getting refilled */\n-        read(pfd.fd, &buf, UIPC_FLUSH_BUFFER_SIZE);\n+        TEMP_FAILURE_RETRY(read(pfd.fd, &buf, UIPC_FLUSH_BUFFER_SIZE));\n     }\n }\n \n@@ -502,7 +502,7 @@\n\n     {\n         uipc_main.read_set = uipc_main.active_set;\n \n-        result = select(uipc_main.max_fd+1, &uipc_main.read_set, NULL, NULL, NULL);\n+        result = TEMP_FAILURE_RETRY(select(uipc_main.max_fd+1, &uipc_main.read_set, NULL, NULL, NULL));\n \n         if (result == 0)\n         {\n@@ -715,7 +715,7 @@\n\n \n     UIPC_LOCK();\n \n-    if (write(uipc_main.ch[ch_id].fd, p_buf, msglen) < 0)\n+    if (TEMP_FAILURE_RETRY(write(uipc_main.ch[ch_id].fd, p_buf, msglen)) < 0)\n     {\n         BTIF_TRACE_ERROR(\""failed to write (%s)\"", strerror(errno));\n     }\n@@ -784,7 +784,7 @@\n\n \n         /* make sure there is data prior to attempting read to avoid blocking\n            a read for more than poll timeout */\n-        if (poll(&pfd, 1, uipc_main.ch[ch_id].read_poll_tmo_ms) == 0)\n+        if (TEMP_FAILURE_RETRY(poll(&pfd, 1, uipc_main.ch[ch_id].read_poll_tmo_ms)) == 0)\n         {\n             BTIF_TRACE_EVENT(\""poll timeout (%d ms)\"", uipc_main.ch[ch_id].read_poll_tmo_ms);\n             break;\n@@ -801,7 +801,7 @@\n\n             return 0;\n         }\n \n-        n = recv(fd, p_buf+n_read, len-n_read, 0);\n+        n = TEMP_FAILURE_RETRY(recv(fd, p_buf+n_read, len-n_read, 0));\n \n         //BTIF_TRACE_EVENT(\""read %d bytes\"", n);\n \n""}",    usleep(1);,3," void *atomic_thread(void *context) {
   struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;
   for (int i = 0; i < at->max_val; i++) {
    TEMP_FAILURE_RETRY(usleep(1));
     atomic_inc_prefix_s32(&at->data[i]);
   }
   return NULL;
}
"," void *atomic_thread(void *context) {
   struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;
   for (int i = 0; i < at->max_val; i++) {
    usleep(1);
     atomic_inc_prefix_s32(&at->data[i]);
   }
   return NULL;
}
",187512.0,C,"    TEMP_FAILURE_RETRY(usleep(1));
","    usleep(1);
",,"@@ -17,7 +17,7 @@

 void *atomic_thread(void *context) {
   struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;
   for (int i = 0; i < at->max_val; i++) {
-    usleep(1);
+    TEMP_FAILURE_RETRY(usleep(1));
     atomic_inc_prefix_s32(&at->data[i]);
   }
   return NULL;
@@ -26,9 +26,9 @@

 void *atomic_thread_inc_dec(void *context) {
   struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;
   for (int i = 0; i < at->max_val; i++) {
-    usleep(1);
+    TEMP_FAILURE_RETRY(usleep(1));
     atomic_inc_prefix_s32(&at->data[i]);
-    usleep(1);
+    TEMP_FAILURE_RETRY(usleep(1));
     atomic_dec_prefix_s32(&at->data[i]);
   }
   return NULL;
","void *atomic_thread(void *context) {
struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;
for (int i = 0; i < at->max_val; i++) {
    usleep(1);
atomic_inc_prefix_s32(&at->data[i]);
}
return NULL;
}
",Android,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c%5E/,1.0," void *atomic_thread(void *context) {
   struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;
   for (int i = 0; i < at->max_val; i++) {
//flaw_line_below:
    usleep(1);
//fix_flaw_line_below:
//    TEMP_FAILURE_RETRY(usleep(1));
     atomic_inc_prefix_s32(&at->data[i]);
   }
   return NULL;
}
"
51,None,Remote,Not required,Partial,CVE-2011-3055,https://www.cvedetails.com/cve/CVE-2011-3055/,,Medium,Partial,Partial,,2012-03-22,6.8,"The browser native UI in Google Chrome before 17.0.963.83 does not require user confirmation before an unpacked extension installation, which allows user-assisted remote attackers to have an unspecified impact via a crafted extension.",2018-01-09,,1.0,https://github.com/chromium/chromium/commit/e9372a1bfd3588a80fcf49aa07321f0971dd6091,e9372a1bfd3588a80fcf49aa07321f0971dd6091,"[V8] Pass Isolate to throwNotEnoughArgumentsError()
https://bugs.webkit.org/show_bug.cgi?id=86983

Reviewed by Adam Barth.

The objective is to pass Isolate around in V8 bindings.
This patch passes Isolate to throwNotEnoughArgumentsError().

No tests. No change in behavior.

* bindings/scripts/CodeGeneratorV8.pm:
(GenerateArgumentsCountCheck):
(GenerateEventConstructorCallback):
* bindings/scripts/test/V8/V8Float64Array.cpp:
(WebCore::Float64ArrayV8Internal::fooCallback):
* bindings/scripts/test/V8/V8TestActiveDOMObject.cpp:
(WebCore::TestActiveDOMObjectV8Internal::excitingFunctionCallback):
(WebCore::TestActiveDOMObjectV8Internal::postMessageCallback):
* bindings/scripts/test/V8/V8TestCustomNamedGetter.cpp:
(WebCore::TestCustomNamedGetterV8Internal::anotherFunctionCallback):
* bindings/scripts/test/V8/V8TestEventConstructor.cpp:
(WebCore::V8TestEventConstructor::constructorCallback):
* bindings/scripts/test/V8/V8TestEventTarget.cpp:
(WebCore::TestEventTargetV8Internal::itemCallback):
(WebCore::TestEventTargetV8Internal::dispatchEventCallback):
* bindings/scripts/test/V8/V8TestInterface.cpp:
(WebCore::TestInterfaceV8Internal::supplementalMethod2Callback):
(WebCore::V8TestInterface::constructorCallback):
* bindings/scripts/test/V8/V8TestMediaQueryListListener.cpp:
(WebCore::TestMediaQueryListListenerV8Internal::methodCallback):
* bindings/scripts/test/V8/V8TestNamedConstructor.cpp:
(WebCore::V8TestNamedConstructorConstructorCallback):
* bindings/scripts/test/V8/V8TestObj.cpp:
(WebCore::TestObjV8Internal::voidMethodWithArgsCallback):
(WebCore::TestObjV8Internal::intMethodWithArgsCallback):
(WebCore::TestObjV8Internal::objMethodWithArgsCallback):
(WebCore::TestObjV8Internal::methodWithSequenceArgCallback):
(WebCore::TestObjV8Internal::methodReturningSequenceCallback):
(WebCore::TestObjV8Internal::methodThatRequiresAllArgsAndThrowsCallback):
(WebCore::TestObjV8Internal::serializedValueCallback):
(WebCore::TestObjV8Internal::idbKeyCallback):
(WebCore::TestObjV8Internal::optionsObjectCallback):
(WebCore::TestObjV8Internal::methodWithNonOptionalArgAndOptionalArgCallback):
(WebCore::TestObjV8Internal::methodWithNonOptionalArgAndTwoOptionalArgsCallback):
(WebCore::TestObjV8Internal::methodWithCallbackArgCallback):
(WebCore::TestObjV8Internal::methodWithNonCallbackArgAndCallbackArgCallback):
(WebCore::TestObjV8Internal::overloadedMethod1Callback):
(WebCore::TestObjV8Internal::overloadedMethod2Callback):
(WebCore::TestObjV8Internal::overloadedMethod3Callback):
(WebCore::TestObjV8Internal::overloadedMethod4Callback):
(WebCore::TestObjV8Internal::overloadedMethod5Callback):
(WebCore::TestObjV8Internal::overloadedMethod6Callback):
(WebCore::TestObjV8Internal::overloadedMethod7Callback):
(WebCore::TestObjV8Internal::overloadedMethod11Callback):
(WebCore::TestObjV8Internal::overloadedMethod12Callback):
(WebCore::TestObjV8Internal::enabledAtRuntimeMethod1Callback):
(WebCore::TestObjV8Internal::enabledAtRuntimeMethod2Callback):
(WebCore::TestObjV8Internal::convert1Callback):
(WebCore::TestObjV8Internal::convert2Callback):
(WebCore::TestObjV8Internal::convert3Callback):
(WebCore::TestObjV8Internal::convert4Callback):
(WebCore::TestObjV8Internal::convert5Callback):
(WebCore::TestObjV8Internal::strictFunctionCallback):
(WebCore::V8TestObj::constructorCallback):
* bindings/scripts/test/V8/V8TestSerializedScriptValueInterface.cpp:
(WebCore::TestSerializedScriptValueInterfaceV8Internal::acceptTransferListCallback):
(WebCore::V8TestSerializedScriptValueInterface::constructorCallback):
* bindings/v8/ScriptController.cpp:
(WebCore::setValueAndClosePopupCallback):
* bindings/v8/V8Proxy.cpp:
(WebCore::V8Proxy::throwNotEnoughArgumentsError):
* bindings/v8/V8Proxy.h:
(V8Proxy):
* bindings/v8/custom/V8AudioContextCustom.cpp:
(WebCore::V8AudioContext::constructorCallback):
* bindings/v8/custom/V8DataViewCustom.cpp:
(WebCore::V8DataView::getInt8Callback):
(WebCore::V8DataView::getUint8Callback):
(WebCore::V8DataView::setInt8Callback):
(WebCore::V8DataView::setUint8Callback):
* bindings/v8/custom/V8DirectoryEntryCustom.cpp:
(WebCore::V8DirectoryEntry::getDirectoryCallback):
(WebCore::V8DirectoryEntry::getFileCallback):
* bindings/v8/custom/V8IntentConstructor.cpp:
(WebCore::V8Intent::constructorCallback):
* bindings/v8/custom/V8SVGLengthCustom.cpp:
(WebCore::V8SVGLength::convertToSpecifiedUnitsCallback):
* bindings/v8/custom/V8WebGLRenderingContextCustom.cpp:
(WebCore::getObjectParameter):
(WebCore::V8WebGLRenderingContext::getAttachedShadersCallback):
(WebCore::V8WebGLRenderingContext::getExtensionCallback):
(WebCore::V8WebGLRenderingContext::getFramebufferAttachmentParameterCallback):
(WebCore::V8WebGLRenderingContext::getParameterCallback):
(WebCore::V8WebGLRenderingContext::getProgramParameterCallback):
(WebCore::V8WebGLRenderingContext::getShaderParameterCallback):
(WebCore::V8WebGLRenderingContext::getUniformCallback):
(WebCore::vertexAttribAndUniformHelperf):
(WebCore::uniformHelperi):
(WebCore::uniformMatrixHelper):
* bindings/v8/custom/V8WebKitMutationObserverCustom.cpp:
(WebCore::V8WebKitMutationObserver::constructorCallback):
(WebCore::V8WebKitMutationObserver::observeCallback):
* bindings/v8/custom/V8WebSocketCustom.cpp:
(WebCore::V8WebSocket::constructorCallback):
(WebCore::V8WebSocket::sendCallback):
* bindings/v8/custom/V8XMLHttpRequestCustom.cpp:
(WebCore::V8XMLHttpRequest::openCallback):


git-svn-id: svn://svn.chromium.org/blink/trunk@117736 bbb929c8-8fbe-4397-9dbb-9b2b20218538",1.0,third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestObj.cpp,"{""sha"": ""2a74667f4fcc8c7450347ecf9bdab1b9d400685d"", ""filename"": ""third_party/WebKit/Source/WebCore/ChangeLog"", ""status"": ""modified"", ""additions"": 110, ""deletions"": 0, ""changes"": 110, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/ChangeLog"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/ChangeLog?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -1,3 +1,113 @@\n+2012-05-21  Kentaro Hara  <haraken@chromium.org>\n+\n+        [V8] Pass Isolate to throwNotEnoughArgumentsError()\n+        https://bugs.webkit.org/show_bug.cgi?id=86983\n+\n+        Reviewed by Adam Barth.\n+\n+        The objective is to pass Isolate around in V8 bindings.\n+        This patch passes Isolate to throwNotEnoughArgumentsError().\n+\n+        No tests. No change in behavior.\n+\n+        * bindings/scripts/CodeGeneratorV8.pm:\n+        (GenerateArgumentsCountCheck):\n+        (GenerateEventConstructorCallback):\n+        * bindings/scripts/test/V8/V8Float64Array.cpp:\n+        (WebCore::Float64ArrayV8Internal::fooCallback):\n+        * bindings/scripts/test/V8/V8TestActiveDOMObject.cpp:\n+        (WebCore::TestActiveDOMObjectV8Internal::excitingFunctionCallback):\n+        (WebCore::TestActiveDOMObjectV8Internal::postMessageCallback):\n+        * bindings/scripts/test/V8/V8TestCustomNamedGetter.cpp:\n+        (WebCore::TestCustomNamedGetterV8Internal::anotherFunctionCallback):\n+        * bindings/scripts/test/V8/V8TestEventConstructor.cpp:\n+        (WebCore::V8TestEventConstructor::constructorCallback):\n+        * bindings/scripts/test/V8/V8TestEventTarget.cpp:\n+        (WebCore::TestEventTargetV8Internal::itemCallback):\n+        (WebCore::TestEventTargetV8Internal::dispatchEventCallback):\n+        * bindings/scripts/test/V8/V8TestInterface.cpp:\n+        (WebCore::TestInterfaceV8Internal::supplementalMethod2Callback):\n+        (WebCore::V8TestInterface::constructorCallback):\n+        * bindings/scripts/test/V8/V8TestMediaQueryListListener.cpp:\n+        (WebCore::TestMediaQueryListListenerV8Internal::methodCallback):\n+        * bindings/scripts/test/V8/V8TestNamedConstructor.cpp:\n+        (WebCore::V8TestNamedConstructorConstructorCallback):\n+        * bindings/scripts/test/V8/V8TestObj.cpp:\n+        (WebCore::TestObjV8Internal::voidMethodWithArgsCallback):\n+        (WebCore::TestObjV8Internal::intMethodWithArgsCallback):\n+        (WebCore::TestObjV8Internal::objMethodWithArgsCallback):\n+        (WebCore::TestObjV8Internal::methodWithSequenceArgCallback):\n+        (WebCore::TestObjV8Internal::methodReturningSequenceCallback):\n+        (WebCore::TestObjV8Internal::methodThatRequiresAllArgsAndThrowsCallback):\n+        (WebCore::TestObjV8Internal::serializedValueCallback):\n+        (WebCore::TestObjV8Internal::idbKeyCallback):\n+        (WebCore::TestObjV8Internal::optionsObjectCallback):\n+        (WebCore::TestObjV8Internal::methodWithNonOptionalArgAndOptionalArgCallback):\n+        (WebCore::TestObjV8Internal::methodWithNonOptionalArgAndTwoOptionalArgsCallback):\n+        (WebCore::TestObjV8Internal::methodWithCallbackArgCallback):\n+        (WebCore::TestObjV8Internal::methodWithNonCallbackArgAndCallbackArgCallback):\n+        (WebCore::TestObjV8Internal::overloadedMethod1Callback):\n+        (WebCore::TestObjV8Internal::overloadedMethod2Callback):\n+        (WebCore::TestObjV8Internal::overloadedMethod3Callback):\n+        (WebCore::TestObjV8Internal::overloadedMethod4Callback):\n+        (WebCore::TestObjV8Internal::overloadedMethod5Callback):\n+        (WebCore::TestObjV8Internal::overloadedMethod6Callback):\n+        (WebCore::TestObjV8Internal::overloadedMethod7Callback):\n+        (WebCore::TestObjV8Internal::overloadedMethod11Callback):\n+        (WebCore::TestObjV8Internal::overloadedMethod12Callback):\n+        (WebCore::TestObjV8Internal::enabledAtRuntimeMethod1Callback):\n+        (WebCore::TestObjV8Internal::enabledAtRuntimeMethod2Callback):\n+        (WebCore::TestObjV8Internal::convert1Callback):\n+        (WebCore::TestObjV8Internal::convert2Callback):\n+        (WebCore::TestObjV8Internal::convert3Callback):\n+        (WebCore::TestObjV8Internal::convert4Callback):\n+        (WebCore::TestObjV8Internal::convert5Callback):\n+        (WebCore::TestObjV8Internal::strictFunctionCallback):\n+        (WebCore::V8TestObj::constructorCallback):\n+        * bindings/scripts/test/V8/V8TestSerializedScriptValueInterface.cpp:\n+        (WebCore::TestSerializedScriptValueInterfaceV8Internal::acceptTransferListCallback):\n+        (WebCore::V8TestSerializedScriptValueInterface::constructorCallback):\n+        * bindings/v8/ScriptController.cpp:\n+        (WebCore::setValueAndClosePopupCallback):\n+        * bindings/v8/V8Proxy.cpp:\n+        (WebCore::V8Proxy::throwNotEnoughArgumentsError):\n+        * bindings/v8/V8Proxy.h:\n+        (V8Proxy):\n+        * bindings/v8/custom/V8AudioContextCustom.cpp:\n+        (WebCore::V8AudioContext::constructorCallback):\n+        * bindings/v8/custom/V8DataViewCustom.cpp:\n+        (WebCore::V8DataView::getInt8Callback):\n+        (WebCore::V8DataView::getUint8Callback):\n+        (WebCore::V8DataView::setInt8Callback):\n+        (WebCore::V8DataView::setUint8Callback):\n+        * bindings/v8/custom/V8DirectoryEntryCustom.cpp:\n+        (WebCore::V8DirectoryEntry::getDirectoryCallback):\n+        (WebCore::V8DirectoryEntry::getFileCallback):\n+        * bindings/v8/custom/V8IntentConstructor.cpp:\n+        (WebCore::V8Intent::constructorCallback):\n+        * bindings/v8/custom/V8SVGLengthCustom.cpp:\n+        (WebCore::V8SVGLength::convertToSpecifiedUnitsCallback):\n+        * bindings/v8/custom/V8WebGLRenderingContextCustom.cpp:\n+        (WebCore::getObjectParameter):\n+        (WebCore::V8WebGLRenderingContext::getAttachedShadersCallback):\n+        (WebCore::V8WebGLRenderingContext::getExtensionCallback):\n+        (WebCore::V8WebGLRenderingContext::getFramebufferAttachmentParameterCallback):\n+        (WebCore::V8WebGLRenderingContext::getParameterCallback):\n+        (WebCore::V8WebGLRenderingContext::getProgramParameterCallback):\n+        (WebCore::V8WebGLRenderingContext::getShaderParameterCallback):\n+        (WebCore::V8WebGLRenderingContext::getUniformCallback):\n+        (WebCore::vertexAttribAndUniformHelperf):\n+        (WebCore::uniformHelperi):\n+        (WebCore::uniformMatrixHelper):\n+        * bindings/v8/custom/V8WebKitMutationObserverCustom.cpp:\n+        (WebCore::V8WebKitMutationObserver::constructorCallback):\n+        (WebCore::V8WebKitMutationObserver::observeCallback):\n+        * bindings/v8/custom/V8WebSocketCustom.cpp:\n+        (WebCore::V8WebSocket::constructorCallback):\n+        (WebCore::V8WebSocket::sendCallback):\n+        * bindings/v8/custom/V8XMLHttpRequestCustom.cpp:\n+        (WebCore::V8XMLHttpRequest::openCallback):\n+\n 2012-05-20  Kentaro Hara  <haraken@chromium.org>\n \n         [V8] Pass Isolate to throwError()s in V8 custom bindings (Part 2)""}<_**next**_>{""sha"": ""e18329e0e262c4eac8eb50e23903ae289b753ad2"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/CodeGeneratorV8.pm"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/CodeGeneratorV8.pm"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/CodeGeneratorV8.pm"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/CodeGeneratorV8.pm?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -1526,7 +1526,7 @@ sub GenerateArgumentsCountCheck\n     my $argumentsCountCheckString = \""\"";\n     if ($numMandatoryParams >= 1) {\n         $argumentsCountCheckString .= \""    if (args.Length() < $numMandatoryParams)\\n\"";\n-        $argumentsCountCheckString .= \""        return V8Proxy::throwNotEnoughArgumentsError();\\n\"";\n+        $argumentsCountCheckString .= \""        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\\n\"";\n     }\n     return $argumentsCountCheckString;\n }\n@@ -1805,7 +1805,7 @@ v8::Handle<v8::Value> V8${implClassName}::constructorCallback(const v8::Argument\n         return args.Holder();\n \n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, type, args[0]);\n     ${implClassName}Init eventInit;""}<_**next**_>{""sha"": ""70a273bac3dc5552f4b7a8148321eb892db47852"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8Float64Array.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8Float64Array.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8Float64Array.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8Float64Array.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -52,7 +52,7 @@ static v8::Handle<v8::Value> fooCallback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.Float64Array.foo\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     Float64Array* imp = V8Float64Array::toNative(args.Holder());\n     EXCEPTION_BLOCK(Float32Array*, array, V8Float32Array::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Float32Array::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     return toV8(imp->foo(array), args.GetIsolate());""}<_**next**_>{""sha"": ""0d2d7872bcabd2034688f21b5992806adcded602"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestActiveDOMObject.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestActiveDOMObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestActiveDOMObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestActiveDOMObject.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -51,7 +51,7 @@ static v8::Handle<v8::Value> excitingFunctionCallback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.TestActiveDOMObject.excitingFunction\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestActiveDOMObject* imp = V8TestActiveDOMObject::toNative(args.Holder());\n     if (!V8BindingSecurity::canAccessFrame(V8BindingState::Only(), imp->frame(), true))\n         return v8::Handle<v8::Value>();\n@@ -64,7 +64,7 @@ static v8::Handle<v8::Value> postMessageCallback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.TestActiveDOMObject.postMessage\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestActiveDOMObject* imp = V8TestActiveDOMObject::toNative(args.Holder());\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, message, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));\n     imp->postMessage(message);""}<_**next**_>{""sha"": ""11b2f9d37214f2b43e1e79cc8c4882eb93a477e7"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestCustomNamedGetter.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestCustomNamedGetter.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestCustomNamedGetter.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestCustomNamedGetter.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -43,7 +43,7 @@ static v8::Handle<v8::Value> anotherFunctionCallback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.TestCustomNamedGetter.anotherFunction\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestCustomNamedGetter* imp = V8TestCustomNamedGetter::toNative(args.Holder());\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));\n     imp->anotherFunction(str);""}<_**next**_>{""sha"": ""48ab1fe4746090d48356b437e295d6ea7f495457"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestEventConstructor.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestEventConstructor.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestEventConstructor.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestEventConstructor.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -73,7 +73,7 @@ v8::Handle<v8::Value> V8TestEventConstructor::constructorCallback(const v8::Argu\n         return args.Holder();\n \n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, type, args[0]);\n     TestEventConstructorInit eventInit;""}<_**next**_>{""sha"": ""5015c08ae40da0c7801b4fcf6ef3149722db49fa"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestEventTarget.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestEventTarget.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestEventTarget.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestEventTarget.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -46,7 +46,7 @@ static v8::Handle<v8::Value> itemCallback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.TestEventTarget.item\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestEventTarget* imp = V8TestEventTarget::toNative(args.Holder());\n     ExceptionCode ec = 0;\n     {\n@@ -88,7 +88,7 @@ static v8::Handle<v8::Value> dispatchEventCallback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.TestEventTarget.dispatchEvent\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestEventTarget* imp = V8TestEventTarget::toNative(args.Holder());\n     ExceptionCode ec = 0;\n     {""}<_**next**_>{""sha"": ""2f2db0a456043ac460f9e01a414fdb1ab20ba6e6"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestInterface.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestInterface.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestInterface.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestInterface.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -124,7 +124,7 @@ static v8::Handle<v8::Value> supplementalMethod2Callback(const v8::Arguments& ar\n {\n     INC_STATS(\""DOM.TestInterface.supplementalMethod2\"");\n     if (args.Length() < 2)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestInterface* imp = V8TestInterface::toNative(args.Holder());\n     ExceptionCode ec = 0;\n     {\n@@ -213,7 +213,7 @@ v8::Handle<v8::Value> V8TestInterface::constructorCallback(const v8::Arguments&\n     if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)\n         return args.Holder();\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     ExceptionCode ec = 0;\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str1, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));""}<_**next**_>{""sha"": ""7139a64bde1a2f7b9c8d1d1fdef6fe7afde1b32d"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestMediaQueryListListener.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestMediaQueryListListener.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestMediaQueryListListener.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestMediaQueryListListener.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -44,7 +44,7 @@ static v8::Handle<v8::Value> methodCallback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.TestMediaQueryListListener.method\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestMediaQueryListListener* imp = V8TestMediaQueryListListener::toNative(args.Holder());\n     EXCEPTION_BLOCK(RefPtr<MediaQueryListListener>, listener, MediaQueryListListener::create(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     imp->method(listener);""}<_**next**_>{""sha"": ""829a082f9f6daa4b4a108d0ba765afd1c5869dd9"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestNamedConstructor.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestNamedConstructor.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestNamedConstructor.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestNamedConstructor.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -64,7 +64,7 @@ static v8::Handle<v8::Value> V8TestNamedConstructorConstructorCallback(const v8:\n     toV8(document, args.GetIsolate());\n \n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     ExceptionCode ec = 0;\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str1, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));""}<_**next**_>{""sha"": ""b7496732349adaa9caeff68b1752c641cee84e5e"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestObj.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 31, ""changes"": 62, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestObj.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestObj.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestObj.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -1230,7 +1230,7 @@ static v8::Handle<v8::Value> voidMethodWithArgsCallback(const v8::Arguments& arg\n {\n     INC_STATS(\""DOM.TestObj.voidMethodWithArgs\"");\n     if (args.Length() < 3)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));\n@@ -1250,7 +1250,7 @@ static v8::Handle<v8::Value> intMethodWithArgsCallback(const v8::Arguments& args\n {\n     INC_STATS(\""DOM.TestObj.intMethodWithArgs\"");\n     if (args.Length() < 3)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));\n@@ -1269,7 +1269,7 @@ static v8::Handle<v8::Value> objMethodWithArgsCallback(const v8::Arguments& args\n {\n     INC_STATS(\""DOM.TestObj.objMethodWithArgs\"");\n     if (args.Length() < 3)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));\n@@ -1281,7 +1281,7 @@ static v8::Handle<v8::Value> methodWithSequenceArgCallback(const v8::Arguments&\n {\n     INC_STATS(\""DOM.TestObj.methodWithSequenceArg\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(sequence<ScriptProfile>*, sequenceArg, toNativeArray<ScriptProfile>(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     imp->methodWithSequenceArg(sequenceArg);\n@@ -1292,7 +1292,7 @@ static v8::Handle<v8::Value> methodReturningSequenceCallback(const v8::Arguments\n {\n     INC_STATS(\""DOM.TestObj.methodReturningSequence\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     return v8Array(imp->methodReturningSequence(intArg), args.GetIsolate());\n@@ -1302,7 +1302,7 @@ static v8::Handle<v8::Value> methodThatRequiresAllArgsAndThrowsCallback(const v8\n {\n     INC_STATS(\""DOM.TestObj.methodThatRequiresAllArgsAndThrows\"");\n     if (args.Length() < 2)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     ExceptionCode ec = 0;\n     {\n@@ -1322,7 +1322,7 @@ static v8::Handle<v8::Value> serializedValueCallback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.TestObj.serializedValue\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     bool serializedArgDidThrow = false;\n     RefPtr<SerializedScriptValue> serializedArg = SerializedScriptValue::create(args[0], 0, 0, serializedArgDidThrow, args.GetIsolate());\n@@ -1336,7 +1336,7 @@ static v8::Handle<v8::Value> idbKeyCallback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.TestObj.idbKey\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(RefPtr<IDBKey>, key, createIDBKeyFromValue(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     imp->idbKey(key.get());\n@@ -1347,7 +1347,7 @@ static v8::Handle<v8::Value> optionsObjectCallback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.TestObj.optionsObject\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(Dictionary, oo, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));\n     if (args.Length() > 0 && !oo.isUndefinedOrNull() && !oo.isObject()) {\n@@ -1553,7 +1553,7 @@ static v8::Handle<v8::Value> methodWithNonOptionalArgAndOptionalArgCallback(cons\n {\n     INC_STATS(\""DOM.TestObj.methodWithNonOptionalArgAndOptionalArg\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, nonOpt, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     if (args.Length() <= 1) {\n@@ -1569,7 +1569,7 @@ static v8::Handle<v8::Value> methodWithNonOptionalArgAndTwoOptionalArgsCallback(\n {\n     INC_STATS(\""DOM.TestObj.methodWithNonOptionalArgAndTwoOptionalArgs\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, nonOpt, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     if (args.Length() <= 1) {\n@@ -1621,7 +1621,7 @@ static v8::Handle<v8::Value> methodWithCallbackArgCallback(const v8::Arguments&\n {\n     INC_STATS(\""DOM.TestObj.methodWithCallbackArg\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     if (args.Length() <= 0 || !args[0]->IsFunction())\n         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());\n@@ -1634,7 +1634,7 @@ static v8::Handle<v8::Value> methodWithNonCallbackArgAndCallbackArgCallback(cons\n {\n     INC_STATS(\""DOM.TestObj.methodWithNonCallbackArgAndCallbackArg\"");\n     if (args.Length() < 2)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, nonCallback, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     if (args.Length() <= 1 || !args[1]->IsFunction())\n@@ -1697,7 +1697,7 @@ static v8::Handle<v8::Value> overloadedMethod1Callback(const v8::Arguments& args\n {\n     INC_STATS(\""DOM.TestObj.overloadedMethod1\"");\n     if (args.Length() < 2)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(TestObj*, objArg, V8TestObj::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));\n@@ -1709,7 +1709,7 @@ static v8::Handle<v8::Value> overloadedMethod2Callback(const v8::Arguments& args\n {\n     INC_STATS(\""DOM.TestObj.overloadedMethod2\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(TestObj*, objArg, V8TestObj::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     if (args.Length() <= 1) {\n@@ -1725,7 +1725,7 @@ static v8::Handle<v8::Value> overloadedMethod3Callback(const v8::Arguments& args\n {\n     INC_STATS(\""DOM.TestObj.overloadedMethod3\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));\n     imp->overloadedMethod(strArg);\n@@ -1736,7 +1736,7 @@ static v8::Handle<v8::Value> overloadedMethod4Callback(const v8::Arguments& args\n {\n     INC_STATS(\""DOM.TestObj.overloadedMethod4\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     imp->overloadedMethod(intArg);\n@@ -1747,7 +1747,7 @@ static v8::Handle<v8::Value> overloadedMethod5Callback(const v8::Arguments& args\n {\n     INC_STATS(\""DOM.TestObj.overloadedMethod5\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     if (args.Length() <= 0 || !args[0]->IsFunction())\n         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());\n@@ -1760,7 +1760,7 @@ static v8::Handle<v8::Value> overloadedMethod6Callback(const v8::Arguments& args\n {\n     INC_STATS(\""DOM.TestObj.overloadedMethod6\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(RefPtr<DOMStringList>, listArg, v8ValueToWebCoreDOMStringList(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     imp->overloadedMethod(listArg);\n@@ -1771,7 +1771,7 @@ static v8::Handle<v8::Value> overloadedMethod7Callback(const v8::Arguments& args\n {\n     INC_STATS(\""DOM.TestObj.overloadedMethod7\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(RefPtr<DOMStringList>, arrayArg, v8ValueToWebCoreDOMStringList(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     imp->overloadedMethod(arrayArg);\n@@ -1822,7 +1822,7 @@ static v8::Handle<v8::Value> overloadedMethod11Callback(const v8::Arguments& arg\n {\n     INC_STATS(\""DOM.TestObj.overloadedMethod11\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     EXCEPTION_BLOCK(int, arg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     TestObj::overloadedMethod1(arg);\n     return v8::Handle<v8::Value>();\n@@ -1836,7 +1836,7 @@ static v8::Handle<v8::Value> overloadedMethod12Callback(const v8::Arguments& arg\n {\n     INC_STATS(\""DOM.TestObj.overloadedMethod12\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, type, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));\n     TestObj::overloadedMethod1(type);\n     return v8::Handle<v8::Value>();\n@@ -1863,7 +1863,7 @@ static v8::Handle<v8::Value> enabledAtRuntimeMethod1Callback(const v8::Arguments\n {\n     INC_STATS(\""DOM.TestObj.enabledAtRuntimeMethod1\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, intArg, V8int::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8int::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     imp->enabledAtRuntimeMethod1(intArg);\n@@ -1874,7 +1874,7 @@ static v8::Handle<v8::Value> enabledAtRuntimeMethod2Callback(const v8::Arguments\n {\n     INC_STATS(\""DOM.TestObj.enabledAtRuntimeMethod2\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, intArg, V8int::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8int::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     imp->enabledAtRuntimeMethod2(intArg);\n@@ -1903,7 +1903,7 @@ static v8::Handle<v8::Value> convert1Callback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.TestObj.convert1\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(a*, , V8a::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8a::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     imp->convert1();\n@@ -1914,7 +1914,7 @@ static v8::Handle<v8::Value> convert2Callback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.TestObj.convert2\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(b*, , V8b::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8b::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     imp->convert2();\n@@ -1925,7 +1925,7 @@ static v8::Handle<v8::Value> convert3Callback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.TestObj.convert3\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(c*, , V8c::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8c::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     imp->convert3();\n@@ -1936,7 +1936,7 @@ static v8::Handle<v8::Value> convert4Callback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.TestObj.convert4\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(d*, , V8d::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8d::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     imp->convert4();\n@@ -1947,7 +1947,7 @@ static v8::Handle<v8::Value> convert5Callback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.TestObj.convert5\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(e*, , V8e::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8e::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     imp->convert5();\n@@ -1980,7 +1980,7 @@ static v8::Handle<v8::Value> strictFunctionCallback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.TestObj.strictFunction\"");\n     if (args.Length() < 3)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     ExceptionCode ec = 0;\n     {\n@@ -2239,7 +2239,7 @@ v8::Handle<v8::Value> V8TestObj::constructorCallback(const v8::Arguments& args)\n     if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)\n         return args.Holder();\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     if (args.Length() <= 0 || !args[0]->IsFunction())\n         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());\n     RefPtr<TestCallback> testCallback = V8TestCallback::create(args[0], getScriptExecutionContext());""}<_**next**_>{""sha"": ""6a80e6d3be8e04ec2b4cf719ce8751e869b45ef1"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestSerializedScriptValueInterface.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestSerializedScriptValueInterface.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestSerializedScriptValueInterface.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/V8/V8TestSerializedScriptValueInterface.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -124,7 +124,7 @@ static v8::Handle<v8::Value> acceptTransferListCallback(const v8::Arguments& arg\n {\n     INC_STATS(\""DOM.TestSerializedScriptValueInterface.acceptTransferList\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestSerializedScriptValueInterface* imp = V8TestSerializedScriptValueInterface::toNative(args.Holder());\n     MessagePortArray messagePortArrayTransferList;\n     ArrayBufferArray arrayBufferArrayTransferList;\n@@ -218,7 +218,7 @@ v8::Handle<v8::Value> V8TestSerializedScriptValueInterface::constructorCallback(\n     if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)\n         return args.Holder();\n     if (args.Length() < 2)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, hello, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));\n     MessagePortArray messagePortArrayTransferList;\n     ArrayBufferArray arrayBufferArrayTransferList;""}<_**next**_>{""sha"": ""0106704df30b3b5646cb34d63dc0da2731228650"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/v8/ScriptController.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/ScriptController.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/ScriptController.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/v8/ScriptController.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -254,7 +254,7 @@ void ScriptController::bindToWindowObject(Frame* frame, const String& key, NPObj\n static v8::Handle<v8::Value> setValueAndClosePopupCallback(const v8::Arguments& args)\n {\n     if (args.Length() < 2)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     DOMWindow* imp = V8DOMWindow::toNative(args.Data()->ToObject());\n     EXCEPTION_BLOCK(int, intValue, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, stringValue, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));""}<_**next**_>{""sha"": ""362fe5e680936660384714b2f5627c81e2d3b42d"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/v8/V8Proxy.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/V8Proxy.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/V8Proxy.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/v8/V8Proxy.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -636,9 +636,9 @@ v8::Handle<v8::Value> V8Proxy::throwTypeError(const char* message)\n     return throwError(TypeError, (message ? message : \""Type error\""));\n }\n \n-v8::Handle<v8::Value> V8Proxy::throwNotEnoughArgumentsError()\n+v8::Handle<v8::Value> V8Proxy::throwNotEnoughArgumentsError(v8::Isolate* isolate)\n {\n-    return throwError(TypeError, \""Not enough arguments\"");\n+    return throwError(TypeError, \""Not enough arguments\"", isolate);\n }\n \n v8::Local<v8::Context> V8Proxy::context(Frame* frame)""}<_**next**_>{""sha"": ""e05e37637c84bbb2326b6c4100e604fd106e0806"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/v8/V8Proxy.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/V8Proxy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/V8Proxy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/v8/V8Proxy.h?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -240,7 +240,7 @@ namespace WebCore {\n \n         // Helpers for throwing syntax and type errors with predefined messages.\n         static v8::Handle<v8::Value> throwTypeError(const char* = 0);\n-        static v8::Handle<v8::Value> throwNotEnoughArgumentsError();\n+        static v8::Handle<v8::Value> throwNotEnoughArgumentsError(v8::Isolate*);\n \n         v8::Local<v8::Context> context();\n         v8::Local<v8::Context> mainWorldContext();""}<_**next**_>{""sha"": ""771abdd084f643a918f03127a0097ed855bda995"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/v8/custom/V8AudioContextCustom.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8AudioContextCustom.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8AudioContextCustom.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8AudioContextCustom.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -71,7 +71,7 @@ v8::Handle<v8::Value> V8AudioContext::constructorCallback(const v8::Arguments& a\n         // Constructor for offline (render-target) AudioContext which renders into an AudioBuffer.\n         // new AudioContext(in unsigned long numberOfChannels, in unsigned long numberOfFrames, in float sampleRate);\n         if (args.Length() < 3)\n-            return V8Proxy::throwNotEnoughArgumentsError();\n+            return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n         bool ok = false;\n ""}<_**next**_>{""sha"": ""954188e3b9a4e167af97a52dddf0870f72d13800"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/v8/custom/V8DataViewCustom.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8DataViewCustom.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8DataViewCustom.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8DataViewCustom.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -68,7 +68,7 @@ v8::Handle<v8::Value> V8DataView::getInt8Callback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.DataView.getInt8\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     DataView* imp = V8DataView::toNative(args.Holder());\n     ExceptionCode ec = 0;\n@@ -85,7 +85,7 @@ v8::Handle<v8::Value> V8DataView::getUint8Callback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.DataView.getUint8\"");\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     DataView* imp = V8DataView::toNative(args.Holder());\n     ExceptionCode ec = 0;\n@@ -102,7 +102,7 @@ v8::Handle<v8::Value> V8DataView::setInt8Callback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.DataView.setInt8\"");\n     if (args.Length() < 2)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     DataView* imp = V8DataView::toNative(args.Holder());\n     ExceptionCode ec = 0;\n@@ -118,7 +118,7 @@ v8::Handle<v8::Value> V8DataView::setUint8Callback(const v8::Arguments& args)\n {\n     INC_STATS(\""DOM.DataView.setUint8\"");\n     if (args.Length() < 2)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     DataView* imp = V8DataView::toNative(args.Holder());\n     ExceptionCode ec = 0;""}<_**next**_>{""sha"": ""6fe52424f50f7634b40f8f4e5dbf248fd2f3d4c5"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/v8/custom/V8DirectoryEntryCustom.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8DirectoryEntryCustom.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8DirectoryEntryCustom.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8DirectoryEntryCustom.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -51,7 +51,7 @@ v8::Handle<v8::Value> V8DirectoryEntry::getDirectoryCallback(const v8::Arguments\n     DirectoryEntry* imp = V8DirectoryEntry::toNative(args.Holder());\n \n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<WithUndefinedOrNullCheck>, path, args[0]);\n     if (args.Length() <= 1) {\n@@ -95,7 +95,7 @@ v8::Handle<v8::Value> V8DirectoryEntry::getFileCallback(const v8::Arguments& arg\n     DirectoryEntry* imp = V8DirectoryEntry::toNative(args.Holder());\n \n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<WithUndefinedOrNullCheck>, path, args[0]);\n     if (args.Length() <= 1) {""}<_**next**_>{""sha"": ""5c6c0a02522f09b2bb3a181872079f8e5bc537ea"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/v8/custom/V8IntentConstructor.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8IntentConstructor.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8IntentConstructor.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8IntentConstructor.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -53,7 +53,7 @@ v8::Handle<v8::Value> V8Intent::constructorCallback(const v8::Arguments& args)\n     if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)\n         return args.Holder();\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     if (args.Length() == 1) {\n         // Use the dictionary constructor. This block will return if the\n         // argument isn't a valid Dictionary.""}<_**next**_>{""sha"": ""10a0735da4464ec94b5c7127a1771b6c0f79b53c"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/v8/custom/V8SVGLengthCustom.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8SVGLengthCustom.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8SVGLengthCustom.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8SVGLengthCustom.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -90,7 +90,7 @@ v8::Handle<v8::Value> V8SVGLength::convertToSpecifiedUnitsCallback(const v8::Arg\n     }\n \n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     SVGLength& imp = wrapper->propertyReference();\n     ExceptionCode ec = 0;""}<_**next**_>{""sha"": ""ad04f184569c538863b0786cff507e4abf576a06"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/v8/custom/V8WebGLRenderingContextCustom.cpp"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 11, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8WebGLRenderingContextCustom.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8WebGLRenderingContextCustom.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8WebGLRenderingContextCustom.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -217,7 +217,7 @@ enum ObjectType {\n static v8::Handle<v8::Value> getObjectParameter(const v8::Arguments& args, ObjectType objectType)\n {\n     if (args.Length() != 2)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     ExceptionCode ec = 0;\n     WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());\n@@ -269,7 +269,7 @@ v8::Handle<v8::Value> V8WebGLRenderingContext::getAttachedShadersCallback(const\n     INC_STATS(\""DOM.WebGLRenderingContext.getAttachedShaders()\"");\n \n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     ExceptionCode ec = 0;\n     WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());\n@@ -303,7 +303,7 @@ v8::Handle<v8::Value> V8WebGLRenderingContext::getExtensionCallback(const v8::Ar\n     INC_STATS(\""DOM.WebGLRenderingContext.getExtensionCallback()\"");\n     WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());\n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, name, args[0]);\n     WebGLExtension* extension = imp->getExtension(name);\n     return toV8Object(extension, args.Holder(), args.GetIsolate());\n@@ -314,7 +314,7 @@ v8::Handle<v8::Value> V8WebGLRenderingContext::getFramebufferAttachmentParameter\n     INC_STATS(\""DOM.WebGLRenderingContext.getFramebufferAttachmentParameter()\"");\n \n     if (args.Length() != 3)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     ExceptionCode ec = 0;\n     WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());\n@@ -334,7 +334,7 @@ v8::Handle<v8::Value> V8WebGLRenderingContext::getParameterCallback(const v8::Ar\n     INC_STATS(\""DOM.WebGLRenderingContext.getParameter()\"");\n \n     if (args.Length() != 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     ExceptionCode ec = 0;\n     WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());\n@@ -352,7 +352,7 @@ v8::Handle<v8::Value> V8WebGLRenderingContext::getProgramParameterCallback(const\n     INC_STATS(\""DOM.WebGLRenderingContext.getProgramParameter()\"");\n \n     if (args.Length() != 2)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     ExceptionCode ec = 0;\n     WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());\n@@ -381,7 +381,7 @@ v8::Handle<v8::Value> V8WebGLRenderingContext::getShaderParameterCallback(const\n     INC_STATS(\""DOM.WebGLRenderingContext.getShaderParameter()\"");\n \n     if (args.Length() != 2)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     ExceptionCode ec = 0;\n     WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());\n@@ -424,7 +424,7 @@ v8::Handle<v8::Value> V8WebGLRenderingContext::getUniformCallback(const v8::Argu\n     INC_STATS(\""DOM.WebGLRenderingContext.getUniform()\"");\n \n     if (args.Length() != 2)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     ExceptionCode ec = 0;\n     WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());\n@@ -495,7 +495,7 @@ static v8::Handle<v8::Value> vertexAttribAndUniformHelperf(const v8::Arguments&\n     // * glVertexAttrib4fv(GLint index, Float32Array data);\n \n     if (args.Length() != 2)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     bool ok = false;\n     int index = -1;\n@@ -577,7 +577,7 @@ static v8::Handle<v8::Value> uniformHelperi(const v8::Arguments& args,\n     // * glUniform4iv(GLUniformLocation location, Int32Array data);\n \n     if (args.Length() != 2)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());\n     if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLUniformLocation::HasInstance(args[0])) {\n@@ -691,7 +691,7 @@ static v8::Handle<v8::Value> uniformMatrixHelper(const v8::Arguments& args,\n     //\n     // FIXME: need to change to accept Float32Array as well.\n     if (args.Length() != 3)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());\n ""}<_**next**_>{""sha"": ""dd7a5d5e0aee21458f4b9ab82e1b3a083674b39d"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/v8/custom/V8WebKitMutationObserverCustom.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8WebKitMutationObserverCustom.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8WebKitMutationObserverCustom.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8WebKitMutationObserverCustom.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -61,7 +61,7 @@ v8::Handle<v8::Value> V8WebKitMutationObserver::constructorCallback(const v8::Ar\n         return args.Holder();\n \n     if (args.Length() < 1)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     v8::Local<v8::Value> arg = args[0];\n     if (!arg->IsObject())\n@@ -83,7 +83,7 @@ v8::Handle<v8::Value> V8WebKitMutationObserver::observeCallback(const v8::Argume\n {\n     INC_STATS(\""DOM.WebKitMutationObserver.observe\"");\n     if (args.Length() < 2)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     WebKitMutationObserver* imp = V8WebKitMutationObserver::toNative(args.Holder());\n     EXCEPTION_BLOCK(Node*, target, V8Node::HasInstance(args[0]) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(args[0])) : 0);\n ""}<_**next**_>{""sha"": ""0be956f4c94643c79b0d42b750a75774e7e367cd"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/v8/custom/V8WebSocketCustom.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8WebSocketCustom.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8WebSocketCustom.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8WebSocketCustom.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -62,7 +62,7 @@ v8::Handle<v8::Value> V8WebSocket::constructorCallback(const v8::Arguments& args\n         return args.Holder();\n \n     if (args.Length() == 0)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     v8::TryCatch tryCatch;\n     v8::Handle<v8::String> urlstring = args[0]->ToString();\n@@ -117,7 +117,7 @@ v8::Handle<v8::Value> V8WebSocket::sendCallback(const v8::Arguments& args)\n     INC_STATS(\""DOM.WebSocket.send()\"");\n \n     if (!args.Length())\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     WebSocket* webSocket = V8WebSocket::toNative(args.Holder());\n     v8::Handle<v8::Value> message = args[0];""}<_**next**_>{""sha"": ""66163ba5eac39ed3ab5e88a62cd18f8109aba49e"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/v8/custom/V8XMLHttpRequestCustom.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8XMLHttpRequestCustom.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e9372a1bfd3588a80fcf49aa07321f0971dd6091/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8XMLHttpRequestCustom.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/v8/custom/V8XMLHttpRequestCustom.cpp?ref=e9372a1bfd3588a80fcf49aa07321f0971dd6091"", ""patch"": ""@@ -121,7 +121,7 @@ v8::Handle<v8::Value> V8XMLHttpRequest::openCallback(const v8::Arguments& args)\n     // open(method, url, async, user, passwd)\n \n     if (args.Length() < 2)\n-        return V8Proxy::throwNotEnoughArgumentsError();\n+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n \n     XMLHttpRequest* xmlHttpRequest = V8XMLHttpRequest::toNative(args.Holder());\n ""}",        return V8Proxy::throwNotEnoughArgumentsError();,4,"static v8::Handle<v8::Value> methodWithNonCallbackArgAndCallbackArgCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.methodWithNonCallbackArgAndCallbackArg"");
     if (args.Length() < 2)
        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, nonCallback, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     if (args.Length() <= 1 || !args[1]->IsFunction())
        return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
    RefPtr<TestCallback> callback = V8TestCallback::create(args[1], getScriptExecutionContext());
    imp->methodWithNonCallbackArgAndCallbackArg(nonCallback, callback);
    return v8::Handle<v8::Value>();
}
","static v8::Handle<v8::Value> methodWithNonCallbackArgAndCallbackArgCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.methodWithNonCallbackArgAndCallbackArg"");
     if (args.Length() < 2)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, nonCallback, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     if (args.Length() <= 1 || !args[1]->IsFunction())
        return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
    RefPtr<TestCallback> callback = V8TestCallback::create(args[1], getScriptExecutionContext());
    imp->methodWithNonCallbackArgAndCallbackArg(nonCallback, callback);
    return v8::Handle<v8::Value>();
}
",184781.0,C,"        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
","        return V8Proxy::throwNotEnoughArgumentsError();
",,"@@ -1230,7 +1230,7 @@ static v8::Handle<v8::Value> voidMethodWithArgsCallback(const v8::Arguments& arg
 {
     INC_STATS(""DOM.TestObj.voidMethodWithArgs"");
     if (args.Length() < 3)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
@@ -1250,7 +1250,7 @@ static v8::Handle<v8::Value> intMethodWithArgsCallback(const v8::Arguments& args
 {
     INC_STATS(""DOM.TestObj.intMethodWithArgs"");
     if (args.Length() < 3)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
@@ -1269,7 +1269,7 @@ static v8::Handle<v8::Value> objMethodWithArgsCallback(const v8::Arguments& args
 {
     INC_STATS(""DOM.TestObj.objMethodWithArgs"");
     if (args.Length() < 3)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
@@ -1281,7 +1281,7 @@ static v8::Handle<v8::Value> methodWithSequenceArgCallback(const v8::Arguments&
 {
     INC_STATS(""DOM.TestObj.methodWithSequenceArg"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(sequence<ScriptProfile>*, sequenceArg, toNativeArray<ScriptProfile>(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     imp->methodWithSequenceArg(sequenceArg);
@@ -1292,7 +1292,7 @@ static v8::Handle<v8::Value> methodReturningSequenceCallback(const v8::Arguments
 {
     INC_STATS(""DOM.TestObj.methodReturningSequence"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     return v8Array(imp->methodReturningSequence(intArg), args.GetIsolate());
@@ -1302,7 +1302,7 @@ static v8::Handle<v8::Value> methodThatRequiresAllArgsAndThrowsCallback(const v8
 {
     INC_STATS(""DOM.TestObj.methodThatRequiresAllArgsAndThrows"");
     if (args.Length() < 2)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     ExceptionCode ec = 0;
     {
@@ -1322,7 +1322,7 @@ static v8::Handle<v8::Value> serializedValueCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.serializedValue"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     bool serializedArgDidThrow = false;
     RefPtr<SerializedScriptValue> serializedArg = SerializedScriptValue::create(args[0], 0, 0, serializedArgDidThrow, args.GetIsolate());
@@ -1336,7 +1336,7 @@ static v8::Handle<v8::Value> idbKeyCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.idbKey"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(RefPtr<IDBKey>, key, createIDBKeyFromValue(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     imp->idbKey(key.get());
@@ -1347,7 +1347,7 @@ static v8::Handle<v8::Value> optionsObjectCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.optionsObject"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(Dictionary, oo, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
     if (args.Length() > 0 && !oo.isUndefinedOrNull() && !oo.isObject()) {
@@ -1553,7 +1553,7 @@ static v8::Handle<v8::Value> methodWithNonOptionalArgAndOptionalArgCallback(cons
 {
     INC_STATS(""DOM.TestObj.methodWithNonOptionalArgAndOptionalArg"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, nonOpt, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     if (args.Length() <= 1) {
@@ -1569,7 +1569,7 @@ static v8::Handle<v8::Value> methodWithNonOptionalArgAndTwoOptionalArgsCallback(
 {
     INC_STATS(""DOM.TestObj.methodWithNonOptionalArgAndTwoOptionalArgs"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, nonOpt, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     if (args.Length() <= 1) {
@@ -1621,7 +1621,7 @@ static v8::Handle<v8::Value> methodWithCallbackArgCallback(const v8::Arguments&
 {
     INC_STATS(""DOM.TestObj.methodWithCallbackArg"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     if (args.Length() <= 0 || !args[0]->IsFunction())
         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
@@ -1634,7 +1634,7 @@ static v8::Handle<v8::Value> methodWithNonCallbackArgAndCallbackArgCallback(cons
 {
     INC_STATS(""DOM.TestObj.methodWithNonCallbackArgAndCallbackArg"");
     if (args.Length() < 2)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, nonCallback, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     if (args.Length() <= 1 || !args[1]->IsFunction())
@@ -1697,7 +1697,7 @@ static v8::Handle<v8::Value> overloadedMethod1Callback(const v8::Arguments& args
 {
     INC_STATS(""DOM.TestObj.overloadedMethod1"");
     if (args.Length() < 2)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(TestObj*, objArg, V8TestObj::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
@@ -1709,7 +1709,7 @@ static v8::Handle<v8::Value> overloadedMethod2Callback(const v8::Arguments& args
 {
     INC_STATS(""DOM.TestObj.overloadedMethod2"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(TestObj*, objArg, V8TestObj::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
     if (args.Length() <= 1) {
@@ -1725,7 +1725,7 @@ static v8::Handle<v8::Value> overloadedMethod3Callback(const v8::Arguments& args
 {
     INC_STATS(""DOM.TestObj.overloadedMethod3"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
     imp->overloadedMethod(strArg);
@@ -1736,7 +1736,7 @@ static v8::Handle<v8::Value> overloadedMethod4Callback(const v8::Arguments& args
 {
     INC_STATS(""DOM.TestObj.overloadedMethod4"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     imp->overloadedMethod(intArg);
@@ -1747,7 +1747,7 @@ static v8::Handle<v8::Value> overloadedMethod5Callback(const v8::Arguments& args
 {
     INC_STATS(""DOM.TestObj.overloadedMethod5"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     if (args.Length() <= 0 || !args[0]->IsFunction())
         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
@@ -1760,7 +1760,7 @@ static v8::Handle<v8::Value> overloadedMethod6Callback(const v8::Arguments& args
 {
     INC_STATS(""DOM.TestObj.overloadedMethod6"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(RefPtr<DOMStringList>, listArg, v8ValueToWebCoreDOMStringList(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     imp->overloadedMethod(listArg);
@@ -1771,7 +1771,7 @@ static v8::Handle<v8::Value> overloadedMethod7Callback(const v8::Arguments& args
 {
     INC_STATS(""DOM.TestObj.overloadedMethod7"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(RefPtr<DOMStringList>, arrayArg, v8ValueToWebCoreDOMStringList(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     imp->overloadedMethod(arrayArg);
@@ -1822,7 +1822,7 @@ static v8::Handle<v8::Value> overloadedMethod11Callback(const v8::Arguments& arg
 {
     INC_STATS(""DOM.TestObj.overloadedMethod11"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     EXCEPTION_BLOCK(int, arg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     TestObj::overloadedMethod1(arg);
     return v8::Handle<v8::Value>();
@@ -1836,7 +1836,7 @@ static v8::Handle<v8::Value> overloadedMethod12Callback(const v8::Arguments& arg
 {
     INC_STATS(""DOM.TestObj.overloadedMethod12"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, type, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
     TestObj::overloadedMethod1(type);
     return v8::Handle<v8::Value>();
@@ -1863,7 +1863,7 @@ static v8::Handle<v8::Value> enabledAtRuntimeMethod1Callback(const v8::Arguments
 {
     INC_STATS(""DOM.TestObj.enabledAtRuntimeMethod1"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, intArg, V8int::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8int::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
     imp->enabledAtRuntimeMethod1(intArg);
@@ -1874,7 +1874,7 @@ static v8::Handle<v8::Value> enabledAtRuntimeMethod2Callback(const v8::Arguments
 {
     INC_STATS(""DOM.TestObj.enabledAtRuntimeMethod2"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, intArg, V8int::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8int::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
     imp->enabledAtRuntimeMethod2(intArg);
@@ -1903,7 +1903,7 @@ static v8::Handle<v8::Value> convert1Callback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.convert1"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(a*, , V8a::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8a::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
     imp->convert1();
@@ -1914,7 +1914,7 @@ static v8::Handle<v8::Value> convert2Callback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.convert2"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(b*, , V8b::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8b::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
     imp->convert2();
@@ -1925,7 +1925,7 @@ static v8::Handle<v8::Value> convert3Callback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.convert3"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(c*, , V8c::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8c::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
     imp->convert3();
@@ -1936,7 +1936,7 @@ static v8::Handle<v8::Value> convert4Callback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.convert4"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(d*, , V8d::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8d::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
     imp->convert4();
@@ -1947,7 +1947,7 @@ static v8::Handle<v8::Value> convert5Callback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.convert5"");
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(e*, , V8e::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8e::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
     imp->convert5();
@@ -1980,7 +1980,7 @@ static v8::Handle<v8::Value> strictFunctionCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.strictFunction"");
     if (args.Length() < 3)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     ExceptionCode ec = 0;
     {
@@ -2239,7 +2239,7 @@ v8::Handle<v8::Value> V8TestObj::constructorCallback(const v8::Arguments& args)
     if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)
         return args.Holder();
     if (args.Length() < 1)
-        return V8Proxy::throwNotEnoughArgumentsError();
+        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     if (args.Length() <= 0 || !args[0]->IsFunction())
         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
     RefPtr<TestCallback> testCallback = V8TestCallback::create(args[0], getScriptExecutionContext());","static v8::Handle<v8::Value> methodWithNonCallbackArgAndCallbackArgCallback(const v8::Arguments& args)
{
INC_STATS(""DOM.TestObj.methodWithNonCallbackArgAndCallbackArg"");
if (args.Length() < 2)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(int, nonCallback, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
if (args.Length() <= 1 || !args[1]->IsFunction())
return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
RefPtr<TestCallback> callback = V8TestCallback::create(args[1], getScriptExecutionContext());
imp->methodWithNonCallbackArgAndCallbackArg(nonCallback, callback);
return v8::Handle<v8::Value>();
}
",Chrome,e9372a1bfd3588a80fcf49aa07321f0971dd6091,ab5ba409a8d61d35b5202888defb10a57679b9d2,1.0,"static v8::Handle<v8::Value> methodWithNonCallbackArgAndCallbackArgCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.methodWithNonCallbackArgAndCallbackArg"");
     if (args.Length() < 2)
//flaw_line_below:
        return V8Proxy::throwNotEnoughArgumentsError();
//fix_flaw_line_below:
//        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, nonCallback, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     if (args.Length() <= 1 || !args[1]->IsFunction())
        return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
    RefPtr<TestCallback> callback = V8TestCallback::create(args[1], getScriptExecutionContext());
    imp->methodWithNonCallbackArgAndCallbackArg(nonCallback, callback);
    return v8::Handle<v8::Value>();
}
"
54,None,Remote,Not required,Partial,CVE-2012-5152,https://www.cvedetails.com/cve/CVE-2012-5152/,CWE-119,Low,None,None,,2013-01-15,5.0,Google Chrome before 24.0.1312.52 allows remote attackers to cause a denial of service (out-of-bounds read) via vectors involving seek operations on video data.,2018-10-30,DoS Overflow ,0.0,https://github.com/chromium/chromium/commit/802ecdb9cee0d66fe546bdf24e98150f8f716ad8,802ecdb9cee0d66fe546bdf24e98150f8f716ad8,"Protect AudioRendererAlgorithm from invalid step sizes.

BUG=165430
TEST=unittests and asan pass.

Review URL: https://codereview.chromium.org/11573023

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@173249 0039d316-1c4b-4281-b951-d872f2087c98",18.0,media/filters/audio_renderer_algorithm_unittest.cc,"{""sha"": ""9e84b9b885494d5ce667596772e100137b5cd1f7"", ""filename"": ""media/filters/audio_renderer_algorithm.cc"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 17, ""changes"": 40, ""blob_url"": ""https://github.com/chromium/chromium/blob/802ecdb9cee0d66fe546bdf24e98150f8f716ad8/media/filters/audio_renderer_algorithm.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/802ecdb9cee0d66fe546bdf24e98150f8f716ad8/media/filters/audio_renderer_algorithm.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/filters/audio_renderer_algorithm.cc?ref=802ecdb9cee0d66fe546bdf24e98150f8f716ad8"", ""patch"": ""@@ -83,19 +83,27 @@ int AudioRendererAlgorithm::FillBuffer(\n   if (playback_rate_ == 0.0f)\n     return 0;\n \n+  int slower_step = ceil(window_size_ * playback_rate_);\n+  int faster_step = ceil(window_size_ / playback_rate_);\n+  AlignToFrameBoundary(&slower_step);\n+  AlignToFrameBoundary(&faster_step);\n+\n   int total_frames_rendered = 0;\n   uint8* output_ptr = dest;\n   while (total_frames_rendered < requested_frames) {\n     if (index_into_window_ == window_size_)\n       ResetWindow();\n \n     bool rendered_frame = true;\n-    if (playback_rate_ > 1.0)\n-      rendered_frame = OutputFasterPlayback(output_ptr);\n-    else if (playback_rate_ < 1.0)\n-      rendered_frame = OutputSlowerPlayback(output_ptr);\n-    else\n+    if (window_size_ > faster_step) {\n+      rendered_frame = OutputFasterPlayback(\n+          output_ptr, window_size_, faster_step);\n+    } else if (slower_step < window_size_) {\n+      rendered_frame = OutputSlowerPlayback(\n+          output_ptr, slower_step, window_size_);\n+    } else {\n       rendered_frame = OutputNormalPlayback(output_ptr);\n+    }\n \n     if (!rendered_frame) {\n       needs_more_data_ = true;\n@@ -114,7 +122,11 @@ void AudioRendererAlgorithm::ResetWindow() {\n   crossfade_frame_number_ = 0;\n }\n \n-bool AudioRendererAlgorithm::OutputFasterPlayback(uint8* dest) {\n+bool AudioRendererAlgorithm::OutputFasterPlayback(uint8* dest,\n+                                                  int input_step,\n+                                                  int output_step) {\n+  // Ensure we don't run into OOB read/write situation.\n+  CHECK_GT(input_step, output_step);\n   DCHECK_LT(index_into_window_, window_size_);\n   DCHECK_GT(playback_rate_, 1.0);\n \n@@ -131,11 +143,6 @@ bool AudioRendererAlgorithm::OutputFasterPlayback(uint8* dest) {\n   //\n   // The duration of each phase is computed below based on the |window_size_|\n   // and |playback_rate_|.\n-  int input_step = window_size_;\n-  int output_step = ceil(window_size_ / playback_rate_);\n-  AlignToFrameBoundary(&output_step);\n-  DCHECK_GT(input_step, output_step);\n-\n   int bytes_to_crossfade = bytes_in_crossfade_;\n   if (muted_ || bytes_to_crossfade > output_step)\n     bytes_to_crossfade = 0;\n@@ -203,7 +210,11 @@ bool AudioRendererAlgorithm::OutputFasterPlayback(uint8* dest) {\n   return true;\n }\n \n-bool AudioRendererAlgorithm::OutputSlowerPlayback(uint8* dest) {\n+bool AudioRendererAlgorithm::OutputSlowerPlayback(uint8* dest,\n+                                                  int input_step,\n+                                                  int output_step) {\n+  // Ensure we don't run into OOB read/write situation.\n+  CHECK_LT(input_step, output_step);\n   DCHECK_LT(index_into_window_, window_size_);\n   DCHECK_LT(playback_rate_, 1.0);\n   DCHECK_NE(playback_rate_, 0.0);\n@@ -224,11 +235,6 @@ bool AudioRendererAlgorithm::OutputSlowerPlayback(uint8* dest) {\n   //\n   // The duration of each phase is computed below based on the |window_size_|\n   // and |playback_rate_|.\n-  int input_step = ceil(window_size_ * playback_rate_);\n-  AlignToFrameBoundary(&input_step);\n-  int output_step = window_size_;\n-  DCHECK_LT(input_step, output_step);\n-\n   int bytes_to_crossfade = bytes_in_crossfade_;\n   if (muted_ || bytes_to_crossfade > input_step)\n     bytes_to_crossfade = 0;""}<_**next**_>{""sha"": ""080a11d2bee20c8100e79644d9036c39525314bb"", ""filename"": ""media/filters/audio_renderer_algorithm.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/802ecdb9cee0d66fe546bdf24e98150f8f716ad8/media/filters/audio_renderer_algorithm.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/802ecdb9cee0d66fe546bdf24e98150f8f716ad8/media/filters/audio_renderer_algorithm.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/filters/audio_renderer_algorithm.h?ref=802ecdb9cee0d66fe546bdf24e98150f8f716ad8"", ""patch"": ""@@ -88,6 +88,8 @@ class MEDIA_EXPORT AudioRendererAlgorithm {\n \n   int bytes_per_channel() { return bytes_per_channel_; }\n \n+  int samples_per_second() { return samples_per_second_; }\n+\n   bool is_muted() { return muted_; }\n \n  private:\n@@ -103,7 +105,7 @@ class MEDIA_EXPORT AudioRendererAlgorithm {\n   // data at normal speed, then we \""fast forward\"" by dropping the next bit of\n   // audio data, and then we stich the pieces together by crossfading from one\n   // audio chunk to the next.\n-  bool OutputFasterPlayback(uint8* dest);\n+  bool OutputFasterPlayback(uint8* dest, int input_step, int output_step);\n \n   // Fills |dest| with one frame of audio data at slower than normal speed.\n   // Returns true if a frame was rendered, false otherwise.\n@@ -114,7 +116,7 @@ class MEDIA_EXPORT AudioRendererAlgorithm {\n   // by repeating some of the audio data from the previous audio segment.\n   // Segments are stiched together by crossfading from one audio chunk to the\n   // next.\n-  bool OutputSlowerPlayback(uint8* dest);\n+  bool OutputSlowerPlayback(uint8* dest, int input_step, int output_step);\n \n   // Resets the window state to the start of a new window.\n   void ResetWindow();""}<_**next**_>{""sha"": ""33e2fd001e83cf2ddf806896f497abc00c6a3caa"", ""filename"": ""media/filters/audio_renderer_algorithm_unittest.cc"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 61, ""changes"": 103, ""blob_url"": ""https://github.com/chromium/chromium/blob/802ecdb9cee0d66fe546bdf24e98150f8f716ad8/media/filters/audio_renderer_algorithm_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/802ecdb9cee0d66fe546bdf24e98150f8f716ad8/media/filters/audio_renderer_algorithm_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/filters/audio_renderer_algorithm_unittest.cc?ref=802ecdb9cee0d66fe546bdf24e98150f8f716ad8"", ""patch"": ""@@ -19,8 +19,8 @@\n \n namespace media {\n \n-static const size_t kRawDataSize = 10 * 1024;\n-static const int kSamplesPerSecond = 44100;\n+static const size_t kRawDataSize = 2048;\n+static const int kSamplesPerSecond = 3000;\n static const ChannelLayout kDefaultChannelLayout = CHANNEL_LAYOUT_STEREO;\n static const int kDefaultSampleBits = 16;\n \n@@ -33,13 +33,16 @@ class AudioRendererAlgorithmTest : public testing::Test {\n   ~AudioRendererAlgorithmTest() {}\n \n   void Initialize() {\n-    Initialize(kDefaultChannelLayout, kDefaultSampleBits);\n+    Initialize(kDefaultChannelLayout, kDefaultSampleBits, kSamplesPerSecond);\n   }\n \n-  void Initialize(ChannelLayout channel_layout, int bits_per_channel) {\n+  void Initialize(ChannelLayout channel_layout, int bits_per_channel,\n+                  int samples_per_second) {\n+    static const int kFrames = kRawDataSize / ((kDefaultSampleBits / 8) *\n+        ChannelLayoutToChannelCount(kDefaultChannelLayout));\n     AudioParameters params(\n         media::AudioParameters::AUDIO_PCM_LINEAR, channel_layout,\n-        kSamplesPerSecond, bits_per_channel, kRawDataSize);\n+        samples_per_second, bits_per_channel, kFrames);\n \n     algorithm_.Initialize(1, params, base::Bind(\n         &AudioRendererAlgorithmTest::EnqueueData, base::Unretained(this)));\n@@ -50,61 +53,22 @@ class AudioRendererAlgorithmTest : public testing::Test {\n     scoped_array<uint8> audio_data(new uint8[kRawDataSize]);\n     CHECK_EQ(kRawDataSize % algorithm_.bytes_per_channel(), 0u);\n     CHECK_EQ(kRawDataSize % algorithm_.bytes_per_frame(), 0u);\n-    size_t length = kRawDataSize / algorithm_.bytes_per_channel();\n-    switch (algorithm_.bytes_per_channel()) {\n-      case 4:\n-        WriteFakeData<int32>(audio_data.get(), length);\n-        break;\n-      case 2:\n-        WriteFakeData<int16>(audio_data.get(), length);\n-        break;\n-      case 1:\n-        WriteFakeData<uint8>(audio_data.get(), length);\n-        break;\n-      default:\n-        NOTREACHED() << \""Unsupported audio bit depth in crossfade.\"";\n-    }\n+    // The value of the data is meaningless; we just want non-zero data to\n+    // differentiate it from muted data.\n+    memset(audio_data.get(), 1, kRawDataSize);\n     algorithm_.EnqueueBuffer(new DataBuffer(audio_data.Pass(), kRawDataSize));\n     bytes_enqueued_ += kRawDataSize;\n   }\n \n-  template <class Type>\n-  void WriteFakeData(uint8* audio_data, size_t length) {\n-    Type* output = reinterpret_cast<Type*>(audio_data);\n-    for (size_t i = 0; i < length; i++) {\n-      // The value of the data is meaningless; we just want non-zero data to\n-      // differentiate it from muted data.\n-      output[i] = i % 5 + 10;\n-    }\n-  }\n+  void CheckFakeData(uint8* audio_data, int frames_written) {\n+    int sum = 0;\n+    for (int i = 0; i < frames_written * algorithm_.bytes_per_frame(); ++i)\n+      sum |= audio_data[i];\n \n-  void CheckFakeData(uint8* audio_data, int frames_written,\n-                     double playback_rate) {\n-    size_t length =\n-        (frames_written * algorithm_.bytes_per_frame())\n-        / algorithm_.bytes_per_channel();\n-\n-    switch (algorithm_.bytes_per_channel()) {\n-      case 4:\n-        DoCheckFakeData<int32>(audio_data, length);\n-        break;\n-      case 2:\n-        DoCheckFakeData<int16>(audio_data, length);\n-        break;\n-      case 1:\n-        DoCheckFakeData<uint8>(audio_data, length);\n-        break;\n-      default:\n-        NOTREACHED() << \""Unsupported audio bit depth in crossfade.\"";\n-    }\n-  }\n-\n-  template <class Type>\n-  void DoCheckFakeData(uint8* audio_data, size_t length) {\n-    Type* output = reinterpret_cast<Type*>(audio_data);\n-    for (size_t i = 0; i < length; i++) {\n-      EXPECT_TRUE(algorithm_.is_muted() || output[i] != 0);\n-    }\n+    if (algorithm_.is_muted())\n+      ASSERT_EQ(sum, 0);\n+    else\n+      ASSERT_NE(sum, 0);\n   }\n \n   int ComputeConsumedBytes(int initial_bytes_enqueued,\n@@ -117,8 +81,8 @@ class AudioRendererAlgorithmTest : public testing::Test {\n   }\n \n   void TestPlaybackRate(double playback_rate) {\n-    static const int kDefaultBufferSize = kSamplesPerSecond / 10;\n-    static const int kDefaultFramesRequested = 5 * kSamplesPerSecond;\n+    const int kDefaultBufferSize = algorithm_.samples_per_second() / 10;\n+    const int kDefaultFramesRequested = 2 * algorithm_.samples_per_second();\n \n     TestPlaybackRate(playback_rate, kDefaultBufferSize,\n                      kDefaultFramesRequested);\n@@ -147,8 +111,8 @@ class AudioRendererAlgorithmTest : public testing::Test {\n       int frames_requested = std::min(buffer_size_in_frames, frames_remaining);\n       int frames_written =\n           algorithm_.FillBuffer(buffer.get(), frames_requested);\n-      CHECK_GT(frames_written, 0);\n-      CheckFakeData(buffer.get(), frames_written, playback_rate);\n+      ASSERT_GT(frames_written, 0);\n+      CheckFakeData(buffer.get(), frames_written);\n       frames_remaining -= frames_written;\n     }\n \n@@ -191,6 +155,16 @@ TEST_F(AudioRendererAlgorithmTest, FillBuffer_NormalRate) {\n   TestPlaybackRate(1.0);\n }\n \n+TEST_F(AudioRendererAlgorithmTest, FillBuffer_NearlyNormalFasterRate) {\n+  Initialize();\n+  TestPlaybackRate(1.0001);\n+}\n+\n+TEST_F(AudioRendererAlgorithmTest, FillBuffer_NearlyNormalSlowerRate) {\n+  Initialize();\n+  TestPlaybackRate(0.9999);\n+}\n+\n TEST_F(AudioRendererAlgorithmTest, FillBuffer_OneAndAQuarterRate) {\n   Initialize();\n   TestPlaybackRate(1.25);\n@@ -269,10 +243,17 @@ TEST_F(AudioRendererAlgorithmTest, FillBuffer_SmallBufferSize) {\n   TestPlaybackRate(1.5, kBufferSizeInFrames, kFramesRequested);\n }\n \n+TEST_F(AudioRendererAlgorithmTest, FillBuffer_LargeBufferSize) {\n+  Initialize(kDefaultChannelLayout, kDefaultSampleBits, 44100);\n+  TestPlaybackRate(1.0);\n+  TestPlaybackRate(0.5);\n+  TestPlaybackRate(1.5);\n+}\n+\n TEST_F(AudioRendererAlgorithmTest, FillBuffer_LowerQualityAudio) {\n   static const ChannelLayout kChannelLayout = CHANNEL_LAYOUT_MONO;\n   static const int kSampleBits = 8;\n-  Initialize(kChannelLayout, kSampleBits);\n+  Initialize(kChannelLayout, kSampleBits, kSamplesPerSecond);\n   TestPlaybackRate(1.0);\n   TestPlaybackRate(0.5);\n   TestPlaybackRate(1.5);\n@@ -281,7 +262,7 @@ TEST_F(AudioRendererAlgorithmTest, FillBuffer_LowerQualityAudio) {\n TEST_F(AudioRendererAlgorithmTest, FillBuffer_HigherQualityAudio) {\n   static const ChannelLayout kChannelLayout = CHANNEL_LAYOUT_STEREO;\n   static const int kSampleBits = 32;\n-  Initialize(kChannelLayout, kSampleBits);\n+  Initialize(kChannelLayout, kSampleBits, kSamplesPerSecond);\n   TestPlaybackRate(1.0);\n   TestPlaybackRate(0.5);\n   TestPlaybackRate(1.5);""}","                     double playback_rate) {/~/    size_t length =/~/        (frames_written * algorithm_.bytes_per_frame())/~/        / algorithm_.bytes_per_channel();/~/    switch (algorithm_.bytes_per_channel()) {/~/      case 4:/~/        DoCheckFakeData<int32>(audio_data, length);/~/        break;/~/      case 2:/~/        DoCheckFakeData<int16>(audio_data, length);/~/        break;/~/      case 1:/~/        DoCheckFakeData<uint8>(audio_data, length);/~/        break;/~/      default:/~/        NOTREACHED() << ""Unsupported audio bit depth in crossfade."";/~/    }/~/  }","1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18","  void CheckFakeData(uint8* audio_data, int frames_written,
","  void CheckFakeData(uint8* audio_data, int frames_written,
                     double playback_rate) {
    size_t length =
        (frames_written * algorithm_.bytes_per_frame())
        / algorithm_.bytes_per_channel();
    switch (algorithm_.bytes_per_channel()) {
      case 4:
        DoCheckFakeData<int32>(audio_data, length);
        break;
      case 2:
        DoCheckFakeData<int16>(audio_data, length);
        break;
      case 1:
        DoCheckFakeData<uint8>(audio_data, length);
        break;
      default:
        NOTREACHED() << ""Unsupported audio bit depth in crossfade."";
    }
  }
",185233.0,C,,"                     double playback_rate) {
    size_t length =
        (frames_written * algorithm_.bytes_per_frame())
        / algorithm_.bytes_per_channel();
    switch (algorithm_.bytes_per_channel()) {
      case 4:
        DoCheckFakeData<int32>(audio_data, length);
        break;
      case 2:
        DoCheckFakeData<int16>(audio_data, length);
        break;
      case 1:
        DoCheckFakeData<uint8>(audio_data, length);
        break;
      default:
        NOTREACHED() << ""Unsupported audio bit depth in crossfade."";
    }
  }
",,"@@ -19,8 +19,8 @@
 
 namespace media {
 
-static const size_t kRawDataSize = 10 * 1024;
-static const int kSamplesPerSecond = 44100;
+static const size_t kRawDataSize = 2048;
+static const int kSamplesPerSecond = 3000;
 static const ChannelLayout kDefaultChannelLayout = CHANNEL_LAYOUT_STEREO;
 static const int kDefaultSampleBits = 16;
 
@@ -33,13 +33,16 @@ class AudioRendererAlgorithmTest : public testing::Test {
   ~AudioRendererAlgorithmTest() {}
 
   void Initialize() {
-    Initialize(kDefaultChannelLayout, kDefaultSampleBits);
+    Initialize(kDefaultChannelLayout, kDefaultSampleBits, kSamplesPerSecond);
   }
 
-  void Initialize(ChannelLayout channel_layout, int bits_per_channel) {
+  void Initialize(ChannelLayout channel_layout, int bits_per_channel,
+                  int samples_per_second) {
+    static const int kFrames = kRawDataSize / ((kDefaultSampleBits / 8) *
+        ChannelLayoutToChannelCount(kDefaultChannelLayout));
     AudioParameters params(
         media::AudioParameters::AUDIO_PCM_LINEAR, channel_layout,
-        kSamplesPerSecond, bits_per_channel, kRawDataSize);
+        samples_per_second, bits_per_channel, kFrames);
 
     algorithm_.Initialize(1, params, base::Bind(
         &AudioRendererAlgorithmTest::EnqueueData, base::Unretained(this)));
@@ -50,61 +53,22 @@ class AudioRendererAlgorithmTest : public testing::Test {
     scoped_array<uint8> audio_data(new uint8[kRawDataSize]);
     CHECK_EQ(kRawDataSize % algorithm_.bytes_per_channel(), 0u);
     CHECK_EQ(kRawDataSize % algorithm_.bytes_per_frame(), 0u);
-    size_t length = kRawDataSize / algorithm_.bytes_per_channel();
-    switch (algorithm_.bytes_per_channel()) {
-      case 4:
-        WriteFakeData<int32>(audio_data.get(), length);
-        break;
-      case 2:
-        WriteFakeData<int16>(audio_data.get(), length);
-        break;
-      case 1:
-        WriteFakeData<uint8>(audio_data.get(), length);
-        break;
-      default:
-        NOTREACHED() << ""Unsupported audio bit depth in crossfade."";
-    }
+    // The value of the data is meaningless; we just want non-zero data to
+    // differentiate it from muted data.
+    memset(audio_data.get(), 1, kRawDataSize);
     algorithm_.EnqueueBuffer(new DataBuffer(audio_data.Pass(), kRawDataSize));
     bytes_enqueued_ += kRawDataSize;
   }
 
-  template <class Type>
-  void WriteFakeData(uint8* audio_data, size_t length) {
-    Type* output = reinterpret_cast<Type*>(audio_data);
-    for (size_t i = 0; i < length; i++) {
-      // The value of the data is meaningless; we just want non-zero data to
-      // differentiate it from muted data.
-      output[i] = i % 5 + 10;
-    }
-  }
+  void CheckFakeData(uint8* audio_data, int frames_written) {
+    int sum = 0;
+    for (int i = 0; i < frames_written * algorithm_.bytes_per_frame(); ++i)
+      sum |= audio_data[i];
 
-  void CheckFakeData(uint8* audio_data, int frames_written,
-                     double playback_rate) {
-    size_t length =
-        (frames_written * algorithm_.bytes_per_frame())
-        / algorithm_.bytes_per_channel();
-
-    switch (algorithm_.bytes_per_channel()) {
-      case 4:
-        DoCheckFakeData<int32>(audio_data, length);
-        break;
-      case 2:
-        DoCheckFakeData<int16>(audio_data, length);
-        break;
-      case 1:
-        DoCheckFakeData<uint8>(audio_data, length);
-        break;
-      default:
-        NOTREACHED() << ""Unsupported audio bit depth in crossfade."";
-    }
-  }
-
-  template <class Type>
-  void DoCheckFakeData(uint8* audio_data, size_t length) {
-    Type* output = reinterpret_cast<Type*>(audio_data);
-    for (size_t i = 0; i < length; i++) {
-      EXPECT_TRUE(algorithm_.is_muted() || output[i] != 0);
-    }
+    if (algorithm_.is_muted())
+      ASSERT_EQ(sum, 0);
+    else
+      ASSERT_NE(sum, 0);
   }
 
   int ComputeConsumedBytes(int initial_bytes_enqueued,
@@ -117,8 +81,8 @@ class AudioRendererAlgorithmTest : public testing::Test {
   }
 
   void TestPlaybackRate(double playback_rate) {
-    static const int kDefaultBufferSize = kSamplesPerSecond / 10;
-    static const int kDefaultFramesRequested = 5 * kSamplesPerSecond;
+    const int kDefaultBufferSize = algorithm_.samples_per_second() / 10;
+    const int kDefaultFramesRequested = 2 * algorithm_.samples_per_second();
 
     TestPlaybackRate(playback_rate, kDefaultBufferSize,
                      kDefaultFramesRequested);
@@ -147,8 +111,8 @@ class AudioRendererAlgorithmTest : public testing::Test {
       int frames_requested = std::min(buffer_size_in_frames, frames_remaining);
       int frames_written =
           algorithm_.FillBuffer(buffer.get(), frames_requested);
-      CHECK_GT(frames_written, 0);
-      CheckFakeData(buffer.get(), frames_written, playback_rate);
+      ASSERT_GT(frames_written, 0);
+      CheckFakeData(buffer.get(), frames_written);
       frames_remaining -= frames_written;
     }
 
@@ -191,6 +155,16 @@ TEST_F(AudioRendererAlgorithmTest, FillBuffer_NormalRate) {
   TestPlaybackRate(1.0);
 }
 
+TEST_F(AudioRendererAlgorithmTest, FillBuffer_NearlyNormalFasterRate) {
+  Initialize();
+  TestPlaybackRate(1.0001);
+}
+
+TEST_F(AudioRendererAlgorithmTest, FillBuffer_NearlyNormalSlowerRate) {
+  Initialize();
+  TestPlaybackRate(0.9999);
+}
+
 TEST_F(AudioRendererAlgorithmTest, FillBuffer_OneAndAQuarterRate) {
   Initialize();
   TestPlaybackRate(1.25);
@@ -269,10 +243,17 @@ TEST_F(AudioRendererAlgorithmTest, FillBuffer_SmallBufferSize) {
   TestPlaybackRate(1.5, kBufferSizeInFrames, kFramesRequested);
 }
 
+TEST_F(AudioRendererAlgorithmTest, FillBuffer_LargeBufferSize) {
+  Initialize(kDefaultChannelLayout, kDefaultSampleBits, 44100);
+  TestPlaybackRate(1.0);
+  TestPlaybackRate(0.5);
+  TestPlaybackRate(1.5);
+}
+
 TEST_F(AudioRendererAlgorithmTest, FillBuffer_LowerQualityAudio) {
   static const ChannelLayout kChannelLayout = CHANNEL_LAYOUT_MONO;
   static const int kSampleBits = 8;
-  Initialize(kChannelLayout, kSampleBits);
+  Initialize(kChannelLayout, kSampleBits, kSamplesPerSecond);
   TestPlaybackRate(1.0);
   TestPlaybackRate(0.5);
   TestPlaybackRate(1.5);
@@ -281,7 +262,7 @@ TEST_F(AudioRendererAlgorithmTest, FillBuffer_LowerQualityAudio) {
 TEST_F(AudioRendererAlgorithmTest, FillBuffer_HigherQualityAudio) {
   static const ChannelLayout kChannelLayout = CHANNEL_LAYOUT_STEREO;
   static const int kSampleBits = 32;
-  Initialize(kChannelLayout, kSampleBits);
+  Initialize(kChannelLayout, kSampleBits, kSamplesPerSecond);
   TestPlaybackRate(1.0);
   TestPlaybackRate(0.5);
   TestPlaybackRate(1.5);","void CheckFakeData(uint8* audio_data, int frames_written,
                     double playback_rate) {
    size_t length =
        (frames_written * algorithm_.bytes_per_frame())
        / algorithm_.bytes_per_channel();
    switch (algorithm_.bytes_per_channel()) {
      case 4:
        DoCheckFakeData<int32>(audio_data, length);
        break;
      case 2:
        DoCheckFakeData<int16>(audio_data, length);
        break;
      case 1:
        DoCheckFakeData<uint8>(audio_data, length);
        break;
      default:
        NOTREACHED() << ""Unsupported audio bit depth in crossfade."";
    }
  }
",Chrome,802ecdb9cee0d66fe546bdf24e98150f8f716ad8,c86e7a815b8a8b8af67bba66561be1aef1e399a3,1.0,"  void CheckFakeData(uint8* audio_data, int frames_written,
//flaw_line_below:
                     double playback_rate) {
//flaw_line_below:
    size_t length =
//flaw_line_below:
        (frames_written * algorithm_.bytes_per_frame())
//flaw_line_below:
        / algorithm_.bytes_per_channel();
//flaw_line_below:

//flaw_line_below:
    switch (algorithm_.bytes_per_channel()) {
//flaw_line_below:
      case 4:
//flaw_line_below:
        DoCheckFakeData<int32>(audio_data, length);
//flaw_line_below:
        break;
//flaw_line_below:
      case 2:
//flaw_line_below:
        DoCheckFakeData<int16>(audio_data, length);
//flaw_line_below:
        break;
//flaw_line_below:
      case 1:
//flaw_line_below:
        DoCheckFakeData<uint8>(audio_data, length);
//flaw_line_below:
        break;
//flaw_line_below:
      default:
//flaw_line_below:
        NOTREACHED() << ""Unsupported audio bit depth in crossfade."";
//flaw_line_below:
    }
//flaw_line_below:
  }
"
78,None,Remote,Not required,Partial,CVE-2017-9727,https://www.cvedetails.com/cve/CVE-2017-9727/,CWE-125,Medium,Partial,Partial,,2017-07-26,6.8,The gx_ttfReader__Read function in base/gxttfb.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) or possibly have unspecified other impact via a crafted document.,2019-10-02,DoS,2.0,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=937ccd17ac65935633b2ebc06cb7089b91e17e6b,937ccd17ac65935633b2ebc06cb7089b91e17e6b,,1.0,,,            r->error = (r->glyph_data.bits.size - r->pos < n ?,8,"static void gx_ttfReader__Read(ttfReader *self, void *p, int n)
{
    gx_ttfReader *r = (gx_ttfReader *)self;
    const byte *q;

     if (!r->error) {
         if (r->extra_glyph_index != -1) {
             q = r->glyph_data.bits.data + r->pos;
            r->error = ((r->pos >= r->glyph_data.bits.size ||
                        r->glyph_data.bits.size - r->pos < n) ?
                             gs_note_error(gs_error_invalidfont) : 0);
             if (r->error == 0)
                 memcpy(p, q, n);
            unsigned int cnt;

            for (cnt = 0; cnt < (uint)n; cnt += r->error) {
                r->error = r->pfont->data.string_proc(r->pfont, (ulong)r->pos + cnt, (ulong)n - cnt, &q);
                if (r->error < 0)
                    break;
                else if ( r->error == 0) {
                    memcpy((char *)p + cnt, q, n - cnt);
                    break;
                } else {
                    memcpy((char *)p + cnt, q, r->error);
                }
            }
        }
    }
    if (r->error) {
        memset(p, 0, n);
        return;
    }
    r->pos += n;
}
","static void gx_ttfReader__Read(ttfReader *self, void *p, int n)
{
    gx_ttfReader *r = (gx_ttfReader *)self;
    const byte *q;

     if (!r->error) {
         if (r->extra_glyph_index != -1) {
             q = r->glyph_data.bits.data + r->pos;
            r->error = (r->glyph_data.bits.size - r->pos < n ?
                             gs_note_error(gs_error_invalidfont) : 0);
             if (r->error == 0)
                 memcpy(p, q, n);
            unsigned int cnt;

            for (cnt = 0; cnt < (uint)n; cnt += r->error) {
                r->error = r->pfont->data.string_proc(r->pfont, (ulong)r->pos + cnt, (ulong)n - cnt, &q);
                if (r->error < 0)
                    break;
                else if ( r->error == 0) {
                    memcpy((char *)p + cnt, q, n - cnt);
                    break;
                } else {
                    memcpy((char *)p + cnt, q, r->error);
                }
            }
        }
    }
    if (r->error) {
        memset(p, 0, n);
        return;
    }
    r->pos += n;
}
",177951.0,C,"            r->error = ((r->pos >= r->glyph_data.bits.size ||
                        r->glyph_data.bits.size - r->pos < n) ?
","            r->error = (r->glyph_data.bits.size - r->pos < n ?
",7755e67116e8973ee0e3b22d653df026a84fa01b,"@@ -79,7 +79,8 @@ static void gx_ttfReader__Read(ttfReader *self, void *p, int n)
     if (!r->error) {
         if (r->extra_glyph_index != -1) {
             q = r->glyph_data.bits.data + r->pos;
-            r->error = (r->glyph_data.bits.size - r->pos < n ?
+            r->error = ((r->pos >= r->glyph_data.bits.size ||
+                        r->glyph_data.bits.size - r->pos < n) ?
                             gs_note_error(gs_error_invalidfont) : 0);
             if (r->error == 0)
                 memcpy(p, q, n);","static void gx_ttfReader__Read(ttfReader *self, void *p, int n)
{
gx_ttfReader *r = (gx_ttfReader *)self;
const byte *q;

if (!r->error) {
if (r->extra_glyph_index != -1) {
q = r->glyph_data.bits.data + r->pos;
            r->error = (r->glyph_data.bits.size - r->pos < n ?
gs_note_error(gs_error_invalidfont) : 0);
if (r->error == 0)
memcpy(p, q, n);
unsigned int cnt;

for (cnt = 0; cnt < (uint)n; cnt += r->error) {
r->error = r->pfont->data.string_proc(r->pfont, (ulong)r->pos + cnt, (ulong)n - cnt, &q);
if (r->error < 0)
break;
else if ( r->error == 0) {
memcpy((char *)p + cnt, q, n - cnt);
break;
} else {
memcpy((char *)p + cnt, q, r->error);
}
}
}
}
if (r->error) {
memset(p, 0, n);
return;
}
r->pos += n;
}
",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=base/gxttfb.c;h=e1561af07a050b5dcd69bb68fb0ba13aea976be5;hb=e1561af07a050b5dcd69bb68fb0ba13aea976be5,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=base/gxttfb.c;h=0e9a444e571ffea7ffecdaec6a396fb235621cda;hb=0e9a444e571ffea7ffecdaec6a396fb235621cda,1.0,"static void gx_ttfReader__Read(ttfReader *self, void *p, int n)
{
    gx_ttfReader *r = (gx_ttfReader *)self;
    const byte *q;

     if (!r->error) {
         if (r->extra_glyph_index != -1) {
             q = r->glyph_data.bits.data + r->pos;
//flaw_line_below:
            r->error = (r->glyph_data.bits.size - r->pos < n ?
//fix_flaw_line_below:
//            r->error = ((r->pos >= r->glyph_data.bits.size ||
//fix_flaw_line_below:
//                        r->glyph_data.bits.size - r->pos < n) ?
                             gs_note_error(gs_error_invalidfont) : 0);
             if (r->error == 0)
                 memcpy(p, q, n);
            unsigned int cnt;

            for (cnt = 0; cnt < (uint)n; cnt += r->error) {
                r->error = r->pfont->data.string_proc(r->pfont, (ulong)r->pos + cnt, (ulong)n - cnt, &q);
                if (r->error < 0)
                    break;
                else if ( r->error == 0) {
                    memcpy((char *)p + cnt, q, n - cnt);
                    break;
                } else {
                    memcpy((char *)p + cnt, q, r->error);
                }
            }
        }
    }
    if (r->error) {
        memset(p, 0, n);
        return;
    }
    r->pos += n;
}
"
90,None,Remote,Not required,Complete,CVE-2016-1621,https://www.cvedetails.com/cve/CVE-2016-1621/,CWE-119,Low,Complete,Complete,,2016-03-12,10.0,"libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792.",2016-12-02,DoS Exec Code Overflow Mem. Corr. ,13.0,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,5a9753fca56f0eeb9f61e342b2fccffc364f9426,"Merge Conflict Fix CL to lmp-mr1-release for ag/849478

DO NOT MERGE - libvpx: Pull from upstream

Current HEAD: 7105df53d7dc13d5e575bc8df714ec8d1da36b06

BUG=23452792

Change-Id: Ic78176fc369e0bacc71d423e0e2e6075d004aaec
",4.0,libvpx/test/variance_test.cc,"{""filename"": ""armv7a-neon/libvpx_srcs.txt"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/armv7a-neon/libvpx_srcs.txt"", ""patch"": ""@@ -1,6 +1,6 @@\n\n+CHANGELOG\n build/make/rtcd.pl\n build/make/version.sh\n-CHANGELOG\n libs.mk\n vp8/common/alloccommon.c\n vp8/common/alloccommon.h\n@@ -19,49 +19,32 @@\n\n vp8/common/arm/armv6/loopfilter_v6.asm.s\n vp8/common/arm/armv6/simpleloopfilter_v6.asm.s\n vp8/common/arm/armv6/sixtappredict8x4_v6.asm.s\n-vp8/common/arm/armv6/vp8_sad16x16_armv6.asm.s\n-vp8/common/arm/armv6/vp8_variance16x16_armv6.asm.s\n-vp8/common/arm/armv6/vp8_variance8x8_armv6.asm.s\n-vp8/common/arm/armv6/vp8_variance_halfpixvar16x16_h_armv6.asm.s\n-vp8/common/arm/armv6/vp8_variance_halfpixvar16x16_hv_armv6.asm.s\n-vp8/common/arm/armv6/vp8_variance_halfpixvar16x16_v_armv6.asm.s\n vp8/common/arm/bilinearfilter_arm.c\n vp8/common/arm/bilinearfilter_arm.h\n vp8/common/arm/dequantize_arm.c\n vp8/common/arm/filter_arm.c\n vp8/common/arm/loopfilter_arm.c\n vp8/common/arm/neon/bilinearpredict_neon.c\n-vp8/common/arm/neon/buildintrapredictorsmby_neon.asm.s\n vp8/common/arm/neon/copymem_neon.c\n vp8/common/arm/neon/dc_only_idct_add_neon.c\n vp8/common/arm/neon/dequant_idct_neon.c\n vp8/common/arm/neon/dequantizeb_neon.c\n vp8/common/arm/neon/idct_blk_neon.c\n-vp8/common/arm/neon/idct_dequant_0_2x_neon.asm.s\n-vp8/common/arm/neon/idct_dequant_full_2x_neon.asm.s\n-vp8/common/arm/neon/iwalsh_neon.asm.s\n-vp8/common/arm/neon/loopfilter_neon.asm.s\n-vp8/common/arm/neon/loopfiltersimplehorizontaledge_neon.asm.s\n-vp8/common/arm/neon/loopfiltersimpleverticaledge_neon.asm.s\n-vp8/common/arm/neon/mbloopfilter_neon.asm.s\n-vp8/common/arm/neon/sad16_neon.asm.s\n-vp8/common/arm/neon/sad8_neon.asm.s\n-vp8/common/arm/neon/save_reg_neon.asm.s\n-vp8/common/arm/neon/shortidct4x4llm_neon.asm.s\n-vp8/common/arm/neon/sixtappredict16x16_neon.asm.s\n-vp8/common/arm/neon/sixtappredict4x4_neon.asm.s\n-vp8/common/arm/neon/sixtappredict8x4_neon.asm.s\n-vp8/common/arm/neon/sixtappredict8x8_neon.asm.s\n-vp8/common/arm/neon/variance_neon.asm.s\n-vp8/common/arm/neon/vp8_subpixelvariance16x16_neon.asm.s\n-vp8/common/arm/neon/vp8_subpixelvariance16x16s_neon.asm.s\n-vp8/common/arm/neon/vp8_subpixelvariance8x8_neon.asm.s\n-vp8/common/arm/reconintra_arm.c\n-vp8/common/arm/variance_arm.c\n+vp8/common/arm/neon/idct_dequant_0_2x_neon.c\n+vp8/common/arm/neon/idct_dequant_full_2x_neon.c\n+vp8/common/arm/neon/iwalsh_neon.c\n+vp8/common/arm/neon/loopfiltersimplehorizontaledge_neon.c\n+vp8/common/arm/neon/loopfiltersimpleverticaledge_neon.c\n+vp8/common/arm/neon/mbloopfilter_neon.c\n+vp8/common/arm/neon/reconintra_neon.c\n+vp8/common/arm/neon/shortidct4x4llm_neon.c\n+vp8/common/arm/neon/sixtappredict_neon.c\n+vp8/common/arm/neon/vp8_loopfilter_neon.c\n vp8/common/blockd.c\n vp8/common/blockd.h\n vp8/common/coefupdateprobs.h\n vp8/common/common.h\n+vp8/common/copy_c.c\n vp8/common/debugmodes.c\n vp8/common/default_coef_probs.h\n vp8/common/dequantize.c\n@@ -82,28 +65,25 @@\n\n vp8/common/idct_blk.c\n vp8/common/idctllm.c\n vp8/common/invtrans.h\n-vp8/common/loopfilter.c\n-vp8/common/loopfilter_filters.c\n vp8/common/loopfilter.h\n+vp8/common/loopfilter_filters.c\n vp8/common/mbpitch.c\n vp8/common/modecont.c\n vp8/common/modecont.h\n vp8/common/mv.h\n+vp8/common/onyx.h\n vp8/common/onyxc_int.h\n vp8/common/onyxd.h\n-vp8/common/onyx.h\n vp8/common/ppflags.h\n-vp8/common/pragmas.h\n vp8/common/quant_common.c\n vp8/common/quant_common.h\n vp8/common/reconinter.c\n vp8/common/reconinter.h\n+vp8/common/reconintra.c\n vp8/common/reconintra4x4.c\n vp8/common/reconintra4x4.h\n-vp8/common/reconintra.c\n vp8/common/rtcd.c\n vp8/common/rtcd_defs.pl\n-vp8/common/sad_c.c\n vp8/common/setupintrarecon.c\n vp8/common/setupintrarecon.h\n vp8/common/swapyv12buffer.c\n@@ -112,9 +92,8 @@\n\n vp8/common/threading.h\n vp8/common/treecoder.c\n vp8/common/treecoder.h\n-vp8/common/variance_c.c\n-vp8/common/variance.h\n vp8/common/vp8_entropymodedata.h\n+vp8/common/vp8_loopfilter.c\n vp8/decoder/dboolhuff.c\n vp8/decoder/dboolhuff.h\n vp8/decoder/decodeframe.c\n@@ -127,29 +106,17 @@\n\n vp8/decoder/onyxd_int.h\n vp8/decoder/threading.c\n vp8/decoder/treereader.h\n-vp8/encoder/arm/armv5te/boolhuff_armv5te.asm.s\n-vp8/encoder/arm/armv5te/vp8_packtokens_armv5.asm.s\n-vp8/encoder/arm/armv5te/vp8_packtokens_mbrow_armv5.asm.s\n-vp8/encoder/arm/armv5te/vp8_packtokens_partitions_armv5.asm.s\n-vp8/encoder/arm/armv6/vp8_fast_quantize_b_armv6.asm.s\n-vp8/encoder/arm/armv6/vp8_mse16x16_armv6.asm.s\n vp8/encoder/arm/armv6/vp8_short_fdct4x4_armv6.asm.s\n-vp8/encoder/arm/armv6/vp8_subtract_armv6.asm.s\n vp8/encoder/arm/armv6/walsh_v6.asm.s\n-vp8/encoder/arm/boolhuff_arm.c\n vp8/encoder/arm/dct_arm.c\n vp8/encoder/arm/neon/denoising_neon.c\n-vp8/encoder/arm/neon/fastquantizeb_neon.asm.s\n-vp8/encoder/arm/neon/picklpf_arm.c\n-vp8/encoder/arm/neon/shortfdct_neon.asm.s\n-vp8/encoder/arm/neon/subtract_neon.asm.s\n-vp8/encoder/arm/neon/vp8_memcpy_neon.asm.s\n-vp8/encoder/arm/neon/vp8_mse16x16_neon.asm.s\n-vp8/encoder/arm/neon/vp8_shortwalsh4x4_neon.asm.s\n-vp8/encoder/arm/quantize_arm.c\n+vp8/encoder/arm/neon/fastquantizeb_neon.c\n+vp8/encoder/arm/neon/shortfdct_neon.c\n+vp8/encoder/arm/neon/vp8_shortwalsh4x4_neon.c\n vp8/encoder/bitstream.c\n vp8/encoder/bitstream.h\n vp8/encoder/block.h\n+vp8/encoder/boolhuff.c\n vp8/encoder/boolhuff.h\n vp8/encoder/dct.c\n vp8/encoder/dct_value_cost.h\n@@ -178,7 +145,6 @@\n\n vp8/encoder/pickinter.c\n vp8/encoder/pickinter.h\n vp8/encoder/picklpf.c\n-vp8/encoder/quantize.c\n vp8/encoder/quantize.h\n vp8/encoder/ratectrl.c\n vp8/encoder/ratectrl.h\n@@ -190,45 +156,22 @@\n\n vp8/encoder/tokenize.h\n vp8/encoder/treewriter.c\n vp8/encoder/treewriter.h\n-vp8/encoder/vp8_asm_enc_offsets.c\n+vp8/encoder/vp8_quantize.c\n vp8/vp8_common.mk\n-vp8/vp8cx_arm.mk\n vp8/vp8_cx_iface.c\n-vp8/vp8cx.mk\n vp8/vp8_dx_iface.c\n+vp8/vp8cx.mk\n+vp8/vp8cx_arm.mk\n vp8/vp8dx.mk\n-vp9/common/arm/neon/vp9_avg_neon.asm.s\n-vp9/common/arm/neon/vp9_convolve8_avg_neon.asm.s\n-vp9/common/arm/neon/vp9_convolve8_neon.asm.s\n-vp9/common/arm/neon/vp9_convolve_neon.c\n-vp9/common/arm/neon/vp9_copy_neon.asm.s\n-vp9/common/arm/neon/vp9_dc_only_idct_add_neon.asm.s\n-vp9/common/arm/neon/vp9_idct16x16_1_add_neon.asm.s\n-vp9/common/arm/neon/vp9_idct16x16_add_neon.asm.s\n-vp9/common/arm/neon/vp9_idct16x16_neon.c\n-vp9/common/arm/neon/vp9_idct32x32_1_add_neon.asm.s\n-vp9/common/arm/neon/vp9_idct32x32_add_neon.asm.s\n-vp9/common/arm/neon/vp9_idct4x4_1_add_neon.asm.s\n-vp9/common/arm/neon/vp9_idct4x4_add_neon.asm.s\n-vp9/common/arm/neon/vp9_idct8x8_1_add_neon.asm.s\n-vp9/common/arm/neon/vp9_idct8x8_add_neon.asm.s\n-vp9/common/arm/neon/vp9_iht4x4_add_neon.asm.s\n-vp9/common/arm/neon/vp9_iht8x8_add_neon.asm.s\n-vp9/common/arm/neon/vp9_loopfilter_16_neon.asm.s\n-vp9/common/arm/neon/vp9_loopfilter_16_neon.c\n-vp9/common/arm/neon/vp9_loopfilter_neon.asm.s\n-vp9/common/arm/neon/vp9_mb_lpf_neon.asm.s\n-vp9/common/arm/neon/vp9_reconintra_neon.asm.s\n-vp9/common/arm/neon/vp9_save_reg_neon.asm.s\n+vp9/common/arm/neon/vp9_iht4x4_add_neon.c\n+vp9/common/arm/neon/vp9_iht8x8_add_neon.c\n vp9/common/vp9_alloccommon.c\n vp9/common/vp9_alloccommon.h\n vp9/common/vp9_blockd.c\n vp9/common/vp9_blockd.h\n+vp9/common/vp9_common.h\n vp9/common/vp9_common_data.c\n vp9/common/vp9_common_data.h\n-vp9/common/vp9_common.h\n-vp9/common/vp9_convolve.c\n-vp9/common/vp9_convolve.h\n vp9/common/vp9_debugmodes.c\n vp9/common/vp9_entropy.c\n vp9/common/vp9_entropy.h\n@@ -244,18 +187,14 @@\n\n vp9/common/vp9_idct.c\n vp9/common/vp9_idct.h\n vp9/common/vp9_loopfilter.c\n-vp9/common/vp9_loopfilter_filters.c\n vp9/common/vp9_loopfilter.h\n vp9/common/vp9_mv.h\n vp9/common/vp9_mvref_common.c\n vp9/common/vp9_mvref_common.h\n vp9/common/vp9_onyxc_int.h\n vp9/common/vp9_ppflags.h\n-vp9/common/vp9_pragmas.h\n vp9/common/vp9_pred_common.c\n vp9/common/vp9_pred_common.h\n-vp9/common/vp9_prob.c\n-vp9/common/vp9_prob.h\n vp9/common/vp9_quant_common.c\n vp9/common/vp9_quant_common.h\n vp9/common/vp9_reconinter.c\n@@ -270,8 +209,9 @@\n\n vp9/common/vp9_scan.h\n vp9/common/vp9_seg_common.c\n vp9/common/vp9_seg_common.h\n-vp9/common/vp9_systemdependent.h\n vp9/common/vp9_textblit.h\n+vp9/common/vp9_thread_common.c\n+vp9/common/vp9_thread_common.h\n vp9/common/vp9_tile_common.c\n vp9/common/vp9_tile_common.h\n vp9/decoder/vp9_decodeframe.c\n@@ -286,21 +226,22 @@\n\n vp9/decoder/vp9_dsubexp.h\n vp9/decoder/vp9_dthread.c\n vp9/decoder/vp9_dthread.h\n-vp9/decoder/vp9_read_bit_buffer.c\n-vp9/decoder/vp9_read_bit_buffer.h\n-vp9/decoder/vp9_reader.c\n-vp9/decoder/vp9_reader.h\n-vp9/decoder/vp9_thread.c\n-vp9/decoder/vp9_thread.h\n+vp9/encoder/arm/neon/vp9_avg_neon.c\n+vp9/encoder/arm/neon/vp9_dct_neon.c\n+vp9/encoder/arm/neon/vp9_error_neon.c\n+vp9/encoder/arm/neon/vp9_quantize_neon.c\n vp9/encoder/vp9_aq_complexity.c\n vp9/encoder/vp9_aq_complexity.h\n vp9/encoder/vp9_aq_cyclicrefresh.c\n vp9/encoder/vp9_aq_cyclicrefresh.h\n vp9/encoder/vp9_aq_variance.c\n vp9/encoder/vp9_aq_variance.h\n+vp9/encoder/vp9_avg.c\n vp9/encoder/vp9_bitstream.c\n vp9/encoder/vp9_bitstream.h\n vp9/encoder/vp9_block.h\n+vp9/encoder/vp9_context_tree.c\n+vp9/encoder/vp9_context_tree.h\n vp9/encoder/vp9_cost.c\n vp9/encoder/vp9_cost.h\n vp9/encoder/vp9_dct.c\n@@ -310,6 +251,10 @@\n\n vp9/encoder/vp9_encodemb.h\n vp9/encoder/vp9_encodemv.c\n vp9/encoder/vp9_encodemv.h\n+vp9/encoder/vp9_encoder.c\n+vp9/encoder/vp9_encoder.h\n+vp9/encoder/vp9_ethread.c\n+vp9/encoder/vp9_ethread.h\n vp9/encoder/vp9_extend.c\n vp9/encoder/vp9_extend.h\n vp9/encoder/vp9_firstpass.c\n@@ -320,8 +265,6 @@\n\n vp9/encoder/vp9_mbgraph.h\n vp9/encoder/vp9_mcomp.c\n vp9/encoder/vp9_mcomp.h\n-vp9/encoder/vp9_onyx_if.c\n-vp9/encoder/vp9_onyx_int.h\n vp9/encoder/vp9_picklpf.c\n vp9/encoder/vp9_picklpf.h\n vp9/encoder/vp9_pickmode.c\n@@ -330,13 +273,16 @@\n\n vp9/encoder/vp9_quantize.h\n vp9/encoder/vp9_ratectrl.c\n vp9/encoder/vp9_ratectrl.h\n+vp9/encoder/vp9_rd.c\n+vp9/encoder/vp9_rd.h\n vp9/encoder/vp9_rdopt.c\n vp9/encoder/vp9_rdopt.h\n vp9/encoder/vp9_resize.c\n vp9/encoder/vp9_resize.h\n-vp9/encoder/vp9_sad.c\n vp9/encoder/vp9_segmentation.c\n vp9/encoder/vp9_segmentation.h\n+vp9/encoder/vp9_skin_detection.c\n+vp9/encoder/vp9_skin_detection.h\n vp9/encoder/vp9_speed_features.c\n vp9/encoder/vp9_speed_features.h\n vp9/encoder/vp9_subexp.c\n@@ -349,59 +295,22 @@\n\n vp9/encoder/vp9_tokenize.h\n vp9/encoder/vp9_treewriter.c\n vp9/encoder/vp9_treewriter.h\n-vp9/encoder/vp9_variance.c\n-vp9/encoder/vp9_variance.h\n-vp9/encoder/vp9_write_bit_buffer.c\n-vp9/encoder/vp9_write_bit_buffer.h\n-vp9/encoder/vp9_writer.c\n-vp9/encoder/vp9_writer.h\n vp9/vp9_common.mk\n vp9/vp9_cx_iface.c\n-vp9/vp9cx.mk\n vp9/vp9_dx_iface.c\n-vp9/vp9dx.mk\n vp9/vp9_iface_common.h\n-vpx_config.c\n+vp9/vp9cx.mk\n+vp9/vp9dx.mk\n vpx/internal/vpx_codec_internal.h\n vpx/internal/vpx_psnr.h\n-vpx_mem/include/vpx_mem_intrnl.h\n-vpx_mem/vpx_mem.c\n-vpx_mem/vpx_mem.h\n-vpx_mem/vpx_mem.mk\n-vpx_ports/arm_cpudetect.c\n-vpx_ports/arm.h\n-vpx_ports/asm_offsets.h\n-vpx_ports/emmintrin_compat.h\n-vpx_ports/mem.h\n-vpx_ports/mem_ops_aligned.h\n-vpx_ports/mem_ops.h\n-vpx_ports/vpx_once.h\n-vpx_ports/vpx_ports.mk\n-vpx_ports/vpx_timer.h\n-vpx_scale/arm/neon/vp8_vpxyv12_copyframe_func_neon.asm.s\n-vpx_scale/arm/neon/vp8_vpxyv12_copysrcframe_func_neon.asm.s\n-vpx_scale/arm/neon/vp8_vpxyv12_extendframeborders_neon.asm.s\n-vpx_scale/arm/neon/yv12extend_arm.c\n-vpx_scale/generic/gen_scalers.c\n-vpx_scale/generic/vpx_scale.c\n-vpx_scale/generic/yv12config.c\n-vpx_scale/generic/yv12extend.c\n-vpx_scale/vpx_scale_asm_offsets.c\n-vpx_scale/vpx_scale.h\n-vpx_scale/vpx_scale.mk\n-vpx_scale/vpx_scale_rtcd.c\n-vpx_scale/vpx_scale_rtcd.pl\n-vpx_scale/yv12config.h\n-vpx/src/svc_encodeframe.c\n vpx/src/vpx_codec.c\n vpx/src/vpx_decoder.c\n vpx/src/vpx_encoder.c\n vpx/src/vpx_image.c\n vpx/src/vpx_psnr.c\n-vpx/svc_context.h\n+vpx/vp8.h\n vpx/vp8cx.h\n vpx/vp8dx.h\n-vpx/vp8.h\n vpx/vpx_codec.h\n vpx/vpx_codec.mk\n vpx/vpx_decoder.h\n@@ -409,3 +318,98 @@\n\n vpx/vpx_frame_buffer.h\n vpx/vpx_image.h\n vpx/vpx_integer.h\n+vpx_config.c\n+vpx_dsp/arm/bilinear_filter_media.asm.s\n+vpx_dsp/arm/fwd_txfm_neon.c\n+vpx_dsp/arm/idct16x16_1_add_neon.asm.s\n+vpx_dsp/arm/idct16x16_add_neon.asm.s\n+vpx_dsp/arm/idct16x16_neon.c\n+vpx_dsp/arm/idct32x32_1_add_neon.asm.s\n+vpx_dsp/arm/idct32x32_add_neon.asm.s\n+vpx_dsp/arm/idct4x4_1_add_neon.asm.s\n+vpx_dsp/arm/idct4x4_add_neon.asm.s\n+vpx_dsp/arm/idct8x8_1_add_neon.asm.s\n+vpx_dsp/arm/idct8x8_add_neon.asm.s\n+vpx_dsp/arm/intrapred_neon.c\n+vpx_dsp/arm/intrapred_neon_asm.asm.s\n+vpx_dsp/arm/loopfilter_16_neon.asm.s\n+vpx_dsp/arm/loopfilter_4_neon.asm.s\n+vpx_dsp/arm/loopfilter_8_neon.asm.s\n+vpx_dsp/arm/loopfilter_mb_neon.asm.s\n+vpx_dsp/arm/loopfilter_neon.c\n+vpx_dsp/arm/sad4d_neon.c\n+vpx_dsp/arm/sad_media.asm.s\n+vpx_dsp/arm/sad_neon.c\n+vpx_dsp/arm/save_reg_neon.asm.s\n+vpx_dsp/arm/subpel_variance_media.c\n+vpx_dsp/arm/subpel_variance_neon.c\n+vpx_dsp/arm/subtract_neon.c\n+vpx_dsp/arm/variance_halfpixvar16x16_h_media.asm.s\n+vpx_dsp/arm/variance_halfpixvar16x16_hv_media.asm.s\n+vpx_dsp/arm/variance_halfpixvar16x16_v_media.asm.s\n+vpx_dsp/arm/variance_media.asm.s\n+vpx_dsp/arm/variance_neon.c\n+vpx_dsp/arm/vpx_convolve8_avg_neon_asm.asm.s\n+vpx_dsp/arm/vpx_convolve8_neon_asm.asm.s\n+vpx_dsp/arm/vpx_convolve_avg_neon_asm.asm.s\n+vpx_dsp/arm/vpx_convolve_copy_neon_asm.asm.s\n+vpx_dsp/arm/vpx_convolve_neon.c\n+vpx_dsp/bitreader.c\n+vpx_dsp/bitreader.h\n+vpx_dsp/bitreader_buffer.c\n+vpx_dsp/bitreader_buffer.h\n+vpx_dsp/bitwriter.c\n+vpx_dsp/bitwriter.h\n+vpx_dsp/bitwriter_buffer.c\n+vpx_dsp/bitwriter_buffer.h\n+vpx_dsp/fwd_txfm.c\n+vpx_dsp/fwd_txfm.h\n+vpx_dsp/intrapred.c\n+vpx_dsp/inv_txfm.c\n+vpx_dsp/inv_txfm.h\n+vpx_dsp/loopfilter.c\n+vpx_dsp/prob.c\n+vpx_dsp/prob.h\n+vpx_dsp/quantize.c\n+vpx_dsp/quantize.h\n+vpx_dsp/sad.c\n+vpx_dsp/subtract.c\n+vpx_dsp/txfm_common.h\n+vpx_dsp/variance.c\n+vpx_dsp/variance.h\n+vpx_dsp/vpx_convolve.c\n+vpx_dsp/vpx_convolve.h\n+vpx_dsp/vpx_dsp.mk\n+vpx_dsp/vpx_dsp_common.h\n+vpx_dsp/vpx_dsp_rtcd.c\n+vpx_dsp/vpx_dsp_rtcd_defs.pl\n+vpx_dsp/vpx_filter.h\n+vpx_mem/include/vpx_mem_intrnl.h\n+vpx_mem/vpx_mem.c\n+vpx_mem/vpx_mem.h\n+vpx_mem/vpx_mem.mk\n+vpx_ports/arm.h\n+vpx_ports/arm_cpudetect.c\n+vpx_ports/bitops.h\n+vpx_ports/emmintrin_compat.h\n+vpx_ports/mem.h\n+vpx_ports/mem_ops.h\n+vpx_ports/mem_ops_aligned.h\n+vpx_ports/msvc.h\n+vpx_ports/system_state.h\n+vpx_ports/vpx_once.h\n+vpx_ports/vpx_ports.mk\n+vpx_ports/vpx_timer.h\n+vpx_scale/generic/gen_scalers.c\n+vpx_scale/generic/vpx_scale.c\n+vpx_scale/generic/yv12config.c\n+vpx_scale/generic/yv12extend.c\n+vpx_scale/vpx_scale.h\n+vpx_scale/vpx_scale.mk\n+vpx_scale/vpx_scale_rtcd.c\n+vpx_scale/vpx_scale_rtcd.pl\n+vpx_scale/yv12config.h\n+vpx_util/endian_inl.h\n+vpx_util/vpx_thread.c\n+vpx_util/vpx_thread.h\n+vpx_util/vpx_util.mk\n""}<_**next**_>{""filename"": ""armv7a-neon/vp8_rtcd.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/armv7a-neon/vp8_rtcd.h"", ""patch"": ""@@ -7,10 +7,6 @@\n\n #define RTCD_EXTERN extern\n #endif\n \n-#ifdef __cplusplus\n-extern \""C\"" {\n-#endif\n-\n /*\n  * VP8\n  */\n@@ -26,6 +22,10 @@\n\n union int_mv;\n struct yv12_buffer_config;\n \n+#ifdef __cplusplus\n+extern \""C\"" {\n+#endif\n+\n void vp8_bilinear_predict16x16_c(unsigned char *src, int src_pitch, int xofst, int yofst, unsigned char *dst, int dst_pitch);\n void vp8_bilinear_predict16x16_armv6(unsigned char *src, int src_pitch, int xofst, int yofst, unsigned char *dst, int dst_pitch);\n void vp8_bilinear_predict16x16_neon(unsigned char *src, int src_pitch, int xofst, int yofst, unsigned char *dst, int dst_pitch);\n@@ -49,10 +49,12 @@\n\n #define vp8_block_error vp8_block_error_c\n \n void vp8_build_intra_predictors_mbuv_s_c(struct macroblockd *x, unsigned char * uabove_row, unsigned char * vabove_row,  unsigned char *uleft, unsigned char *vleft, int left_stride, unsigned char * upred_ptr, unsigned char * vpred_ptr, int pred_stride);\n-#define vp8_build_intra_predictors_mbuv_s vp8_build_intra_predictors_mbuv_s_c\n+void vp8_build_intra_predictors_mbuv_s_neon(struct macroblockd *x, unsigned char * uabove_row, unsigned char * vabove_row,  unsigned char *uleft, unsigned char *vleft, int left_stride, unsigned char * upred_ptr, unsigned char * vpred_ptr, int pred_stride);\n+#define vp8_build_intra_predictors_mbuv_s vp8_build_intra_predictors_mbuv_s_neon\n \n void vp8_build_intra_predictors_mby_s_c(struct macroblockd *x, unsigned char * yabove_row, unsigned char * yleft, int left_stride, unsigned char * ypred_ptr, int y_stride);\n-#define vp8_build_intra_predictors_mby_s vp8_build_intra_predictors_mby_s_c\n+void vp8_build_intra_predictors_mby_s_neon(struct macroblockd *x, unsigned char * yabove_row, unsigned char * yleft, int left_stride, unsigned char * ypred_ptr, int y_stride);\n+#define vp8_build_intra_predictors_mby_s vp8_build_intra_predictors_mby_s_neon\n \n void vp8_clear_system_state_c();\n #define vp8_clear_system_state vp8_clear_system_state_c\n@@ -77,10 +79,14 @@\n\n void vp8_dc_only_idct_add_neon(short input, unsigned char *pred, int pred_stride, unsigned char *dst, int dst_stride);\n #define vp8_dc_only_idct_add vp8_dc_only_idct_add_neon\n \n-int vp8_denoiser_filter_c(struct yv12_buffer_config* mc_running_avg, struct yv12_buffer_config* running_avg, struct macroblock* signal, unsigned int motion_magnitude2, int y_offset, int uv_offset);\n-int vp8_denoiser_filter_neon(struct yv12_buffer_config* mc_running_avg, struct yv12_buffer_config* running_avg, struct macroblock* signal, unsigned int motion_magnitude2, int y_offset, int uv_offset);\n+int vp8_denoiser_filter_c(unsigned char *mc_running_avg_y, int mc_avg_y_stride, unsigned char *running_avg_y, int avg_y_stride, unsigned char *sig, int sig_stride, unsigned int motion_magnitude, int increase_denoising);\n+int vp8_denoiser_filter_neon(unsigned char *mc_running_avg_y, int mc_avg_y_stride, unsigned char *running_avg_y, int avg_y_stride, unsigned char *sig, int sig_stride, unsigned int motion_magnitude, int increase_denoising);\n #define vp8_denoiser_filter vp8_denoiser_filter_neon\n \n+int vp8_denoiser_filter_uv_c(unsigned char *mc_running_avg, int mc_avg_stride, unsigned char *running_avg, int avg_stride, unsigned char *sig, int sig_stride, unsigned int motion_magnitude, int increase_denoising);\n+int vp8_denoiser_filter_uv_neon(unsigned char *mc_running_avg, int mc_avg_stride, unsigned char *running_avg, int avg_stride, unsigned char *sig, int sig_stride, unsigned int motion_magnitude, int increase_denoising);\n+#define vp8_denoiser_filter_uv vp8_denoiser_filter_uv_neon\n+\n void vp8_dequant_idct_add_c(short *input, short *dq, unsigned char *output, int stride);\n void vp8_dequant_idct_add_v6(short *input, short *dq, unsigned char *output, int stride);\n void vp8_dequant_idct_add_neon(short *input, short *dq, unsigned char *output, int stride);\n@@ -105,24 +111,12 @@\n\n #define vp8_diamond_search_sad vp8_diamond_search_sad_c\n \n void vp8_fast_quantize_b_c(struct block *, struct blockd *);\n-void vp8_fast_quantize_b_armv6(struct block *, struct blockd *);\n void vp8_fast_quantize_b_neon(struct block *, struct blockd *);\n #define vp8_fast_quantize_b vp8_fast_quantize_b_neon\n \n-void vp8_fast_quantize_b_pair_c(struct block *b1, struct block *b2, struct blockd *d1, struct blockd *d2);\n-void vp8_fast_quantize_b_pair_neon(struct block *b1, struct block *b2, struct blockd *d1, struct blockd *d2);\n-#define vp8_fast_quantize_b_pair vp8_fast_quantize_b_pair_neon\n-\n int vp8_full_search_sad_c(struct macroblock *x, struct block *b, struct blockd *d, union int_mv *ref_mv, int sad_per_bit, int distance, struct variance_vtable *fn_ptr, int *mvcost[2], union int_mv *center_mv);\n #define vp8_full_search_sad vp8_full_search_sad_c\n \n-unsigned int vp8_get4x4sse_cs_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride);\n-unsigned int vp8_get4x4sse_cs_neon(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride);\n-#define vp8_get4x4sse_cs vp8_get4x4sse_cs_neon\n-\n-unsigned int vp8_get_mb_ss_c(const short *);\n-#define vp8_get_mb_ss vp8_get_mb_ss_c\n-\n void vp8_intra4x4_predict_c(unsigned char *Above, unsigned char *yleft, int left_stride, int b_mode, unsigned char *dst, int dst_stride, unsigned char top_left);\n void vp8_intra4x4_predict_armv6(unsigned char *Above, unsigned char *yleft, int left_stride, int b_mode, unsigned char *dst, int dst_stride, unsigned char top_left);\n #define vp8_intra4x4_predict vp8_intra4x4_predict_armv6\n@@ -173,98 +167,12 @@\n\n int vp8_mbuverror_c(struct macroblock *mb);\n #define vp8_mbuverror vp8_mbuverror_c\n \n-unsigned int vp8_mse16x16_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_mse16x16_armv6(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_mse16x16_neon(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_mse16x16 vp8_mse16x16_neon\n-\n-void vp8_quantize_mb_c(struct macroblock *);\n-void vp8_quantize_mb_neon(struct macroblock *);\n-#define vp8_quantize_mb vp8_quantize_mb_neon\n-\n-void vp8_quantize_mbuv_c(struct macroblock *);\n-void vp8_quantize_mbuv_neon(struct macroblock *);\n-#define vp8_quantize_mbuv vp8_quantize_mbuv_neon\n-\n-void vp8_quantize_mby_c(struct macroblock *);\n-void vp8_quantize_mby_neon(struct macroblock *);\n-#define vp8_quantize_mby vp8_quantize_mby_neon\n-\n int vp8_refining_search_sad_c(struct macroblock *x, struct block *b, struct blockd *d, union int_mv *ref_mv, int sad_per_bit, int distance, struct variance_vtable *fn_ptr, int *mvcost[2], union int_mv *center_mv);\n #define vp8_refining_search_sad vp8_refining_search_sad_c\n \n void vp8_regular_quantize_b_c(struct block *, struct blockd *);\n #define vp8_regular_quantize_b vp8_regular_quantize_b_c\n \n-void vp8_regular_quantize_b_pair_c(struct block *b1, struct block *b2, struct blockd *d1, struct blockd *d2);\n-#define vp8_regular_quantize_b_pair vp8_regular_quantize_b_pair_c\n-\n-unsigned int vp8_sad16x16_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-unsigned int vp8_sad16x16_armv6(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-unsigned int vp8_sad16x16_neon(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp8_sad16x16 vp8_sad16x16_neon\n-\n-void vp8_sad16x16x3_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad16x16x3 vp8_sad16x16x3_c\n-\n-void vp8_sad16x16x4d_c(const unsigned char *src_ptr, int src_stride, const unsigned char * const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad16x16x4d vp8_sad16x16x4d_c\n-\n-void vp8_sad16x16x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned short *sad_array);\n-#define vp8_sad16x16x8 vp8_sad16x16x8_c\n-\n-unsigned int vp8_sad16x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-unsigned int vp8_sad16x8_neon(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp8_sad16x8 vp8_sad16x8_neon\n-\n-void vp8_sad16x8x3_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad16x8x3 vp8_sad16x8x3_c\n-\n-void vp8_sad16x8x4d_c(const unsigned char *src_ptr, int src_stride, const unsigned char * const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad16x8x4d vp8_sad16x8x4d_c\n-\n-void vp8_sad16x8x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned short *sad_array);\n-#define vp8_sad16x8x8 vp8_sad16x8x8_c\n-\n-unsigned int vp8_sad4x4_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-unsigned int vp8_sad4x4_neon(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp8_sad4x4 vp8_sad4x4_neon\n-\n-void vp8_sad4x4x3_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad4x4x3 vp8_sad4x4x3_c\n-\n-void vp8_sad4x4x4d_c(const unsigned char *src_ptr, int src_stride, const unsigned char * const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad4x4x4d vp8_sad4x4x4d_c\n-\n-void vp8_sad4x4x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned short *sad_array);\n-#define vp8_sad4x4x8 vp8_sad4x4x8_c\n-\n-unsigned int vp8_sad8x16_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-unsigned int vp8_sad8x16_neon(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp8_sad8x16 vp8_sad8x16_neon\n-\n-void vp8_sad8x16x3_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad8x16x3 vp8_sad8x16x3_c\n-\n-void vp8_sad8x16x4d_c(const unsigned char *src_ptr, int src_stride, const unsigned char * const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad8x16x4d vp8_sad8x16x4d_c\n-\n-void vp8_sad8x16x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned short *sad_array);\n-#define vp8_sad8x16x8 vp8_sad8x16x8_c\n-\n-unsigned int vp8_sad8x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-unsigned int vp8_sad8x8_neon(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp8_sad8x8 vp8_sad8x8_neon\n-\n-void vp8_sad8x8x3_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad8x8x3 vp8_sad8x8x3_c\n-\n-void vp8_sad8x8x4d_c(const unsigned char *src_ptr, int src_stride, const unsigned char * const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad8x8x4d vp8_sad8x8x4d_c\n-\n-void vp8_sad8x8x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned short *sad_array);\n-#define vp8_sad8x8x8 vp8_sad8x8x8_c\n-\n void vp8_short_fdct4x4_c(short *input, short *output, int pitch);\n void vp8_short_fdct4x4_armv6(short *input, short *output, int pitch);\n void vp8_short_fdct4x4_neon(short *input, short *output, int pitch);\n@@ -300,8 +208,7 @@\n\n \n void vp8_sixtap_predict4x4_c(unsigned char *src, int src_pitch, int xofst, int yofst, unsigned char *dst, int dst_pitch);\n void vp8_sixtap_predict4x4_armv6(unsigned char *src, int src_pitch, int xofst, int yofst, unsigned char *dst, int dst_pitch);\n-void vp8_sixtap_predict4x4_neon(unsigned char *src, int src_pitch, int xofst, int yofst, unsigned char *dst, int dst_pitch);\n-#define vp8_sixtap_predict4x4 vp8_sixtap_predict4x4_neon\n+#define vp8_sixtap_predict4x4 vp8_sixtap_predict4x4_armv6\n \n void vp8_sixtap_predict8x4_c(unsigned char *src, int src_pitch, int xofst, int yofst, unsigned char *dst, int dst_pitch);\n void vp8_sixtap_predict8x4_armv6(unsigned char *src, int src_pitch, int xofst, int yofst, unsigned char *dst, int dst_pitch);\n@@ -313,83 +220,6 @@\n\n void vp8_sixtap_predict8x8_neon(unsigned char *src, int src_pitch, int xofst, int yofst, unsigned char *dst, int dst_pitch);\n #define vp8_sixtap_predict8x8 vp8_sixtap_predict8x8_neon\n \n-unsigned int vp8_sub_pixel_mse16x16_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_mse16x16 vp8_sub_pixel_mse16x16_c\n-\n-unsigned int vp8_sub_pixel_variance16x16_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-unsigned int vp8_sub_pixel_variance16x16_armv6(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-unsigned int vp8_sub_pixel_variance16x16_neon(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_variance16x16 vp8_sub_pixel_variance16x16_neon\n-\n-unsigned int vp8_sub_pixel_variance16x8_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_variance16x8 vp8_sub_pixel_variance16x8_c\n-\n-unsigned int vp8_sub_pixel_variance4x4_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_variance4x4 vp8_sub_pixel_variance4x4_c\n-\n-unsigned int vp8_sub_pixel_variance8x16_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_variance8x16 vp8_sub_pixel_variance8x16_c\n-\n-unsigned int vp8_sub_pixel_variance8x8_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-unsigned int vp8_sub_pixel_variance8x8_armv6(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-unsigned int vp8_sub_pixel_variance8x8_neon(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_variance8x8 vp8_sub_pixel_variance8x8_neon\n-\n-void vp8_subtract_b_c(struct block *be, struct blockd *bd, int pitch);\n-void vp8_subtract_b_armv6(struct block *be, struct blockd *bd, int pitch);\n-void vp8_subtract_b_neon(struct block *be, struct blockd *bd, int pitch);\n-#define vp8_subtract_b vp8_subtract_b_neon\n-\n-void vp8_subtract_mbuv_c(short *diff, unsigned char *usrc, unsigned char *vsrc, int src_stride, unsigned char *upred, unsigned char *vpred, int pred_stride);\n-void vp8_subtract_mbuv_armv6(short *diff, unsigned char *usrc, unsigned char *vsrc, int src_stride, unsigned char *upred, unsigned char *vpred, int pred_stride);\n-void vp8_subtract_mbuv_neon(short *diff, unsigned char *usrc, unsigned char *vsrc, int src_stride, unsigned char *upred, unsigned char *vpred, int pred_stride);\n-#define vp8_subtract_mbuv vp8_subtract_mbuv_neon\n-\n-void vp8_subtract_mby_c(short *diff, unsigned char *src, int src_stride, unsigned char *pred, int pred_stride);\n-void vp8_subtract_mby_armv6(short *diff, unsigned char *src, int src_stride, unsigned char *pred, int pred_stride);\n-void vp8_subtract_mby_neon(short *diff, unsigned char *src, int src_stride, unsigned char *pred, int pred_stride);\n-#define vp8_subtract_mby vp8_subtract_mby_neon\n-\n-unsigned int vp8_variance16x16_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance16x16_armv6(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance16x16_neon(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance16x16 vp8_variance16x16_neon\n-\n-unsigned int vp8_variance16x8_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance16x8_neon(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance16x8 vp8_variance16x8_neon\n-\n-unsigned int vp8_variance4x4_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance4x4 vp8_variance4x4_c\n-\n-unsigned int vp8_variance8x16_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance8x16_neon(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance8x16 vp8_variance8x16_neon\n-\n-unsigned int vp8_variance8x8_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance8x8_armv6(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance8x8_neon(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance8x8 vp8_variance8x8_neon\n-\n-unsigned int vp8_variance_halfpixvar16x16_h_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance_halfpixvar16x16_h_armv6(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance_halfpixvar16x16_h_neon(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance_halfpixvar16x16_h vp8_variance_halfpixvar16x16_h_neon\n-\n-unsigned int vp8_variance_halfpixvar16x16_hv_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance_halfpixvar16x16_hv_armv6(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance_halfpixvar16x16_hv_neon(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance_halfpixvar16x16_hv vp8_variance_halfpixvar16x16_hv_neon\n-\n-unsigned int vp8_variance_halfpixvar16x16_v_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance_halfpixvar16x16_v_armv6(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance_halfpixvar16x16_v_neon(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance_halfpixvar16x16_v vp8_variance_halfpixvar16x16_v_neon\n-\n-void vp8_yv12_copy_partial_frame_c(struct yv12_buffer_config *src_ybc, struct yv12_buffer_config *dst_ybc);\n-void vp8_yv12_copy_partial_frame_neon(struct yv12_buffer_config *src_ybc, struct yv12_buffer_config *dst_ybc);\n-#define vp8_yv12_copy_partial_frame vp8_yv12_copy_partial_frame_neon\n-\n void vp8_rtcd(void);\n \n #include \""vpx_config.h\""\n""}<_**next**_>{""filename"": ""armv7a-neon/vp9_rtcd.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/armv7a-neon/vp9_rtcd.h"", ""patch"": ""@@ -7,15 +7,12 @@\n\n #define RTCD_EXTERN extern\n #endif\n \n-#ifdef __cplusplus\n-extern \""C\"" {\n-#endif\n-\n /*\n  * VP9\n  */\n \n #include \""vpx/vpx_integer.h\""\n+#include \""vp9/common/vp9_common.h\""\n #include \""vp9/common/vp9_enums.h\""\n \n struct macroblockd;\n@@ -23,715 +20,98 @@\n\n /* Encoder forward decls */\n struct macroblock;\n struct vp9_variance_vtable;\n-\n-#define DEC_MVCOSTS int *mvjcost, int *mvcost[2]\n+struct search_site_config;\n struct mv;\n union int_mv;\n struct yv12_buffer_config;\n \n-void vp9_blend_b_c(uint8_t *y, uint8_t *u, uint8_t *v, int y1, int u1, int v1, int alpha, int stride);\n-#define vp9_blend_b vp9_blend_b_c\n+#ifdef __cplusplus\n+extern \""C\"" {\n+#endif\n \n-void vp9_blend_mb_inner_c(uint8_t *y, uint8_t *u, uint8_t *v, int y1, int u1, int v1, int alpha, int stride);\n-#define vp9_blend_mb_inner vp9_blend_mb_inner_c\n+unsigned int vp9_avg_4x4_c(const uint8_t *, int p);\n+#define vp9_avg_4x4 vp9_avg_4x4_c\n \n-void vp9_blend_mb_outer_c(uint8_t *y, uint8_t *u, uint8_t *v, int y1, int u1, int v1, int alpha, int stride);\n-#define vp9_blend_mb_outer vp9_blend_mb_outer_c\n+unsigned int vp9_avg_8x8_c(const uint8_t *, int p);\n+unsigned int vp9_avg_8x8_neon(const uint8_t *, int p);\n+#define vp9_avg_8x8 vp9_avg_8x8_neon\n \n-int64_t vp9_block_error_c(const int16_t *coeff, const int16_t *dqcoeff, intptr_t block_size, int64_t *ssz);\n+int64_t vp9_block_error_c(const tran_low_t *coeff, const tran_low_t *dqcoeff, intptr_t block_size, int64_t *ssz);\n #define vp9_block_error vp9_block_error_c\n \n-void vp9_convolve8_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-void vp9_convolve8_neon(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8 vp9_convolve8_neon\n+int64_t vp9_block_error_fp_c(const int16_t *coeff, const int16_t *dqcoeff, int block_size);\n+int64_t vp9_block_error_fp_neon(const int16_t *coeff, const int16_t *dqcoeff, int block_size);\n+#define vp9_block_error_fp vp9_block_error_fp_neon\n \n-void vp9_convolve8_avg_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-void vp9_convolve8_avg_neon(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8_avg vp9_convolve8_avg_neon\n-\n-void vp9_convolve8_avg_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-void vp9_convolve8_avg_horiz_neon(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8_avg_horiz vp9_convolve8_avg_horiz_neon\n-\n-void vp9_convolve8_avg_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-void vp9_convolve8_avg_vert_neon(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8_avg_vert vp9_convolve8_avg_vert_neon\n-\n-void vp9_convolve8_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-void vp9_convolve8_horiz_neon(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8_horiz vp9_convolve8_horiz_neon\n-\n-void vp9_convolve8_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-void vp9_convolve8_vert_neon(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8_vert vp9_convolve8_vert_neon\n-\n-void vp9_convolve_avg_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-void vp9_convolve_avg_neon(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve_avg vp9_convolve_avg_neon\n-\n-void vp9_convolve_copy_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-void vp9_convolve_copy_neon(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve_copy vp9_convolve_copy_neon\n-\n-void vp9_d117_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d117_predictor_16x16 vp9_d117_predictor_16x16_c\n-\n-void vp9_d117_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d117_predictor_32x32 vp9_d117_predictor_32x32_c\n-\n-void vp9_d117_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d117_predictor_4x4 vp9_d117_predictor_4x4_c\n-\n-void vp9_d117_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d117_predictor_8x8 vp9_d117_predictor_8x8_c\n-\n-void vp9_d135_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d135_predictor_16x16 vp9_d135_predictor_16x16_c\n-\n-void vp9_d135_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d135_predictor_32x32 vp9_d135_predictor_32x32_c\n-\n-void vp9_d135_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d135_predictor_4x4 vp9_d135_predictor_4x4_c\n-\n-void vp9_d135_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d135_predictor_8x8 vp9_d135_predictor_8x8_c\n-\n-void vp9_d153_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d153_predictor_16x16 vp9_d153_predictor_16x16_c\n-\n-void vp9_d153_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d153_predictor_32x32 vp9_d153_predictor_32x32_c\n-\n-void vp9_d153_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d153_predictor_4x4 vp9_d153_predictor_4x4_c\n-\n-void vp9_d153_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d153_predictor_8x8 vp9_d153_predictor_8x8_c\n-\n-void vp9_d207_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d207_predictor_16x16 vp9_d207_predictor_16x16_c\n-\n-void vp9_d207_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d207_predictor_32x32 vp9_d207_predictor_32x32_c\n-\n-void vp9_d207_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d207_predictor_4x4 vp9_d207_predictor_4x4_c\n-\n-void vp9_d207_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d207_predictor_8x8 vp9_d207_predictor_8x8_c\n-\n-void vp9_d45_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d45_predictor_16x16 vp9_d45_predictor_16x16_c\n-\n-void vp9_d45_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d45_predictor_32x32 vp9_d45_predictor_32x32_c\n-\n-void vp9_d45_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d45_predictor_4x4 vp9_d45_predictor_4x4_c\n-\n-void vp9_d45_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d45_predictor_8x8 vp9_d45_predictor_8x8_c\n-\n-void vp9_d63_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d63_predictor_16x16 vp9_d63_predictor_16x16_c\n-\n-void vp9_d63_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d63_predictor_32x32 vp9_d63_predictor_32x32_c\n-\n-void vp9_d63_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d63_predictor_4x4 vp9_d63_predictor_4x4_c\n-\n-void vp9_d63_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d63_predictor_8x8 vp9_d63_predictor_8x8_c\n-\n-void vp9_dc_128_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_128_predictor_16x16 vp9_dc_128_predictor_16x16_c\n-\n-void vp9_dc_128_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_128_predictor_32x32 vp9_dc_128_predictor_32x32_c\n-\n-void vp9_dc_128_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_128_predictor_4x4 vp9_dc_128_predictor_4x4_c\n-\n-void vp9_dc_128_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_128_predictor_8x8 vp9_dc_128_predictor_8x8_c\n-\n-void vp9_dc_left_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_left_predictor_16x16 vp9_dc_left_predictor_16x16_c\n-\n-void vp9_dc_left_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_left_predictor_32x32 vp9_dc_left_predictor_32x32_c\n-\n-void vp9_dc_left_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_left_predictor_4x4 vp9_dc_left_predictor_4x4_c\n-\n-void vp9_dc_left_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_left_predictor_8x8 vp9_dc_left_predictor_8x8_c\n-\n-void vp9_dc_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_predictor_16x16 vp9_dc_predictor_16x16_c\n-\n-void vp9_dc_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_predictor_32x32 vp9_dc_predictor_32x32_c\n-\n-void vp9_dc_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_predictor_4x4 vp9_dc_predictor_4x4_c\n-\n-void vp9_dc_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_predictor_8x8 vp9_dc_predictor_8x8_c\n-\n-void vp9_dc_top_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_top_predictor_16x16 vp9_dc_top_predictor_16x16_c\n-\n-void vp9_dc_top_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_top_predictor_32x32 vp9_dc_top_predictor_32x32_c\n-\n-void vp9_dc_top_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_top_predictor_4x4 vp9_dc_top_predictor_4x4_c\n-\n-void vp9_dc_top_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_top_predictor_8x8 vp9_dc_top_predictor_8x8_c\n-\n-int vp9_diamond_search_sad_c(const struct macroblock *x, struct mv *ref_mv, struct mv *best_mv, int search_param, int sad_per_bit, int *num00, const struct vp9_variance_vtable *fn_ptr, DEC_MVCOSTS, const struct mv *center_mv);\n+int vp9_diamond_search_sad_c(const struct macroblock *x, const struct search_site_config *cfg,  struct mv *ref_mv, struct mv *best_mv, int search_param, int sad_per_bit, int *num00, const struct vp9_variance_vtable *fn_ptr, const struct mv *center_mv);\n #define vp9_diamond_search_sad vp9_diamond_search_sad_c\n \n-void vp9_fdct16x16_c(const int16_t *input, int16_t *output, int stride);\n-#define vp9_fdct16x16 vp9_fdct16x16_c\n+void vp9_fdct8x8_quant_c(const int16_t *input, int stride, tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+void vp9_fdct8x8_quant_neon(const int16_t *input, int stride, tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+#define vp9_fdct8x8_quant vp9_fdct8x8_quant_neon\n \n-void vp9_fdct32x32_c(const int16_t *input, int16_t *output, int stride);\n-#define vp9_fdct32x32 vp9_fdct32x32_c\n-\n-void vp9_fdct32x32_rd_c(const int16_t *input, int16_t *output, int stride);\n-#define vp9_fdct32x32_rd vp9_fdct32x32_rd_c\n-\n-void vp9_fdct4x4_c(const int16_t *input, int16_t *output, int stride);\n-#define vp9_fdct4x4 vp9_fdct4x4_c\n-\n-void vp9_fdct8x8_c(const int16_t *input, int16_t *output, int stride);\n-#define vp9_fdct8x8 vp9_fdct8x8_c\n-\n-void vp9_fht16x16_c(const int16_t *input, int16_t *output, int stride, int tx_type);\n+void vp9_fht16x16_c(const int16_t *input, tran_low_t *output, int stride, int tx_type);\n #define vp9_fht16x16 vp9_fht16x16_c\n \n-void vp9_fht4x4_c(const int16_t *input, int16_t *output, int stride, int tx_type);\n+void vp9_fht4x4_c(const int16_t *input, tran_low_t *output, int stride, int tx_type);\n #define vp9_fht4x4 vp9_fht4x4_c\n \n-void vp9_fht8x8_c(const int16_t *input, int16_t *output, int stride, int tx_type);\n+void vp9_fht8x8_c(const int16_t *input, tran_low_t *output, int stride, int tx_type);\n #define vp9_fht8x8 vp9_fht8x8_c\n \n-int vp9_full_range_search_c(const struct macroblock *x, struct mv *ref_mv, struct mv *best_mv, int search_param, int sad_per_bit, int *num00, const struct vp9_variance_vtable *fn_ptr, DEC_MVCOSTS, const struct mv *center_mv);\n+int vp9_full_range_search_c(const struct macroblock *x, const struct search_site_config *cfg, struct mv *ref_mv, struct mv *best_mv, int search_param, int sad_per_bit, int *num00, const struct vp9_variance_vtable *fn_ptr, const struct mv *center_mv);\n #define vp9_full_range_search vp9_full_range_search_c\n \n-int vp9_full_search_sad_c(const struct macroblock *x, const struct mv *ref_mv, int sad_per_bit, int distance, const struct vp9_variance_vtable *fn_ptr, DEC_MVCOSTS, const struct mv *center_mv, struct mv *best_mv);\n+int vp9_full_search_sad_c(const struct macroblock *x, const struct mv *ref_mv, int sad_per_bit, int distance, const struct vp9_variance_vtable *fn_ptr, const struct mv *center_mv, struct mv *best_mv);\n #define vp9_full_search_sad vp9_full_search_sad_c\n \n-void vp9_fwht4x4_c(const int16_t *input, int16_t *output, int stride);\n+void vp9_fwht4x4_c(const int16_t *input, tran_low_t *output, int stride);\n #define vp9_fwht4x4 vp9_fwht4x4_c\n \n-unsigned int vp9_get_mb_ss_c(const int16_t *);\n-#define vp9_get_mb_ss vp9_get_mb_ss_c\n+void vp9_hadamard_16x16_c(int16_t const *src_diff, int src_stride, int16_t *coeff);\n+#define vp9_hadamard_16x16 vp9_hadamard_16x16_c\n \n-void vp9_get_sse_sum_16x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum);\n-#define vp9_get_sse_sum_16x16 vp9_get_sse_sum_16x16_c\n+void vp9_hadamard_8x8_c(int16_t const *src_diff, int src_stride, int16_t *coeff);\n+#define vp9_hadamard_8x8 vp9_hadamard_8x8_c\n \n-void vp9_get_sse_sum_8x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum);\n-#define vp9_get_sse_sum_8x8 vp9_get_sse_sum_8x8_c\n-\n-void vp9_h_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-void vp9_h_predictor_16x16_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_h_predictor_16x16 vp9_h_predictor_16x16_neon\n-\n-void vp9_h_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-void vp9_h_predictor_32x32_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_h_predictor_32x32 vp9_h_predictor_32x32_neon\n-\n-void vp9_h_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-void vp9_h_predictor_4x4_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_h_predictor_4x4 vp9_h_predictor_4x4_neon\n-\n-void vp9_h_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-void vp9_h_predictor_8x8_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_h_predictor_8x8 vp9_h_predictor_8x8_neon\n-\n-void vp9_idct16x16_10_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-void vp9_idct16x16_10_add_neon(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct16x16_10_add vp9_idct16x16_10_add_neon\n-\n-void vp9_idct16x16_1_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-void vp9_idct16x16_1_add_neon(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct16x16_1_add vp9_idct16x16_1_add_neon\n-\n-void vp9_idct16x16_256_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-void vp9_idct16x16_256_add_neon(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct16x16_256_add vp9_idct16x16_256_add_neon\n-\n-void vp9_idct32x32_1024_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-void vp9_idct32x32_1024_add_neon(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct32x32_1024_add vp9_idct32x32_1024_add_neon\n-\n-void vp9_idct32x32_1_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-void vp9_idct32x32_1_add_neon(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct32x32_1_add vp9_idct32x32_1_add_neon\n-\n-void vp9_idct32x32_34_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-void vp9_idct32x32_1024_add_neon(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct32x32_34_add vp9_idct32x32_1024_add_neon\n-\n-void vp9_idct4x4_16_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-void vp9_idct4x4_16_add_neon(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct4x4_16_add vp9_idct4x4_16_add_neon\n-\n-void vp9_idct4x4_1_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-void vp9_idct4x4_1_add_neon(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct4x4_1_add vp9_idct4x4_1_add_neon\n-\n-void vp9_idct8x8_10_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-void vp9_idct8x8_10_add_neon(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct8x8_10_add vp9_idct8x8_10_add_neon\n-\n-void vp9_idct8x8_1_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-void vp9_idct8x8_1_add_neon(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct8x8_1_add vp9_idct8x8_1_add_neon\n-\n-void vp9_idct8x8_64_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-void vp9_idct8x8_64_add_neon(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct8x8_64_add vp9_idct8x8_64_add_neon\n-\n-void vp9_iht16x16_256_add_c(const int16_t *input, uint8_t *output, int pitch, int tx_type);\n+void vp9_iht16x16_256_add_c(const tran_low_t *input, uint8_t *output, int pitch, int tx_type);\n #define vp9_iht16x16_256_add vp9_iht16x16_256_add_c\n \n-void vp9_iht4x4_16_add_c(const int16_t *input, uint8_t *dest, int dest_stride, int tx_type);\n-void vp9_iht4x4_16_add_neon(const int16_t *input, uint8_t *dest, int dest_stride, int tx_type);\n+void vp9_iht4x4_16_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride, int tx_type);\n+void vp9_iht4x4_16_add_neon(const tran_low_t *input, uint8_t *dest, int dest_stride, int tx_type);\n #define vp9_iht4x4_16_add vp9_iht4x4_16_add_neon\n \n-void vp9_iht8x8_64_add_c(const int16_t *input, uint8_t *dest, int dest_stride, int tx_type);\n-void vp9_iht8x8_64_add_neon(const int16_t *input, uint8_t *dest, int dest_stride, int tx_type);\n+void vp9_iht8x8_64_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride, int tx_type);\n+void vp9_iht8x8_64_add_neon(const tran_low_t *input, uint8_t *dest, int dest_stride, int tx_type);\n #define vp9_iht8x8_64_add vp9_iht8x8_64_add_neon\n \n-void vp9_iwht4x4_16_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_iwht4x4_16_add vp9_iwht4x4_16_add_c\n+int16_t vp9_int_pro_col_c(uint8_t const *ref, const int width);\n+int16_t vp9_int_pro_col_neon(uint8_t const *ref, const int width);\n+#define vp9_int_pro_col vp9_int_pro_col_neon\n \n-void vp9_iwht4x4_1_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_iwht4x4_1_add vp9_iwht4x4_1_add_c\n+void vp9_int_pro_row_c(int16_t *hbuf, uint8_t const *ref, const int ref_stride, const int height);\n+void vp9_int_pro_row_neon(int16_t *hbuf, uint8_t const *ref, const int ref_stride, const int height);\n+#define vp9_int_pro_row vp9_int_pro_row_neon\n \n-void vp9_lpf_horizontal_16_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-void vp9_lpf_horizontal_16_neon(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-#define vp9_lpf_horizontal_16 vp9_lpf_horizontal_16_neon\n+void vp9_minmax_8x8_c(const uint8_t *s, int p, const uint8_t *d, int dp, int *min, int *max);\n+#define vp9_minmax_8x8 vp9_minmax_8x8_c\n \n-void vp9_lpf_horizontal_4_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-void vp9_lpf_horizontal_4_neon(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-#define vp9_lpf_horizontal_4 vp9_lpf_horizontal_4_neon\n+void vp9_quantize_fp_c(const tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+void vp9_quantize_fp_neon(const tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+#define vp9_quantize_fp vp9_quantize_fp_neon\n \n-void vp9_lpf_horizontal_4_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n-void vp9_lpf_horizontal_4_dual_neon(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n-#define vp9_lpf_horizontal_4_dual vp9_lpf_horizontal_4_dual_neon\n+void vp9_quantize_fp_32x32_c(const tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+#define vp9_quantize_fp_32x32 vp9_quantize_fp_32x32_c\n \n-void vp9_lpf_horizontal_8_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-void vp9_lpf_horizontal_8_neon(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-#define vp9_lpf_horizontal_8 vp9_lpf_horizontal_8_neon\n+int16_t vp9_satd_c(const int16_t *coeff, int length);\n+#define vp9_satd vp9_satd_c\n \n-void vp9_lpf_horizontal_8_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n-void vp9_lpf_horizontal_8_dual_neon(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n-#define vp9_lpf_horizontal_8_dual vp9_lpf_horizontal_8_dual_neon\n-\n-void vp9_lpf_vertical_16_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh);\n-void vp9_lpf_vertical_16_neon(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh);\n-#define vp9_lpf_vertical_16 vp9_lpf_vertical_16_neon\n-\n-void vp9_lpf_vertical_16_dual_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh);\n-void vp9_lpf_vertical_16_dual_neon(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh);\n-#define vp9_lpf_vertical_16_dual vp9_lpf_vertical_16_dual_neon\n-\n-void vp9_lpf_vertical_4_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-void vp9_lpf_vertical_4_neon(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-#define vp9_lpf_vertical_4 vp9_lpf_vertical_4_neon\n-\n-void vp9_lpf_vertical_4_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n-void vp9_lpf_vertical_4_dual_neon(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n-#define vp9_lpf_vertical_4_dual vp9_lpf_vertical_4_dual_neon\n-\n-void vp9_lpf_vertical_8_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-void vp9_lpf_vertical_8_neon(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-#define vp9_lpf_vertical_8 vp9_lpf_vertical_8_neon\n-\n-void vp9_lpf_vertical_8_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n-void vp9_lpf_vertical_8_dual_neon(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n-#define vp9_lpf_vertical_8_dual vp9_lpf_vertical_8_dual_neon\n-\n-unsigned int vp9_mse16x16_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n-#define vp9_mse16x16 vp9_mse16x16_c\n-\n-unsigned int vp9_mse16x8_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n-#define vp9_mse16x8 vp9_mse16x8_c\n-\n-unsigned int vp9_mse8x16_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n-#define vp9_mse8x16 vp9_mse8x16_c\n-\n-unsigned int vp9_mse8x8_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n-#define vp9_mse8x8 vp9_mse8x8_c\n-\n-void vp9_quantize_b_c(const int16_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, int16_t *qcoeff_ptr, int16_t *dqcoeff_ptr, const int16_t *dequant_ptr, int zbin_oq_value, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n-#define vp9_quantize_b vp9_quantize_b_c\n-\n-void vp9_quantize_b_32x32_c(const int16_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, int16_t *qcoeff_ptr, int16_t *dqcoeff_ptr, const int16_t *dequant_ptr, int zbin_oq_value, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n-#define vp9_quantize_b_32x32 vp9_quantize_b_32x32_c\n-\n-int vp9_refining_search_sad_c(const struct macroblock *x, struct mv *ref_mv, int sad_per_bit, int distance, const struct vp9_variance_vtable *fn_ptr, DEC_MVCOSTS, const struct mv *center_mv);\n-#define vp9_refining_search_sad vp9_refining_search_sad_c\n-\n-unsigned int vp9_sad16x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad16x16 vp9_sad16x16_c\n-\n-unsigned int vp9_sad16x16_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad16x16_avg vp9_sad16x16_avg_c\n-\n-void vp9_sad16x16x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad16x16x3 vp9_sad16x16x3_c\n-\n-void vp9_sad16x16x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad16x16x4d vp9_sad16x16x4d_c\n-\n-void vp9_sad16x16x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad16x16x8 vp9_sad16x16x8_c\n-\n-unsigned int vp9_sad16x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad16x32 vp9_sad16x32_c\n-\n-unsigned int vp9_sad16x32_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad16x32_avg vp9_sad16x32_avg_c\n-\n-void vp9_sad16x32x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad16x32x4d vp9_sad16x32x4d_c\n-\n-unsigned int vp9_sad16x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad16x8 vp9_sad16x8_c\n-\n-unsigned int vp9_sad16x8_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad16x8_avg vp9_sad16x8_avg_c\n-\n-void vp9_sad16x8x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad16x8x3 vp9_sad16x8x3_c\n-\n-void vp9_sad16x8x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad16x8x4d vp9_sad16x8x4d_c\n-\n-void vp9_sad16x8x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad16x8x8 vp9_sad16x8x8_c\n-\n-unsigned int vp9_sad32x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad32x16 vp9_sad32x16_c\n-\n-unsigned int vp9_sad32x16_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad32x16_avg vp9_sad32x16_avg_c\n-\n-void vp9_sad32x16x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad32x16x4d vp9_sad32x16x4d_c\n-\n-unsigned int vp9_sad32x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad32x32 vp9_sad32x32_c\n-\n-unsigned int vp9_sad32x32_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad32x32_avg vp9_sad32x32_avg_c\n-\n-void vp9_sad32x32x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad32x32x3 vp9_sad32x32x3_c\n-\n-void vp9_sad32x32x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad32x32x4d vp9_sad32x32x4d_c\n-\n-void vp9_sad32x32x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad32x32x8 vp9_sad32x32x8_c\n-\n-unsigned int vp9_sad32x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad32x64 vp9_sad32x64_c\n-\n-unsigned int vp9_sad32x64_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad32x64_avg vp9_sad32x64_avg_c\n-\n-void vp9_sad32x64x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad32x64x4d vp9_sad32x64x4d_c\n-\n-unsigned int vp9_sad4x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad4x4 vp9_sad4x4_c\n-\n-unsigned int vp9_sad4x4_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad4x4_avg vp9_sad4x4_avg_c\n-\n-void vp9_sad4x4x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad4x4x3 vp9_sad4x4x3_c\n-\n-void vp9_sad4x4x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad4x4x4d vp9_sad4x4x4d_c\n-\n-void vp9_sad4x4x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad4x4x8 vp9_sad4x4x8_c\n-\n-unsigned int vp9_sad4x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad4x8 vp9_sad4x8_c\n-\n-unsigned int vp9_sad4x8_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad4x8_avg vp9_sad4x8_avg_c\n-\n-void vp9_sad4x8x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_ptr[], int ref_stride, unsigned int *sad_array);\n-#define vp9_sad4x8x4d vp9_sad4x8x4d_c\n-\n-void vp9_sad4x8x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n-#define vp9_sad4x8x8 vp9_sad4x8x8_c\n-\n-unsigned int vp9_sad64x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad64x32 vp9_sad64x32_c\n-\n-unsigned int vp9_sad64x32_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad64x32_avg vp9_sad64x32_avg_c\n-\n-void vp9_sad64x32x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad64x32x4d vp9_sad64x32x4d_c\n-\n-unsigned int vp9_sad64x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad64x64 vp9_sad64x64_c\n-\n-unsigned int vp9_sad64x64_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad64x64_avg vp9_sad64x64_avg_c\n-\n-void vp9_sad64x64x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad64x64x3 vp9_sad64x64x3_c\n-\n-void vp9_sad64x64x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad64x64x4d vp9_sad64x64x4d_c\n-\n-void vp9_sad64x64x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad64x64x8 vp9_sad64x64x8_c\n-\n-unsigned int vp9_sad8x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad8x16 vp9_sad8x16_c\n-\n-unsigned int vp9_sad8x16_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad8x16_avg vp9_sad8x16_avg_c\n-\n-void vp9_sad8x16x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad8x16x3 vp9_sad8x16x3_c\n-\n-void vp9_sad8x16x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad8x16x4d vp9_sad8x16x4d_c\n-\n-void vp9_sad8x16x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad8x16x8 vp9_sad8x16x8_c\n-\n-unsigned int vp9_sad8x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad8x4 vp9_sad8x4_c\n-\n-unsigned int vp9_sad8x4_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad8x4_avg vp9_sad8x4_avg_c\n-\n-void vp9_sad8x4x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_ptr[], int ref_stride, unsigned int *sad_array);\n-#define vp9_sad8x4x4d vp9_sad8x4x4d_c\n-\n-void vp9_sad8x4x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n-#define vp9_sad8x4x8 vp9_sad8x4x8_c\n-\n-unsigned int vp9_sad8x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad8x8 vp9_sad8x8_c\n-\n-unsigned int vp9_sad8x8_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad8x8_avg vp9_sad8x8_avg_c\n-\n-void vp9_sad8x8x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad8x8x3 vp9_sad8x8x3_c\n-\n-void vp9_sad8x8x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad8x8x4d vp9_sad8x8x4d_c\n-\n-void vp9_sad8x8x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad8x8x8 vp9_sad8x8x8_c\n-\n-unsigned int vp9_sub_pixel_avg_variance16x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance16x16 vp9_sub_pixel_avg_variance16x16_c\n-\n-unsigned int vp9_sub_pixel_avg_variance16x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance16x32 vp9_sub_pixel_avg_variance16x32_c\n-\n-unsigned int vp9_sub_pixel_avg_variance16x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance16x8 vp9_sub_pixel_avg_variance16x8_c\n-\n-unsigned int vp9_sub_pixel_avg_variance32x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance32x16 vp9_sub_pixel_avg_variance32x16_c\n-\n-unsigned int vp9_sub_pixel_avg_variance32x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance32x32 vp9_sub_pixel_avg_variance32x32_c\n-\n-unsigned int vp9_sub_pixel_avg_variance32x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance32x64 vp9_sub_pixel_avg_variance32x64_c\n-\n-unsigned int vp9_sub_pixel_avg_variance4x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance4x4 vp9_sub_pixel_avg_variance4x4_c\n-\n-unsigned int vp9_sub_pixel_avg_variance4x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance4x8 vp9_sub_pixel_avg_variance4x8_c\n-\n-unsigned int vp9_sub_pixel_avg_variance64x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance64x32 vp9_sub_pixel_avg_variance64x32_c\n-\n-unsigned int vp9_sub_pixel_avg_variance64x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance64x64 vp9_sub_pixel_avg_variance64x64_c\n-\n-unsigned int vp9_sub_pixel_avg_variance8x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance8x16 vp9_sub_pixel_avg_variance8x16_c\n-\n-unsigned int vp9_sub_pixel_avg_variance8x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance8x4 vp9_sub_pixel_avg_variance8x4_c\n-\n-unsigned int vp9_sub_pixel_avg_variance8x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance8x8 vp9_sub_pixel_avg_variance8x8_c\n-\n-unsigned int vp9_sub_pixel_mse32x32_c(const uint8_t *src_ptr, int  source_stride, int  xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_mse32x32 vp9_sub_pixel_mse32x32_c\n-\n-unsigned int vp9_sub_pixel_mse64x64_c(const uint8_t *src_ptr, int  source_stride, int  xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_mse64x64 vp9_sub_pixel_mse64x64_c\n-\n-unsigned int vp9_sub_pixel_variance16x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance16x16 vp9_sub_pixel_variance16x16_c\n-\n-unsigned int vp9_sub_pixel_variance16x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance16x32 vp9_sub_pixel_variance16x32_c\n-\n-unsigned int vp9_sub_pixel_variance16x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance16x8 vp9_sub_pixel_variance16x8_c\n-\n-unsigned int vp9_sub_pixel_variance32x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance32x16 vp9_sub_pixel_variance32x16_c\n-\n-unsigned int vp9_sub_pixel_variance32x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance32x32 vp9_sub_pixel_variance32x32_c\n-\n-unsigned int vp9_sub_pixel_variance32x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance32x64 vp9_sub_pixel_variance32x64_c\n-\n-unsigned int vp9_sub_pixel_variance4x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance4x4 vp9_sub_pixel_variance4x4_c\n-\n-unsigned int vp9_sub_pixel_variance4x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance4x8 vp9_sub_pixel_variance4x8_c\n-\n-unsigned int vp9_sub_pixel_variance64x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance64x32 vp9_sub_pixel_variance64x32_c\n-\n-unsigned int vp9_sub_pixel_variance64x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance64x64 vp9_sub_pixel_variance64x64_c\n-\n-unsigned int vp9_sub_pixel_variance8x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance8x16 vp9_sub_pixel_variance8x16_c\n-\n-unsigned int vp9_sub_pixel_variance8x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance8x4 vp9_sub_pixel_variance8x4_c\n-\n-unsigned int vp9_sub_pixel_variance8x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance8x8 vp9_sub_pixel_variance8x8_c\n-\n-void vp9_subtract_block_c(int rows, int cols, int16_t *diff_ptr, ptrdiff_t diff_stride, const uint8_t *src_ptr, ptrdiff_t src_stride, const uint8_t *pred_ptr, ptrdiff_t pred_stride);\n-#define vp9_subtract_block vp9_subtract_block_c\n-\n-void vp9_temporal_filter_apply_c(uint8_t *frame1, unsigned int stride, uint8_t *frame2, unsigned int block_size, int strength, int filter_weight, unsigned int *accumulator, uint16_t *count);\n+void vp9_temporal_filter_apply_c(uint8_t *frame1, unsigned int stride, uint8_t *frame2, unsigned int block_width, unsigned int block_height, int strength, int filter_weight, unsigned int *accumulator, uint16_t *count);\n #define vp9_temporal_filter_apply vp9_temporal_filter_apply_c\n \n-void vp9_tm_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-void vp9_tm_predictor_16x16_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_tm_predictor_16x16 vp9_tm_predictor_16x16_neon\n-\n-void vp9_tm_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-void vp9_tm_predictor_32x32_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_tm_predictor_32x32 vp9_tm_predictor_32x32_neon\n-\n-void vp9_tm_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-void vp9_tm_predictor_4x4_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_tm_predictor_4x4 vp9_tm_predictor_4x4_neon\n-\n-void vp9_tm_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-void vp9_tm_predictor_8x8_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_tm_predictor_8x8 vp9_tm_predictor_8x8_neon\n-\n-void vp9_v_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-void vp9_v_predictor_16x16_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_v_predictor_16x16 vp9_v_predictor_16x16_neon\n-\n-void vp9_v_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-void vp9_v_predictor_32x32_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_v_predictor_32x32 vp9_v_predictor_32x32_neon\n-\n-void vp9_v_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-void vp9_v_predictor_4x4_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_v_predictor_4x4 vp9_v_predictor_4x4_neon\n-\n-void vp9_v_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-void vp9_v_predictor_8x8_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_v_predictor_8x8 vp9_v_predictor_8x8_neon\n-\n-unsigned int vp9_variance16x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance16x16 vp9_variance16x16_c\n-\n-unsigned int vp9_variance16x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance16x32 vp9_variance16x32_c\n-\n-unsigned int vp9_variance16x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance16x8 vp9_variance16x8_c\n-\n-unsigned int vp9_variance32x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance32x16 vp9_variance32x16_c\n-\n-unsigned int vp9_variance32x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance32x32 vp9_variance32x32_c\n-\n-unsigned int vp9_variance32x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance32x64 vp9_variance32x64_c\n-\n-unsigned int vp9_variance4x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance4x4 vp9_variance4x4_c\n-\n-unsigned int vp9_variance4x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance4x8 vp9_variance4x8_c\n-\n-unsigned int vp9_variance64x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance64x32 vp9_variance64x32_c\n-\n-unsigned int vp9_variance64x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance64x64 vp9_variance64x64_c\n-\n-unsigned int vp9_variance8x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance8x16 vp9_variance8x16_c\n-\n-unsigned int vp9_variance8x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance8x4 vp9_variance8x4_c\n-\n-unsigned int vp9_variance8x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance8x8 vp9_variance8x8_c\n-\n-unsigned int vp9_variance_halfpixvar16x16_h_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar16x16_h vp9_variance_halfpixvar16x16_h_c\n-\n-unsigned int vp9_variance_halfpixvar16x16_hv_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar16x16_hv vp9_variance_halfpixvar16x16_hv_c\n-\n-unsigned int vp9_variance_halfpixvar16x16_v_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar16x16_v vp9_variance_halfpixvar16x16_v_c\n-\n-unsigned int vp9_variance_halfpixvar32x32_h_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar32x32_h vp9_variance_halfpixvar32x32_h_c\n-\n-unsigned int vp9_variance_halfpixvar32x32_hv_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar32x32_hv vp9_variance_halfpixvar32x32_hv_c\n-\n-unsigned int vp9_variance_halfpixvar32x32_v_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar32x32_v vp9_variance_halfpixvar32x32_v_c\n-\n-unsigned int vp9_variance_halfpixvar64x64_h_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar64x64_h vp9_variance_halfpixvar64x64_h_c\n-\n-unsigned int vp9_variance_halfpixvar64x64_hv_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar64x64_hv vp9_variance_halfpixvar64x64_hv_c\n-\n-unsigned int vp9_variance_halfpixvar64x64_v_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar64x64_v vp9_variance_halfpixvar64x64_v_c\n+int vp9_vector_var_c(int16_t const *ref, int16_t const *src, const int bwl);\n+int vp9_vector_var_neon(int16_t const *ref, int16_t const *src, const int bwl);\n+#define vp9_vector_var vp9_vector_var_neon\n \n void vp9_rtcd(void);\n \n""}<_**next**_>{""filename"": ""armv7a-neon/vpx_config.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/armv7a-neon/vpx_config.c"", ""patch"": ""@@ -5,5 +5,6 @@\n\n /* tree. An additional intellectual property rights grant can be found */\n /* in the file PATENTS.  All contributing project authors may */\n /* be found in the AUTHORS file in the root of the source tree. */\n-static const char* const cfg = \""--target=armv7-android-gcc --disable-runtime-cpu-detect --sdk-path=/usr/local/google/home/hkuang/Downloads/android-ndk-r9d --disable-examples --disable-docs --enable-realtime-only\"";\n+#include \""vpx/vpx_codec.h\""\n+static const char* const cfg = \""--target=armv7-android-gcc --disable-runtime-cpu-detect --sdk-path=/usr/local/google/home/vigneshv/Downloads/android-ndk-r10 --disable-examples --disable-docs --enable-realtime-only --disable-webm-io\"";\n const char *vpx_codec_build_config(void) {return cfg;}\n""}<_**next**_>{""filename"": ""armv7a-neon/vpx_config.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/armv7a-neon/vpx_config.h"", ""patch"": ""@@ -9,18 +9,19 @@\n\n #ifndef VPX_CONFIG_H\n #define VPX_CONFIG_H\n #define RESTRICT    \n-#define INLINE      __inline__ __attribute__((always_inline))\n+#define INLINE      inline\n #define ARCH_ARM 1\n #define ARCH_MIPS 0\n #define ARCH_X86 0\n #define ARCH_X86_64 0\n-#define ARCH_PPC32 0\n-#define ARCH_PPC64 0\n-#define HAVE_EDSP 1\n+#define HAVE_EDSP 0\n #define HAVE_MEDIA 1\n #define HAVE_NEON 1\n+#define HAVE_NEON_ASM 1\n #define HAVE_MIPS32 0\n #define HAVE_DSPR2 0\n+#define HAVE_MSA 0\n+#define HAVE_MIPS64 0\n #define HAVE_MMX 0\n #define HAVE_SSE 0\n #define HAVE_SSE2 0\n@@ -29,19 +30,18 @@\n\n #define HAVE_SSE4_1 0\n #define HAVE_AVX 0\n #define HAVE_AVX2 0\n-#define HAVE_ALTIVEC 0\n #define HAVE_VPX_PORTS 1\n #define HAVE_STDINT_H 1\n-#define HAVE_ALT_TREE_LAYOUT 0\n #define HAVE_PTHREAD_H 1\n #define HAVE_SYS_MMAN_H 1\n #define HAVE_UNISTD_H 1\n+#define CONFIG_DEPENDENCY_TRACKING 1\n #define CONFIG_EXTERNAL_BUILD 0\n-#define CONFIG_INSTALL_DOCS 0\n+#define CONFIG_INSTALL_DOCS 1\n #define CONFIG_INSTALL_BINS 1\n #define CONFIG_INSTALL_LIBS 1\n #define CONFIG_INSTALL_SRCS 0\n-#define CONFIG_USE_X86INC 1\n+#define CONFIG_USE_X86INC 0\n #define CONFIG_DEBUG 0\n #define CONFIG_GPROF 0\n #define CONFIG_GCOV 0\n@@ -52,10 +52,6 @@\n\n #define CONFIG_BIG_ENDIAN 0\n #define CONFIG_CODEC_SRCS 0\n #define CONFIG_DEBUG_LIBS 0\n-#define CONFIG_FAST_UNALIGNED 1\n-#define CONFIG_MEM_MANAGER 0\n-#define CONFIG_MEM_TRACKER 0\n-#define CONFIG_MEM_CHECKS 0\n #define CONFIG_DEQUANT_TOKENS 0\n #define CONFIG_DC_RECON 0\n #define CONFIG_RUNTIME_CPU_DETECT 0\n@@ -67,8 +63,11 @@\n\n #define CONFIG_VP8_DECODER 1\n #define CONFIG_VP9_ENCODER 1\n #define CONFIG_VP9_DECODER 1\n+#define CONFIG_VP10_ENCODER 0\n+#define CONFIG_VP10_DECODER 0\n #define CONFIG_VP8 1\n #define CONFIG_VP9 1\n+#define CONFIG_VP10 0\n #define CONFIG_ENCODERS 1\n #define CONFIG_DECODERS 1\n #define CONFIG_STATIC_MSVCRT 0\n@@ -82,12 +81,18 @@\n\n #define CONFIG_POSTPROC_VISUALIZER 0\n #define CONFIG_OS_SUPPORT 1\n #define CONFIG_UNIT_TESTS 0\n-#define CONFIG_WEBM_IO 1\n+#define CONFIG_WEBM_IO 0\n+#define CONFIG_LIBYUV 1\n #define CONFIG_DECODE_PERF_TESTS 0\n+#define CONFIG_ENCODE_PERF_TESTS 0\n #define CONFIG_MULTI_RES_ENCODING 0\n #define CONFIG_TEMPORAL_DENOISING 1\n+#define CONFIG_VP9_TEMPORAL_DENOISING 0\n+#define CONFIG_COEFFICIENT_RANGE_CHECKING 0\n+#define CONFIG_VP9_HIGHBITDEPTH 0\n #define CONFIG_EXPERIMENTAL 0\n-#define CONFIG_DECRYPT 0\n-#define CONFIG_MULTIPLE_ARF 0\n-#define CONFIG_ALPHA 0\n+#define CONFIG_SIZE_LIMIT 0\n+#define CONFIG_SPATIAL_SVC 0\n+#define CONFIG_FP_MB_STATS 0\n+#define CONFIG_EMULATE_HARDWARE 0\n #endif /* VPX_CONFIG_H */\n""}<_**next**_>{""filename"": ""armv7a-neon/vpx_dsp_rtcd.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/armv7a-neon/vpx_dsp_rtcd.h"", ""patch"": ""@@ -0,0 +1,765 @@\n\n+#ifndef VPX_DSP_RTCD_H_\n+#define VPX_DSP_RTCD_H_\n+\n+#ifdef RTCD_C\n+#define RTCD_EXTERN\n+#else\n+#define RTCD_EXTERN extern\n+#endif\n+\n+/*\n+ * DSP\n+ */\n+\n+#include \""vpx/vpx_integer.h\""\n+#include \""vpx_dsp/vpx_dsp_common.h\""\n+\n+\n+#ifdef __cplusplus\n+extern \""C\"" {\n+#endif\n+\n+void vpx_comp_avg_pred_c(uint8_t *comp_pred, const uint8_t *pred, int width, int height, const uint8_t *ref, int ref_stride);\n+#define vpx_comp_avg_pred vpx_comp_avg_pred_c\n+\n+void vpx_convolve8_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+void vpx_convolve8_neon(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8 vpx_convolve8_neon\n+\n+void vpx_convolve8_avg_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+void vpx_convolve8_avg_neon(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8_avg vpx_convolve8_avg_neon\n+\n+void vpx_convolve8_avg_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+void vpx_convolve8_avg_horiz_neon(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8_avg_horiz vpx_convolve8_avg_horiz_neon\n+\n+void vpx_convolve8_avg_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+void vpx_convolve8_avg_vert_neon(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8_avg_vert vpx_convolve8_avg_vert_neon\n+\n+void vpx_convolve8_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+void vpx_convolve8_horiz_neon(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8_horiz vpx_convolve8_horiz_neon\n+\n+void vpx_convolve8_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+void vpx_convolve8_vert_neon(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8_vert vpx_convolve8_vert_neon\n+\n+void vpx_convolve_avg_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+void vpx_convolve_avg_neon(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve_avg vpx_convolve_avg_neon\n+\n+void vpx_convolve_copy_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+void vpx_convolve_copy_neon(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve_copy vpx_convolve_copy_neon\n+\n+void vpx_d117_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d117_predictor_16x16 vpx_d117_predictor_16x16_c\n+\n+void vpx_d117_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d117_predictor_32x32 vpx_d117_predictor_32x32_c\n+\n+void vpx_d117_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d117_predictor_4x4 vpx_d117_predictor_4x4_c\n+\n+void vpx_d117_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d117_predictor_8x8 vpx_d117_predictor_8x8_c\n+\n+void vpx_d135_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d135_predictor_16x16 vpx_d135_predictor_16x16_c\n+\n+void vpx_d135_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d135_predictor_32x32 vpx_d135_predictor_32x32_c\n+\n+void vpx_d135_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_d135_predictor_4x4_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d135_predictor_4x4 vpx_d135_predictor_4x4_neon\n+\n+void vpx_d135_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d135_predictor_8x8 vpx_d135_predictor_8x8_c\n+\n+void vpx_d153_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d153_predictor_16x16 vpx_d153_predictor_16x16_c\n+\n+void vpx_d153_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d153_predictor_32x32 vpx_d153_predictor_32x32_c\n+\n+void vpx_d153_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d153_predictor_4x4 vpx_d153_predictor_4x4_c\n+\n+void vpx_d153_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d153_predictor_8x8 vpx_d153_predictor_8x8_c\n+\n+void vpx_d207_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d207_predictor_16x16 vpx_d207_predictor_16x16_c\n+\n+void vpx_d207_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d207_predictor_32x32 vpx_d207_predictor_32x32_c\n+\n+void vpx_d207_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d207_predictor_4x4 vpx_d207_predictor_4x4_c\n+\n+void vpx_d207_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d207_predictor_8x8 vpx_d207_predictor_8x8_c\n+\n+void vpx_d45_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_d45_predictor_16x16_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d45_predictor_16x16 vpx_d45_predictor_16x16_neon\n+\n+void vpx_d45_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d45_predictor_32x32 vpx_d45_predictor_32x32_c\n+\n+void vpx_d45_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_d45_predictor_4x4_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d45_predictor_4x4 vpx_d45_predictor_4x4_neon\n+\n+void vpx_d45_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_d45_predictor_8x8_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d45_predictor_8x8 vpx_d45_predictor_8x8_neon\n+\n+void vpx_d63_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d63_predictor_16x16 vpx_d63_predictor_16x16_c\n+\n+void vpx_d63_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d63_predictor_32x32 vpx_d63_predictor_32x32_c\n+\n+void vpx_d63_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d63_predictor_4x4 vpx_d63_predictor_4x4_c\n+\n+void vpx_d63_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d63_predictor_8x8 vpx_d63_predictor_8x8_c\n+\n+void vpx_dc_128_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_dc_128_predictor_16x16_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_128_predictor_16x16 vpx_dc_128_predictor_16x16_neon\n+\n+void vpx_dc_128_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_dc_128_predictor_32x32_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_128_predictor_32x32 vpx_dc_128_predictor_32x32_neon\n+\n+void vpx_dc_128_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_dc_128_predictor_4x4_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_128_predictor_4x4 vpx_dc_128_predictor_4x4_neon\n+\n+void vpx_dc_128_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_dc_128_predictor_8x8_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_128_predictor_8x8 vpx_dc_128_predictor_8x8_neon\n+\n+void vpx_dc_left_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_dc_left_predictor_16x16_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_left_predictor_16x16 vpx_dc_left_predictor_16x16_neon\n+\n+void vpx_dc_left_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_dc_left_predictor_32x32_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_left_predictor_32x32 vpx_dc_left_predictor_32x32_neon\n+\n+void vpx_dc_left_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_dc_left_predictor_4x4_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_left_predictor_4x4 vpx_dc_left_predictor_4x4_neon\n+\n+void vpx_dc_left_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_dc_left_predictor_8x8_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_left_predictor_8x8 vpx_dc_left_predictor_8x8_neon\n+\n+void vpx_dc_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_dc_predictor_16x16_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_predictor_16x16 vpx_dc_predictor_16x16_neon\n+\n+void vpx_dc_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_dc_predictor_32x32_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_predictor_32x32 vpx_dc_predictor_32x32_neon\n+\n+void vpx_dc_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_dc_predictor_4x4_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_predictor_4x4 vpx_dc_predictor_4x4_neon\n+\n+void vpx_dc_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_dc_predictor_8x8_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_predictor_8x8 vpx_dc_predictor_8x8_neon\n+\n+void vpx_dc_top_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_dc_top_predictor_16x16_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_top_predictor_16x16 vpx_dc_top_predictor_16x16_neon\n+\n+void vpx_dc_top_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_dc_top_predictor_32x32_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_top_predictor_32x32 vpx_dc_top_predictor_32x32_neon\n+\n+void vpx_dc_top_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_dc_top_predictor_4x4_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_top_predictor_4x4 vpx_dc_top_predictor_4x4_neon\n+\n+void vpx_dc_top_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_dc_top_predictor_8x8_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_top_predictor_8x8 vpx_dc_top_predictor_8x8_neon\n+\n+void vpx_fdct16x16_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct16x16 vpx_fdct16x16_c\n+\n+void vpx_fdct16x16_1_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct16x16_1 vpx_fdct16x16_1_c\n+\n+void vpx_fdct32x32_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct32x32 vpx_fdct32x32_c\n+\n+void vpx_fdct32x32_1_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct32x32_1 vpx_fdct32x32_1_c\n+\n+void vpx_fdct32x32_rd_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct32x32_rd vpx_fdct32x32_rd_c\n+\n+void vpx_fdct4x4_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct4x4 vpx_fdct4x4_c\n+\n+void vpx_fdct4x4_1_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct4x4_1 vpx_fdct4x4_1_c\n+\n+void vpx_fdct8x8_c(const int16_t *input, tran_low_t *output, int stride);\n+void vpx_fdct8x8_neon(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct8x8 vpx_fdct8x8_neon\n+\n+void vpx_fdct8x8_1_c(const int16_t *input, tran_low_t *output, int stride);\n+void vpx_fdct8x8_1_neon(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct8x8_1 vpx_fdct8x8_1_neon\n+\n+void vpx_get16x16var_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum);\n+void vpx_get16x16var_neon(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum);\n+#define vpx_get16x16var vpx_get16x16var_neon\n+\n+unsigned int vpx_get4x4sse_cs_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride);\n+unsigned int vpx_get4x4sse_cs_neon(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride);\n+#define vpx_get4x4sse_cs vpx_get4x4sse_cs_neon\n+\n+void vpx_get8x8var_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum);\n+void vpx_get8x8var_neon(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum);\n+#define vpx_get8x8var vpx_get8x8var_neon\n+\n+unsigned int vpx_get_mb_ss_c(const int16_t *);\n+#define vpx_get_mb_ss vpx_get_mb_ss_c\n+\n+void vpx_h_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_h_predictor_16x16_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_h_predictor_16x16 vpx_h_predictor_16x16_neon\n+\n+void vpx_h_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_h_predictor_32x32_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_h_predictor_32x32 vpx_h_predictor_32x32_neon\n+\n+void vpx_h_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_h_predictor_4x4_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_h_predictor_4x4 vpx_h_predictor_4x4_neon\n+\n+void vpx_h_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_h_predictor_8x8_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_h_predictor_8x8 vpx_h_predictor_8x8_neon\n+\n+void vpx_idct16x16_10_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+void vpx_idct16x16_10_add_neon(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct16x16_10_add vpx_idct16x16_10_add_neon\n+\n+void vpx_idct16x16_1_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+void vpx_idct16x16_1_add_neon(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct16x16_1_add vpx_idct16x16_1_add_neon\n+\n+void vpx_idct16x16_256_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+void vpx_idct16x16_256_add_neon(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct16x16_256_add vpx_idct16x16_256_add_neon\n+\n+void vpx_idct32x32_1024_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+void vpx_idct32x32_1024_add_neon(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct32x32_1024_add vpx_idct32x32_1024_add_neon\n+\n+void vpx_idct32x32_1_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+void vpx_idct32x32_1_add_neon(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct32x32_1_add vpx_idct32x32_1_add_neon\n+\n+void vpx_idct32x32_34_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+void vpx_idct32x32_1024_add_neon(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct32x32_34_add vpx_idct32x32_1024_add_neon\n+\n+void vpx_idct4x4_16_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+void vpx_idct4x4_16_add_neon(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct4x4_16_add vpx_idct4x4_16_add_neon\n+\n+void vpx_idct4x4_1_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+void vpx_idct4x4_1_add_neon(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct4x4_1_add vpx_idct4x4_1_add_neon\n+\n+void vpx_idct8x8_12_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+void vpx_idct8x8_12_add_neon(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct8x8_12_add vpx_idct8x8_12_add_neon\n+\n+void vpx_idct8x8_1_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+void vpx_idct8x8_1_add_neon(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct8x8_1_add vpx_idct8x8_1_add_neon\n+\n+void vpx_idct8x8_64_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+void vpx_idct8x8_64_add_neon(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct8x8_64_add vpx_idct8x8_64_add_neon\n+\n+void vpx_iwht4x4_16_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_iwht4x4_16_add vpx_iwht4x4_16_add_c\n+\n+void vpx_iwht4x4_1_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_iwht4x4_1_add vpx_iwht4x4_1_add_c\n+\n+void vpx_lpf_horizontal_16_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+void vpx_lpf_horizontal_16_neon(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+#define vpx_lpf_horizontal_16 vpx_lpf_horizontal_16_neon\n+\n+void vpx_lpf_horizontal_4_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+void vpx_lpf_horizontal_4_neon(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+#define vpx_lpf_horizontal_4 vpx_lpf_horizontal_4_neon\n+\n+void vpx_lpf_horizontal_4_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n+void vpx_lpf_horizontal_4_dual_neon(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n+#define vpx_lpf_horizontal_4_dual vpx_lpf_horizontal_4_dual_neon\n+\n+void vpx_lpf_horizontal_8_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+void vpx_lpf_horizontal_8_neon(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+#define vpx_lpf_horizontal_8 vpx_lpf_horizontal_8_neon\n+\n+void vpx_lpf_horizontal_8_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n+void vpx_lpf_horizontal_8_dual_neon(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n+#define vpx_lpf_horizontal_8_dual vpx_lpf_horizontal_8_dual_neon\n+\n+void vpx_lpf_vertical_16_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh);\n+void vpx_lpf_vertical_16_neon(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh);\n+#define vpx_lpf_vertical_16 vpx_lpf_vertical_16_neon\n+\n+void vpx_lpf_vertical_16_dual_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh);\n+void vpx_lpf_vertical_16_dual_neon(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh);\n+#define vpx_lpf_vertical_16_dual vpx_lpf_vertical_16_dual_neon\n+\n+void vpx_lpf_vertical_4_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+void vpx_lpf_vertical_4_neon(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+#define vpx_lpf_vertical_4 vpx_lpf_vertical_4_neon\n+\n+void vpx_lpf_vertical_4_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n+void vpx_lpf_vertical_4_dual_neon(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n+#define vpx_lpf_vertical_4_dual vpx_lpf_vertical_4_dual_neon\n+\n+void vpx_lpf_vertical_8_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+void vpx_lpf_vertical_8_neon(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+#define vpx_lpf_vertical_8 vpx_lpf_vertical_8_neon\n+\n+void vpx_lpf_vertical_8_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n+void vpx_lpf_vertical_8_dual_neon(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n+#define vpx_lpf_vertical_8_dual vpx_lpf_vertical_8_dual_neon\n+\n+unsigned int vpx_mse16x16_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n+unsigned int vpx_mse16x16_media(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n+unsigned int vpx_mse16x16_neon(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n+#define vpx_mse16x16 vpx_mse16x16_neon\n+\n+unsigned int vpx_mse16x8_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n+#define vpx_mse16x8 vpx_mse16x8_c\n+\n+unsigned int vpx_mse8x16_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n+#define vpx_mse8x16 vpx_mse8x16_c\n+\n+unsigned int vpx_mse8x8_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n+#define vpx_mse8x8 vpx_mse8x8_c\n+\n+void vpx_quantize_b_c(const tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+#define vpx_quantize_b vpx_quantize_b_c\n+\n+void vpx_quantize_b_32x32_c(const tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+#define vpx_quantize_b_32x32 vpx_quantize_b_32x32_c\n+\n+unsigned int vpx_sad16x16_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+unsigned int vpx_sad16x16_media(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+unsigned int vpx_sad16x16_neon(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad16x16 vpx_sad16x16_neon\n+\n+unsigned int vpx_sad16x16_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad16x16_avg vpx_sad16x16_avg_c\n+\n+void vpx_sad16x16x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x16x3 vpx_sad16x16x3_c\n+\n+void vpx_sad16x16x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+void vpx_sad16x16x4d_neon(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x16x4d vpx_sad16x16x4d_neon\n+\n+void vpx_sad16x16x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x16x8 vpx_sad16x16x8_c\n+\n+unsigned int vpx_sad16x32_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad16x32 vpx_sad16x32_c\n+\n+unsigned int vpx_sad16x32_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad16x32_avg vpx_sad16x32_avg_c\n+\n+void vpx_sad16x32x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x32x4d vpx_sad16x32x4d_c\n+\n+unsigned int vpx_sad16x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+unsigned int vpx_sad16x8_neon(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad16x8 vpx_sad16x8_neon\n+\n+unsigned int vpx_sad16x8_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad16x8_avg vpx_sad16x8_avg_c\n+\n+void vpx_sad16x8x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x8x3 vpx_sad16x8x3_c\n+\n+void vpx_sad16x8x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x8x4d vpx_sad16x8x4d_c\n+\n+void vpx_sad16x8x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x8x8 vpx_sad16x8x8_c\n+\n+unsigned int vpx_sad32x16_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad32x16 vpx_sad32x16_c\n+\n+unsigned int vpx_sad32x16_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad32x16_avg vpx_sad32x16_avg_c\n+\n+void vpx_sad32x16x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad32x16x4d vpx_sad32x16x4d_c\n+\n+unsigned int vpx_sad32x32_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+unsigned int vpx_sad32x32_neon(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad32x32 vpx_sad32x32_neon\n+\n+unsigned int vpx_sad32x32_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad32x32_avg vpx_sad32x32_avg_c\n+\n+void vpx_sad32x32x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad32x32x3 vpx_sad32x32x3_c\n+\n+void vpx_sad32x32x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+void vpx_sad32x32x4d_neon(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad32x32x4d vpx_sad32x32x4d_neon\n+\n+void vpx_sad32x32x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad32x32x8 vpx_sad32x32x8_c\n+\n+unsigned int vpx_sad32x64_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad32x64 vpx_sad32x64_c\n+\n+unsigned int vpx_sad32x64_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad32x64_avg vpx_sad32x64_avg_c\n+\n+void vpx_sad32x64x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad32x64x4d vpx_sad32x64x4d_c\n+\n+unsigned int vpx_sad4x4_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+unsigned int vpx_sad4x4_neon(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad4x4 vpx_sad4x4_neon\n+\n+unsigned int vpx_sad4x4_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad4x4_avg vpx_sad4x4_avg_c\n+\n+void vpx_sad4x4x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad4x4x3 vpx_sad4x4x3_c\n+\n+void vpx_sad4x4x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad4x4x4d vpx_sad4x4x4d_c\n+\n+void vpx_sad4x4x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad4x4x8 vpx_sad4x4x8_c\n+\n+unsigned int vpx_sad4x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad4x8 vpx_sad4x8_c\n+\n+unsigned int vpx_sad4x8_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad4x8_avg vpx_sad4x8_avg_c\n+\n+void vpx_sad4x8x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad4x8x4d vpx_sad4x8x4d_c\n+\n+void vpx_sad4x8x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad4x8x8 vpx_sad4x8x8_c\n+\n+unsigned int vpx_sad64x32_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad64x32 vpx_sad64x32_c\n+\n+unsigned int vpx_sad64x32_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad64x32_avg vpx_sad64x32_avg_c\n+\n+void vpx_sad64x32x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad64x32x4d vpx_sad64x32x4d_c\n+\n+unsigned int vpx_sad64x64_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+unsigned int vpx_sad64x64_neon(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad64x64 vpx_sad64x64_neon\n+\n+unsigned int vpx_sad64x64_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad64x64_avg vpx_sad64x64_avg_c\n+\n+void vpx_sad64x64x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad64x64x3 vpx_sad64x64x3_c\n+\n+void vpx_sad64x64x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+void vpx_sad64x64x4d_neon(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad64x64x4d vpx_sad64x64x4d_neon\n+\n+void vpx_sad64x64x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad64x64x8 vpx_sad64x64x8_c\n+\n+unsigned int vpx_sad8x16_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+unsigned int vpx_sad8x16_neon(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad8x16 vpx_sad8x16_neon\n+\n+unsigned int vpx_sad8x16_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad8x16_avg vpx_sad8x16_avg_c\n+\n+void vpx_sad8x16x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x16x3 vpx_sad8x16x3_c\n+\n+void vpx_sad8x16x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x16x4d vpx_sad8x16x4d_c\n+\n+void vpx_sad8x16x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x16x8 vpx_sad8x16x8_c\n+\n+unsigned int vpx_sad8x4_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad8x4 vpx_sad8x4_c\n+\n+unsigned int vpx_sad8x4_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad8x4_avg vpx_sad8x4_avg_c\n+\n+void vpx_sad8x4x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x4x4d vpx_sad8x4x4d_c\n+\n+void vpx_sad8x4x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x4x8 vpx_sad8x4x8_c\n+\n+unsigned int vpx_sad8x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+unsigned int vpx_sad8x8_neon(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad8x8 vpx_sad8x8_neon\n+\n+unsigned int vpx_sad8x8_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad8x8_avg vpx_sad8x8_avg_c\n+\n+void vpx_sad8x8x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x8x3 vpx_sad8x8x3_c\n+\n+void vpx_sad8x8x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x8x4d vpx_sad8x8x4d_c\n+\n+void vpx_sad8x8x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x8x8 vpx_sad8x8x8_c\n+\n+void vpx_scaled_2d_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_2d vpx_scaled_2d_c\n+\n+void vpx_scaled_avg_2d_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_avg_2d vpx_scaled_avg_2d_c\n+\n+void vpx_scaled_avg_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_avg_horiz vpx_scaled_avg_horiz_c\n+\n+void vpx_scaled_avg_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_avg_vert vpx_scaled_avg_vert_c\n+\n+void vpx_scaled_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_horiz vpx_scaled_horiz_c\n+\n+void vpx_scaled_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_vert vpx_scaled_vert_c\n+\n+uint32_t vpx_sub_pixel_avg_variance16x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance16x16 vpx_sub_pixel_avg_variance16x16_c\n+\n+uint32_t vpx_sub_pixel_avg_variance16x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance16x32 vpx_sub_pixel_avg_variance16x32_c\n+\n+uint32_t vpx_sub_pixel_avg_variance16x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance16x8 vpx_sub_pixel_avg_variance16x8_c\n+\n+uint32_t vpx_sub_pixel_avg_variance32x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance32x16 vpx_sub_pixel_avg_variance32x16_c\n+\n+uint32_t vpx_sub_pixel_avg_variance32x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance32x32 vpx_sub_pixel_avg_variance32x32_c\n+\n+uint32_t vpx_sub_pixel_avg_variance32x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance32x64 vpx_sub_pixel_avg_variance32x64_c\n+\n+uint32_t vpx_sub_pixel_avg_variance4x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance4x4 vpx_sub_pixel_avg_variance4x4_c\n+\n+uint32_t vpx_sub_pixel_avg_variance4x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance4x8 vpx_sub_pixel_avg_variance4x8_c\n+\n+uint32_t vpx_sub_pixel_avg_variance64x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance64x32 vpx_sub_pixel_avg_variance64x32_c\n+\n+uint32_t vpx_sub_pixel_avg_variance64x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance64x64 vpx_sub_pixel_avg_variance64x64_c\n+\n+uint32_t vpx_sub_pixel_avg_variance8x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance8x16 vpx_sub_pixel_avg_variance8x16_c\n+\n+uint32_t vpx_sub_pixel_avg_variance8x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance8x4 vpx_sub_pixel_avg_variance8x4_c\n+\n+uint32_t vpx_sub_pixel_avg_variance8x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance8x8 vpx_sub_pixel_avg_variance8x8_c\n+\n+uint32_t vpx_sub_pixel_variance16x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+uint32_t vpx_sub_pixel_variance16x16_media(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+uint32_t vpx_sub_pixel_variance16x16_neon(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance16x16 vpx_sub_pixel_variance16x16_neon\n+\n+uint32_t vpx_sub_pixel_variance16x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance16x32 vpx_sub_pixel_variance16x32_c\n+\n+uint32_t vpx_sub_pixel_variance16x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance16x8 vpx_sub_pixel_variance16x8_c\n+\n+uint32_t vpx_sub_pixel_variance32x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance32x16 vpx_sub_pixel_variance32x16_c\n+\n+uint32_t vpx_sub_pixel_variance32x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+uint32_t vpx_sub_pixel_variance32x32_neon(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance32x32 vpx_sub_pixel_variance32x32_neon\n+\n+uint32_t vpx_sub_pixel_variance32x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance32x64 vpx_sub_pixel_variance32x64_c\n+\n+uint32_t vpx_sub_pixel_variance4x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance4x4 vpx_sub_pixel_variance4x4_c\n+\n+uint32_t vpx_sub_pixel_variance4x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance4x8 vpx_sub_pixel_variance4x8_c\n+\n+uint32_t vpx_sub_pixel_variance64x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance64x32 vpx_sub_pixel_variance64x32_c\n+\n+uint32_t vpx_sub_pixel_variance64x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+uint32_t vpx_sub_pixel_variance64x64_neon(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance64x64 vpx_sub_pixel_variance64x64_neon\n+\n+uint32_t vpx_sub_pixel_variance8x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance8x16 vpx_sub_pixel_variance8x16_c\n+\n+uint32_t vpx_sub_pixel_variance8x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance8x4 vpx_sub_pixel_variance8x4_c\n+\n+uint32_t vpx_sub_pixel_variance8x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+uint32_t vpx_sub_pixel_variance8x8_media(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+uint32_t vpx_sub_pixel_variance8x8_neon(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance8x8 vpx_sub_pixel_variance8x8_neon\n+\n+void vpx_subtract_block_c(int rows, int cols, int16_t *diff_ptr, ptrdiff_t diff_stride, const uint8_t *src_ptr, ptrdiff_t src_stride, const uint8_t *pred_ptr, ptrdiff_t pred_stride);\n+void vpx_subtract_block_neon(int rows, int cols, int16_t *diff_ptr, ptrdiff_t diff_stride, const uint8_t *src_ptr, ptrdiff_t src_stride, const uint8_t *pred_ptr, ptrdiff_t pred_stride);\n+#define vpx_subtract_block vpx_subtract_block_neon\n+\n+void vpx_tm_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_tm_predictor_16x16_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_tm_predictor_16x16 vpx_tm_predictor_16x16_neon\n+\n+void vpx_tm_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_tm_predictor_32x32_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_tm_predictor_32x32 vpx_tm_predictor_32x32_neon\n+\n+void vpx_tm_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_tm_predictor_4x4_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_tm_predictor_4x4 vpx_tm_predictor_4x4_neon\n+\n+void vpx_tm_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_tm_predictor_8x8_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_tm_predictor_8x8 vpx_tm_predictor_8x8_neon\n+\n+void vpx_v_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_v_predictor_16x16_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_v_predictor_16x16 vpx_v_predictor_16x16_neon\n+\n+void vpx_v_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_v_predictor_32x32_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_v_predictor_32x32 vpx_v_predictor_32x32_neon\n+\n+void vpx_v_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_v_predictor_4x4_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_v_predictor_4x4 vpx_v_predictor_4x4_neon\n+\n+void vpx_v_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+void vpx_v_predictor_8x8_neon(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_v_predictor_8x8 vpx_v_predictor_8x8_neon\n+\n+unsigned int vpx_variance16x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+unsigned int vpx_variance16x16_media(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+unsigned int vpx_variance16x16_neon(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance16x16 vpx_variance16x16_neon\n+\n+unsigned int vpx_variance16x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance16x32 vpx_variance16x32_c\n+\n+unsigned int vpx_variance16x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+unsigned int vpx_variance16x8_neon(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance16x8 vpx_variance16x8_neon\n+\n+unsigned int vpx_variance32x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance32x16 vpx_variance32x16_c\n+\n+unsigned int vpx_variance32x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+unsigned int vpx_variance32x32_neon(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance32x32 vpx_variance32x32_neon\n+\n+unsigned int vpx_variance32x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+unsigned int vpx_variance32x64_neon(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance32x64 vpx_variance32x64_neon\n+\n+unsigned int vpx_variance4x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance4x4 vpx_variance4x4_c\n+\n+unsigned int vpx_variance4x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance4x8 vpx_variance4x8_c\n+\n+unsigned int vpx_variance64x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+unsigned int vpx_variance64x32_neon(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance64x32 vpx_variance64x32_neon\n+\n+unsigned int vpx_variance64x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+unsigned int vpx_variance64x64_neon(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance64x64 vpx_variance64x64_neon\n+\n+unsigned int vpx_variance8x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+unsigned int vpx_variance8x16_neon(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance8x16 vpx_variance8x16_neon\n+\n+unsigned int vpx_variance8x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance8x4 vpx_variance8x4_c\n+\n+unsigned int vpx_variance8x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+unsigned int vpx_variance8x8_media(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+unsigned int vpx_variance8x8_neon(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance8x8 vpx_variance8x8_neon\n+\n+uint32_t vpx_variance_halfpixvar16x16_h_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, uint32_t *sse);\n+uint32_t vpx_variance_halfpixvar16x16_h_media(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, uint32_t *sse);\n+#define vpx_variance_halfpixvar16x16_h vpx_variance_halfpixvar16x16_h_media\n+\n+uint32_t vpx_variance_halfpixvar16x16_hv_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, uint32_t *sse);\n+uint32_t vpx_variance_halfpixvar16x16_hv_media(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, uint32_t *sse);\n+#define vpx_variance_halfpixvar16x16_hv vpx_variance_halfpixvar16x16_hv_media\n+\n+uint32_t vpx_variance_halfpixvar16x16_v_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, uint32_t *sse);\n+uint32_t vpx_variance_halfpixvar16x16_v_media(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, uint32_t *sse);\n+#define vpx_variance_halfpixvar16x16_v vpx_variance_halfpixvar16x16_v_media\n+\n+void vpx_dsp_rtcd(void);\n+\n+#include \""vpx_config.h\""\n+\n+#ifdef RTCD_C\n+#include \""vpx_ports/arm.h\""\n+static void setup_rtcd_internal(void)\n+{\n+    int flags = arm_cpu_caps();\n+\n+    (void)flags;\n+\n+}\n+#endif\n+\n+#ifdef __cplusplus\n+}  // extern \""C\""\n+#endif\n+\n+#endif\n""}<_**next**_>{""filename"": ""armv7a-neon/vpx_scale_rtcd.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/armv7a-neon/vpx_scale_rtcd.h"", ""patch"": ""@@ -7,12 +7,12 @@\n\n #define RTCD_EXTERN extern\n #endif\n \n+struct yv12_buffer_config;\n+\n #ifdef __cplusplus\n extern \""C\"" {\n #endif\n \n-struct yv12_buffer_config;\n-\n void vp8_horizontal_line_2_1_scale_c(const unsigned char *source, unsigned int source_width, unsigned char *dest, unsigned int dest_width);\n #define vp8_horizontal_line_2_1_scale vp8_horizontal_line_2_1_scale_c\n \n@@ -35,18 +35,16 @@\n\n #define vp8_vertical_band_5_4_scale vp8_vertical_band_5_4_scale_c\n \n void vp8_yv12_copy_frame_c(const struct yv12_buffer_config *src_ybc, struct yv12_buffer_config *dst_ybc);\n-void vp8_yv12_copy_frame_neon(const struct yv12_buffer_config *src_ybc, struct yv12_buffer_config *dst_ybc);\n-#define vp8_yv12_copy_frame vp8_yv12_copy_frame_neon\n+#define vp8_yv12_copy_frame vp8_yv12_copy_frame_c\n \n void vp8_yv12_extend_frame_borders_c(struct yv12_buffer_config *ybf);\n-void vp8_yv12_extend_frame_borders_neon(struct yv12_buffer_config *ybf);\n-#define vp8_yv12_extend_frame_borders vp8_yv12_extend_frame_borders_neon\n+#define vp8_yv12_extend_frame_borders vp8_yv12_extend_frame_borders_c\n \n-void vp9_extend_frame_borders_c(struct yv12_buffer_config *ybf);\n-#define vp9_extend_frame_borders vp9_extend_frame_borders_c\n+void vpx_extend_frame_borders_c(struct yv12_buffer_config *ybf);\n+#define vpx_extend_frame_borders vpx_extend_frame_borders_c\n \n-void vp9_extend_frame_inner_borders_c(struct yv12_buffer_config *ybf);\n-#define vp9_extend_frame_inner_borders vp9_extend_frame_inner_borders_c\n+void vpx_extend_frame_inner_borders_c(struct yv12_buffer_config *ybf);\n+#define vpx_extend_frame_inner_borders vpx_extend_frame_inner_borders_c\n \n void vpx_yv12_copy_y_c(const struct yv12_buffer_config *src_ybc, struct yv12_buffer_config *dst_ybc);\n #define vpx_yv12_copy_y vpx_yv12_copy_y_c\n""}<_**next**_>{""filename"": ""armv7a-neon/vpx_version.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/armv7a-neon/vpx_version.h"", ""patch"": ""@@ -1,7 +1,7 @@\n\n #define VERSION_MAJOR  1\n-#define VERSION_MINOR  3\n+#define VERSION_MINOR  4\n #define VERSION_PATCH  0\n-#define VERSION_EXTRA  \""2239-g4fffefe\""\n+#define VERSION_EXTRA  \""\""\n #define VERSION_PACKED ((VERSION_MAJOR<<16)|(VERSION_MINOR<<8)|(VERSION_PATCH))\n-#define VERSION_STRING_NOSP \""v1.3.0-2239-g4fffefe\""\n-#define VERSION_STRING      \"" v1.3.0-2239-g4fffefe\""\n+#define VERSION_STRING_NOSP \""v1.4.0\""\n+#define VERSION_STRING      \"" v1.4.0\""\n""}<_**next**_>{""filename"": ""armv7a/libvpx_srcs.txt"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/armv7a/libvpx_srcs.txt"", ""patch"": ""@@ -1,6 +1,6 @@\n\n+CHANGELOG\n build/make/rtcd.pl\n build/make/version.sh\n-CHANGELOG\n libs.mk\n vp8/common/alloccommon.c\n vp8/common/alloccommon.h\n@@ -19,23 +19,16 @@\n\n vp8/common/arm/armv6/loopfilter_v6.asm.s\n vp8/common/arm/armv6/simpleloopfilter_v6.asm.s\n vp8/common/arm/armv6/sixtappredict8x4_v6.asm.s\n-vp8/common/arm/armv6/vp8_sad16x16_armv6.asm.s\n-vp8/common/arm/armv6/vp8_variance16x16_armv6.asm.s\n-vp8/common/arm/armv6/vp8_variance8x8_armv6.asm.s\n-vp8/common/arm/armv6/vp8_variance_halfpixvar16x16_h_armv6.asm.s\n-vp8/common/arm/armv6/vp8_variance_halfpixvar16x16_hv_armv6.asm.s\n-vp8/common/arm/armv6/vp8_variance_halfpixvar16x16_v_armv6.asm.s\n vp8/common/arm/bilinearfilter_arm.c\n vp8/common/arm/bilinearfilter_arm.h\n vp8/common/arm/dequantize_arm.c\n vp8/common/arm/filter_arm.c\n vp8/common/arm/loopfilter_arm.c\n-vp8/common/arm/reconintra_arm.c\n-vp8/common/arm/variance_arm.c\n vp8/common/blockd.c\n vp8/common/blockd.h\n vp8/common/coefupdateprobs.h\n vp8/common/common.h\n+vp8/common/copy_c.c\n vp8/common/debugmodes.c\n vp8/common/default_coef_probs.h\n vp8/common/dequantize.c\n@@ -56,28 +49,25 @@\n\n vp8/common/idct_blk.c\n vp8/common/idctllm.c\n vp8/common/invtrans.h\n-vp8/common/loopfilter.c\n-vp8/common/loopfilter_filters.c\n vp8/common/loopfilter.h\n+vp8/common/loopfilter_filters.c\n vp8/common/mbpitch.c\n vp8/common/modecont.c\n vp8/common/modecont.h\n vp8/common/mv.h\n+vp8/common/onyx.h\n vp8/common/onyxc_int.h\n vp8/common/onyxd.h\n-vp8/common/onyx.h\n vp8/common/ppflags.h\n-vp8/common/pragmas.h\n vp8/common/quant_common.c\n vp8/common/quant_common.h\n vp8/common/reconinter.c\n vp8/common/reconinter.h\n+vp8/common/reconintra.c\n vp8/common/reconintra4x4.c\n vp8/common/reconintra4x4.h\n-vp8/common/reconintra.c\n vp8/common/rtcd.c\n vp8/common/rtcd_defs.pl\n-vp8/common/sad_c.c\n vp8/common/setupintrarecon.c\n vp8/common/setupintrarecon.h\n vp8/common/swapyv12buffer.c\n@@ -86,9 +76,8 @@\n\n vp8/common/threading.h\n vp8/common/treecoder.c\n vp8/common/treecoder.h\n-vp8/common/variance_c.c\n-vp8/common/variance.h\n vp8/common/vp8_entropymodedata.h\n+vp8/common/vp8_loopfilter.c\n vp8/decoder/dboolhuff.c\n vp8/decoder/dboolhuff.h\n vp8/decoder/decodeframe.c\n@@ -101,21 +90,13 @@\n\n vp8/decoder/onyxd_int.h\n vp8/decoder/threading.c\n vp8/decoder/treereader.h\n-vp8/encoder/arm/armv5te/boolhuff_armv5te.asm.s\n-vp8/encoder/arm/armv5te/vp8_packtokens_armv5.asm.s\n-vp8/encoder/arm/armv5te/vp8_packtokens_mbrow_armv5.asm.s\n-vp8/encoder/arm/armv5te/vp8_packtokens_partitions_armv5.asm.s\n-vp8/encoder/arm/armv6/vp8_fast_quantize_b_armv6.asm.s\n-vp8/encoder/arm/armv6/vp8_mse16x16_armv6.asm.s\n vp8/encoder/arm/armv6/vp8_short_fdct4x4_armv6.asm.s\n-vp8/encoder/arm/armv6/vp8_subtract_armv6.asm.s\n vp8/encoder/arm/armv6/walsh_v6.asm.s\n-vp8/encoder/arm/boolhuff_arm.c\n vp8/encoder/arm/dct_arm.c\n-vp8/encoder/arm/quantize_arm.c\n vp8/encoder/bitstream.c\n vp8/encoder/bitstream.h\n vp8/encoder/block.h\n+vp8/encoder/boolhuff.c\n vp8/encoder/boolhuff.h\n vp8/encoder/dct.c\n vp8/encoder/dct_value_cost.h\n@@ -144,7 +125,6 @@\n\n vp8/encoder/pickinter.c\n vp8/encoder/pickinter.h\n vp8/encoder/picklpf.c\n-vp8/encoder/quantize.c\n vp8/encoder/quantize.h\n vp8/encoder/ratectrl.c\n vp8/encoder/ratectrl.h\n@@ -156,22 +136,20 @@\n\n vp8/encoder/tokenize.h\n vp8/encoder/treewriter.c\n vp8/encoder/treewriter.h\n-vp8/encoder/vp8_asm_enc_offsets.c\n+vp8/encoder/vp8_quantize.c\n vp8/vp8_common.mk\n-vp8/vp8cx_arm.mk\n vp8/vp8_cx_iface.c\n-vp8/vp8cx.mk\n vp8/vp8_dx_iface.c\n+vp8/vp8cx.mk\n+vp8/vp8cx_arm.mk\n vp8/vp8dx.mk\n vp9/common/vp9_alloccommon.c\n vp9/common/vp9_alloccommon.h\n vp9/common/vp9_blockd.c\n vp9/common/vp9_blockd.h\n+vp9/common/vp9_common.h\n vp9/common/vp9_common_data.c\n vp9/common/vp9_common_data.h\n-vp9/common/vp9_common.h\n-vp9/common/vp9_convolve.c\n-vp9/common/vp9_convolve.h\n vp9/common/vp9_debugmodes.c\n vp9/common/vp9_entropy.c\n vp9/common/vp9_entropy.h\n@@ -187,18 +165,14 @@\n\n vp9/common/vp9_idct.c\n vp9/common/vp9_idct.h\n vp9/common/vp9_loopfilter.c\n-vp9/common/vp9_loopfilter_filters.c\n vp9/common/vp9_loopfilter.h\n vp9/common/vp9_mv.h\n vp9/common/vp9_mvref_common.c\n vp9/common/vp9_mvref_common.h\n vp9/common/vp9_onyxc_int.h\n vp9/common/vp9_ppflags.h\n-vp9/common/vp9_pragmas.h\n vp9/common/vp9_pred_common.c\n vp9/common/vp9_pred_common.h\n-vp9/common/vp9_prob.c\n-vp9/common/vp9_prob.h\n vp9/common/vp9_quant_common.c\n vp9/common/vp9_quant_common.h\n vp9/common/vp9_reconinter.c\n@@ -213,8 +187,9 @@\n\n vp9/common/vp9_scan.h\n vp9/common/vp9_seg_common.c\n vp9/common/vp9_seg_common.h\n-vp9/common/vp9_systemdependent.h\n vp9/common/vp9_textblit.h\n+vp9/common/vp9_thread_common.c\n+vp9/common/vp9_thread_common.h\n vp9/common/vp9_tile_common.c\n vp9/common/vp9_tile_common.h\n vp9/decoder/vp9_decodeframe.c\n@@ -229,21 +204,18 @@\n\n vp9/decoder/vp9_dsubexp.h\n vp9/decoder/vp9_dthread.c\n vp9/decoder/vp9_dthread.h\n-vp9/decoder/vp9_read_bit_buffer.c\n-vp9/decoder/vp9_read_bit_buffer.h\n-vp9/decoder/vp9_reader.c\n-vp9/decoder/vp9_reader.h\n-vp9/decoder/vp9_thread.c\n-vp9/decoder/vp9_thread.h\n vp9/encoder/vp9_aq_complexity.c\n vp9/encoder/vp9_aq_complexity.h\n vp9/encoder/vp9_aq_cyclicrefresh.c\n vp9/encoder/vp9_aq_cyclicrefresh.h\n vp9/encoder/vp9_aq_variance.c\n vp9/encoder/vp9_aq_variance.h\n+vp9/encoder/vp9_avg.c\n vp9/encoder/vp9_bitstream.c\n vp9/encoder/vp9_bitstream.h\n vp9/encoder/vp9_block.h\n+vp9/encoder/vp9_context_tree.c\n+vp9/encoder/vp9_context_tree.h\n vp9/encoder/vp9_cost.c\n vp9/encoder/vp9_cost.h\n vp9/encoder/vp9_dct.c\n@@ -253,6 +225,10 @@\n\n vp9/encoder/vp9_encodemb.h\n vp9/encoder/vp9_encodemv.c\n vp9/encoder/vp9_encodemv.h\n+vp9/encoder/vp9_encoder.c\n+vp9/encoder/vp9_encoder.h\n+vp9/encoder/vp9_ethread.c\n+vp9/encoder/vp9_ethread.h\n vp9/encoder/vp9_extend.c\n vp9/encoder/vp9_extend.h\n vp9/encoder/vp9_firstpass.c\n@@ -263,8 +239,6 @@\n\n vp9/encoder/vp9_mbgraph.h\n vp9/encoder/vp9_mcomp.c\n vp9/encoder/vp9_mcomp.h\n-vp9/encoder/vp9_onyx_if.c\n-vp9/encoder/vp9_onyx_int.h\n vp9/encoder/vp9_picklpf.c\n vp9/encoder/vp9_picklpf.h\n vp9/encoder/vp9_pickmode.c\n@@ -273,13 +247,16 @@\n\n vp9/encoder/vp9_quantize.h\n vp9/encoder/vp9_ratectrl.c\n vp9/encoder/vp9_ratectrl.h\n+vp9/encoder/vp9_rd.c\n+vp9/encoder/vp9_rd.h\n vp9/encoder/vp9_rdopt.c\n vp9/encoder/vp9_rdopt.h\n vp9/encoder/vp9_resize.c\n vp9/encoder/vp9_resize.h\n-vp9/encoder/vp9_sad.c\n vp9/encoder/vp9_segmentation.c\n vp9/encoder/vp9_segmentation.h\n+vp9/encoder/vp9_skin_detection.c\n+vp9/encoder/vp9_skin_detection.h\n vp9/encoder/vp9_speed_features.c\n vp9/encoder/vp9_speed_features.h\n vp9/encoder/vp9_subexp.c\n@@ -292,55 +269,22 @@\n\n vp9/encoder/vp9_tokenize.h\n vp9/encoder/vp9_treewriter.c\n vp9/encoder/vp9_treewriter.h\n-vp9/encoder/vp9_variance.c\n-vp9/encoder/vp9_variance.h\n-vp9/encoder/vp9_write_bit_buffer.c\n-vp9/encoder/vp9_write_bit_buffer.h\n-vp9/encoder/vp9_writer.c\n-vp9/encoder/vp9_writer.h\n vp9/vp9_common.mk\n vp9/vp9_cx_iface.c\n-vp9/vp9cx.mk\n vp9/vp9_dx_iface.c\n-vp9/vp9dx.mk\n vp9/vp9_iface_common.h\n-vpx_config.c\n+vp9/vp9cx.mk\n+vp9/vp9dx.mk\n vpx/internal/vpx_codec_internal.h\n vpx/internal/vpx_psnr.h\n-vpx_mem/include/vpx_mem_intrnl.h\n-vpx_mem/vpx_mem.c\n-vpx_mem/vpx_mem.h\n-vpx_mem/vpx_mem.mk\n-vpx_ports/arm_cpudetect.c\n-vpx_ports/arm.h\n-vpx_ports/asm_offsets.h\n-vpx_ports/emmintrin_compat.h\n-vpx_ports/mem.h\n-vpx_ports/mem_ops_aligned.h\n-vpx_ports/mem_ops.h\n-vpx_ports/vpx_once.h\n-vpx_ports/vpx_ports.mk\n-vpx_ports/vpx_timer.h\n-vpx_scale/generic/gen_scalers.c\n-vpx_scale/generic/vpx_scale.c\n-vpx_scale/generic/yv12config.c\n-vpx_scale/generic/yv12extend.c\n-vpx_scale/vpx_scale_asm_offsets.c\n-vpx_scale/vpx_scale.h\n-vpx_scale/vpx_scale.mk\n-vpx_scale/vpx_scale_rtcd.c\n-vpx_scale/vpx_scale_rtcd.pl\n-vpx_scale/yv12config.h\n-vpx/src/svc_encodeframe.c\n vpx/src/vpx_codec.c\n vpx/src/vpx_decoder.c\n vpx/src/vpx_encoder.c\n vpx/src/vpx_image.c\n vpx/src/vpx_psnr.c\n-vpx/svc_context.h\n+vpx/vp8.h\n vpx/vp8cx.h\n vpx/vp8dx.h\n-vpx/vp8.h\n vpx/vpx_codec.h\n vpx/vpx_codec.mk\n vpx/vpx_decoder.h\n@@ -348,3 +292,70 @@\n\n vpx/vpx_frame_buffer.h\n vpx/vpx_image.h\n vpx/vpx_integer.h\n+vpx_config.c\n+vpx_dsp/arm/bilinear_filter_media.asm.s\n+vpx_dsp/arm/sad_media.asm.s\n+vpx_dsp/arm/subpel_variance_media.c\n+vpx_dsp/arm/variance_halfpixvar16x16_h_media.asm.s\n+vpx_dsp/arm/variance_halfpixvar16x16_hv_media.asm.s\n+vpx_dsp/arm/variance_halfpixvar16x16_v_media.asm.s\n+vpx_dsp/arm/variance_media.asm.s\n+vpx_dsp/bitreader.c\n+vpx_dsp/bitreader.h\n+vpx_dsp/bitreader_buffer.c\n+vpx_dsp/bitreader_buffer.h\n+vpx_dsp/bitwriter.c\n+vpx_dsp/bitwriter.h\n+vpx_dsp/bitwriter_buffer.c\n+vpx_dsp/bitwriter_buffer.h\n+vpx_dsp/fwd_txfm.c\n+vpx_dsp/fwd_txfm.h\n+vpx_dsp/intrapred.c\n+vpx_dsp/inv_txfm.c\n+vpx_dsp/inv_txfm.h\n+vpx_dsp/loopfilter.c\n+vpx_dsp/prob.c\n+vpx_dsp/prob.h\n+vpx_dsp/quantize.c\n+vpx_dsp/quantize.h\n+vpx_dsp/sad.c\n+vpx_dsp/subtract.c\n+vpx_dsp/txfm_common.h\n+vpx_dsp/variance.c\n+vpx_dsp/variance.h\n+vpx_dsp/vpx_convolve.c\n+vpx_dsp/vpx_convolve.h\n+vpx_dsp/vpx_dsp.mk\n+vpx_dsp/vpx_dsp_common.h\n+vpx_dsp/vpx_dsp_rtcd.c\n+vpx_dsp/vpx_dsp_rtcd_defs.pl\n+vpx_dsp/vpx_filter.h\n+vpx_mem/include/vpx_mem_intrnl.h\n+vpx_mem/vpx_mem.c\n+vpx_mem/vpx_mem.h\n+vpx_mem/vpx_mem.mk\n+vpx_ports/arm.h\n+vpx_ports/arm_cpudetect.c\n+vpx_ports/bitops.h\n+vpx_ports/emmintrin_compat.h\n+vpx_ports/mem.h\n+vpx_ports/mem_ops.h\n+vpx_ports/mem_ops_aligned.h\n+vpx_ports/msvc.h\n+vpx_ports/system_state.h\n+vpx_ports/vpx_once.h\n+vpx_ports/vpx_ports.mk\n+vpx_ports/vpx_timer.h\n+vpx_scale/generic/gen_scalers.c\n+vpx_scale/generic/vpx_scale.c\n+vpx_scale/generic/yv12config.c\n+vpx_scale/generic/yv12extend.c\n+vpx_scale/vpx_scale.h\n+vpx_scale/vpx_scale.mk\n+vpx_scale/vpx_scale_rtcd.c\n+vpx_scale/vpx_scale_rtcd.pl\n+vpx_scale/yv12config.h\n+vpx_util/endian_inl.h\n+vpx_util/vpx_thread.c\n+vpx_util/vpx_thread.h\n+vpx_util/vpx_util.mk\n""}<_**next**_>{""filename"": ""armv7a/vp8_rtcd.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/armv7a/vp8_rtcd.h"", ""patch"": ""@@ -7,10 +7,6 @@\n\n #define RTCD_EXTERN extern\n #endif\n \n-#ifdef __cplusplus\n-extern \""C\"" {\n-#endif\n-\n /*\n  * VP8\n  */\n@@ -26,6 +22,10 @@\n\n union int_mv;\n struct yv12_buffer_config;\n \n+#ifdef __cplusplus\n+extern \""C\"" {\n+#endif\n+\n void vp8_bilinear_predict16x16_c(unsigned char *src, int src_pitch, int xofst, int yofst, unsigned char *dst, int dst_pitch);\n void vp8_bilinear_predict16x16_armv6(unsigned char *src, int src_pitch, int xofst, int yofst, unsigned char *dst, int dst_pitch);\n #define vp8_bilinear_predict16x16 vp8_bilinear_predict16x16_armv6\n@@ -70,9 +70,12 @@\n\n void vp8_dc_only_idct_add_v6(short input, unsigned char *pred, int pred_stride, unsigned char *dst, int dst_stride);\n #define vp8_dc_only_idct_add vp8_dc_only_idct_add_v6\n \n-int vp8_denoiser_filter_c(struct yv12_buffer_config* mc_running_avg, struct yv12_buffer_config* running_avg, struct macroblock* signal, unsigned int motion_magnitude2, int y_offset, int uv_offset);\n+int vp8_denoiser_filter_c(unsigned char *mc_running_avg_y, int mc_avg_y_stride, unsigned char *running_avg_y, int avg_y_stride, unsigned char *sig, int sig_stride, unsigned int motion_magnitude, int increase_denoising);\n #define vp8_denoiser_filter vp8_denoiser_filter_c\n \n+int vp8_denoiser_filter_uv_c(unsigned char *mc_running_avg, int mc_avg_stride, unsigned char *running_avg, int avg_stride, unsigned char *sig, int sig_stride, unsigned int motion_magnitude, int increase_denoising);\n+#define vp8_denoiser_filter_uv vp8_denoiser_filter_uv_c\n+\n void vp8_dequant_idct_add_c(short *input, short *dq, unsigned char *output, int stride);\n void vp8_dequant_idct_add_v6(short *input, short *dq, unsigned char *output, int stride);\n #define vp8_dequant_idct_add vp8_dequant_idct_add_v6\n@@ -93,21 +96,11 @@\n\n #define vp8_diamond_search_sad vp8_diamond_search_sad_c\n \n void vp8_fast_quantize_b_c(struct block *, struct blockd *);\n-void vp8_fast_quantize_b_armv6(struct block *, struct blockd *);\n-#define vp8_fast_quantize_b vp8_fast_quantize_b_armv6\n-\n-void vp8_fast_quantize_b_pair_c(struct block *b1, struct block *b2, struct blockd *d1, struct blockd *d2);\n-#define vp8_fast_quantize_b_pair vp8_fast_quantize_b_pair_c\n+#define vp8_fast_quantize_b vp8_fast_quantize_b_c\n \n int vp8_full_search_sad_c(struct macroblock *x, struct block *b, struct blockd *d, union int_mv *ref_mv, int sad_per_bit, int distance, struct variance_vtable *fn_ptr, int *mvcost[2], union int_mv *center_mv);\n #define vp8_full_search_sad vp8_full_search_sad_c\n \n-unsigned int vp8_get4x4sse_cs_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride);\n-#define vp8_get4x4sse_cs vp8_get4x4sse_cs_c\n-\n-unsigned int vp8_get_mb_ss_c(const short *);\n-#define vp8_get_mb_ss vp8_get_mb_ss_c\n-\n void vp8_intra4x4_predict_c(unsigned char *Above, unsigned char *yleft, int left_stride, int b_mode, unsigned char *dst, int dst_stride, unsigned char top_left);\n void vp8_intra4x4_predict_armv6(unsigned char *Above, unsigned char *yleft, int left_stride, int b_mode, unsigned char *dst, int dst_stride, unsigned char top_left);\n #define vp8_intra4x4_predict vp8_intra4x4_predict_armv6\n@@ -150,89 +143,12 @@\n\n int vp8_mbuverror_c(struct macroblock *mb);\n #define vp8_mbuverror vp8_mbuverror_c\n \n-unsigned int vp8_mse16x16_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_mse16x16_armv6(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_mse16x16 vp8_mse16x16_armv6\n-\n-void vp8_quantize_mb_c(struct macroblock *);\n-#define vp8_quantize_mb vp8_quantize_mb_c\n-\n-void vp8_quantize_mbuv_c(struct macroblock *);\n-#define vp8_quantize_mbuv vp8_quantize_mbuv_c\n-\n-void vp8_quantize_mby_c(struct macroblock *);\n-#define vp8_quantize_mby vp8_quantize_mby_c\n-\n int vp8_refining_search_sad_c(struct macroblock *x, struct block *b, struct blockd *d, union int_mv *ref_mv, int sad_per_bit, int distance, struct variance_vtable *fn_ptr, int *mvcost[2], union int_mv *center_mv);\n #define vp8_refining_search_sad vp8_refining_search_sad_c\n \n void vp8_regular_quantize_b_c(struct block *, struct blockd *);\n #define vp8_regular_quantize_b vp8_regular_quantize_b_c\n \n-void vp8_regular_quantize_b_pair_c(struct block *b1, struct block *b2, struct blockd *d1, struct blockd *d2);\n-#define vp8_regular_quantize_b_pair vp8_regular_quantize_b_pair_c\n-\n-unsigned int vp8_sad16x16_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-unsigned int vp8_sad16x16_armv6(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp8_sad16x16 vp8_sad16x16_armv6\n-\n-void vp8_sad16x16x3_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad16x16x3 vp8_sad16x16x3_c\n-\n-void vp8_sad16x16x4d_c(const unsigned char *src_ptr, int src_stride, const unsigned char * const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad16x16x4d vp8_sad16x16x4d_c\n-\n-void vp8_sad16x16x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned short *sad_array);\n-#define vp8_sad16x16x8 vp8_sad16x16x8_c\n-\n-unsigned int vp8_sad16x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp8_sad16x8 vp8_sad16x8_c\n-\n-void vp8_sad16x8x3_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad16x8x3 vp8_sad16x8x3_c\n-\n-void vp8_sad16x8x4d_c(const unsigned char *src_ptr, int src_stride, const unsigned char * const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad16x8x4d vp8_sad16x8x4d_c\n-\n-void vp8_sad16x8x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned short *sad_array);\n-#define vp8_sad16x8x8 vp8_sad16x8x8_c\n-\n-unsigned int vp8_sad4x4_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp8_sad4x4 vp8_sad4x4_c\n-\n-void vp8_sad4x4x3_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad4x4x3 vp8_sad4x4x3_c\n-\n-void vp8_sad4x4x4d_c(const unsigned char *src_ptr, int src_stride, const unsigned char * const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad4x4x4d vp8_sad4x4x4d_c\n-\n-void vp8_sad4x4x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned short *sad_array);\n-#define vp8_sad4x4x8 vp8_sad4x4x8_c\n-\n-unsigned int vp8_sad8x16_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp8_sad8x16 vp8_sad8x16_c\n-\n-void vp8_sad8x16x3_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad8x16x3 vp8_sad8x16x3_c\n-\n-void vp8_sad8x16x4d_c(const unsigned char *src_ptr, int src_stride, const unsigned char * const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad8x16x4d vp8_sad8x16x4d_c\n-\n-void vp8_sad8x16x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned short *sad_array);\n-#define vp8_sad8x16x8 vp8_sad8x16x8_c\n-\n-unsigned int vp8_sad8x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp8_sad8x8 vp8_sad8x8_c\n-\n-void vp8_sad8x8x3_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad8x8x3 vp8_sad8x8x3_c\n-\n-void vp8_sad8x8x4d_c(const unsigned char *src_ptr, int src_stride, const unsigned char * const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad8x8x4d vp8_sad8x8x4d_c\n-\n-void vp8_sad8x8x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned short *sad_array);\n-#define vp8_sad8x8x8 vp8_sad8x8x8_c\n-\n void vp8_short_fdct4x4_c(short *input, short *output, int pitch);\n void vp8_short_fdct4x4_armv6(short *input, short *output, int pitch);\n #define vp8_short_fdct4x4 vp8_short_fdct4x4_armv6\n@@ -272,70 +188,6 @@\n\n void vp8_sixtap_predict8x8_armv6(unsigned char *src, int src_pitch, int xofst, int yofst, unsigned char *dst, int dst_pitch);\n #define vp8_sixtap_predict8x8 vp8_sixtap_predict8x8_armv6\n \n-unsigned int vp8_sub_pixel_mse16x16_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_mse16x16 vp8_sub_pixel_mse16x16_c\n-\n-unsigned int vp8_sub_pixel_variance16x16_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-unsigned int vp8_sub_pixel_variance16x16_armv6(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_variance16x16 vp8_sub_pixel_variance16x16_armv6\n-\n-unsigned int vp8_sub_pixel_variance16x8_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_variance16x8 vp8_sub_pixel_variance16x8_c\n-\n-unsigned int vp8_sub_pixel_variance4x4_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_variance4x4 vp8_sub_pixel_variance4x4_c\n-\n-unsigned int vp8_sub_pixel_variance8x16_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_variance8x16 vp8_sub_pixel_variance8x16_c\n-\n-unsigned int vp8_sub_pixel_variance8x8_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-unsigned int vp8_sub_pixel_variance8x8_armv6(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_variance8x8 vp8_sub_pixel_variance8x8_armv6\n-\n-void vp8_subtract_b_c(struct block *be, struct blockd *bd, int pitch);\n-void vp8_subtract_b_armv6(struct block *be, struct blockd *bd, int pitch);\n-#define vp8_subtract_b vp8_subtract_b_armv6\n-\n-void vp8_subtract_mbuv_c(short *diff, unsigned char *usrc, unsigned char *vsrc, int src_stride, unsigned char *upred, unsigned char *vpred, int pred_stride);\n-void vp8_subtract_mbuv_armv6(short *diff, unsigned char *usrc, unsigned char *vsrc, int src_stride, unsigned char *upred, unsigned char *vpred, int pred_stride);\n-#define vp8_subtract_mbuv vp8_subtract_mbuv_armv6\n-\n-void vp8_subtract_mby_c(short *diff, unsigned char *src, int src_stride, unsigned char *pred, int pred_stride);\n-void vp8_subtract_mby_armv6(short *diff, unsigned char *src, int src_stride, unsigned char *pred, int pred_stride);\n-#define vp8_subtract_mby vp8_subtract_mby_armv6\n-\n-unsigned int vp8_variance16x16_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance16x16_armv6(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance16x16 vp8_variance16x16_armv6\n-\n-unsigned int vp8_variance16x8_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance16x8 vp8_variance16x8_c\n-\n-unsigned int vp8_variance4x4_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance4x4 vp8_variance4x4_c\n-\n-unsigned int vp8_variance8x16_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance8x16 vp8_variance8x16_c\n-\n-unsigned int vp8_variance8x8_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance8x8_armv6(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance8x8 vp8_variance8x8_armv6\n-\n-unsigned int vp8_variance_halfpixvar16x16_h_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance_halfpixvar16x16_h_armv6(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance_halfpixvar16x16_h vp8_variance_halfpixvar16x16_h_armv6\n-\n-unsigned int vp8_variance_halfpixvar16x16_hv_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance_halfpixvar16x16_hv_armv6(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance_halfpixvar16x16_hv vp8_variance_halfpixvar16x16_hv_armv6\n-\n-unsigned int vp8_variance_halfpixvar16x16_v_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-unsigned int vp8_variance_halfpixvar16x16_v_armv6(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance_halfpixvar16x16_v vp8_variance_halfpixvar16x16_v_armv6\n-\n-void vp8_yv12_copy_partial_frame_c(struct yv12_buffer_config *src_ybc, struct yv12_buffer_config *dst_ybc);\n-#define vp8_yv12_copy_partial_frame vp8_yv12_copy_partial_frame_c\n-\n void vp8_rtcd(void);\n \n #include \""vpx_config.h\""\n""}<_**next**_>{""filename"": ""armv7a/vp9_rtcd.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/armv7a/vp9_rtcd.h"", ""patch"": ""@@ -7,15 +7,12 @@\n\n #define RTCD_EXTERN extern\n #endif\n \n-#ifdef __cplusplus\n-extern \""C\"" {\n-#endif\n-\n /*\n  * VP9\n  */\n \n #include \""vpx/vpx_integer.h\""\n+#include \""vp9/common/vp9_common.h\""\n #include \""vp9/common/vp9_enums.h\""\n \n struct macroblockd;\n@@ -23,671 +20,89 @@\n\n /* Encoder forward decls */\n struct macroblock;\n struct vp9_variance_vtable;\n-\n-#define DEC_MVCOSTS int *mvjcost, int *mvcost[2]\n+struct search_site_config;\n struct mv;\n union int_mv;\n struct yv12_buffer_config;\n \n-void vp9_blend_b_c(uint8_t *y, uint8_t *u, uint8_t *v, int y1, int u1, int v1, int alpha, int stride);\n-#define vp9_blend_b vp9_blend_b_c\n+#ifdef __cplusplus\n+extern \""C\"" {\n+#endif\n \n-void vp9_blend_mb_inner_c(uint8_t *y, uint8_t *u, uint8_t *v, int y1, int u1, int v1, int alpha, int stride);\n-#define vp9_blend_mb_inner vp9_blend_mb_inner_c\n+unsigned int vp9_avg_4x4_c(const uint8_t *, int p);\n+#define vp9_avg_4x4 vp9_avg_4x4_c\n \n-void vp9_blend_mb_outer_c(uint8_t *y, uint8_t *u, uint8_t *v, int y1, int u1, int v1, int alpha, int stride);\n-#define vp9_blend_mb_outer vp9_blend_mb_outer_c\n+unsigned int vp9_avg_8x8_c(const uint8_t *, int p);\n+#define vp9_avg_8x8 vp9_avg_8x8_c\n \n-int64_t vp9_block_error_c(const int16_t *coeff, const int16_t *dqcoeff, intptr_t block_size, int64_t *ssz);\n+int64_t vp9_block_error_c(const tran_low_t *coeff, const tran_low_t *dqcoeff, intptr_t block_size, int64_t *ssz);\n #define vp9_block_error vp9_block_error_c\n \n-void vp9_convolve8_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8 vp9_convolve8_c\n+int64_t vp9_block_error_fp_c(const int16_t *coeff, const int16_t *dqcoeff, int block_size);\n+#define vp9_block_error_fp vp9_block_error_fp_c\n \n-void vp9_convolve8_avg_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8_avg vp9_convolve8_avg_c\n-\n-void vp9_convolve8_avg_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8_avg_horiz vp9_convolve8_avg_horiz_c\n-\n-void vp9_convolve8_avg_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8_avg_vert vp9_convolve8_avg_vert_c\n-\n-void vp9_convolve8_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8_horiz vp9_convolve8_horiz_c\n-\n-void vp9_convolve8_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8_vert vp9_convolve8_vert_c\n-\n-void vp9_convolve_avg_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve_avg vp9_convolve_avg_c\n-\n-void vp9_convolve_copy_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve_copy vp9_convolve_copy_c\n-\n-void vp9_d117_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d117_predictor_16x16 vp9_d117_predictor_16x16_c\n-\n-void vp9_d117_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d117_predictor_32x32 vp9_d117_predictor_32x32_c\n-\n-void vp9_d117_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d117_predictor_4x4 vp9_d117_predictor_4x4_c\n-\n-void vp9_d117_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d117_predictor_8x8 vp9_d117_predictor_8x8_c\n-\n-void vp9_d135_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d135_predictor_16x16 vp9_d135_predictor_16x16_c\n-\n-void vp9_d135_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d135_predictor_32x32 vp9_d135_predictor_32x32_c\n-\n-void vp9_d135_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d135_predictor_4x4 vp9_d135_predictor_4x4_c\n-\n-void vp9_d135_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d135_predictor_8x8 vp9_d135_predictor_8x8_c\n-\n-void vp9_d153_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d153_predictor_16x16 vp9_d153_predictor_16x16_c\n-\n-void vp9_d153_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d153_predictor_32x32 vp9_d153_predictor_32x32_c\n-\n-void vp9_d153_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d153_predictor_4x4 vp9_d153_predictor_4x4_c\n-\n-void vp9_d153_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d153_predictor_8x8 vp9_d153_predictor_8x8_c\n-\n-void vp9_d207_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d207_predictor_16x16 vp9_d207_predictor_16x16_c\n-\n-void vp9_d207_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d207_predictor_32x32 vp9_d207_predictor_32x32_c\n-\n-void vp9_d207_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d207_predictor_4x4 vp9_d207_predictor_4x4_c\n-\n-void vp9_d207_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d207_predictor_8x8 vp9_d207_predictor_8x8_c\n-\n-void vp9_d45_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d45_predictor_16x16 vp9_d45_predictor_16x16_c\n-\n-void vp9_d45_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d45_predictor_32x32 vp9_d45_predictor_32x32_c\n-\n-void vp9_d45_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d45_predictor_4x4 vp9_d45_predictor_4x4_c\n-\n-void vp9_d45_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d45_predictor_8x8 vp9_d45_predictor_8x8_c\n-\n-void vp9_d63_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d63_predictor_16x16 vp9_d63_predictor_16x16_c\n-\n-void vp9_d63_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d63_predictor_32x32 vp9_d63_predictor_32x32_c\n-\n-void vp9_d63_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d63_predictor_4x4 vp9_d63_predictor_4x4_c\n-\n-void vp9_d63_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d63_predictor_8x8 vp9_d63_predictor_8x8_c\n-\n-void vp9_dc_128_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_128_predictor_16x16 vp9_dc_128_predictor_16x16_c\n-\n-void vp9_dc_128_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_128_predictor_32x32 vp9_dc_128_predictor_32x32_c\n-\n-void vp9_dc_128_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_128_predictor_4x4 vp9_dc_128_predictor_4x4_c\n-\n-void vp9_dc_128_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_128_predictor_8x8 vp9_dc_128_predictor_8x8_c\n-\n-void vp9_dc_left_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_left_predictor_16x16 vp9_dc_left_predictor_16x16_c\n-\n-void vp9_dc_left_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_left_predictor_32x32 vp9_dc_left_predictor_32x32_c\n-\n-void vp9_dc_left_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_left_predictor_4x4 vp9_dc_left_predictor_4x4_c\n-\n-void vp9_dc_left_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_left_predictor_8x8 vp9_dc_left_predictor_8x8_c\n-\n-void vp9_dc_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_predictor_16x16 vp9_dc_predictor_16x16_c\n-\n-void vp9_dc_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_predictor_32x32 vp9_dc_predictor_32x32_c\n-\n-void vp9_dc_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_predictor_4x4 vp9_dc_predictor_4x4_c\n-\n-void vp9_dc_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_predictor_8x8 vp9_dc_predictor_8x8_c\n-\n-void vp9_dc_top_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_top_predictor_16x16 vp9_dc_top_predictor_16x16_c\n-\n-void vp9_dc_top_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_top_predictor_32x32 vp9_dc_top_predictor_32x32_c\n-\n-void vp9_dc_top_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_top_predictor_4x4 vp9_dc_top_predictor_4x4_c\n-\n-void vp9_dc_top_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_top_predictor_8x8 vp9_dc_top_predictor_8x8_c\n-\n-int vp9_diamond_search_sad_c(const struct macroblock *x, struct mv *ref_mv, struct mv *best_mv, int search_param, int sad_per_bit, int *num00, const struct vp9_variance_vtable *fn_ptr, DEC_MVCOSTS, const struct mv *center_mv);\n+int vp9_diamond_search_sad_c(const struct macroblock *x, const struct search_site_config *cfg,  struct mv *ref_mv, struct mv *best_mv, int search_param, int sad_per_bit, int *num00, const struct vp9_variance_vtable *fn_ptr, const struct mv *center_mv);\n #define vp9_diamond_search_sad vp9_diamond_search_sad_c\n \n-void vp9_fdct16x16_c(const int16_t *input, int16_t *output, int stride);\n-#define vp9_fdct16x16 vp9_fdct16x16_c\n+void vp9_fdct8x8_quant_c(const int16_t *input, int stride, tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+#define vp9_fdct8x8_quant vp9_fdct8x8_quant_c\n \n-void vp9_fdct32x32_c(const int16_t *input, int16_t *output, int stride);\n-#define vp9_fdct32x32 vp9_fdct32x32_c\n-\n-void vp9_fdct32x32_rd_c(const int16_t *input, int16_t *output, int stride);\n-#define vp9_fdct32x32_rd vp9_fdct32x32_rd_c\n-\n-void vp9_fdct4x4_c(const int16_t *input, int16_t *output, int stride);\n-#define vp9_fdct4x4 vp9_fdct4x4_c\n-\n-void vp9_fdct8x8_c(const int16_t *input, int16_t *output, int stride);\n-#define vp9_fdct8x8 vp9_fdct8x8_c\n-\n-void vp9_fht16x16_c(const int16_t *input, int16_t *output, int stride, int tx_type);\n+void vp9_fht16x16_c(const int16_t *input, tran_low_t *output, int stride, int tx_type);\n #define vp9_fht16x16 vp9_fht16x16_c\n \n-void vp9_fht4x4_c(const int16_t *input, int16_t *output, int stride, int tx_type);\n+void vp9_fht4x4_c(const int16_t *input, tran_low_t *output, int stride, int tx_type);\n #define vp9_fht4x4 vp9_fht4x4_c\n \n-void vp9_fht8x8_c(const int16_t *input, int16_t *output, int stride, int tx_type);\n+void vp9_fht8x8_c(const int16_t *input, tran_low_t *output, int stride, int tx_type);\n #define vp9_fht8x8 vp9_fht8x8_c\n \n-int vp9_full_range_search_c(const struct macroblock *x, struct mv *ref_mv, struct mv *best_mv, int search_param, int sad_per_bit, int *num00, const struct vp9_variance_vtable *fn_ptr, DEC_MVCOSTS, const struct mv *center_mv);\n+int vp9_full_range_search_c(const struct macroblock *x, const struct search_site_config *cfg, struct mv *ref_mv, struct mv *best_mv, int search_param, int sad_per_bit, int *num00, const struct vp9_variance_vtable *fn_ptr, const struct mv *center_mv);\n #define vp9_full_range_search vp9_full_range_search_c\n \n-int vp9_full_search_sad_c(const struct macroblock *x, const struct mv *ref_mv, int sad_per_bit, int distance, const struct vp9_variance_vtable *fn_ptr, DEC_MVCOSTS, const struct mv *center_mv, struct mv *best_mv);\n+int vp9_full_search_sad_c(const struct macroblock *x, const struct mv *ref_mv, int sad_per_bit, int distance, const struct vp9_variance_vtable *fn_ptr, const struct mv *center_mv, struct mv *best_mv);\n #define vp9_full_search_sad vp9_full_search_sad_c\n \n-void vp9_fwht4x4_c(const int16_t *input, int16_t *output, int stride);\n+void vp9_fwht4x4_c(const int16_t *input, tran_low_t *output, int stride);\n #define vp9_fwht4x4 vp9_fwht4x4_c\n \n-unsigned int vp9_get_mb_ss_c(const int16_t *);\n-#define vp9_get_mb_ss vp9_get_mb_ss_c\n+void vp9_hadamard_16x16_c(int16_t const *src_diff, int src_stride, int16_t *coeff);\n+#define vp9_hadamard_16x16 vp9_hadamard_16x16_c\n \n-void vp9_get_sse_sum_16x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum);\n-#define vp9_get_sse_sum_16x16 vp9_get_sse_sum_16x16_c\n+void vp9_hadamard_8x8_c(int16_t const *src_diff, int src_stride, int16_t *coeff);\n+#define vp9_hadamard_8x8 vp9_hadamard_8x8_c\n \n-void vp9_get_sse_sum_8x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum);\n-#define vp9_get_sse_sum_8x8 vp9_get_sse_sum_8x8_c\n-\n-void vp9_h_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_h_predictor_16x16 vp9_h_predictor_16x16_c\n-\n-void vp9_h_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_h_predictor_32x32 vp9_h_predictor_32x32_c\n-\n-void vp9_h_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_h_predictor_4x4 vp9_h_predictor_4x4_c\n-\n-void vp9_h_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_h_predictor_8x8 vp9_h_predictor_8x8_c\n-\n-void vp9_idct16x16_10_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct16x16_10_add vp9_idct16x16_10_add_c\n-\n-void vp9_idct16x16_1_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct16x16_1_add vp9_idct16x16_1_add_c\n-\n-void vp9_idct16x16_256_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct16x16_256_add vp9_idct16x16_256_add_c\n-\n-void vp9_idct32x32_1024_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct32x32_1024_add vp9_idct32x32_1024_add_c\n-\n-void vp9_idct32x32_1_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct32x32_1_add vp9_idct32x32_1_add_c\n-\n-void vp9_idct32x32_34_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct32x32_34_add vp9_idct32x32_34_add_c\n-\n-void vp9_idct4x4_16_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct4x4_16_add vp9_idct4x4_16_add_c\n-\n-void vp9_idct4x4_1_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct4x4_1_add vp9_idct4x4_1_add_c\n-\n-void vp9_idct8x8_10_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct8x8_10_add vp9_idct8x8_10_add_c\n-\n-void vp9_idct8x8_1_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct8x8_1_add vp9_idct8x8_1_add_c\n-\n-void vp9_idct8x8_64_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct8x8_64_add vp9_idct8x8_64_add_c\n-\n-void vp9_iht16x16_256_add_c(const int16_t *input, uint8_t *output, int pitch, int tx_type);\n+void vp9_iht16x16_256_add_c(const tran_low_t *input, uint8_t *output, int pitch, int tx_type);\n #define vp9_iht16x16_256_add vp9_iht16x16_256_add_c\n \n-void vp9_iht4x4_16_add_c(const int16_t *input, uint8_t *dest, int dest_stride, int tx_type);\n+void vp9_iht4x4_16_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride, int tx_type);\n #define vp9_iht4x4_16_add vp9_iht4x4_16_add_c\n \n-void vp9_iht8x8_64_add_c(const int16_t *input, uint8_t *dest, int dest_stride, int tx_type);\n+void vp9_iht8x8_64_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride, int tx_type);\n #define vp9_iht8x8_64_add vp9_iht8x8_64_add_c\n \n-void vp9_iwht4x4_16_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_iwht4x4_16_add vp9_iwht4x4_16_add_c\n+int16_t vp9_int_pro_col_c(uint8_t const *ref, const int width);\n+#define vp9_int_pro_col vp9_int_pro_col_c\n \n-void vp9_iwht4x4_1_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_iwht4x4_1_add vp9_iwht4x4_1_add_c\n+void vp9_int_pro_row_c(int16_t *hbuf, uint8_t const *ref, const int ref_stride, const int height);\n+#define vp9_int_pro_row vp9_int_pro_row_c\n \n-void vp9_lpf_horizontal_16_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-#define vp9_lpf_horizontal_16 vp9_lpf_horizontal_16_c\n+void vp9_minmax_8x8_c(const uint8_t *s, int p, const uint8_t *d, int dp, int *min, int *max);\n+#define vp9_minmax_8x8 vp9_minmax_8x8_c\n \n-void vp9_lpf_horizontal_4_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-#define vp9_lpf_horizontal_4 vp9_lpf_horizontal_4_c\n+void vp9_quantize_fp_c(const tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+#define vp9_quantize_fp vp9_quantize_fp_c\n \n-void vp9_lpf_horizontal_4_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n-#define vp9_lpf_horizontal_4_dual vp9_lpf_horizontal_4_dual_c\n+void vp9_quantize_fp_32x32_c(const tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+#define vp9_quantize_fp_32x32 vp9_quantize_fp_32x32_c\n \n-void vp9_lpf_horizontal_8_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-#define vp9_lpf_horizontal_8 vp9_lpf_horizontal_8_c\n+int16_t vp9_satd_c(const int16_t *coeff, int length);\n+#define vp9_satd vp9_satd_c\n \n-void vp9_lpf_horizontal_8_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n-#define vp9_lpf_horizontal_8_dual vp9_lpf_horizontal_8_dual_c\n-\n-void vp9_lpf_vertical_16_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh);\n-#define vp9_lpf_vertical_16 vp9_lpf_vertical_16_c\n-\n-void vp9_lpf_vertical_16_dual_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh);\n-#define vp9_lpf_vertical_16_dual vp9_lpf_vertical_16_dual_c\n-\n-void vp9_lpf_vertical_4_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-#define vp9_lpf_vertical_4 vp9_lpf_vertical_4_c\n-\n-void vp9_lpf_vertical_4_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n-#define vp9_lpf_vertical_4_dual vp9_lpf_vertical_4_dual_c\n-\n-void vp9_lpf_vertical_8_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-#define vp9_lpf_vertical_8 vp9_lpf_vertical_8_c\n-\n-void vp9_lpf_vertical_8_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n-#define vp9_lpf_vertical_8_dual vp9_lpf_vertical_8_dual_c\n-\n-unsigned int vp9_mse16x16_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n-#define vp9_mse16x16 vp9_mse16x16_c\n-\n-unsigned int vp9_mse16x8_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n-#define vp9_mse16x8 vp9_mse16x8_c\n-\n-unsigned int vp9_mse8x16_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n-#define vp9_mse8x16 vp9_mse8x16_c\n-\n-unsigned int vp9_mse8x8_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n-#define vp9_mse8x8 vp9_mse8x8_c\n-\n-void vp9_quantize_b_c(const int16_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, int16_t *qcoeff_ptr, int16_t *dqcoeff_ptr, const int16_t *dequant_ptr, int zbin_oq_value, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n-#define vp9_quantize_b vp9_quantize_b_c\n-\n-void vp9_quantize_b_32x32_c(const int16_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, int16_t *qcoeff_ptr, int16_t *dqcoeff_ptr, const int16_t *dequant_ptr, int zbin_oq_value, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n-#define vp9_quantize_b_32x32 vp9_quantize_b_32x32_c\n-\n-int vp9_refining_search_sad_c(const struct macroblock *x, struct mv *ref_mv, int sad_per_bit, int distance, const struct vp9_variance_vtable *fn_ptr, DEC_MVCOSTS, const struct mv *center_mv);\n-#define vp9_refining_search_sad vp9_refining_search_sad_c\n-\n-unsigned int vp9_sad16x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad16x16 vp9_sad16x16_c\n-\n-unsigned int vp9_sad16x16_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad16x16_avg vp9_sad16x16_avg_c\n-\n-void vp9_sad16x16x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad16x16x3 vp9_sad16x16x3_c\n-\n-void vp9_sad16x16x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad16x16x4d vp9_sad16x16x4d_c\n-\n-void vp9_sad16x16x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad16x16x8 vp9_sad16x16x8_c\n-\n-unsigned int vp9_sad16x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad16x32 vp9_sad16x32_c\n-\n-unsigned int vp9_sad16x32_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad16x32_avg vp9_sad16x32_avg_c\n-\n-void vp9_sad16x32x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad16x32x4d vp9_sad16x32x4d_c\n-\n-unsigned int vp9_sad16x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad16x8 vp9_sad16x8_c\n-\n-unsigned int vp9_sad16x8_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad16x8_avg vp9_sad16x8_avg_c\n-\n-void vp9_sad16x8x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad16x8x3 vp9_sad16x8x3_c\n-\n-void vp9_sad16x8x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad16x8x4d vp9_sad16x8x4d_c\n-\n-void vp9_sad16x8x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad16x8x8 vp9_sad16x8x8_c\n-\n-unsigned int vp9_sad32x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad32x16 vp9_sad32x16_c\n-\n-unsigned int vp9_sad32x16_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad32x16_avg vp9_sad32x16_avg_c\n-\n-void vp9_sad32x16x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad32x16x4d vp9_sad32x16x4d_c\n-\n-unsigned int vp9_sad32x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad32x32 vp9_sad32x32_c\n-\n-unsigned int vp9_sad32x32_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad32x32_avg vp9_sad32x32_avg_c\n-\n-void vp9_sad32x32x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad32x32x3 vp9_sad32x32x3_c\n-\n-void vp9_sad32x32x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad32x32x4d vp9_sad32x32x4d_c\n-\n-void vp9_sad32x32x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad32x32x8 vp9_sad32x32x8_c\n-\n-unsigned int vp9_sad32x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad32x64 vp9_sad32x64_c\n-\n-unsigned int vp9_sad32x64_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad32x64_avg vp9_sad32x64_avg_c\n-\n-void vp9_sad32x64x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad32x64x4d vp9_sad32x64x4d_c\n-\n-unsigned int vp9_sad4x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad4x4 vp9_sad4x4_c\n-\n-unsigned int vp9_sad4x4_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad4x4_avg vp9_sad4x4_avg_c\n-\n-void vp9_sad4x4x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad4x4x3 vp9_sad4x4x3_c\n-\n-void vp9_sad4x4x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad4x4x4d vp9_sad4x4x4d_c\n-\n-void vp9_sad4x4x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad4x4x8 vp9_sad4x4x8_c\n-\n-unsigned int vp9_sad4x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad4x8 vp9_sad4x8_c\n-\n-unsigned int vp9_sad4x8_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad4x8_avg vp9_sad4x8_avg_c\n-\n-void vp9_sad4x8x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_ptr[], int ref_stride, unsigned int *sad_array);\n-#define vp9_sad4x8x4d vp9_sad4x8x4d_c\n-\n-void vp9_sad4x8x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n-#define vp9_sad4x8x8 vp9_sad4x8x8_c\n-\n-unsigned int vp9_sad64x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad64x32 vp9_sad64x32_c\n-\n-unsigned int vp9_sad64x32_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad64x32_avg vp9_sad64x32_avg_c\n-\n-void vp9_sad64x32x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad64x32x4d vp9_sad64x32x4d_c\n-\n-unsigned int vp9_sad64x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad64x64 vp9_sad64x64_c\n-\n-unsigned int vp9_sad64x64_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad64x64_avg vp9_sad64x64_avg_c\n-\n-void vp9_sad64x64x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad64x64x3 vp9_sad64x64x3_c\n-\n-void vp9_sad64x64x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad64x64x4d vp9_sad64x64x4d_c\n-\n-void vp9_sad64x64x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad64x64x8 vp9_sad64x64x8_c\n-\n-unsigned int vp9_sad8x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad8x16 vp9_sad8x16_c\n-\n-unsigned int vp9_sad8x16_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad8x16_avg vp9_sad8x16_avg_c\n-\n-void vp9_sad8x16x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad8x16x3 vp9_sad8x16x3_c\n-\n-void vp9_sad8x16x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad8x16x4d vp9_sad8x16x4d_c\n-\n-void vp9_sad8x16x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad8x16x8 vp9_sad8x16x8_c\n-\n-unsigned int vp9_sad8x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad8x4 vp9_sad8x4_c\n-\n-unsigned int vp9_sad8x4_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad8x4_avg vp9_sad8x4_avg_c\n-\n-void vp9_sad8x4x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_ptr[], int ref_stride, unsigned int *sad_array);\n-#define vp9_sad8x4x4d vp9_sad8x4x4d_c\n-\n-void vp9_sad8x4x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n-#define vp9_sad8x4x8 vp9_sad8x4x8_c\n-\n-unsigned int vp9_sad8x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad8x8 vp9_sad8x8_c\n-\n-unsigned int vp9_sad8x8_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad8x8_avg vp9_sad8x8_avg_c\n-\n-void vp9_sad8x8x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad8x8x3 vp9_sad8x8x3_c\n-\n-void vp9_sad8x8x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad8x8x4d vp9_sad8x8x4d_c\n-\n-void vp9_sad8x8x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad8x8x8 vp9_sad8x8x8_c\n-\n-unsigned int vp9_sub_pixel_avg_variance16x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance16x16 vp9_sub_pixel_avg_variance16x16_c\n-\n-unsigned int vp9_sub_pixel_avg_variance16x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance16x32 vp9_sub_pixel_avg_variance16x32_c\n-\n-unsigned int vp9_sub_pixel_avg_variance16x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance16x8 vp9_sub_pixel_avg_variance16x8_c\n-\n-unsigned int vp9_sub_pixel_avg_variance32x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance32x16 vp9_sub_pixel_avg_variance32x16_c\n-\n-unsigned int vp9_sub_pixel_avg_variance32x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance32x32 vp9_sub_pixel_avg_variance32x32_c\n-\n-unsigned int vp9_sub_pixel_avg_variance32x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance32x64 vp9_sub_pixel_avg_variance32x64_c\n-\n-unsigned int vp9_sub_pixel_avg_variance4x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance4x4 vp9_sub_pixel_avg_variance4x4_c\n-\n-unsigned int vp9_sub_pixel_avg_variance4x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance4x8 vp9_sub_pixel_avg_variance4x8_c\n-\n-unsigned int vp9_sub_pixel_avg_variance64x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance64x32 vp9_sub_pixel_avg_variance64x32_c\n-\n-unsigned int vp9_sub_pixel_avg_variance64x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance64x64 vp9_sub_pixel_avg_variance64x64_c\n-\n-unsigned int vp9_sub_pixel_avg_variance8x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance8x16 vp9_sub_pixel_avg_variance8x16_c\n-\n-unsigned int vp9_sub_pixel_avg_variance8x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance8x4 vp9_sub_pixel_avg_variance8x4_c\n-\n-unsigned int vp9_sub_pixel_avg_variance8x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance8x8 vp9_sub_pixel_avg_variance8x8_c\n-\n-unsigned int vp9_sub_pixel_mse32x32_c(const uint8_t *src_ptr, int  source_stride, int  xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_mse32x32 vp9_sub_pixel_mse32x32_c\n-\n-unsigned int vp9_sub_pixel_mse64x64_c(const uint8_t *src_ptr, int  source_stride, int  xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_mse64x64 vp9_sub_pixel_mse64x64_c\n-\n-unsigned int vp9_sub_pixel_variance16x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance16x16 vp9_sub_pixel_variance16x16_c\n-\n-unsigned int vp9_sub_pixel_variance16x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance16x32 vp9_sub_pixel_variance16x32_c\n-\n-unsigned int vp9_sub_pixel_variance16x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance16x8 vp9_sub_pixel_variance16x8_c\n-\n-unsigned int vp9_sub_pixel_variance32x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance32x16 vp9_sub_pixel_variance32x16_c\n-\n-unsigned int vp9_sub_pixel_variance32x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance32x32 vp9_sub_pixel_variance32x32_c\n-\n-unsigned int vp9_sub_pixel_variance32x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance32x64 vp9_sub_pixel_variance32x64_c\n-\n-unsigned int vp9_sub_pixel_variance4x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance4x4 vp9_sub_pixel_variance4x4_c\n-\n-unsigned int vp9_sub_pixel_variance4x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance4x8 vp9_sub_pixel_variance4x8_c\n-\n-unsigned int vp9_sub_pixel_variance64x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance64x32 vp9_sub_pixel_variance64x32_c\n-\n-unsigned int vp9_sub_pixel_variance64x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance64x64 vp9_sub_pixel_variance64x64_c\n-\n-unsigned int vp9_sub_pixel_variance8x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance8x16 vp9_sub_pixel_variance8x16_c\n-\n-unsigned int vp9_sub_pixel_variance8x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance8x4 vp9_sub_pixel_variance8x4_c\n-\n-unsigned int vp9_sub_pixel_variance8x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance8x8 vp9_sub_pixel_variance8x8_c\n-\n-void vp9_subtract_block_c(int rows, int cols, int16_t *diff_ptr, ptrdiff_t diff_stride, const uint8_t *src_ptr, ptrdiff_t src_stride, const uint8_t *pred_ptr, ptrdiff_t pred_stride);\n-#define vp9_subtract_block vp9_subtract_block_c\n-\n-void vp9_temporal_filter_apply_c(uint8_t *frame1, unsigned int stride, uint8_t *frame2, unsigned int block_size, int strength, int filter_weight, unsigned int *accumulator, uint16_t *count);\n+void vp9_temporal_filter_apply_c(uint8_t *frame1, unsigned int stride, uint8_t *frame2, unsigned int block_width, unsigned int block_height, int strength, int filter_weight, unsigned int *accumulator, uint16_t *count);\n #define vp9_temporal_filter_apply vp9_temporal_filter_apply_c\n \n-void vp9_tm_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_tm_predictor_16x16 vp9_tm_predictor_16x16_c\n-\n-void vp9_tm_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_tm_predictor_32x32 vp9_tm_predictor_32x32_c\n-\n-void vp9_tm_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_tm_predictor_4x4 vp9_tm_predictor_4x4_c\n-\n-void vp9_tm_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_tm_predictor_8x8 vp9_tm_predictor_8x8_c\n-\n-void vp9_v_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_v_predictor_16x16 vp9_v_predictor_16x16_c\n-\n-void vp9_v_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_v_predictor_32x32 vp9_v_predictor_32x32_c\n-\n-void vp9_v_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_v_predictor_4x4 vp9_v_predictor_4x4_c\n-\n-void vp9_v_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_v_predictor_8x8 vp9_v_predictor_8x8_c\n-\n-unsigned int vp9_variance16x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance16x16 vp9_variance16x16_c\n-\n-unsigned int vp9_variance16x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance16x32 vp9_variance16x32_c\n-\n-unsigned int vp9_variance16x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance16x8 vp9_variance16x8_c\n-\n-unsigned int vp9_variance32x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance32x16 vp9_variance32x16_c\n-\n-unsigned int vp9_variance32x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance32x32 vp9_variance32x32_c\n-\n-unsigned int vp9_variance32x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance32x64 vp9_variance32x64_c\n-\n-unsigned int vp9_variance4x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance4x4 vp9_variance4x4_c\n-\n-unsigned int vp9_variance4x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance4x8 vp9_variance4x8_c\n-\n-unsigned int vp9_variance64x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance64x32 vp9_variance64x32_c\n-\n-unsigned int vp9_variance64x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance64x64 vp9_variance64x64_c\n-\n-unsigned int vp9_variance8x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance8x16 vp9_variance8x16_c\n-\n-unsigned int vp9_variance8x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance8x4 vp9_variance8x4_c\n-\n-unsigned int vp9_variance8x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance8x8 vp9_variance8x8_c\n-\n-unsigned int vp9_variance_halfpixvar16x16_h_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar16x16_h vp9_variance_halfpixvar16x16_h_c\n-\n-unsigned int vp9_variance_halfpixvar16x16_hv_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar16x16_hv vp9_variance_halfpixvar16x16_hv_c\n-\n-unsigned int vp9_variance_halfpixvar16x16_v_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar16x16_v vp9_variance_halfpixvar16x16_v_c\n-\n-unsigned int vp9_variance_halfpixvar32x32_h_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar32x32_h vp9_variance_halfpixvar32x32_h_c\n-\n-unsigned int vp9_variance_halfpixvar32x32_hv_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar32x32_hv vp9_variance_halfpixvar32x32_hv_c\n-\n-unsigned int vp9_variance_halfpixvar32x32_v_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar32x32_v vp9_variance_halfpixvar32x32_v_c\n-\n-unsigned int vp9_variance_halfpixvar64x64_h_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar64x64_h vp9_variance_halfpixvar64x64_h_c\n-\n-unsigned int vp9_variance_halfpixvar64x64_hv_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar64x64_hv vp9_variance_halfpixvar64x64_hv_c\n-\n-unsigned int vp9_variance_halfpixvar64x64_v_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar64x64_v vp9_variance_halfpixvar64x64_v_c\n+int vp9_vector_var_c(int16_t const *ref, int16_t const *src, const int bwl);\n+#define vp9_vector_var vp9_vector_var_c\n \n void vp9_rtcd(void);\n \n""}<_**next**_>{""filename"": ""armv7a/vpx_config.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/armv7a/vpx_config.c"", ""patch"": ""@@ -5,5 +5,6 @@\n\n /* tree. An additional intellectual property rights grant can be found */\n /* in the file PATENTS.  All contributing project authors may */\n /* be found in the AUTHORS file in the root of the source tree. */\n-static const char* const cfg = \""--target=armv7-android-gcc --disable-runtime-cpu-detect --sdk-path=/usr/local/google/home/hkuang/Downloads/android-ndk-r9d --disable-neon --disable-examples --disable-docs --enable-realtime-only\"";\n+#include \""vpx/vpx_codec.h\""\n+static const char* const cfg = \""--target=armv7-android-gcc --disable-runtime-cpu-detect --sdk-path=/usr/local/google/home/vigneshv/Downloads/android-ndk-r10 --disable-neon --disable-neon-asm --disable-examples --disable-docs --enable-realtime-only --disable-webm-io\"";\n const char *vpx_codec_build_config(void) {return cfg;}\n""}<_**next**_>{""filename"": ""armv7a/vpx_config.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/armv7a/vpx_config.h"", ""patch"": ""@@ -9,18 +9,19 @@\n\n #ifndef VPX_CONFIG_H\n #define VPX_CONFIG_H\n #define RESTRICT    \n-#define INLINE      __inline__ __attribute__((always_inline))\n+#define INLINE      inline\n #define ARCH_ARM 1\n #define ARCH_MIPS 0\n #define ARCH_X86 0\n #define ARCH_X86_64 0\n-#define ARCH_PPC32 0\n-#define ARCH_PPC64 0\n-#define HAVE_EDSP 1\n+#define HAVE_EDSP 0\n #define HAVE_MEDIA 1\n #define HAVE_NEON 0\n+#define HAVE_NEON_ASM 0\n #define HAVE_MIPS32 0\n #define HAVE_DSPR2 0\n+#define HAVE_MSA 0\n+#define HAVE_MIPS64 0\n #define HAVE_MMX 0\n #define HAVE_SSE 0\n #define HAVE_SSE2 0\n@@ -29,19 +30,18 @@\n\n #define HAVE_SSE4_1 0\n #define HAVE_AVX 0\n #define HAVE_AVX2 0\n-#define HAVE_ALTIVEC 0\n #define HAVE_VPX_PORTS 1\n #define HAVE_STDINT_H 1\n-#define HAVE_ALT_TREE_LAYOUT 0\n #define HAVE_PTHREAD_H 1\n #define HAVE_SYS_MMAN_H 1\n #define HAVE_UNISTD_H 1\n+#define CONFIG_DEPENDENCY_TRACKING 1\n #define CONFIG_EXTERNAL_BUILD 0\n-#define CONFIG_INSTALL_DOCS 0\n+#define CONFIG_INSTALL_DOCS 1\n #define CONFIG_INSTALL_BINS 1\n #define CONFIG_INSTALL_LIBS 1\n #define CONFIG_INSTALL_SRCS 0\n-#define CONFIG_USE_X86INC 1\n+#define CONFIG_USE_X86INC 0\n #define CONFIG_DEBUG 0\n #define CONFIG_GPROF 0\n #define CONFIG_GCOV 0\n@@ -52,10 +52,6 @@\n\n #define CONFIG_BIG_ENDIAN 0\n #define CONFIG_CODEC_SRCS 0\n #define CONFIG_DEBUG_LIBS 0\n-#define CONFIG_FAST_UNALIGNED 1\n-#define CONFIG_MEM_MANAGER 0\n-#define CONFIG_MEM_TRACKER 0\n-#define CONFIG_MEM_CHECKS 0\n #define CONFIG_DEQUANT_TOKENS 0\n #define CONFIG_DC_RECON 0\n #define CONFIG_RUNTIME_CPU_DETECT 0\n@@ -67,8 +63,11 @@\n\n #define CONFIG_VP8_DECODER 1\n #define CONFIG_VP9_ENCODER 1\n #define CONFIG_VP9_DECODER 1\n+#define CONFIG_VP10_ENCODER 0\n+#define CONFIG_VP10_DECODER 0\n #define CONFIG_VP8 1\n #define CONFIG_VP9 1\n+#define CONFIG_VP10 0\n #define CONFIG_ENCODERS 1\n #define CONFIG_DECODERS 1\n #define CONFIG_STATIC_MSVCRT 0\n@@ -82,12 +81,18 @@\n\n #define CONFIG_POSTPROC_VISUALIZER 0\n #define CONFIG_OS_SUPPORT 1\n #define CONFIG_UNIT_TESTS 0\n-#define CONFIG_WEBM_IO 1\n+#define CONFIG_WEBM_IO 0\n+#define CONFIG_LIBYUV 1\n #define CONFIG_DECODE_PERF_TESTS 0\n+#define CONFIG_ENCODE_PERF_TESTS 0\n #define CONFIG_MULTI_RES_ENCODING 0\n #define CONFIG_TEMPORAL_DENOISING 1\n+#define CONFIG_VP9_TEMPORAL_DENOISING 0\n+#define CONFIG_COEFFICIENT_RANGE_CHECKING 0\n+#define CONFIG_VP9_HIGHBITDEPTH 0\n #define CONFIG_EXPERIMENTAL 0\n-#define CONFIG_DECRYPT 0\n-#define CONFIG_MULTIPLE_ARF 0\n-#define CONFIG_ALPHA 0\n+#define CONFIG_SIZE_LIMIT 0\n+#define CONFIG_SPATIAL_SVC 0\n+#define CONFIG_FP_MB_STATS 0\n+#define CONFIG_EMULATE_HARDWARE 0\n #endif /* VPX_CONFIG_H */\n""}<_**next**_>{""filename"": ""armv7a/vpx_dsp_rtcd.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/armv7a/vpx_dsp_rtcd.h"", ""patch"": ""@@ -0,0 +1,674 @@\n\n+#ifndef VPX_DSP_RTCD_H_\n+#define VPX_DSP_RTCD_H_\n+\n+#ifdef RTCD_C\n+#define RTCD_EXTERN\n+#else\n+#define RTCD_EXTERN extern\n+#endif\n+\n+/*\n+ * DSP\n+ */\n+\n+#include \""vpx/vpx_integer.h\""\n+#include \""vpx_dsp/vpx_dsp_common.h\""\n+\n+\n+#ifdef __cplusplus\n+extern \""C\"" {\n+#endif\n+\n+void vpx_comp_avg_pred_c(uint8_t *comp_pred, const uint8_t *pred, int width, int height, const uint8_t *ref, int ref_stride);\n+#define vpx_comp_avg_pred vpx_comp_avg_pred_c\n+\n+void vpx_convolve8_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8 vpx_convolve8_c\n+\n+void vpx_convolve8_avg_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8_avg vpx_convolve8_avg_c\n+\n+void vpx_convolve8_avg_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8_avg_horiz vpx_convolve8_avg_horiz_c\n+\n+void vpx_convolve8_avg_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8_avg_vert vpx_convolve8_avg_vert_c\n+\n+void vpx_convolve8_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8_horiz vpx_convolve8_horiz_c\n+\n+void vpx_convolve8_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8_vert vpx_convolve8_vert_c\n+\n+void vpx_convolve_avg_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve_avg vpx_convolve_avg_c\n+\n+void vpx_convolve_copy_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve_copy vpx_convolve_copy_c\n+\n+void vpx_d117_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d117_predictor_16x16 vpx_d117_predictor_16x16_c\n+\n+void vpx_d117_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d117_predictor_32x32 vpx_d117_predictor_32x32_c\n+\n+void vpx_d117_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d117_predictor_4x4 vpx_d117_predictor_4x4_c\n+\n+void vpx_d117_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d117_predictor_8x8 vpx_d117_predictor_8x8_c\n+\n+void vpx_d135_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d135_predictor_16x16 vpx_d135_predictor_16x16_c\n+\n+void vpx_d135_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d135_predictor_32x32 vpx_d135_predictor_32x32_c\n+\n+void vpx_d135_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d135_predictor_4x4 vpx_d135_predictor_4x4_c\n+\n+void vpx_d135_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d135_predictor_8x8 vpx_d135_predictor_8x8_c\n+\n+void vpx_d153_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d153_predictor_16x16 vpx_d153_predictor_16x16_c\n+\n+void vpx_d153_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d153_predictor_32x32 vpx_d153_predictor_32x32_c\n+\n+void vpx_d153_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d153_predictor_4x4 vpx_d153_predictor_4x4_c\n+\n+void vpx_d153_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d153_predictor_8x8 vpx_d153_predictor_8x8_c\n+\n+void vpx_d207_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d207_predictor_16x16 vpx_d207_predictor_16x16_c\n+\n+void vpx_d207_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d207_predictor_32x32 vpx_d207_predictor_32x32_c\n+\n+void vpx_d207_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d207_predictor_4x4 vpx_d207_predictor_4x4_c\n+\n+void vpx_d207_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d207_predictor_8x8 vpx_d207_predictor_8x8_c\n+\n+void vpx_d45_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d45_predictor_16x16 vpx_d45_predictor_16x16_c\n+\n+void vpx_d45_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d45_predictor_32x32 vpx_d45_predictor_32x32_c\n+\n+void vpx_d45_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d45_predictor_4x4 vpx_d45_predictor_4x4_c\n+\n+void vpx_d45_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d45_predictor_8x8 vpx_d45_predictor_8x8_c\n+\n+void vpx_d63_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d63_predictor_16x16 vpx_d63_predictor_16x16_c\n+\n+void vpx_d63_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d63_predictor_32x32 vpx_d63_predictor_32x32_c\n+\n+void vpx_d63_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d63_predictor_4x4 vpx_d63_predictor_4x4_c\n+\n+void vpx_d63_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d63_predictor_8x8 vpx_d63_predictor_8x8_c\n+\n+void vpx_dc_128_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_128_predictor_16x16 vpx_dc_128_predictor_16x16_c\n+\n+void vpx_dc_128_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_128_predictor_32x32 vpx_dc_128_predictor_32x32_c\n+\n+void vpx_dc_128_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_128_predictor_4x4 vpx_dc_128_predictor_4x4_c\n+\n+void vpx_dc_128_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_128_predictor_8x8 vpx_dc_128_predictor_8x8_c\n+\n+void vpx_dc_left_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_left_predictor_16x16 vpx_dc_left_predictor_16x16_c\n+\n+void vpx_dc_left_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_left_predictor_32x32 vpx_dc_left_predictor_32x32_c\n+\n+void vpx_dc_left_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_left_predictor_4x4 vpx_dc_left_predictor_4x4_c\n+\n+void vpx_dc_left_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_left_predictor_8x8 vpx_dc_left_predictor_8x8_c\n+\n+void vpx_dc_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_predictor_16x16 vpx_dc_predictor_16x16_c\n+\n+void vpx_dc_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_predictor_32x32 vpx_dc_predictor_32x32_c\n+\n+void vpx_dc_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_predictor_4x4 vpx_dc_predictor_4x4_c\n+\n+void vpx_dc_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_predictor_8x8 vpx_dc_predictor_8x8_c\n+\n+void vpx_dc_top_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_top_predictor_16x16 vpx_dc_top_predictor_16x16_c\n+\n+void vpx_dc_top_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_top_predictor_32x32 vpx_dc_top_predictor_32x32_c\n+\n+void vpx_dc_top_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_top_predictor_4x4 vpx_dc_top_predictor_4x4_c\n+\n+void vpx_dc_top_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_top_predictor_8x8 vpx_dc_top_predictor_8x8_c\n+\n+void vpx_fdct16x16_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct16x16 vpx_fdct16x16_c\n+\n+void vpx_fdct16x16_1_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct16x16_1 vpx_fdct16x16_1_c\n+\n+void vpx_fdct32x32_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct32x32 vpx_fdct32x32_c\n+\n+void vpx_fdct32x32_1_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct32x32_1 vpx_fdct32x32_1_c\n+\n+void vpx_fdct32x32_rd_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct32x32_rd vpx_fdct32x32_rd_c\n+\n+void vpx_fdct4x4_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct4x4 vpx_fdct4x4_c\n+\n+void vpx_fdct4x4_1_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct4x4_1 vpx_fdct4x4_1_c\n+\n+void vpx_fdct8x8_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct8x8 vpx_fdct8x8_c\n+\n+void vpx_fdct8x8_1_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct8x8_1 vpx_fdct8x8_1_c\n+\n+void vpx_get16x16var_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum);\n+#define vpx_get16x16var vpx_get16x16var_c\n+\n+unsigned int vpx_get4x4sse_cs_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride);\n+#define vpx_get4x4sse_cs vpx_get4x4sse_cs_c\n+\n+void vpx_get8x8var_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum);\n+#define vpx_get8x8var vpx_get8x8var_c\n+\n+unsigned int vpx_get_mb_ss_c(const int16_t *);\n+#define vpx_get_mb_ss vpx_get_mb_ss_c\n+\n+void vpx_h_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_h_predictor_16x16 vpx_h_predictor_16x16_c\n+\n+void vpx_h_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_h_predictor_32x32 vpx_h_predictor_32x32_c\n+\n+void vpx_h_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_h_predictor_4x4 vpx_h_predictor_4x4_c\n+\n+void vpx_h_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_h_predictor_8x8 vpx_h_predictor_8x8_c\n+\n+void vpx_idct16x16_10_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct16x16_10_add vpx_idct16x16_10_add_c\n+\n+void vpx_idct16x16_1_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct16x16_1_add vpx_idct16x16_1_add_c\n+\n+void vpx_idct16x16_256_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct16x16_256_add vpx_idct16x16_256_add_c\n+\n+void vpx_idct32x32_1024_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct32x32_1024_add vpx_idct32x32_1024_add_c\n+\n+void vpx_idct32x32_1_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct32x32_1_add vpx_idct32x32_1_add_c\n+\n+void vpx_idct32x32_34_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct32x32_34_add vpx_idct32x32_34_add_c\n+\n+void vpx_idct4x4_16_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct4x4_16_add vpx_idct4x4_16_add_c\n+\n+void vpx_idct4x4_1_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct4x4_1_add vpx_idct4x4_1_add_c\n+\n+void vpx_idct8x8_12_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct8x8_12_add vpx_idct8x8_12_add_c\n+\n+void vpx_idct8x8_1_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct8x8_1_add vpx_idct8x8_1_add_c\n+\n+void vpx_idct8x8_64_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct8x8_64_add vpx_idct8x8_64_add_c\n+\n+void vpx_iwht4x4_16_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_iwht4x4_16_add vpx_iwht4x4_16_add_c\n+\n+void vpx_iwht4x4_1_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_iwht4x4_1_add vpx_iwht4x4_1_add_c\n+\n+void vpx_lpf_horizontal_16_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+#define vpx_lpf_horizontal_16 vpx_lpf_horizontal_16_c\n+\n+void vpx_lpf_horizontal_4_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+#define vpx_lpf_horizontal_4 vpx_lpf_horizontal_4_c\n+\n+void vpx_lpf_horizontal_4_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n+#define vpx_lpf_horizontal_4_dual vpx_lpf_horizontal_4_dual_c\n+\n+void vpx_lpf_horizontal_8_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+#define vpx_lpf_horizontal_8 vpx_lpf_horizontal_8_c\n+\n+void vpx_lpf_horizontal_8_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n+#define vpx_lpf_horizontal_8_dual vpx_lpf_horizontal_8_dual_c\n+\n+void vpx_lpf_vertical_16_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh);\n+#define vpx_lpf_vertical_16 vpx_lpf_vertical_16_c\n+\n+void vpx_lpf_vertical_16_dual_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh);\n+#define vpx_lpf_vertical_16_dual vpx_lpf_vertical_16_dual_c\n+\n+void vpx_lpf_vertical_4_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+#define vpx_lpf_vertical_4 vpx_lpf_vertical_4_c\n+\n+void vpx_lpf_vertical_4_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n+#define vpx_lpf_vertical_4_dual vpx_lpf_vertical_4_dual_c\n+\n+void vpx_lpf_vertical_8_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+#define vpx_lpf_vertical_8 vpx_lpf_vertical_8_c\n+\n+void vpx_lpf_vertical_8_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n+#define vpx_lpf_vertical_8_dual vpx_lpf_vertical_8_dual_c\n+\n+unsigned int vpx_mse16x16_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n+unsigned int vpx_mse16x16_media(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n+#define vpx_mse16x16 vpx_mse16x16_media\n+\n+unsigned int vpx_mse16x8_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n+#define vpx_mse16x8 vpx_mse16x8_c\n+\n+unsigned int vpx_mse8x16_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n+#define vpx_mse8x16 vpx_mse8x16_c\n+\n+unsigned int vpx_mse8x8_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n+#define vpx_mse8x8 vpx_mse8x8_c\n+\n+void vpx_quantize_b_c(const tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+#define vpx_quantize_b vpx_quantize_b_c\n+\n+void vpx_quantize_b_32x32_c(const tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+#define vpx_quantize_b_32x32 vpx_quantize_b_32x32_c\n+\n+unsigned int vpx_sad16x16_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+unsigned int vpx_sad16x16_media(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad16x16 vpx_sad16x16_media\n+\n+unsigned int vpx_sad16x16_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad16x16_avg vpx_sad16x16_avg_c\n+\n+void vpx_sad16x16x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x16x3 vpx_sad16x16x3_c\n+\n+void vpx_sad16x16x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x16x4d vpx_sad16x16x4d_c\n+\n+void vpx_sad16x16x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x16x8 vpx_sad16x16x8_c\n+\n+unsigned int vpx_sad16x32_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad16x32 vpx_sad16x32_c\n+\n+unsigned int vpx_sad16x32_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad16x32_avg vpx_sad16x32_avg_c\n+\n+void vpx_sad16x32x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x32x4d vpx_sad16x32x4d_c\n+\n+unsigned int vpx_sad16x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad16x8 vpx_sad16x8_c\n+\n+unsigned int vpx_sad16x8_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad16x8_avg vpx_sad16x8_avg_c\n+\n+void vpx_sad16x8x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x8x3 vpx_sad16x8x3_c\n+\n+void vpx_sad16x8x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x8x4d vpx_sad16x8x4d_c\n+\n+void vpx_sad16x8x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x8x8 vpx_sad16x8x8_c\n+\n+unsigned int vpx_sad32x16_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad32x16 vpx_sad32x16_c\n+\n+unsigned int vpx_sad32x16_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad32x16_avg vpx_sad32x16_avg_c\n+\n+void vpx_sad32x16x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad32x16x4d vpx_sad32x16x4d_c\n+\n+unsigned int vpx_sad32x32_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad32x32 vpx_sad32x32_c\n+\n+unsigned int vpx_sad32x32_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad32x32_avg vpx_sad32x32_avg_c\n+\n+void vpx_sad32x32x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad32x32x3 vpx_sad32x32x3_c\n+\n+void vpx_sad32x32x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad32x32x4d vpx_sad32x32x4d_c\n+\n+void vpx_sad32x32x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad32x32x8 vpx_sad32x32x8_c\n+\n+unsigned int vpx_sad32x64_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad32x64 vpx_sad32x64_c\n+\n+unsigned int vpx_sad32x64_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad32x64_avg vpx_sad32x64_avg_c\n+\n+void vpx_sad32x64x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad32x64x4d vpx_sad32x64x4d_c\n+\n+unsigned int vpx_sad4x4_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad4x4 vpx_sad4x4_c\n+\n+unsigned int vpx_sad4x4_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad4x4_avg vpx_sad4x4_avg_c\n+\n+void vpx_sad4x4x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad4x4x3 vpx_sad4x4x3_c\n+\n+void vpx_sad4x4x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad4x4x4d vpx_sad4x4x4d_c\n+\n+void vpx_sad4x4x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad4x4x8 vpx_sad4x4x8_c\n+\n+unsigned int vpx_sad4x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad4x8 vpx_sad4x8_c\n+\n+unsigned int vpx_sad4x8_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad4x8_avg vpx_sad4x8_avg_c\n+\n+void vpx_sad4x8x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad4x8x4d vpx_sad4x8x4d_c\n+\n+void vpx_sad4x8x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad4x8x8 vpx_sad4x8x8_c\n+\n+unsigned int vpx_sad64x32_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad64x32 vpx_sad64x32_c\n+\n+unsigned int vpx_sad64x32_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad64x32_avg vpx_sad64x32_avg_c\n+\n+void vpx_sad64x32x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad64x32x4d vpx_sad64x32x4d_c\n+\n+unsigned int vpx_sad64x64_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad64x64 vpx_sad64x64_c\n+\n+unsigned int vpx_sad64x64_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad64x64_avg vpx_sad64x64_avg_c\n+\n+void vpx_sad64x64x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad64x64x3 vpx_sad64x64x3_c\n+\n+void vpx_sad64x64x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad64x64x4d vpx_sad64x64x4d_c\n+\n+void vpx_sad64x64x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad64x64x8 vpx_sad64x64x8_c\n+\n+unsigned int vpx_sad8x16_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad8x16 vpx_sad8x16_c\n+\n+unsigned int vpx_sad8x16_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad8x16_avg vpx_sad8x16_avg_c\n+\n+void vpx_sad8x16x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x16x3 vpx_sad8x16x3_c\n+\n+void vpx_sad8x16x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x16x4d vpx_sad8x16x4d_c\n+\n+void vpx_sad8x16x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x16x8 vpx_sad8x16x8_c\n+\n+unsigned int vpx_sad8x4_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad8x4 vpx_sad8x4_c\n+\n+unsigned int vpx_sad8x4_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad8x4_avg vpx_sad8x4_avg_c\n+\n+void vpx_sad8x4x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x4x4d vpx_sad8x4x4d_c\n+\n+void vpx_sad8x4x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x4x8 vpx_sad8x4x8_c\n+\n+unsigned int vpx_sad8x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad8x8 vpx_sad8x8_c\n+\n+unsigned int vpx_sad8x8_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad8x8_avg vpx_sad8x8_avg_c\n+\n+void vpx_sad8x8x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x8x3 vpx_sad8x8x3_c\n+\n+void vpx_sad8x8x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x8x4d vpx_sad8x8x4d_c\n+\n+void vpx_sad8x8x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x8x8 vpx_sad8x8x8_c\n+\n+void vpx_scaled_2d_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_2d vpx_scaled_2d_c\n+\n+void vpx_scaled_avg_2d_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_avg_2d vpx_scaled_avg_2d_c\n+\n+void vpx_scaled_avg_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_avg_horiz vpx_scaled_avg_horiz_c\n+\n+void vpx_scaled_avg_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_avg_vert vpx_scaled_avg_vert_c\n+\n+void vpx_scaled_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_horiz vpx_scaled_horiz_c\n+\n+void vpx_scaled_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_vert vpx_scaled_vert_c\n+\n+uint32_t vpx_sub_pixel_avg_variance16x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance16x16 vpx_sub_pixel_avg_variance16x16_c\n+\n+uint32_t vpx_sub_pixel_avg_variance16x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance16x32 vpx_sub_pixel_avg_variance16x32_c\n+\n+uint32_t vpx_sub_pixel_avg_variance16x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance16x8 vpx_sub_pixel_avg_variance16x8_c\n+\n+uint32_t vpx_sub_pixel_avg_variance32x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance32x16 vpx_sub_pixel_avg_variance32x16_c\n+\n+uint32_t vpx_sub_pixel_avg_variance32x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance32x32 vpx_sub_pixel_avg_variance32x32_c\n+\n+uint32_t vpx_sub_pixel_avg_variance32x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance32x64 vpx_sub_pixel_avg_variance32x64_c\n+\n+uint32_t vpx_sub_pixel_avg_variance4x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance4x4 vpx_sub_pixel_avg_variance4x4_c\n+\n+uint32_t vpx_sub_pixel_avg_variance4x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance4x8 vpx_sub_pixel_avg_variance4x8_c\n+\n+uint32_t vpx_sub_pixel_avg_variance64x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance64x32 vpx_sub_pixel_avg_variance64x32_c\n+\n+uint32_t vpx_sub_pixel_avg_variance64x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance64x64 vpx_sub_pixel_avg_variance64x64_c\n+\n+uint32_t vpx_sub_pixel_avg_variance8x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance8x16 vpx_sub_pixel_avg_variance8x16_c\n+\n+uint32_t vpx_sub_pixel_avg_variance8x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance8x4 vpx_sub_pixel_avg_variance8x4_c\n+\n+uint32_t vpx_sub_pixel_avg_variance8x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance8x8 vpx_sub_pixel_avg_variance8x8_c\n+\n+uint32_t vpx_sub_pixel_variance16x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+uint32_t vpx_sub_pixel_variance16x16_media(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance16x16 vpx_sub_pixel_variance16x16_media\n+\n+uint32_t vpx_sub_pixel_variance16x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance16x32 vpx_sub_pixel_variance16x32_c\n+\n+uint32_t vpx_sub_pixel_variance16x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance16x8 vpx_sub_pixel_variance16x8_c\n+\n+uint32_t vpx_sub_pixel_variance32x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance32x16 vpx_sub_pixel_variance32x16_c\n+\n+uint32_t vpx_sub_pixel_variance32x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance32x32 vpx_sub_pixel_variance32x32_c\n+\n+uint32_t vpx_sub_pixel_variance32x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance32x64 vpx_sub_pixel_variance32x64_c\n+\n+uint32_t vpx_sub_pixel_variance4x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance4x4 vpx_sub_pixel_variance4x4_c\n+\n+uint32_t vpx_sub_pixel_variance4x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance4x8 vpx_sub_pixel_variance4x8_c\n+\n+uint32_t vpx_sub_pixel_variance64x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance64x32 vpx_sub_pixel_variance64x32_c\n+\n+uint32_t vpx_sub_pixel_variance64x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance64x64 vpx_sub_pixel_variance64x64_c\n+\n+uint32_t vpx_sub_pixel_variance8x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance8x16 vpx_sub_pixel_variance8x16_c\n+\n+uint32_t vpx_sub_pixel_variance8x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance8x4 vpx_sub_pixel_variance8x4_c\n+\n+uint32_t vpx_sub_pixel_variance8x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+uint32_t vpx_sub_pixel_variance8x8_media(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance8x8 vpx_sub_pixel_variance8x8_media\n+\n+void vpx_subtract_block_c(int rows, int cols, int16_t *diff_ptr, ptrdiff_t diff_stride, const uint8_t *src_ptr, ptrdiff_t src_stride, const uint8_t *pred_ptr, ptrdiff_t pred_stride);\n+#define vpx_subtract_block vpx_subtract_block_c\n+\n+void vpx_tm_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_tm_predictor_16x16 vpx_tm_predictor_16x16_c\n+\n+void vpx_tm_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_tm_predictor_32x32 vpx_tm_predictor_32x32_c\n+\n+void vpx_tm_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_tm_predictor_4x4 vpx_tm_predictor_4x4_c\n+\n+void vpx_tm_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_tm_predictor_8x8 vpx_tm_predictor_8x8_c\n+\n+void vpx_v_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_v_predictor_16x16 vpx_v_predictor_16x16_c\n+\n+void vpx_v_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_v_predictor_32x32 vpx_v_predictor_32x32_c\n+\n+void vpx_v_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_v_predictor_4x4 vpx_v_predictor_4x4_c\n+\n+void vpx_v_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_v_predictor_8x8 vpx_v_predictor_8x8_c\n+\n+unsigned int vpx_variance16x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+unsigned int vpx_variance16x16_media(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance16x16 vpx_variance16x16_media\n+\n+unsigned int vpx_variance16x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance16x32 vpx_variance16x32_c\n+\n+unsigned int vpx_variance16x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance16x8 vpx_variance16x8_c\n+\n+unsigned int vpx_variance32x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance32x16 vpx_variance32x16_c\n+\n+unsigned int vpx_variance32x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance32x32 vpx_variance32x32_c\n+\n+unsigned int vpx_variance32x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance32x64 vpx_variance32x64_c\n+\n+unsigned int vpx_variance4x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance4x4 vpx_variance4x4_c\n+\n+unsigned int vpx_variance4x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance4x8 vpx_variance4x8_c\n+\n+unsigned int vpx_variance64x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance64x32 vpx_variance64x32_c\n+\n+unsigned int vpx_variance64x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance64x64 vpx_variance64x64_c\n+\n+unsigned int vpx_variance8x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance8x16 vpx_variance8x16_c\n+\n+unsigned int vpx_variance8x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance8x4 vpx_variance8x4_c\n+\n+unsigned int vpx_variance8x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+unsigned int vpx_variance8x8_media(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance8x8 vpx_variance8x8_media\n+\n+uint32_t vpx_variance_halfpixvar16x16_h_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, uint32_t *sse);\n+uint32_t vpx_variance_halfpixvar16x16_h_media(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, uint32_t *sse);\n+#define vpx_variance_halfpixvar16x16_h vpx_variance_halfpixvar16x16_h_media\n+\n+uint32_t vpx_variance_halfpixvar16x16_hv_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, uint32_t *sse);\n+uint32_t vpx_variance_halfpixvar16x16_hv_media(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, uint32_t *sse);\n+#define vpx_variance_halfpixvar16x16_hv vpx_variance_halfpixvar16x16_hv_media\n+\n+uint32_t vpx_variance_halfpixvar16x16_v_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, uint32_t *sse);\n+uint32_t vpx_variance_halfpixvar16x16_v_media(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, uint32_t *sse);\n+#define vpx_variance_halfpixvar16x16_v vpx_variance_halfpixvar16x16_v_media\n+\n+void vpx_dsp_rtcd(void);\n+\n+#include \""vpx_config.h\""\n+\n+#ifdef RTCD_C\n+#include \""vpx_ports/arm.h\""\n+static void setup_rtcd_internal(void)\n+{\n+    int flags = arm_cpu_caps();\n+\n+    (void)flags;\n+\n+}\n+#endif\n+\n+#ifdef __cplusplus\n+}  // extern \""C\""\n+#endif\n+\n+#endif\n""}<_**next**_>{""filename"": ""armv7a/vpx_scale_rtcd.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/armv7a/vpx_scale_rtcd.h"", ""patch"": ""@@ -7,12 +7,12 @@\n\n #define RTCD_EXTERN extern\n #endif\n \n+struct yv12_buffer_config;\n+\n #ifdef __cplusplus\n extern \""C\"" {\n #endif\n \n-struct yv12_buffer_config;\n-\n void vp8_horizontal_line_2_1_scale_c(const unsigned char *source, unsigned int source_width, unsigned char *dest, unsigned int dest_width);\n #define vp8_horizontal_line_2_1_scale vp8_horizontal_line_2_1_scale_c\n \n@@ -40,11 +40,11 @@\n\n void vp8_yv12_extend_frame_borders_c(struct yv12_buffer_config *ybf);\n #define vp8_yv12_extend_frame_borders vp8_yv12_extend_frame_borders_c\n \n-void vp9_extend_frame_borders_c(struct yv12_buffer_config *ybf);\n-#define vp9_extend_frame_borders vp9_extend_frame_borders_c\n+void vpx_extend_frame_borders_c(struct yv12_buffer_config *ybf);\n+#define vpx_extend_frame_borders vpx_extend_frame_borders_c\n \n-void vp9_extend_frame_inner_borders_c(struct yv12_buffer_config *ybf);\n-#define vp9_extend_frame_inner_borders vp9_extend_frame_inner_borders_c\n+void vpx_extend_frame_inner_borders_c(struct yv12_buffer_config *ybf);\n+#define vpx_extend_frame_inner_borders vpx_extend_frame_inner_borders_c\n \n void vpx_yv12_copy_y_c(const struct yv12_buffer_config *src_ybc, struct yv12_buffer_config *dst_ybc);\n #define vpx_yv12_copy_y vpx_yv12_copy_y_c\n""}<_**next**_>{""filename"": ""armv7a/vpx_version.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/armv7a/vpx_version.h"", ""patch"": ""@@ -1,7 +1,7 @@\n\n #define VERSION_MAJOR  1\n-#define VERSION_MINOR  3\n+#define VERSION_MINOR  4\n #define VERSION_PATCH  0\n-#define VERSION_EXTRA  \""2239-g4fffefe\""\n+#define VERSION_EXTRA  \""\""\n #define VERSION_PACKED ((VERSION_MAJOR<<16)|(VERSION_MINOR<<8)|(VERSION_PATCH))\n-#define VERSION_STRING_NOSP \""v1.3.0-2239-g4fffefe\""\n-#define VERSION_STRING      \"" v1.3.0-2239-g4fffefe\""\n+#define VERSION_STRING_NOSP \""v1.4.0\""\n+#define VERSION_STRING      \"" v1.4.0\""\n""}<_**next**_>{""filename"": ""generic/libvpx_srcs.txt"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/generic/libvpx_srcs.txt"", ""patch"": ""@@ -1,6 +1,6 @@\n\n+CHANGELOG\n build/make/rtcd.pl\n build/make/version.sh\n-CHANGELOG\n libs.mk\n vp8/common/alloccommon.c\n vp8/common/alloccommon.h\n@@ -8,6 +8,7 @@\n\n vp8/common/blockd.h\n vp8/common/coefupdateprobs.h\n vp8/common/common.h\n+vp8/common/copy_c.c\n vp8/common/debugmodes.c\n vp8/common/default_coef_probs.h\n vp8/common/dequantize.c\n@@ -28,28 +29,25 @@\n\n vp8/common/idct_blk.c\n vp8/common/idctllm.c\n vp8/common/invtrans.h\n-vp8/common/loopfilter.c\n-vp8/common/loopfilter_filters.c\n vp8/common/loopfilter.h\n+vp8/common/loopfilter_filters.c\n vp8/common/mbpitch.c\n vp8/common/modecont.c\n vp8/common/modecont.h\n vp8/common/mv.h\n+vp8/common/onyx.h\n vp8/common/onyxc_int.h\n vp8/common/onyxd.h\n-vp8/common/onyx.h\n vp8/common/ppflags.h\n-vp8/common/pragmas.h\n vp8/common/quant_common.c\n vp8/common/quant_common.h\n vp8/common/reconinter.c\n vp8/common/reconinter.h\n+vp8/common/reconintra.c\n vp8/common/reconintra4x4.c\n vp8/common/reconintra4x4.h\n-vp8/common/reconintra.c\n vp8/common/rtcd.c\n vp8/common/rtcd_defs.pl\n-vp8/common/sad_c.c\n vp8/common/setupintrarecon.c\n vp8/common/setupintrarecon.h\n vp8/common/swapyv12buffer.c\n@@ -58,9 +56,8 @@\n\n vp8/common/threading.h\n vp8/common/treecoder.c\n vp8/common/treecoder.h\n-vp8/common/variance_c.c\n-vp8/common/variance.h\n vp8/common/vp8_entropymodedata.h\n+vp8/common/vp8_loopfilter.c\n vp8/decoder/dboolhuff.c\n vp8/decoder/dboolhuff.h\n vp8/decoder/decodeframe.c\n@@ -105,7 +102,6 @@\n\n vp8/encoder/pickinter.c\n vp8/encoder/pickinter.h\n vp8/encoder/picklpf.c\n-vp8/encoder/quantize.c\n vp8/encoder/quantize.h\n vp8/encoder/ratectrl.c\n vp8/encoder/ratectrl.h\n@@ -117,21 +113,19 @@\n\n vp8/encoder/tokenize.h\n vp8/encoder/treewriter.c\n vp8/encoder/treewriter.h\n-vp8/encoder/vp8_asm_enc_offsets.c\n+vp8/encoder/vp8_quantize.c\n vp8/vp8_common.mk\n vp8/vp8_cx_iface.c\n-vp8/vp8cx.mk\n vp8/vp8_dx_iface.c\n+vp8/vp8cx.mk\n vp8/vp8dx.mk\n vp9/common/vp9_alloccommon.c\n vp9/common/vp9_alloccommon.h\n vp9/common/vp9_blockd.c\n vp9/common/vp9_blockd.h\n+vp9/common/vp9_common.h\n vp9/common/vp9_common_data.c\n vp9/common/vp9_common_data.h\n-vp9/common/vp9_common.h\n-vp9/common/vp9_convolve.c\n-vp9/common/vp9_convolve.h\n vp9/common/vp9_debugmodes.c\n vp9/common/vp9_entropy.c\n vp9/common/vp9_entropy.h\n@@ -147,18 +141,14 @@\n\n vp9/common/vp9_idct.c\n vp9/common/vp9_idct.h\n vp9/common/vp9_loopfilter.c\n-vp9/common/vp9_loopfilter_filters.c\n vp9/common/vp9_loopfilter.h\n vp9/common/vp9_mv.h\n vp9/common/vp9_mvref_common.c\n vp9/common/vp9_mvref_common.h\n vp9/common/vp9_onyxc_int.h\n vp9/common/vp9_ppflags.h\n-vp9/common/vp9_pragmas.h\n vp9/common/vp9_pred_common.c\n vp9/common/vp9_pred_common.h\n-vp9/common/vp9_prob.c\n-vp9/common/vp9_prob.h\n vp9/common/vp9_quant_common.c\n vp9/common/vp9_quant_common.h\n vp9/common/vp9_reconinter.c\n@@ -173,8 +163,9 @@\n\n vp9/common/vp9_scan.h\n vp9/common/vp9_seg_common.c\n vp9/common/vp9_seg_common.h\n-vp9/common/vp9_systemdependent.h\n vp9/common/vp9_textblit.h\n+vp9/common/vp9_thread_common.c\n+vp9/common/vp9_thread_common.h\n vp9/common/vp9_tile_common.c\n vp9/common/vp9_tile_common.h\n vp9/decoder/vp9_decodeframe.c\n@@ -189,21 +180,18 @@\n\n vp9/decoder/vp9_dsubexp.h\n vp9/decoder/vp9_dthread.c\n vp9/decoder/vp9_dthread.h\n-vp9/decoder/vp9_read_bit_buffer.c\n-vp9/decoder/vp9_read_bit_buffer.h\n-vp9/decoder/vp9_reader.c\n-vp9/decoder/vp9_reader.h\n-vp9/decoder/vp9_thread.c\n-vp9/decoder/vp9_thread.h\n vp9/encoder/vp9_aq_complexity.c\n vp9/encoder/vp9_aq_complexity.h\n vp9/encoder/vp9_aq_cyclicrefresh.c\n vp9/encoder/vp9_aq_cyclicrefresh.h\n vp9/encoder/vp9_aq_variance.c\n vp9/encoder/vp9_aq_variance.h\n+vp9/encoder/vp9_avg.c\n vp9/encoder/vp9_bitstream.c\n vp9/encoder/vp9_bitstream.h\n vp9/encoder/vp9_block.h\n+vp9/encoder/vp9_context_tree.c\n+vp9/encoder/vp9_context_tree.h\n vp9/encoder/vp9_cost.c\n vp9/encoder/vp9_cost.h\n vp9/encoder/vp9_dct.c\n@@ -213,6 +201,10 @@\n\n vp9/encoder/vp9_encodemb.h\n vp9/encoder/vp9_encodemv.c\n vp9/encoder/vp9_encodemv.h\n+vp9/encoder/vp9_encoder.c\n+vp9/encoder/vp9_encoder.h\n+vp9/encoder/vp9_ethread.c\n+vp9/encoder/vp9_ethread.h\n vp9/encoder/vp9_extend.c\n vp9/encoder/vp9_extend.h\n vp9/encoder/vp9_firstpass.c\n@@ -223,8 +215,6 @@\n\n vp9/encoder/vp9_mbgraph.h\n vp9/encoder/vp9_mcomp.c\n vp9/encoder/vp9_mcomp.h\n-vp9/encoder/vp9_onyx_if.c\n-vp9/encoder/vp9_onyx_int.h\n vp9/encoder/vp9_picklpf.c\n vp9/encoder/vp9_picklpf.h\n vp9/encoder/vp9_pickmode.c\n@@ -233,13 +223,16 @@\n\n vp9/encoder/vp9_quantize.h\n vp9/encoder/vp9_ratectrl.c\n vp9/encoder/vp9_ratectrl.h\n+vp9/encoder/vp9_rd.c\n+vp9/encoder/vp9_rd.h\n vp9/encoder/vp9_rdopt.c\n vp9/encoder/vp9_rdopt.h\n vp9/encoder/vp9_resize.c\n vp9/encoder/vp9_resize.h\n-vp9/encoder/vp9_sad.c\n vp9/encoder/vp9_segmentation.c\n vp9/encoder/vp9_segmentation.h\n+vp9/encoder/vp9_skin_detection.c\n+vp9/encoder/vp9_skin_detection.h\n vp9/encoder/vp9_speed_features.c\n vp9/encoder/vp9_speed_features.h\n vp9/encoder/vp9_subexp.c\n@@ -252,53 +245,22 @@\n\n vp9/encoder/vp9_tokenize.h\n vp9/encoder/vp9_treewriter.c\n vp9/encoder/vp9_treewriter.h\n-vp9/encoder/vp9_variance.c\n-vp9/encoder/vp9_variance.h\n-vp9/encoder/vp9_write_bit_buffer.c\n-vp9/encoder/vp9_write_bit_buffer.h\n-vp9/encoder/vp9_writer.c\n-vp9/encoder/vp9_writer.h\n vp9/vp9_common.mk\n vp9/vp9_cx_iface.c\n-vp9/vp9cx.mk\n vp9/vp9_dx_iface.c\n-vp9/vp9dx.mk\n vp9/vp9_iface_common.h\n-vpx_config.c\n+vp9/vp9cx.mk\n+vp9/vp9dx.mk\n vpx/internal/vpx_codec_internal.h\n vpx/internal/vpx_psnr.h\n-vpx_mem/include/vpx_mem_intrnl.h\n-vpx_mem/vpx_mem.c\n-vpx_mem/vpx_mem.h\n-vpx_mem/vpx_mem.mk\n-vpx_ports/asm_offsets.h\n-vpx_ports/emmintrin_compat.h\n-vpx_ports/mem.h\n-vpx_ports/mem_ops_aligned.h\n-vpx_ports/mem_ops.h\n-vpx_ports/vpx_once.h\n-vpx_ports/vpx_ports.mk\n-vpx_ports/vpx_timer.h\n-vpx_scale/generic/gen_scalers.c\n-vpx_scale/generic/vpx_scale.c\n-vpx_scale/generic/yv12config.c\n-vpx_scale/generic/yv12extend.c\n-vpx_scale/vpx_scale_asm_offsets.c\n-vpx_scale/vpx_scale.h\n-vpx_scale/vpx_scale.mk\n-vpx_scale/vpx_scale_rtcd.c\n-vpx_scale/vpx_scale_rtcd.pl\n-vpx_scale/yv12config.h\n-vpx/src/svc_encodeframe.c\n vpx/src/vpx_codec.c\n vpx/src/vpx_decoder.c\n vpx/src/vpx_encoder.c\n vpx/src/vpx_image.c\n vpx/src/vpx_psnr.c\n-vpx/svc_context.h\n+vpx/vp8.h\n vpx/vp8cx.h\n vpx/vp8dx.h\n-vpx/vp8.h\n vpx/vpx_codec.h\n vpx/vpx_codec.mk\n vpx/vpx_decoder.h\n@@ -306,3 +268,61 @@\n\n vpx/vpx_frame_buffer.h\n vpx/vpx_image.h\n vpx/vpx_integer.h\n+vpx_config.c\n+vpx_dsp/bitreader.c\n+vpx_dsp/bitreader.h\n+vpx_dsp/bitreader_buffer.c\n+vpx_dsp/bitreader_buffer.h\n+vpx_dsp/bitwriter.c\n+vpx_dsp/bitwriter.h\n+vpx_dsp/bitwriter_buffer.c\n+vpx_dsp/bitwriter_buffer.h\n+vpx_dsp/fwd_txfm.c\n+vpx_dsp/fwd_txfm.h\n+vpx_dsp/intrapred.c\n+vpx_dsp/inv_txfm.c\n+vpx_dsp/inv_txfm.h\n+vpx_dsp/loopfilter.c\n+vpx_dsp/prob.c\n+vpx_dsp/prob.h\n+vpx_dsp/quantize.c\n+vpx_dsp/quantize.h\n+vpx_dsp/sad.c\n+vpx_dsp/subtract.c\n+vpx_dsp/txfm_common.h\n+vpx_dsp/variance.c\n+vpx_dsp/variance.h\n+vpx_dsp/vpx_convolve.c\n+vpx_dsp/vpx_convolve.h\n+vpx_dsp/vpx_dsp.mk\n+vpx_dsp/vpx_dsp_common.h\n+vpx_dsp/vpx_dsp_rtcd.c\n+vpx_dsp/vpx_dsp_rtcd_defs.pl\n+vpx_dsp/vpx_filter.h\n+vpx_mem/include/vpx_mem_intrnl.h\n+vpx_mem/vpx_mem.c\n+vpx_mem/vpx_mem.h\n+vpx_mem/vpx_mem.mk\n+vpx_ports/bitops.h\n+vpx_ports/emmintrin_compat.h\n+vpx_ports/mem.h\n+vpx_ports/mem_ops.h\n+vpx_ports/mem_ops_aligned.h\n+vpx_ports/msvc.h\n+vpx_ports/system_state.h\n+vpx_ports/vpx_once.h\n+vpx_ports/vpx_ports.mk\n+vpx_ports/vpx_timer.h\n+vpx_scale/generic/gen_scalers.c\n+vpx_scale/generic/vpx_scale.c\n+vpx_scale/generic/yv12config.c\n+vpx_scale/generic/yv12extend.c\n+vpx_scale/vpx_scale.h\n+vpx_scale/vpx_scale.mk\n+vpx_scale/vpx_scale_rtcd.c\n+vpx_scale/vpx_scale_rtcd.pl\n+vpx_scale/yv12config.h\n+vpx_util/endian_inl.h\n+vpx_util/vpx_thread.c\n+vpx_util/vpx_thread.h\n+vpx_util/vpx_util.mk\n""}<_**next**_>{""filename"": ""generic/vp8_rtcd.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/generic/vp8_rtcd.h"", ""patch"": ""@@ -7,10 +7,6 @@\n\n #define RTCD_EXTERN extern\n #endif\n \n-#ifdef __cplusplus\n-extern \""C\"" {\n-#endif\n-\n /*\n  * VP8\n  */\n@@ -26,6 +22,10 @@\n\n union int_mv;\n struct yv12_buffer_config;\n \n+#ifdef __cplusplus\n+extern \""C\"" {\n+#endif\n+\n void vp8_bilinear_predict16x16_c(unsigned char *src, int src_pitch, int xofst, int yofst, unsigned char *dst, int dst_pitch);\n #define vp8_bilinear_predict16x16 vp8_bilinear_predict16x16_c\n \n@@ -62,9 +62,12 @@\n\n void vp8_dc_only_idct_add_c(short input, unsigned char *pred, int pred_stride, unsigned char *dst, int dst_stride);\n #define vp8_dc_only_idct_add vp8_dc_only_idct_add_c\n \n-int vp8_denoiser_filter_c(struct yv12_buffer_config* mc_running_avg, struct yv12_buffer_config* running_avg, struct macroblock* signal, unsigned int motion_magnitude2, int y_offset, int uv_offset);\n+int vp8_denoiser_filter_c(unsigned char *mc_running_avg_y, int mc_avg_y_stride, unsigned char *running_avg_y, int avg_y_stride, unsigned char *sig, int sig_stride, unsigned int motion_magnitude, int increase_denoising);\n #define vp8_denoiser_filter vp8_denoiser_filter_c\n \n+int vp8_denoiser_filter_uv_c(unsigned char *mc_running_avg, int mc_avg_stride, unsigned char *running_avg, int avg_stride, unsigned char *sig, int sig_stride, unsigned int motion_magnitude, int increase_denoising);\n+#define vp8_denoiser_filter_uv vp8_denoiser_filter_uv_c\n+\n void vp8_dequant_idct_add_c(short *input, short *dq, unsigned char *output, int stride);\n #define vp8_dequant_idct_add vp8_dequant_idct_add_c\n \n@@ -83,18 +86,9 @@\n\n void vp8_fast_quantize_b_c(struct block *, struct blockd *);\n #define vp8_fast_quantize_b vp8_fast_quantize_b_c\n \n-void vp8_fast_quantize_b_pair_c(struct block *b1, struct block *b2, struct blockd *d1, struct blockd *d2);\n-#define vp8_fast_quantize_b_pair vp8_fast_quantize_b_pair_c\n-\n int vp8_full_search_sad_c(struct macroblock *x, struct block *b, struct blockd *d, union int_mv *ref_mv, int sad_per_bit, int distance, struct variance_vtable *fn_ptr, int *mvcost[2], union int_mv *center_mv);\n #define vp8_full_search_sad vp8_full_search_sad_c\n \n-unsigned int vp8_get4x4sse_cs_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride);\n-#define vp8_get4x4sse_cs vp8_get4x4sse_cs_c\n-\n-unsigned int vp8_get_mb_ss_c(const short *);\n-#define vp8_get_mb_ss vp8_get_mb_ss_c\n-\n void vp8_intra4x4_predict_c(unsigned char *Above, unsigned char *yleft, int left_stride, int b_mode, unsigned char *dst, int dst_stride, unsigned char top_left);\n #define vp8_intra4x4_predict vp8_intra4x4_predict_c\n \n@@ -128,87 +122,12 @@\n\n int vp8_mbuverror_c(struct macroblock *mb);\n #define vp8_mbuverror vp8_mbuverror_c\n \n-unsigned int vp8_mse16x16_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_mse16x16 vp8_mse16x16_c\n-\n-void vp8_quantize_mb_c(struct macroblock *);\n-#define vp8_quantize_mb vp8_quantize_mb_c\n-\n-void vp8_quantize_mbuv_c(struct macroblock *);\n-#define vp8_quantize_mbuv vp8_quantize_mbuv_c\n-\n-void vp8_quantize_mby_c(struct macroblock *);\n-#define vp8_quantize_mby vp8_quantize_mby_c\n-\n int vp8_refining_search_sad_c(struct macroblock *x, struct block *b, struct blockd *d, union int_mv *ref_mv, int sad_per_bit, int distance, struct variance_vtable *fn_ptr, int *mvcost[2], union int_mv *center_mv);\n #define vp8_refining_search_sad vp8_refining_search_sad_c\n \n void vp8_regular_quantize_b_c(struct block *, struct blockd *);\n #define vp8_regular_quantize_b vp8_regular_quantize_b_c\n \n-void vp8_regular_quantize_b_pair_c(struct block *b1, struct block *b2, struct blockd *d1, struct blockd *d2);\n-#define vp8_regular_quantize_b_pair vp8_regular_quantize_b_pair_c\n-\n-unsigned int vp8_sad16x16_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp8_sad16x16 vp8_sad16x16_c\n-\n-void vp8_sad16x16x3_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad16x16x3 vp8_sad16x16x3_c\n-\n-void vp8_sad16x16x4d_c(const unsigned char *src_ptr, int src_stride, const unsigned char * const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad16x16x4d vp8_sad16x16x4d_c\n-\n-void vp8_sad16x16x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned short *sad_array);\n-#define vp8_sad16x16x8 vp8_sad16x16x8_c\n-\n-unsigned int vp8_sad16x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp8_sad16x8 vp8_sad16x8_c\n-\n-void vp8_sad16x8x3_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad16x8x3 vp8_sad16x8x3_c\n-\n-void vp8_sad16x8x4d_c(const unsigned char *src_ptr, int src_stride, const unsigned char * const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad16x8x4d vp8_sad16x8x4d_c\n-\n-void vp8_sad16x8x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned short *sad_array);\n-#define vp8_sad16x8x8 vp8_sad16x8x8_c\n-\n-unsigned int vp8_sad4x4_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp8_sad4x4 vp8_sad4x4_c\n-\n-void vp8_sad4x4x3_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad4x4x3 vp8_sad4x4x3_c\n-\n-void vp8_sad4x4x4d_c(const unsigned char *src_ptr, int src_stride, const unsigned char * const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad4x4x4d vp8_sad4x4x4d_c\n-\n-void vp8_sad4x4x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned short *sad_array);\n-#define vp8_sad4x4x8 vp8_sad4x4x8_c\n-\n-unsigned int vp8_sad8x16_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp8_sad8x16 vp8_sad8x16_c\n-\n-void vp8_sad8x16x3_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad8x16x3 vp8_sad8x16x3_c\n-\n-void vp8_sad8x16x4d_c(const unsigned char *src_ptr, int src_stride, const unsigned char * const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad8x16x4d vp8_sad8x16x4d_c\n-\n-void vp8_sad8x16x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned short *sad_array);\n-#define vp8_sad8x16x8 vp8_sad8x16x8_c\n-\n-unsigned int vp8_sad8x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp8_sad8x8 vp8_sad8x8_c\n-\n-void vp8_sad8x8x3_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad8x8x3 vp8_sad8x8x3_c\n-\n-void vp8_sad8x8x4d_c(const unsigned char *src_ptr, int src_stride, const unsigned char * const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp8_sad8x8x4d vp8_sad8x8x4d_c\n-\n-void vp8_sad8x8x8_c(const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned short *sad_array);\n-#define vp8_sad8x8x8 vp8_sad8x8x8_c\n-\n void vp8_short_fdct4x4_c(short *input, short *output, int pitch);\n #define vp8_short_fdct4x4 vp8_short_fdct4x4_c\n \n@@ -239,60 +158,6 @@\n\n void vp8_sixtap_predict8x8_c(unsigned char *src, int src_pitch, int xofst, int yofst, unsigned char *dst, int dst_pitch);\n #define vp8_sixtap_predict8x8 vp8_sixtap_predict8x8_c\n \n-unsigned int vp8_sub_pixel_mse16x16_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_mse16x16 vp8_sub_pixel_mse16x16_c\n-\n-unsigned int vp8_sub_pixel_variance16x16_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_variance16x16 vp8_sub_pixel_variance16x16_c\n-\n-unsigned int vp8_sub_pixel_variance16x8_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_variance16x8 vp8_sub_pixel_variance16x8_c\n-\n-unsigned int vp8_sub_pixel_variance4x4_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_variance4x4 vp8_sub_pixel_variance4x4_c\n-\n-unsigned int vp8_sub_pixel_variance8x16_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_variance8x16 vp8_sub_pixel_variance8x16_c\n-\n-unsigned int vp8_sub_pixel_variance8x8_c(const unsigned char  *src_ptr, int  source_stride, int  xoffset, int  yoffset, const unsigned char *ref_ptr, int Refstride, unsigned int *sse);\n-#define vp8_sub_pixel_variance8x8 vp8_sub_pixel_variance8x8_c\n-\n-void vp8_subtract_b_c(struct block *be, struct blockd *bd, int pitch);\n-#define vp8_subtract_b vp8_subtract_b_c\n-\n-void vp8_subtract_mbuv_c(short *diff, unsigned char *usrc, unsigned char *vsrc, int src_stride, unsigned char *upred, unsigned char *vpred, int pred_stride);\n-#define vp8_subtract_mbuv vp8_subtract_mbuv_c\n-\n-void vp8_subtract_mby_c(short *diff, unsigned char *src, int src_stride, unsigned char *pred, int pred_stride);\n-#define vp8_subtract_mby vp8_subtract_mby_c\n-\n-unsigned int vp8_variance16x16_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance16x16 vp8_variance16x16_c\n-\n-unsigned int vp8_variance16x8_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance16x8 vp8_variance16x8_c\n-\n-unsigned int vp8_variance4x4_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance4x4 vp8_variance4x4_c\n-\n-unsigned int vp8_variance8x16_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance8x16 vp8_variance8x16_c\n-\n-unsigned int vp8_variance8x8_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance8x8 vp8_variance8x8_c\n-\n-unsigned int vp8_variance_halfpixvar16x16_h_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance_halfpixvar16x16_h vp8_variance_halfpixvar16x16_h_c\n-\n-unsigned int vp8_variance_halfpixvar16x16_hv_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance_halfpixvar16x16_hv vp8_variance_halfpixvar16x16_hv_c\n-\n-unsigned int vp8_variance_halfpixvar16x16_v_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, unsigned int *sse);\n-#define vp8_variance_halfpixvar16x16_v vp8_variance_halfpixvar16x16_v_c\n-\n-void vp8_yv12_copy_partial_frame_c(struct yv12_buffer_config *src_ybc, struct yv12_buffer_config *dst_ybc);\n-#define vp8_yv12_copy_partial_frame vp8_yv12_copy_partial_frame_c\n-\n void vp8_rtcd(void);\n \n #include \""vpx_config.h\""\n""}<_**next**_>{""filename"": ""generic/vp9_rtcd.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/generic/vp9_rtcd.h"", ""patch"": ""@@ -7,15 +7,12 @@\n\n #define RTCD_EXTERN extern\n #endif\n \n-#ifdef __cplusplus\n-extern \""C\"" {\n-#endif\n-\n /*\n  * VP9\n  */\n \n #include \""vpx/vpx_integer.h\""\n+#include \""vp9/common/vp9_common.h\""\n #include \""vp9/common/vp9_enums.h\""\n \n struct macroblockd;\n@@ -23,671 +20,89 @@\n\n /* Encoder forward decls */\n struct macroblock;\n struct vp9_variance_vtable;\n-\n-#define DEC_MVCOSTS int *mvjcost, int *mvcost[2]\n+struct search_site_config;\n struct mv;\n union int_mv;\n struct yv12_buffer_config;\n \n-void vp9_blend_b_c(uint8_t *y, uint8_t *u, uint8_t *v, int y1, int u1, int v1, int alpha, int stride);\n-#define vp9_blend_b vp9_blend_b_c\n+#ifdef __cplusplus\n+extern \""C\"" {\n+#endif\n \n-void vp9_blend_mb_inner_c(uint8_t *y, uint8_t *u, uint8_t *v, int y1, int u1, int v1, int alpha, int stride);\n-#define vp9_blend_mb_inner vp9_blend_mb_inner_c\n+unsigned int vp9_avg_4x4_c(const uint8_t *, int p);\n+#define vp9_avg_4x4 vp9_avg_4x4_c\n \n-void vp9_blend_mb_outer_c(uint8_t *y, uint8_t *u, uint8_t *v, int y1, int u1, int v1, int alpha, int stride);\n-#define vp9_blend_mb_outer vp9_blend_mb_outer_c\n+unsigned int vp9_avg_8x8_c(const uint8_t *, int p);\n+#define vp9_avg_8x8 vp9_avg_8x8_c\n \n-int64_t vp9_block_error_c(const int16_t *coeff, const int16_t *dqcoeff, intptr_t block_size, int64_t *ssz);\n+int64_t vp9_block_error_c(const tran_low_t *coeff, const tran_low_t *dqcoeff, intptr_t block_size, int64_t *ssz);\n #define vp9_block_error vp9_block_error_c\n \n-void vp9_convolve8_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8 vp9_convolve8_c\n+int64_t vp9_block_error_fp_c(const int16_t *coeff, const int16_t *dqcoeff, int block_size);\n+#define vp9_block_error_fp vp9_block_error_fp_c\n \n-void vp9_convolve8_avg_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8_avg vp9_convolve8_avg_c\n-\n-void vp9_convolve8_avg_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8_avg_horiz vp9_convolve8_avg_horiz_c\n-\n-void vp9_convolve8_avg_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8_avg_vert vp9_convolve8_avg_vert_c\n-\n-void vp9_convolve8_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8_horiz vp9_convolve8_horiz_c\n-\n-void vp9_convolve8_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve8_vert vp9_convolve8_vert_c\n-\n-void vp9_convolve_avg_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve_avg vp9_convolve_avg_c\n-\n-void vp9_convolve_copy_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n-#define vp9_convolve_copy vp9_convolve_copy_c\n-\n-void vp9_d117_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d117_predictor_16x16 vp9_d117_predictor_16x16_c\n-\n-void vp9_d117_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d117_predictor_32x32 vp9_d117_predictor_32x32_c\n-\n-void vp9_d117_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d117_predictor_4x4 vp9_d117_predictor_4x4_c\n-\n-void vp9_d117_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d117_predictor_8x8 vp9_d117_predictor_8x8_c\n-\n-void vp9_d135_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d135_predictor_16x16 vp9_d135_predictor_16x16_c\n-\n-void vp9_d135_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d135_predictor_32x32 vp9_d135_predictor_32x32_c\n-\n-void vp9_d135_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d135_predictor_4x4 vp9_d135_predictor_4x4_c\n-\n-void vp9_d135_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d135_predictor_8x8 vp9_d135_predictor_8x8_c\n-\n-void vp9_d153_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d153_predictor_16x16 vp9_d153_predictor_16x16_c\n-\n-void vp9_d153_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d153_predictor_32x32 vp9_d153_predictor_32x32_c\n-\n-void vp9_d153_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d153_predictor_4x4 vp9_d153_predictor_4x4_c\n-\n-void vp9_d153_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d153_predictor_8x8 vp9_d153_predictor_8x8_c\n-\n-void vp9_d207_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d207_predictor_16x16 vp9_d207_predictor_16x16_c\n-\n-void vp9_d207_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d207_predictor_32x32 vp9_d207_predictor_32x32_c\n-\n-void vp9_d207_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d207_predictor_4x4 vp9_d207_predictor_4x4_c\n-\n-void vp9_d207_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d207_predictor_8x8 vp9_d207_predictor_8x8_c\n-\n-void vp9_d45_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d45_predictor_16x16 vp9_d45_predictor_16x16_c\n-\n-void vp9_d45_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d45_predictor_32x32 vp9_d45_predictor_32x32_c\n-\n-void vp9_d45_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d45_predictor_4x4 vp9_d45_predictor_4x4_c\n-\n-void vp9_d45_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d45_predictor_8x8 vp9_d45_predictor_8x8_c\n-\n-void vp9_d63_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d63_predictor_16x16 vp9_d63_predictor_16x16_c\n-\n-void vp9_d63_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d63_predictor_32x32 vp9_d63_predictor_32x32_c\n-\n-void vp9_d63_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d63_predictor_4x4 vp9_d63_predictor_4x4_c\n-\n-void vp9_d63_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_d63_predictor_8x8 vp9_d63_predictor_8x8_c\n-\n-void vp9_dc_128_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_128_predictor_16x16 vp9_dc_128_predictor_16x16_c\n-\n-void vp9_dc_128_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_128_predictor_32x32 vp9_dc_128_predictor_32x32_c\n-\n-void vp9_dc_128_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_128_predictor_4x4 vp9_dc_128_predictor_4x4_c\n-\n-void vp9_dc_128_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_128_predictor_8x8 vp9_dc_128_predictor_8x8_c\n-\n-void vp9_dc_left_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_left_predictor_16x16 vp9_dc_left_predictor_16x16_c\n-\n-void vp9_dc_left_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_left_predictor_32x32 vp9_dc_left_predictor_32x32_c\n-\n-void vp9_dc_left_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_left_predictor_4x4 vp9_dc_left_predictor_4x4_c\n-\n-void vp9_dc_left_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_left_predictor_8x8 vp9_dc_left_predictor_8x8_c\n-\n-void vp9_dc_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_predictor_16x16 vp9_dc_predictor_16x16_c\n-\n-void vp9_dc_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_predictor_32x32 vp9_dc_predictor_32x32_c\n-\n-void vp9_dc_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_predictor_4x4 vp9_dc_predictor_4x4_c\n-\n-void vp9_dc_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_predictor_8x8 vp9_dc_predictor_8x8_c\n-\n-void vp9_dc_top_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_top_predictor_16x16 vp9_dc_top_predictor_16x16_c\n-\n-void vp9_dc_top_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_top_predictor_32x32 vp9_dc_top_predictor_32x32_c\n-\n-void vp9_dc_top_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_top_predictor_4x4 vp9_dc_top_predictor_4x4_c\n-\n-void vp9_dc_top_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_dc_top_predictor_8x8 vp9_dc_top_predictor_8x8_c\n-\n-int vp9_diamond_search_sad_c(const struct macroblock *x, struct mv *ref_mv, struct mv *best_mv, int search_param, int sad_per_bit, int *num00, const struct vp9_variance_vtable *fn_ptr, DEC_MVCOSTS, const struct mv *center_mv);\n+int vp9_diamond_search_sad_c(const struct macroblock *x, const struct search_site_config *cfg,  struct mv *ref_mv, struct mv *best_mv, int search_param, int sad_per_bit, int *num00, const struct vp9_variance_vtable *fn_ptr, const struct mv *center_mv);\n #define vp9_diamond_search_sad vp9_diamond_search_sad_c\n \n-void vp9_fdct16x16_c(const int16_t *input, int16_t *output, int stride);\n-#define vp9_fdct16x16 vp9_fdct16x16_c\n+void vp9_fdct8x8_quant_c(const int16_t *input, int stride, tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+#define vp9_fdct8x8_quant vp9_fdct8x8_quant_c\n \n-void vp9_fdct32x32_c(const int16_t *input, int16_t *output, int stride);\n-#define vp9_fdct32x32 vp9_fdct32x32_c\n-\n-void vp9_fdct32x32_rd_c(const int16_t *input, int16_t *output, int stride);\n-#define vp9_fdct32x32_rd vp9_fdct32x32_rd_c\n-\n-void vp9_fdct4x4_c(const int16_t *input, int16_t *output, int stride);\n-#define vp9_fdct4x4 vp9_fdct4x4_c\n-\n-void vp9_fdct8x8_c(const int16_t *input, int16_t *output, int stride);\n-#define vp9_fdct8x8 vp9_fdct8x8_c\n-\n-void vp9_fht16x16_c(const int16_t *input, int16_t *output, int stride, int tx_type);\n+void vp9_fht16x16_c(const int16_t *input, tran_low_t *output, int stride, int tx_type);\n #define vp9_fht16x16 vp9_fht16x16_c\n \n-void vp9_fht4x4_c(const int16_t *input, int16_t *output, int stride, int tx_type);\n+void vp9_fht4x4_c(const int16_t *input, tran_low_t *output, int stride, int tx_type);\n #define vp9_fht4x4 vp9_fht4x4_c\n \n-void vp9_fht8x8_c(const int16_t *input, int16_t *output, int stride, int tx_type);\n+void vp9_fht8x8_c(const int16_t *input, tran_low_t *output, int stride, int tx_type);\n #define vp9_fht8x8 vp9_fht8x8_c\n \n-int vp9_full_range_search_c(const struct macroblock *x, struct mv *ref_mv, struct mv *best_mv, int search_param, int sad_per_bit, int *num00, const struct vp9_variance_vtable *fn_ptr, DEC_MVCOSTS, const struct mv *center_mv);\n+int vp9_full_range_search_c(const struct macroblock *x, const struct search_site_config *cfg, struct mv *ref_mv, struct mv *best_mv, int search_param, int sad_per_bit, int *num00, const struct vp9_variance_vtable *fn_ptr, const struct mv *center_mv);\n #define vp9_full_range_search vp9_full_range_search_c\n \n-int vp9_full_search_sad_c(const struct macroblock *x, const struct mv *ref_mv, int sad_per_bit, int distance, const struct vp9_variance_vtable *fn_ptr, DEC_MVCOSTS, const struct mv *center_mv, struct mv *best_mv);\n+int vp9_full_search_sad_c(const struct macroblock *x, const struct mv *ref_mv, int sad_per_bit, int distance, const struct vp9_variance_vtable *fn_ptr, const struct mv *center_mv, struct mv *best_mv);\n #define vp9_full_search_sad vp9_full_search_sad_c\n \n-void vp9_fwht4x4_c(const int16_t *input, int16_t *output, int stride);\n+void vp9_fwht4x4_c(const int16_t *input, tran_low_t *output, int stride);\n #define vp9_fwht4x4 vp9_fwht4x4_c\n \n-unsigned int vp9_get_mb_ss_c(const int16_t *);\n-#define vp9_get_mb_ss vp9_get_mb_ss_c\n+void vp9_hadamard_16x16_c(int16_t const *src_diff, int src_stride, int16_t *coeff);\n+#define vp9_hadamard_16x16 vp9_hadamard_16x16_c\n \n-void vp9_get_sse_sum_16x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum);\n-#define vp9_get_sse_sum_16x16 vp9_get_sse_sum_16x16_c\n+void vp9_hadamard_8x8_c(int16_t const *src_diff, int src_stride, int16_t *coeff);\n+#define vp9_hadamard_8x8 vp9_hadamard_8x8_c\n \n-void vp9_get_sse_sum_8x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum);\n-#define vp9_get_sse_sum_8x8 vp9_get_sse_sum_8x8_c\n-\n-void vp9_h_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_h_predictor_16x16 vp9_h_predictor_16x16_c\n-\n-void vp9_h_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_h_predictor_32x32 vp9_h_predictor_32x32_c\n-\n-void vp9_h_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_h_predictor_4x4 vp9_h_predictor_4x4_c\n-\n-void vp9_h_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_h_predictor_8x8 vp9_h_predictor_8x8_c\n-\n-void vp9_idct16x16_10_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct16x16_10_add vp9_idct16x16_10_add_c\n-\n-void vp9_idct16x16_1_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct16x16_1_add vp9_idct16x16_1_add_c\n-\n-void vp9_idct16x16_256_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct16x16_256_add vp9_idct16x16_256_add_c\n-\n-void vp9_idct32x32_1024_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct32x32_1024_add vp9_idct32x32_1024_add_c\n-\n-void vp9_idct32x32_1_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct32x32_1_add vp9_idct32x32_1_add_c\n-\n-void vp9_idct32x32_34_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct32x32_34_add vp9_idct32x32_34_add_c\n-\n-void vp9_idct4x4_16_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct4x4_16_add vp9_idct4x4_16_add_c\n-\n-void vp9_idct4x4_1_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct4x4_1_add vp9_idct4x4_1_add_c\n-\n-void vp9_idct8x8_10_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct8x8_10_add vp9_idct8x8_10_add_c\n-\n-void vp9_idct8x8_1_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct8x8_1_add vp9_idct8x8_1_add_c\n-\n-void vp9_idct8x8_64_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_idct8x8_64_add vp9_idct8x8_64_add_c\n-\n-void vp9_iht16x16_256_add_c(const int16_t *input, uint8_t *output, int pitch, int tx_type);\n+void vp9_iht16x16_256_add_c(const tran_low_t *input, uint8_t *output, int pitch, int tx_type);\n #define vp9_iht16x16_256_add vp9_iht16x16_256_add_c\n \n-void vp9_iht4x4_16_add_c(const int16_t *input, uint8_t *dest, int dest_stride, int tx_type);\n+void vp9_iht4x4_16_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride, int tx_type);\n #define vp9_iht4x4_16_add vp9_iht4x4_16_add_c\n \n-void vp9_iht8x8_64_add_c(const int16_t *input, uint8_t *dest, int dest_stride, int tx_type);\n+void vp9_iht8x8_64_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride, int tx_type);\n #define vp9_iht8x8_64_add vp9_iht8x8_64_add_c\n \n-void vp9_iwht4x4_16_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_iwht4x4_16_add vp9_iwht4x4_16_add_c\n+int16_t vp9_int_pro_col_c(uint8_t const *ref, const int width);\n+#define vp9_int_pro_col vp9_int_pro_col_c\n \n-void vp9_iwht4x4_1_add_c(const int16_t *input, uint8_t *dest, int dest_stride);\n-#define vp9_iwht4x4_1_add vp9_iwht4x4_1_add_c\n+void vp9_int_pro_row_c(int16_t *hbuf, uint8_t const *ref, const int ref_stride, const int height);\n+#define vp9_int_pro_row vp9_int_pro_row_c\n \n-void vp9_lpf_horizontal_16_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-#define vp9_lpf_horizontal_16 vp9_lpf_horizontal_16_c\n+void vp9_minmax_8x8_c(const uint8_t *s, int p, const uint8_t *d, int dp, int *min, int *max);\n+#define vp9_minmax_8x8 vp9_minmax_8x8_c\n \n-void vp9_lpf_horizontal_4_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-#define vp9_lpf_horizontal_4 vp9_lpf_horizontal_4_c\n+void vp9_quantize_fp_c(const tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+#define vp9_quantize_fp vp9_quantize_fp_c\n \n-void vp9_lpf_horizontal_4_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n-#define vp9_lpf_horizontal_4_dual vp9_lpf_horizontal_4_dual_c\n+void vp9_quantize_fp_32x32_c(const tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+#define vp9_quantize_fp_32x32 vp9_quantize_fp_32x32_c\n \n-void vp9_lpf_horizontal_8_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-#define vp9_lpf_horizontal_8 vp9_lpf_horizontal_8_c\n+int16_t vp9_satd_c(const int16_t *coeff, int length);\n+#define vp9_satd vp9_satd_c\n \n-void vp9_lpf_horizontal_8_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n-#define vp9_lpf_horizontal_8_dual vp9_lpf_horizontal_8_dual_c\n-\n-void vp9_lpf_vertical_16_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh);\n-#define vp9_lpf_vertical_16 vp9_lpf_vertical_16_c\n-\n-void vp9_lpf_vertical_16_dual_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh);\n-#define vp9_lpf_vertical_16_dual vp9_lpf_vertical_16_dual_c\n-\n-void vp9_lpf_vertical_4_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-#define vp9_lpf_vertical_4 vp9_lpf_vertical_4_c\n-\n-void vp9_lpf_vertical_4_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n-#define vp9_lpf_vertical_4_dual vp9_lpf_vertical_4_dual_c\n-\n-void vp9_lpf_vertical_8_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n-#define vp9_lpf_vertical_8 vp9_lpf_vertical_8_c\n-\n-void vp9_lpf_vertical_8_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n-#define vp9_lpf_vertical_8_dual vp9_lpf_vertical_8_dual_c\n-\n-unsigned int vp9_mse16x16_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n-#define vp9_mse16x16 vp9_mse16x16_c\n-\n-unsigned int vp9_mse16x8_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n-#define vp9_mse16x8 vp9_mse16x8_c\n-\n-unsigned int vp9_mse8x16_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n-#define vp9_mse8x16 vp9_mse8x16_c\n-\n-unsigned int vp9_mse8x8_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n-#define vp9_mse8x8 vp9_mse8x8_c\n-\n-void vp9_quantize_b_c(const int16_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, int16_t *qcoeff_ptr, int16_t *dqcoeff_ptr, const int16_t *dequant_ptr, int zbin_oq_value, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n-#define vp9_quantize_b vp9_quantize_b_c\n-\n-void vp9_quantize_b_32x32_c(const int16_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, int16_t *qcoeff_ptr, int16_t *dqcoeff_ptr, const int16_t *dequant_ptr, int zbin_oq_value, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n-#define vp9_quantize_b_32x32 vp9_quantize_b_32x32_c\n-\n-int vp9_refining_search_sad_c(const struct macroblock *x, struct mv *ref_mv, int sad_per_bit, int distance, const struct vp9_variance_vtable *fn_ptr, DEC_MVCOSTS, const struct mv *center_mv);\n-#define vp9_refining_search_sad vp9_refining_search_sad_c\n-\n-unsigned int vp9_sad16x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad16x16 vp9_sad16x16_c\n-\n-unsigned int vp9_sad16x16_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad16x16_avg vp9_sad16x16_avg_c\n-\n-void vp9_sad16x16x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad16x16x3 vp9_sad16x16x3_c\n-\n-void vp9_sad16x16x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad16x16x4d vp9_sad16x16x4d_c\n-\n-void vp9_sad16x16x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad16x16x8 vp9_sad16x16x8_c\n-\n-unsigned int vp9_sad16x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad16x32 vp9_sad16x32_c\n-\n-unsigned int vp9_sad16x32_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad16x32_avg vp9_sad16x32_avg_c\n-\n-void vp9_sad16x32x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad16x32x4d vp9_sad16x32x4d_c\n-\n-unsigned int vp9_sad16x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad16x8 vp9_sad16x8_c\n-\n-unsigned int vp9_sad16x8_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad16x8_avg vp9_sad16x8_avg_c\n-\n-void vp9_sad16x8x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad16x8x3 vp9_sad16x8x3_c\n-\n-void vp9_sad16x8x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad16x8x4d vp9_sad16x8x4d_c\n-\n-void vp9_sad16x8x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad16x8x8 vp9_sad16x8x8_c\n-\n-unsigned int vp9_sad32x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad32x16 vp9_sad32x16_c\n-\n-unsigned int vp9_sad32x16_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad32x16_avg vp9_sad32x16_avg_c\n-\n-void vp9_sad32x16x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad32x16x4d vp9_sad32x16x4d_c\n-\n-unsigned int vp9_sad32x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad32x32 vp9_sad32x32_c\n-\n-unsigned int vp9_sad32x32_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad32x32_avg vp9_sad32x32_avg_c\n-\n-void vp9_sad32x32x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad32x32x3 vp9_sad32x32x3_c\n-\n-void vp9_sad32x32x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad32x32x4d vp9_sad32x32x4d_c\n-\n-void vp9_sad32x32x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad32x32x8 vp9_sad32x32x8_c\n-\n-unsigned int vp9_sad32x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad32x64 vp9_sad32x64_c\n-\n-unsigned int vp9_sad32x64_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad32x64_avg vp9_sad32x64_avg_c\n-\n-void vp9_sad32x64x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad32x64x4d vp9_sad32x64x4d_c\n-\n-unsigned int vp9_sad4x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad4x4 vp9_sad4x4_c\n-\n-unsigned int vp9_sad4x4_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad4x4_avg vp9_sad4x4_avg_c\n-\n-void vp9_sad4x4x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad4x4x3 vp9_sad4x4x3_c\n-\n-void vp9_sad4x4x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad4x4x4d vp9_sad4x4x4d_c\n-\n-void vp9_sad4x4x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad4x4x8 vp9_sad4x4x8_c\n-\n-unsigned int vp9_sad4x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad4x8 vp9_sad4x8_c\n-\n-unsigned int vp9_sad4x8_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad4x8_avg vp9_sad4x8_avg_c\n-\n-void vp9_sad4x8x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_ptr[], int ref_stride, unsigned int *sad_array);\n-#define vp9_sad4x8x4d vp9_sad4x8x4d_c\n-\n-void vp9_sad4x8x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n-#define vp9_sad4x8x8 vp9_sad4x8x8_c\n-\n-unsigned int vp9_sad64x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad64x32 vp9_sad64x32_c\n-\n-unsigned int vp9_sad64x32_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad64x32_avg vp9_sad64x32_avg_c\n-\n-void vp9_sad64x32x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad64x32x4d vp9_sad64x32x4d_c\n-\n-unsigned int vp9_sad64x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad64x64 vp9_sad64x64_c\n-\n-unsigned int vp9_sad64x64_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad64x64_avg vp9_sad64x64_avg_c\n-\n-void vp9_sad64x64x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad64x64x3 vp9_sad64x64x3_c\n-\n-void vp9_sad64x64x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad64x64x4d vp9_sad64x64x4d_c\n-\n-void vp9_sad64x64x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad64x64x8 vp9_sad64x64x8_c\n-\n-unsigned int vp9_sad8x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad8x16 vp9_sad8x16_c\n-\n-unsigned int vp9_sad8x16_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad8x16_avg vp9_sad8x16_avg_c\n-\n-void vp9_sad8x16x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad8x16x3 vp9_sad8x16x3_c\n-\n-void vp9_sad8x16x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad8x16x4d vp9_sad8x16x4d_c\n-\n-void vp9_sad8x16x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad8x16x8 vp9_sad8x16x8_c\n-\n-unsigned int vp9_sad8x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int max_sad);\n-#define vp9_sad8x4 vp9_sad8x4_c\n-\n-unsigned int vp9_sad8x4_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad8x4_avg vp9_sad8x4_avg_c\n-\n-void vp9_sad8x4x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_ptr[], int ref_stride, unsigned int *sad_array);\n-#define vp9_sad8x4x4d vp9_sad8x4x4d_c\n-\n-void vp9_sad8x4x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n-#define vp9_sad8x4x8 vp9_sad8x4x8_c\n-\n-unsigned int vp9_sad8x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int max_sad);\n-#define vp9_sad8x8 vp9_sad8x8_c\n-\n-unsigned int vp9_sad8x8_avg_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, const uint8_t *second_pred, unsigned int max_sad);\n-#define vp9_sad8x8_avg vp9_sad8x8_avg_c\n-\n-void vp9_sad8x8x3_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad8x8x3 vp9_sad8x8x3_c\n-\n-void vp9_sad8x8x4d_c(const uint8_t *src_ptr, int  src_stride, const uint8_t* const ref_ptr[], int  ref_stride, unsigned int *sad_array);\n-#define vp9_sad8x8x4d vp9_sad8x8x4d_c\n-\n-void vp9_sad8x8x8_c(const uint8_t *src_ptr, int  src_stride, const uint8_t *ref_ptr, int  ref_stride, uint32_t *sad_array);\n-#define vp9_sad8x8x8 vp9_sad8x8x8_c\n-\n-unsigned int vp9_sub_pixel_avg_variance16x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance16x16 vp9_sub_pixel_avg_variance16x16_c\n-\n-unsigned int vp9_sub_pixel_avg_variance16x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance16x32 vp9_sub_pixel_avg_variance16x32_c\n-\n-unsigned int vp9_sub_pixel_avg_variance16x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance16x8 vp9_sub_pixel_avg_variance16x8_c\n-\n-unsigned int vp9_sub_pixel_avg_variance32x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance32x16 vp9_sub_pixel_avg_variance32x16_c\n-\n-unsigned int vp9_sub_pixel_avg_variance32x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance32x32 vp9_sub_pixel_avg_variance32x32_c\n-\n-unsigned int vp9_sub_pixel_avg_variance32x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance32x64 vp9_sub_pixel_avg_variance32x64_c\n-\n-unsigned int vp9_sub_pixel_avg_variance4x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance4x4 vp9_sub_pixel_avg_variance4x4_c\n-\n-unsigned int vp9_sub_pixel_avg_variance4x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance4x8 vp9_sub_pixel_avg_variance4x8_c\n-\n-unsigned int vp9_sub_pixel_avg_variance64x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance64x32 vp9_sub_pixel_avg_variance64x32_c\n-\n-unsigned int vp9_sub_pixel_avg_variance64x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance64x64 vp9_sub_pixel_avg_variance64x64_c\n-\n-unsigned int vp9_sub_pixel_avg_variance8x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance8x16 vp9_sub_pixel_avg_variance8x16_c\n-\n-unsigned int vp9_sub_pixel_avg_variance8x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance8x4 vp9_sub_pixel_avg_variance8x4_c\n-\n-unsigned int vp9_sub_pixel_avg_variance8x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, const uint8_t *second_pred);\n-#define vp9_sub_pixel_avg_variance8x8 vp9_sub_pixel_avg_variance8x8_c\n-\n-unsigned int vp9_sub_pixel_mse32x32_c(const uint8_t *src_ptr, int  source_stride, int  xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_mse32x32 vp9_sub_pixel_mse32x32_c\n-\n-unsigned int vp9_sub_pixel_mse64x64_c(const uint8_t *src_ptr, int  source_stride, int  xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_mse64x64 vp9_sub_pixel_mse64x64_c\n-\n-unsigned int vp9_sub_pixel_variance16x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance16x16 vp9_sub_pixel_variance16x16_c\n-\n-unsigned int vp9_sub_pixel_variance16x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance16x32 vp9_sub_pixel_variance16x32_c\n-\n-unsigned int vp9_sub_pixel_variance16x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance16x8 vp9_sub_pixel_variance16x8_c\n-\n-unsigned int vp9_sub_pixel_variance32x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance32x16 vp9_sub_pixel_variance32x16_c\n-\n-unsigned int vp9_sub_pixel_variance32x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance32x32 vp9_sub_pixel_variance32x32_c\n-\n-unsigned int vp9_sub_pixel_variance32x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance32x64 vp9_sub_pixel_variance32x64_c\n-\n-unsigned int vp9_sub_pixel_variance4x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance4x4 vp9_sub_pixel_variance4x4_c\n-\n-unsigned int vp9_sub_pixel_variance4x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance4x8 vp9_sub_pixel_variance4x8_c\n-\n-unsigned int vp9_sub_pixel_variance64x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance64x32 vp9_sub_pixel_variance64x32_c\n-\n-unsigned int vp9_sub_pixel_variance64x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance64x64 vp9_sub_pixel_variance64x64_c\n-\n-unsigned int vp9_sub_pixel_variance8x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance8x16 vp9_sub_pixel_variance8x16_c\n-\n-unsigned int vp9_sub_pixel_variance8x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance8x4 vp9_sub_pixel_variance8x4_c\n-\n-unsigned int vp9_sub_pixel_variance8x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_sub_pixel_variance8x8 vp9_sub_pixel_variance8x8_c\n-\n-void vp9_subtract_block_c(int rows, int cols, int16_t *diff_ptr, ptrdiff_t diff_stride, const uint8_t *src_ptr, ptrdiff_t src_stride, const uint8_t *pred_ptr, ptrdiff_t pred_stride);\n-#define vp9_subtract_block vp9_subtract_block_c\n-\n-void vp9_temporal_filter_apply_c(uint8_t *frame1, unsigned int stride, uint8_t *frame2, unsigned int block_size, int strength, int filter_weight, unsigned int *accumulator, uint16_t *count);\n+void vp9_temporal_filter_apply_c(uint8_t *frame1, unsigned int stride, uint8_t *frame2, unsigned int block_width, unsigned int block_height, int strength, int filter_weight, unsigned int *accumulator, uint16_t *count);\n #define vp9_temporal_filter_apply vp9_temporal_filter_apply_c\n \n-void vp9_tm_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_tm_predictor_16x16 vp9_tm_predictor_16x16_c\n-\n-void vp9_tm_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_tm_predictor_32x32 vp9_tm_predictor_32x32_c\n-\n-void vp9_tm_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_tm_predictor_4x4 vp9_tm_predictor_4x4_c\n-\n-void vp9_tm_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_tm_predictor_8x8 vp9_tm_predictor_8x8_c\n-\n-void vp9_v_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_v_predictor_16x16 vp9_v_predictor_16x16_c\n-\n-void vp9_v_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_v_predictor_32x32 vp9_v_predictor_32x32_c\n-\n-void vp9_v_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_v_predictor_4x4 vp9_v_predictor_4x4_c\n-\n-void vp9_v_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n-#define vp9_v_predictor_8x8 vp9_v_predictor_8x8_c\n-\n-unsigned int vp9_variance16x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance16x16 vp9_variance16x16_c\n-\n-unsigned int vp9_variance16x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance16x32 vp9_variance16x32_c\n-\n-unsigned int vp9_variance16x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance16x8 vp9_variance16x8_c\n-\n-unsigned int vp9_variance32x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance32x16 vp9_variance32x16_c\n-\n-unsigned int vp9_variance32x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance32x32 vp9_variance32x32_c\n-\n-unsigned int vp9_variance32x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance32x64 vp9_variance32x64_c\n-\n-unsigned int vp9_variance4x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance4x4 vp9_variance4x4_c\n-\n-unsigned int vp9_variance4x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance4x8 vp9_variance4x8_c\n-\n-unsigned int vp9_variance64x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance64x32 vp9_variance64x32_c\n-\n-unsigned int vp9_variance64x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance64x64 vp9_variance64x64_c\n-\n-unsigned int vp9_variance8x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance8x16 vp9_variance8x16_c\n-\n-unsigned int vp9_variance8x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance8x4 vp9_variance8x4_c\n-\n-unsigned int vp9_variance8x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance8x8 vp9_variance8x8_c\n-\n-unsigned int vp9_variance_halfpixvar16x16_h_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar16x16_h vp9_variance_halfpixvar16x16_h_c\n-\n-unsigned int vp9_variance_halfpixvar16x16_hv_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar16x16_hv vp9_variance_halfpixvar16x16_hv_c\n-\n-unsigned int vp9_variance_halfpixvar16x16_v_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar16x16_v vp9_variance_halfpixvar16x16_v_c\n-\n-unsigned int vp9_variance_halfpixvar32x32_h_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar32x32_h vp9_variance_halfpixvar32x32_h_c\n-\n-unsigned int vp9_variance_halfpixvar32x32_hv_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar32x32_hv vp9_variance_halfpixvar32x32_hv_c\n-\n-unsigned int vp9_variance_halfpixvar32x32_v_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar32x32_v vp9_variance_halfpixvar32x32_v_c\n-\n-unsigned int vp9_variance_halfpixvar64x64_h_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar64x64_h vp9_variance_halfpixvar64x64_h_c\n-\n-unsigned int vp9_variance_halfpixvar64x64_hv_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar64x64_hv vp9_variance_halfpixvar64x64_hv_c\n-\n-unsigned int vp9_variance_halfpixvar64x64_v_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n-#define vp9_variance_halfpixvar64x64_v vp9_variance_halfpixvar64x64_v_c\n+int vp9_vector_var_c(int16_t const *ref, int16_t const *src, const int bwl);\n+#define vp9_vector_var vp9_vector_var_c\n \n void vp9_rtcd(void);\n \n""}<_**next**_>{""filename"": ""generic/vpx_config.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/generic/vpx_config.c"", ""patch"": ""@@ -5,5 +5,6 @@\n\n /* tree. An additional intellectual property rights grant can be found */\n /* in the file PATENTS.  All contributing project authors may */\n /* be found in the AUTHORS file in the root of the source tree. */\n-static const char* const cfg = \""--force-target=generic-gnu --disable-examples --disable-docs --enable-realtime-only\"";\n+#include \""vpx/vpx_codec.h\""\n+static const char* const cfg = \""--force-target=generic-gnu --disable-examples --disable-docs --enable-realtime-only --disable-webm-io\"";\n const char *vpx_codec_build_config(void) {return cfg;}\n""}<_**next**_>{""filename"": ""generic/vpx_config.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/generic/vpx_config.h"", ""patch"": ""@@ -9,18 +9,19 @@\n\n #ifndef VPX_CONFIG_H\n #define VPX_CONFIG_H\n #define RESTRICT    \n-#define INLINE      __inline__ __attribute__((always_inline))\n+#define INLINE      inline\n #define ARCH_ARM 0\n #define ARCH_MIPS 0\n #define ARCH_X86 0\n #define ARCH_X86_64 0\n-#define ARCH_PPC32 0\n-#define ARCH_PPC64 0\n #define HAVE_EDSP 0\n #define HAVE_MEDIA 0\n #define HAVE_NEON 0\n+#define HAVE_NEON_ASM 0\n #define HAVE_MIPS32 0\n #define HAVE_DSPR2 0\n+#define HAVE_MSA 0\n+#define HAVE_MIPS64 0\n #define HAVE_MMX 0\n #define HAVE_SSE 0\n #define HAVE_SSE2 0\n@@ -29,19 +30,18 @@\n\n #define HAVE_SSE4_1 0\n #define HAVE_AVX 0\n #define HAVE_AVX2 0\n-#define HAVE_ALTIVEC 0\n #define HAVE_VPX_PORTS 1\n #define HAVE_STDINT_H 1\n-#define HAVE_ALT_TREE_LAYOUT 0\n #define HAVE_PTHREAD_H 1\n #define HAVE_SYS_MMAN_H 1\n #define HAVE_UNISTD_H 1\n+#define CONFIG_DEPENDENCY_TRACKING 1\n #define CONFIG_EXTERNAL_BUILD 0\n-#define CONFIG_INSTALL_DOCS 0\n+#define CONFIG_INSTALL_DOCS 1\n #define CONFIG_INSTALL_BINS 1\n #define CONFIG_INSTALL_LIBS 1\n #define CONFIG_INSTALL_SRCS 0\n-#define CONFIG_USE_X86INC 1\n+#define CONFIG_USE_X86INC 0\n #define CONFIG_DEBUG 0\n #define CONFIG_GPROF 0\n #define CONFIG_GCOV 0\n@@ -52,10 +52,6 @@\n\n #define CONFIG_BIG_ENDIAN 0\n #define CONFIG_CODEC_SRCS 0\n #define CONFIG_DEBUG_LIBS 0\n-#define CONFIG_FAST_UNALIGNED 1\n-#define CONFIG_MEM_MANAGER 0\n-#define CONFIG_MEM_TRACKER 0\n-#define CONFIG_MEM_CHECKS 0\n #define CONFIG_DEQUANT_TOKENS 0\n #define CONFIG_DC_RECON 0\n #define CONFIG_RUNTIME_CPU_DETECT 0\n@@ -67,8 +63,11 @@\n\n #define CONFIG_VP8_DECODER 1\n #define CONFIG_VP9_ENCODER 1\n #define CONFIG_VP9_DECODER 1\n+#define CONFIG_VP10_ENCODER 0\n+#define CONFIG_VP10_DECODER 0\n #define CONFIG_VP8 1\n #define CONFIG_VP9 1\n+#define CONFIG_VP10 0\n #define CONFIG_ENCODERS 1\n #define CONFIG_DECODERS 1\n #define CONFIG_STATIC_MSVCRT 0\n@@ -82,12 +81,18 @@\n\n #define CONFIG_POSTPROC_VISUALIZER 0\n #define CONFIG_OS_SUPPORT 1\n #define CONFIG_UNIT_TESTS 1\n-#define CONFIG_WEBM_IO 1\n+#define CONFIG_WEBM_IO 0\n+#define CONFIG_LIBYUV 1\n #define CONFIG_DECODE_PERF_TESTS 0\n+#define CONFIG_ENCODE_PERF_TESTS 0\n #define CONFIG_MULTI_RES_ENCODING 0\n #define CONFIG_TEMPORAL_DENOISING 1\n+#define CONFIG_VP9_TEMPORAL_DENOISING 0\n+#define CONFIG_COEFFICIENT_RANGE_CHECKING 0\n+#define CONFIG_VP9_HIGHBITDEPTH 0\n #define CONFIG_EXPERIMENTAL 0\n-#define CONFIG_DECRYPT 0\n-#define CONFIG_MULTIPLE_ARF 0\n-#define CONFIG_ALPHA 0\n+#define CONFIG_SIZE_LIMIT 0\n+#define CONFIG_SPATIAL_SVC 0\n+#define CONFIG_FP_MB_STATS 0\n+#define CONFIG_EMULATE_HARDWARE 0\n #endif /* VPX_CONFIG_H */\n""}<_**next**_>{""filename"": ""generic/vpx_dsp_rtcd.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/generic/vpx_dsp_rtcd.h"", ""patch"": ""@@ -0,0 +1,660 @@\n\n+#ifndef VPX_DSP_RTCD_H_\n+#define VPX_DSP_RTCD_H_\n+\n+#ifdef RTCD_C\n+#define RTCD_EXTERN\n+#else\n+#define RTCD_EXTERN extern\n+#endif\n+\n+/*\n+ * DSP\n+ */\n+\n+#include \""vpx/vpx_integer.h\""\n+#include \""vpx_dsp/vpx_dsp_common.h\""\n+\n+\n+#ifdef __cplusplus\n+extern \""C\"" {\n+#endif\n+\n+void vpx_comp_avg_pred_c(uint8_t *comp_pred, const uint8_t *pred, int width, int height, const uint8_t *ref, int ref_stride);\n+#define vpx_comp_avg_pred vpx_comp_avg_pred_c\n+\n+void vpx_convolve8_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8 vpx_convolve8_c\n+\n+void vpx_convolve8_avg_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8_avg vpx_convolve8_avg_c\n+\n+void vpx_convolve8_avg_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8_avg_horiz vpx_convolve8_avg_horiz_c\n+\n+void vpx_convolve8_avg_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8_avg_vert vpx_convolve8_avg_vert_c\n+\n+void vpx_convolve8_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8_horiz vpx_convolve8_horiz_c\n+\n+void vpx_convolve8_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve8_vert vpx_convolve8_vert_c\n+\n+void vpx_convolve_avg_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve_avg vpx_convolve_avg_c\n+\n+void vpx_convolve_copy_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_convolve_copy vpx_convolve_copy_c\n+\n+void vpx_d117_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d117_predictor_16x16 vpx_d117_predictor_16x16_c\n+\n+void vpx_d117_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d117_predictor_32x32 vpx_d117_predictor_32x32_c\n+\n+void vpx_d117_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d117_predictor_4x4 vpx_d117_predictor_4x4_c\n+\n+void vpx_d117_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d117_predictor_8x8 vpx_d117_predictor_8x8_c\n+\n+void vpx_d135_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d135_predictor_16x16 vpx_d135_predictor_16x16_c\n+\n+void vpx_d135_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d135_predictor_32x32 vpx_d135_predictor_32x32_c\n+\n+void vpx_d135_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d135_predictor_4x4 vpx_d135_predictor_4x4_c\n+\n+void vpx_d135_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d135_predictor_8x8 vpx_d135_predictor_8x8_c\n+\n+void vpx_d153_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d153_predictor_16x16 vpx_d153_predictor_16x16_c\n+\n+void vpx_d153_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d153_predictor_32x32 vpx_d153_predictor_32x32_c\n+\n+void vpx_d153_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d153_predictor_4x4 vpx_d153_predictor_4x4_c\n+\n+void vpx_d153_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d153_predictor_8x8 vpx_d153_predictor_8x8_c\n+\n+void vpx_d207_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d207_predictor_16x16 vpx_d207_predictor_16x16_c\n+\n+void vpx_d207_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d207_predictor_32x32 vpx_d207_predictor_32x32_c\n+\n+void vpx_d207_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d207_predictor_4x4 vpx_d207_predictor_4x4_c\n+\n+void vpx_d207_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d207_predictor_8x8 vpx_d207_predictor_8x8_c\n+\n+void vpx_d45_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d45_predictor_16x16 vpx_d45_predictor_16x16_c\n+\n+void vpx_d45_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d45_predictor_32x32 vpx_d45_predictor_32x32_c\n+\n+void vpx_d45_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d45_predictor_4x4 vpx_d45_predictor_4x4_c\n+\n+void vpx_d45_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d45_predictor_8x8 vpx_d45_predictor_8x8_c\n+\n+void vpx_d63_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d63_predictor_16x16 vpx_d63_predictor_16x16_c\n+\n+void vpx_d63_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d63_predictor_32x32 vpx_d63_predictor_32x32_c\n+\n+void vpx_d63_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d63_predictor_4x4 vpx_d63_predictor_4x4_c\n+\n+void vpx_d63_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_d63_predictor_8x8 vpx_d63_predictor_8x8_c\n+\n+void vpx_dc_128_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_128_predictor_16x16 vpx_dc_128_predictor_16x16_c\n+\n+void vpx_dc_128_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_128_predictor_32x32 vpx_dc_128_predictor_32x32_c\n+\n+void vpx_dc_128_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_128_predictor_4x4 vpx_dc_128_predictor_4x4_c\n+\n+void vpx_dc_128_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_128_predictor_8x8 vpx_dc_128_predictor_8x8_c\n+\n+void vpx_dc_left_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_left_predictor_16x16 vpx_dc_left_predictor_16x16_c\n+\n+void vpx_dc_left_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_left_predictor_32x32 vpx_dc_left_predictor_32x32_c\n+\n+void vpx_dc_left_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_left_predictor_4x4 vpx_dc_left_predictor_4x4_c\n+\n+void vpx_dc_left_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_left_predictor_8x8 vpx_dc_left_predictor_8x8_c\n+\n+void vpx_dc_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_predictor_16x16 vpx_dc_predictor_16x16_c\n+\n+void vpx_dc_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_predictor_32x32 vpx_dc_predictor_32x32_c\n+\n+void vpx_dc_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_predictor_4x4 vpx_dc_predictor_4x4_c\n+\n+void vpx_dc_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_predictor_8x8 vpx_dc_predictor_8x8_c\n+\n+void vpx_dc_top_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_top_predictor_16x16 vpx_dc_top_predictor_16x16_c\n+\n+void vpx_dc_top_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_top_predictor_32x32 vpx_dc_top_predictor_32x32_c\n+\n+void vpx_dc_top_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_top_predictor_4x4 vpx_dc_top_predictor_4x4_c\n+\n+void vpx_dc_top_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_dc_top_predictor_8x8 vpx_dc_top_predictor_8x8_c\n+\n+void vpx_fdct16x16_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct16x16 vpx_fdct16x16_c\n+\n+void vpx_fdct16x16_1_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct16x16_1 vpx_fdct16x16_1_c\n+\n+void vpx_fdct32x32_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct32x32 vpx_fdct32x32_c\n+\n+void vpx_fdct32x32_1_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct32x32_1 vpx_fdct32x32_1_c\n+\n+void vpx_fdct32x32_rd_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct32x32_rd vpx_fdct32x32_rd_c\n+\n+void vpx_fdct4x4_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct4x4 vpx_fdct4x4_c\n+\n+void vpx_fdct4x4_1_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct4x4_1 vpx_fdct4x4_1_c\n+\n+void vpx_fdct8x8_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct8x8 vpx_fdct8x8_c\n+\n+void vpx_fdct8x8_1_c(const int16_t *input, tran_low_t *output, int stride);\n+#define vpx_fdct8x8_1 vpx_fdct8x8_1_c\n+\n+void vpx_get16x16var_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum);\n+#define vpx_get16x16var vpx_get16x16var_c\n+\n+unsigned int vpx_get4x4sse_cs_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride);\n+#define vpx_get4x4sse_cs vpx_get4x4sse_cs_c\n+\n+void vpx_get8x8var_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum);\n+#define vpx_get8x8var vpx_get8x8var_c\n+\n+unsigned int vpx_get_mb_ss_c(const int16_t *);\n+#define vpx_get_mb_ss vpx_get_mb_ss_c\n+\n+void vpx_h_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_h_predictor_16x16 vpx_h_predictor_16x16_c\n+\n+void vpx_h_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_h_predictor_32x32 vpx_h_predictor_32x32_c\n+\n+void vpx_h_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_h_predictor_4x4 vpx_h_predictor_4x4_c\n+\n+void vpx_h_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_h_predictor_8x8 vpx_h_predictor_8x8_c\n+\n+void vpx_idct16x16_10_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct16x16_10_add vpx_idct16x16_10_add_c\n+\n+void vpx_idct16x16_1_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct16x16_1_add vpx_idct16x16_1_add_c\n+\n+void vpx_idct16x16_256_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct16x16_256_add vpx_idct16x16_256_add_c\n+\n+void vpx_idct32x32_1024_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct32x32_1024_add vpx_idct32x32_1024_add_c\n+\n+void vpx_idct32x32_1_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct32x32_1_add vpx_idct32x32_1_add_c\n+\n+void vpx_idct32x32_34_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct32x32_34_add vpx_idct32x32_34_add_c\n+\n+void vpx_idct4x4_16_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct4x4_16_add vpx_idct4x4_16_add_c\n+\n+void vpx_idct4x4_1_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct4x4_1_add vpx_idct4x4_1_add_c\n+\n+void vpx_idct8x8_12_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct8x8_12_add vpx_idct8x8_12_add_c\n+\n+void vpx_idct8x8_1_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct8x8_1_add vpx_idct8x8_1_add_c\n+\n+void vpx_idct8x8_64_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_idct8x8_64_add vpx_idct8x8_64_add_c\n+\n+void vpx_iwht4x4_16_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_iwht4x4_16_add vpx_iwht4x4_16_add_c\n+\n+void vpx_iwht4x4_1_add_c(const tran_low_t *input, uint8_t *dest, int dest_stride);\n+#define vpx_iwht4x4_1_add vpx_iwht4x4_1_add_c\n+\n+void vpx_lpf_horizontal_16_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+#define vpx_lpf_horizontal_16 vpx_lpf_horizontal_16_c\n+\n+void vpx_lpf_horizontal_4_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+#define vpx_lpf_horizontal_4 vpx_lpf_horizontal_4_c\n+\n+void vpx_lpf_horizontal_4_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n+#define vpx_lpf_horizontal_4_dual vpx_lpf_horizontal_4_dual_c\n+\n+void vpx_lpf_horizontal_8_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+#define vpx_lpf_horizontal_8 vpx_lpf_horizontal_8_c\n+\n+void vpx_lpf_horizontal_8_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n+#define vpx_lpf_horizontal_8_dual vpx_lpf_horizontal_8_dual_c\n+\n+void vpx_lpf_vertical_16_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh);\n+#define vpx_lpf_vertical_16 vpx_lpf_vertical_16_c\n+\n+void vpx_lpf_vertical_16_dual_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh);\n+#define vpx_lpf_vertical_16_dual vpx_lpf_vertical_16_dual_c\n+\n+void vpx_lpf_vertical_4_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+#define vpx_lpf_vertical_4 vpx_lpf_vertical_4_c\n+\n+void vpx_lpf_vertical_4_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n+#define vpx_lpf_vertical_4_dual vpx_lpf_vertical_4_dual_c\n+\n+void vpx_lpf_vertical_8_c(uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int count);\n+#define vpx_lpf_vertical_8 vpx_lpf_vertical_8_c\n+\n+void vpx_lpf_vertical_8_dual_c(uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1);\n+#define vpx_lpf_vertical_8_dual vpx_lpf_vertical_8_dual_c\n+\n+unsigned int vpx_mse16x16_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n+#define vpx_mse16x16 vpx_mse16x16_c\n+\n+unsigned int vpx_mse16x8_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n+#define vpx_mse16x8 vpx_mse16x8_c\n+\n+unsigned int vpx_mse8x16_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n+#define vpx_mse8x16 vpx_mse8x16_c\n+\n+unsigned int vpx_mse8x8_c(const uint8_t *src_ptr, int  source_stride, const uint8_t *ref_ptr, int  recon_stride, unsigned int *sse);\n+#define vpx_mse8x8 vpx_mse8x8_c\n+\n+void vpx_quantize_b_c(const tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+#define vpx_quantize_b vpx_quantize_b_c\n+\n+void vpx_quantize_b_32x32_c(const tran_low_t *coeff_ptr, intptr_t n_coeffs, int skip_block, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan);\n+#define vpx_quantize_b_32x32 vpx_quantize_b_32x32_c\n+\n+unsigned int vpx_sad16x16_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad16x16 vpx_sad16x16_c\n+\n+unsigned int vpx_sad16x16_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad16x16_avg vpx_sad16x16_avg_c\n+\n+void vpx_sad16x16x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x16x3 vpx_sad16x16x3_c\n+\n+void vpx_sad16x16x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x16x4d vpx_sad16x16x4d_c\n+\n+void vpx_sad16x16x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x16x8 vpx_sad16x16x8_c\n+\n+unsigned int vpx_sad16x32_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad16x32 vpx_sad16x32_c\n+\n+unsigned int vpx_sad16x32_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad16x32_avg vpx_sad16x32_avg_c\n+\n+void vpx_sad16x32x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x32x4d vpx_sad16x32x4d_c\n+\n+unsigned int vpx_sad16x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad16x8 vpx_sad16x8_c\n+\n+unsigned int vpx_sad16x8_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad16x8_avg vpx_sad16x8_avg_c\n+\n+void vpx_sad16x8x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x8x3 vpx_sad16x8x3_c\n+\n+void vpx_sad16x8x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x8x4d vpx_sad16x8x4d_c\n+\n+void vpx_sad16x8x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad16x8x8 vpx_sad16x8x8_c\n+\n+unsigned int vpx_sad32x16_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad32x16 vpx_sad32x16_c\n+\n+unsigned int vpx_sad32x16_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad32x16_avg vpx_sad32x16_avg_c\n+\n+void vpx_sad32x16x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad32x16x4d vpx_sad32x16x4d_c\n+\n+unsigned int vpx_sad32x32_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad32x32 vpx_sad32x32_c\n+\n+unsigned int vpx_sad32x32_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad32x32_avg vpx_sad32x32_avg_c\n+\n+void vpx_sad32x32x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad32x32x3 vpx_sad32x32x3_c\n+\n+void vpx_sad32x32x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad32x32x4d vpx_sad32x32x4d_c\n+\n+void vpx_sad32x32x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad32x32x8 vpx_sad32x32x8_c\n+\n+unsigned int vpx_sad32x64_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad32x64 vpx_sad32x64_c\n+\n+unsigned int vpx_sad32x64_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad32x64_avg vpx_sad32x64_avg_c\n+\n+void vpx_sad32x64x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad32x64x4d vpx_sad32x64x4d_c\n+\n+unsigned int vpx_sad4x4_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad4x4 vpx_sad4x4_c\n+\n+unsigned int vpx_sad4x4_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad4x4_avg vpx_sad4x4_avg_c\n+\n+void vpx_sad4x4x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad4x4x3 vpx_sad4x4x3_c\n+\n+void vpx_sad4x4x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad4x4x4d vpx_sad4x4x4d_c\n+\n+void vpx_sad4x4x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad4x4x8 vpx_sad4x4x8_c\n+\n+unsigned int vpx_sad4x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad4x8 vpx_sad4x8_c\n+\n+unsigned int vpx_sad4x8_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad4x8_avg vpx_sad4x8_avg_c\n+\n+void vpx_sad4x8x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad4x8x4d vpx_sad4x8x4d_c\n+\n+void vpx_sad4x8x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad4x8x8 vpx_sad4x8x8_c\n+\n+unsigned int vpx_sad64x32_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad64x32 vpx_sad64x32_c\n+\n+unsigned int vpx_sad64x32_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad64x32_avg vpx_sad64x32_avg_c\n+\n+void vpx_sad64x32x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad64x32x4d vpx_sad64x32x4d_c\n+\n+unsigned int vpx_sad64x64_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad64x64 vpx_sad64x64_c\n+\n+unsigned int vpx_sad64x64_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad64x64_avg vpx_sad64x64_avg_c\n+\n+void vpx_sad64x64x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad64x64x3 vpx_sad64x64x3_c\n+\n+void vpx_sad64x64x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad64x64x4d vpx_sad64x64x4d_c\n+\n+void vpx_sad64x64x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad64x64x8 vpx_sad64x64x8_c\n+\n+unsigned int vpx_sad8x16_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad8x16 vpx_sad8x16_c\n+\n+unsigned int vpx_sad8x16_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad8x16_avg vpx_sad8x16_avg_c\n+\n+void vpx_sad8x16x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x16x3 vpx_sad8x16x3_c\n+\n+void vpx_sad8x16x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x16x4d vpx_sad8x16x4d_c\n+\n+void vpx_sad8x16x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x16x8 vpx_sad8x16x8_c\n+\n+unsigned int vpx_sad8x4_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad8x4 vpx_sad8x4_c\n+\n+unsigned int vpx_sad8x4_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad8x4_avg vpx_sad8x4_avg_c\n+\n+void vpx_sad8x4x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x4x4d vpx_sad8x4x4d_c\n+\n+void vpx_sad8x4x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x4x8 vpx_sad8x4x8_c\n+\n+unsigned int vpx_sad8x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride);\n+#define vpx_sad8x8 vpx_sad8x8_c\n+\n+unsigned int vpx_sad8x8_avg_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred);\n+#define vpx_sad8x8_avg vpx_sad8x8_avg_c\n+\n+void vpx_sad8x8x3_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x8x3 vpx_sad8x8x3_c\n+\n+void vpx_sad8x8x4d_c(const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_ptr[], int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x8x4d vpx_sad8x8x4d_c\n+\n+void vpx_sad8x8x8_c(const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, uint32_t *sad_array);\n+#define vpx_sad8x8x8 vpx_sad8x8x8_c\n+\n+void vpx_scaled_2d_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_2d vpx_scaled_2d_c\n+\n+void vpx_scaled_avg_2d_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_avg_2d vpx_scaled_avg_2d_c\n+\n+void vpx_scaled_avg_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_avg_horiz vpx_scaled_avg_horiz_c\n+\n+void vpx_scaled_avg_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_avg_vert vpx_scaled_avg_vert_c\n+\n+void vpx_scaled_horiz_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_horiz vpx_scaled_horiz_c\n+\n+void vpx_scaled_vert_c(const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const int16_t *filter_x, int x_step_q4, const int16_t *filter_y, int y_step_q4, int w, int h);\n+#define vpx_scaled_vert vpx_scaled_vert_c\n+\n+uint32_t vpx_sub_pixel_avg_variance16x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance16x16 vpx_sub_pixel_avg_variance16x16_c\n+\n+uint32_t vpx_sub_pixel_avg_variance16x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance16x32 vpx_sub_pixel_avg_variance16x32_c\n+\n+uint32_t vpx_sub_pixel_avg_variance16x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance16x8 vpx_sub_pixel_avg_variance16x8_c\n+\n+uint32_t vpx_sub_pixel_avg_variance32x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance32x16 vpx_sub_pixel_avg_variance32x16_c\n+\n+uint32_t vpx_sub_pixel_avg_variance32x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance32x32 vpx_sub_pixel_avg_variance32x32_c\n+\n+uint32_t vpx_sub_pixel_avg_variance32x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance32x64 vpx_sub_pixel_avg_variance32x64_c\n+\n+uint32_t vpx_sub_pixel_avg_variance4x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance4x4 vpx_sub_pixel_avg_variance4x4_c\n+\n+uint32_t vpx_sub_pixel_avg_variance4x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance4x8 vpx_sub_pixel_avg_variance4x8_c\n+\n+uint32_t vpx_sub_pixel_avg_variance64x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance64x32 vpx_sub_pixel_avg_variance64x32_c\n+\n+uint32_t vpx_sub_pixel_avg_variance64x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance64x64 vpx_sub_pixel_avg_variance64x64_c\n+\n+uint32_t vpx_sub_pixel_avg_variance8x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance8x16 vpx_sub_pixel_avg_variance8x16_c\n+\n+uint32_t vpx_sub_pixel_avg_variance8x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance8x4 vpx_sub_pixel_avg_variance8x4_c\n+\n+uint32_t vpx_sub_pixel_avg_variance8x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred);\n+#define vpx_sub_pixel_avg_variance8x8 vpx_sub_pixel_avg_variance8x8_c\n+\n+uint32_t vpx_sub_pixel_variance16x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance16x16 vpx_sub_pixel_variance16x16_c\n+\n+uint32_t vpx_sub_pixel_variance16x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance16x32 vpx_sub_pixel_variance16x32_c\n+\n+uint32_t vpx_sub_pixel_variance16x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance16x8 vpx_sub_pixel_variance16x8_c\n+\n+uint32_t vpx_sub_pixel_variance32x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance32x16 vpx_sub_pixel_variance32x16_c\n+\n+uint32_t vpx_sub_pixel_variance32x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance32x32 vpx_sub_pixel_variance32x32_c\n+\n+uint32_t vpx_sub_pixel_variance32x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance32x64 vpx_sub_pixel_variance32x64_c\n+\n+uint32_t vpx_sub_pixel_variance4x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance4x4 vpx_sub_pixel_variance4x4_c\n+\n+uint32_t vpx_sub_pixel_variance4x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance4x8 vpx_sub_pixel_variance4x8_c\n+\n+uint32_t vpx_sub_pixel_variance64x32_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance64x32 vpx_sub_pixel_variance64x32_c\n+\n+uint32_t vpx_sub_pixel_variance64x64_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance64x64 vpx_sub_pixel_variance64x64_c\n+\n+uint32_t vpx_sub_pixel_variance8x16_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance8x16 vpx_sub_pixel_variance8x16_c\n+\n+uint32_t vpx_sub_pixel_variance8x4_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance8x4 vpx_sub_pixel_variance8x4_c\n+\n+uint32_t vpx_sub_pixel_variance8x8_c(const uint8_t *src_ptr, int source_stride, int xoffset, int  yoffset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse);\n+#define vpx_sub_pixel_variance8x8 vpx_sub_pixel_variance8x8_c\n+\n+void vpx_subtract_block_c(int rows, int cols, int16_t *diff_ptr, ptrdiff_t diff_stride, const uint8_t *src_ptr, ptrdiff_t src_stride, const uint8_t *pred_ptr, ptrdiff_t pred_stride);\n+#define vpx_subtract_block vpx_subtract_block_c\n+\n+void vpx_tm_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_tm_predictor_16x16 vpx_tm_predictor_16x16_c\n+\n+void vpx_tm_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_tm_predictor_32x32 vpx_tm_predictor_32x32_c\n+\n+void vpx_tm_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_tm_predictor_4x4 vpx_tm_predictor_4x4_c\n+\n+void vpx_tm_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_tm_predictor_8x8 vpx_tm_predictor_8x8_c\n+\n+void vpx_v_predictor_16x16_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_v_predictor_16x16 vpx_v_predictor_16x16_c\n+\n+void vpx_v_predictor_32x32_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_v_predictor_32x32 vpx_v_predictor_32x32_c\n+\n+void vpx_v_predictor_4x4_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_v_predictor_4x4 vpx_v_predictor_4x4_c\n+\n+void vpx_v_predictor_8x8_c(uint8_t *dst, ptrdiff_t y_stride, const uint8_t *above, const uint8_t *left);\n+#define vpx_v_predictor_8x8 vpx_v_predictor_8x8_c\n+\n+unsigned int vpx_variance16x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance16x16 vpx_variance16x16_c\n+\n+unsigned int vpx_variance16x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance16x32 vpx_variance16x32_c\n+\n+unsigned int vpx_variance16x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance16x8 vpx_variance16x8_c\n+\n+unsigned int vpx_variance32x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance32x16 vpx_variance32x16_c\n+\n+unsigned int vpx_variance32x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance32x32 vpx_variance32x32_c\n+\n+unsigned int vpx_variance32x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance32x64 vpx_variance32x64_c\n+\n+unsigned int vpx_variance4x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance4x4 vpx_variance4x4_c\n+\n+unsigned int vpx_variance4x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance4x8 vpx_variance4x8_c\n+\n+unsigned int vpx_variance64x32_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance64x32 vpx_variance64x32_c\n+\n+unsigned int vpx_variance64x64_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance64x64 vpx_variance64x64_c\n+\n+unsigned int vpx_variance8x16_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance8x16 vpx_variance8x16_c\n+\n+unsigned int vpx_variance8x4_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance8x4 vpx_variance8x4_c\n+\n+unsigned int vpx_variance8x8_c(const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse);\n+#define vpx_variance8x8 vpx_variance8x8_c\n+\n+uint32_t vpx_variance_halfpixvar16x16_h_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, uint32_t *sse);\n+#define vpx_variance_halfpixvar16x16_h vpx_variance_halfpixvar16x16_h_c\n+\n+uint32_t vpx_variance_halfpixvar16x16_hv_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, uint32_t *sse);\n+#define vpx_variance_halfpixvar16x16_hv vpx_variance_halfpixvar16x16_hv_c\n+\n+uint32_t vpx_variance_halfpixvar16x16_v_c(const unsigned char *src_ptr, int source_stride, const unsigned char *ref_ptr, int  ref_stride, uint32_t *sse);\n+#define vpx_variance_halfpixvar16x16_v vpx_variance_halfpixvar16x16_v_c\n+\n+void vpx_dsp_rtcd(void);\n+\n+#include \""vpx_config.h\""\n+\n+#ifdef RTCD_C\n+static void setup_rtcd_internal(void)\n+{\n+}\n+#endif\n+\n+#ifdef __cplusplus\n+}  // extern \""C\""\n+#endif\n+\n+#endif\n""}<_**next**_>{""filename"": ""generic/vpx_scale_rtcd.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/generic/vpx_scale_rtcd.h"", ""patch"": ""@@ -7,12 +7,12 @@\n\n #define RTCD_EXTERN extern\n #endif\n \n+struct yv12_buffer_config;\n+\n #ifdef __cplusplus\n extern \""C\"" {\n #endif\n \n-struct yv12_buffer_config;\n-\n void vp8_horizontal_line_2_1_scale_c(const unsigned char *source, unsigned int source_width, unsigned char *dest, unsigned int dest_width);\n #define vp8_horizontal_line_2_1_scale vp8_horizontal_line_2_1_scale_c\n \n@@ -40,11 +40,11 @@\n\n void vp8_yv12_extend_frame_borders_c(struct yv12_buffer_config *ybf);\n #define vp8_yv12_extend_frame_borders vp8_yv12_extend_frame_borders_c\n \n-void vp9_extend_frame_borders_c(struct yv12_buffer_config *ybf);\n-#define vp9_extend_frame_borders vp9_extend_frame_borders_c\n+void vpx_extend_frame_borders_c(struct yv12_buffer_config *ybf);\n+#define vpx_extend_frame_borders vpx_extend_frame_borders_c\n \n-void vp9_extend_frame_inner_borders_c(struct yv12_buffer_config *ybf);\n-#define vp9_extend_frame_inner_borders vp9_extend_frame_inner_borders_c\n+void vpx_extend_frame_inner_borders_c(struct yv12_buffer_config *ybf);\n+#define vpx_extend_frame_inner_borders vpx_extend_frame_inner_borders_c\n \n void vpx_yv12_copy_y_c(const struct yv12_buffer_config *src_ybc, struct yv12_buffer_config *dst_ybc);\n #define vpx_yv12_copy_y vpx_yv12_copy_y_c\n""}<_**next**_>{""filename"": ""generic/vpx_version.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/generic/vpx_version.h"", ""patch"": ""@@ -1,7 +1,7 @@\n\n #define VERSION_MAJOR  1\n-#define VERSION_MINOR  3\n+#define VERSION_MINOR  4\n #define VERSION_PATCH  0\n-#define VERSION_EXTRA  \""2239-g4fffefe\""\n+#define VERSION_EXTRA  \""\""\n #define VERSION_PACKED ((VERSION_MAJOR<<16)|(VERSION_MINOR<<8)|(VERSION_PATCH))\n-#define VERSION_STRING_NOSP \""v1.3.0-2239-g4fffefe\""\n-#define VERSION_STRING      \"" v1.3.0-2239-g4fffefe\""\n+#define VERSION_STRING_NOSP \""v1.4.0\""\n+#define VERSION_STRING      \"" v1.4.0\""\n""}<_**next**_>{""filename"": ""libvpx/.mailmap"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/.mailmap"", ""patch"": ""@@ -1,18 +1,26 @@\n\n Adrian Grange <agrange@google.com>\n+Alex Converse <aconverse@google.com> <alex.converse@gmail.com>\n Alexis Ballier <aballier@gentoo.org> <alexis.ballier@gmail.com>\n+Alpha Lam <hclam@google.com> <hclam@chromium.org>\n+Deb Mukherjee <debargha@google.com>\n+Erik Niemeyer <erik.a.niemeyer@intel.com> <erik.a.niemeyer@gmail.com>\n+Guillaume Martres <gmartres@google.com> <smarter3@gmail.com>\n Hangyu Kuang <hkuang@google.com>\n Jim Bankoski <jimbankoski@google.com>\n-John Koleszar <jkoleszar@google.com>\n Johann Koenig <johannkoenig@google.com>\n Johann Koenig <johannkoenig@google.com> <johann.koenig@duck.com>\n-Johann Koenig <johannkoenig@google.com> <johannkoenig@dhcp-172-19-7-52.mtv.corp.google.com>\n+John Koleszar <jkoleszar@google.com>\n+Joshua Litt <joshualitt@google.com> <joshualitt@chromium.org>\n+Marco Paniconi <marpan@google.com>\n+Marco Paniconi <marpan@google.com> <marpan@chromium.org>\n Pascal Massimino <pascal.massimino@gmail.com>\n+Paul Wilkins <paulwilkins@google.com>\n+Ralph Giles <giles@xiph.org> <giles@entropywave.com>\n+Ralph Giles <giles@xiph.org> <giles@mozilla.com>\n Sami Pietil\u00e4 <samipietila@google.com>\n+Tamar Levy <tamar.levy@intel.com>\n+Tamar Levy <tamar.levy@intel.com> <levytamar82@gmail.com>\n Tero Rintaluoma <teror@google.com> <tero.rintaluoma@on2.com>\n Timothy B. Terriberry <tterribe@xiph.org> Tim Terriberry <tterriberry@mozilla.com>\n Tom Finegan <tomfinegan@google.com>\n-Ralph Giles <giles@xiph.org> <giles@entropywave.com>\n-Ralph Giles <giles@xiph.org> <giles@mozilla.com>\n-Alpha Lam <hclam@google.com> <hclam@chromium.org>\n-Deb Mukherjee <debargha@google.com>\n Yaowu Xu <yaowu@google.com> <yaowu@xuyaowu.com>\n""}<_**next**_>{""filename"": ""libvpx/AUTHORS"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/AUTHORS"", ""patch"": ""@@ -3,10 +3,11 @@\n\n \n Aaron Watry <awatry@gmail.com>\n Abo Talib Mahfoodh <ab.mahfoodh@gmail.com>\n+Adam Xu <adam@xuyaowu.com>\n Adrian Grange <agrange@google.com>\n Ahmad Sharif <asharif@google.com>\n Alexander Voronov <avoronov@graphics.cs.msu.ru>\n-Alex Converse <alex.converse@gmail.com>\n+Alex Converse <aconverse@google.com>\n Alexis Ballier <aballier@gentoo.org>\n Alok Ahuja <waveletcoeff@gmail.com>\n Alpha Lam <hclam@google.com>\n@@ -14,44 +15,58 @@\n\n Ami Fischman <fischman@chromium.org>\n Andoni Morales Alastruey <ylatuya@gmail.com>\n Andres Mejia <mcitadel@gmail.com>\n+Andrew Russell <anrussell@google.com>\n Aron Rosenberg <arosenberg@logitech.com>\n Attila Nagy <attilanagy@google.com>\n changjun.yang <changjun.yang@intel.com>\n+Charles 'Buck' Krasic <ckrasic@google.com>\n chm <chm@rock-chips.com>\n Christian Duvivier <cduvivier@google.com>\n Daniel Kang <ddkang@google.com>\n Deb Mukherjee <debargha@google.com>\n+Dim Temp <dimtemp0@gmail.com>\n Dmitry Kovalev <dkovalev@google.com>\n Dragan Mrdjan <dmrdjan@mips.com>\n-Erik Niemeyer <erik.a.niemeyer@gmail.com>\n+Ehsan Akhgari <ehsan.akhgari@gmail.com>\n+Erik Niemeyer <erik.a.niemeyer@intel.com>\n Fabio Pedretti <fabio.ped@libero.it>\n Frank Galligan <fgalligan@google.com>\n Fredrik S\u00f6derquist <fs@opera.com>\n Fritz Koenig <frkoenig@google.com>\n Gaute Strokkenes <gaute.strokkenes@broadcom.com>\n Giuseppe Scrivano <gscrivano@gnu.org>\n+Gordana Cmiljanovic <gordana.cmiljanovic@imgtec.com>\n Guillaume Martres <gmartres@google.com>\n Guillermo Ballester Valor <gbvalor@gmail.com>\n Hangyu Kuang <hkuang@google.com>\n+Hanno B\u00f6ck <hanno@hboeck.de>\n Henrik Lundin <hlundin@google.com>\n Hui Su <huisu@google.com>\n Ivan Maltz <ivanmaltz@google.com>\n+Jacek Caban <cjacek@gmail.com>\n+JackyChen <jackychen@google.com>\n James Berry <jamesberry@google.com>\n+James Yu <james.yu@linaro.org>\n James Zern <jzern@google.com>\n+Jan Gerber <j@mailb.org>\n Jan Kratochvil <jan.kratochvil@redhat.com>\n Janne Salonen <jsalonen@google.com>\n Jeff Faust <jfaust@google.com>\n Jeff Muizelaar <jmuizelaar@mozilla.com>\n Jeff Petkau <jpet@chromium.org>\n+Jia Jia <jia.jia@linaro.org>\n Jim Bankoski <jimbankoski@google.com>\n Jingning Han <jingning@google.com>\n+Joey Parrish <joeyparrish@google.com>\n Johann Koenig <johannkoenig@google.com>\n John Koleszar <jkoleszar@google.com>\n+John Stark <jhnstrk@gmail.com>\n Joshua Bleecher Snyder <josh@treelinelabs.com>\n Joshua Litt <joshualitt@google.com>\n Justin Clift <justin@salasaga.org>\n Justin Lebar <justin.lebar@gmail.com>\n KO Myung-Hun <komh@chollian.net>\n+Lawrence Vel\u00e1zquez <larryv@macports.org>\n Lou Quillio <louquillio@google.com>\n Luca Barbato <lu_zero@gentoo.org>\n Makoto Kato <makoto.kt@gmail.com>\n@@ -65,6 +80,7 @@\n\n Mike Frysinger <vapier@chromium.org>\n Mike Hommey <mhommey@mozilla.com>\n Mikhal Shemer <mikhal@google.com>\n+Minghai Shang <minghai@google.com>\n Morton Jonuschat <yabawock@gmail.com>\n Parag Salasakar <img.mips1@gmail.com>\n Pascal Massimino <pascal.massimino@gmail.com>\n@@ -72,6 +88,8 @@\n\n Paul Wilkins <paulwilkins@google.com>\n Pavol Rusnak <stick@gk2.sk>\n Pawe\u0142 Hajdan <phajdan@google.com>\n+Pengchong Jin <pengchong@google.com>\n+Peter de Rivaz <peter.derivaz@gmail.com>\n Philip J\u00e4genstedt <philipj@opera.com>\n Priit Laes <plaes@plaes.org>\n Rafael \u00c1vila de Esp\u00edndola <rafael.espindola@gmail.com>\n@@ -79,22 +97,29 @@\n\n Ralph Giles <giles@xiph.org>\n Rob Bradford <rob@linux.intel.com>\n Ronald S. Bultje <rbultje@google.com>\n+Rui Ueyama <ruiu@google.com>\n Sami Pietil\u00e4 <samipietila@google.com>\n Scott Graham <scottmg@chromium.org>\n Scott LaVarnway <slavarnway@google.com>\n+Sean McGovern <gseanmcg@gmail.com>\n+Sergey Ulanov <sergeyu@chromium.org>\n Shimon Doodkin <helpmepro1@gmail.com>\n Stefan Holmer <holmer@google.com>\n Suman Sunkara <sunkaras@google.com>\n Taekhyun Kim <takim@nvidia.com>\n Takanori MATSUURA <t.matsuu@gmail.com>\n Tamar Levy <tamar.levy@intel.com>\n+Tao Bai <michaelbai@chromium.org>\n Tero Rintaluoma <teror@google.com>\n Thijs Vermeir <thijsvermeir@gmail.com>\n+Tim Kopp <tkopp@google.com>\n Timothy B. Terriberry <tterribe@xiph.org>\n Tom Finegan <tomfinegan@google.com>\n Vignesh Venkatasubramanian <vigneshv@google.com>\n Yaowu Xu <yaowu@google.com>\n+Yongzhe Wang <yongzhe@google.com>\n Yunqing Wang <yunqingwang@google.com>\n+Zoe Liu <zoeliu@google.com>\n Google Inc.\n The Mozilla Foundation\n The Xiph.Org Foundation\n""}<_**next**_>{""filename"": ""libvpx/CHANGELOG"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/CHANGELOG"", ""patch"": ""@@ -1,3 +1,31 @@\n\n+xxxx-yy-zz v1.4.0 \""Changes for next release\""\n+  vpxenc is changed to use VP9 by default.\n+  Encoder controls added for 1 pass SVC.\n+  Decoder control to toggle on/off loopfilter.\n+\n+2015-04-03 v1.4.0 \""Indian Runner Duck\""\n+  This release includes significant improvements to the VP9 codec.\n+\n+  - Upgrading:\n+    This release is ABI incompatible with 1.3.0. It drops the compatibility\n+    layer, requiring VPX_IMG_FMT_* instead of IMG_FMT_*, and adds several codec\n+    controls for VP9.\n+\n+  - Enhancements:\n+    Faster VP9 encoding and decoding\n+    Multithreaded VP9 decoding (tile and frame-based)\n+    Multithreaded VP9 encoding - on by default\n+    YUV 4:2:2 and 4:4:4 support in VP9\n+    10 and 12bit support in VP9\n+    64bit ARM support by replacing ARM assembly with intrinsics\n+\n+  - Bug Fixes:\n+    Fixes a VP9 bitstream issue in Profile 1. This only affected non-YUV 4:2:0\n+    files.\n+\n+  - Known Issues:\n+    Frame Parallel decoding fails for segmented and non-420 files.\n+\n 2013-11-15 v1.3.0 \""Forest\""\n   This release introduces the VP9 codec in a backward-compatible way.\n   All existing users of VP8 can continue to use the library without\n""}<_**next**_>{""filename"": ""libvpx/PATENTS"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/PATENTS"", ""patch"": ""@@ -1,22 +1,23 @@\n\n Additional IP Rights Grant (Patents)\n+------------------------------------\n \n-\""This implementation\"" means the copyrightable works distributed by\n-Google as part of the WebM Project.\n+\""These implementations\"" means the copyrightable works that implement the WebM\n+codecs distributed by Google as part of the WebM Project.\n \n-Google hereby grants to you a perpetual, worldwide, non-exclusive,\n-no-charge, royalty-free, irrevocable (except as stated in this section)\n-patent license to make, have made, use, offer to sell, sell, import,\n-transfer, and otherwise run, modify and propagate the contents of this\n-implementation of VP8, where such license applies only to those patent\n-claims, both currently owned by Google and acquired in the future,\n-licensable by Google that are necessarily infringed by this\n-implementation of VP8. This grant does not include claims that would be\n-infringed only as a consequence of further modification of this\n-implementation. If you or your agent or exclusive licensee institute or\n-order or agree to the institution of patent litigation against any\n-entity (including a cross-claim or counterclaim in a lawsuit) alleging\n-that this implementation of VP8 or any code incorporated within this\n-implementation of VP8 constitutes direct or contributory patent\n-infringement, or inducement of patent infringement, then any patent\n-rights granted to you under this License for this implementation of VP8\n-shall terminate as of the date such litigation is filed.\n+Google hereby grants to you a perpetual, worldwide, non-exclusive, no-charge,\n+royalty-free, irrevocable (except as stated in this section) patent license to\n+make, have made, use, offer to sell, sell, import, transfer, and otherwise\n+run, modify and propagate the contents of these implementations of WebM, where\n+such license applies only to those patent claims, both currently owned by\n+Google and acquired in the future, licensable by Google that are necessarily\n+infringed by these implementations of WebM. This grant does not include claims\n+that would be infringed only as a consequence of further modification of these\n+implementations. If you or your agent or exclusive licensee institute or order\n+or agree to the institution of patent litigation or any other patent\n+enforcement activity against any entity (including a cross-claim or\n+counterclaim in a lawsuit) alleging that any of these implementations of WebM\n+or any code incorporated within any of these implementations of WebM\n+constitute direct or contributory patent infringement, or inducement of\n+patent infringement, then any patent rights granted to you under this License\n+for these implementations of WebM shall terminate as of the date such\n+litigation is filed.\n""}<_**next**_>{""filename"": ""libvpx/README"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/README"", ""patch"": ""@@ -1,5 +1,4 @@\n\n-vpx Multi-Format Codec SDK\n-README - 1 August 2013\n+README - 23 March 2015\n \n Welcome to the WebM VP8/VP9 Codec SDK!\n \n@@ -12,22 +11,20 @@\n\n \n     * All x86 targets require the Yasm[1] assembler be installed.\n     * All Windows builds require that Cygwin[2] be installed.\n-    * Building the documentation requires PHP[3] and Doxygen[4]. If you do not\n-      have these packages, you must pass --disable-install-docs to the\n-      configure script.\n-    * Downloading the data for the unit tests requires curl[5] and sha1sum.\n+    * Building the documentation requires Doxygen[3]. If you do not\n+      have this package, the install-docs option will be disabled.\n+    * Downloading the data for the unit tests requires curl[4] and sha1sum.\n       sha1sum is provided via the GNU coreutils, installed by default on\n       many *nix platforms, as well as MinGW and Cygwin. If coreutils is not\n       available, a compatible version of sha1sum can be built from\n-      source[6]. These requirements are optional if not running the unit\n+      source[5]. These requirements are optional if not running the unit\n       tests.\n \n     [1]: http://www.tortall.net/projects/yasm\n     [2]: http://www.cygwin.com\n-    [3]: http://php.net\n-    [4]: http://www.doxygen.org\n-    [5]: http://curl.haxx.se\n-    [6]: http://www.microbrew.org/tools/md5sha1sum/\n+    [3]: http://www.doxygen.org\n+    [4]: http://curl.haxx.se\n+    [5]: http://www.microbrew.org/tools/md5sha1sum/\n \n   2. Out-of-tree builds\n   Out of tree builds are a supported method of building the application. For\n@@ -50,14 +47,11 @@\n\n   --help output of the configure script. As of this writing, the list of\n   available targets is:\n \n-    armv5te-android-gcc\n-    armv5te-linux-rvct\n-    armv5te-linux-gcc\n-    armv5te-none-rvct\n     armv6-darwin-gcc\n     armv6-linux-rvct\n     armv6-linux-gcc\n     armv6-none-rvct\n+    arm64-darwin-gcc\n     armv7-android-gcc\n     armv7-darwin-gcc\n     armv7-linux-rvct\n@@ -65,13 +59,10 @@\n\n     armv7-none-rvct\n     armv7-win32-vs11\n     armv7-win32-vs12\n+    armv7-win32-vs14\n+    armv7s-darwin-gcc\n     mips32-linux-gcc\n-    ppc32-darwin8-gcc\n-    ppc32-darwin9-gcc\n-    ppc32-linux-gcc\n-    ppc64-darwin8-gcc\n-    ppc64-darwin9-gcc\n-    ppc64-linux-gcc\n+    mips64-linux-gcc\n     sparc-solaris-gcc\n     x86-android-gcc\n     x86-darwin8-gcc\n@@ -82,6 +73,8 @@\n\n     x86-darwin11-gcc\n     x86-darwin12-gcc\n     x86-darwin13-gcc\n+    x86-darwin14-gcc\n+    x86-iphonesimulator-gcc\n     x86-linux-gcc\n     x86-linux-icc\n     x86-os2-gcc\n@@ -93,11 +86,15 @@\n\n     x86-win32-vs10\n     x86-win32-vs11\n     x86-win32-vs12\n+    x86-win32-vs14\n+    x86_64-android-gcc\n     x86_64-darwin9-gcc\n     x86_64-darwin10-gcc\n     x86_64-darwin11-gcc\n     x86_64-darwin12-gcc\n     x86_64-darwin13-gcc\n+    x86_64-darwin14-gcc\n+    x86_64-iphonesimulator-gcc\n     x86_64-linux-gcc\n     x86_64-linux-icc\n     x86_64-solaris-gcc\n@@ -107,12 +104,7 @@\n\n     x86_64-win64-vs10\n     x86_64-win64-vs11\n     x86_64-win64-vs12\n-    universal-darwin8-gcc\n-    universal-darwin9-gcc\n-    universal-darwin10-gcc\n-    universal-darwin11-gcc\n-    universal-darwin12-gcc\n-    universal-darwin13-gcc\n+    x86_64-win64-vs14\n     generic-gnu\n \n   The generic-gnu target, in conjunction with the CROSS environment variable,\n@@ -133,6 +125,14 @@\n\n   This defaults to config.log. This should give a good indication of what went\n   wrong. If not, contact us for support.\n \n+VP8/VP9 TEST VECTORS:\n+  The test vectors can be downloaded and verified using the build system after\n+  running configure. To specify an alternate directory the\n+  LIBVPX_TEST_DATA_PATH environment variable can be used.\n+\n+  $ ./configure --enable-unit-tests\n+  $ LIBVPX_TEST_DATA_PATH=../libvpx-test-data make testdata\n+\n SUPPORT\n   This library is an open source project supported by its community. Please\n   please email webm-discuss@webmproject.org for help.\n""}<_**next**_>{""filename"": ""libvpx/args.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/args.c"", ""patch"": ""@@ -14,9 +14,7 @@\n\n #include <limits.h>\n #include \""args.h\""\n \n-#ifdef _MSC_VER\n-#define snprintf _snprintf\n-#endif\n+#include \""vpx_ports/msvc.h\""\n \n #if defined(__GNUC__) && __GNUC__\n extern void die(const char *fmt, ...) __attribute__((noreturn));\n""}<_**next**_>{""filename"": ""libvpx/args.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/args.h"", ""patch"": ""@@ -51,6 +51,7 @@\n\n unsigned int arg_parse_uint(const struct arg *arg);\n int arg_parse_int(const struct arg *arg);\n struct vpx_rational arg_parse_rational(const struct arg *arg);\n+int arg_parse_enum(const struct arg *arg);\n int arg_parse_enum_or_int(const struct arg *arg);\n #ifdef __cplusplus\n }  // extern \""C\""\n""}<_**next**_>{""filename"": ""libvpx/build/make/Android.mk"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/build/make/Android.mk"", ""patch"": ""@@ -38,11 +38,12 @@\n\n # For this we import the 'cpufeatures' module from the NDK sources.\n # libvpx can also be configured without this runtime detection method.\n # Configuring with --disable-runtime-cpu-detect will assume presence of NEON.\n-# Configuring with --disable-runtime-cpu-detect --disable-neon will remove any\n-# NEON dependency.\n+# Configuring with --disable-runtime-cpu-detect --disable-neon \\\n+#     --disable-neon-asm\n+# will remove any NEON dependency.\n \n # To change to building armeabi, run ./libvpx/configure again, but with\n-# --target=arm5te-android-gcc and modify the Application.mk file to\n+# --target=armv6-android-gcc and modify the Application.mk file to\n # set APP_ABI := armeabi\n #\n # Running ndk-build will build libvpx and include it in your project.\n@@ -53,12 +54,25 @@\n\n ASM_CNV_PATH_LOCAL := $(TARGET_ARCH_ABI)/ads2gas\n ASM_CNV_PATH := $(LOCAL_PATH)/$(ASM_CNV_PATH_LOCAL)\n \n-# Makefiles created by the libvpx configure process\n-# This will need to be fixed to handle x86.\n+# Use the makefiles generated by upstream configure to determine which files to\n+# build. Also set any architecture-specific flags.\n ifeq ($(TARGET_ARCH_ABI),armeabi-v7a)\n   include $(CONFIG_DIR)libs-armv7-android-gcc.mk\n+  LOCAL_ARM_MODE := arm\n+else ifeq  ($(TARGET_ARCH_ABI),armeabi)\n+  include $(CONFIG_DIR)libs-armv6-android-gcc.mk\n+  LOCAL_ARM_MODE := arm\n+else ifeq  ($(TARGET_ARCH_ABI),arm64-v8a)\n+  include $(CONFIG_DIR)libs-armv8-android-gcc.mk\n+  LOCAL_ARM_MODE := arm\n+else ifeq ($(TARGET_ARCH_ABI),x86)\n+  include $(CONFIG_DIR)libs-x86-android-gcc.mk\n+else ifeq ($(TARGET_ARCH_ABI),x86_64)\n+  include $(CONFIG_DIR)libs-x86_64-android-gcc.mk\n+else ifeq ($(TARGET_ARCH_ABI),mips)\n+  include $(CONFIG_DIR)libs-mips-android-gcc.mk\n else\n-  include $(CONFIG_DIR)libs-armv5te-android-gcc.mk\n+  $(error Not a supported TARGET_ARCH_ABI: $(TARGET_ARCH_ABI))\n endif\n \n # Rule that is normally in Makefile created by libvpx\n@@ -72,55 +86,15 @@\n\n # Include the list of files to be built\n include $(LIBVPX_PATH)/libs.mk\n \n-# Want arm, not thumb, optimized\n-LOCAL_ARM_MODE := arm\n+# Optimise the code. May want to revisit this setting in the future.\n LOCAL_CFLAGS := -O3\n \n-# -----------------------------------------------------------------------------\n-# Template  : asm_offsets_template\n-# Arguments : 1: assembly offsets file to be created\n-#             2: c file to base assembly offsets on\n-# Returns   : None\n-# Usage     : $(eval $(call asm_offsets_template,<asmfile>, <srcfile>\n-# Rationale : Create offsets at compile time using for structures that are\n-#             defined in c, but used in assembly functions.\n-# -----------------------------------------------------------------------------\n-define asm_offsets_template\n-\n-_SRC:=$(2)\n-_OBJ:=$(ASM_CNV_PATH)/$$(notdir $(2)).S\n-\n-_FLAGS = $$($$(my)CFLAGS) \\\n-          $$(call get-src-file-target-cflags,$(2)) \\\n-          $$(call host-c-includes,$$(LOCAL_C_INCLUDES) $$(CONFIG_DIR)) \\\n-          $$(LOCAL_CFLAGS) \\\n-          $$(NDK_APP_CFLAGS) \\\n-          $$(call host-c-includes,$$($(my)C_INCLUDES)) \\\n-          -DINLINE_ASM \\\n-          -S \\\n-\n-_TEXT = \""Compile $$(call get-src-file-text,$(2))\""\n-_CC   = $$(TARGET_CC)\n-\n-$$(eval $$(call ev-build-file))\n-\n-$(1) : $$(_OBJ) $(2)\n-\t@mkdir -p $$(dir $$@)\n-\t@grep $(OFFSET_PATTERN) $$< | tr -d '\\#' | $(CONFIG_DIR)$(ASM_CONVERSION) > $$@\n-endef\n-\n-# Use ads2gas script to convert from RVCT format to GAS format.  This passes\n-#  puts the processed file under $(ASM_CNV_PATH).  Local clean rule\n-#  to handle removing these\n-ifeq ($(CONFIG_VP8_ENCODER), yes)\n-  ASM_CNV_OFFSETS_DEPEND += $(ASM_CNV_PATH)/vp8_asm_enc_offsets.asm\n-endif\n-ifeq ($(HAVE_NEON), yes)\n-  ASM_CNV_OFFSETS_DEPEND += $(ASM_CNV_PATH)/vpx_scale_asm_offsets.asm\n-endif\n+# For x86, include the source code in the search path so it will find files\n+# like x86inc.asm and x86_abi_support.asm\n+LOCAL_ASMFLAGS := -I$(LIBVPX_PATH)\n \n .PRECIOUS: %.asm.s\n-$(ASM_CNV_PATH)/libvpx/%.asm.s: $(LIBVPX_PATH)/%.asm $(ASM_CNV_OFFSETS_DEPEND)\n+$(ASM_CNV_PATH)/libvpx/%.asm.s: $(LIBVPX_PATH)/%.asm\n \t@mkdir -p $(dir $@)\n \t@$(CONFIG_DIR)$(ASM_CONVERSION) <$< > $@\n \n@@ -142,22 +116,34 @@\n\n LOCAL_CODEC_SRCS_C = $(filter-out vpx_config.c %_neon.c, $(CODEC_SRCS_C))\n \n LOCAL_SRC_FILES += $(foreach file, $(LOCAL_CODEC_SRCS_C), libvpx/$(file))\n-LOCAL_SRC_FILES += $(foreach file, $(LOCAL_NEON_SRCS_C), libvpx/$(file).neon)\n+ifeq ($(TARGET_ARCH_ABI),armeabi-v7a)\n+  LOCAL_SRC_FILES += $(foreach file, $(LOCAL_NEON_SRCS_C), libvpx/$(file).neon)\n+else # If there are neon sources then we are building for arm64 and do not need to specify .neon\n+  LOCAL_SRC_FILES += $(foreach file, $(LOCAL_NEON_SRCS_C), libvpx/$(file))\n+endif\n \n # Pull out assembly files, splitting NEON from the rest.  This is\n # done to specify that the NEON assembly files use NEON assembler flags.\n-CODEC_SRCS_ASM_ALL = $(filter %.asm.s, $(CODEC_SRCS_UNIQUE))\n-CODEC_SRCS_ASM = $(foreach v, \\\n-                 $(CODEC_SRCS_ASM_ALL), \\\n-                 $(if $(findstring neon,$(v)),,$(v)))\n+# x86 assembly matches %.asm, arm matches %.asm.s\n+\n+# x86:\n+\n+CODEC_SRCS_ASM_X86 = $(filter %.asm, $(CODEC_SRCS_UNIQUE))\n+LOCAL_SRC_FILES += $(foreach file, $(CODEC_SRCS_ASM_X86), libvpx/$(file))\n+\n+# arm:\n+CODEC_SRCS_ASM_ARM_ALL = $(filter %.asm.s, $(CODEC_SRCS_UNIQUE))\n+CODEC_SRCS_ASM_ARM = $(foreach v, \\\n+                     $(CODEC_SRCS_ASM_ARM_ALL), \\\n+                     $(if $(findstring neon,$(v)),,$(v)))\n CODEC_SRCS_ASM_ADS2GAS = $(patsubst %.s, \\\n                          $(ASM_CNV_PATH_LOCAL)/libvpx/%.s, \\\n-                         $(CODEC_SRCS_ASM))\n+                         $(CODEC_SRCS_ASM_ARM))\n LOCAL_SRC_FILES += $(CODEC_SRCS_ASM_ADS2GAS)\n \n ifeq ($(TARGET_ARCH_ABI),armeabi-v7a)\n   CODEC_SRCS_ASM_NEON = $(foreach v, \\\n-                        $(CODEC_SRCS_ASM_ALL),\\\n+                        $(CODEC_SRCS_ASM_ARM_ALL),\\\n                         $(if $(findstring neon,$(v)),$(v),))\n   CODEC_SRCS_ASM_NEON_ADS2GAS = $(patsubst %.s, \\\n                                 $(ASM_CNV_PATH_LOCAL)/libvpx/%.s, \\\n@@ -174,41 +160,44 @@\n\n \n LOCAL_MODULE := libvpx\n \n-LOCAL_LDLIBS := -llog\n-\n ifeq ($(CONFIG_RUNTIME_CPU_DETECT),yes)\n   LOCAL_STATIC_LIBRARIES := cpufeatures\n endif\n \n # Add a dependency to force generation of the RTCD files.\n+define rtcd_dep_template\n+rtcd_dep_template_SRCS := $(addprefix $(LOCAL_PATH)/, $(LOCAL_SRC_FILES))\n+rtcd_dep_template_SRCS := $$(rtcd_dep_template_SRCS:.neon=)\n ifeq ($(CONFIG_VP8), yes)\n-$(foreach file, $(LOCAL_SRC_FILES), $(LOCAL_PATH)/$(file)): vp8_rtcd.h\n+$$(rtcd_dep_template_SRCS): vp8_rtcd.h\n endif\n ifeq ($(CONFIG_VP9), yes)\n-$(foreach file, $(LOCAL_SRC_FILES), $(LOCAL_PATH)/$(file)): vp9_rtcd.h\n+$$(rtcd_dep_template_SRCS): vp9_rtcd.h\n endif\n-$(foreach file, $(LOCAL_SRC_FILES), $(LOCAL_PATH)/$(file)): vpx_scale_rtcd.h\n+ifeq ($(CONFIG_VP10), yes)\n+$$(rtcd_dep_template_SRCS): vp10_rtcd.h\n+endif\n+$$(rtcd_dep_template_SRCS): vpx_scale_rtcd.h\n+$$(rtcd_dep_template_SRCS): vpx_dsp_rtcd.h\n+\n+ifneq ($(findstring $(TARGET_ARCH_ABI),x86 x86_64),)\n+$$(rtcd_dep_template_SRCS): vpx_config.asm\n+endif\n+endef\n+\n+$(eval $(call rtcd_dep_template))\n \n .PHONY: clean\n clean:\n \t@echo \""Clean: ads2gas files [$(TARGET_ARCH_ABI)]\""\n \t@$(RM) $(CODEC_SRCS_ASM_ADS2GAS) $(CODEC_SRCS_ASM_NEON_ADS2GAS)\n-\t@$(RM) $(patsubst %.asm, %.*, $(ASM_CNV_OFFSETS_DEPEND))\n \t@$(RM) -r $(ASM_CNV_PATH)\n \t@$(RM) $(CLEAN-OBJS)\n \n-include $(BUILD_SHARED_LIBRARY)\n-\n-ifeq ($(HAVE_NEON), yes)\n-  $(eval $(call asm_offsets_template,\\\n-    $(ASM_CNV_PATH)/vpx_scale_asm_offsets.asm, \\\n-    $(LIBVPX_PATH)/vpx_scale/vpx_scale_asm_offsets.c))\n-endif\n-\n-ifeq ($(CONFIG_VP8_ENCODER), yes)\n-  $(eval $(call asm_offsets_template,\\\n-    $(ASM_CNV_PATH)/vp8_asm_enc_offsets.asm, \\\n-    $(LIBVPX_PATH)/vp8/encoder/vp8_asm_enc_offsets.c))\n+ifeq ($(ENABLE_SHARED),1)\n+  include $(BUILD_SHARED_LIBRARY)\n+else\n+  include $(BUILD_STATIC_LIBRARY)\n endif\n \n ifeq ($(CONFIG_RUNTIME_CPU_DETECT),yes)\n""}<_**next**_>{""filename"": ""libvpx/build/make/Makefile"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/build/make/Makefile"", ""patch"": ""@@ -19,9 +19,13 @@\n\n         done\n all: .DEFAULT\n clean:: .DEFAULT\n+exampletest: .DEFAULT\n install:: .DEFAULT\n test:: .DEFAULT\n+test-no-data-check:: .DEFAULT\n testdata:: .DEFAULT\n+utiltest: .DEFAULT\n+exampletest-no-data-check utiltest-no-data-check: .DEFAULT\n \n \n # Note: md5sum is not installed on OS X, but openssl is. Openssl may not be\n@@ -52,17 +56,12 @@\n\n                 | sed -e 's/MD5(\\(.*\\))= \\([0-9a-f]\\{32\\}\\)/\\2  \\1/' \\\n                 > md5sums.txt;\\\n         fi\n-\n-\n endif\n \n+# Since we invoke make recursively for multiple targets we need to include the\n+# .mk file for the correct target, but only when $(target) is non-empty.\n ifneq ($(target),)\n-# Normally, we want to build the filename from the target and the toolchain.\n-# This disambiguates from the $(target).mk file that exists in the source tree.\n-# However, the toolchain is part of the target in universal builds, so we\n-# don't want to include TOOLCHAIN in that case. FAT_ARCHS is used to test\n-# if we're in the universal case.\n-include $(target)$(if $(FAT_ARCHS),,-$(TOOLCHAIN)).mk\n+include $(target)-$(TOOLCHAIN).mk\n endif\n BUILD_ROOT?=.\n VPATH=$(SRC_PATH_BARE)\n@@ -106,28 +105,41 @@\n\n \n .PHONY: dist\n dist:\n+.PHONY: exampletest\n+exampletest:\n .PHONY: install\n install::\n .PHONY: test\n test::\n .PHONY: testdata\n testdata::\n+.PHONY: utiltest\n+utiltest:\n+.PHONY: test-no-data-check exampletest-no-data-check utiltest-no-data-check\n+test-no-data-check::\n+exampletest-no-data-check utiltest-no-data-check:\n \n # Add compiler flags for intrinsic files\n+ifeq ($(TOOLCHAIN), x86-os2-gcc)\n+STACKREALIGN=-mstackrealign\n+else\n+STACKREALIGN=\n+endif\n+\n $(BUILD_PFX)%_mmx.c.d: CFLAGS += -mmmx\n $(BUILD_PFX)%_mmx.c.o: CFLAGS += -mmmx\n-$(BUILD_PFX)%_sse2.c.d: CFLAGS += -msse2\n-$(BUILD_PFX)%_sse2.c.o: CFLAGS += -msse2\n-$(BUILD_PFX)%_sse3.c.d: CFLAGS += -msse3\n-$(BUILD_PFX)%_sse3.c.o: CFLAGS += -msse3\n-$(BUILD_PFX)%_ssse3.c.d: CFLAGS += -mssse3\n-$(BUILD_PFX)%_ssse3.c.o: CFLAGS += -mssse3\n-$(BUILD_PFX)%_sse4.c.d: CFLAGS += -msse4.1\n-$(BUILD_PFX)%_sse4.c.o: CFLAGS += -msse4.1\n-$(BUILD_PFX)%_avx.c.d: CFLAGS += -mavx\n-$(BUILD_PFX)%_avx.c.o: CFLAGS += -mavx\n-$(BUILD_PFX)%_avx2.c.d: CFLAGS += -mavx2\n-$(BUILD_PFX)%_avx2.c.o: CFLAGS += -mavx2\n+$(BUILD_PFX)%_sse2.c.d: CFLAGS += -msse2 $(STACKREALIGN)\n+$(BUILD_PFX)%_sse2.c.o: CFLAGS += -msse2 $(STACKREALIGN)\n+$(BUILD_PFX)%_sse3.c.d: CFLAGS += -msse3 $(STACKREALIGN)\n+$(BUILD_PFX)%_sse3.c.o: CFLAGS += -msse3 $(STACKREALIGN)\n+$(BUILD_PFX)%_ssse3.c.d: CFLAGS += -mssse3 $(STACKREALIGN)\n+$(BUILD_PFX)%_ssse3.c.o: CFLAGS += -mssse3 $(STACKREALIGN)\n+$(BUILD_PFX)%_sse4.c.d: CFLAGS += -msse4.1 $(STACKREALIGN)\n+$(BUILD_PFX)%_sse4.c.o: CFLAGS += -msse4.1 $(STACKREALIGN)\n+$(BUILD_PFX)%_avx.c.d: CFLAGS += -mavx $(STACKREALIGN)\n+$(BUILD_PFX)%_avx.c.o: CFLAGS += -mavx $(STACKREALIGN)\n+$(BUILD_PFX)%_avx2.c.d: CFLAGS += -mavx2 $(STACKREALIGN)\n+$(BUILD_PFX)%_avx2.c.o: CFLAGS += -mavx2 $(STACKREALIGN)\n \n $(BUILD_PFX)%.c.d: %.c\n \t$(if $(quiet),@echo \""    [DEP] $@\"")\n@@ -136,6 +148,7 @@\n\n \n $(BUILD_PFX)%.c.o: %.c\n \t$(if $(quiet),@echo \""    [CC] $@\"")\n+\t$(qexec)$(if $(CONFIG_DEPENDENCY_TRACKING),,mkdir -p $(dir $@))\n \t$(qexec)$(CC) $(INTERNAL_CFLAGS) $(CFLAGS) -c -o $@ $<\n \n $(BUILD_PFX)%.cc.d: %.cc\n@@ -145,6 +158,17 @@\n\n \n $(BUILD_PFX)%.cc.o: %.cc\n \t$(if $(quiet),@echo \""    [CXX] $@\"")\n+\t$(qexec)$(if $(CONFIG_DEPENDENCY_TRACKING),,mkdir -p $(dir $@))\n+\t$(qexec)$(CXX) $(INTERNAL_CFLAGS) $(CXXFLAGS) -c -o $@ $<\n+\n+$(BUILD_PFX)%.cpp.d: %.cpp\n+\t$(if $(quiet),@echo \""    [DEP] $@\"")\n+\t$(qexec)mkdir -p $(dir $@)\n+\t$(qexec)$(CXX) $(INTERNAL_CFLAGS) $(CXXFLAGS) -M $< | $(fmt_deps) > $@\n+\n+$(BUILD_PFX)%.cpp.o: %.cpp\n+\t$(if $(quiet),@echo \""    [CXX] $@\"")\n+\t$(qexec)$(if $(CONFIG_DEPENDENCY_TRACKING),,mkdir -p $(dir $@))\n \t$(qexec)$(CXX) $(INTERNAL_CFLAGS) $(CXXFLAGS) -c -o $@ $<\n \n $(BUILD_PFX)%.asm.d: %.asm\n@@ -155,6 +179,7 @@\n\n \n $(BUILD_PFX)%.asm.o: %.asm\n \t$(if $(quiet),@echo \""    [AS] $@\"")\n+\t$(qexec)$(if $(CONFIG_DEPENDENCY_TRACKING),,mkdir -p $(dir $@))\n \t$(qexec)$(AS) $(ASFLAGS) -o $@ $<\n \n $(BUILD_PFX)%.s.d: %.s\n@@ -165,12 +190,14 @@\n\n \n $(BUILD_PFX)%.s.o: %.s\n \t$(if $(quiet),@echo \""    [AS] $@\"")\n+\t$(qexec)$(if $(CONFIG_DEPENDENCY_TRACKING),,mkdir -p $(dir $@))\n \t$(qexec)$(AS) $(ASFLAGS) -o $@ $<\n \n .PRECIOUS: %.c.S\n %.c.S: CFLAGS += -DINLINE_ASM\n $(BUILD_PFX)%.c.S: %.c\n \t$(if $(quiet),@echo \""    [GEN] $@\"")\n+\t$(qexec)$(if $(CONFIG_DEPENDENCY_TRACKING),,mkdir -p $(dir $@))\n \t$(qexec)$(CC) -S $(CFLAGS) -o $@ $<\n \n .PRECIOUS: %.asm.s\n@@ -183,13 +210,13 @@\n\n # the copy implementation\n HAVE_GNU_STRIP := $(if $(CONFIG_DEBUG),,$(HAVE_GNU_STRIP))\n ifeq ($(HAVE_GNU_STRIP),yes)\n-# Older binutils strip global sybols not needed for relocation processing\n-# when given --strip-unneeded. Use nm and awk to identify globals and\n-# keep them.\n+# Older binutils strip global symbols not needed for relocation processing\n+# when given --strip-unneeded. Using nm and awk to identify globals and\n+# keep them caused command line length issues under mingw and segfaults in\n+# test_libvpx were observed under OS/2: simply use --strip-debug.\n %.a: %_g.a\n \t$(if $(quiet),@echo \""    [STRIP] $@ < $<\"")\n-\t$(qexec)$(STRIP) --strip-unneeded \\\n-         `$(NM) $< | grep ' [A-TV-Z] ' | awk '{print \""-K\""$$3'}`\\\n+\t$(qexec)$(STRIP) --strip-debug \\\n           -o $@ $<\n else\n %.a: %_g.a\n@@ -198,14 +225,6 @@\n\n endif\n \n #\n-# Rule to extract assembly constants from C sources\n-#\n-obj_int_extract: build/make/obj_int_extract.c\n-\t$(if $(quiet),@echo \""    [HOSTCC] $@\"")\n-\t$(qexec)$(HOSTCC) -I. -I$(SRC_PATH_BARE) -o $@ $<\n-CLEAN-OBJS += obj_int_extract\n-\n-#\n # Utility functions\n #\n pairmap=$(if $(strip $(2)),\\\n@@ -218,7 +237,7 @@\n\n \n find_file1=$(word 1,$(wildcard $(subst //,/,$(addsuffix /$(1),$(2)))))\n find_file=$(foreach f,$(1),$(call find_file1,$(strip $(f)),$(strip $(2))) )\n-obj_pats=.c=.c.o $(AS_SFX)=$(AS_SFX).o .cc=.cc.o\n+obj_pats=.c=.c.o $(AS_SFX)=$(AS_SFX).o .cc=.cc.o .cpp=.cpp.o\n objs=$(addprefix $(BUILD_PFX),$(foreach p,$(obj_pats),$(filter %.o,$(1:$(p))) ))\n \n install_map_templates=$(eval $(call install_map_template,$(1),$(2)))\n@@ -296,18 +315,15 @@\n\n         $$(filter %.o,$$^) $$(extralibs)\n endef\n \n-\n-\n-define lipo_lib_template\n-$(1): $(addsuffix /$(1),$(FAT_ARCHS))\n-\t$(if $(quiet),@echo \""    [LIPO] $$@\"")\n-\t$(qexec)libtool -static -o $$@ $$?\n-endef\n-\n-define lipo_bin_template\n-$(1): $(addsuffix /$(1),$(FAT_ARCHS))\n-\t$(if $(quiet),@echo \""    [LIPO] $$@\"")\n-\t$(qexec)lipo -output $$@ -create $$?\n+define dll_template\n+# Not using a pattern rule here because we don't want to generate empty\n+# archives when they are listed as a dependency in files not responsible\n+# for creating them.\n+$(1):\n+\t$(if $(quiet),@echo \""    [LD] $$@\"")\n+\t$(qexec)$$(LD) -Zdll $$(LDFLAGS) \\\n+        -o $$@ \\\n+        $$(filter %.o,$$^) $$(extralibs) $$(EXPORTS_FILE)\n endef\n \n \n@@ -317,10 +333,15 @@\n\n ifneq ($(target),)\n include $(SRC_PATH_BARE)/$(target:-$(TOOLCHAIN)=).mk\n endif\n-ifeq ($(filter %clean,$(MAKECMDGOALS)),)\n-  # Older versions of make don't like -include directives with no arguments\n-  ifneq ($(filter %.d,$(OBJS-yes:.o=.d)),)\n-    -include $(filter %.d,$(OBJS-yes:.o=.d))\n+\n+skip_deps := $(filter %clean,$(MAKECMDGOALS))\n+skip_deps += $(findstring testdata,$(MAKECMDGOALS))\n+ifeq ($(strip $(skip_deps)),)\n+  ifeq ($(CONFIG_DEPENDENCY_TRACKING),yes)\n+    # Older versions of make don't like -include directives with no arguments\n+    ifneq ($(filter %.d,$(OBJS-yes:.o=.d)),)\n+      -include $(filter %.d,$(OBJS-yes:.o=.d))\n+    endif\n   endif\n endif\n \n@@ -361,8 +382,9 @@\n\n .libs: $(LIBS)\n \t@touch $@\n $(foreach lib,$(filter %_g.a,$(LIBS)),$(eval $(call archive_template,$(lib))))\n-$(foreach lib,$(filter %so.$(VERSION_MAJOR).$(VERSION_MINOR).$(VERSION_PATCH),$(LIBS)),$(eval $(call so_template,$(lib))))\n-$(foreach lib,$(filter %$(VERSION_MAJOR).dylib,$(LIBS)),$(eval $(call dl_template,$(lib))))\n+$(foreach lib,$(filter %so.$(SO_VERSION_MAJOR).$(SO_VERSION_MINOR).$(SO_VERSION_PATCH),$(LIBS)),$(eval $(call so_template,$(lib))))\n+$(foreach lib,$(filter %$(SO_VERSION_MAJOR).dylib,$(LIBS)),$(eval $(call dl_template,$(lib))))\n+$(foreach lib,$(filter %$(SO_VERSION_MAJOR).dll,$(LIBS)),$(eval $(call dll_template,$(lib))))\n \n INSTALL-LIBS=$(call cond_enabled,CONFIG_INSTALL_LIBS,INSTALL-LIBS)\n ifeq ($(MAKECMDGOALS),dist)\n@@ -401,11 +423,8 @@\n\n     DIST-SRCS-$(CONFIG_MSVS)  += build/make/gen_msvs_proj.sh\n     DIST-SRCS-$(CONFIG_MSVS)  += build/make/gen_msvs_sln.sh\n     DIST-SRCS-$(CONFIG_MSVS)  += build/make/gen_msvs_vcxproj.sh\n-    DIST-SRCS-$(CONFIG_MSVS)  += build/x86-msvs/obj_int_extract.bat\n-    DIST-SRCS-$(CONFIG_MSVS)  += build/arm-msvs/obj_int_extract.bat\n+    DIST-SRCS-$(CONFIG_MSVS)  += build/make/msvs_common.sh\n     DIST-SRCS-$(CONFIG_RVCT) += build/make/armlink_adapter.sh\n-    # Include obj_int_extract if we use offsets from *_asm_*_offsets\n-    DIST-SRCS-$(ARCH_ARM)$(ARCH_X86)$(ARCH_X86_64)    += build/make/obj_int_extract.c\n     DIST-SRCS-$(ARCH_ARM)    += build/make/ads2gas.pl\n     DIST-SRCS-$(ARCH_ARM)    += build/make/ads2gas_apple.pl\n     DIST-SRCS-$(ARCH_ARM)    += build/make/ads2armasm_ms.pl\n""}<_**next**_>{""filename"": ""libvpx/build/make/configure.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/build/make/configure.sh"", ""patch"": ""@@ -14,62 +14,56 @@\n\n # Logging / Output Functions\n #\n die_unknown(){\n-    echo \""Unknown option \\\""$1\\\"".\""\n-    echo \""See $0 --help for available options.\""\n-    clean_temp_files\n-    exit 1\n+  echo \""Unknown option \\\""$1\\\"".\""\n+  echo \""See $0 --help for available options.\""\n+  clean_temp_files\n+  exit 1\n }\n \n-\n die() {\n-    echo \""$@\""\n-    echo\n-    echo \""Configuration failed. This could reflect a misconfiguration of your\""\n-    echo \""toolchains, improper options selected, or another problem. If you\""\n-    echo \""don't see any useful error messages above, the next step is to look\""\n-    echo \""at the configure error log file ($logfile) to determine what\""\n-    echo \""configure was trying to do when it died.\""\n-    clean_temp_files\n-    exit 1\n+  echo \""$@\""\n+  echo\n+  echo \""Configuration failed. This could reflect a misconfiguration of your\""\n+  echo \""toolchains, improper options selected, or another problem. If you\""\n+  echo \""don't see any useful error messages above, the next step is to look\""\n+  echo \""at the configure error log file ($logfile) to determine what\""\n+  echo \""configure was trying to do when it died.\""\n+  clean_temp_files\n+  exit 1\n }\n \n-\n log(){\n-    echo \""$@\"" >>$logfile\n+  echo \""$@\"" >>$logfile\n }\n \n-\n log_file(){\n-    log BEGIN $1\n-    cat -n $1 >>$logfile\n-    log END $1\n+  log BEGIN $1\n+  cat -n $1 >>$logfile\n+  log END $1\n }\n \n-\n log_echo() {\n-    echo \""$@\""\n-    log \""$@\""\n+  echo \""$@\""\n+  log \""$@\""\n }\n \n-\n fwrite () {\n-    outfile=$1\n-    shift\n-    echo \""$@\"" >> ${outfile}\n+  outfile=$1\n+  shift\n+  echo \""$@\"" >> ${outfile}\n }\n \n-\n show_help_pre(){\n-    for opt in ${CMDLINE_SELECT}; do\n-        opt2=`echo $opt | sed -e 's;_;-;g'`\n-        if enabled $opt; then\n-            eval \""toggle_${opt}=\\\""--disable-${opt2}\\\""\""\n-        else\n-            eval \""toggle_${opt}=\\\""--enable-${opt2} \\\""\""\n-        fi\n-    done\n+  for opt in ${CMDLINE_SELECT}; do\n+    opt2=`echo $opt | sed -e 's;_;-;g'`\n+    if enabled $opt; then\n+      eval \""toggle_${opt}=\\\""--disable-${opt2}\\\""\""\n+    else\n+      eval \""toggle_${opt}=\\\""--enable-${opt2} \\\""\""\n+    fi\n+  done\n \n-    cat <<EOF\n+  cat <<EOF\n Usage: configure [options]\n Options:\n \n@@ -89,6 +83,8 @@\n\n   ${toggle_gprof}             enable/disable gprof profiling instrumentation\n   ${toggle_gcov}              enable/disable gcov coverage instrumentation\n   ${toggle_thumb}             enable/disable building arm assembly in thumb mode\n+  ${toggle_dependency_tracking}\n+                              disable to speed up one-time build\n \n Install options:\n   ${toggle_install_docs}      control whether docs are installed\n@@ -100,9 +96,8 @@\n\n EOF\n }\n \n-\n show_help_post(){\n-    cat <<EOF\n+  cat <<EOF\n \n \n NOTES:\n@@ -119,150 +114,137 @@\n\n   exit 1\n }\n \n-\n show_targets() {\n-    while [ -n \""$*\"" ]; do\n-        if [ \""${1%%-*}\"" = \""${2%%-*}\"" ]; then\n-            if [ \""${2%%-*}\"" = \""${3%%-*}\"" ]; then\n-                printf \""    %-24s %-24s %-24s\\n\"" \""$1\"" \""$2\"" \""$3\""\n-                shift; shift; shift\n-            else\n-                printf \""    %-24s %-24s\\n\"" \""$1\"" \""$2\""\n-                shift; shift\n-            fi\n-        else\n-            printf \""    %-24s\\n\"" \""$1\""\n-            shift\n-        fi\n-    done\n+  while [ -n \""$*\"" ]; do\n+    if [ \""${1%%-*}\"" = \""${2%%-*}\"" ]; then\n+      if [ \""${2%%-*}\"" = \""${3%%-*}\"" ]; then\n+        printf \""    %-24s %-24s %-24s\\n\"" \""$1\"" \""$2\"" \""$3\""\n+        shift; shift; shift\n+      else\n+        printf \""    %-24s %-24s\\n\"" \""$1\"" \""$2\""\n+        shift; shift\n+      fi\n+    else\n+      printf \""    %-24s\\n\"" \""$1\""\n+      shift\n+    fi\n+  done\n }\n \n-\n show_help() {\n-    show_help_pre\n-    show_help_post\n+  show_help_pre\n+  show_help_post\n }\n \n #\n # List Processing Functions\n #\n set_all(){\n-    value=$1\n-    shift\n-    for var in $*; do\n-        eval $var=$value\n-    done\n+  value=$1\n+  shift\n+  for var in $*; do\n+    eval $var=$value\n+  done\n }\n \n-\n is_in(){\n-    value=$1\n-    shift\n-    for var in $*; do\n-        [ $var = $value ] && return 0\n-    done\n-    return 1\n+  value=$1\n+  shift\n+  for var in $*; do\n+    [ $var = $value ] && return 0\n+  done\n+  return 1\n }\n \n-\n add_cflags() {\n-    CFLAGS=\""${CFLAGS} $@\""\n-    CXXFLAGS=\""${CXXFLAGS} $@\""\n+  CFLAGS=\""${CFLAGS} $@\""\n+  CXXFLAGS=\""${CXXFLAGS} $@\""\n }\n \n-\n add_cflags_only() {\n-    CFLAGS=\""${CFLAGS} $@\""\n+  CFLAGS=\""${CFLAGS} $@\""\n }\n \n-\n add_cxxflags_only() {\n-    CXXFLAGS=\""${CXXFLAGS} $@\""\n+  CXXFLAGS=\""${CXXFLAGS} $@\""\n }\n \n-\n add_ldflags() {\n-    LDFLAGS=\""${LDFLAGS} $@\""\n+  LDFLAGS=\""${LDFLAGS} $@\""\n }\n \n-\n add_asflags() {\n-    ASFLAGS=\""${ASFLAGS} $@\""\n+  ASFLAGS=\""${ASFLAGS} $@\""\n }\n \n-\n add_extralibs() {\n-    extralibs=\""${extralibs} $@\""\n+  extralibs=\""${extralibs} $@\""\n }\n \n #\n # Boolean Manipulation Functions\n #\n enable_feature(){\n-    set_all yes $*\n+  set_all yes $*\n }\n \n disable_feature(){\n-    set_all no $*\n+  set_all no $*\n }\n \n enabled(){\n-    eval test \""x\\$$1\"" = \""xyes\""\n+  eval test \""x\\$$1\"" = \""xyes\""\n }\n \n disabled(){\n-    eval test \""x\\$$1\"" = \""xno\""\n+  eval test \""x\\$$1\"" = \""xno\""\n }\n \n-\n soft_enable() {\n-    for var in $*; do\n-        if ! disabled $var; then\n-            log_echo \""  enabling $var\""\n-            enable_feature $var\n-        fi\n-    done\n+  for var in $*; do\n+    if ! disabled $var; then\n+      enabled $var || log_echo \""  enabling $var\""\n+      enable_feature $var\n+    fi\n+  done\n }\n \n soft_disable() {\n-    for var in $*; do\n-        if ! enabled $var; then\n-            log_echo \""  disabling $var\""\n-            disable_feature $var\n-        fi\n-    done\n+  for var in $*; do\n+    if ! enabled $var; then\n+      disabled $var || log_echo \""  disabling $var\""\n+      disable_feature $var\n+    fi\n+  done\n }\n \n-\n #\n # Text Processing Functions\n #\n toupper(){\n-    echo \""$@\"" | tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ\n+  echo \""$@\"" | tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ\n }\n \n-\n tolower(){\n-    echo \""$@\"" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz\n+  echo \""$@\"" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz\n }\n \n-\n #\n # Temporary File Functions\n #\n source_path=${0%/*}\n enable_feature source_path_used\n-if test -z \""$source_path\"" -o \""$source_path\"" = \"".\"" ; then\n-    source_path=\""`pwd`\""\n-    disable_feature source_path_used\n+if [ -z \""$source_path\"" ] || [ \""$source_path\"" = \"".\"" ]; then\n+  source_path=\""`pwd`\""\n+  disable_feature source_path_used\n fi\n \n if test ! -z \""$TMPDIR\"" ; then\n-    TMPDIRx=\""${TMPDIR}\""\n+  TMPDIRx=\""${TMPDIR}\""\n elif test ! -z \""$TEMPDIR\"" ; then\n-    TMPDIRx=\""${TEMPDIR}\""\n+  TMPDIRx=\""${TEMPDIR}\""\n else\n-    TMPDIRx=\""/tmp\""\n+  TMPDIRx=\""/tmp\""\n fi\n RAND=$(awk 'BEGIN { srand(); printf \""%d\\n\"",(rand() * 32768)}')\n TMP_H=\""${TMPDIRx}/vpx-conf-$$-${RAND}.h\""\n@@ -273,76 +255,77 @@\n\n TMP_ASM=\""${TMPDIRx}/vpx-conf-$$-${RAND}.asm\""\n \n clean_temp_files() {\n-    rm -f ${TMP_C} ${TMP_CC} ${TMP_H} ${TMP_O} ${TMP_X} ${TMP_ASM}\n-    enabled gcov && rm -f ${TMP_C%.c}.gcno ${TMP_CC%.cc}.gcno\n+  rm -f ${TMP_C} ${TMP_CC} ${TMP_H} ${TMP_O} ${TMP_X} ${TMP_ASM}\n+  enabled gcov && rm -f ${TMP_C%.c}.gcno ${TMP_CC%.cc}.gcno\n }\n \n #\n # Toolchain Check Functions\n #\n check_cmd() {\n-    enabled external_build && return\n-    log \""$@\""\n-    \""$@\"" >>${logfile} 2>&1\n+  enabled external_build && return\n+  log \""$@\""\n+  \""$@\"" >>${logfile} 2>&1\n }\n \n check_cc() {\n-    log check_cc \""$@\""\n-    cat >${TMP_C}\n-    log_file ${TMP_C}\n-    check_cmd ${CC} ${CFLAGS} \""$@\"" -c -o ${TMP_O} ${TMP_C}\n+  log check_cc \""$@\""\n+  cat >${TMP_C}\n+  log_file ${TMP_C}\n+  check_cmd ${CC} ${CFLAGS} \""$@\"" -c -o ${TMP_O} ${TMP_C}\n }\n \n check_cxx() {\n-    log check_cxx \""$@\""\n-    cat >${TMP_CC}\n-    log_file ${TMP_CC}\n-    check_cmd ${CXX} ${CXXFLAGS} \""$@\"" -c -o ${TMP_O} ${TMP_CC}\n+  log check_cxx \""$@\""\n+  cat >${TMP_CC}\n+  log_file ${TMP_CC}\n+  check_cmd ${CXX} ${CXXFLAGS} \""$@\"" -c -o ${TMP_O} ${TMP_CC}\n }\n \n check_cpp() {\n-    log check_cpp \""$@\""\n-    cat > ${TMP_C}\n-    log_file ${TMP_C}\n-    check_cmd ${CC} ${CFLAGS} \""$@\"" -E -o ${TMP_O} ${TMP_C}\n+  log check_cpp \""$@\""\n+  cat > ${TMP_C}\n+  log_file ${TMP_C}\n+  check_cmd ${CC} ${CFLAGS} \""$@\"" -E -o ${TMP_O} ${TMP_C}\n }\n \n check_ld() {\n-    log check_ld \""$@\""\n-    check_cc $@ \\\n-        && check_cmd ${LD} ${LDFLAGS} \""$@\"" -o ${TMP_X} ${TMP_O} ${extralibs}\n+  log check_ld \""$@\""\n+  check_cc $@ \\\n+    && check_cmd ${LD} ${LDFLAGS} \""$@\"" -o ${TMP_X} ${TMP_O} ${extralibs}\n }\n \n check_header(){\n-    log check_header \""$@\""\n-    header=$1\n-    shift\n-    var=`echo $header | sed 's/[^A-Za-z0-9_]/_/g'`\n-    disable_feature $var\n-    check_cpp \""$@\"" <<EOF && enable_feature $var\n+  log check_header \""$@\""\n+  header=$1\n+  shift\n+  var=`echo $header | sed 's/[^A-Za-z0-9_]/_/g'`\n+  disable_feature $var\n+  check_cpp \""$@\"" <<EOF && enable_feature $var\n #include \""$header\""\n int x;\n EOF\n }\n \n-\n check_cflags() {\n-    log check_cflags \""$@\""\n-    check_cc -Werror \""$@\"" <<EOF\n+ log check_cflags \""$@\""\n+ check_cc -Werror \""$@\"" <<EOF\n int x;\n EOF\n }\n \n check_cxxflags() {\n-    log check_cxxflags \""$@\""\n+  log check_cxxflags \""$@\""\n \n-    # Catch CFLAGS that trigger CXX warnings\n-    case \""$CXX\"" in\n-      *c++-analyzer|*clang++|*g++*) check_cxx -Werror \""$@\"" <<EOF\n+  # Catch CFLAGS that trigger CXX warnings\n+  case \""$CXX\"" in\n+    *c++-analyzer|*clang++|*g++*)\n+      check_cxx -Werror \""$@\"" <<EOF\n int x;\n EOF\n       ;;\n-      *) check_cxx -Werror \""$@\"" <<EOF\n+    *)\n+      check_cxx -Werror \""$@\"" <<EOF\n int x;\n EOF\n       ;;\n@@ -350,82 +333,82 @@\n\n }\n \n check_add_cflags() {\n-    check_cxxflags \""$@\"" && add_cxxflags_only \""$@\""\n-    check_cflags \""$@\"" && add_cflags_only \""$@\""\n+  check_cxxflags \""$@\"" && add_cxxflags_only \""$@\""\n+  check_cflags \""$@\"" && add_cflags_only \""$@\""\n }\n \n check_add_asflags() {\n-    log add_asflags \""$@\""\n-    add_asflags \""$@\""\n+  log add_asflags \""$@\""\n+  add_asflags \""$@\""\n }\n \n check_add_ldflags() {\n-    log add_ldflags \""$@\""\n-    add_ldflags \""$@\""\n+  log add_ldflags \""$@\""\n+  add_ldflags \""$@\""\n }\n \n check_asm_align() {\n-    log check_asm_align \""$@\""\n-    cat >${TMP_ASM} <<EOF\n+  log check_asm_align \""$@\""\n+  cat >${TMP_ASM} <<EOF\n section .rodata\n align 16\n EOF\n-    log_file ${TMP_ASM}\n-    check_cmd ${AS} ${ASFLAGS} -o ${TMP_O} ${TMP_ASM}\n-    readelf -WS ${TMP_O} >${TMP_X}\n-    log_file ${TMP_X}\n-    if ! grep -q '\\.rodata .* 16$' ${TMP_X}; then\n-        die \""${AS} ${ASFLAGS} does not support section alignment (nasm <=2.08?)\""\n-    fi\n+  log_file ${TMP_ASM}\n+  check_cmd ${AS} ${ASFLAGS} -o ${TMP_O} ${TMP_ASM}\n+  readelf -WS ${TMP_O} >${TMP_X}\n+  log_file ${TMP_X}\n+  if ! grep -q '\\.rodata .* 16$' ${TMP_X}; then\n+    die \""${AS} ${ASFLAGS} does not support section alignment (nasm <=2.08?)\""\n+  fi\n }\n \n # tests for -m$1 toggling the feature given in $2. If $2 is empty $1 is used.\n check_gcc_machine_option() {\n-    local opt=\""$1\""\n-    local feature=\""$2\""\n-    [ -n \""$feature\"" ] || feature=\""$opt\""\n+  opt=\""$1\""\n+  feature=\""$2\""\n+  [ -n \""$feature\"" ] || feature=\""$opt\""\n \n-    if enabled gcc && ! disabled \""$feature\"" && ! check_cflags \""-m$opt\""; then\n-        RTCD_OPTIONS=\""${RTCD_OPTIONS}--disable-$feature \""\n-    else\n-        soft_enable \""$feature\""\n-    fi\n+  if enabled gcc && ! disabled \""$feature\"" && ! check_cflags \""-m$opt\""; then\n+    RTCD_OPTIONS=\""${RTCD_OPTIONS}--disable-$feature \""\n+  else\n+    soft_enable \""$feature\""\n+  fi\n }\n \n write_common_config_banner() {\n-    print_webm_license config.mk \""##\"" \""\""\n-    echo '# This file automatically generated by configure. Do not edit!' >> config.mk\n-    echo \""TOOLCHAIN := ${toolchain}\"" >> config.mk\n+  print_webm_license config.mk \""##\"" \""\""\n+  echo '# This file automatically generated by configure. Do not edit!' >> config.mk\n+  echo \""TOOLCHAIN := ${toolchain}\"" >> config.mk\n \n-    case ${toolchain} in\n-        *-linux-rvct)\n-            echo \""ALT_LIBC := ${alt_libc}\"" >> config.mk\n-            ;;\n-    esac\n+  case ${toolchain} in\n+    *-linux-rvct)\n+      echo \""ALT_LIBC := ${alt_libc}\"" >> config.mk\n+      ;;\n+  esac\n }\n \n write_common_config_targets() {\n-    for t in ${all_targets}; do\n-        if enabled ${t}; then\n-            if enabled universal || enabled child; then\n-                fwrite config.mk \""ALL_TARGETS += ${t}-${toolchain}\""\n-            else\n-                fwrite config.mk \""ALL_TARGETS += ${t}\""\n-            fi\n-        fi\n+  for t in ${all_targets}; do\n+    if enabled ${t}; then\n+      if enabled child; then\n+        fwrite config.mk \""ALL_TARGETS += ${t}-${toolchain}\""\n+      else\n+        fwrite config.mk \""ALL_TARGETS += ${t}\""\n+      fi\n+    fi\n     true;\n-    done\n-true\n+  done\n+  true\n }\n \n write_common_target_config_mk() {\n-    local CC=\""${CC}\""\n-    local CXX=\""${CXX}\""\n-    enabled ccache && CC=\""ccache ${CC}\""\n-    enabled ccache && CXX=\""ccache ${CXX}\""\n-    print_webm_license $1 \""##\"" \""\""\n+  saved_CC=\""${CC}\""\n+  saved_CXX=\""${CXX}\""\n+  enabled ccache && CC=\""ccache ${CC}\""\n+  enabled ccache && CXX=\""ccache ${CXX}\""\n+  print_webm_license $1 \""##\"" \""\""\n \n-    cat >> $1 << EOF\n+  cat >> $1 << EOF\n # This file automatically generated by configure. Do not edit!\n SRC_PATH=\""$source_path\""\n SRC_PATH_BARE=$source_path\n@@ -455,80 +438,87 @@\n\n RTCD_OPTIONS = ${RTCD_OPTIONS}\n EOF\n \n-    if enabled rvct; then cat >> $1 << EOF\n+  if enabled rvct; then cat >> $1 << EOF\n fmt_deps = sed -e 's;^__image.axf;\\${@:.d=.o} \\$@;' #hide\n EOF\n-    else cat >> $1 << EOF\n+  else cat >> $1 << EOF\n fmt_deps = sed -e 's;^\\([a-zA-Z0-9_]*\\)\\.o;\\${@:.d=.o} \\$@;'\n EOF\n-    fi\n+  fi\n \n-    print_config_mk ARCH   \""${1}\"" ${ARCH_LIST}\n-    print_config_mk HAVE   \""${1}\"" ${HAVE_LIST}\n-    print_config_mk CONFIG \""${1}\"" ${CONFIG_LIST}\n-    print_config_mk HAVE   \""${1}\"" gnu_strip\n+  print_config_mk ARCH   \""${1}\"" ${ARCH_LIST}\n+  print_config_mk HAVE   \""${1}\"" ${HAVE_LIST}\n+  print_config_mk CONFIG \""${1}\"" ${CONFIG_LIST}\n+  print_config_mk HAVE   \""${1}\"" gnu_strip\n \n-    enabled msvs && echo \""CONFIG_VS_VERSION=${vs_version}\"" >> \""${1}\""\n+  enabled msvs && echo \""CONFIG_VS_VERSION=${vs_version}\"" >> \""${1}\""\n \n+  CC=\""${saved_CC}\""\n+  CXX=\""${saved_CXX}\""\n }\n \n-\n write_common_target_config_h() {\n-    print_webm_license ${TMP_H} \""/*\"" \"" */\""\n-    cat >> ${TMP_H} << EOF\n+  print_webm_license ${TMP_H} \""/*\"" \"" */\""\n+  cat >> ${TMP_H} << EOF\n /* This file automatically generated by configure. Do not edit! */\n #ifndef VPX_CONFIG_H\n #define VPX_CONFIG_H\n #define RESTRICT    ${RESTRICT}\n #define INLINE      ${INLINE}\n EOF\n-    print_config_h ARCH   \""${TMP_H}\"" ${ARCH_LIST}\n-    print_config_h HAVE   \""${TMP_H}\"" ${HAVE_LIST}\n-    print_config_h CONFIG \""${TMP_H}\"" ${CONFIG_LIST}\n-    echo \""#endif /* VPX_CONFIG_H */\"" >> ${TMP_H}\n-    mkdir -p `dirname \""$1\""`\n-    cmp \""$1\"" ${TMP_H} >/dev/null 2>&1 || mv ${TMP_H} \""$1\""\n+  print_config_h ARCH   \""${TMP_H}\"" ${ARCH_LIST}\n+  print_config_h HAVE   \""${TMP_H}\"" ${HAVE_LIST}\n+  print_config_h CONFIG \""${TMP_H}\"" ${CONFIG_LIST}\n+  print_config_vars_h   \""${TMP_H}\"" ${VAR_LIST}\n+  echo \""#endif /* VPX_CONFIG_H */\"" >> ${TMP_H}\n+  mkdir -p `dirname \""$1\""`\n+  cmp \""$1\"" ${TMP_H} >/dev/null 2>&1 || mv ${TMP_H} \""$1\""\n }\n \n process_common_cmdline() {\n-    for opt in \""$@\""; do\n-        optval=\""${opt#*=}\""\n-        case \""$opt\"" in\n-        --child) enable_feature child\n+  for opt in \""$@\""; do\n+    optval=\""${opt#*=}\""\n+    case \""$opt\"" in\n+      --child)\n+        enable_feature child\n         ;;\n-        --log*)\n+      --log*)\n         logging=\""$optval\""\n         if ! disabled logging ; then\n-            enabled logging || logfile=\""$logging\""\n+          enabled logging || logfile=\""$logging\""\n         else\n-            logfile=/dev/null\n+          logfile=/dev/null\n         fi\n         ;;\n-        --target=*) toolchain=\""${toolchain:-${optval}}\""\n+      --target=*)\n+        toolchain=\""${toolchain:-${optval}}\""\n         ;;\n-        --force-target=*) toolchain=\""${toolchain:-${optval}}\""; enable_feature force_toolchain\n+      --force-target=*)\n+        toolchain=\""${toolchain:-${optval}}\""\n+        enable_feature force_toolchain\n         ;;\n-        --cpu)\n+      --cpu=*)\n+        tune_cpu=\""$optval\""\n         ;;\n-        --cpu=*) tune_cpu=\""$optval\""\n-        ;;\n-        --extra-cflags=*)\n+      --extra-cflags=*)\n         extra_cflags=\""${optval}\""\n         ;;\n-        --enable-?*|--disable-?*)\n+      --enable-?*|--disable-?*)\n         eval `echo \""$opt\"" | sed 's/--/action=/;s/-/ option=/;s/-/_/g'`\n         if echo \""${ARCH_EXT_LIST}\"" | grep \""^ *$option\\$\"" >/dev/null; then\n-            [ $action = \""disable\"" ] && RTCD_OPTIONS=\""${RTCD_OPTIONS}${opt} \""\n+          [ $action = \""disable\"" ] && RTCD_OPTIONS=\""${RTCD_OPTIONS}--disable-${option} \""\n         elif [ $action = \""disable\"" ] && ! disabled $option ; then\n           echo \""${CMDLINE_SELECT}\"" | grep \""^ *$option\\$\"" >/dev/null ||\n             die_unknown $opt\n+          log_echo \""  disabling $option\""\n         elif [ $action = \""enable\"" ] && ! enabled $option ; then\n           echo \""${CMDLINE_SELECT}\"" | grep \""^ *$option\\$\"" >/dev/null ||\n             die_unknown $opt\n+          log_echo \""  enabling $option\""\n         fi\n         ${action}_feature $option\n         ;;\n-        --require-?*)\n+      --require-?*)\n         eval `echo \""$opt\"" | sed 's/--/action=/;s/-/ option=/;s/-/_/g'`\n         if echo \""${ARCH_EXT_LIST}\"" none | grep \""^ *$option\\$\"" >/dev/null; then\n             RTCD_OPTIONS=\""${RTCD_OPTIONS}${opt} \""\n@@ -536,770 +526,862 @@\n\n             die_unknown $opt\n         fi\n         ;;\n-        --force-enable-?*|--force-disable-?*)\n+      --force-enable-?*|--force-disable-?*)\n         eval `echo \""$opt\"" | sed 's/--force-/action=/;s/-/ option=/;s/-/_/g'`\n         ${action}_feature $option\n         ;;\n-        --libc=*)\n+      --libc=*)\n         [ -d \""${optval}\"" ] || die \""Not a directory: ${optval}\""\n         disable_feature builtin_libc\n         alt_libc=\""${optval}\""\n         ;;\n-        --as=*)\n-        [ \""${optval}\"" = yasm -o \""${optval}\"" = nasm -o \""${optval}\"" = auto ] \\\n-            || die \""Must be yasm, nasm or auto: ${optval}\""\n+      --as=*)\n+        [ \""${optval}\"" = yasm ] || [ \""${optval}\"" = nasm ] \\\n+          || [ \""${optval}\"" = auto ] \\\n+          || die \""Must be yasm, nasm or auto: ${optval}\""\n         alt_as=\""${optval}\""\n         ;;\n-        --prefix=*)\n+      --size-limit=*)\n+        w=\""${optval%%x*}\""\n+        h=\""${optval##*x}\""\n+        VAR_LIST=\""DECODE_WIDTH_LIMIT ${w} DECODE_HEIGHT_LIMIT ${h}\""\n+        [ ${w} -gt 0 ] && [ ${h} -gt 0 ] || die \""Invalid size-limit: too small.\""\n+        [ ${w} -lt 65536 ] && [ ${h} -lt 65536 ] \\\n+            || die \""Invalid size-limit: too big.\""\n+        enable_feature size_limit\n+        ;;\n+      --prefix=*)\n         prefix=\""${optval}\""\n         ;;\n-        --libdir=*)\n+      --libdir=*)\n         libdir=\""${optval}\""\n         ;;\n-        --sdk-path=*)\n+      --sdk-path=*)\n         [ -d \""${optval}\"" ] || die \""Not a directory: ${optval}\""\n         sdk_path=\""${optval}\""\n         ;;\n-        --libc|--as|--prefix|--libdir|--sdk-path)\n+      --libc|--as|--prefix|--libdir|--sdk-path)\n         die \""Option ${opt} requires argument\""\n         ;;\n-        --help|-h) show_help\n+      --help|-h)\n+        show_help\n         ;;\n-        *) die_unknown $opt\n+      *)\n+        die_unknown $opt\n         ;;\n-        esac\n-    done\n+    esac\n+  done\n }\n \n process_cmdline() {\n-    for opt do\n-        optval=\""${opt#*=}\""\n-        case \""$opt\"" in\n-        *) process_common_cmdline $opt\n+  for opt do\n+    optval=\""${opt#*=}\""\n+    case \""$opt\"" in\n+      *)\n+        process_common_cmdline $opt\n         ;;\n-        esac\n-    done\n+    esac\n+  done\n }\n \n-\n post_process_common_cmdline() {\n-    prefix=\""${prefix:-/usr/local}\""\n-    prefix=\""${prefix%/}\""\n-    libdir=\""${libdir:-${prefix}/lib}\""\n-    libdir=\""${libdir%/}\""\n-    if [ \""${libdir#${prefix}}\"" = \""${libdir}\"" ]; then\n-        die \""Libdir ${libdir} must be a subdirectory of ${prefix}\""\n-    fi\n+  prefix=\""${prefix:-/usr/local}\""\n+  prefix=\""${prefix%/}\""\n+  libdir=\""${libdir:-${prefix}/lib}\""\n+  libdir=\""${libdir%/}\""\n+  if [ \""${libdir#${prefix}}\"" = \""${libdir}\"" ]; then\n+    die \""Libdir ${libdir} must be a subdirectory of ${prefix}\""\n+  fi\n }\n \n-\n post_process_cmdline() {\n-    true;\n+  true;\n }\n \n setup_gnu_toolchain() {\n-        CC=${CC:-${CROSS}gcc}\n-        CXX=${CXX:-${CROSS}g++}\n-        AR=${AR:-${CROSS}ar}\n-        LD=${LD:-${CROSS}${link_with_cc:-ld}}\n-        AS=${AS:-${CROSS}as}\n-    STRIP=${STRIP:-${CROSS}strip}\n-    NM=${NM:-${CROSS}nm}\n-        AS_SFX=.s\n-        EXE_SFX=\n+  CC=${CC:-${CROSS}gcc}\n+  CXX=${CXX:-${CROSS}g++}\n+  AR=${AR:-${CROSS}ar}\n+  LD=${LD:-${CROSS}${link_with_cc:-ld}}\n+  AS=${AS:-${CROSS}as}\n+  STRIP=${STRIP:-${CROSS}strip}\n+  NM=${NM:-${CROSS}nm}\n+  AS_SFX=.s\n+  EXE_SFX=\n+}\n+\n+# Reliably find the newest available Darwin SDKs. (Older versions of\n+# xcrun don't support --show-sdk-path.)\n+show_darwin_sdk_path() {\n+  xcrun --sdk $1 --show-sdk-path 2>/dev/null ||\n+    xcodebuild -sdk $1 -version Path 2>/dev/null\n }\n \n process_common_toolchain() {\n-    if [ -z \""$toolchain\"" ]; then\n-        gcctarget=\""${CHOST:-$(gcc -dumpmachine 2> /dev/null)}\""\n+  if [ -z \""$toolchain\"" ]; then\n+    gcctarget=\""${CHOST:-$(gcc -dumpmachine 2> /dev/null)}\""\n \n-        # detect tgt_isa\n-        case \""$gcctarget\"" in\n-            armv6*)\n-                tgt_isa=armv6\n-                ;;\n-            armv7*-hardfloat*)\n-                tgt_isa=armv7\n-                float_abi=hard\n-                ;;\n-            armv7*)\n-                tgt_isa=armv7\n-                float_abi=softfp\n-                ;;\n-            armv5te*)\n-                tgt_isa=armv5te\n-                ;;\n-            *x86_64*|*amd64*)\n-                tgt_isa=x86_64\n-                ;;\n-            *i[3456]86*)\n-                tgt_isa=x86\n-                ;;\n-            *powerpc64*)\n-                tgt_isa=ppc64\n-                ;;\n-            *powerpc*)\n-                tgt_isa=ppc32\n-                ;;\n-            *sparc*)\n-                tgt_isa=sparc\n-                ;;\n-        esac\n+    # detect tgt_isa\n+    case \""$gcctarget\"" in\n+      armv6*)\n+        tgt_isa=armv6\n+        ;;\n+      armv7*-hardfloat*)\n+        tgt_isa=armv7\n+        float_abi=hard\n+        ;;\n+      armv7*)\n+        tgt_isa=armv7\n+        float_abi=softfp\n+        ;;\n+      *x86_64*|*amd64*)\n+        tgt_isa=x86_64\n+        ;;\n+      *i[3456]86*)\n+        tgt_isa=x86\n+        ;;\n+      *sparc*)\n+        tgt_isa=sparc\n+        ;;\n+    esac\n \n-        # detect tgt_os\n-        case \""$gcctarget\"" in\n-            *darwin8*)\n-                tgt_isa=universal\n-                tgt_os=darwin8\n-                ;;\n-            *darwin9*)\n-                tgt_isa=universal\n-                tgt_os=darwin9\n-                ;;\n-            *darwin10*)\n-                tgt_isa=x86_64\n-                tgt_os=darwin10\n-                ;;\n-            *darwin11*)\n-                tgt_isa=x86_64\n-                tgt_os=darwin11\n-                ;;\n-            *darwin12*)\n-                tgt_isa=x86_64\n-                tgt_os=darwin12\n-                ;;\n-            *darwin13*)\n-                tgt_isa=x86_64\n-                tgt_os=darwin13\n-                ;;\n-            x86_64*mingw32*)\n-                tgt_os=win64\n-                ;;\n-            *mingw32*|*cygwin*)\n-                [ -z \""$tgt_isa\"" ] && tgt_isa=x86\n-                tgt_os=win32\n-                ;;\n-            *linux*|*bsd*)\n-                tgt_os=linux\n-                ;;\n-            *solaris2.10)\n-                tgt_os=solaris\n-                ;;\n-            *os2*)\n-                tgt_os=os2\n-                ;;\n-        esac\n+    # detect tgt_os\n+    case \""$gcctarget\"" in\n+      *darwin10*)\n+        tgt_isa=x86_64\n+        tgt_os=darwin10\n+        ;;\n+      *darwin11*)\n+        tgt_isa=x86_64\n+        tgt_os=darwin11\n+        ;;\n+      *darwin12*)\n+        tgt_isa=x86_64\n+        tgt_os=darwin12\n+        ;;\n+      *darwin13*)\n+        tgt_isa=x86_64\n+        tgt_os=darwin13\n+        ;;\n+      *darwin14*)\n+        tgt_isa=x86_64\n+        tgt_os=darwin14\n+        ;;\n+      x86_64*mingw32*)\n+        tgt_os=win64\n+        ;;\n+      *mingw32*|*cygwin*)\n+        [ -z \""$tgt_isa\"" ] && tgt_isa=x86\n+        tgt_os=win32\n+        ;;\n+      *linux*|*bsd*)\n+        tgt_os=linux\n+        ;;\n+      *solaris2.10)\n+        tgt_os=solaris\n+        ;;\n+      *os2*)\n+        tgt_os=os2\n+        ;;\n+    esac\n \n-        if [ -n \""$tgt_isa\"" ] && [ -n \""$tgt_os\"" ]; then\n-            toolchain=${tgt_isa}-${tgt_os}-gcc\n-        fi\n+    if [ -n \""$tgt_isa\"" ] && [ -n \""$tgt_os\"" ]; then\n+      toolchain=${tgt_isa}-${tgt_os}-gcc\n     fi\n+  fi\n \n-    toolchain=${toolchain:-generic-gnu}\n+  toolchain=${toolchain:-generic-gnu}\n \n-    is_in ${toolchain} ${all_platforms} || enabled force_toolchain \\\n-        || die \""Unrecognized toolchain '${toolchain}'\""\n+  is_in ${toolchain} ${all_platforms} || enabled force_toolchain \\\n+    || die \""Unrecognized toolchain '${toolchain}'\""\n \n-    enabled child || log_echo \""Configuring for target '${toolchain}'\""\n+  enabled child || log_echo \""Configuring for target '${toolchain}'\""\n \n-    #\n-    # Set up toolchain variables\n-    #\n-    tgt_isa=$(echo ${toolchain} | awk 'BEGIN{FS=\""-\""}{print $1}')\n-    tgt_os=$(echo ${toolchain} | awk 'BEGIN{FS=\""-\""}{print $2}')\n-    tgt_cc=$(echo ${toolchain} | awk 'BEGIN{FS=\""-\""}{print $3}')\n+  #\n+  # Set up toolchain variables\n+  #\n+  tgt_isa=$(echo ${toolchain} | awk 'BEGIN{FS=\""-\""}{print $1}')\n+  tgt_os=$(echo ${toolchain} | awk 'BEGIN{FS=\""-\""}{print $2}')\n+  tgt_cc=$(echo ${toolchain} | awk 'BEGIN{FS=\""-\""}{print $3}')\n \n-    # Mark the specific ISA requested as enabled\n-    soft_enable ${tgt_isa}\n-    enable_feature ${tgt_os}\n-    enable_feature ${tgt_cc}\n+  # Mark the specific ISA requested as enabled\n+  soft_enable ${tgt_isa}\n+  enable_feature ${tgt_os}\n+  enable_feature ${tgt_cc}\n \n-    # Enable the architecture family\n-    case ${tgt_isa} in\n-        arm*) enable_feature arm;;\n-        mips*) enable_feature mips;;\n-    esac\n+  # Enable the architecture family\n+  case ${tgt_isa} in\n+    arm*)\n+      enable_feature arm\n+      ;;\n+    mips*)\n+      enable_feature mips\n+      ;;\n+  esac\n \n-    # PIC is probably what we want when building shared libs\n-    enabled shared && soft_enable pic\n+  # PIC is probably what we want when building shared libs\n+  enabled shared && soft_enable pic\n \n-    # Handle darwin variants. Newer SDKs allow targeting older\n-    # platforms, so find the newest SDK available.\n-    case ${toolchain} in\n-        *-darwin*)\n-            if [ -z \""${DEVELOPER_DIR}\"" ]; then\n-                DEVELOPER_DIR=`xcode-select -print-path 2> /dev/null`\n-                [ $? -ne 0 ] && OSX_SKIP_DIR_CHECK=1\n-            fi\n-            if [ -z \""${OSX_SKIP_DIR_CHECK}\"" ]; then\n-                OSX_SDK_ROOTS=\""${DEVELOPER_DIR}/SDKs\""\n-                OSX_SDK_VERSIONS=\""MacOSX10.4u.sdk MacOSX10.5.sdk MacOSX10.6.sdk\""\n-                OSX_SDK_VERSIONS=\""${OSX_SDK_VERSIONS} MacOSX10.7.sdk\""\n-                for v in ${OSX_SDK_VERSIONS}; do\n-                    if [ -d \""${OSX_SDK_ROOTS}/${v}\"" ]; then\n-                        osx_sdk_dir=\""${OSX_SDK_ROOTS}/${v}\""\n-                    fi\n-                done\n-            fi\n-            ;;\n-    esac\n+  # Minimum iOS version for all target platforms (darwin and iphonesimulator).\n+  IOS_VERSION_MIN=\""6.0\""\n \n-    if [ -d \""${osx_sdk_dir}\"" ]; then\n+  # Handle darwin variants. Newer SDKs allow targeting older\n+  # platforms, so use the newest one available.\n+  case ${toolchain} in\n+    arm*-darwin*)\n+      ios_sdk_dir=\""$(show_darwin_sdk_path iphoneos)\""\n+      if [ -d \""${ios_sdk_dir}\"" ]; then\n+        add_cflags  \""-isysroot ${ios_sdk_dir}\""\n+        add_ldflags \""-isysroot ${ios_sdk_dir}\""\n+      fi\n+      ;;\n+    *-darwin*)\n+      osx_sdk_dir=\""$(show_darwin_sdk_path macosx)\""\n+      if [ -d \""${osx_sdk_dir}\"" ]; then\n         add_cflags  \""-isysroot ${osx_sdk_dir}\""\n         add_ldflags \""-isysroot ${osx_sdk_dir}\""\n-    fi\n+      fi\n+      ;;\n+  esac\n \n-    case ${toolchain} in\n-        *-darwin8-*)\n-            add_cflags  \""-mmacosx-version-min=10.4\""\n-            add_ldflags \""-mmacosx-version-min=10.4\""\n-            ;;\n-        *-darwin9-*)\n-            add_cflags  \""-mmacosx-version-min=10.5\""\n-            add_ldflags \""-mmacosx-version-min=10.5\""\n-            ;;\n-        *-darwin10-*)\n-            add_cflags  \""-mmacosx-version-min=10.6\""\n-            add_ldflags \""-mmacosx-version-min=10.6\""\n-            ;;\n-        *-darwin11-*)\n-            add_cflags  \""-mmacosx-version-min=10.7\""\n-            add_ldflags \""-mmacosx-version-min=10.7\""\n-            ;;\n-        *-darwin12-*)\n-            add_cflags  \""-mmacosx-version-min=10.8\""\n-            add_ldflags \""-mmacosx-version-min=10.8\""\n-            ;;\n-        *-darwin13-*)\n-            add_cflags  \""-mmacosx-version-min=10.9\""\n-            add_ldflags \""-mmacosx-version-min=10.9\""\n-            ;;\n-    esac\n+  case ${toolchain} in\n+    *-darwin8-*)\n+      add_cflags  \""-mmacosx-version-min=10.4\""\n+      add_ldflags \""-mmacosx-version-min=10.4\""\n+      ;;\n+    *-darwin9-*)\n+      add_cflags  \""-mmacosx-version-min=10.5\""\n+      add_ldflags \""-mmacosx-version-min=10.5\""\n+      ;;\n+    *-darwin10-*)\n+      add_cflags  \""-mmacosx-version-min=10.6\""\n+      add_ldflags \""-mmacosx-version-min=10.6\""\n+      ;;\n+    *-darwin11-*)\n+      add_cflags  \""-mmacosx-version-min=10.7\""\n+      add_ldflags \""-mmacosx-version-min=10.7\""\n+      ;;\n+    *-darwin12-*)\n+      add_cflags  \""-mmacosx-version-min=10.8\""\n+      add_ldflags \""-mmacosx-version-min=10.8\""\n+      ;;\n+    *-darwin13-*)\n+      add_cflags  \""-mmacosx-version-min=10.9\""\n+      add_ldflags \""-mmacosx-version-min=10.9\""\n+      ;;\n+    *-darwin14-*)\n+      add_cflags  \""-mmacosx-version-min=10.10\""\n+      add_ldflags \""-mmacosx-version-min=10.10\""\n+      ;;\n+    *-iphonesimulator-*)\n+      add_cflags  \""-miphoneos-version-min=${IOS_VERSION_MIN}\""\n+      add_ldflags \""-miphoneos-version-min=${IOS_VERSION_MIN}\""\n+      iossim_sdk_dir=\""$(show_darwin_sdk_path iphonesimulator)\""\n+      if [ -d \""${iossim_sdk_dir}\"" ]; then\n+        add_cflags  \""-isysroot ${iossim_sdk_dir}\""\n+        add_ldflags \""-isysroot ${iossim_sdk_dir}\""\n+      fi\n+      ;;\n+  esac\n \n-    # Handle Solaris variants. Solaris 10 needs -lposix4\n-    case ${toolchain} in\n-        sparc-solaris-*)\n-            add_extralibs -lposix4\n-            disable_feature fast_unaligned\n-            ;;\n-        *-solaris-*)\n-            add_extralibs -lposix4\n-            ;;\n-    esac\n+  # Handle Solaris variants. Solaris 10 needs -lposix4\n+  case ${toolchain} in\n+    sparc-solaris-*)\n+      add_extralibs -lposix4\n+      ;;\n+    *-solaris-*)\n+      add_extralibs -lposix4\n+      ;;\n+  esac\n \n-    # Process ARM architecture variants\n-    case ${toolchain} in\n+  # Process ARM architecture variants\n+  case ${toolchain} in\n     arm*)\n-        # on arm, isa versions are supersets\n-        case ${tgt_isa} in\n-        armv7)\n-            soft_enable neon\n-            soft_enable media\n-            soft_enable edsp\n-            soft_enable fast_unaligned\n-            ;;\n+      # on arm, isa versions are supersets\n+      case ${tgt_isa} in\n+        arm64|armv8)\n+          soft_enable neon\n+          ;;\n+        armv7|armv7s)\n+          soft_enable neon\n+          # Only enable neon_asm when neon is also enabled.\n+          enabled neon && soft_enable neon_asm\n+          # If someone tries to force it through, die.\n+          if disabled neon && enabled neon_asm; then\n+            die \""Disabling neon while keeping neon-asm is not supported\""\n+          fi\n+          case ${toolchain} in\n+            *-darwin*)\n+              # Neon is guaranteed on iOS 6+ devices, while old media extensions\n+              # no longer assemble with iOS 9 SDK\n+              ;;\n+            *)\n+              soft_enable media\n+          esac\n+          ;;\n         armv6)\n-            soft_enable media\n-            soft_enable edsp\n-            soft_enable fast_unaligned\n-            ;;\n-        armv5te)\n-            soft_enable edsp\n-            disable_feature fast_unaligned\n-            ;;\n-        esac\n+          soft_enable media\n+          ;;\n+      esac\n \n-        asm_conversion_cmd=\""cat\""\n+      asm_conversion_cmd=\""cat\""\n \n-        case ${tgt_cc} in\n+      case ${tgt_cc} in\n         gcc)\n-            CROSS=${CROSS:-arm-none-linux-gnueabi-}\n-            link_with_cc=gcc\n-            setup_gnu_toolchain\n-            arch_int=${tgt_isa##armv}\n-            arch_int=${arch_int%%te}\n-            check_add_asflags --defsym ARCHITECTURE=${arch_int}\n-            tune_cflags=\""-mtune=\""\n-            if [ ${tgt_isa} = \""armv7\"" ]; then\n-                if [ -z \""${float_abi}\"" ]; then\n-                    check_cpp <<EOF && float_abi=hard || float_abi=softfp\n+          CROSS=${CROSS:-arm-none-linux-gnueabi-}\n+          link_with_cc=gcc\n+          setup_gnu_toolchain\n+          arch_int=${tgt_isa##armv}\n+          arch_int=${arch_int%%te}\n+          check_add_asflags --defsym ARCHITECTURE=${arch_int}\n+          tune_cflags=\""-mtune=\""\n+          if [ ${tgt_isa} = \""armv7\"" ] || [ ${tgt_isa} = \""armv7s\"" ]; then\n+            if [ -z \""${float_abi}\"" ]; then\n+              check_cpp <<EOF && float_abi=hard || float_abi=softfp\n #ifndef __ARM_PCS_VFP\n #error \""not hardfp\""\n #endif\n EOF\n-                fi\n-                check_add_cflags  -march=armv7-a -mfloat-abi=${float_abi}\n-                check_add_asflags -march=armv7-a -mfloat-abi=${float_abi}\n-\n-                if enabled neon\n-                then\n-                    check_add_cflags -mfpu=neon #-ftree-vectorize\n-                    check_add_asflags -mfpu=neon\n-                fi\n-\n-                if [ -z \""${tune_cpu}\"" ]; then\n-                    tune_cpu=cortex-a8\n-                fi\n-            else\n-                check_add_cflags -march=${tgt_isa}\n-                check_add_asflags -march=${tgt_isa}\n             fi\n+            check_add_cflags  -march=armv7-a -mfloat-abi=${float_abi}\n+            check_add_asflags -march=armv7-a -mfloat-abi=${float_abi}\n \n-            enabled debug && add_asflags -g\n-            asm_conversion_cmd=\""${source_path}/build/make/ads2gas.pl\""\n-            if enabled thumb; then\n-                asm_conversion_cmd=\""$asm_conversion_cmd -thumb\""\n-                check_add_cflags -mthumb\n-                check_add_asflags -mthumb -mimplicit-it=always\n+            if enabled neon || enabled neon_asm; then\n+              check_add_cflags -mfpu=neon #-ftree-vectorize\n+              check_add_asflags -mfpu=neon\n             fi\n-            ;;\n+          else\n+            check_add_cflags -march=${tgt_isa}\n+            check_add_asflags -march=${tgt_isa}\n+          fi\n+\n+          enabled debug && add_asflags -g\n+          asm_conversion_cmd=\""${source_path}/build/make/ads2gas.pl\""\n+          if enabled thumb; then\n+            asm_conversion_cmd=\""$asm_conversion_cmd -thumb\""\n+            check_add_cflags -mthumb\n+            check_add_asflags -mthumb -mimplicit-it=always\n+          fi\n+          ;;\n         vs*)\n-            asm_conversion_cmd=\""${source_path}/build/make/ads2armasm_ms.pl\""\n-            AS_SFX=.s\n-            msvs_arch_dir=arm-msvs\n-            disable_feature multithread\n-            disable_feature unit_tests\n-            ;;\n+          asm_conversion_cmd=\""${source_path}/build/make/ads2armasm_ms.pl\""\n+          AS_SFX=.s\n+          msvs_arch_dir=arm-msvs\n+          disable_feature multithread\n+          disable_feature unit_tests\n+          vs_version=${tgt_cc##vs}\n+          if [ $vs_version -ge 12 ]; then\n+            # MSVC 2013 doesn't allow doing plain .exe projects for ARM,\n+            # only \""AppContainerApplication\"" which requires an AppxManifest.\n+            # Therefore disable the examples, just build the library.\n+            disable_feature examples\n+          fi\n+          ;;\n         rvct)\n-            CC=armcc\n-            AR=armar\n-            AS=armasm\n-            LD=${source_path}/build/make/armlink_adapter.sh\n-            STRIP=arm-none-linux-gnueabi-strip\n-            NM=arm-none-linux-gnueabi-nm\n-            tune_cflags=\""--cpu=\""\n-            tune_asflags=\""--cpu=\""\n-            if [ -z \""${tune_cpu}\"" ]; then\n-                if [ ${tgt_isa} = \""armv7\"" ]; then\n-                    if enabled neon\n-                    then\n-                        check_add_cflags --fpu=softvfp+vfpv3\n-                        check_add_asflags --fpu=softvfp+vfpv3\n-                    fi\n-                    check_add_cflags --cpu=Cortex-A8\n-                    check_add_asflags --cpu=Cortex-A8\n-                else\n-                    check_add_cflags --cpu=${tgt_isa##armv}\n-                    check_add_asflags --cpu=${tgt_isa##armv}\n-                fi\n+          CC=armcc\n+          AR=armar\n+          AS=armasm\n+          LD=\""${source_path}/build/make/armlink_adapter.sh\""\n+          STRIP=arm-none-linux-gnueabi-strip\n+          NM=arm-none-linux-gnueabi-nm\n+          tune_cflags=\""--cpu=\""\n+          tune_asflags=\""--cpu=\""\n+          if [ -z \""${tune_cpu}\"" ]; then\n+            if [ ${tgt_isa} = \""armv7\"" ]; then\n+              if enabled neon || enabled neon_asm\n+              then\n+                check_add_cflags --fpu=softvfp+vfpv3\n+                check_add_asflags --fpu=softvfp+vfpv3\n+              fi\n+              check_add_cflags --cpu=Cortex-A8\n+              check_add_asflags --cpu=Cortex-A8\n+            else\n+              check_add_cflags --cpu=${tgt_isa##armv}\n+              check_add_asflags --cpu=${tgt_isa##armv}\n             fi\n-            arch_int=${tgt_isa##armv}\n-            arch_int=${arch_int%%te}\n-            check_add_asflags --pd \""\\\""ARCHITECTURE SETA ${arch_int}\\\""\""\n-            enabled debug && add_asflags -g\n-            add_cflags --gnu\n-            add_cflags --enum_is_int\n-            add_cflags --wchar32\n-        ;;\n-        esac\n+          fi\n+          arch_int=${tgt_isa##armv}\n+          arch_int=${arch_int%%te}\n+          check_add_asflags --pd \""\\\""ARCHITECTURE SETA ${arch_int}\\\""\""\n+          enabled debug && add_asflags -g\n+          add_cflags --gnu\n+          add_cflags --enum_is_int\n+          add_cflags --wchar32\n+          ;;\n+      esac\n \n-        case ${tgt_os} in\n+      case ${tgt_os} in\n         none*)\n-            disable_feature multithread\n-            disable_feature os_support\n-            ;;\n+          disable_feature multithread\n+          disable_feature os_support\n+          ;;\n \n         android*)\n-            SDK_PATH=${sdk_path}\n-            COMPILER_LOCATION=`find \""${SDK_PATH}\"" \\\n-                               -name \""arm-linux-androideabi-gcc*\"" -print -quit`\n-            TOOLCHAIN_PATH=${COMPILER_LOCATION%/*}/arm-linux-androideabi-\n-            CC=${TOOLCHAIN_PATH}gcc\n-            CXX=${TOOLCHAIN_PATH}g++\n-            AR=${TOOLCHAIN_PATH}ar\n-            LD=${TOOLCHAIN_PATH}gcc\n-            AS=${TOOLCHAIN_PATH}as\n-            STRIP=${TOOLCHAIN_PATH}strip\n-            NM=${TOOLCHAIN_PATH}nm\n+          SDK_PATH=${sdk_path}\n+          COMPILER_LOCATION=`find \""${SDK_PATH}\"" \\\n+                             -name \""arm-linux-androideabi-gcc*\"" -print -quit`\n+          TOOLCHAIN_PATH=${COMPILER_LOCATION%/*}/arm-linux-androideabi-\n+          CC=${TOOLCHAIN_PATH}gcc\n+          CXX=${TOOLCHAIN_PATH}g++\n+          AR=${TOOLCHAIN_PATH}ar\n+          LD=${TOOLCHAIN_PATH}gcc\n+          AS=${TOOLCHAIN_PATH}as\n+          STRIP=${TOOLCHAIN_PATH}strip\n+          NM=${TOOLCHAIN_PATH}nm\n \n-            if [ -z \""${alt_libc}\"" ]; then\n-                alt_libc=`find \""${SDK_PATH}\"" -name arch-arm -print | \\\n-                          awk '{n = split($0,a,\""/\""); \\\n-                                split(a[n-1],b,\""-\""); \\\n-                                print $0 \"" \"" b[2]}' | \\\n-                          sort -g -k 2 | \\\n-                          awk '{ print $1 }' | tail -1`\n-            fi\n+          if [ -z \""${alt_libc}\"" ]; then\n+            alt_libc=`find \""${SDK_PATH}\"" -name arch-arm -print | \\\n+              awk '{n = split($0,a,\""/\""); \\\n+                split(a[n-1],b,\""-\""); \\\n+                print $0 \"" \"" b[2]}' | \\\n+                sort -g -k 2 | \\\n+                awk '{ print $1 }' | tail -1`\n+          fi\n \n-            add_cflags \""--sysroot=${alt_libc}\""\n-            add_ldflags \""--sysroot=${alt_libc}\""\n+          add_cflags \""--sysroot=${alt_libc}\""\n+          add_ldflags \""--sysroot=${alt_libc}\""\n \n-            # linker flag that routes around a CPU bug in some\n-            # Cortex-A8 implementations (NDK Dev Guide)\n-            add_ldflags \""-Wl,--fix-cortex-a8\""\n+          # linker flag that routes around a CPU bug in some\n+          # Cortex-A8 implementations (NDK Dev Guide)\n+          add_ldflags \""-Wl,--fix-cortex-a8\""\n \n-            enable_feature pic\n-            soft_enable realtime_only\n-            if [ ${tgt_isa} = \""armv7\"" ]; then\n-                soft_enable runtime_cpu_detect\n-            fi\n-            if enabled runtime_cpu_detect; then\n-                add_cflags \""-I${SDK_PATH}/sources/android/cpufeatures\""\n-            fi\n+          enable_feature pic\n+          soft_enable realtime_only\n+          if [ ${tgt_isa} = \""armv7\"" ]; then\n+            soft_enable runtime_cpu_detect\n+          fi\n+          if enabled runtime_cpu_detect; then\n+            add_cflags \""-I${SDK_PATH}/sources/android/cpufeatures\""\n+          fi\n           ;;\n \n         darwin*)\n+          XCRUN_FIND=\""xcrun --sdk iphoneos --find\""\n+          CXX=\""$(${XCRUN_FIND} clang++)\""\n+          CC=\""$(${XCRUN_FIND} clang)\""\n+          AR=\""$(${XCRUN_FIND} ar)\""\n+          AS=\""$(${XCRUN_FIND} as)\""\n+          STRIP=\""$(${XCRUN_FIND} strip)\""\n+          NM=\""$(${XCRUN_FIND} nm)\""\n+          RANLIB=\""$(${XCRUN_FIND} ranlib)\""\n+          AS_SFX=.s\n \n-            XCRUN_FIND=\""xcrun --sdk iphoneos -find\""\n-            CXX=\""$(${XCRUN_FIND} clang++)\""\n-            CC=\""$(${XCRUN_FIND} clang)\""\n-            AR=\""$(${XCRUN_FIND} ar)\""\n+          # Special handling of ld for armv6 because libclang_rt.ios.a does\n+          # not contain armv6 support in Apple's clang package:\n+          #   Apple LLVM version 5.1 (clang-503.0.40) (based on LLVM 3.4svn).\n+          # TODO(tomfinegan): Remove this. Our minimum iOS version (6.0)\n+          # renders support for armv6 unnecessary because the 3GS and up\n+          # support neon.\n+          if [ \""${tgt_isa}\"" = \""armv6\"" ]; then\n             LD=\""$(${XCRUN_FIND} ld)\""\n-            AS=\""$(${XCRUN_FIND} as)\""\n-            STRIP=\""$(${XCRUN_FIND} strip)\""\n-            NM=\""$(${XCRUN_FIND} nm)\""\n-            RANLIB=\""$(${XCRUN_FIND} ranlib)\""\n-            AS_SFX=.s\n+          else\n+            LD=\""${CXX:-$(${XCRUN_FIND} ld)}\""\n+          fi\n \n-            # ASFLAGS is written here instead of using check_add_asflags\n-            # because we need to overwrite all of ASFLAGS and purge the\n-            # options that were put in above\n-            ASFLAGS=\""-arch ${tgt_isa} -g\""\n+          # ASFLAGS is written here instead of using check_add_asflags\n+          # because we need to overwrite all of ASFLAGS and purge the\n+          # options that were put in above\n+          ASFLAGS=\""-arch ${tgt_isa} -g\""\n \n-            alt_libc=\""$(xcrun --sdk iphoneos --show-sdk-path)\""\n-            add_cflags -arch ${tgt_isa} -isysroot ${alt_libc}\n-            add_ldflags -arch ${tgt_isa} -ios_version_min 7.0\n+          add_cflags -arch ${tgt_isa}\n+          add_ldflags -arch ${tgt_isa}\n \n-            for d in lib usr/lib usr/lib/system; do\n-                try_dir=\""${alt_libc}/${d}\""\n-                [ -d \""${try_dir}\"" ] && add_ldflags -L\""${try_dir}\""\n-            done\n+          alt_libc=\""$(show_darwin_sdk_path iphoneos)\""\n+          if [ -d \""${alt_libc}\"" ]; then\n+            add_cflags -isysroot ${alt_libc}\n+          fi\n \n-            asm_conversion_cmd=\""${source_path}/build/make/ads2gas_apple.pl\""\n-         ;;\n+          if [ \""${LD}\"" = \""${CXX}\"" ]; then\n+            add_ldflags -miphoneos-version-min=\""${IOS_VERSION_MIN}\""\n+          else\n+            add_ldflags -ios_version_min \""${IOS_VERSION_MIN}\""\n+          fi\n+\n+          for d in lib usr/lib usr/lib/system; do\n+            try_dir=\""${alt_libc}/${d}\""\n+            [ -d \""${try_dir}\"" ] && add_ldflags -L\""${try_dir}\""\n+          done\n+\n+          asm_conversion_cmd=\""${source_path}/build/make/ads2gas_apple.pl\""\n+          ;;\n \n         linux*)\n-            enable_feature linux\n-            if enabled rvct; then\n-                # Check if we have CodeSourcery GCC in PATH. Needed for\n-                # libraries\n-                hash arm-none-linux-gnueabi-gcc 2>&- || \\\n-                  die \""Couldn't find CodeSourcery GCC from PATH\""\n+          enable_feature linux\n+          if enabled rvct; then\n+            # Check if we have CodeSourcery GCC in PATH. Needed for\n+            # libraries\n+            hash arm-none-linux-gnueabi-gcc 2>&- || \\\n+              die \""Couldn't find CodeSourcery GCC from PATH\""\n \n-                # Use armcc as a linker to enable translation of\n-                # some gcc specific options such as -lm and -lpthread.\n-                LD=\""armcc --translate_gcc\""\n+            # Use armcc as a linker to enable translation of\n+            # some gcc specific options such as -lm and -lpthread.\n+            LD=\""armcc --translate_gcc\""\n \n-                # create configuration file (uses path to CodeSourcery GCC)\n-                armcc --arm_linux_configure --arm_linux_config_file=arm_linux.cfg\n+            # create configuration file (uses path to CodeSourcery GCC)\n+            armcc --arm_linux_configure --arm_linux_config_file=arm_linux.cfg\n \n-                add_cflags --arm_linux_paths --arm_linux_config_file=arm_linux.cfg\n-                add_asflags --no_hide_all --apcs=/interwork\n-                add_ldflags --arm_linux_paths --arm_linux_config_file=arm_linux.cfg\n-                enabled pic && add_cflags --apcs=/fpic\n-                enabled pic && add_asflags --apcs=/fpic\n-                enabled shared && add_cflags --shared\n-            fi\n-        ;;\n-\n-        esac\n-    ;;\n+            add_cflags --arm_linux_paths --arm_linux_config_file=arm_linux.cfg\n+            add_asflags --no_hide_all --apcs=/interwork\n+            add_ldflags --arm_linux_paths --arm_linux_config_file=arm_linux.cfg\n+            enabled pic && add_cflags --apcs=/fpic\n+            enabled pic && add_asflags --apcs=/fpic\n+            enabled shared && add_cflags --shared\n+          fi\n+          ;;\n+      esac\n+      ;;\n     mips*)\n-        link_with_cc=gcc\n-        setup_gnu_toolchain\n-        tune_cflags=\""-mtune=\""\n-        if enabled dspr2; then\n-            check_add_cflags -mips32r2 -mdspr2\n-            disable_feature fast_unaligned\n-        fi\n-        check_add_cflags -march=${tgt_isa}\n-        check_add_asflags -march=${tgt_isa}\n-        check_add_asflags -KPIC\n-    ;;\n-    ppc*)\n-        enable_feature ppc\n-        bits=${tgt_isa##ppc}\n-        link_with_cc=gcc\n-        setup_gnu_toolchain\n-        add_asflags -force_cpusubtype_ALL -I\""\\$(dir \\$<)darwin\""\n-        soft_enable altivec\n-        enabled altivec && add_cflags -maltivec\n+      link_with_cc=gcc\n+      setup_gnu_toolchain\n+      tune_cflags=\""-mtune=\""\n+      if enabled dspr2; then\n+        check_add_cflags -mips32r2 -mdspr2\n+      fi\n \n-        case \""$tgt_os\"" in\n-        linux*)\n-            add_asflags -maltivec -mregnames -I\""\\$(dir \\$<)linux\""\n-        ;;\n-        darwin*)\n-            darwin_arch=\""-arch ppc\""\n-            enabled ppc64 && darwin_arch=\""${darwin_arch}64\""\n-            add_cflags  ${darwin_arch} -m${bits} -fasm-blocks\n-            add_asflags ${darwin_arch} -force_cpusubtype_ALL -I\""\\$(dir \\$<)darwin\""\n-            add_ldflags ${darwin_arch} -m${bits}\n-            enabled altivec && add_cflags -faltivec\n-        ;;\n+      if enabled runtime_cpu_detect; then\n+        disable_feature runtime_cpu_detect\n+      fi\n+\n+      if [ -n \""${tune_cpu}\"" ]; then\n+        case ${tune_cpu} in\n+          p5600)\n+            check_add_cflags -mips32r5 -funroll-loops -mload-store-pairs\n+            check_add_cflags -msched-weight -mhard-float -mfp64\n+            check_add_asflags -mips32r5 -mhard-float -mfp64\n+            check_add_ldflags -mfp64\n+            ;;\n+          i6400)\n+            check_add_cflags -mips64r6 -mabi=64 -funroll-loops -msched-weight \n+            check_add_cflags  -mload-store-pairs -mhard-float -mfp64\n+            check_add_asflags -mips64r6 -mabi=64 -mhard-float -mfp64\n+            check_add_ldflags -mips64r6 -mabi=64 -mfp64\n+            ;;\n         esac\n-    ;;\n+\n+        if enabled msa; then\n+          add_cflags -mmsa\n+          add_asflags -mmsa\n+          add_ldflags -mmsa\n+        fi\n+      fi\n+\n+      check_add_cflags -march=${tgt_isa}\n+      check_add_asflags -march=${tgt_isa}\n+      check_add_asflags -KPIC\n+      ;;\n     x86*)\n-        bits=32\n-        enabled x86_64 && bits=64\n-        check_cpp <<EOF && bits=x32\n-#ifndef __ILP32__\n+      case  ${tgt_os} in\n+        win*)\n+          enabled gcc && add_cflags -fno-common\n+          ;;\n+        solaris*)\n+          CC=${CC:-${CROSS}gcc}\n+          CXX=${CXX:-${CROSS}g++}\n+          LD=${LD:-${CROSS}gcc}\n+          CROSS=${CROSS:-g}\n+          ;;\n+        os2)\n+          AS=${AS:-nasm}\n+          ;;\n+      esac\n+\n+      AS=\""${alt_as:-${AS:-auto}}\""\n+      case  ${tgt_cc} in\n+        icc*)\n+          CC=${CC:-icc}\n+          LD=${LD:-icc}\n+          setup_gnu_toolchain\n+          add_cflags -use-msasm  # remove -use-msasm too?\n+          # add -no-intel-extensions to suppress warning #10237\n+          # refer to http://software.intel.com/en-us/forums/topic/280199\n+          add_ldflags -i-static -no-intel-extensions\n+          enabled x86_64 && add_cflags -ipo -static -O3 -no-prec-div\n+          enabled x86_64 && AR=xiar\n+          case ${tune_cpu} in\n+            atom*)\n+              tune_cflags=\""-x\""\n+              tune_cpu=\""SSE3_ATOM\""\n+              ;;\n+            *)\n+              tune_cflags=\""-march=\""\n+              ;;\n+          esac\n+          ;;\n+        gcc*)\n+          link_with_cc=gcc\n+          tune_cflags=\""-march=\""\n+          setup_gnu_toolchain\n+          #for 32 bit x86 builds, -O3 did not turn on this flag\n+          enabled optimizations && disabled gprof && check_add_cflags -fomit-frame-pointer\n+          ;;\n+        vs*)\n+          # When building with Microsoft Visual Studio the assembler is\n+          # invoked directly. Checking at configure time is unnecessary.\n+          # Skip the check by setting AS arbitrarily\n+          AS=msvs\n+          msvs_arch_dir=x86-msvs\n+          vc_version=${tgt_cc##vs}\n+          case $vc_version in\n+            7|8|9|10)\n+              echo \""${tgt_cc} does not support avx/avx2, disabling.....\""\n+              RTCD_OPTIONS=\""${RTCD_OPTIONS}--disable-avx --disable-avx2 \""\n+              soft_disable avx\n+              soft_disable avx2\n+              ;;\n+          esac\n+          ;;\n+      esac\n+\n+      bits=32\n+      enabled x86_64 && bits=64\n+      check_cpp <<EOF && bits=x32\n+#if !defined(__ILP32__) || !defined(__x86_64__)\n #error \""not x32\""\n #endif\n EOF\n+      case ${tgt_cc} in\n+        gcc*)\n+          add_cflags -m${bits}\n+          add_ldflags -m${bits}\n+          ;;\n+      esac\n \n-        case  ${tgt_os} in\n-            win*)\n-                enabled gcc && add_cflags -fno-common\n-                ;;\n-            solaris*)\n-                CC=${CC:-${CROSS}gcc}\n-                CXX=${CXX:-${CROSS}g++}\n-                LD=${LD:-${CROSS}gcc}\n-                CROSS=${CROSS:-g}\n-                ;;\n-            os2)\n-                AS=${AS:-nasm}\n-                ;;\n-        esac\n+      soft_enable runtime_cpu_detect\n+      # We can't use 'check_cflags' until the compiler is configured and CC is\n+      # populated.\n+      check_gcc_machine_option mmx\n+      check_gcc_machine_option sse\n+      check_gcc_machine_option sse2\n+      check_gcc_machine_option sse3\n+      check_gcc_machine_option ssse3\n+      check_gcc_machine_option sse4 sse4_1\n+      check_gcc_machine_option avx\n+      check_gcc_machine_option avx2\n \n-        AS=\""${alt_as:-${AS:-auto}}\""\n-        case  ${tgt_cc} in\n-            icc*)\n-                CC=${CC:-icc}\n-                LD=${LD:-icc}\n-                setup_gnu_toolchain\n-                add_cflags -use-msasm  # remove -use-msasm too?\n-                # add -no-intel-extensions to suppress warning #10237\n-                # refer to http://software.intel.com/en-us/forums/topic/280199\n-                add_ldflags -i-static -no-intel-extensions\n-                enabled x86_64 && add_cflags -ipo -static -O3 -no-prec-div\n-                enabled x86_64 && AR=xiar\n-                case ${tune_cpu} in\n-                    atom*)\n-                        tune_cflags=\""-x\""\n-                        tune_cpu=\""SSE3_ATOM\""\n-                    ;;\n-                    *)\n-                        tune_cflags=\""-march=\""\n-                    ;;\n-                esac\n-            ;;\n-            gcc*)\n-                add_cflags -m${bits}\n-                add_ldflags -m${bits}\n-                link_with_cc=gcc\n-                tune_cflags=\""-march=\""\n-                setup_gnu_toolchain\n-                #for 32 bit x86 builds, -O3 did not turn on this flag\n-                enabled optimizations && disabled gprof && check_add_cflags -fomit-frame-pointer\n-            ;;\n-            vs*)\n-                # When building with Microsoft Visual Studio the assembler is\n-                # invoked directly. Checking at configure time is unnecessary.\n-                # Skip the check by setting AS arbitrarily\n-                AS=msvs\n-                msvs_arch_dir=x86-msvs\n-                vc_version=${tgt_cc##vs}\n-                case $vc_version in\n-                    7|8|9|10)\n-                         echo \""${tgt_cc} does not support avx/avx2, disabling.....\""\n-                         RTCD_OPTIONS=\""${RTCD_OPTIONS}--disable-avx --disable-avx2 \""\n-                         soft_disable avx\n-                         soft_disable avx2\n-                    ;;\n-                esac\n-            ;;\n-        esac\n+      case \""${AS}\"" in\n+        auto|\""\"")\n+          which nasm >/dev/null 2>&1 && AS=nasm\n+          which yasm >/dev/null 2>&1 && AS=yasm\n+          if [ \""${AS}\"" = nasm ] ; then\n+            # Apple ships version 0.98 of nasm through at least Xcode 6. Revisit\n+            # this check if they start shipping a compatible version.\n+            apple=`nasm -v | grep \""Apple\""`\n+            [ -n \""${apple}\"" ] \\\n+              && echo \""Unsupported version of nasm: ${apple}\"" \\\n+              && AS=\""\""\n+          fi\n+          [ \""${AS}\"" = auto ] || [ -z \""${AS}\"" ] \\\n+            && die \""Neither yasm nor nasm have been found\""\n+          ;;\n+      esac\n+      log_echo \""  using $AS\""\n+      [ \""${AS##*/}\"" = nasm ] && add_asflags -Ox\n+      AS_SFX=.asm\n+      case  ${tgt_os} in\n+        win32)\n+          add_asflags -f win32\n+          enabled debug && add_asflags -g cv8\n+          EXE_SFX=.exe\n+          ;;\n+        win64)\n+          add_asflags -f x64\n+          enabled debug && add_asflags -g cv8\n+          EXE_SFX=.exe\n+          ;;\n+        linux*|solaris*|android*)\n+          add_asflags -f elf${bits}\n+          enabled debug && [ \""${AS}\"" = yasm ] && add_asflags -g dwarf2\n+          enabled debug && [ \""${AS}\"" = nasm ] && add_asflags -g\n+          [ \""${AS##*/}\"" = nasm ] && check_asm_align\n+          ;;\n+        darwin*)\n+          add_asflags -f macho${bits}\n+          enabled x86 && darwin_arch=\""-arch i386\"" || darwin_arch=\""-arch x86_64\""\n+          add_cflags  ${darwin_arch}\n+          add_ldflags ${darwin_arch}\n+          # -mdynamic-no-pic is still a bit of voodoo -- it was required at\n+          # one time, but does not seem to be now, and it breaks some of the\n+          # code that still relies on inline assembly.\n+          # enabled icc && ! enabled pic && add_cflags -fno-pic -mdynamic-no-pic\n+          enabled icc && ! enabled pic && add_cflags -fno-pic\n+          ;;\n+        iphonesimulator)\n+          add_asflags -f macho${bits}\n+          enabled x86 && sim_arch=\""-arch i386\"" || sim_arch=\""-arch x86_64\""\n+          add_cflags  ${sim_arch}\n+          add_ldflags ${sim_arch}\n+          ;;\n+        os2)\n+          add_asflags -f aout\n+          enabled debug && add_asflags -g\n+          EXE_SFX=.exe\n+          ;;\n+        *)\n+          log \""Warning: Unknown os $tgt_os while setting up $AS flags\""\n+          ;;\n+      esac\n+      ;;\n+    *-gcc|generic-gnu)\n+      link_with_cc=gcc\n+      enable_feature gcc\n+      setup_gnu_toolchain\n+      ;;\n+  esac\n \n-        soft_enable runtime_cpu_detect\n-        # We can't use 'check_cflags' until the compiler is configured and CC is\n-        # populated.\n-        check_gcc_machine_option mmx\n-        check_gcc_machine_option sse\n-        check_gcc_machine_option sse2\n-        check_gcc_machine_option sse3\n-        check_gcc_machine_option ssse3\n-        check_gcc_machine_option sse4 sse4_1\n-        check_gcc_machine_option avx\n-        check_gcc_machine_option avx2\n-\n-        case \""${AS}\"" in\n-            auto|\""\"")\n-                which nasm >/dev/null 2>&1 && AS=nasm\n-                which yasm >/dev/null 2>&1 && AS=yasm\n-                [ \""${AS}\"" = auto -o -z \""${AS}\"" ] \\\n-                    && die \""Neither yasm nor nasm have been found\""\n-            ;;\n-        esac\n-        log_echo \""  using $AS\""\n-        [ \""${AS##*/}\"" = nasm ] && add_asflags -Ox\n-        AS_SFX=.asm\n-        case  ${tgt_os} in\n-            win32)\n-                add_asflags -f win32\n-                enabled debug && add_asflags -g cv8\n-                EXE_SFX=.exe\n-            ;;\n-            win64)\n-                add_asflags -f x64\n-                enabled debug && add_asflags -g cv8\n-                EXE_SFX=.exe\n-            ;;\n-            linux*|solaris*|android*)\n-                add_asflags -f elf${bits}\n-                enabled debug && [ \""${AS}\"" = yasm ] && add_asflags -g dwarf2\n-                enabled debug && [ \""${AS}\"" = nasm ] && add_asflags -g\n-                [ \""${AS##*/}\"" = nasm ] && check_asm_align\n-            ;;\n-            darwin*)\n-                add_asflags -f macho${bits}\n-                enabled x86 && darwin_arch=\""-arch i386\"" || darwin_arch=\""-arch x86_64\""\n-                add_cflags  ${darwin_arch}\n-                add_ldflags ${darwin_arch}\n-                # -mdynamic-no-pic is still a bit of voodoo -- it was required at\n-                # one time, but does not seem to be now, and it breaks some of the\n-                # code that still relies on inline assembly.\n-                # enabled icc && ! enabled pic && add_cflags -fno-pic -mdynamic-no-pic\n-                enabled icc && ! enabled pic && add_cflags -fno-pic\n-            ;;\n-            os2)\n-                add_asflags -f aout\n-                enabled debug && add_asflags -g\n-                EXE_SFX=.exe\n-            ;;\n-            *) log \""Warning: Unknown os $tgt_os while setting up $AS flags\""\n-            ;;\n-        esac\n-    ;;\n-    universal*|*-gcc|generic-gnu)\n-        link_with_cc=gcc\n-        enable_feature gcc\n-    setup_gnu_toolchain\n-    ;;\n-    esac\n-\n-    # Try to enable CPU specific tuning\n-    if [ -n \""${tune_cpu}\"" ]; then\n-        if [ -n \""${tune_cflags}\"" ]; then\n-            check_add_cflags ${tune_cflags}${tune_cpu} || \\\n-                die \""Requested CPU '${tune_cpu}' not supported by compiler\""\n-        fi\n+  # Try to enable CPU specific tuning\n+  if [ -n \""${tune_cpu}\"" ]; then\n+    if [ -n \""${tune_cflags}\"" ]; then\n+      check_add_cflags ${tune_cflags}${tune_cpu} || \\\n+        die \""Requested CPU '${tune_cpu}' not supported by compiler\""\n+    fi\n     if [ -n \""${tune_asflags}\"" ]; then\n-            check_add_asflags ${tune_asflags}${tune_cpu} || \\\n-                die \""Requested CPU '${tune_cpu}' not supported by assembler\""\n-        fi\n+      check_add_asflags ${tune_asflags}${tune_cpu} || \\\n+        die \""Requested CPU '${tune_cpu}' not supported by assembler\""\n+    fi\n     if [ -z \""${tune_cflags}${tune_asflags}\"" ]; then\n-            log_echo \""Warning: CPU tuning not supported by this toolchain\""\n-        fi\n+      log_echo \""Warning: CPU tuning not supported by this toolchain\""\n     fi\n+  fi\n \n-    enabled debug && check_add_cflags -g && check_add_ldflags -g\n-    enabled gprof && check_add_cflags -pg && check_add_ldflags -pg\n-    enabled gcov &&\n-        check_add_cflags -fprofile-arcs -ftest-coverage &&\n-        check_add_ldflags -fprofile-arcs -ftest-coverage\n+  if enabled debug; then\n+    check_add_cflags -g && check_add_ldflags -g\n+  else\n+    check_add_cflags -DNDEBUG\n+  fi\n \n-    if enabled optimizations; then\n-        if enabled rvct; then\n-            enabled small && check_add_cflags -Ospace || check_add_cflags -Otime\n-        else\n-            enabled small && check_add_cflags -O2 ||  check_add_cflags -O3\n-        fi\n+  enabled gprof && check_add_cflags -pg && check_add_ldflags -pg\n+  enabled gcov &&\n+    check_add_cflags -fprofile-arcs -ftest-coverage &&\n+    check_add_ldflags -fprofile-arcs -ftest-coverage\n+\n+  if enabled optimizations; then\n+    if enabled rvct; then\n+      enabled small && check_add_cflags -Ospace || check_add_cflags -Otime\n+    else\n+      enabled small && check_add_cflags -O2 ||  check_add_cflags -O3\n     fi\n+  fi\n \n-    # default use_x86inc to yes if pic is no or 64bit or we are not on darwin\n-    if [ ${tgt_isa} = x86_64 -o ! \""$pic\"" = \""yes\"" -o \\\n-         \""${tgt_os#darwin}\"" = \""${tgt_os}\""  ]; then\n-      soft_enable use_x86inc\n-    fi\n+  if [ \""${tgt_isa}\"" = \""x86_64\"" ] || [ \""${tgt_isa}\"" = \""x86\"" ]; then\n+    soft_enable use_x86inc\n+  fi\n \n-    # Position Independent Code (PIC) support, for building relocatable\n-    # shared objects\n-    enabled gcc && enabled pic && check_add_cflags -fPIC\n+  # Position Independent Code (PIC) support, for building relocatable\n+  # shared objects\n+  enabled gcc && enabled pic && check_add_cflags -fPIC\n \n-    # Work around longjmp interception on glibc >= 2.11, to improve binary\n-    # compatibility. See http://code.google.com/p/webm/issues/detail?id=166\n-    enabled linux && check_add_cflags -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0\n+  # Work around longjmp interception on glibc >= 2.11, to improve binary\n+  # compatibility. See http://code.google.com/p/webm/issues/detail?id=166\n+  enabled linux && check_add_cflags -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0\n \n-    # Check for strip utility variant\n-    ${STRIP} -V 2>/dev/null | grep GNU >/dev/null && enable_feature gnu_strip\n+  # Check for strip utility variant\n+  ${STRIP} -V 2>/dev/null | grep GNU >/dev/null && enable_feature gnu_strip\n \n-    # Try to determine target endianness\n-    check_cc <<EOF\n-    unsigned int e = 'O'<<24 | '2'<<16 | 'B'<<8 | 'E';\n+  # Try to determine target endianness\n+  check_cc <<EOF\n+unsigned int e = 'O'<<24 | '2'<<16 | 'B'<<8 | 'E';\n EOF\n     [ -f \""${TMP_O}\"" ] && od -A n -t x1 \""${TMP_O}\"" | tr -d '\\n' |\n         grep '4f *32 *42 *45' >/dev/null 2>&1 && enable_feature big_endian\n \n     # Try to find which inline keywords are supported\n     check_cc <<EOF && INLINE=\""inline\""\n-    static inline function() {}\n-EOF\n-    check_cc <<EOF && INLINE=\""__inline__ __attribute__((always_inline))\""\n-    static __attribute__((always_inline)) function() {}\n+static inline function() {}\n EOF\n \n-    # Almost every platform uses pthreads.\n-    if enabled multithread; then\n-        case ${toolchain} in\n-            *-win*-vs*);;\n-            *-android-gcc);;\n-            *) check_header pthread.h && add_extralibs -lpthread\n-        esac\n-    fi\n-\n-    # only for MIPS platforms\n+  # Almost every platform uses pthreads.\n+  if enabled multithread; then\n     case ${toolchain} in\n-        mips*)\n-            if enabled dspr2; then\n-                if enabled big_endian; then\n-                    echo \""dspr2 optimizations are available only for little endian platforms\""\n-                    disable_feature dspr2\n-                fi\n-            fi\n+      *-win*-vs*)\n+        ;;\n+      *-android-gcc)\n+        ;;\n+      *)\n+        check_header pthread.h && add_extralibs -lpthread\n         ;;\n     esac\n+  fi\n \n-    # glibc needs these\n-    if enabled linux; then\n-        add_cflags -D_LARGEFILE_SOURCE\n-        add_cflags -D_FILE_OFFSET_BITS=64\n-    fi\n+  # only for MIPS platforms\n+  case ${toolchain} in\n+    mips*)\n+      if enabled big_endian; then\n+        if enabled dspr2; then\n+          echo \""dspr2 optimizations are available only for little endian platforms\""\n+          disable_feature dspr2\n+        fi\n+        if enabled msa; then\n+          echo \""msa optimizations are available only for little endian platforms\""\n+          disable_feature msa\n+        fi\n+      fi\n+      ;;\n+  esac\n \n-    # append any user defined extra cflags\n-    if [ -n \""${extra_cflags}\"" ] ; then\n-        check_add_cflags ${extra_cflags} || \\\n-        die \""Requested extra CFLAGS '${extra_cflags}' not supported by compiler\""\n-    fi\n+  # glibc needs these\n+  if enabled linux; then\n+    add_cflags -D_LARGEFILE_SOURCE\n+    add_cflags -D_FILE_OFFSET_BITS=64\n+  fi\n+\n+  # append any user defined extra cflags\n+  if [ -n \""${extra_cflags}\"" ] ; then\n+    check_add_cflags ${extra_cflags} || \\\n+    die \""Requested extra CFLAGS '${extra_cflags}' not supported by compiler\""\n+  fi\n }\n \n process_toolchain() {\n-    process_common_toolchain\n+  process_common_toolchain\n }\n \n print_config_mk() {\n-    local prefix=$1\n-    local makefile=$2\n-    shift 2\n-    for cfg; do\n-        upname=\""`toupper $cfg`\""\n-        if enabled $cfg; then\n-            echo \""${prefix}_${upname}=yes\"" >> $makefile\n-        fi\n-    done\n+  saved_prefix=\""${prefix}\""\n+  prefix=$1\n+  makefile=$2\n+  shift 2\n+  for cfg; do\n+    if enabled $cfg; then\n+      upname=\""`toupper $cfg`\""\n+      echo \""${prefix}_${upname}=yes\"" >> $makefile\n+    fi\n+  done\n+  prefix=\""${saved_prefix}\""\n }\n \n print_config_h() {\n-    local prefix=$1\n-    local header=$2\n+  saved_prefix=\""${prefix}\""\n+  prefix=$1\n+  header=$2\n+  shift 2\n+  for cfg; do\n+    upname=\""`toupper $cfg`\""\n+    if enabled $cfg; then\n+      echo \""#define ${prefix}_${upname} 1\"" >> $header\n+    else\n+      echo \""#define ${prefix}_${upname} 0\"" >> $header\n+    fi\n+  done\n+  prefix=\""${saved_prefix}\""\n+}\n+\n+print_config_vars_h() {\n+  header=$1\n+  shift\n+  while [ $# -gt 0 ]; do\n+    upname=\""`toupper $1`\""\n+    echo \""#define ${upname} $2\"" >> $header\n     shift 2\n-    for cfg; do\n-        upname=\""`toupper $cfg`\""\n-        if enabled $cfg; then\n-            echo \""#define ${prefix}_${upname} 1\"" >> $header\n-        else\n-            echo \""#define ${prefix}_${upname} 0\"" >> $header\n-        fi\n-    done\n+  done\n }\n \n print_webm_license() {\n-    local destination=$1\n-    local prefix=\""$2\""\n-    local suffix=\""$3\""\n-    shift 3\n-    cat <<EOF > ${destination}\n+  saved_prefix=\""${prefix}\""\n+  destination=$1\n+  prefix=\""$2\""\n+  suffix=\""$3\""\n+  shift 3\n+  cat <<EOF > ${destination}\n ${prefix} Copyright (c) 2011 The WebM project authors. All Rights Reserved.${suffix}\n ${prefix} ${suffix}\n ${prefix} Use of this source code is governed by a BSD-style license${suffix}\n@@ -1308,42 +1390,43 @@\n\n ${prefix} in the file PATENTS.  All contributing project authors may${suffix}\n ${prefix} be found in the AUTHORS file in the root of the source tree.${suffix}\n EOF\n+  prefix=\""${saved_prefix}\""\n }\n \n process_targets() {\n-    true;\n+  true;\n }\n \n process_detect() {\n-    true;\n+  true;\n }\n \n enable_feature logging\n logfile=\""config.log\""\n self=$0\n process() {\n-    cmdline_args=\""$@\""\n-    process_cmdline \""$@\""\n-    if enabled child; then\n-        echo \""# ${self} $@\"" >> ${logfile}\n-    else\n-        echo \""# ${self} $@\"" > ${logfile}\n-    fi\n-    post_process_common_cmdline\n-    post_process_cmdline\n-    process_toolchain\n-    process_detect\n-    process_targets\n+  cmdline_args=\""$@\""\n+  process_cmdline \""$@\""\n+  if enabled child; then\n+    echo \""# ${self} $@\"" >> ${logfile}\n+  else\n+    echo \""# ${self} $@\"" > ${logfile}\n+  fi\n+  post_process_common_cmdline\n+  post_process_cmdline\n+  process_toolchain\n+  process_detect\n+  process_targets\n \n-    OOT_INSTALLS=\""${OOT_INSTALLS}\""\n-    if enabled source_path_used; then\n-    # Prepare the PWD for building.\n-    for f in ${OOT_INSTALLS}; do\n-            install -D ${source_path}/$f $f\n-    done\n-    fi\n-    cp ${source_path}/build/make/Makefile .\n+  OOT_INSTALLS=\""${OOT_INSTALLS}\""\n+  if enabled source_path_used; then\n+  # Prepare the PWD for building.\n+  for f in ${OOT_INSTALLS}; do\n+    install -D \""${source_path}/$f\"" \""$f\""\n+  done\n+  fi\n+  cp \""${source_path}/build/make/Makefile\"" .\n \n-    clean_temp_files\n-    true\n+  clean_temp_files\n+  true\n }\n""}<_**next**_>{""filename"": ""libvpx/build/make/gen_msvs_proj.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/build/make/gen_msvs_proj.sh"", ""patch"": ""@@ -9,11 +9,11 @@\n\n ##  be found in the AUTHORS file in the root of the source tree.\n ##\n \n-\n self=$0\n self_basename=${self##*/}\n self_dirname=$(dirname \""$0\"")\n-EOL=$'\\n'\n+\n+. \""$self_dirname/msvs_common.sh\""|| exit 127\n \n show_help() {\n     cat <<EOF\n@@ -43,82 +43,6 @@\n\n     exit 1\n }\n \n-die() {\n-    echo \""${self_basename}: $@\"" >&2\n-    exit 1\n-}\n-\n-die_unknown(){\n-    echo \""Unknown option \\\""$1\\\"".\"" >&2\n-    echo \""See ${self_basename} --help for available options.\"" >&2\n-    exit 1\n-}\n-\n-generate_uuid() {\n-    local hex=\""0123456789ABCDEF\""\n-    local i\n-    local uuid=\""\""\n-    local j\n-    #93995380-89BD-4b04-88EB-625FBE52EBFB\n-    for ((i=0; i<32; i++)); do\n-        (( j = $RANDOM % 16 ))\n-        uuid=\""${uuid}${hex:$j:1}\""\n-    done\n-    echo \""${uuid:0:8}-${uuid:8:4}-${uuid:12:4}-${uuid:16:4}-${uuid:20:12}\""\n-}\n-\n-indent1=\""    \""\n-indent=\""\""\n-indent_push() {\n-    indent=\""${indent}${indent1}\""\n-}\n-indent_pop() {\n-    indent=\""${indent%${indent1}}\""\n-}\n-\n-tag_attributes() {\n-    for opt in \""$@\""; do\n-        optval=\""${opt#*=}\""\n-        [ -n \""${optval}\"" ] ||\n-            die \""Missing attribute value in '$opt' while generating $tag tag\""\n-        echo \""${indent}${opt%%=*}=\\\""${optval}\\\""\""\n-    done\n-}\n-\n-open_tag() {\n-    local tag=$1\n-    shift\n-    if [ $# -ne 0 ]; then\n-        echo \""${indent}<${tag}\""\n-        indent_push\n-        tag_attributes \""$@\""\n-        echo \""${indent}>\""\n-    else\n-        echo \""${indent}<${tag}>\""\n-        indent_push\n-    fi\n-}\n-\n-close_tag() {\n-    local tag=$1\n-    indent_pop\n-    echo \""${indent}</${tag}>\""\n-}\n-\n-tag() {\n-    local tag=$1\n-    shift\n-    if [ $# -ne 0 ]; then\n-        echo \""${indent}<${tag}\""\n-        indent_push\n-        tag_attributes \""$@\""\n-        indent_pop\n-        echo \""${indent}/>\""\n-    else\n-        echo \""${indent}<${tag}/>\""\n-    fi\n-}\n-\n generate_filter() {\n     local var=$1\n     local name=$2\n@@ -143,10 +67,16 @@\n\n             if [ \""${f##*.}\"" == \""$pat\"" ]; then\n                 unset file_list[i]\n \n-                objf=$(echo ${f%.*}.obj | sed -e 's/^[\\./]\\+//g' -e 's,/,_,g')\n-                open_tag File RelativePath=\""./$f\""\n+                objf=$(echo ${f%.*}.obj \\\n+                       | sed -e \""s,$src_path_bare,,\"" \\\n+                             -e 's/^[\\./]\\+//g' -e 's,[:/ ],_,g')\n+                open_tag File RelativePath=\""$f\""\n \n                 if [ \""$pat\"" == \""asm\"" ] && $asm_use_custom_step; then\n+                    # Avoid object file name collisions, i.e. vpx_config.c and\n+                    # vpx_config.asm produce the same object file without\n+                    # this additional suffix.\n+                    objf=${objf%.obj}_asm.obj\n                     for plat in \""${platforms[@]}\""; do\n                         for cfg in Debug Release; do\n                             open_tag FileConfiguration \\\n@@ -211,7 +141,9 @@\n\n         ;;\n         --lib) proj_kind=\""lib\""\n         ;;\n-        --src-path-bare=*) src_path_bare=\""$optval\""\n+        --src-path-bare=*)\n+            src_path_bare=$(fix_path \""$optval\"")\n+            src_path_bare=${src_path_bare%/}\n         ;;\n         --static-crt) use_static_runtime=true\n         ;;\n@@ -225,9 +157,11 @@\n\n             esac\n         ;;\n         -I*)\n+            opt=${opt##-I}\n+            opt=$(fix_path \""$opt\"")\n             opt=\""${opt%/}\""\n-            incs=\""${incs}${incs:+;}&quot;${opt##-I}&quot;\""\n-            yasmincs=\""${yasmincs} ${opt}\""\n+            incs=\""${incs}${incs:+;}&quot;${opt}&quot;\""\n+            yasmincs=\""${yasmincs} -I&quot;${opt}&quot;\""\n         ;;\n         -D*) defines=\""${defines}${defines:+;}${opt##-D}\""\n         ;;\n@@ -236,9 +170,11 @@\n\n                 libdirs=\""${libdirs}${libdirs:+;}&quot;\\$(OutDir)&quot;\""\n             else\n                  # Also try directories for this platform/configuration\n-                 libdirs=\""${libdirs}${libdirs:+;}&quot;${opt##-L}&quot;\""\n-                 libdirs=\""${libdirs}${libdirs:+;}&quot;${opt##-L}/\\$(PlatformName)/\\$(ConfigurationName)&quot;\""\n-                 libdirs=\""${libdirs}${libdirs:+;}&quot;${opt##-L}/\\$(PlatformName)&quot;\""\n+                 opt=${opt##-L}\n+                 opt=$(fix_path \""$opt\"")\n+                 libdirs=\""${libdirs}${libdirs:+;}&quot;${opt}&quot;\""\n+                 libdirs=\""${libdirs}${libdirs:+;}&quot;${opt}/\\$(PlatformName)/\\$(ConfigurationName)&quot;\""\n+                 libdirs=\""${libdirs}${libdirs:+;}&quot;${opt}/\\$(PlatformName)&quot;\""\n             fi\n         ;;\n         -l*) libs=\""${libs}${libs:+ }${opt##-l}.lib\""\n@@ -246,6 +182,7 @@\n\n         -*) die_unknown $opt\n         ;;\n         *)\n+            # The paths in file_list are fixed outside of the loop.\n             file_list[${#file_list[@]}]=\""$opt\""\n             case \""$opt\"" in\n                  *.asm) uses_asm=true\n@@ -254,6 +191,10 @@\n\n         ;;\n     esac\n done\n+\n+# Make one call to fix_path for file_list to improve performance.\n+fix_file_list\n+\n outfile=${outfile:-/dev/stdout}\n guid=${guid:-`generate_uuid`}\n asm_use_custom_step=false\n@@ -308,13 +249,13 @@\n\n case \""$target\"" in\n     x86_64*)\n         platforms[0]=\""x64\""\n-        asm_Debug_cmdline=\""yasm -Xvc -g cv8 -f \\$(PlatformName) ${yasmincs} &quot;\\$(InputPath)&quot;\""\n-        asm_Release_cmdline=\""yasm -Xvc -f \\$(PlatformName) ${yasmincs} &quot;\\$(InputPath)&quot;\""\n+        asm_Debug_cmdline=\""yasm -Xvc -g cv8 -f win64 ${yasmincs} &quot;\\$(InputPath)&quot;\""\n+        asm_Release_cmdline=\""yasm -Xvc -f win64 ${yasmincs} &quot;\\$(InputPath)&quot;\""\n     ;;\n     x86*)\n         platforms[0]=\""Win32\""\n-        asm_Debug_cmdline=\""yasm -Xvc -g cv8 -f \\$(PlatformName) ${yasmincs} &quot;\\$(InputPath)&quot;\""\n-        asm_Release_cmdline=\""yasm -Xvc -f \\$(PlatformName) ${yasmincs} &quot;\\$(InputPath)&quot;\""\n+        asm_Debug_cmdline=\""yasm -Xvc -g cv8 -f win32 ${yasmincs} &quot;\\$(InputPath)&quot;\""\n+        asm_Release_cmdline=\""yasm -Xvc -f win32 ${yasmincs} &quot;\\$(InputPath)&quot;\""\n     ;;\n     *) die \""Unsupported target $target!\""\n     ;;\n@@ -358,23 +299,8 @@\n\n         case \""$target\"" in\n             x86*)\n                 case \""$name\"" in\n-                    obj_int_extract)\n-                        tag Tool \\\n-                            Name=\""VCCLCompilerTool\"" \\\n-                            Optimization=\""0\"" \\\n-                            AdditionalIncludeDirectories=\""$incs\"" \\\n-                            PreprocessorDefinitions=\""WIN32;DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;_CRT_SECURE_NO_DEPRECATE\"" \\\n-                            RuntimeLibrary=\""$debug_runtime\"" \\\n-                            WarningLevel=\""3\"" \\\n-                            DebugInformationFormat=\""1\"" \\\n-                            $warn_64bit \\\n-                    ;;\n                     vpx)\n                         tag Tool \\\n-                            Name=\""VCPreBuildEventTool\"" \\\n-                            CommandLine=\""call obj_int_extract.bat $src_path_bare $plat_no_ws\\\\\\$(ConfigurationName)\"" \\\n-\n-                        tag Tool \\\n                             Name=\""VCCLCompilerTool\"" \\\n                             Optimization=\""0\"" \\\n                             AdditionalIncludeDirectories=\""$incs\"" \\\n@@ -410,11 +336,6 @@\n\n                 case \""$target\"" in\n                     x86*)\n                         case \""$name\"" in\n-                            obj_int_extract)\n-                                tag Tool \\\n-                                    Name=\""VCLinkerTool\"" \\\n-                                    GenerateDebugInformation=\""true\"" \\\n-                            ;;\n                             *)\n                                 tag Tool \\\n                                     Name=\""VCLinkerTool\"" \\\n@@ -463,25 +384,8 @@\n\n         case \""$target\"" in\n             x86*)\n                 case \""$name\"" in\n-                    obj_int_extract)\n-                        tag Tool \\\n-                            Name=\""VCCLCompilerTool\"" \\\n-                            Optimization=\""2\"" \\\n-                            FavorSizeorSpeed=\""1\"" \\\n-                            AdditionalIncludeDirectories=\""$incs\"" \\\n-                            PreprocessorDefinitions=\""WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;_CRT_SECURE_NO_DEPRECATE\"" \\\n-                            RuntimeLibrary=\""$release_runtime\"" \\\n-                            UsePrecompiledHeader=\""0\"" \\\n-                            WarningLevel=\""3\"" \\\n-                            DebugInformationFormat=\""0\"" \\\n-                            $warn_64bit \\\n-                    ;;\n                     vpx)\n                         tag Tool \\\n-                            Name=\""VCPreBuildEventTool\"" \\\n-                            CommandLine=\""call obj_int_extract.bat $src_path_bare $plat_no_ws\\\\\\$(ConfigurationName)\"" \\\n-\n-                        tag Tool \\\n                             Name=\""VCCLCompilerTool\"" \\\n                             Optimization=\""2\"" \\\n                             FavorSizeorSpeed=\""1\"" \\\n@@ -519,11 +423,6 @@\n\n                 case \""$target\"" in\n                     x86*)\n                         case \""$name\"" in\n-                            obj_int_extract)\n-                                tag Tool \\\n-                                    Name=\""VCLinkerTool\"" \\\n-                                    GenerateDebugInformation=\""true\"" \\\n-                            ;;\n                             *)\n                                 tag Tool \\\n                                     Name=\""VCLinkerTool\"" \\\n""}<_**next**_>{""filename"": ""libvpx/build/make/gen_msvs_sln.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/build/make/gen_msvs_sln.sh"", ""patch"": ""@@ -19,13 +19,13 @@\n\n     cat <<EOF\n Usage: ${self_basename} [options] file1 [file2 ...]\n \n-This script generates a Visual Studio 2005 solution file from a list of project\n+This script generates a Visual Studio solution file from a list of project\n files.\n \n Options:\n     --help                      Print this message\n     --out=outfile               Redirect output to a file\n-    --ver=version               Version (7,8,9,10,11) of visual studio to generate for\n+    --ver=version               Version (7,8,9,10,11,12,14) of visual studio to generate for\n     --target=isa-os-cc          Target specifier\n EOF\n     exit 1\n@@ -255,7 +255,7 @@\n\n     ;;\n     --ver=*) vs_ver=\""$optval\""\n              case $optval in\n-             [789]|10|11|12)\n+             [789]|10|11|12|14)\n              ;;\n              *) die Unrecognized Visual Studio Version in $opt\n              ;;\n@@ -300,12 +300,15 @@\n\n     12) sln_vers=\""12.00\""\n        sln_vers_str=\""Visual Studio 2013\""\n     ;;\n+    14) sln_vers=\""14.00\""\n+       sln_vers_str=\""Visual Studio 2015\""\n+    ;;\n esac\n case \""${vs_ver:-8}\"" in\n     [789])\n     sfx=vcproj\n     ;;\n-    10|11|12)\n+    10|11|12|14)\n     sfx=vcxproj\n     ;;\n esac\n""}<_**next**_>{""filename"": ""libvpx/build/make/gen_msvs_vcxproj.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/build/make/gen_msvs_vcxproj.sh"", ""patch"": ""@@ -9,11 +9,11 @@\n\n ##  be found in the AUTHORS file in the root of the source tree.\n ##\n \n-\n self=$0\n self_basename=${self##*/}\n self_dirname=$(dirname \""$0\"")\n-EOL=$'\\n'\n+\n+. \""$self_dirname/msvs_common.sh\""|| exit 127\n \n show_help() {\n     cat <<EOF\n@@ -34,7 +34,7 @@\n\n     --name=project_name         Name of the project (required)\n     --proj-guid=GUID            GUID to use for the project\n     --module-def=filename       File containing export definitions (for DLLs)\n-    --ver=version               Version (10,11,12) of visual studio to generate for\n+    --ver=version               Version (10,11,12,14) of visual studio to generate for\n     --src-path-bare=dir         Path to root of source tree\n     -Ipath/to/include           Additional include directories\n     -DFLAG[=value]              Preprocessor macros to define\n@@ -44,82 +44,6 @@\n\n     exit 1\n }\n \n-die() {\n-    echo \""${self_basename}: $@\"" >&2\n-    exit 1\n-}\n-\n-die_unknown(){\n-    echo \""Unknown option \\\""$1\\\"".\"" >&2\n-    echo \""See ${self_basename} --help for available options.\"" >&2\n-    exit 1\n-}\n-\n-generate_uuid() {\n-    local hex=\""0123456789ABCDEF\""\n-    local i\n-    local uuid=\""\""\n-    local j\n-    #93995380-89BD-4b04-88EB-625FBE52EBFB\n-    for ((i=0; i<32; i++)); do\n-        (( j = $RANDOM % 16 ))\n-        uuid=\""${uuid}${hex:$j:1}\""\n-    done\n-    echo \""${uuid:0:8}-${uuid:8:4}-${uuid:12:4}-${uuid:16:4}-${uuid:20:12}\""\n-}\n-\n-indent1=\""    \""\n-indent=\""\""\n-indent_push() {\n-    indent=\""${indent}${indent1}\""\n-}\n-indent_pop() {\n-    indent=\""${indent%${indent1}}\""\n-}\n-\n-tag_attributes() {\n-    for opt in \""$@\""; do\n-        optval=\""${opt#*=}\""\n-        [ -n \""${optval}\"" ] ||\n-            die \""Missing attribute value in '$opt' while generating $tag tag\""\n-        echo \""${indent}${opt%%=*}=\\\""${optval}\\\""\""\n-    done\n-}\n-\n-open_tag() {\n-    local tag=$1\n-    shift\n-    if [ $# -ne 0 ]; then\n-        echo \""${indent}<${tag}\""\n-        indent_push\n-        tag_attributes \""$@\""\n-        echo \""${indent}>\""\n-    else\n-        echo \""${indent}<${tag}>\""\n-        indent_push\n-    fi\n-}\n-\n-close_tag() {\n-    local tag=$1\n-    indent_pop\n-    echo \""${indent}</${tag}>\""\n-}\n-\n-tag() {\n-    local tag=$1\n-    shift\n-    if [ $# -ne 0 ]; then\n-        echo \""${indent}<${tag}\""\n-        indent_push\n-        tag_attributes \""$@\""\n-        indent_pop\n-        echo \""${indent}/>\""\n-    else\n-        echo \""${indent}<${tag}/>\""\n-    fi\n-}\n-\n tag_content() {\n     local tag=$1\n     local content=$2\n@@ -154,7 +78,9 @@\n\n             if [ \""${f##*.}\"" == \""$pat\"" ]; then\n                 unset file_list[i]\n \n-                objf=$(echo ${f%.*}.obj | sed -e 's/^[\\./]\\+//g' -e 's,/,_,g')\n+                objf=$(echo ${f%.*}.obj \\\n+                       | sed -e \""s,$src_path_bare,,\"" \\\n+                             -e 's/^[\\./]\\+//g' -e 's,[:/ ],_,g')\n \n                 if ([ \""$pat\"" == \""asm\"" ] || [ \""$pat\"" == \""s\"" ]) && $asm_use_custom_step; then\n                     # Avoid object file name collisions, i.e. vpx_config.c and\n@@ -162,7 +88,7 @@\n\n                     # this additional suffix.\n                     objf=${objf%.obj}_asm.obj\n                     open_tag CustomBuild \\\n-                        Include=\"".\\\\$f\""\n+                        Include=\""$f\""\n                     for plat in \""${platforms[@]}\""; do\n                         for cfg in Debug Release; do\n                             tag_content Message \""Assembling %(Filename)%(Extension)\"" \\\n@@ -177,7 +103,7 @@\n\n                 elif [ \""$pat\"" == \""c\"" ] || \\\n                      [ \""$pat\"" == \""cc\"" ] || [ \""$pat\"" == \""cpp\"" ]; then\n                     open_tag ClCompile \\\n-                        Include=\"".\\\\$f\""\n+                        Include=\""$f\""\n                     # Separate file names with Condition?\n                     tag_content ObjectFileName \""\\$(IntDir)$objf\""\n                     # Check for AVX and turn it on to avoid warnings.\n@@ -187,7 +113,7 @@\n\n                     close_tag ClCompile\n                 elif [ \""$pat\"" == \""h\"" ] ; then\n                     tag ClInclude \\\n-                        Include=\"".\\\\$f\""\n+                        Include=\""$f\""\n                 elif [ \""$pat\"" == \""vcxproj\"" ] ; then\n                     open_tag ProjectReference \\\n                         Include=\""$f\""\n@@ -197,7 +123,7 @@\n\n                     close_tag ProjectReference\n                 else\n                     tag None \\\n-                        Include=\"".\\\\$f\""\n+                        Include=\""$f\""\n                 fi\n \n                 break\n@@ -231,7 +157,9 @@\n\n         ;;\n         --lib) proj_kind=\""lib\""\n         ;;\n-        --src-path-bare=*) src_path_bare=\""$optval\""\n+        --src-path-bare=*)\n+            src_path_bare=$(fix_path \""$optval\"")\n+            src_path_bare=${src_path_bare%/}\n         ;;\n         --static-crt) use_static_runtime=true\n         ;;\n@@ -240,27 +168,31 @@\n\n         --ver=*)\n             vs_ver=\""$optval\""\n             case \""$optval\"" in\n-                10|11|12)\n+                10|11|12|14)\n                 ;;\n                 *) die Unrecognized Visual Studio Version in $opt\n                 ;;\n             esac\n         ;;\n         -I*)\n+            opt=${opt##-I}\n+            opt=$(fix_path \""$opt\"")\n             opt=\""${opt%/}\""\n-            incs=\""${incs}${incs:+;}${opt##-I}\""\n-            yasmincs=\""${yasmincs} ${opt}\""\n+            incs=\""${incs}${incs:+;}&quot;${opt}&quot;\""\n+            yasmincs=\""${yasmincs} -I&quot;${opt}&quot;\""\n         ;;\n         -D*) defines=\""${defines}${defines:+;}${opt##-D}\""\n         ;;\n         -L*) # fudge . to $(OutDir)\n             if [ \""${opt##-L}\"" == \"".\"" ]; then\n-                libdirs=\""${libdirs}${libdirs:+;}\\$(OutDir)\""\n+                libdirs=\""${libdirs}${libdirs:+;}&quot;\\$(OutDir)&quot;\""\n             else\n                  # Also try directories for this platform/configuration\n-                 libdirs=\""${libdirs}${libdirs:+;}${opt##-L}\""\n-                 libdirs=\""${libdirs}${libdirs:+;}${opt##-L}/\\$(PlatformName)/\\$(Configuration)\""\n-                 libdirs=\""${libdirs}${libdirs:+;}${opt##-L}/\\$(PlatformName)\""\n+                 opt=${opt##-L}\n+                 opt=$(fix_path \""$opt\"")\n+                 libdirs=\""${libdirs}${libdirs:+;}&quot;${opt}&quot;\""\n+                 libdirs=\""${libdirs}${libdirs:+;}&quot;${opt}/\\$(PlatformName)/\\$(Configuration)&quot;\""\n+                 libdirs=\""${libdirs}${libdirs:+;}&quot;${opt}/\\$(PlatformName)&quot;\""\n             fi\n         ;;\n         -l*) libs=\""${libs}${libs:+ }${opt##-l}.lib\""\n@@ -268,6 +200,7 @@\n\n         -*) die_unknown $opt\n         ;;\n         *)\n+            # The paths in file_list are fixed outside of the loop.\n             file_list[${#file_list[@]}]=\""$opt\""\n             case \""$opt\"" in\n                  *.asm|*.s) uses_asm=true\n@@ -276,12 +209,16 @@\n\n         ;;\n     esac\n done\n+\n+# Make one call to fix_path for file_list to improve performance.\n+fix_file_list\n+\n outfile=${outfile:-/dev/stdout}\n guid=${guid:-`generate_uuid`}\n asm_use_custom_step=false\n uses_asm=${uses_asm:-false}\n case \""${vs_ver:-11}\"" in\n-    10|11|12)\n+    10|11|12|14)\n        asm_use_custom_step=$uses_asm\n     ;;\n esac\n@@ -316,24 +253,18 @@\n\n case \""$target\"" in\n     x86_64*)\n         platforms[0]=\""x64\""\n-        asm_Debug_cmdline=\""yasm -Xvc -g cv8 -f \\$(PlatformName) ${yasmincs} &quot;%(FullPath)&quot;\""\n-        asm_Release_cmdline=\""yasm -Xvc -f \\$(PlatformName) ${yasmincs} &quot;%(FullPath)&quot;\""\n+        asm_Debug_cmdline=\""yasm -Xvc -g cv8 -f win64 ${yasmincs} &quot;%(FullPath)&quot;\""\n+        asm_Release_cmdline=\""yasm -Xvc -f win64 ${yasmincs} &quot;%(FullPath)&quot;\""\n     ;;\n     x86*)\n         platforms[0]=\""Win32\""\n-        asm_Debug_cmdline=\""yasm -Xvc -g cv8 -f \\$(PlatformName) ${yasmincs} &quot;%(FullPath)&quot;\""\n-        asm_Release_cmdline=\""yasm -Xvc -f \\$(PlatformName) ${yasmincs} &quot;%(FullPath)&quot;\""\n+        asm_Debug_cmdline=\""yasm -Xvc -g cv8 -f win32 ${yasmincs} &quot;%(FullPath)&quot;\""\n+        asm_Release_cmdline=\""yasm -Xvc -f win32 ${yasmincs} &quot;%(FullPath)&quot;\""\n     ;;\n     arm*)\n-        asm_Debug_cmdline=\""armasm -nologo &quot;%(FullPath)&quot;\""\n-        asm_Release_cmdline=\""armasm -nologo &quot;%(FullPath)&quot;\""\n-        if [ \""$name\"" = \""obj_int_extract\"" ]; then\n-            # We don't want to build this tool for the target architecture,\n-            # but for an architecture we can run locally during the build.\n-            platforms[0]=\""Win32\""\n-        else\n-            platforms[0]=\""ARM\""\n-        fi\n+        platforms[0]=\""ARM\""\n+        asm_Debug_cmdline=\""armasm -nologo -oldit &quot;%(FullPath)&quot;\""\n+        asm_Release_cmdline=\""armasm -nologo -oldit &quot;%(FullPath)&quot;\""\n     ;;\n     *) die \""Unsupported target $target!\""\n     ;;\n@@ -364,6 +295,18 @@\n\n         tag_content ProjectGuid \""{${guid}}\""\n         tag_content RootNamespace ${name}\n         tag_content Keyword ManagedCProj\n+        if [ $vs_ver -ge 12 ] && [ \""${platforms[0]}\"" = \""ARM\"" ]; then\n+            tag_content AppContainerApplication true\n+            # The application type can be one of \""Windows Store\"",\n+            # \""Windows Phone\"" or \""Windows Phone Silverlight\"". The\n+            # actual value doesn't matter from the libvpx point of view,\n+            # since a static library built for one works on the others.\n+            # The PlatformToolset field needs to be set in sync with this;\n+            # for Windows Store and Windows Phone Silverlight it should be\n+            # v120 while it should be v120_wp81 if the type is Windows Phone.\n+            tag_content ApplicationType \""Windows Store\""\n+            tag_content ApplicationTypeRevision 8.1\n+        fi\n     close_tag PropertyGroup\n \n     tag Import \\\n@@ -396,18 +339,13 @@\n\n                 fi\n             fi\n             if [ \""$vs_ver\"" = \""12\"" ]; then\n-                if [ \""$plat\"" = \""ARM\"" ]; then\n-                    # Setting the wp80 toolchain automatically sets the\n-                    # WINAPI_FAMILY define, which is required for building\n-                    # code for arm with the windows headers. Alternatively,\n-                    # one could add AppContainerApplication=true in the Globals\n-                    # section and add PrecompiledHeader=NotUsing and\n-                    # CompileAsWinRT=false in ClCompile and SubSystem=Console\n-                    # in Link.\n-                    tag_content PlatformToolset v120_wp80\n-                else\n-                    tag_content PlatformToolset v120\n-                fi\n+                # Setting a PlatformToolset indicating windows phone isn't\n+                # enough to build code for arm with MSVC 2013, one strictly\n+                # has to enable AppContainerApplication as well.\n+                tag_content PlatformToolset v120\n+            fi\n+            if [ \""$vs_ver\"" = \""14\"" ]; then\n+                tag_content PlatformToolset v140\n             fi\n             tag_content CharacterSet Unicode\n             if [ \""$config\"" = \""Release\"" ]; then\n@@ -459,23 +397,13 @@\n\n                 if [ \""$hostplat\"" == \""ARM\"" ]; then\n                     hostplat=Win32\n                 fi\n-                open_tag PreBuildEvent\n-                tag_content Command \""call obj_int_extract.bat $src_path_bare $hostplat\\\\\\$(Configuration)\""\n-                close_tag PreBuildEvent\n             fi\n             open_tag ClCompile\n             if [ \""$config\"" = \""Debug\"" ]; then\n                 opt=Disabled\n                 runtime=$debug_runtime\n                 curlibs=$debug_libs\n-                case \""$name\"" in\n-                obj_int_extract)\n-                    debug=DEBUG\n-                    ;;\n-                *)\n-                    debug=_DEBUG\n-                    ;;\n-                esac\n+                debug=_DEBUG\n             else\n                 opt=MaxSpeed\n                 runtime=$release_runtime\n@@ -483,14 +411,7 @@\n\n                 tag_content FavorSizeOrSpeed Speed\n                 debug=NDEBUG\n             fi\n-            case \""$name\"" in\n-            obj_int_extract)\n-                extradefines=\"";_CONSOLE\""\n-                ;;\n-            *)\n-                extradefines=\"";$defines\""\n-                ;;\n-            esac\n+            extradefines=\"";$defines\""\n             tag_content Optimization $opt\n             tag_content AdditionalIncludeDirectories \""$incs;%(AdditionalIncludeDirectories)\""\n             tag_content PreprocessorDefinitions \""WIN32;$debug;_CRT_SECURE_NO_WARNINGS;_CRT_SECURE_NO_DEPRECATE$extradefines;%(PreprocessorDefinitions)\""\n@@ -499,15 +420,21 @@\n\n             if ${werror:-false}; then\n                 tag_content TreatWarningAsError true\n             fi\n+            if [ $vs_ver -ge 11 ]; then\n+                # We need to override the defaults for these settings\n+                # if AppContainerApplication is set.\n+                tag_content CompileAsWinRT false\n+                tag_content PrecompiledHeader NotUsing\n+                tag_content SDLCheck false\n+            fi\n             close_tag ClCompile\n             case \""$proj_kind\"" in\n             exe)\n                 open_tag Link\n-                if [ \""$name\"" != \""obj_int_extract\"" ]; then\n-                    tag_content AdditionalDependencies \""$curlibs\""\n-                    tag_content AdditionalLibraryDirectories \""$libdirs;%(AdditionalLibraryDirectories)\""\n-                fi\n                 tag_content GenerateDebugInformation true\n+                # Console is the default normally, but if\n+                # AppContainerApplication is set, we need to override it.\n+                tag_content SubSystem Console\n                 close_tag Link\n                 ;;\n             dll)\n""}<_**next**_>{""filename"": ""libvpx/build/make/iosbuild.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/build/make/iosbuild.sh"", ""patch"": ""@@ -0,0 +1,274 @@\n\n+#!/bin/sh\n+##\n+##  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+##\n+##  Use of this source code is governed by a BSD-style license\n+##  that can be found in the LICENSE file in the root of the source\n+##  tree. An additional intellectual property rights grant can be found\n+##  in the file PATENTS.  All contributing project authors may\n+##  be found in the AUTHORS file in the root of the source tree.\n+##\n+##\n+## This script generates 'VPX.framework'. An iOS app can encode and decode VPx\n+## video by including 'VPX.framework'.\n+##\n+## Run iosbuild.sh to create 'VPX.framework' in the current directory.\n+##\n+set -e\n+devnull='> /dev/null 2>&1'\n+\n+BUILD_ROOT=\""_iosbuild\""\n+CONFIGURE_ARGS=\""--disable-docs\n+                --disable-examples\n+                --disable-libyuv\n+                --disable-unit-tests\""\n+DIST_DIR=\""_dist\""\n+FRAMEWORK_DIR=\""VPX.framework\""\n+HEADER_DIR=\""${FRAMEWORK_DIR}/Headers/vpx\""\n+MAKE_JOBS=1\n+SCRIPT_DIR=$(dirname \""$0\"")\n+LIBVPX_SOURCE_DIR=$(cd ${SCRIPT_DIR}/../..; pwd)\n+LIPO=$(xcrun -sdk iphoneos${SDK} -find lipo)\n+ORIG_PWD=\""$(pwd)\""\n+TARGETS=\""arm64-darwin-gcc\n+         armv7-darwin-gcc\n+         armv7s-darwin-gcc\n+         x86-iphonesimulator-gcc\n+         x86_64-iphonesimulator-gcc\""\n+\n+# Configures for the target specified by $1, and invokes make with the dist\n+# target using $DIST_DIR as the distribution output directory.\n+build_target() {\n+  local target=\""$1\""\n+  local old_pwd=\""$(pwd)\""\n+\n+  vlog \""***Building target: ${target}***\""\n+\n+  mkdir \""${target}\""\n+  cd \""${target}\""\n+  eval \""${LIBVPX_SOURCE_DIR}/configure\"" --target=\""${target}\"" \\\n+    ${CONFIGURE_ARGS} ${EXTRA_CONFIGURE_ARGS} ${devnull}\n+  export DIST_DIR\n+  eval make -j ${MAKE_JOBS} dist ${devnull}\n+  cd \""${old_pwd}\""\n+\n+  vlog \""***Done building target: ${target}***\""\n+}\n+\n+# Returns the preprocessor symbol for the target specified by $1.\n+target_to_preproc_symbol() {\n+  target=\""$1\""\n+  case \""${target}\"" in\n+    arm64-*)\n+      echo \""__aarch64__\""\n+      ;;\n+    armv7-*)\n+      echo \""__ARM_ARCH_7A__\""\n+      ;;\n+    armv7s-*)\n+      echo \""__ARM_ARCH_7S__\""\n+      ;;\n+    x86-*)\n+      echo \""__i386__\""\n+      ;;\n+    x86_64-*)\n+      echo \""__x86_64__\""\n+      ;;\n+    *)\n+      echo \""#error ${target} unknown/unsupported\""\n+      return 1\n+      ;;\n+  esac\n+}\n+\n+# Create a vpx_config.h shim that, based on preprocessor settings for the\n+# current target CPU, includes the real vpx_config.h for the current target.\n+# $1 is the list of targets.\n+create_vpx_framework_config_shim() {\n+  local targets=\""$1\""\n+  local config_file=\""${HEADER_DIR}/vpx_config.h\""\n+  local preproc_symbol=\""\""\n+  local target=\""\""\n+  local include_guard=\""VPX_FRAMEWORK_HEADERS_VPX_VPX_CONFIG_H_\""\n+\n+  local file_header=\""/*\n+ *  Copyright (c) $(date +%Y) The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+/* GENERATED FILE: DO NOT EDIT! */\n+\n+#ifndef ${include_guard}\n+#define ${include_guard}\n+\n+#if defined\""\n+\n+  printf \""%s\"" \""${file_header}\"" > \""${config_file}\""\n+  for target in ${targets}; do\n+    preproc_symbol=$(target_to_preproc_symbol \""${target}\"")\n+    printf \"" ${preproc_symbol}\\n\"" >> \""${config_file}\""\n+    printf \""#define VPX_FRAMEWORK_TARGET \\\""${target}\\\""\\n\"" >> \""${config_file}\""\n+    printf \""#include \\\""VPX/vpx/${target}/vpx_config.h\\\""\\n\"" >> \""${config_file}\""\n+    printf \""#elif defined\"" >> \""${config_file}\""\n+    mkdir \""${HEADER_DIR}/${target}\""\n+    cp -p \""${BUILD_ROOT}/${target}/vpx_config.h\"" \""${HEADER_DIR}/${target}\""\n+  done\n+\n+  # Consume the last line of output from the loop: We don't want it.\n+  sed -i '' -e '$d' \""${config_file}\""\n+\n+  printf \""#endif\\n\\n\"" >> \""${config_file}\""\n+  printf \""#endif  // ${include_guard}\"" >> \""${config_file}\""\n+}\n+\n+# Configures and builds each target specified by $1, and then builds\n+# VPX.framework.\n+build_framework() {\n+  local lib_list=\""\""\n+  local targets=\""$1\""\n+  local target=\""\""\n+  local target_dist_dir=\""\""\n+\n+  # Clean up from previous build(s).\n+  rm -rf \""${BUILD_ROOT}\"" \""${FRAMEWORK_DIR}\""\n+\n+  # Create output dirs.\n+  mkdir -p \""${BUILD_ROOT}\""\n+  mkdir -p \""${HEADER_DIR}\""\n+\n+  cd \""${BUILD_ROOT}\""\n+\n+  for target in ${targets}; do\n+    build_target \""${target}\""\n+    target_dist_dir=\""${BUILD_ROOT}/${target}/${DIST_DIR}\""\n+    lib_list=\""${lib_list} ${target_dist_dir}/lib/libvpx.a\""\n+  done\n+\n+  cd \""${ORIG_PWD}\""\n+\n+  # The basic libvpx API includes are all the same; just grab the most recent\n+  # set.\n+  cp -p \""${target_dist_dir}\""/include/vpx/* \""${HEADER_DIR}\""\n+\n+  # Build the fat library.\n+  ${LIPO} -create ${lib_list} -output ${FRAMEWORK_DIR}/VPX\n+\n+  # Create the vpx_config.h shim that allows usage of vpx_config.h from\n+  # within VPX.framework.\n+  create_vpx_framework_config_shim \""${targets}\""\n+\n+  # Copy in vpx_version.h.\n+  cp -p \""${BUILD_ROOT}/${target}/vpx_version.h\"" \""${HEADER_DIR}\""\n+\n+  vlog \""Created fat library ${FRAMEWORK_DIR}/VPX containing:\""\n+  for lib in ${lib_list}; do\n+    vlog \""  $(echo ${lib} | awk -F / '{print $2, $NF}')\""\n+  done\n+\n+  # TODO(tomfinegan): Verify that expected targets are included within\n+  # VPX.framework/VPX via lipo -info.\n+}\n+\n+# Trap function. Cleans up the subtree used to build all targets contained in\n+# $TARGETS.\n+cleanup() {\n+  local readonly res=$?\n+  cd \""${ORIG_PWD}\""\n+\n+  if [ $res -ne 0 ]; then\n+    elog \""build exited with error ($res)\""\n+  fi\n+\n+  if [ \""${PRESERVE_BUILD_OUTPUT}\"" != \""yes\"" ]; then\n+    rm -rf \""${BUILD_ROOT}\""\n+  fi\n+}\n+\n+iosbuild_usage() {\n+cat << EOF\n+  Usage: ${0##*/} [arguments]\n+    --help: Display this message and exit.\n+    --extra-configure-args <args>: Extra args to pass when configuring libvpx.\n+    --jobs: Number of make jobs.\n+    --preserve-build-output: Do not delete the build directory.\n+    --show-build-output: Show output from each library build.\n+    --targets <targets>: Override default target list. Defaults:\n+         ${TARGETS}\n+    --verbose: Output information about the environment and each stage of the\n+               build.\n+EOF\n+}\n+\n+elog() {\n+  echo \""${0##*/} failed because: $@\"" 1>&2\n+}\n+\n+vlog() {\n+  if [ \""${VERBOSE}\"" = \""yes\"" ]; then\n+    echo \""$@\""\n+  fi\n+}\n+\n+trap cleanup EXIT\n+\n+# Parse the command line.\n+while [ -n \""$1\"" ]; do\n+  case \""$1\"" in\n+    --extra-configure-args)\n+      EXTRA_CONFIGURE_ARGS=\""$2\""\n+      shift\n+      ;;\n+    --help)\n+      iosbuild_usage\n+      exit\n+      ;;\n+    --jobs)\n+      MAKE_JOBS=\""$2\""\n+      shift\n+      ;;\n+    --preserve-build-output)\n+      PRESERVE_BUILD_OUTPUT=yes\n+      ;;\n+    --show-build-output)\n+      devnull=\n+      ;;\n+    --targets)\n+      TARGETS=\""$2\""\n+      shift\n+      ;;\n+    --verbose)\n+      VERBOSE=yes\n+      ;;\n+    *)\n+      iosbuild_usage\n+      exit 1\n+      ;;\n+  esac\n+  shift\n+done\n+\n+if [ \""${VERBOSE}\"" = \""yes\"" ]; then\n+cat << EOF\n+  BUILD_ROOT=${BUILD_ROOT}\n+  DIST_DIR=${DIST_DIR}\n+  CONFIGURE_ARGS=${CONFIGURE_ARGS}\n+  EXTRA_CONFIGURE_ARGS=${EXTRA_CONFIGURE_ARGS}\n+  FRAMEWORK_DIR=${FRAMEWORK_DIR}\n+  HEADER_DIR=${HEADER_DIR}\n+  MAKE_JOBS=${MAKE_JOBS}\n+  PRESERVE_BUILD_OUTPUT=${PRESERVE_BUILD_OUTPUT}\n+  LIBVPX_SOURCE_DIR=${LIBVPX_SOURCE_DIR}\n+  LIPO=${LIPO}\n+  ORIG_PWD=${ORIG_PWD}\n+  TARGETS=\""${TARGETS}\""\n+EOF\n+fi\n+\n+build_framework \""${TARGETS}\""\n+echo \""Successfully built '${FRAMEWORK_DIR}' for:\""\n+echo \""         ${TARGETS}\""\n""}<_**next**_>{""filename"": ""libvpx/build/make/msvs_common.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/build/make/msvs_common.sh"", ""patch"": ""@@ -0,0 +1,113 @@\n\n+#!/bin/bash\n+##\n+##  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+##\n+##  Use of this source code is governed by a BSD-style license\n+##  that can be found in the LICENSE file in the root of the source\n+##  tree. An additional intellectual property rights grant can be found\n+##  in the file PATENTS.  All contributing project authors may\n+##  be found in the AUTHORS file in the root of the source tree.\n+##\n+\n+if [ \""$(uname -o 2>/dev/null)\"" = \""Cygwin\"" ] \\\n+   && cygpath --help >/dev/null 2>&1; then\n+    FIXPATH='cygpath -m'\n+else\n+    FIXPATH='echo_path'\n+fi\n+\n+die() {\n+    echo \""${self_basename}: $@\"" >&2\n+    exit 1\n+}\n+\n+die_unknown(){\n+    echo \""Unknown option \\\""$1\\\"".\"" >&2\n+    echo \""See ${self_basename} --help for available options.\"" >&2\n+    exit 1\n+}\n+\n+echo_path() {\n+    for path; do\n+        echo \""$path\""\n+    done\n+}\n+\n+# Output one, possibly changed based on the system, path per line.\n+fix_path() {\n+    $FIXPATH \""$@\""\n+}\n+\n+# Corrects the paths in file_list in one pass for efficiency.\n+fix_file_list() {\n+    # TODO(jzern): this could be more generic and take the array as a param.\n+    files=$(fix_path \""${file_list[@]}\"")\n+    local IFS=$'\\n'\n+    file_list=($files)\n+}\n+\n+generate_uuid() {\n+    local hex=\""0123456789ABCDEF\""\n+    local i\n+    local uuid=\""\""\n+    local j\n+    #93995380-89BD-4b04-88EB-625FBE52EBFB\n+    for ((i=0; i<32; i++)); do\n+        (( j = $RANDOM % 16 ))\n+        uuid=\""${uuid}${hex:$j:1}\""\n+    done\n+    echo \""${uuid:0:8}-${uuid:8:4}-${uuid:12:4}-${uuid:16:4}-${uuid:20:12}\""\n+}\n+\n+indent1=\""    \""\n+indent=\""\""\n+indent_push() {\n+    indent=\""${indent}${indent1}\""\n+}\n+indent_pop() {\n+    indent=\""${indent%${indent1}}\""\n+}\n+\n+tag_attributes() {\n+    for opt in \""$@\""; do\n+        optval=\""${opt#*=}\""\n+        [ -n \""${optval}\"" ] ||\n+            die \""Missing attribute value in '$opt' while generating $tag tag\""\n+        echo \""${indent}${opt%%=*}=\\\""${optval}\\\""\""\n+    done\n+}\n+\n+open_tag() {\n+    local tag=$1\n+    shift\n+    if [ $# -ne 0 ]; then\n+        echo \""${indent}<${tag}\""\n+        indent_push\n+        tag_attributes \""$@\""\n+        echo \""${indent}>\""\n+    else\n+        echo \""${indent}<${tag}>\""\n+        indent_push\n+    fi\n+}\n+\n+close_tag() {\n+    local tag=$1\n+    indent_pop\n+    echo \""${indent}</${tag}>\""\n+}\n+\n+tag() {\n+    local tag=$1\n+    shift\n+    if [ $# -ne 0 ]; then\n+        echo \""${indent}<${tag}\""\n+        indent_push\n+        tag_attributes \""$@\""\n+        indent_pop\n+        echo \""${indent}/>\""\n+    else\n+        echo \""${indent}<${tag}/>\""\n+    fi\n+}\n+\n""}<_**next**_>{""filename"": ""libvpx/build/make/rtcd.pl"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/build/make/rtcd.pl"", ""patch"": ""@@ -3,7 +3,7 @@\n\n no strict 'refs';\n use warnings;\n use Getopt::Long;\n-Getopt::Long::Configure(\""auto_help\"");\n+Getopt::Long::Configure(\""auto_help\"") if $Getopt::Long::VERSION > 2.32;\n \n my %ALL_FUNCS = ();\n my @ALL_ARCHS;\n@@ -49,7 +49,7 @@\n\n \n my %config = ();\n while (<CONFIG_FILE>) {\n-  next if !/^CONFIG_/;\n+  next if !/^(?:CONFIG_|HAVE_)/;\n   chomp;\n   my @pair = split /=/;\n   $config{$pair[0]} = $pair[1];\n@@ -209,14 +209,16 @@\n\n #define RTCD_EXTERN extern\n #endif\n \n+EOF\n+\n+process_forward_decls();\n+print <<EOF;\n+\n #ifdef __cplusplus\n extern \""C\"" {\n #endif\n \n EOF\n-\n-process_forward_decls();\n-print \""\\n\"";\n declare_function_pointers(\""c\"", @ALL_ARCHS);\n \n print <<EOF;\n@@ -272,6 +274,9 @@\n\n   # Assign the helper variable for each enabled extension\n   foreach my $opt (@ALL_ARCHS) {\n     my $opt_uc = uc $opt;\n+    # Enable neon assembly based on HAVE_NEON logic instead of adding new\n+    # HAVE_NEON_ASM logic\n+    if ($opt eq 'neon_asm') { $opt_uc = 'NEON' }\n     eval \""\\$have_${opt}=\\\""flags & HAS_${opt_uc}\\\""\"";\n   }\n \n@@ -314,13 +319,14 @@\n\n \n   print <<EOF;\n #if HAVE_DSPR2\n+void vpx_dsputil_static_init();\n #if CONFIG_VP8\n void dsputil_static_init();\n-dsputil_static_init();\n #endif\n-#if CONFIG_VP9\n-void vp9_dsputil_static_init();\n-vp9_dsputil_static_init();\n+\n+vpx_dsputil_static_init();\n+#if CONFIG_VP8\n+dsputil_static_init();\n #endif\n #endif\n }\n@@ -362,26 +368,32 @@\n\n   @REQUIRES = filter(keys %required ? keys %required : qw/mmx sse sse2/);\n   &require(@REQUIRES);\n   x86;\n-} elsif ($opts{arch} eq 'mips32') {\n-  @ALL_ARCHS = filter(qw/mips32/);\n+} elsif ($opts{arch} eq 'mips32' || $opts{arch} eq 'mips64') {\n+  @ALL_ARCHS = filter(\""$opts{arch}\"");\n   open CONFIG_FILE, $opts{config} or\n     die \""Error opening config file '$opts{config}': $!\\n\"";\n   while (<CONFIG_FILE>) {\n     if (/HAVE_DSPR2=yes/) {\n-      @ALL_ARCHS = filter(qw/mips32 dspr2/);\n+      @ALL_ARCHS = filter(\""$opts{arch}\"", qw/dspr2/);\n+      last;\n+    }\n+    if (/HAVE_MSA=yes/) {\n+      @ALL_ARCHS = filter(\""$opts{arch}\"", qw/msa/);\n       last;\n     }\n   }\n   close CONFIG_FILE;\n   mips;\n-} elsif ($opts{arch} eq 'armv5te') {\n-  @ALL_ARCHS = filter(qw/edsp/);\n-  arm;\n } elsif ($opts{arch} eq 'armv6') {\n-  @ALL_ARCHS = filter(qw/edsp media/);\n+  @ALL_ARCHS = filter(qw/media/);\n   arm;\n-} elsif ($opts{arch} eq 'armv7') {\n-  @ALL_ARCHS = filter(qw/edsp media neon/);\n+} elsif ($opts{arch} =~ /armv7\\w?/) {\n+  @ALL_ARCHS = filter(qw/media neon_asm neon/);\n+  @REQUIRES = filter(keys %required ? keys %required : qw/media/);\n+  &require(@REQUIRES);\n+  arm;\n+} elsif ($opts{arch} eq 'armv8' || $opts{arch} eq 'arm64' ) {\n+  @ALL_ARCHS = filter(qw/neon/);\n   arm;\n } else {\n   unoptimized;\n""}<_**next**_>{""filename"": ""libvpx/build/make/version.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/build/make/version.sh"", ""patch"": ""@@ -24,9 +24,9 @@\n\n id=${3:-VERSION_STRING}\n \n git_version_id=\""\""\n-if [ -d ${source_path}/.git ]; then\n+if [ -d \""${source_path}/.git\"" ]; then\n     # Source Path is a git working copy. Check for local modifications.\n-    export GIT_DIR=${source_path}/.git\n+    export GIT_DIR=\""${source_path}/.git\""\n     git_version_id=`git describe --match=v[0-9]* 2>/dev/null`\n fi\n \n""}<_**next**_>{""filename"": ""libvpx/codereview.settings"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/codereview.settings"", ""patch"": ""@@ -0,0 +1,4 @@\n\n+# This file is used by gcl to get repository specific information.\n+GERRIT_HOST: chromium-review.googlesource.com\n+GERRIT_PORT: 29418\n+CODE_REVIEW_SERVER: chromium-review.googlesource.com\n""}<_**next**_>{""filename"": ""libvpx/configure"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/configure"", ""patch"": ""@@ -25,18 +25,20 @@\n\n   ${toggle_docs}                  documentation\n   ${toggle_unit_tests}            unit tests\n   ${toggle_decode_perf_tests}     build decoder perf tests with unit tests\n+  ${toggle_encode_perf_tests}     build encoder perf tests with unit tests\n+  --cpu=CPU                       tune for the specified CPU (ARM: cortex-a8, X86: sse3)\n   --libc=PATH                     path to alternate libc\n+  --size-limit=WxH                max size to allow in the decoder\n   --as={yasm|nasm|auto}           use specified assembler [auto, yasm preferred]\n   --sdk-path=PATH                 path to root of sdk (android builds only)\n-  ${toggle_fast_unaligned}        don't use unaligned accesses, even when\n-                                  supported by hardware [auto]\n   ${toggle_codec_srcs}            in/exclude codec library source code\n   ${toggle_debug_libs}            in/exclude debug version of libraries\n   ${toggle_static_msvcrt}         use static MSVCRT (VS builds only)\n+  ${toggle_vp9_highbitdepth}      use VP9 high bit depth (10/12) profiles\n   ${toggle_vp8}                   VP8 codec support\n   ${toggle_vp9}                   VP9 codec support\n+  ${toggle_vp10}                  VP10 codec support\n   ${toggle_internal_stats}        output of encoder internal stats for debug, if supported (encoders)\n-  ${toggle_mem_tracker}           track memory usage\n   ${toggle_postproc}              postprocessing\n   ${toggle_vp9_postproc}          vp9 specific postprocessing\n   ${toggle_multithread}           multithreaded encoding and decoding\n@@ -44,6 +46,9 @@\n\n   ${toggle_realtime_only}         enable this option while building for real-time encoding\n   ${toggle_onthefly_bitpacking}   enable on-the-fly bitpacking in real-time encoding\n   ${toggle_error_concealment}     enable this option to get a decoder which is able to conceal losses\n+  ${toggle_coefficient_range_checking}\n+                                  enable decoder to check if intermediate\n+                                  transform coefficients are in valid range\n   ${toggle_runtime_cpu_detect}    runtime cpu detection\n   ${toggle_shared}                shared library support\n   ${toggle_static}                static library support\n@@ -51,7 +56,10 @@\n\n   ${toggle_postproc_visualizer}   macro block / block level visualizers\n   ${toggle_multi_res_encoding}    enable multiple-resolution encoding\n   ${toggle_temporal_denoising}    enable temporal denoising and disable the spatial denoiser\n+  ${toggle_vp9_temporal_denoising}\n+                                  enable vp9 temporal denoising\n   ${toggle_webm_io}               enable input from and output to WebM container\n+  ${toggle_libyuv}                enable libyuv\n \n Codecs:\n   Codecs can be selectively enabled or disabled individually, or by family:\n@@ -64,10 +72,10 @@\n\n EOF\n #restore editor state '\n \n-    local family;\n-    local last_family;\n-    local c;\n-    local str;\n+    family=\""\"";\n+    last_family=\""\"";\n+    c=\""\"";\n+    str=\""\"";\n     for c in ${CODECS}; do\n         family=${c%_*}\n         if [ \""${family}\"" != \""${last_family}\"" ]; then\n@@ -87,14 +95,11 @@\n\n \n # all_platforms is a list of all supported target platforms. Maintain\n # alphabetically by architecture, generic-gnu last.\n-all_platforms=\""${all_platforms} armv5te-android-gcc\""\n-all_platforms=\""${all_platforms} armv5te-linux-rvct\""\n-all_platforms=\""${all_platforms} armv5te-linux-gcc\""\n-all_platforms=\""${all_platforms} armv5te-none-rvct\""\n all_platforms=\""${all_platforms} armv6-darwin-gcc\""\n all_platforms=\""${all_platforms} armv6-linux-rvct\""\n all_platforms=\""${all_platforms} armv6-linux-gcc\""\n all_platforms=\""${all_platforms} armv6-none-rvct\""\n+all_platforms=\""${all_platforms} arm64-darwin-gcc\""\n all_platforms=\""${all_platforms} armv7-android-gcc\""   #neon Cortex-A8\n all_platforms=\""${all_platforms} armv7-darwin-gcc\""    #neon Cortex-A8\n all_platforms=\""${all_platforms} armv7-linux-rvct\""    #neon Cortex-A8\n@@ -102,13 +107,10 @@\n\n all_platforms=\""${all_platforms} armv7-none-rvct\""     #neon Cortex-A8\n all_platforms=\""${all_platforms} armv7-win32-vs11\""\n all_platforms=\""${all_platforms} armv7-win32-vs12\""\n+all_platforms=\""${all_platforms} armv7-win32-vs14\""\n+all_platforms=\""${all_platforms} armv7s-darwin-gcc\""\n all_platforms=\""${all_platforms} mips32-linux-gcc\""\n-all_platforms=\""${all_platforms} ppc32-darwin8-gcc\""\n-all_platforms=\""${all_platforms} ppc32-darwin9-gcc\""\n-all_platforms=\""${all_platforms} ppc32-linux-gcc\""\n-all_platforms=\""${all_platforms} ppc64-darwin8-gcc\""\n-all_platforms=\""${all_platforms} ppc64-darwin9-gcc\""\n-all_platforms=\""${all_platforms} ppc64-linux-gcc\""\n+all_platforms=\""${all_platforms} mips64-linux-gcc\""\n all_platforms=\""${all_platforms} sparc-solaris-gcc\""\n all_platforms=\""${all_platforms} x86-android-gcc\""\n all_platforms=\""${all_platforms} x86-darwin8-gcc\""\n@@ -119,6 +121,8 @@\n\n all_platforms=\""${all_platforms} x86-darwin11-gcc\""\n all_platforms=\""${all_platforms} x86-darwin12-gcc\""\n all_platforms=\""${all_platforms} x86-darwin13-gcc\""\n+all_platforms=\""${all_platforms} x86-darwin14-gcc\""\n+all_platforms=\""${all_platforms} x86-iphonesimulator-gcc\""\n all_platforms=\""${all_platforms} x86-linux-gcc\""\n all_platforms=\""${all_platforms} x86-linux-icc\""\n all_platforms=\""${all_platforms} x86-os2-gcc\""\n@@ -130,11 +134,15 @@\n\n all_platforms=\""${all_platforms} x86-win32-vs10\""\n all_platforms=\""${all_platforms} x86-win32-vs11\""\n all_platforms=\""${all_platforms} x86-win32-vs12\""\n+all_platforms=\""${all_platforms} x86-win32-vs14\""\n+all_platforms=\""${all_platforms} x86_64-android-gcc\""\n all_platforms=\""${all_platforms} x86_64-darwin9-gcc\""\n all_platforms=\""${all_platforms} x86_64-darwin10-gcc\""\n all_platforms=\""${all_platforms} x86_64-darwin11-gcc\""\n all_platforms=\""${all_platforms} x86_64-darwin12-gcc\""\n all_platforms=\""${all_platforms} x86_64-darwin13-gcc\""\n+all_platforms=\""${all_platforms} x86_64-darwin14-gcc\""\n+all_platforms=\""${all_platforms} x86_64-iphonesimulator-gcc\""\n all_platforms=\""${all_platforms} x86_64-linux-gcc\""\n all_platforms=\""${all_platforms} x86_64-linux-icc\""\n all_platforms=\""${all_platforms} x86_64-solaris-gcc\""\n@@ -144,12 +152,7 @@\n\n all_platforms=\""${all_platforms} x86_64-win64-vs10\""\n all_platforms=\""${all_platforms} x86_64-win64-vs11\""\n all_platforms=\""${all_platforms} x86_64-win64-vs12\""\n-all_platforms=\""${all_platforms} universal-darwin8-gcc\""\n-all_platforms=\""${all_platforms} universal-darwin9-gcc\""\n-all_platforms=\""${all_platforms} universal-darwin10-gcc\""\n-all_platforms=\""${all_platforms} universal-darwin11-gcc\""\n-all_platforms=\""${all_platforms} universal-darwin12-gcc\""\n-all_platforms=\""${all_platforms} universal-darwin13-gcc\""\n+all_platforms=\""${all_platforms} x86_64-win64-vs14\""\n all_platforms=\""${all_platforms} generic-gnu\""\n \n # all_targets is a list of all targets that can be configured\n@@ -158,7 +161,7 @@\n\n \n # all targets available are enabled, by default.\n for t in ${all_targets}; do\n-    [ -f ${source_path}/${t}.mk ] && enable_feature ${t}\n+    [ -f \""${source_path}/${t}.mk\"" ] && enable_feature ${t}\n done\n \n if ! perl --version >/dev/null; then\n@@ -166,9 +169,9 @@\n\n fi\n \n \n-if [ \""`cd ${source_path} && pwd`\"" != \""`pwd`\"" ]; then\n+if [ \""`cd \\\""${source_path}\\\"" && pwd`\"" != \""`pwd`\"" ]; then\n   # test to see if source_path already configured\n-  if [ -f ${source_path}/vpx_config.h ]; then\n+  if [ -f \""${source_path}/vpx_config.h\"" ]; then\n     die \""source directory already configured; run 'make distclean' there first\""\n   fi\n fi\n@@ -186,62 +189,59 @@\n\n     [ $doxy_minor -eq 5 ] && [ $doxy_patch -ge 3 ] && enable_feature doxygen\n fi\n \n+# disable codecs when their source directory does not exist\n+[ -d \""${source_path}/vp8\"" ] || disable_feature vp8\n+[ -d \""${source_path}/vp9\"" ] || disable_feature vp9\n+[ -d \""${source_path}/vp10\"" ] || disable_feature vp10\n+\n+# disable vp10 codec by default\n+disable_feature vp10\n+\n # install everything except the sources, by default. sources will have\n # to be enabled when doing dist builds, since that's no longer a common\n # case.\n-enabled doxygen && php -v >/dev/null 2>&1 && enable_feature install_docs\n+enabled doxygen && enable_feature install_docs\n enable_feature install_bins\n enable_feature install_libs\n \n enable_feature static\n enable_feature optimizations\n-enable_feature fast_unaligned #allow unaligned accesses, if supported by hw\n+enable_feature dependency_tracking\n enable_feature spatial_resampling\n enable_feature multithread\n enable_feature os_support\n enable_feature temporal_denoising\n \n-[ -d ${source_path}/../include ] && enable_feature alt_tree_layout\n-for d in vp8 vp9; do\n-    [ -d ${source_path}/${d} ] && disable_feature alt_tree_layout;\n-done\n-\n-if ! enabled alt_tree_layout; then\n-# development environment\n-[ -d ${source_path}/vp8 ] && CODECS=\""${CODECS} vp8_encoder vp8_decoder\""\n-[ -d ${source_path}/vp9 ] && CODECS=\""${CODECS} vp9_encoder vp9_decoder\""\n-else\n-# customer environment\n-[ -f ${source_path}/../include/vpx/vp8cx.h ] && CODECS=\""${CODECS} vp8_encoder\""\n-[ -f ${source_path}/../include/vpx/vp8dx.h ] && CODECS=\""${CODECS} vp8_decoder\""\n-[ -f ${source_path}/../include/vpx/vp9cx.h ] && CODECS=\""${CODECS} vp9_encoder\""\n-[ -f ${source_path}/../include/vpx/vp9dx.h ] && CODECS=\""${CODECS} vp9_decoder\""\n-[ -f ${source_path}/../include/vpx/vp8cx.h ] || disable_feature vp8_encoder\n-[ -f ${source_path}/../include/vpx/vp8dx.h ] || disable_feature vp8_decoder\n-[ -f ${source_path}/../include/vpx/vp9cx.h ] || disable_feature vp9_encoder\n-[ -f ${source_path}/../include/vpx/vp9dx.h ] || disable_feature vp9_decoder\n-\n-[ -f ${source_path}/../lib/*/*mt.lib ] && soft_enable static_msvcrt\n-fi\n-\n-CODECS=\""$(echo ${CODECS} | tr ' ' '\\n')\""\n-CODEC_FAMILIES=\""$(for c in ${CODECS}; do echo ${c%_*}; done | sort | uniq)\""\n+CODECS=\""\n+    vp8_encoder\n+    vp8_decoder\n+    vp9_encoder\n+    vp9_decoder\n+    vp10_encoder\n+    vp10_decoder\n+\""\n+CODEC_FAMILIES=\""\n+    vp8\n+    vp9\n+    vp10\n+\""\n \n ARCH_LIST=\""\n     arm\n     mips\n     x86\n     x86_64\n-    ppc32\n-    ppc64\n \""\n ARCH_EXT_LIST=\""\n     edsp\n     media\n     neon\n+    neon_asm\n \n     mips32\n     dspr2\n+    msa\n+    mips64\n \n     mmx\n     sse\n@@ -251,23 +251,22 @@\n\n     sse4_1\n     avx\n     avx2\n-\n-    altivec\n \""\n HAVE_LIST=\""\n     ${ARCH_EXT_LIST}\n     vpx_ports\n     stdint_h\n-    alt_tree_layout\n     pthread_h\n     sys_mman_h\n     unistd_h\n \""\n EXPERIMENT_LIST=\""\n-    multiple_arf\n-    alpha\n+    spatial_svc\n+    fp_mb_stats\n+    emulate_hardware\n \""\n CONFIG_LIST=\""\n+    dependency_tracking\n     external_build\n     install_docs\n     install_bins\n@@ -285,10 +284,6 @@\n\n \n     codec_srcs\n     debug_libs\n-    fast_unaligned\n-    mem_manager\n-    mem_tracker\n-    mem_checks\n \n     dequant_tokens\n     dc_recon\n@@ -313,14 +308,20 @@\n\n     os_support\n     unit_tests\n     webm_io\n+    libyuv\n     decode_perf_tests\n+    encode_perf_tests\n     multi_res_encoding\n     temporal_denoising\n+    vp9_temporal_denoising\n+    coefficient_range_checking\n+    vp9_highbitdepth\n     experimental\n-    decrypt\n+    size_limit\n     ${EXPERIMENT_LIST}\n \""\n CMDLINE_SELECT=\""\n+    dependency_tracking\n     external_build\n     extra_warnings\n     werror\n@@ -343,7 +344,7 @@\n\n     docs\n     libc\n     as\n-    fast_unaligned\n+    size_limit\n     codec_srcs\n     debug_libs\n \n@@ -356,7 +357,6 @@\n\n     ${CODECS}\n     ${CODEC_FAMILIES}\n     static_msvcrt\n-    mem_tracker\n     spatial_resampling\n     realtime_only\n     onthefly_bitpacking\n@@ -367,11 +367,15 @@\n\n     postproc_visualizer\n     unit_tests\n     webm_io\n+    libyuv\n     decode_perf_tests\n+    encode_perf_tests\n     multi_res_encoding\n     temporal_denoising\n+    vp9_temporal_denoising\n+    coefficient_range_checking\n+    vp9_highbitdepth\n     experimental\n-    decrypt\n \""\n \n process_cmdline() {\n@@ -398,7 +402,7 @@\n\n }\n \n post_process_cmdline() {\n-    local c\n+    c=\""\""\n \n     # If the codec family is disabled, disable all components of that family.\n     # If the codec family is enabled, enable all components of that family.\n@@ -425,28 +429,12 @@\n\n \n process_targets() {\n     enabled child || write_common_config_banner\n-    enabled universal || write_common_target_config_h  ${BUILD_PFX}vpx_config.h\n-\n-    # TODO: add host tools target (obj_int_extract, etc)\n-\n-    # For fat binaries, call configure recursively to configure for each\n-    # binary architecture to be included.\n-    if enabled universal; then\n-        # Call configure (ourselves) for each subarchitecture\n-        for arch in $fat_bin_archs; do\n-            BUILD_PFX=${arch}/ toolchain=${arch} $self --child $cmdline_args || exit $?\n-        done\n-    fi\n-\n-    # The write_common_config (config.mk) logic is deferred until after the\n-    # recursive calls to configure complete, because we want our universal\n-    # targets to be executed last.\n+    write_common_target_config_h ${BUILD_PFX}vpx_config.h\n     write_common_config_targets\n-    enabled universal && echo \""FAT_ARCHS=${fat_bin_archs}\"" >> config.mk\n \n     # Calculate the default distribution name, based on the enabled features\n-    local cf\n-    local DIST_DIR=vpx\n+    cf=\""\""\n+    DIST_DIR=vpx\n     for cf in $CODEC_FAMILIES; do\n         if enabled ${cf}_encoder && enabled ${cf}_decoder; then\n             DIST_DIR=\""${DIST_DIR}-${cf}\""\n@@ -468,7 +456,7 @@\n\n           ;;\n     esac\n     if [ -f \""${source_path}/build/make/version.sh\"" ]; then\n-        local ver=`\""$source_path/build/make/version.sh\"" --bare $source_path`\n+        ver=`\""$source_path/build/make/version.sh\"" --bare \""$source_path\""`\n         DIST_DIR=\""${DIST_DIR}-${ver}\""\n         VERSION_STRING=${ver}\n         ver=${ver%%-*}\n@@ -502,7 +490,7 @@\n\n     # Write makefiles for all enabled targets\n     #\n     for tgt in libs examples docs solution; do\n-        local tgt_fn=\""$tgt-$toolchain.mk\""\n+        tgt_fn=\""$tgt-$toolchain.mk\""\n \n         if enabled $tgt; then\n             echo \""Creating makefiles for ${toolchain} ${tgt}\""\n@@ -518,11 +506,11 @@\n\n         # Can only build shared libs on a subset of platforms. Doing this check\n         # here rather than at option parse time because the target auto-detect\n         # magic happens after the command line has been parsed.\n-        if ! enabled linux; then\n+        if ! enabled linux && ! enabled os2; then\n             if enabled gnu; then\n                 echo \""--enable-shared is only supported on ELF; assuming this is OK\""\n             else\n-                die \""--enable-shared only supported on ELF for now\""\n+                die \""--enable-shared only supported on ELF and OS/2 for now\""\n             fi\n         fi\n     fi\n@@ -541,7 +529,7 @@\n\n                     true;\n                 ;;\n                 *)\n-                    local result=false\n+                    result=false\n                     for d in \""$@\""; do\n                         [ -f \""${d##-I}/$header\"" ] && result=true && break\n                     done\n@@ -587,30 +575,6 @@\n\n process_toolchain() {\n     process_common_toolchain\n \n-    # Handle universal binaries for this architecture\n-    case $toolchain in\n-        universal-darwin*)\n-            local darwin_ver=${tgt_os##darwin}\n-\n-            # Snow Leopard (10.6/darwin10) dropped support for PPC\n-            # Include PPC support for all prior versions\n-            if [ $darwin_ver -lt 10 ]; then\n-                fat_bin_archs=\""$fat_bin_archs ppc32-${tgt_os}-gcc\""\n-            fi\n-\n-            # Tiger (10.4/darwin8) brought support for x86\n-            if [ $darwin_ver -ge 8 ]; then\n-                fat_bin_archs=\""$fat_bin_archs x86-${tgt_os}-${tgt_cc}\""\n-            fi\n-\n-            # Leopard (10.5/darwin9) brought 64 bit support\n-            if [ $darwin_ver -ge 9 ]; then\n-                fat_bin_archs=\""$fat_bin_archs x86_64-${tgt_os}-${tgt_cc}\""\n-            fi\n-            ;;\n-    esac\n-\n-\n     # Enable some useful compiler flags\n     if enabled gcc; then\n         enabled werror && check_add_cflags -Werror\n@@ -686,7 +650,7 @@\n\n                  VCPROJ_SFX=vcproj\n                  gen_vcproj_cmd=${source_path}/build/make/gen_msvs_proj.sh\n                  ;;\n-             10|11|12)\n+             10|11|12|14)\n                  VCPROJ_SFX=vcxproj\n                  gen_vcproj_cmd=${source_path}/build/make/gen_msvs_vcxproj.sh\n                  enabled werror && gen_vcproj_cmd=\""${gen_vcproj_cmd} --enable-werror\""\n@@ -698,27 +662,32 @@\n\n     esac\n \n     # Other toolchain specific defaults\n-    case $toolchain in x86*|ppc*|universal*) soft_enable postproc;; esac\n+    case $toolchain in x86*) soft_enable postproc;; esac\n \n     if enabled postproc_visualizer; then\n         enabled postproc || die \""postproc_visualizer requires postproc to be enabled\""\n     fi\n \n-    # Enable WebM IO by default.\n-    soft_enable webm_io\n-\n     # Enable unit tests by default if we have a working C++ compiler.\n     case \""$toolchain\"" in\n         *-vs*)\n             soft_enable unit_tests\n+            soft_enable webm_io\n+            soft_enable libyuv\n         ;;\n         *-android-*)\n+            soft_enable webm_io\n+            soft_enable libyuv\n             # GTestLog must be modified to use Android logging utilities.\n         ;;\n         *-darwin-*)\n             # iOS/ARM builds do not work with gtest. This does not match\n             # x86 targets.\n         ;;\n+        *-iphonesimulator-*)\n+            soft_enable webm_io\n+            soft_enable libyuv\n+        ;;\n         *-win*)\n             # Some mingw toolchains don't have pthread available by default.\n             # Treat these more like visual studio where threading in gtest\n@@ -726,13 +695,27 @@\n\n             check_cxx \""$@\"" <<EOF && soft_enable unit_tests\n int z;\n EOF\n+            check_cxx \""$@\"" <<EOF && soft_enable webm_io\n+int z;\n+EOF\n+            check_cxx \""$@\"" <<EOF && soft_enable libyuv\n+int z;\n+EOF\n         ;;\n         *)\n             enabled pthread_h && check_cxx \""$@\"" <<EOF && soft_enable unit_tests\n int z;\n EOF\n+            check_cxx \""$@\"" <<EOF && soft_enable webm_io\n+int z;\n+EOF\n+            check_cxx \""$@\"" <<EOF && soft_enable libyuv\n+int z;\n+EOF\n         ;;\n     esac\n+    # libwebm needs to be linked with C++ standard library\n+    enabled webm_io && LD=${CXX}\n }\n \n \n@@ -743,6 +726,7 @@\n\n process \""$@\""\n print_webm_license ${BUILD_PFX}vpx_config.c \""/*\"" \"" */\""\n cat <<EOF >> ${BUILD_PFX}vpx_config.c\n+#include \""vpx/vpx_codec.h\""\n static const char* const cfg = \""$CONFIGURE_ARGS\"";\n const char *vpx_codec_build_config(void) {return cfg;}\n EOF\n""}<_**next**_>{""filename"": ""libvpx/docs.mk"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/docs.mk"", ""patch"": ""@@ -23,12 +23,6 @@\n\n # Other doxy files sourced in Markdown\n TXT_DOX = $(call enabled,TXT_DOX)\n \n-%.dox: %.txt\n-\t@echo \""    [DOXY] $@\""\n-\t@$(SRC_PATH_BARE)/examples/gen_example_doxy.php \\\n-             $(@:.dox=)  \""$($@.DESC)\"" > $@ < $<\n-\n-\n EXAMPLE_PATH += $(SRC_PATH_BARE) #for CHANGELOG, README, etc\n EXAMPLE_PATH += $(SRC_PATH_BARE)/examples\n \n""}<_**next**_>{""filename"": ""libvpx/examples.mk"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/examples.mk"", ""patch"": ""@@ -9,11 +9,47 @@\n\n ##\n \n LIBYUV_SRCS +=  third_party/libyuv/include/libyuv/basic_types.h  \\\n+                third_party/libyuv/include/libyuv/convert.h \\\n+                third_party/libyuv/include/libyuv/convert_argb.h \\\n+                third_party/libyuv/include/libyuv/convert_from.h \\\n                 third_party/libyuv/include/libyuv/cpu_id.h  \\\n+                third_party/libyuv/include/libyuv/planar_functions.h  \\\n+                third_party/libyuv/include/libyuv/rotate.h  \\\n+                third_party/libyuv/include/libyuv/row.h  \\\n                 third_party/libyuv/include/libyuv/scale.h  \\\n-                third_party/libyuv/source/row.h \\\n-                third_party/libyuv/source/scale.c  \\\n-                third_party/libyuv/source/cpu_id.c\n+                third_party/libyuv/include/libyuv/scale_row.h  \\\n+                third_party/libyuv/source/cpu_id.cc \\\n+                third_party/libyuv/source/planar_functions.cc \\\n+                third_party/libyuv/source/row_any.cc \\\n+                third_party/libyuv/source/row_common.cc \\\n+                third_party/libyuv/source/row_gcc.cc \\\n+                third_party/libyuv/source/row_mips.cc \\\n+                third_party/libyuv/source/row_neon.cc \\\n+                third_party/libyuv/source/row_neon64.cc \\\n+                third_party/libyuv/source/row_win.cc \\\n+                third_party/libyuv/source/scale.cc \\\n+                third_party/libyuv/source/scale_any.cc \\\n+                third_party/libyuv/source/scale_common.cc \\\n+                third_party/libyuv/source/scale_gcc.cc \\\n+                third_party/libyuv/source/scale_mips.cc \\\n+                third_party/libyuv/source/scale_neon.cc \\\n+                third_party/libyuv/source/scale_neon64.cc \\\n+                third_party/libyuv/source/scale_win.cc \\\n+\n+LIBWEBM_MUXER_SRCS += third_party/libwebm/mkvmuxer.cpp \\\n+                      third_party/libwebm/mkvmuxerutil.cpp \\\n+                      third_party/libwebm/mkvwriter.cpp \\\n+                      third_party/libwebm/mkvmuxer.hpp \\\n+                      third_party/libwebm/mkvmuxertypes.hpp \\\n+                      third_party/libwebm/mkvmuxerutil.hpp \\\n+                      third_party/libwebm/mkvparser.hpp \\\n+                      third_party/libwebm/mkvwriter.hpp \\\n+                      third_party/libwebm/webmids.hpp\n+\n+LIBWEBM_PARSER_SRCS = third_party/libwebm/mkvparser.cpp \\\n+                      third_party/libwebm/mkvreader.cpp \\\n+                      third_party/libwebm/mkvparser.hpp \\\n+                      third_party/libwebm/mkvreader.hpp\n \n # List of examples to build. UTILS are tools meant for distribution\n # while EXAMPLES demonstrate specific portions of the API.\n@@ -21,22 +57,19 @@\n\n vpxdec.SRCS                 += md5_utils.c md5_utils.h\n vpxdec.SRCS                 += vpx_ports/mem_ops.h\n vpxdec.SRCS                 += vpx_ports/mem_ops_aligned.h\n+vpxdec.SRCS                 += vpx_ports/msvc.h\n vpxdec.SRCS                 += vpx_ports/vpx_timer.h\n vpxdec.SRCS                 += vpx/vpx_integer.h\n vpxdec.SRCS                 += args.c args.h\n vpxdec.SRCS                 += ivfdec.c ivfdec.h\n vpxdec.SRCS                 += tools_common.c tools_common.h\n vpxdec.SRCS                 += y4menc.c y4menc.h\n-vpxdec.SRCS                 += $(LIBYUV_SRCS)\n+ifeq ($(CONFIG_LIBYUV),yes)\n+  vpxdec.SRCS                 += $(LIBYUV_SRCS)\n+endif\n ifeq ($(CONFIG_WEBM_IO),yes)\n-  vpxdec.SRCS                 += third_party/nestegg/halloc/halloc.h\n-  vpxdec.SRCS                 += third_party/nestegg/halloc/src/align.h\n-  vpxdec.SRCS                 += third_party/nestegg/halloc/src/halloc.c\n-  vpxdec.SRCS                 += third_party/nestegg/halloc/src/hlist.h\n-  vpxdec.SRCS                 += third_party/nestegg/halloc/src/macros.h\n-  vpxdec.SRCS                 += third_party/nestegg/include/nestegg/nestegg.h\n-  vpxdec.SRCS                 += third_party/nestegg/src/nestegg.c\n-  vpxdec.SRCS                 += webmdec.c webmdec.h\n+  vpxdec.SRCS                 += $(LIBWEBM_PARSER_SRCS)\n+  vpxdec.SRCS                 += webmdec.cc webmdec.h\n endif\n vpxdec.GUID                  = BA5FE66F-38DD-E034-F542-B1578C5FB950\n vpxdec.DESCRIPTION           = Full featured decoder\n@@ -49,44 +82,44 @@\n\n vpxenc.SRCS                 += warnings.c warnings.h\n vpxenc.SRCS                 += vpx_ports/mem_ops.h\n vpxenc.SRCS                 += vpx_ports/mem_ops_aligned.h\n+vpxenc.SRCS                 += vpx_ports/msvc.h\n vpxenc.SRCS                 += vpx_ports/vpx_timer.h\n vpxenc.SRCS                 += vpxstats.c vpxstats.h\n-vpxenc.SRCS                 += $(LIBYUV_SRCS)\n+ifeq ($(CONFIG_LIBYUV),yes)\n+  vpxenc.SRCS                 += $(LIBYUV_SRCS)\n+endif\n ifeq ($(CONFIG_WEBM_IO),yes)\n-  vpxenc.SRCS                 += third_party/libmkv/EbmlIDs.h\n-  vpxenc.SRCS                 += third_party/libmkv/EbmlWriter.c\n-  vpxenc.SRCS                 += third_party/libmkv/EbmlWriter.h\n-  vpxenc.SRCS                 += webmenc.c webmenc.h\n+  vpxenc.SRCS                 += $(LIBWEBM_MUXER_SRCS)\n+  vpxenc.SRCS                 += webmenc.cc webmenc.h\n endif\n vpxenc.GUID                  = 548DEC74-7A15-4B2B-AFC3-AA102E7C25C1\n vpxenc.DESCRIPTION           = Full featured encoder\n-EXAMPLES-$(CONFIG_VP9_ENCODER)    += vp9_spatial_scalable_encoder.c\n-vp9_spatial_scalable_encoder.SRCS += args.c args.h\n-vp9_spatial_scalable_encoder.SRCS += ivfenc.c ivfenc.h\n-vp9_spatial_scalable_encoder.SRCS += tools_common.c tools_common.h\n-vp9_spatial_scalable_encoder.SRCS += video_common.h\n-vp9_spatial_scalable_encoder.SRCS += video_writer.h video_writer.c\n-vp9_spatial_scalable_encoder.SRCS += vpxstats.c vpxstats.h\n-vp9_spatial_scalable_encoder.GUID   = 4A38598D-627D-4505-9C7B-D4020C84100D\n-vp9_spatial_scalable_encoder.DESCRIPTION = Spatial Scalable Encoder\n+ifeq ($(CONFIG_SPATIAL_SVC),yes)\n+  EXAMPLES-$(CONFIG_VP9_ENCODER)      += vp9_spatial_svc_encoder.c\n+  vp9_spatial_svc_encoder.SRCS        += args.c args.h\n+  vp9_spatial_svc_encoder.SRCS        += ivfenc.c ivfenc.h\n+  vp9_spatial_svc_encoder.SRCS        += tools_common.c tools_common.h\n+  vp9_spatial_svc_encoder.SRCS        += video_common.h\n+  vp9_spatial_svc_encoder.SRCS        += video_writer.h video_writer.c\n+  vp9_spatial_svc_encoder.SRCS        += vpx_ports/msvc.h\n+  vp9_spatial_svc_encoder.SRCS        += vpxstats.c vpxstats.h\n+  vp9_spatial_svc_encoder.GUID        = 4A38598D-627D-4505-9C7B-D4020C84100D\n+  vp9_spatial_svc_encoder.DESCRIPTION = VP9 Spatial SVC Encoder\n+endif\n \n ifneq ($(CONFIG_SHARED),yes)\n EXAMPLES-$(CONFIG_VP9_ENCODER)    += resize_util.c\n endif\n \n-# XMA example disabled for now, not used in VP8\n-#UTILS-$(CONFIG_DECODERS)    += example_xma.c\n-#example_xma.GUID             = A955FC4A-73F1-44F7-135E-30D84D32F022\n-#example_xma.DESCRIPTION      = External Memory Allocation mode usage\n-\n-EXAMPLES-$(CONFIG_ENCODERS)         += vpx_temporal_scalable_patterns.c\n-vpx_temporal_scalable_patterns.SRCS += ivfenc.c ivfenc.h\n-vpx_temporal_scalable_patterns.SRCS += tools_common.c tools_common.h\n-vpx_temporal_scalable_patterns.SRCS += video_common.h\n-vpx_temporal_scalable_patterns.SRCS += video_writer.h video_writer.c\n-vpx_temporal_scalable_patterns.GUID  = B18C08F2-A439-4502-A78E-849BE3D60947\n-vpx_temporal_scalable_patterns.DESCRIPTION = Temporal Scalability Encoder\n-EXAMPLES-$(CONFIG_VP8_DECODER)     += simple_decoder.c\n+EXAMPLES-$(CONFIG_ENCODERS)          += vpx_temporal_svc_encoder.c\n+vpx_temporal_svc_encoder.SRCS        += ivfenc.c ivfenc.h\n+vpx_temporal_svc_encoder.SRCS        += tools_common.c tools_common.h\n+vpx_temporal_svc_encoder.SRCS        += video_common.h\n+vpx_temporal_svc_encoder.SRCS        += video_writer.h video_writer.c\n+vpx_temporal_svc_encoder.SRCS        += vpx_ports/msvc.h\n+vpx_temporal_svc_encoder.GUID        = B18C08F2-A439-4502-A78E-849BE3D60947\n+vpx_temporal_svc_encoder.DESCRIPTION = Temporal SVC Encoder\n+EXAMPLES-$(CONFIG_DECODERS)        += simple_decoder.c\n simple_decoder.GUID                 = D3BBF1E9-2427-450D-BBFF-B2843C1D44CC\n simple_decoder.SRCS                += ivfdec.h ivfdec.c\n simple_decoder.SRCS                += tools_common.h tools_common.c\n@@ -94,17 +127,19 @@\n\n simple_decoder.SRCS                += video_reader.h video_reader.c\n simple_decoder.SRCS                += vpx_ports/mem_ops.h\n simple_decoder.SRCS                += vpx_ports/mem_ops_aligned.h\n+simple_decoder.SRCS                += vpx_ports/msvc.h\n simple_decoder.DESCRIPTION          = Simplified decoder loop\n-EXAMPLES-$(CONFIG_VP8_DECODER)     += postproc.c\n+EXAMPLES-$(CONFIG_DECODERS)        += postproc.c\n postproc.SRCS                      += ivfdec.h ivfdec.c\n postproc.SRCS                      += tools_common.h tools_common.c\n postproc.SRCS                      += video_common.h\n postproc.SRCS                      += video_reader.h video_reader.c\n postproc.SRCS                      += vpx_ports/mem_ops.h\n postproc.SRCS                      += vpx_ports/mem_ops_aligned.h\n+postproc.SRCS                      += vpx_ports/msvc.h\n postproc.GUID                       = 65E33355-F35E-4088-884D-3FD4905881D7\n postproc.DESCRIPTION                = Decoder postprocessor control\n-EXAMPLES-$(CONFIG_VP8_DECODER)     += decode_to_md5.c\n+EXAMPLES-$(CONFIG_DECODERS)        += decode_to_md5.c\n decode_to_md5.SRCS                 += md5_utils.h md5_utils.c\n decode_to_md5.SRCS                 += ivfdec.h ivfdec.c\n decode_to_md5.SRCS                 += tools_common.h tools_common.c\n@@ -112,43 +147,49 @@\n\n decode_to_md5.SRCS                 += video_reader.h video_reader.c\n decode_to_md5.SRCS                 += vpx_ports/mem_ops.h\n decode_to_md5.SRCS                 += vpx_ports/mem_ops_aligned.h\n+decode_to_md5.SRCS                 += vpx_ports/msvc.h\n decode_to_md5.GUID                  = 59120B9B-2735-4BFE-B022-146CA340FE42\n decode_to_md5.DESCRIPTION           = Frame by frame MD5 checksum\n-EXAMPLES-$(CONFIG_VP8_ENCODER)  += simple_encoder.c\n+EXAMPLES-$(CONFIG_ENCODERS)     += simple_encoder.c\n simple_encoder.SRCS             += ivfenc.h ivfenc.c\n simple_encoder.SRCS             += tools_common.h tools_common.c\n simple_encoder.SRCS             += video_common.h\n simple_encoder.SRCS             += video_writer.h video_writer.c\n+simple_encoder.SRCS             += vpx_ports/msvc.h\n simple_encoder.GUID              = 4607D299-8A71-4D2C-9B1D-071899B6FBFD\n simple_encoder.DESCRIPTION       = Simplified encoder loop\n-EXAMPLES-$(CONFIG_VP8_ENCODER)  += twopass_encoder.c\n+EXAMPLES-$(CONFIG_VP9_ENCODER)  += vp9_lossless_encoder.c\n+vp9_lossless_encoder.SRCS       += ivfenc.h ivfenc.c\n+vp9_lossless_encoder.SRCS       += tools_common.h tools_common.c\n+vp9_lossless_encoder.SRCS       += video_common.h\n+vp9_lossless_encoder.SRCS       += video_writer.h video_writer.c\n+vp9_lossless_encoder.SRCS       += vpx_ports/msvc.h\n+vp9_lossless_encoder.GUID        = B63C7C88-5348-46DC-A5A6-CC151EF93366\n+vp9_lossless_encoder.DESCRIPTION = Simplified lossless VP9 encoder\n+EXAMPLES-$(CONFIG_ENCODERS)     += twopass_encoder.c\n twopass_encoder.SRCS            += ivfenc.h ivfenc.c\n twopass_encoder.SRCS            += tools_common.h tools_common.c\n twopass_encoder.SRCS            += video_common.h\n twopass_encoder.SRCS            += video_writer.h video_writer.c\n+twopass_encoder.SRCS            += vpx_ports/msvc.h\n twopass_encoder.GUID             = 73494FA6-4AF9-4763-8FBB-265C92402FD8\n twopass_encoder.DESCRIPTION      = Two-pass encoder loop\n-ifeq ($(CONFIG_DECODERS),yes)\n-EXAMPLES-$(CONFIG_VP8_ENCODER)  += decode_with_drops.c\n+EXAMPLES-$(CONFIG_DECODERS)     += decode_with_drops.c\n decode_with_drops.SRCS          += ivfdec.h ivfdec.c\n decode_with_drops.SRCS          += tools_common.h tools_common.c\n decode_with_drops.SRCS          += video_common.h\n decode_with_drops.SRCS          += video_reader.h video_reader.c\n decode_with_drops.SRCS          += vpx_ports/mem_ops.h\n decode_with_drops.SRCS          += vpx_ports/mem_ops_aligned.h\n-endif\n+decode_with_drops.SRCS          += vpx_ports/msvc.h\n decode_with_drops.GUID           = CE5C53C4-8DDA-438A-86ED-0DDD3CDB8D26\n decode_with_drops.DESCRIPTION    = Drops frames while decoding\n-ifeq ($(CONFIG_VP8_DECODER),yes)\n-EXAMPLES-$(CONFIG_ERROR_CONCEALMENT)    += decode_with_partial_drops.c\n-endif\n-decode_with_partial_drops.GUID           = 61C2D026-5754-46AC-916F-1343ECC5537E\n-decode_with_partial_drops.DESCRIPTION    = Drops parts of frames while decoding\n EXAMPLES-$(CONFIG_ENCODERS)        += set_maps.c\n set_maps.SRCS                      += ivfenc.h ivfenc.c\n set_maps.SRCS                      += tools_common.h tools_common.c\n set_maps.SRCS                      += video_common.h\n set_maps.SRCS                      += video_writer.h video_writer.c\n+set_maps.SRCS                      += vpx_ports/msvc.h\n set_maps.GUID                       = ECB2D24D-98B8-4015-A465-A4AF3DCC145F\n set_maps.DESCRIPTION                = Set active and ROI maps\n EXAMPLES-$(CONFIG_VP8_ENCODER)     += vp8cx_set_ref.c\n@@ -156,16 +197,23 @@\n\n vp8cx_set_ref.SRCS                 += tools_common.h tools_common.c\n vp8cx_set_ref.SRCS                 += video_common.h\n vp8cx_set_ref.SRCS                 += video_writer.h video_writer.c\n+vp8cx_set_ref.SRCS                 += vpx_ports/msvc.h\n vp8cx_set_ref.GUID                  = C5E31F7F-96F6-48BD-BD3E-10EBF6E8057A\n vp8cx_set_ref.DESCRIPTION           = VP8 set encoder reference frame\n \n \n ifeq ($(CONFIG_MULTI_RES_ENCODING),yes)\n-EXAMPLES-$(CONFIG_VP8_DECODER)          += vp8_multi_resolution_encoder.c\n+ifeq ($(CONFIG_LIBYUV),yes)\n+EXAMPLES-$(CONFIG_VP8_ENCODER)          += vp8_multi_resolution_encoder.c\n+vp8_multi_resolution_encoder.SRCS       += ivfenc.h ivfenc.c\n+vp8_multi_resolution_encoder.SRCS       += tools_common.h tools_common.c\n+vp8_multi_resolution_encoder.SRCS       += video_writer.h video_writer.c\n+vp8_multi_resolution_encoder.SRCS       += vpx_ports/msvc.h\n vp8_multi_resolution_encoder.SRCS       += $(LIBYUV_SRCS)\n vp8_multi_resolution_encoder.GUID        = 04f8738e-63c8-423b-90fa-7c2703a374de\n vp8_multi_resolution_encoder.DESCRIPTION = VP8 Multiple-resolution Encoding\n endif\n+endif\n \n # Handle extra library flags depending on codec configuration\n \n@@ -190,17 +238,18 @@\n\n # from an installed tree or a version controlled tree. Determine\n # the proper paths.\n ifeq ($(HAVE_ALT_TREE_LAYOUT),yes)\n-    LIB_PATH := $(SRC_PATH_BARE)/../lib\n-    INC_PATH := $(SRC_PATH_BARE)/../include\n+    LIB_PATH-yes := $(SRC_PATH_BARE)/../lib\n+    INC_PATH-yes := $(SRC_PATH_BARE)/../include\n else\n     LIB_PATH-yes                     += $(if $(BUILD_PFX),$(BUILD_PFX),.)\n     INC_PATH-$(CONFIG_VP8_DECODER)   += $(SRC_PATH_BARE)/vp8\n     INC_PATH-$(CONFIG_VP8_ENCODER)   += $(SRC_PATH_BARE)/vp8\n     INC_PATH-$(CONFIG_VP9_DECODER)   += $(SRC_PATH_BARE)/vp9\n     INC_PATH-$(CONFIG_VP9_ENCODER)   += $(SRC_PATH_BARE)/vp9\n-    LIB_PATH := $(call enabled,LIB_PATH)\n-    INC_PATH := $(call enabled,INC_PATH)\n endif\n+INC_PATH-$(CONFIG_LIBYUV) += $(SRC_PATH_BARE)/third_party/libyuv/include\n+LIB_PATH := $(call enabled,LIB_PATH)\n+INC_PATH := $(call enabled,INC_PATH)\n INTERNAL_CFLAGS = $(addprefix -I,$(INC_PATH))\n INTERNAL_LDFLAGS += $(addprefix -L,$(LIB_PATH))\n \n@@ -220,14 +269,6 @@\n\n $(foreach ex,$(ALL_EXAMPLES),$(eval $(notdir $(ex:.c=)).SRCS += $(ex) examples.mk))\n \n \n-# If this is a universal (fat) binary, then all the subarchitectures have\n-# already been built and our job is to stitch them together. The\n-# BUILD_OBJS variable indicates whether we should be building\n-# (compiling, linking) the library. The LIPO_OBJS variable indicates\n-# that we're stitching.\n-$(eval $(if $(filter universal%,$(TOOLCHAIN)),LIPO_OBJS,BUILD_OBJS):=yes)\n-\n-\n # Create build/install dependencies for all examples. The common case\n # is handled here. The MSVS case is handled below.\n NOT_MSVS = $(if $(CONFIG_MSVS),,yes)\n@@ -235,24 +276,28 @@\n\n INSTALL-BINS-$(NOT_MSVS)   += $(addprefix bin/,$(UTILS:.c=$(EXE_SFX)))\n DIST-SRCS-yes              += $(ALL_SRCS)\n INSTALL-SRCS-yes           += $(UTIL_SRCS)\n-OBJS-$(NOT_MSVS)           += $(if $(BUILD_OBJS),$(call objs,$(ALL_SRCS)))\n+OBJS-$(NOT_MSVS)           += $(call objs,$(ALL_SRCS))\n BINS-$(NOT_MSVS)           += $(addprefix $(BUILD_PFX),$(ALL_EXAMPLES:.c=$(EXE_SFX)))\n \n \n # Instantiate linker template for all examples.\n CODEC_LIB=$(if $(CONFIG_DEBUG_LIBS),vpx_g,vpx)\n-SHARED_LIB_SUF=$(if $(filter darwin%,$(TGT_OS)),.dylib,.so)\n+ifneq ($(filter darwin%,$(TGT_OS)),)\n+SHARED_LIB_SUF=.dylib\n+else\n+ifneq ($(filter os2%,$(TGT_OS)),)\n+SHARED_LIB_SUF=_dll.a\n+else\n+SHARED_LIB_SUF=.so\n+endif\n+endif\n CODEC_LIB_SUF=$(if $(CONFIG_SHARED),$(SHARED_LIB_SUF),.a)\n $(foreach bin,$(BINS-yes),\\\n-    $(if $(BUILD_OBJS),$(eval $(bin):\\\n-        $(LIB_PATH)/lib$(CODEC_LIB)$(CODEC_LIB_SUF)))\\\n-    $(if $(BUILD_OBJS),$(eval $(call linker_template,$(bin),\\\n+    $(eval $(bin):$(LIB_PATH)/lib$(CODEC_LIB)$(CODEC_LIB_SUF))\\\n+    $(eval $(call linker_template,$(bin),\\\n         $(call objs,$($(notdir $(bin:$(EXE_SFX)=)).SRCS)) \\\n         -l$(CODEC_LIB) $(addprefix -l,$(CODEC_EXTRA_LIBS))\\\n-        )))\\\n-    $(if $(LIPO_OBJS),$(eval $(call lipo_bin_template,$(bin))))\\\n-    )\n-\n+        )))\n \n # The following pairs define a mapping of locations in the distribution\n # tree to locations in the source/build trees.\n@@ -280,13 +325,14 @@\n\n # the makefiles). We may want to revisit this.\n define vcproj_template\n $(1): $($(1:.$(VCPROJ_SFX)=).SRCS) vpx.$(VCPROJ_SFX)\n-\t@echo \""    [vcproj] $$@\""\n-\t$$(GEN_VCPROJ)\\\n+\t$(if $(quiet),@echo \""    [vcproj] $$@\"")\n+\t$(qexec)$$(GEN_VCPROJ)\\\n             --exe\\\n             --target=$$(TOOLCHAIN)\\\n             --name=$$(@:.$(VCPROJ_SFX)=)\\\n             --ver=$$(CONFIG_VS_VERSION)\\\n             --proj-guid=$$($$(@:.$(VCPROJ_SFX)=).GUID)\\\n+            --src-path-bare=\""$(SRC_PATH_BARE)\"" \\\n             $$(if $$(CONFIG_STATIC_MSVCRT),--static-crt) \\\n             --out=$$@ $$(INTERNAL_CFLAGS) $$(CFLAGS) \\\n             $$(INTERNAL_LDFLAGS) $$(LDFLAGS) -l$$(CODEC_LIB) $$^\n@@ -303,6 +349,7 @@\n\n #\n %.dox: %.c\n \t@echo \""    [DOXY] $@\""\n+\t@mkdir -p $(dir $@)\n \t@echo \""/*!\\page example_$(@F:.dox=) $(@F:.dox=)\"" > $@\n \t@echo \""   \\includelineno $(<F)\"" >> $@\n \t@echo \""*/\"" >> $@\n""}<_**next**_>{""filename"": ""libvpx/examples/decode_to_md5.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/examples/decode_to_md5.c"", ""patch"": ""@@ -33,14 +33,12 @@\n\n #include <stdlib.h>\n #include <string.h>\n \n-#define VPX_CODEC_DISABLE_COMPAT 1\n-\n #include \""vpx/vp8dx.h\""\n #include \""vpx/vpx_decoder.h\""\n \n-#include \""./md5_utils.h\""\n-#include \""./tools_common.h\""\n-#include \""./video_reader.h\""\n+#include \""../md5_utils.h\""\n+#include \""../tools_common.h\""\n+#include \""../video_reader.h\""\n #include \""./vpx_config.h\""\n \n static void get_image_md5(const vpx_image_t *img, unsigned char digest[16]) {\n@@ -73,7 +71,7 @@\n\n \n static const char *exec_name;\n \n-void usage_exit() {\n+void usage_exit(void) {\n   fprintf(stderr, \""Usage: %s <infile> <outfile>\\n\"", exec_name);\n   exit(EXIT_FAILURE);\n }\n@@ -104,9 +102,9 @@\n\n   if (!decoder)\n     die(\""Unknown input codec.\"");\n \n-  printf(\""Using %s\\n\"", vpx_codec_iface_name(decoder->interface()));\n+  printf(\""Using %s\\n\"", vpx_codec_iface_name(decoder->codec_interface()));\n \n-  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))\n+  if (vpx_codec_dec_init(&codec, decoder->codec_interface(), NULL, 0))\n     die_codec(&codec, \""Failed to initialize decoder\"");\n \n   while (vpx_video_reader_read_frame(reader)) {\n""}<_**next**_>{""filename"": ""libvpx/examples/decode_with_drops.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/examples/decode_with_drops.c"", ""patch"": ""@@ -56,18 +56,16 @@\n\n #include <stdlib.h>\n #include <string.h>\n \n-#define VPX_CODEC_DISABLE_COMPAT 1\n-\n #include \""vpx/vp8dx.h\""\n #include \""vpx/vpx_decoder.h\""\n \n-#include \""./tools_common.h\""\n-#include \""./video_reader.h\""\n+#include \""../tools_common.h\""\n+#include \""../video_reader.h\""\n #include \""./vpx_config.h\""\n \n static const char *exec_name;\n \n-void usage_exit() {\n+void usage_exit(void) {\n   fprintf(stderr, \""Usage: %s <infile> <outfile> <N-M|N/M>\\n\"", exec_name);\n   exit(EXIT_FAILURE);\n }\n@@ -108,9 +106,9 @@\n\n   if (!decoder)\n     die(\""Unknown input codec.\"");\n \n-  printf(\""Using %s\\n\"", vpx_codec_iface_name(decoder->interface()));\n+  printf(\""Using %s\\n\"", vpx_codec_iface_name(decoder->codec_interface()));\n \n-  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))\n+  if (vpx_codec_dec_init(&codec, decoder->codec_interface(), NULL, 0))\n     die_codec(&codec, \""Failed to initialize decoder.\"");\n \n   while (vpx_video_reader_read_frame(reader)) {\n""}<_**next**_>{""filename"": ""libvpx/examples/postproc.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/examples/postproc.c"", ""patch"": ""@@ -43,18 +43,16 @@\n\n #include <stdlib.h>\n #include <string.h>\n \n-#define VPX_CODEC_DISABLE_COMPAT 1\n-\n #include \""vpx/vp8dx.h\""\n #include \""vpx/vpx_decoder.h\""\n \n-#include \""./tools_common.h\""\n-#include \""./video_reader.h\""\n+#include \""../tools_common.h\""\n+#include \""../video_reader.h\""\n #include \""./vpx_config.h\""\n \n static const char *exec_name;\n \n-void usage_exit() {\n+void usage_exit(void) {\n   fprintf(stderr, \""Usage: %s <infile> <outfile>\\n\"", exec_name);\n   exit(EXIT_FAILURE);\n }\n@@ -86,9 +84,9 @@\n\n   if (!decoder)\n     die(\""Unknown input codec.\"");\n \n-  printf(\""Using %s\\n\"", vpx_codec_iface_name(decoder->interface()));\n+  printf(\""Using %s\\n\"", vpx_codec_iface_name(decoder->codec_interface()));\n \n-  res = vpx_codec_dec_init(&codec, decoder->interface(), NULL,\n+  res = vpx_codec_dec_init(&codec, decoder->codec_interface(), NULL,\n                            VPX_CODEC_USE_POSTPROC);\n   if (res == VPX_CODEC_INCAPABLE)\n     die_codec(&codec, \""Postproc not supported by this decoder.\"");\n""}<_**next**_>{""filename"": ""libvpx/examples/resize_util.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/examples/resize_util.c"", ""patch"": ""@@ -15,15 +15,23 @@\n\n #include <stdlib.h>\n #include <string.h>\n \n-#include \""./vp9/encoder/vp9_resize.h\""\n+#include \""../tools_common.h\""\n+#include \""../vp9/encoder/vp9_resize.h\""\n \n-static void usage(char *progname) {\n+static const char *exec_name = NULL;\n+\n+static void usage() {\n   printf(\""Usage:\\n\"");\n   printf(\""%s <input_yuv> <width>x<height> <target_width>x<target_height> \"",\n-         progname);\n+         exec_name);\n   printf(\""<output_yuv> [<frames>]\\n\"");\n }\n \n+void usage_exit(void) {\n+  usage();\n+  exit(EXIT_FAILURE);\n+}\n+\n static int parse_dim(char *v, int *width, int *height) {\n   char *x = strchr(v, 'x');\n   if (x == NULL)\n@@ -47,9 +55,11 @@\n\n   int f, frames;\n   int width, height, target_width, target_height;\n \n+  exec_name = argv[0];\n+\n   if (argc < 5) {\n     printf(\""Incorrect parameters:\\n\"");\n-    usage(argv[0]);\n+    usage();\n     return 1;\n   }\n \n@@ -57,25 +67,25 @@\n\n   fout = argv[4];\n   if (!parse_dim(argv[2], &width, &height)) {\n     printf(\""Incorrect parameters: %s\\n\"", argv[2]);\n-    usage(argv[0]);\n+    usage();\n     return 1;\n   }\n   if (!parse_dim(argv[3], &target_width, &target_height)) {\n     printf(\""Incorrect parameters: %s\\n\"", argv[3]);\n-    usage(argv[0]);\n+    usage();\n     return 1;\n   }\n \n   fpin = fopen(fin, \""rb\"");\n   if (fpin == NULL) {\n     printf(\""Can't open file %s to read\\n\"", fin);\n-    usage(argv[0]);\n+    usage();\n     return 1;\n   }\n   fpout = fopen(fout, \""wb\"");\n   if (fpout == NULL) {\n     printf(\""Can't open file %s to write\\n\"", fout);\n-    usage(argv[0]);\n+    usage();\n     return 1;\n   }\n   if (argc >= 6)\n""}<_**next**_>{""filename"": ""libvpx/examples/set_maps.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/examples/set_maps.c"", ""patch"": ""@@ -42,20 +42,20 @@\n\n // Use the `simple_decoder` example to decode this sample, and observe\n // the change in the image at frames 22, 33, and 44.\n \n+#include <assert.h>\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n \n-#define VPX_CODEC_DISABLE_COMPAT 1\n #include \""vpx/vp8cx.h\""\n #include \""vpx/vpx_encoder.h\""\n \n-#include \""./tools_common.h\""\n-#include \""./video_writer.h\""\n+#include \""../tools_common.h\""\n+#include \""../video_writer.h\""\n \n static const char *exec_name;\n \n-void usage_exit() {\n+void usage_exit(void) {\n   fprintf(stderr, \""Usage: %s <codec> <width> <height> <infile> <outfile>\\n\"",\n           exec_name);\n   exit(EXIT_FAILURE);\n@@ -64,7 +64,8 @@\n\n static void set_roi_map(const vpx_codec_enc_cfg_t *cfg,\n                         vpx_codec_ctx_t *codec) {\n   unsigned int i;\n-  vpx_roi_map_t roi = {0};\n+  vpx_roi_map_t roi;\n+  memset(&roi, 0, sizeof(roi));\n \n   roi.rows = (cfg->g_h + 15) / 16;\n   roi.cols = (cfg->g_w + 15) / 16;\n@@ -97,7 +98,7 @@\n\n static void set_active_map(const vpx_codec_enc_cfg_t *cfg,\n                            vpx_codec_ctx_t *codec) {\n   unsigned int i;\n-  vpx_active_map_t map = {0};\n+  vpx_active_map_t map = {0, 0, 0};\n \n   map.rows = (cfg->g_h + 15) / 16;\n   map.cols = (cfg->g_w + 15) / 16;\n@@ -114,7 +115,7 @@\n\n \n static void unset_active_map(const vpx_codec_enc_cfg_t *cfg,\n                              vpx_codec_ctx_t *codec) {\n-  vpx_active_map_t map = {0};\n+  vpx_active_map_t map = {0, 0, 0};\n \n   map.rows = (cfg->g_h + 15) / 16;\n   map.cols = (cfg->g_w + 15) / 16;\n@@ -124,10 +125,11 @@\n\n     die_codec(codec, \""Failed to set active map\"");\n }\n \n-static void encode_frame(vpx_codec_ctx_t *codec,\n-                         vpx_image_t *img,\n-                         int frame_index,\n-                         VpxVideoWriter *writer) {\n+static int encode_frame(vpx_codec_ctx_t *codec,\n+                        vpx_image_t *img,\n+                        int frame_index,\n+                        VpxVideoWriter *writer) {\n+  int got_pkts = 0;\n   vpx_codec_iter_t iter = NULL;\n   const vpx_codec_cx_pkt_t *pkt = NULL;\n   const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1, 0,\n@@ -136,6 +138,8 @@\n\n     die_codec(codec, \""Failed to encode frame\"");\n \n   while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {\n+    got_pkts = 1;\n+\n     if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {\n       const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;\n       if (!vpx_video_writer_write_frame(writer,\n@@ -149,30 +153,34 @@\n\n       fflush(stdout);\n     }\n   }\n+\n+  return got_pkts;\n }\n \n int main(int argc, char **argv) {\n   FILE *infile = NULL;\n-  vpx_codec_ctx_t codec = {0};\n-  vpx_codec_enc_cfg_t cfg = {0};\n+  vpx_codec_ctx_t codec;\n+  vpx_codec_enc_cfg_t cfg;\n   int frame_count = 0;\n-  vpx_image_t raw = {0};\n+  vpx_image_t raw;\n   vpx_codec_err_t res;\n-  VpxVideoInfo info = {0};\n+  VpxVideoInfo info;\n   VpxVideoWriter *writer = NULL;\n   const VpxInterface *encoder = NULL;\n   const int fps = 2;        // TODO(dkovalev) add command line argument\n   const double bits_per_pixel_per_frame = 0.067;\n \n   exec_name = argv[0];\n-\n   if (argc != 6)\n     die(\""Invalid number of arguments\"");\n \n-  encoder = get_vpx_encoder_by_name(argv[1]);\n-  if (!encoder)\n-    die(\""Unsupported codec.\"");\n+  memset(&info, 0, sizeof(info));\n \n+  encoder = get_vpx_encoder_by_name(argv[1]);\n+  if (encoder == NULL) {\n+    die(\""Unsupported codec.\"");\n+  }\n+  assert(encoder != NULL);\n   info.codec_fourcc = encoder->fourcc;\n   info.frame_width = strtol(argv[2], NULL, 0);\n   info.frame_height = strtol(argv[3], NULL, 0);\n@@ -191,9 +199,9 @@\n\n     die(\""Failed to allocate image.\"");\n   }\n \n-  printf(\""Using %s\\n\"", vpx_codec_iface_name(encoder->interface()));\n+  printf(\""Using %s\\n\"", vpx_codec_iface_name(encoder->codec_interface()));\n \n-  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);\n+  res = vpx_codec_enc_config_default(encoder->codec_interface(), &cfg, 0);\n   if (res)\n     die_codec(&codec, \""Failed to get default codec config.\"");\n \n@@ -212,9 +220,10 @@\n\n   if (!(infile = fopen(argv[4], \""rb\"")))\n     die(\""Failed to open %s for reading.\"", argv[4]);\n \n-  if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))\n+  if (vpx_codec_enc_init(&codec, encoder->codec_interface(), &cfg, 0))\n     die_codec(&codec, \""Failed to initialize encoder\"");\n \n+  // Encode frames.\n   while (vpx_img_read(&raw, infile)) {\n     ++frame_count;\n \n@@ -228,7 +237,10 @@\n\n \n     encode_frame(&codec, &raw, frame_count, writer);\n   }\n-  encode_frame(&codec, NULL, -1, writer);\n+\n+  // Flush encoder.\n+  while (encode_frame(&codec, NULL, -1, writer)) {}\n+\n   printf(\""\\n\"");\n   fclose(infile);\n   printf(\""Processed %d frames.\\n\"", frame_count);\n""}<_**next**_>{""filename"": ""libvpx/examples/simple_decoder.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/examples/simple_decoder.c"", ""patch"": ""@@ -29,30 +29,29 @@\n\n // -----------------\n // For decoders, you only have to include `vpx_decoder.h` and then any\n // header files for the specific codecs you use. In this case, we're using\n-// vp8. The `VPX_CODEC_DISABLE_COMPAT` macro can be defined to ensure\n-// strict compliance with the latest SDK by disabling some backwards\n-// compatibility features. Defining this macro is encouraged.\n+// vp8.\n //\n // Initializing The Codec\n // ----------------------\n-// The decoder is initialized by the following code. This is an example for\n-// the VP8 decoder, but the code is analogous for all algorithms. Replace\n-// `vpx_codec_vp8_dx()` with a pointer to the interface exposed by the\n-// algorithm you want to use. The `cfg` argument is left as NULL in this\n-// example, because we want the algorithm to determine the stream\n-// configuration (width/height) and allocate memory automatically. This\n-// parameter is generally only used if you need to preallocate memory,\n-// particularly in External Memory Allocation mode.\n+// The libvpx decoder is initialized by the call to vpx_codec_dec_init().\n+// Determining the codec interface to use is handled by VpxVideoReader and the\n+// functions prefixed with vpx_video_reader_. Discussion of those functions is\n+// beyond the scope of this example, but the main gist is to open the input file\n+// and parse just enough of it to determine if it's a VPx file and which VPx\n+// codec is contained within the file.\n+// Note the NULL pointer passed to vpx_codec_dec_init(). We do that in this\n+// example because we want the algorithm to determine the stream configuration\n+// (width/height) and allocate memory automatically.\n //\n // Decoding A Frame\n // ----------------\n // Once the frame has been read into memory, it is decoded using the\n // `vpx_codec_decode` function. The call takes a pointer to the data\n-// (`frame`) and the length of the data (`frame_sz`). No application data\n+// (`frame`) and the length of the data (`frame_size`). No application data\n // is associated with the frame in this example, so the `user_priv`\n // parameter is NULL. The `deadline` parameter is left at zero for this\n-// example. This parameter is generally only used when doing adaptive\n-// postprocessing.\n+// example. This parameter is generally only used when doing adaptive post\n+// processing.\n //\n // Codecs may produce a variable number of output frames for every call to\n // `vpx_codec_decode`. These frames are retrieved by the\n@@ -74,25 +73,22 @@\n\n // --------------\n // This example does not special case any error return codes. If there was\n // an error, a descriptive message is printed and the program exits. With\n-// few exeptions, vpx_codec functions return an enumerated error status,\n+// few exceptions, vpx_codec functions return an enumerated error status,\n // with the value `0` indicating success.\n \n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n \n-#define VPX_CODEC_DISABLE_COMPAT 1\n-\n-#include \""vpx/vp8dx.h\""\n #include \""vpx/vpx_decoder.h\""\n \n-#include \""./tools_common.h\""\n-#include \""./video_reader.h\""\n+#include \""../tools_common.h\""\n+#include \""../video_reader.h\""\n #include \""./vpx_config.h\""\n \n static const char *exec_name;\n \n-void usage_exit() {\n+void usage_exit(void) {\n   fprintf(stderr, \""Usage: %s <infile> <outfile>\\n\"", exec_name);\n   exit(EXIT_FAILURE);\n }\n@@ -123,9 +119,9 @@\n\n   if (!decoder)\n     die(\""Unknown input codec.\"");\n \n-  printf(\""Using %s\\n\"", vpx_codec_iface_name(decoder->interface()));\n+  printf(\""Using %s\\n\"", vpx_codec_iface_name(decoder->codec_interface()));\n \n-  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))\n+  if (vpx_codec_dec_init(&codec, decoder->codec_interface(), NULL, 0))\n     die_codec(&codec, \""Failed to initialize decoder.\"");\n \n   while (vpx_video_reader_read_frame(reader)) {\n""}<_**next**_>{""filename"": ""libvpx/examples/simple_encoder.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/examples/simple_encoder.c"", ""patch"": ""@@ -28,9 +28,7 @@\n\n // -----------------\n // For encoders, you only have to include `vpx_encoder.h` and then any\n // header files for the specific codecs you use. In this case, we're using\n-// vp8. The `VPX_CODEC_DISABLE_COMPAT` macro can be defined to ensure\n-// strict compliance with the latest SDK by disabling some backwards\n-// compatibility features. Defining this macro is encouraged.\n+// vp8.\n //\n // Getting The Default Configuration\n // ---------------------------------\n@@ -101,15 +99,14 @@\n\n #include <stdlib.h>\n #include <string.h>\n \n-#define VPX_CODEC_DISABLE_COMPAT 1\n #include \""vpx/vpx_encoder.h\""\n \n-#include \""./tools_common.h\""\n-#include \""./video_writer.h\""\n+#include \""../tools_common.h\""\n+#include \""../video_writer.h\""\n \n static const char *exec_name;\n \n-void usage_exit() {\n+void usage_exit(void) {\n   fprintf(stderr,\n           \""Usage: %s <codec> <width> <height> <infile> <outfile> \""\n               \""<keyframe-interval> [<error-resilient>]\\nSee comments in \""\n@@ -118,11 +115,12 @@\n\n   exit(EXIT_FAILURE);\n }\n \n-static void encode_frame(vpx_codec_ctx_t *codec,\n-                         vpx_image_t *img,\n-                         int frame_index,\n-                         int flags,\n-                         VpxVideoWriter *writer) {\n+static int encode_frame(vpx_codec_ctx_t *codec,\n+                        vpx_image_t *img,\n+                        int frame_index,\n+                        int flags,\n+                        VpxVideoWriter *writer) {\n+  int got_pkts = 0;\n   vpx_codec_iter_t iter = NULL;\n   const vpx_codec_cx_pkt_t *pkt = NULL;\n   const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1,\n@@ -131,6 +129,8 @@\n\n     die_codec(codec, \""Failed to encode frame\"");\n \n   while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {\n+    got_pkts = 1;\n+\n     if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {\n       const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;\n       if (!vpx_video_writer_write_frame(writer,\n@@ -139,11 +139,12 @@\n\n                                         pkt->data.frame.pts)) {\n         die_codec(codec, \""Failed to write compressed frame\"");\n       }\n-\n       printf(keyframe ? \""K\"" : \"".\"");\n       fflush(stdout);\n     }\n   }\n+\n+  return got_pkts;\n }\n \n int main(int argc, char **argv) {\n@@ -207,9 +208,9 @@\n\n   if (keyframe_interval < 0)\n     die(\""Invalid keyframe interval value.\"");\n \n-  printf(\""Using %s\\n\"", vpx_codec_iface_name(encoder->interface()));\n+  printf(\""Using %s\\n\"", vpx_codec_iface_name(encoder->codec_interface()));\n \n-  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);\n+  res = vpx_codec_enc_config_default(encoder->codec_interface(), &cfg, 0);\n   if (res)\n     die_codec(&codec, \""Failed to get default codec config.\"");\n \n@@ -227,16 +228,19 @@\n\n   if (!(infile = fopen(infile_arg, \""rb\"")))\n     die(\""Failed to open %s for reading.\"", infile_arg);\n \n-  if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))\n+  if (vpx_codec_enc_init(&codec, encoder->codec_interface(), &cfg, 0))\n     die_codec(&codec, \""Failed to initialize encoder\"");\n \n+  // Encode frames.\n   while (vpx_img_read(&raw, infile)) {\n     int flags = 0;\n     if (keyframe_interval > 0 && frame_count % keyframe_interval == 0)\n       flags |= VPX_EFLAG_FORCE_KF;\n     encode_frame(&codec, &raw, frame_count++, flags, writer);\n   }\n-  encode_frame(&codec, NULL, -1, 0, writer);  // flush the encoder\n+\n+  // Flush encoder.\n+  while (encode_frame(&codec, NULL, -1, 0, writer)) {};\n \n   printf(\""\\n\"");\n   fclose(infile);\n""}<_**next**_>{""filename"": ""libvpx/examples/twopass_encoder.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/examples/twopass_encoder.c"", ""patch"": ""@@ -28,9 +28,8 @@\n\n // Encoding A Frame\n // ----------------\n // Encoding a frame in two pass mode is identical to the simple encoder\n-// example, except the deadline is set to VPX_DL_BEST_QUALITY to get the\n-// best quality possible. VPX_DL_GOOD_QUALITY could also be used.\n-//\n+// example. To increase the quality while sacrificing encoding speed,\n+// VPX_DL_BEST_QUALITY can be used in place of VPX_DL_GOOD_QUALITY.\n //\n // Processing Statistics Packets\n // -----------------------------\n@@ -52,27 +51,27 @@\n\n #include <stdlib.h>\n #include <string.h>\n \n-#define VPX_CODEC_DISABLE_COMPAT 1\n #include \""vpx/vpx_encoder.h\""\n \n-#include \""./tools_common.h\""\n-#include \""./video_writer.h\""\n+#include \""../tools_common.h\""\n+#include \""../video_writer.h\""\n \n static const char *exec_name;\n \n-void usage_exit() {\n+void usage_exit(void) {\n   fprintf(stderr, \""Usage: %s <codec> <width> <height> <infile> <outfile>\\n\"",\n           exec_name);\n   exit(EXIT_FAILURE);\n }\n \n-static void get_frame_stats(vpx_codec_ctx_t *ctx,\n-                            const vpx_image_t *img,\n-                            vpx_codec_pts_t pts,\n-                            unsigned int duration,\n-                            vpx_enc_frame_flags_t flags,\n-                            unsigned int deadline,\n-                            vpx_fixed_buf_t *stats) {\n+static int get_frame_stats(vpx_codec_ctx_t *ctx,\n+                           const vpx_image_t *img,\n+                           vpx_codec_pts_t pts,\n+                           unsigned int duration,\n+                           vpx_enc_frame_flags_t flags,\n+                           unsigned int deadline,\n+                           vpx_fixed_buf_t *stats) {\n+  int got_pkts = 0;\n   vpx_codec_iter_t iter = NULL;\n   const vpx_codec_cx_pkt_t *pkt = NULL;\n   const vpx_codec_err_t res = vpx_codec_encode(ctx, img, pts, duration, flags,\n@@ -81,6 +80,8 @@\n\n     die_codec(ctx, \""Failed to get frame stats.\"");\n \n   while ((pkt = vpx_codec_get_cx_data(ctx, &iter)) != NULL) {\n+    got_pkts = 1;\n+\n     if (pkt->kind == VPX_CODEC_STATS_PKT) {\n       const uint8_t *const pkt_buf = pkt->data.twopass_stats.buf;\n       const size_t pkt_size = pkt->data.twopass_stats.sz;\n@@ -89,15 +90,18 @@\n\n       stats->sz += pkt_size;\n     }\n   }\n+\n+  return got_pkts;\n }\n \n-static void encode_frame(vpx_codec_ctx_t *ctx,\n-                         const vpx_image_t *img,\n-                         vpx_codec_pts_t pts,\n-                         unsigned int duration,\n-                         vpx_enc_frame_flags_t flags,\n-                         unsigned int deadline,\n-                         VpxVideoWriter *writer) {\n+static int encode_frame(vpx_codec_ctx_t *ctx,\n+                        const vpx_image_t *img,\n+                        vpx_codec_pts_t pts,\n+                        unsigned int duration,\n+                        vpx_enc_frame_flags_t flags,\n+                        unsigned int deadline,\n+                        VpxVideoWriter *writer) {\n+  int got_pkts = 0;\n   vpx_codec_iter_t iter = NULL;\n   const vpx_codec_cx_pkt_t *pkt = NULL;\n   const vpx_codec_err_t res = vpx_codec_encode(ctx, img, pts, duration, flags,\n@@ -106,6 +110,7 @@\n\n     die_codec(ctx, \""Failed to encode frame.\"");\n \n   while ((pkt = vpx_codec_get_cx_data(ctx, &iter)) != NULL) {\n+    got_pkts = 1;\n     if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {\n       const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;\n \n@@ -117,19 +122,90 @@\n\n       fflush(stdout);\n     }\n   }\n+\n+  return got_pkts;\n+}\n+\n+static vpx_fixed_buf_t pass0(vpx_image_t *raw,\n+                             FILE *infile,\n+                             const VpxInterface *encoder,\n+                             const vpx_codec_enc_cfg_t *cfg) {\n+  vpx_codec_ctx_t codec;\n+  int frame_count = 0;\n+  vpx_fixed_buf_t stats = {NULL, 0};\n+\n+  if (vpx_codec_enc_init(&codec, encoder->codec_interface(), cfg, 0))\n+    die_codec(&codec, \""Failed to initialize encoder\"");\n+\n+  // Calculate frame statistics.\n+  while (vpx_img_read(raw, infile)) {\n+    ++frame_count;\n+    get_frame_stats(&codec, raw, frame_count, 1, 0, VPX_DL_GOOD_QUALITY,\n+                    &stats);\n+  }\n+\n+  // Flush encoder.\n+  while (get_frame_stats(&codec, NULL, frame_count, 1, 0,\n+                         VPX_DL_GOOD_QUALITY, &stats)) {}\n+\n+  printf(\""Pass 0 complete. Processed %d frames.\\n\"", frame_count);\n+  if (vpx_codec_destroy(&codec))\n+    die_codec(&codec, \""Failed to destroy codec.\"");\n+\n+  return stats;\n+}\n+\n+static void pass1(vpx_image_t *raw,\n+                  FILE *infile,\n+                  const char *outfile_name,\n+                  const VpxInterface *encoder,\n+                  const vpx_codec_enc_cfg_t *cfg) {\n+  VpxVideoInfo info = {\n+    encoder->fourcc,\n+    cfg->g_w,\n+    cfg->g_h,\n+    {cfg->g_timebase.num, cfg->g_timebase.den}\n+  };\n+  VpxVideoWriter *writer = NULL;\n+  vpx_codec_ctx_t codec;\n+  int frame_count = 0;\n+\n+  writer = vpx_video_writer_open(outfile_name, kContainerIVF, &info);\n+  if (!writer)\n+    die(\""Failed to open %s for writing\"", outfile_name);\n+\n+  if (vpx_codec_enc_init(&codec, encoder->codec_interface(), cfg, 0))\n+    die_codec(&codec, \""Failed to initialize encoder\"");\n+\n+  // Encode frames.\n+  while (vpx_img_read(raw, infile)) {\n+    ++frame_count;\n+    encode_frame(&codec, raw, frame_count, 1, 0, VPX_DL_GOOD_QUALITY, writer);\n+  }\n+\n+  // Flush encoder.\n+  while (encode_frame(&codec, NULL, -1, 1, 0, VPX_DL_GOOD_QUALITY, writer)) {}\n+\n+  printf(\""\\n\"");\n+\n+  if (vpx_codec_destroy(&codec))\n+    die_codec(&codec, \""Failed to destroy codec.\"");\n+\n+  vpx_video_writer_close(writer);\n+\n+  printf(\""Pass 1 complete. Processed %d frames.\\n\"", frame_count);\n }\n \n int main(int argc, char **argv) {\n   FILE *infile = NULL;\n-  VpxVideoWriter *writer = NULL;\n+  int w, h;\n   vpx_codec_ctx_t codec;\n   vpx_codec_enc_cfg_t cfg;\n   vpx_image_t raw;\n   vpx_codec_err_t res;\n-  vpx_fixed_buf_t stats = {0};\n-  VpxVideoInfo info = {0};\n+  vpx_fixed_buf_t stats;\n+\n   const VpxInterface *encoder = NULL;\n-  int pass;\n   const int fps = 30;        // TODO(dkovalev) add command line argument\n   const int bitrate = 200;   // kbit/s TODO(dkovalev) add command line argument\n   const char *const codec_arg = argv[1];\n@@ -146,85 +222,44 @@\n\n   if (!encoder)\n     die(\""Unsupported codec.\"");\n \n-  info.codec_fourcc = encoder->fourcc;\n-  info.time_base.numerator = 1;\n-  info.time_base.denominator = fps;\n-  info.frame_width = strtol(width_arg, NULL, 0);\n-  info.frame_height = strtol(height_arg, NULL, 0);\n+  w = strtol(width_arg, NULL, 0);\n+  h = strtol(height_arg, NULL, 0);\n \n-  if (info.frame_width <= 0 ||\n-      info.frame_height <= 0 ||\n-      (info.frame_width % 2) != 0 ||\n-      (info.frame_height % 2) != 0) {\n-    die(\""Invalid frame size: %dx%d\"", info.frame_width, info.frame_height);\n-  }\n+  if (w  <= 0 || h <= 0 || (w % 2) != 0 || (h  % 2) != 0)\n+    die(\""Invalid frame size: %dx%d\"", w, h);\n \n-  if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,\n-                                             info.frame_height, 1)) {\n-    die(\""Failed to allocate image\"", info.frame_width, info.frame_height);\n-  }\n+  if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, w, h, 1))\n+    die(\""Failed to allocate image\"", w, h);\n \n-  writer = vpx_video_writer_open(outfile_arg, kContainerIVF, &info);\n-  if (!writer)\n-    die(\""Failed to open %s for writing\"", outfile_arg);\n+  printf(\""Using %s\\n\"", vpx_codec_iface_name(encoder->codec_interface()));\n \n-  printf(\""Using %s\\n\"", vpx_codec_iface_name(encoder->interface()));\n-\n-  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);\n+  // Configuration\n+  res = vpx_codec_enc_config_default(encoder->codec_interface(), &cfg, 0);\n   if (res)\n     die_codec(&codec, \""Failed to get default codec config.\"");\n \n-  cfg.g_w = info.frame_width;\n-  cfg.g_h = info.frame_height;\n-  cfg.g_timebase.num = info.time_base.numerator;\n-  cfg.g_timebase.den = info.time_base.denominator;\n+  cfg.g_w = w;\n+  cfg.g_h = h;\n+  cfg.g_timebase.num = 1;\n+  cfg.g_timebase.den = fps;\n   cfg.rc_target_bitrate = bitrate;\n \n-  for (pass = 0; pass < 2; ++pass) {\n-    int frame_count = 0;\n+  if (!(infile = fopen(infile_arg, \""rb\"")))\n+    die(\""Failed to open %s for reading\"", infile_arg);\n \n-    if (pass == 0) {\n-      cfg.g_pass = VPX_RC_FIRST_PASS;\n-    } else {\n-      cfg.g_pass = VPX_RC_LAST_PASS;\n-      cfg.rc_twopass_stats_in = stats;\n-    }\n+  // Pass 0\n+  cfg.g_pass = VPX_RC_FIRST_PASS;\n+  stats = pass0(&raw, infile, encoder, &cfg);\n \n-    if (!(infile = fopen(infile_arg, \""rb\"")))\n-      die(\""Failed to open %s for reading\"", infile_arg);\n-\n-    if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))\n-      die_codec(&codec, \""Failed to initialize encoder\"");\n-\n-    while (vpx_img_read(&raw, infile)) {\n-      ++frame_count;\n-\n-      if (pass == 0) {\n-        get_frame_stats(&codec, &raw, frame_count, 1, 0, VPX_DL_BEST_QUALITY,\n-                        &stats);\n-      } else {\n-        encode_frame(&codec, &raw, frame_count, 1, 0, VPX_DL_BEST_QUALITY,\n-                     writer);\n-      }\n-    }\n-\n-    if (pass == 0) {\n-      get_frame_stats(&codec, NULL, frame_count, 1, 0, VPX_DL_BEST_QUALITY,\n-                      &stats);\n-    } else {\n-      printf(\""\\n\"");\n-    }\n-\n-    fclose(infile);\n-    printf(\""Pass %d complete. Processed %d frames.\\n\"", pass + 1, frame_count);\n-    if (vpx_codec_destroy(&codec))\n-      die_codec(&codec, \""Failed to destroy codec.\"");\n-  }\n-\n-  vpx_img_free(&raw);\n+  // Pass 1\n+  rewind(infile);\n+  cfg.g_pass = VPX_RC_LAST_PASS;\n+  cfg.rc_twopass_stats_in = stats;\n+  pass1(&raw, infile, outfile_arg, encoder, &cfg);\n   free(stats.buf);\n \n-  vpx_video_writer_close(writer);\n+  vpx_img_free(&raw);\n+  fclose(infile);\n \n   return EXIT_SUCCESS;\n }\n""}<_**next**_>{""filename"": ""libvpx/examples/vp8_multi_resolution_encoder.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/examples/vp8_multi_resolution_encoder.c"", ""patch"": ""@@ -13,22 +13,40 @@\n\n  * High-resolution input video is down-sampled to lower-resolutions. The\n  * encoder then encodes the video and outputs multiple bitstreams with\n  * different resolutions.\n+ *\n+ * This test also allows for settings temporal layers for each spatial layer.\n+ * Different number of temporal layers per spatial stream may be used.\n+ * Currently up to 3 temporal layers per spatial stream (encoder) are supported\n+ * in this test.\n  */\n+\n+#include \""./vpx_config.h\""\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <stdarg.h>\n #include <string.h>\n #include <math.h>\n-#define VPX_CODEC_DISABLE_COMPAT 1\n+#include <assert.h>\n+#include <sys/time.h>\n+#if USE_POSIX_MMAP\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <sys/mman.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#endif\n+#include \""vpx_ports/vpx_timer.h\""\n #include \""vpx/vpx_encoder.h\""\n #include \""vpx/vp8cx.h\""\n #include \""vpx_ports/mem_ops.h\""\n-#include \""./tools_common.h\""\n+#include \""../tools_common.h\""\n #define interface (vpx_codec_vp8_cx())\n #define fourcc    0x30385056\n \n-#define IVF_FILE_HDR_SZ  (32)\n-#define IVF_FRAME_HDR_SZ (12)\n+void usage_exit(void) {\n+  exit(EXIT_FAILURE);\n+}\n \n /*\n  * The input video frame is downsampled several times to generate a multi-level\n@@ -38,32 +56,18 @@\n\n  * bitstreams with resolution of 1280x720(level 0), 640x360(level 1), and\n  * 320x180(level 2) respectively.\n  */\n+\n+/* Number of encoders (spatial resolutions) used in this test. */\n #define NUM_ENCODERS 3\n \n+/* Maximum number of temporal layers allowed for this test. */\n+#define MAX_NUM_TEMPORAL_LAYERS 3\n+\n /* This example uses the scaler function in libyuv. */\n #include \""third_party/libyuv/include/libyuv/basic_types.h\""\n #include \""third_party/libyuv/include/libyuv/scale.h\""\n #include \""third_party/libyuv/include/libyuv/cpu_id.h\""\n \n-static void die(const char *fmt, ...) {\n-    va_list ap;\n-\n-    va_start(ap, fmt);\n-    vprintf(fmt, ap);\n-    if(fmt[strlen(fmt)-1] != '\\n')\n-        printf(\""\\n\"");\n-    exit(EXIT_FAILURE);\n-}\n-\n-static void die_codec(vpx_codec_ctx_t *ctx, const char *s) {\n-    const char *detail = vpx_codec_error_detail(ctx);\n-\n-    printf(\""%s: %s\\n\"", s, vpx_codec_error(ctx));\n-    if(detail)\n-        printf(\""    %s\\n\"",detail);\n-    exit(EXIT_FAILURE);\n-}\n-\n int (*read_frame_p)(FILE *f, vpx_image_t *img);\n \n static int read_frame(FILE *f, vpx_image_t *img) {\n@@ -170,21 +174,172 @@\n\n     (void) fwrite(header, 1, 12, outfile);\n }\n \n+/* Temporal scaling parameters */\n+/* This sets all the temporal layer parameters given |num_temporal_layers|,\n+ * including the target bit allocation across temporal layers. Bit allocation\n+ * parameters will be passed in as user parameters in another version.\n+ */\n+static void set_temporal_layer_pattern(int num_temporal_layers,\n+                                       vpx_codec_enc_cfg_t *cfg,\n+                                       int bitrate,\n+                                       int *layer_flags)\n+{\n+    assert(num_temporal_layers <= MAX_NUM_TEMPORAL_LAYERS);\n+    switch (num_temporal_layers)\n+    {\n+    case 1:\n+    {\n+        /* 1-layer */\n+        cfg->ts_number_layers     = 1;\n+        cfg->ts_periodicity       = 1;\n+        cfg->ts_rate_decimator[0] = 1;\n+        cfg->ts_layer_id[0] = 0;\n+        cfg->ts_target_bitrate[0] = bitrate;\n+\n+        // Update L only.\n+        layer_flags[0] = VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF;\n+        break;\n+    }\n+\n+    case 2:\n+    {\n+        /* 2-layers, with sync point at first frame of layer 1. */\n+        cfg->ts_number_layers     = 2;\n+        cfg->ts_periodicity       = 2;\n+        cfg->ts_rate_decimator[0] = 2;\n+        cfg->ts_rate_decimator[1] = 1;\n+        cfg->ts_layer_id[0] = 0;\n+        cfg->ts_layer_id[1] = 1;\n+        // Use 60/40 bit allocation as example.\n+        cfg->ts_target_bitrate[0] = 0.6f * bitrate;\n+        cfg->ts_target_bitrate[1] = bitrate;\n+\n+        /* 0=L, 1=GF */\n+        // ARF is used as predictor for all frames, and is only updated on\n+        // key frame. Sync point every 8 frames.\n+\n+        // Layer 0: predict from L and ARF, update L and G.\n+        layer_flags[0] = VP8_EFLAG_NO_REF_GF |\n+                         VP8_EFLAG_NO_UPD_ARF;\n+\n+        // Layer 1: sync point: predict from L and ARF, and update G.\n+        layer_flags[1] = VP8_EFLAG_NO_REF_GF |\n+                         VP8_EFLAG_NO_UPD_LAST |\n+                         VP8_EFLAG_NO_UPD_ARF;\n+\n+        // Layer 0, predict from L and ARF, update L.\n+        layer_flags[2] = VP8_EFLAG_NO_REF_GF  |\n+                         VP8_EFLAG_NO_UPD_GF  |\n+                         VP8_EFLAG_NO_UPD_ARF;\n+\n+        // Layer 1: predict from L, G and ARF, and update G.\n+        layer_flags[3] = VP8_EFLAG_NO_UPD_ARF |\n+                         VP8_EFLAG_NO_UPD_LAST |\n+                         VP8_EFLAG_NO_UPD_ENTROPY;\n+\n+        // Layer 0\n+        layer_flags[4] = layer_flags[2];\n+\n+        // Layer 1\n+        layer_flags[5] = layer_flags[3];\n+\n+        // Layer 0\n+        layer_flags[6] = layer_flags[4];\n+\n+        // Layer 1\n+        layer_flags[7] = layer_flags[5];\n+        break;\n+    }\n+\n+    case 3:\n+    default:\n+    {\n+        // 3-layers structure where ARF is used as predictor for all frames,\n+        // and is only updated on key frame.\n+        // Sync points for layer 1 and 2 every 8 frames.\n+        cfg->ts_number_layers     = 3;\n+        cfg->ts_periodicity       = 4;\n+        cfg->ts_rate_decimator[0] = 4;\n+        cfg->ts_rate_decimator[1] = 2;\n+        cfg->ts_rate_decimator[2] = 1;\n+        cfg->ts_layer_id[0] = 0;\n+        cfg->ts_layer_id[1] = 2;\n+        cfg->ts_layer_id[2] = 1;\n+        cfg->ts_layer_id[3] = 2;\n+        // Use 40/20/40 bit allocation as example.\n+        cfg->ts_target_bitrate[0] = 0.4f * bitrate;\n+        cfg->ts_target_bitrate[1] = 0.6f * bitrate;\n+        cfg->ts_target_bitrate[2] = bitrate;\n+\n+        /* 0=L, 1=GF, 2=ARF */\n+\n+        // Layer 0: predict from L and ARF; update L and G.\n+        layer_flags[0] =  VP8_EFLAG_NO_UPD_ARF |\n+                          VP8_EFLAG_NO_REF_GF;\n+\n+        // Layer 2: sync point: predict from L and ARF; update none.\n+        layer_flags[1] = VP8_EFLAG_NO_REF_GF |\n+                         VP8_EFLAG_NO_UPD_GF |\n+                         VP8_EFLAG_NO_UPD_ARF |\n+                         VP8_EFLAG_NO_UPD_LAST |\n+                         VP8_EFLAG_NO_UPD_ENTROPY;\n+\n+        // Layer 1: sync point: predict from L and ARF; update G.\n+        layer_flags[2] = VP8_EFLAG_NO_REF_GF |\n+                         VP8_EFLAG_NO_UPD_ARF |\n+                         VP8_EFLAG_NO_UPD_LAST;\n+\n+        // Layer 2: predict from L, G, ARF; update none.\n+        layer_flags[3] = VP8_EFLAG_NO_UPD_GF |\n+                         VP8_EFLAG_NO_UPD_ARF |\n+                         VP8_EFLAG_NO_UPD_LAST |\n+                         VP8_EFLAG_NO_UPD_ENTROPY;\n+\n+        // Layer 0: predict from L and ARF; update L.\n+        layer_flags[4] = VP8_EFLAG_NO_UPD_GF |\n+                         VP8_EFLAG_NO_UPD_ARF |\n+                         VP8_EFLAG_NO_REF_GF;\n+\n+        // Layer 2: predict from L, G, ARF; update none.\n+        layer_flags[5] = layer_flags[3];\n+\n+        // Layer 1: predict from L, G, ARF; update G.\n+        layer_flags[6] = VP8_EFLAG_NO_UPD_ARF |\n+                         VP8_EFLAG_NO_UPD_LAST;\n+\n+        // Layer 2: predict from L, G, ARF; update none.\n+        layer_flags[7] = layer_flags[3];\n+        break;\n+    }\n+    }\n+}\n+\n+/* The periodicity of the pattern given the number of temporal layers. */\n+static int periodicity_to_num_layers[MAX_NUM_TEMPORAL_LAYERS] = {1, 8, 8};\n+\n int main(int argc, char **argv)\n {\n-    FILE                *infile, *outfile[NUM_ENCODERS];\n+    FILE                 *infile, *outfile[NUM_ENCODERS];\n+    FILE                 *downsampled_input[NUM_ENCODERS - 1];\n+    char                 filename[50];\n     vpx_codec_ctx_t      codec[NUM_ENCODERS];\n     vpx_codec_enc_cfg_t  cfg[NUM_ENCODERS];\n-    vpx_codec_pts_t      frame_cnt = 0;\n+    int                  frame_cnt = 0;\n     vpx_image_t          raw[NUM_ENCODERS];\n     vpx_codec_err_t      res[NUM_ENCODERS];\n \n     int                  i;\n     long                 width;\n     long                 height;\n+    int                  length_frame;\n     int                  frame_avail;\n     int                  got_data;\n     int                  flags = 0;\n+    int                  layer_id = 0;\n+\n+    int                  layer_flags[VPX_TS_MAX_PERIODICITY * NUM_ENCODERS]\n+                                     = {0};\n+    int                  flag_periodicity;\n \n     /*Currently, only realtime mode is supported in multi-resolution encoding.*/\n     int                  arg_deadline = VPX_DL_REALTIME;\n@@ -193,39 +348,51 @@\n\n        don't need to know PSNR, which will skip PSNR calculation and save\n        encoding time. */\n     int                  show_psnr = 0;\n+    int                  key_frame_insert = 0;\n     uint64_t             psnr_sse_total[NUM_ENCODERS] = {0};\n     uint64_t             psnr_samples_total[NUM_ENCODERS] = {0};\n     double               psnr_totals[NUM_ENCODERS][4] = {{0,0}};\n     int                  psnr_count[NUM_ENCODERS] = {0};\n \n+    double               cx_time = 0;\n+    struct  timeval      tv1, tv2, difftv;\n+\n     /* Set the required target bitrates for each resolution level.\n      * If target bitrate for highest-resolution level is set to 0,\n      * (i.e. target_bitrate[0]=0), we skip encoding at that level.\n      */\n     unsigned int         target_bitrate[NUM_ENCODERS]={1000, 500, 100};\n+\n     /* Enter the frame rate of the input video */\n     int                  framerate = 30;\n+\n     /* Set down-sampling factor for each resolution level.\n        dsf[0] controls down sampling from level 0 to level 1;\n        dsf[1] controls down sampling from level 1 to level 2;\n        dsf[2] is not used. */\n     vpx_rational_t dsf[NUM_ENCODERS] = {{2, 1}, {2, 1}, {1, 1}};\n \n-    if(argc!= (5+NUM_ENCODERS))\n-        die(\""Usage: %s <width> <height> <infile> <outfile(s)> <output psnr?>\\n\"",\n+    /* Set the number of temporal layers for each encoder/resolution level,\n+     * starting from highest resoln down to lowest resoln. */\n+    unsigned int         num_temporal_layers[NUM_ENCODERS] = {3, 3, 3};\n+\n+    if(argc!= (7 + 3 * NUM_ENCODERS))\n+        die(\""Usage: %s <width> <height> <frame_rate>  <infile> <outfile(s)> \""\n+            \""<rate_encoder(s)> <temporal_layer(s)> <key_frame_insert> <output psnr?> \\n\"",\n             argv[0]);\n \n     printf(\""Using %s\\n\"",vpx_codec_iface_name(interface));\n \n     width = strtol(argv[1], NULL, 0);\n     height = strtol(argv[2], NULL, 0);\n+    framerate = strtol(argv[3], NULL, 0);\n \n     if(width < 16 || width%2 || height <16 || height%2)\n         die(\""Invalid resolution: %ldx%ld\"", width, height);\n \n     /* Open input video file for encoding */\n-    if(!(infile = fopen(argv[3], \""rb\"")))\n-        die(\""Failed to open %s for reading\"", argv[3]);\n+    if(!(infile = fopen(argv[4], \""rb\"")))\n+        die(\""Failed to open %s for reading\"", argv[4]);\n \n     /* Open output file for each encoder to output bitstreams */\n     for (i=0; i< NUM_ENCODERS; i++)\n@@ -236,11 +403,40 @@\n\n             continue;\n         }\n \n-        if(!(outfile[i] = fopen(argv[i+4], \""wb\"")))\n+        if(!(outfile[i] = fopen(argv[i+5], \""wb\"")))\n             die(\""Failed to open %s for writing\"", argv[i+4]);\n     }\n \n-    show_psnr = strtol(argv[NUM_ENCODERS + 4], NULL, 0);\n+    // Bitrates per spatial layer: overwrite default rates above.\n+    for (i=0; i< NUM_ENCODERS; i++)\n+    {\n+        target_bitrate[i] = strtol(argv[NUM_ENCODERS + 5 + i], NULL, 0);\n+    }\n+\n+    // Temporal layers per spatial layers: overwrite default settings above.\n+    for (i=0; i< NUM_ENCODERS; i++)\n+    {\n+        num_temporal_layers[i] = strtol(argv[2 * NUM_ENCODERS + 5 + i], NULL, 0);\n+        if (num_temporal_layers[i] < 1 || num_temporal_layers[i] > 3)\n+          die(\""Invalid temporal layers: %d, Must be 1, 2, or 3. \\n\"",\n+              num_temporal_layers);\n+    }\n+\n+    /* Open file to write out each spatially downsampled input stream. */\n+    for (i=0; i< NUM_ENCODERS - 1; i++)\n+    {\n+       // Highest resoln is encoder 0.\n+        if (sprintf(filename,\""ds%d.yuv\"",NUM_ENCODERS - i) < 0)\n+        {\n+            return EXIT_FAILURE;\n+        }\n+        downsampled_input[i] = fopen(filename,\""wb\"");\n+    }\n+\n+    key_frame_insert = strtol(argv[3 * NUM_ENCODERS + 5], NULL, 0);\n+\n+    show_psnr = strtol(argv[3 * NUM_ENCODERS + 6], NULL, 0);\n+\n \n     /* Populate default encoder configuration */\n     for (i=0; i< NUM_ENCODERS; i++)\n@@ -258,14 +454,13 @@\n\n     /* Highest-resolution encoder settings */\n     cfg[0].g_w = width;\n     cfg[0].g_h = height;\n-    cfg[0].g_threads = 1;                           /* number of threads used */\n-    cfg[0].rc_dropframe_thresh = 30;\n+    cfg[0].rc_dropframe_thresh = 0;\n     cfg[0].rc_end_usage = VPX_CBR;\n     cfg[0].rc_resize_allowed = 0;\n-    cfg[0].rc_min_quantizer = 4;\n+    cfg[0].rc_min_quantizer = 2;\n     cfg[0].rc_max_quantizer = 56;\n-    cfg[0].rc_undershoot_pct = 98;\n-    cfg[0].rc_overshoot_pct = 100;\n+    cfg[0].rc_undershoot_pct = 100;\n+    cfg[0].rc_overshoot_pct = 15;\n     cfg[0].rc_buf_initial_sz = 500;\n     cfg[0].rc_buf_optimal_sz = 600;\n     cfg[0].rc_buf_sz = 1000;\n@@ -276,7 +471,6 @@\n\n     /* Note: These 3 settings are copied to all levels. But, except the lowest\n      * resolution level, all other levels are set to VPX_KF_DISABLED internally.\n      */\n-    //cfg[0].kf_mode           = VPX_KF_DISABLED;\n     cfg[0].kf_mode           = VPX_KF_AUTO;\n     cfg[0].kf_min_dist = 3000;\n     cfg[0].kf_max_dist = 3000;\n@@ -290,7 +484,6 @@\n\n     {\n         memcpy(&cfg[i], &cfg[0], sizeof(vpx_codec_enc_cfg_t));\n \n-        cfg[i].g_threads = 1;                       /* number of threads used */\n         cfg[i].rc_target_bitrate = target_bitrate[i];\n \n         /* Note: Width & height of other-resolution encoders are calculated\n@@ -310,6 +503,13 @@\n\n         if((cfg[i].g_h)%2)cfg[i].g_h++;\n     }\n \n+\n+    // Set the number of threads per encode/spatial layer.\n+    // (1, 1, 1) means no encoder threading.\n+    cfg[0].g_threads = 2;\n+    cfg[1].g_threads = 1;\n+    cfg[2].g_threads = 1;\n+\n     /* Allocate image for each encoder */\n     for (i=0; i< NUM_ENCODERS; i++)\n         if(!vpx_img_alloc(&raw[i], VPX_IMG_FMT_I420, cfg[i].g_w, cfg[i].g_h, 32))\n@@ -324,6 +524,15 @@\n\n         if(outfile[i])\n             write_ivf_file_header(outfile[i], &cfg[i], 0);\n \n+    /* Temporal layers settings */\n+    for ( i=0; i<NUM_ENCODERS; i++)\n+    {\n+        set_temporal_layer_pattern(num_temporal_layers[i],\n+                                   &cfg[i],\n+                                   cfg[i].rc_target_bitrate,\n+                                   &layer_flags[i * VPX_TS_MAX_PERIODICITY]);\n+    }\n+\n     /* Initialize multi-encoder */\n     if(vpx_codec_enc_init_multi(&codec[0], interface, &cfg[0], NUM_ENCODERS,\n                                 (show_psnr ? VPX_CODEC_USE_PSNR : 0), &dsf[0]))\n@@ -334,15 +543,16 @@\n\n     for ( i=0; i<NUM_ENCODERS; i++)\n     {\n         int speed = -6;\n+        /* Lower speed for the lowest resolution. */\n+        if (i == NUM_ENCODERS - 1) speed = -4;\n         if(vpx_codec_control(&codec[i], VP8E_SET_CPUUSED, speed))\n             die_codec(&codec[i], \""Failed to set cpu_used\"");\n     }\n \n-    /* Set static threshold. */\n+    /* Set static threshold = 1 for all encoders */\n     for ( i=0; i<NUM_ENCODERS; i++)\n     {\n-        unsigned int static_thresh = 1;\n-        if(vpx_codec_control(&codec[i], VP8E_SET_STATIC_THRESHOLD, static_thresh))\n+        if(vpx_codec_control(&codec[i], VP8E_SET_STATIC_THRESHOLD, 1))\n             die_codec(&codec[i], \""Failed to set static threshold\"");\n     }\n \n@@ -356,6 +566,23 @@\n\n             die_codec(&codec[i], \""Failed to set noise_sensitivity\"");\n     }\n \n+    /* Set the number of token partitions */\n+    for ( i=0; i<NUM_ENCODERS; i++)\n+    {\n+        if(vpx_codec_control(&codec[i], VP8E_SET_TOKEN_PARTITIONS, 1))\n+            die_codec(&codec[i], \""Failed to set static threshold\"");\n+    }\n+\n+    /* Set the max intra target bitrate */\n+    for ( i=0; i<NUM_ENCODERS; i++)\n+    {\n+        unsigned int max_intra_size_pct =\n+            (int)(((double)cfg[0].rc_buf_optimal_sz * 0.5) * framerate / 10);\n+        if(vpx_codec_control(&codec[i], VP8E_SET_MAX_INTRA_BITRATE_PCT,\n+                             max_intra_size_pct))\n+            die_codec(&codec[i], \""Failed to set static threshold\"");\n+       //printf(\""%d %d \\n\"",i,max_intra_size_pct);\n+    }\n \n     frame_avail = 1;\n     got_data = 0;\n@@ -382,18 +609,55 @@\n\n                           raw[i].planes[VPX_PLANE_U], raw[i].stride[VPX_PLANE_U],\n                           raw[i].planes[VPX_PLANE_V], raw[i].stride[VPX_PLANE_V],\n                           raw[i].d_w, raw[i].d_h, 1);\n+                /* Write out down-sampled input. */\n+                length_frame = cfg[i].g_w *  cfg[i].g_h *3/2;\n+                if (fwrite(raw[i].planes[0], 1, length_frame,\n+                           downsampled_input[NUM_ENCODERS - i - 1]) !=\n+                               length_frame)\n+                {\n+                    return EXIT_FAILURE;\n+                }\n             }\n         }\n \n-        /* Encode each frame at multi-levels */\n-        if(vpx_codec_encode(&codec[0], frame_avail? &raw[0] : NULL,\n-            frame_cnt, 1, flags, arg_deadline))\n-            die_codec(&codec[0], \""Failed to encode frame\"");\n+        /* Set the flags (reference and update) for all the encoders.*/\n+        for ( i=0; i<NUM_ENCODERS; i++)\n+        {\n+            layer_id = cfg[i].ts_layer_id[frame_cnt % cfg[i].ts_periodicity];\n+            flags = 0;\n+            flag_periodicity = periodicity_to_num_layers\n+                [num_temporal_layers[i] - 1];\n+            flags = layer_flags[i * VPX_TS_MAX_PERIODICITY +\n+                                frame_cnt % flag_periodicity];\n+            // Key frame flag for first frame.\n+            if (frame_cnt == 0)\n+            {\n+                flags |= VPX_EFLAG_FORCE_KF;\n+            }\n+            if (frame_cnt > 0 && frame_cnt == key_frame_insert)\n+            {\n+                flags = VPX_EFLAG_FORCE_KF;\n+            }\n \n+            vpx_codec_control(&codec[i], VP8E_SET_FRAME_FLAGS, flags);\n+            vpx_codec_control(&codec[i], VP8E_SET_TEMPORAL_LAYER_ID, layer_id);\n+        }\n+\n+        gettimeofday(&tv1, NULL);\n+        /* Encode each frame at multi-levels */\n+        /* Note the flags must be set to 0 in the encode call if they are set\n+           for each frame with the vpx_codec_control(), as done above. */\n+        if(vpx_codec_encode(&codec[0], frame_avail? &raw[0] : NULL,\n+            frame_cnt, 1, 0, arg_deadline))\n+        {\n+            die_codec(&codec[0], \""Failed to encode frame\"");\n+        }\n+        gettimeofday(&tv2, NULL);\n+        timersub(&tv2, &tv1, &difftv);\n+        cx_time += (double)(difftv.tv_sec * 1000000 + difftv.tv_usec);\n         for (i=NUM_ENCODERS-1; i>=0 ; i--)\n         {\n             got_data = 0;\n-\n             while( (pkt[i] = vpx_codec_get_cx_data(&codec[i], &iter[i])) )\n             {\n                 got_data = 1;\n@@ -412,7 +676,6 @@\n\n                             psnr_samples_total[i] += pkt[i]->data.psnr.samples[0];\n                             for (j = 0; j < 4; j++)\n                             {\n-                                //fprintf(stderr, \""%.3lf \"", pkt[i]->data.psnr.psnr[j]);\n                                 psnr_totals[i][j] += pkt[i]->data.psnr.psnr[j];\n                             }\n                             psnr_count[i]++;\n@@ -423,13 +686,15 @@\n\n                         break;\n                 }\n                 printf(pkt[i]->kind == VPX_CODEC_CX_FRAME_PKT\n-                       && (pkt[i]->data.frame.flags & VPX_FRAME_IS_KEY)? \""K\"":\"".\"");\n+                       && (pkt[i]->data.frame.flags & VPX_FRAME_IS_KEY)? \""K\"":\""\"");\n                 fflush(stdout);\n             }\n         }\n         frame_cnt++;\n     }\n     printf(\""\\n\"");\n+    printf(\""FPS for encoding %d %f %f \\n\"", frame_cnt, (float)cx_time / 1000000,\n+           1000000 * (double)frame_cnt / (double)cx_time);\n \n     fclose(infile);\n \n""}<_**next**_>{""filename"": ""libvpx/examples/vp8cx_set_ref.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/examples/vp8cx_set_ref.c"", ""patch"": ""@@ -50,25 +50,25 @@\n\n #include <stdlib.h>\n #include <string.h>\n \n-#define VPX_CODEC_DISABLE_COMPAT 1\n #include \""vpx/vp8cx.h\""\n #include \""vpx/vpx_encoder.h\""\n \n-#include \""./tools_common.h\""\n-#include \""./video_writer.h\""\n+#include \""../tools_common.h\""\n+#include \""../video_writer.h\""\n \n static const char *exec_name;\n \n-void usage_exit() {\n+void usage_exit(void) {\n   fprintf(stderr, \""Usage: %s <width> <height> <infile> <outfile> <frame>\\n\"",\n           exec_name);\n   exit(EXIT_FAILURE);\n }\n \n-static void encode_frame(vpx_codec_ctx_t *codec,\n-                         vpx_image_t *img,\n-                         int frame_index,\n-                         VpxVideoWriter *writer) {\n+static int encode_frame(vpx_codec_ctx_t *codec,\n+                        vpx_image_t *img,\n+                        int frame_index,\n+                        VpxVideoWriter *writer) {\n+  int got_pkts = 0;\n   vpx_codec_iter_t iter = NULL;\n   const vpx_codec_cx_pkt_t *pkt = NULL;\n   const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1, 0,\n@@ -77,6 +77,8 @@\n\n     die_codec(codec, \""Failed to encode frame\"");\n \n   while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {\n+    got_pkts = 1;\n+\n     if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {\n       const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;\n       if (!vpx_video_writer_write_frame(writer,\n@@ -90,6 +92,8 @@\n\n       fflush(stdout);\n     }\n   }\n+\n+  return got_pkts;\n }\n \n int main(int argc, char **argv) {\n@@ -138,9 +142,9 @@\n\n     die(\""Failed to allocate image.\"");\n   }\n \n-  printf(\""Using %s\\n\"", vpx_codec_iface_name(encoder->interface()));\n+  printf(\""Using %s\\n\"", vpx_codec_iface_name(encoder->codec_interface()));\n \n-  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);\n+  res = vpx_codec_enc_config_default(encoder->codec_interface(), &cfg, 0);\n   if (res)\n     die_codec(&codec, \""Failed to get default codec config.\"");\n \n@@ -157,9 +161,10 @@\n\n   if (!(infile = fopen(argv[3], \""rb\"")))\n     die(\""Failed to open %s for reading.\"", argv[3]);\n \n-  if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))\n+  if (vpx_codec_enc_init(&codec, encoder->codec_interface(), &cfg, 0))\n     die_codec(&codec, \""Failed to initialize encoder\"");\n \n+  // Encode frames.\n   while (vpx_img_read(&raw, infile)) {\n     if (frame_count + 1 == update_frame_num) {\n       vpx_ref_frame_t ref;\n@@ -171,7 +176,9 @@\n\n \n     encode_frame(&codec, &raw, frame_count++, writer);\n   }\n-  encode_frame(&codec, NULL, -1, writer);\n+\n+  // Flush encoder.\n+  while (encode_frame(&codec, NULL, -1, writer)) {}\n \n   printf(\""\\n\"");\n   fclose(infile);\n""}<_**next**_>{""filename"": ""libvpx/examples/vp9_lossless_encoder.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/examples/vp9_lossless_encoder.c"", ""patch"": ""@@ -0,0 +1,144 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \""vpx/vpx_encoder.h\""\n+#include \""vpx/vp8cx.h\""\n+\n+#include \""../tools_common.h\""\n+#include \""../video_writer.h\""\n+\n+static const char *exec_name;\n+\n+void usage_exit(void) {\n+  fprintf(stderr, \""vp9_lossless_encoder: Example demonstrating VP9 lossless \""\n+                  \""encoding feature. Supports raw input only.\\n\"");\n+  fprintf(stderr, \""Usage: %s <width> <height> <infile> <outfile>\\n\"", exec_name);\n+  exit(EXIT_FAILURE);\n+}\n+\n+static int encode_frame(vpx_codec_ctx_t *codec,\n+                        vpx_image_t *img,\n+                        int frame_index,\n+                        int flags,\n+                        VpxVideoWriter *writer) {\n+  int got_pkts = 0;\n+  vpx_codec_iter_t iter = NULL;\n+  const vpx_codec_cx_pkt_t *pkt = NULL;\n+  const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1,\n+                                               flags, VPX_DL_GOOD_QUALITY);\n+  if (res != VPX_CODEC_OK)\n+    die_codec(codec, \""Failed to encode frame\"");\n+\n+  while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {\n+    got_pkts = 1;\n+\n+    if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {\n+      const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;\n+      if (!vpx_video_writer_write_frame(writer,\n+                                        pkt->data.frame.buf,\n+                                        pkt->data.frame.sz,\n+                                        pkt->data.frame.pts)) {\n+        die_codec(codec, \""Failed to write compressed frame\"");\n+      }\n+      printf(keyframe ? \""K\"" : \"".\"");\n+      fflush(stdout);\n+    }\n+  }\n+\n+  return got_pkts;\n+}\n+\n+int main(int argc, char **argv) {\n+  FILE *infile = NULL;\n+  vpx_codec_ctx_t codec;\n+  vpx_codec_enc_cfg_t cfg;\n+  int frame_count = 0;\n+  vpx_image_t raw;\n+  vpx_codec_err_t res;\n+  VpxVideoInfo info = {0};\n+  VpxVideoWriter *writer = NULL;\n+  const VpxInterface *encoder = NULL;\n+  const int fps = 30;\n+\n+  exec_name = argv[0];\n+\n+  if (argc < 5)\n+    die(\""Invalid number of arguments\"");\n+\n+  encoder = get_vpx_encoder_by_name(\""vp9\"");\n+  if (!encoder)\n+     die(\""Unsupported codec.\"");\n+\n+  info.codec_fourcc = encoder->fourcc;\n+  info.frame_width = strtol(argv[1], NULL, 0);\n+  info.frame_height = strtol(argv[2], NULL, 0);\n+  info.time_base.numerator = 1;\n+  info.time_base.denominator = fps;\n+\n+  if (info.frame_width <= 0 ||\n+      info.frame_height <= 0 ||\n+      (info.frame_width % 2) != 0 ||\n+      (info.frame_height % 2) != 0) {\n+    die(\""Invalid frame size: %dx%d\"", info.frame_width, info.frame_height);\n+  }\n+\n+  if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,\n+                                             info.frame_height, 1)) {\n+    die(\""Failed to allocate image.\"");\n+  }\n+\n+  printf(\""Using %s\\n\"", vpx_codec_iface_name(encoder->codec_interface()));\n+\n+  res = vpx_codec_enc_config_default(encoder->codec_interface(), &cfg, 0);\n+  if (res)\n+    die_codec(&codec, \""Failed to get default codec config.\"");\n+\n+  cfg.g_w = info.frame_width;\n+  cfg.g_h = info.frame_height;\n+  cfg.g_timebase.num = info.time_base.numerator;\n+  cfg.g_timebase.den = info.time_base.denominator;\n+\n+  writer = vpx_video_writer_open(argv[4], kContainerIVF, &info);\n+  if (!writer)\n+    die(\""Failed to open %s for writing.\"", argv[4]);\n+\n+  if (!(infile = fopen(argv[3], \""rb\"")))\n+    die(\""Failed to open %s for reading.\"", argv[3]);\n+\n+  if (vpx_codec_enc_init(&codec, encoder->codec_interface(), &cfg, 0))\n+    die_codec(&codec, \""Failed to initialize encoder\"");\n+\n+  if (vpx_codec_control_(&codec, VP9E_SET_LOSSLESS, 1))\n+    die_codec(&codec, \""Failed to use lossless mode\"");\n+\n+  // Encode frames.\n+  while (vpx_img_read(&raw, infile)) {\n+    encode_frame(&codec, &raw, frame_count++, 0, writer);\n+  }\n+\n+  // Flush encoder.\n+  while (encode_frame(&codec, NULL, -1, 0, writer)) {}\n+\n+  printf(\""\\n\"");\n+  fclose(infile);\n+  printf(\""Processed %d frames.\\n\"", frame_count);\n+\n+  vpx_img_free(&raw);\n+  if (vpx_codec_destroy(&codec))\n+    die_codec(&codec, \""Failed to destroy codec.\"");\n+\n+  vpx_video_writer_close(writer);\n+\n+  return EXIT_SUCCESS;\n+}\n""}<_**next**_>{""filename"": ""libvpx/examples/vp9_spatial_svc_encoder.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/examples/vp9_spatial_svc_encoder.c"", ""patch"": ""@@ -0,0 +1,792 @@\n\n+/*\n+ *  Copyright (c) 2012 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+/*\n+ * This is an example demonstrating how to implement a multi-layer\n+ * VP9 encoding scheme based on spatial scalability for video applications\n+ * that benefit from a scalable bitstream.\n+ */\n+\n+#include <math.h>\n+#include <stdarg.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+\n+\n+#include \""../args.h\""\n+#include \""../tools_common.h\""\n+#include \""../video_writer.h\""\n+\n+#include \""vpx/svc_context.h\""\n+#include \""vpx/vp8cx.h\""\n+#include \""vpx/vpx_encoder.h\""\n+#include \""../vpxstats.h\""\n+#define OUTPUT_RC_STATS 1\n+\n+static const arg_def_t skip_frames_arg =\n+    ARG_DEF(\""s\"", \""skip-frames\"", 1, \""input frames to skip\"");\n+static const arg_def_t frames_arg =\n+    ARG_DEF(\""f\"", \""frames\"", 1, \""number of frames to encode\"");\n+static const arg_def_t threads_arg =\n+    ARG_DEF(\""th\"", \""threads\"", 1, \""number of threads to use\"");\n+#if OUTPUT_RC_STATS\n+static const arg_def_t output_rc_stats_arg =\n+    ARG_DEF(\""rcstat\"", \""output_rc_stats\"", 1, \""output rc stats\"");\n+#endif\n+static const arg_def_t width_arg = ARG_DEF(\""w\"", \""width\"", 1, \""source width\"");\n+static const arg_def_t height_arg = ARG_DEF(\""h\"", \""height\"", 1, \""source height\"");\n+static const arg_def_t timebase_arg =\n+    ARG_DEF(\""t\"", \""timebase\"", 1, \""timebase (num/den)\"");\n+static const arg_def_t bitrate_arg = ARG_DEF(\n+    \""b\"", \""target-bitrate\"", 1, \""encoding bitrate, in kilobits per second\"");\n+static const arg_def_t spatial_layers_arg =\n+    ARG_DEF(\""sl\"", \""spatial-layers\"", 1, \""number of spatial SVC layers\"");\n+static const arg_def_t temporal_layers_arg =\n+    ARG_DEF(\""tl\"", \""temporal-layers\"", 1, \""number of temporal SVC layers\"");\n+static const arg_def_t temporal_layering_mode_arg =\n+    ARG_DEF(\""tlm\"", \""temporal-layering-mode\"", 1, \""temporal layering scheme.\""\n+        \""VP9E_TEMPORAL_LAYERING_MODE\"");\n+static const arg_def_t kf_dist_arg =\n+    ARG_DEF(\""k\"", \""kf-dist\"", 1, \""number of frames between keyframes\"");\n+static const arg_def_t scale_factors_arg =\n+    ARG_DEF(\""r\"", \""scale-factors\"", 1, \""scale factors (lowest to highest layer)\"");\n+static const arg_def_t passes_arg =\n+    ARG_DEF(\""p\"", \""passes\"", 1, \""Number of passes (1/2)\"");\n+static const arg_def_t pass_arg =\n+    ARG_DEF(NULL, \""pass\"", 1, \""Pass to execute (1/2)\"");\n+static const arg_def_t fpf_name_arg =\n+    ARG_DEF(NULL, \""fpf\"", 1, \""First pass statistics file name\"");\n+static const arg_def_t min_q_arg =\n+    ARG_DEF(NULL, \""min-q\"", 1, \""Minimum quantizer\"");\n+static const arg_def_t max_q_arg =\n+    ARG_DEF(NULL, \""max-q\"", 1, \""Maximum quantizer\"");\n+static const arg_def_t min_bitrate_arg =\n+    ARG_DEF(NULL, \""min-bitrate\"", 1, \""Minimum bitrate\"");\n+static const arg_def_t max_bitrate_arg =\n+    ARG_DEF(NULL, \""max-bitrate\"", 1, \""Maximum bitrate\"");\n+static const arg_def_t lag_in_frame_arg =\n+    ARG_DEF(NULL, \""lag-in-frames\"", 1, \""Number of frame to input before \""\n+        \""generating any outputs\"");\n+static const arg_def_t rc_end_usage_arg =\n+    ARG_DEF(NULL, \""rc-end-usage\"", 1, \""0 - 3: VBR, CBR, CQ, Q\"");\n+static const arg_def_t speed_arg =\n+    ARG_DEF(\""sp\"", \""speed\"", 1, \""speed configuration\"");\n+\n+#if CONFIG_VP9_HIGHBITDEPTH\n+static const struct arg_enum_list bitdepth_enum[] = {\n+  {\""8\"",  VPX_BITS_8},\n+  {\""10\"", VPX_BITS_10},\n+  {\""12\"", VPX_BITS_12},\n+  {NULL, 0}\n+};\n+\n+static const arg_def_t bitdepth_arg =\n+    ARG_DEF_ENUM(\""d\"", \""bit-depth\"", 1, \""Bit depth for codec 8, 10 or 12. \"",\n+                 bitdepth_enum);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+\n+\n+static const arg_def_t *svc_args[] = {\n+  &frames_arg,        &width_arg,         &height_arg,\n+  &timebase_arg,      &bitrate_arg,       &skip_frames_arg, &spatial_layers_arg,\n+  &kf_dist_arg,       &scale_factors_arg, &passes_arg,      &pass_arg,\n+  &fpf_name_arg,      &min_q_arg,         &max_q_arg,       &min_bitrate_arg,\n+  &max_bitrate_arg,   &temporal_layers_arg, &temporal_layering_mode_arg,\n+  &lag_in_frame_arg,  &threads_arg,\n+#if OUTPUT_RC_STATS\n+  &output_rc_stats_arg,\n+#endif\n+\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  &bitdepth_arg,\n+#endif\n+  &speed_arg,\n+  &rc_end_usage_arg,  NULL\n+};\n+\n+static const uint32_t default_frames_to_skip = 0;\n+static const uint32_t default_frames_to_code = 60 * 60;\n+static const uint32_t default_width = 1920;\n+static const uint32_t default_height = 1080;\n+static const uint32_t default_timebase_num = 1;\n+static const uint32_t default_timebase_den = 60;\n+static const uint32_t default_bitrate = 1000;\n+static const uint32_t default_spatial_layers = 5;\n+static const uint32_t default_temporal_layers = 1;\n+static const uint32_t default_kf_dist = 100;\n+static const uint32_t default_temporal_layering_mode = 0;\n+static const uint32_t default_output_rc_stats = 0;\n+static const int32_t default_speed = -1;  // -1 means use library default.\n+static const uint32_t default_threads = 0;  // zero means use library default.\n+\n+typedef struct {\n+  const char *input_filename;\n+  const char *output_filename;\n+  uint32_t frames_to_code;\n+  uint32_t frames_to_skip;\n+  struct VpxInputContext input_ctx;\n+  stats_io_t rc_stats;\n+  int passes;\n+  int pass;\n+} AppInput;\n+\n+static const char *exec_name;\n+\n+void usage_exit(void) {\n+  fprintf(stderr, \""Usage: %s <options> input_filename output_filename\\n\"",\n+          exec_name);\n+  fprintf(stderr, \""Options:\\n\"");\n+  arg_show_usage(stderr, svc_args);\n+  exit(EXIT_FAILURE);\n+}\n+\n+static void parse_command_line(int argc, const char **argv_,\n+                               AppInput *app_input, SvcContext *svc_ctx,\n+                               vpx_codec_enc_cfg_t *enc_cfg) {\n+  struct arg arg = {0};\n+  char **argv = NULL;\n+  char **argi = NULL;\n+  char **argj = NULL;\n+  vpx_codec_err_t res;\n+  int passes = 0;\n+  int pass = 0;\n+  const char *fpf_file_name = NULL;\n+  unsigned int min_bitrate = 0;\n+  unsigned int max_bitrate = 0;\n+  char string_options[1024] = {0};\n+\n+  // initialize SvcContext with parameters that will be passed to vpx_svc_init\n+  svc_ctx->log_level = SVC_LOG_DEBUG;\n+  svc_ctx->spatial_layers = default_spatial_layers;\n+  svc_ctx->temporal_layers = default_temporal_layers;\n+  svc_ctx->temporal_layering_mode = default_temporal_layering_mode;\n+#if OUTPUT_RC_STATS\n+  svc_ctx->output_rc_stat = default_output_rc_stats;\n+#endif\n+  svc_ctx->speed = default_speed;\n+  svc_ctx->threads = default_threads;\n+\n+  // start with default encoder configuration\n+  res = vpx_codec_enc_config_default(vpx_codec_vp9_cx(), enc_cfg, 0);\n+  if (res) {\n+    die(\""Failed to get config: %s\\n\"", vpx_codec_err_to_string(res));\n+  }\n+  // update enc_cfg with app default values\n+  enc_cfg->g_w = default_width;\n+  enc_cfg->g_h = default_height;\n+  enc_cfg->g_timebase.num = default_timebase_num;\n+  enc_cfg->g_timebase.den = default_timebase_den;\n+  enc_cfg->rc_target_bitrate = default_bitrate;\n+  enc_cfg->kf_min_dist = default_kf_dist;\n+  enc_cfg->kf_max_dist = default_kf_dist;\n+  enc_cfg->rc_end_usage = VPX_CQ;\n+\n+  // initialize AppInput with default values\n+  app_input->frames_to_code = default_frames_to_code;\n+  app_input->frames_to_skip = default_frames_to_skip;\n+\n+  // process command line options\n+  argv = argv_dup(argc - 1, argv_ + 1);\n+  for (argi = argj = argv; (*argj = *argi); argi += arg.argv_step) {\n+    arg.argv_step = 1;\n+\n+    if (arg_match(&arg, &frames_arg, argi)) {\n+      app_input->frames_to_code = arg_parse_uint(&arg);\n+    } else if (arg_match(&arg, &width_arg, argi)) {\n+      enc_cfg->g_w = arg_parse_uint(&arg);\n+    } else if (arg_match(&arg, &height_arg, argi)) {\n+      enc_cfg->g_h = arg_parse_uint(&arg);\n+    } else if (arg_match(&arg, &timebase_arg, argi)) {\n+      enc_cfg->g_timebase = arg_parse_rational(&arg);\n+    } else if (arg_match(&arg, &bitrate_arg, argi)) {\n+      enc_cfg->rc_target_bitrate = arg_parse_uint(&arg);\n+    } else if (arg_match(&arg, &skip_frames_arg, argi)) {\n+      app_input->frames_to_skip = arg_parse_uint(&arg);\n+    } else if (arg_match(&arg, &spatial_layers_arg, argi)) {\n+      svc_ctx->spatial_layers = arg_parse_uint(&arg);\n+    } else if (arg_match(&arg, &temporal_layers_arg, argi)) {\n+      svc_ctx->temporal_layers = arg_parse_uint(&arg);\n+#if OUTPUT_RC_STATS\n+    } else if (arg_match(&arg, &output_rc_stats_arg, argi)) {\n+      svc_ctx->output_rc_stat = arg_parse_uint(&arg);\n+#endif\n+    } else if (arg_match(&arg, &speed_arg, argi)) {\n+      svc_ctx->speed = arg_parse_uint(&arg);\n+    } else if (arg_match(&arg, &threads_arg, argi)) {\n+      svc_ctx->threads = arg_parse_uint(&arg);\n+    } else if (arg_match(&arg, &temporal_layering_mode_arg, argi)) {\n+      svc_ctx->temporal_layering_mode =\n+          enc_cfg->temporal_layering_mode = arg_parse_int(&arg);\n+      if (svc_ctx->temporal_layering_mode) {\n+        enc_cfg->g_error_resilient = 1;\n+      }\n+    } else if (arg_match(&arg, &kf_dist_arg, argi)) {\n+      enc_cfg->kf_min_dist = arg_parse_uint(&arg);\n+      enc_cfg->kf_max_dist = enc_cfg->kf_min_dist;\n+    } else if (arg_match(&arg, &scale_factors_arg, argi)) {\n+      snprintf(string_options, sizeof(string_options), \""%s scale-factors=%s\"",\n+               string_options, arg.val);\n+    } else if (arg_match(&arg, &passes_arg, argi)) {\n+      passes = arg_parse_uint(&arg);\n+      if (passes < 1 || passes > 2) {\n+        die(\""Error: Invalid number of passes (%d)\\n\"", passes);\n+      }\n+    } else if (arg_match(&arg, &pass_arg, argi)) {\n+      pass = arg_parse_uint(&arg);\n+      if (pass < 1 || pass > 2) {\n+        die(\""Error: Invalid pass selected (%d)\\n\"", pass);\n+      }\n+    } else if (arg_match(&arg, &fpf_name_arg, argi)) {\n+      fpf_file_name = arg.val;\n+    } else if (arg_match(&arg, &min_q_arg, argi)) {\n+      snprintf(string_options, sizeof(string_options), \""%s min-quantizers=%s\"",\n+               string_options, arg.val);\n+    } else if (arg_match(&arg, &max_q_arg, argi)) {\n+      snprintf(string_options, sizeof(string_options), \""%s max-quantizers=%s\"",\n+               string_options, arg.val);\n+    } else if (arg_match(&arg, &min_bitrate_arg, argi)) {\n+      min_bitrate = arg_parse_uint(&arg);\n+    } else if (arg_match(&arg, &max_bitrate_arg, argi)) {\n+      max_bitrate = arg_parse_uint(&arg);\n+    } else if (arg_match(&arg, &lag_in_frame_arg, argi)) {\n+      enc_cfg->g_lag_in_frames = arg_parse_uint(&arg);\n+    } else if (arg_match(&arg, &rc_end_usage_arg, argi)) {\n+      enc_cfg->rc_end_usage = arg_parse_uint(&arg);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    } else if (arg_match(&arg, &bitdepth_arg, argi)) {\n+      enc_cfg->g_bit_depth = arg_parse_enum_or_int(&arg);\n+      switch (enc_cfg->g_bit_depth) {\n+        case VPX_BITS_8:\n+          enc_cfg->g_input_bit_depth = 8;\n+          enc_cfg->g_profile = 0;\n+          break;\n+        case VPX_BITS_10:\n+          enc_cfg->g_input_bit_depth = 10;\n+          enc_cfg->g_profile = 2;\n+          break;\n+         case VPX_BITS_12:\n+          enc_cfg->g_input_bit_depth = 12;\n+          enc_cfg->g_profile = 2;\n+          break;\n+        default:\n+          die(\""Error: Invalid bit depth selected (%d)\\n\"", enc_cfg->g_bit_depth);\n+          break;\n+      }\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+    } else {\n+      ++argj;\n+    }\n+  }\n+\n+  // There will be a space in front of the string options\n+  if (strlen(string_options) > 0)\n+    vpx_svc_set_options(svc_ctx, string_options + 1);\n+\n+  if (passes == 0 || passes == 1) {\n+    if (pass) {\n+      fprintf(stderr, \""pass is ignored since there's only one pass\\n\"");\n+    }\n+    enc_cfg->g_pass = VPX_RC_ONE_PASS;\n+  } else {\n+    if (pass == 0) {\n+      die(\""pass must be specified when passes is 2\\n\"");\n+    }\n+\n+    if (fpf_file_name == NULL) {\n+      die(\""fpf must be specified when passes is 2\\n\"");\n+    }\n+\n+    if (pass == 1) {\n+      enc_cfg->g_pass = VPX_RC_FIRST_PASS;\n+      if (!stats_open_file(&app_input->rc_stats, fpf_file_name, 0)) {\n+        fatal(\""Failed to open statistics store\"");\n+      }\n+    } else {\n+      enc_cfg->g_pass = VPX_RC_LAST_PASS;\n+      if (!stats_open_file(&app_input->rc_stats, fpf_file_name, 1)) {\n+        fatal(\""Failed to open statistics store\"");\n+      }\n+      enc_cfg->rc_twopass_stats_in = stats_get(&app_input->rc_stats);\n+    }\n+    app_input->passes = passes;\n+    app_input->pass = pass;\n+  }\n+\n+  if (enc_cfg->rc_target_bitrate > 0) {\n+    if (min_bitrate > 0) {\n+      enc_cfg->rc_2pass_vbr_minsection_pct =\n+          min_bitrate * 100 / enc_cfg->rc_target_bitrate;\n+    }\n+    if (max_bitrate > 0) {\n+      enc_cfg->rc_2pass_vbr_maxsection_pct =\n+          max_bitrate * 100 / enc_cfg->rc_target_bitrate;\n+    }\n+  }\n+\n+  // Check for unrecognized options\n+  for (argi = argv; *argi; ++argi)\n+    if (argi[0][0] == '-' && strlen(argi[0]) > 1)\n+      die(\""Error: Unrecognized option %s\\n\"", *argi);\n+\n+  if (argv[0] == NULL || argv[1] == 0) {\n+    usage_exit();\n+  }\n+  app_input->input_filename = argv[0];\n+  app_input->output_filename = argv[1];\n+  free(argv);\n+\n+  if (enc_cfg->g_w < 16 || enc_cfg->g_w % 2 || enc_cfg->g_h < 16 ||\n+      enc_cfg->g_h % 2)\n+    die(\""Invalid resolution: %d x %d\\n\"", enc_cfg->g_w, enc_cfg->g_h);\n+\n+  printf(\n+      \""Codec %s\\nframes: %d, skip: %d\\n\""\n+      \""layers: %d\\n\""\n+      \""width %d, height: %d,\\n\""\n+      \""num: %d, den: %d, bitrate: %d,\\n\""\n+      \""gop size: %d\\n\"",\n+      vpx_codec_iface_name(vpx_codec_vp9_cx()), app_input->frames_to_code,\n+      app_input->frames_to_skip,\n+      svc_ctx->spatial_layers, enc_cfg->g_w, enc_cfg->g_h,\n+      enc_cfg->g_timebase.num, enc_cfg->g_timebase.den,\n+      enc_cfg->rc_target_bitrate, enc_cfg->kf_max_dist);\n+}\n+\n+#if OUTPUT_RC_STATS\n+// For rate control encoding stats.\n+struct RateControlStats {\n+  // Number of input frames per layer.\n+  int layer_input_frames[VPX_MAX_LAYERS];\n+  // Total (cumulative) number of encoded frames per layer.\n+  int layer_tot_enc_frames[VPX_MAX_LAYERS];\n+  // Number of encoded non-key frames per layer.\n+  int layer_enc_frames[VPX_MAX_LAYERS];\n+  // Framerate per layer (cumulative).\n+  double layer_framerate[VPX_MAX_LAYERS];\n+  // Target average frame size per layer (per-frame-bandwidth per layer).\n+  double layer_pfb[VPX_MAX_LAYERS];\n+  // Actual average frame size per layer.\n+  double layer_avg_frame_size[VPX_MAX_LAYERS];\n+  // Average rate mismatch per layer (|target - actual| / target).\n+  double layer_avg_rate_mismatch[VPX_MAX_LAYERS];\n+  // Actual encoding bitrate per layer (cumulative).\n+  double layer_encoding_bitrate[VPX_MAX_LAYERS];\n+  // Average of the short-time encoder actual bitrate.\n+  // TODO(marpan): Should we add these short-time stats for each layer?\n+  double avg_st_encoding_bitrate;\n+  // Variance of the short-time encoder actual bitrate.\n+  double variance_st_encoding_bitrate;\n+  // Window (number of frames) for computing short-time encoding bitrate.\n+  int window_size;\n+  // Number of window measurements.\n+  int window_count;\n+};\n+\n+// Note: these rate control stats assume only 1 key frame in the\n+// sequence (i.e., first frame only).\n+static void set_rate_control_stats(struct RateControlStats *rc,\n+                                     vpx_codec_enc_cfg_t *cfg) {\n+  unsigned int sl, tl;\n+  // Set the layer (cumulative) framerate and the target layer (non-cumulative)\n+  // per-frame-bandwidth, for the rate control encoding stats below.\n+  const double framerate = cfg->g_timebase.den / cfg->g_timebase.num;\n+\n+  for (sl = 0; sl < cfg->ss_number_layers; ++sl) {\n+    for (tl = 0; tl < cfg->ts_number_layers; ++tl) {\n+      const int layer = sl * cfg->ts_number_layers + tl;\n+      const int tlayer0 = sl * cfg->ts_number_layers;\n+      rc->layer_framerate[layer] =\n+          framerate / cfg->ts_rate_decimator[tl];\n+      if (tl > 0) {\n+        rc->layer_pfb[layer] = 1000.0 *\n+            (cfg->layer_target_bitrate[layer] -\n+                cfg->layer_target_bitrate[layer - 1]) /\n+            (rc->layer_framerate[layer] -\n+                rc->layer_framerate[layer - 1]);\n+      } else {\n+        rc->layer_pfb[tlayer0] = 1000.0 *\n+            cfg->layer_target_bitrate[tlayer0] /\n+            rc->layer_framerate[tlayer0];\n+      }\n+      rc->layer_input_frames[layer] = 0;\n+      rc->layer_enc_frames[layer] = 0;\n+      rc->layer_tot_enc_frames[layer] = 0;\n+      rc->layer_encoding_bitrate[layer] = 0.0;\n+      rc->layer_avg_frame_size[layer] = 0.0;\n+      rc->layer_avg_rate_mismatch[layer] = 0.0;\n+    }\n+  }\n+  rc->window_count = 0;\n+  rc->window_size = 15;\n+  rc->avg_st_encoding_bitrate = 0.0;\n+  rc->variance_st_encoding_bitrate = 0.0;\n+}\n+\n+static void printout_rate_control_summary(struct RateControlStats *rc,\n+                                          vpx_codec_enc_cfg_t *cfg,\n+                                          int frame_cnt) {\n+  unsigned int sl, tl;\n+  int tot_num_frames = 0;\n+  double perc_fluctuation = 0.0;\n+  printf(\""Total number of processed frames: %d\\n\\n\"", frame_cnt - 1);\n+  printf(\""Rate control layer stats for sl%d tl%d layer(s):\\n\\n\"",\n+      cfg->ss_number_layers, cfg->ts_number_layers);\n+  for (sl = 0; sl < cfg->ss_number_layers; ++sl) {\n+    for (tl = 0; tl < cfg->ts_number_layers; ++tl) {\n+      const int layer = sl * cfg->ts_number_layers + tl;\n+      const int num_dropped = (tl > 0) ?\n+          (rc->layer_input_frames[layer] - rc->layer_enc_frames[layer]) :\n+          (rc->layer_input_frames[layer] - rc->layer_enc_frames[layer] - 1);\n+      if (!sl)\n+        tot_num_frames += rc->layer_input_frames[layer];\n+      rc->layer_encoding_bitrate[layer] = 0.001 * rc->layer_framerate[layer] *\n+          rc->layer_encoding_bitrate[layer] / tot_num_frames;\n+      rc->layer_avg_frame_size[layer] = rc->layer_avg_frame_size[layer] /\n+          rc->layer_enc_frames[layer];\n+      rc->layer_avg_rate_mismatch[layer] =\n+          100.0 * rc->layer_avg_rate_mismatch[layer] /\n+          rc->layer_enc_frames[layer];\n+      printf(\""For layer#: sl%d tl%d \\n\"", sl, tl);\n+      printf(\""Bitrate (target vs actual): %d %f.0 kbps\\n\"",\n+             cfg->layer_target_bitrate[layer],\n+             rc->layer_encoding_bitrate[layer]);\n+      printf(\""Average frame size (target vs actual): %f %f bits\\n\"",\n+             rc->layer_pfb[layer], rc->layer_avg_frame_size[layer]);\n+      printf(\""Average rate_mismatch: %f\\n\"",\n+             rc->layer_avg_rate_mismatch[layer]);\n+      printf(\""Number of input frames, encoded (non-key) frames, \""\n+          \""and percent dropped frames: %d %d %f.0 \\n\"",\n+          rc->layer_input_frames[layer], rc->layer_enc_frames[layer],\n+          100.0 * num_dropped / rc->layer_input_frames[layer]);\n+      printf(\""\\n\"");\n+    }\n+  }\n+  rc->avg_st_encoding_bitrate = rc->avg_st_encoding_bitrate / rc->window_count;\n+  rc->variance_st_encoding_bitrate =\n+      rc->variance_st_encoding_bitrate / rc->window_count -\n+      (rc->avg_st_encoding_bitrate * rc->avg_st_encoding_bitrate);\n+  perc_fluctuation = 100.0 * sqrt(rc->variance_st_encoding_bitrate) /\n+      rc->avg_st_encoding_bitrate;\n+  printf(\""Short-time stats, for window of %d frames: \\n\"", rc->window_size);\n+  printf(\""Average, rms-variance, and percent-fluct: %f %f %f \\n\"",\n+         rc->avg_st_encoding_bitrate,\n+         sqrt(rc->variance_st_encoding_bitrate),\n+         perc_fluctuation);\n+  if (frame_cnt != tot_num_frames)\n+    die(\""Error: Number of input frames not equal to output encoded frames != \""\n+        \""%d tot_num_frames = %d\\n\"", frame_cnt, tot_num_frames);\n+}\n+\n+vpx_codec_err_t parse_superframe_index(const uint8_t *data,\n+                                       size_t data_sz,\n+                                       uint32_t sizes[8], int *count) {\n+  // A chunk ending with a byte matching 0xc0 is an invalid chunk unless\n+  // it is a super frame index. If the last byte of real video compression\n+  // data is 0xc0 the encoder must add a 0 byte. If we have the marker but\n+  // not the associated matching marker byte at the front of the index we have\n+  // an invalid bitstream and need to return an error.\n+\n+  uint8_t marker;\n+\n+  marker = *(data + data_sz - 1);\n+  *count = 0;\n+\n+\n+  if ((marker & 0xe0) == 0xc0) {\n+    const uint32_t frames = (marker & 0x7) + 1;\n+    const uint32_t mag = ((marker >> 3) & 0x3) + 1;\n+    const size_t index_sz = 2 + mag * frames;\n+\n+    // This chunk is marked as having a superframe index but doesn't have\n+    // enough data for it, thus it's an invalid superframe index.\n+    if (data_sz < index_sz)\n+      return VPX_CODEC_CORRUPT_FRAME;\n+\n+    {\n+      const uint8_t marker2 = *(data + data_sz - index_sz);\n+\n+      // This chunk is marked as having a superframe index but doesn't have\n+      // the matching marker byte at the front of the index therefore it's an\n+      // invalid chunk.\n+      if (marker != marker2)\n+        return VPX_CODEC_CORRUPT_FRAME;\n+    }\n+\n+    {\n+      // Found a valid superframe index.\n+      uint32_t i, j;\n+      const uint8_t *x = &data[data_sz - index_sz + 1];\n+\n+      for (i = 0; i < frames; ++i) {\n+        uint32_t this_sz = 0;\n+\n+        for (j = 0; j < mag; ++j)\n+          this_sz |= (*x++) << (j * 8);\n+        sizes[i] = this_sz;\n+      }\n+      *count = frames;\n+    }\n+  }\n+  return VPX_CODEC_OK;\n+}\n+#endif\n+\n+int main(int argc, const char **argv) {\n+  AppInput app_input = {0};\n+  VpxVideoWriter *writer = NULL;\n+  VpxVideoInfo info = {0};\n+  vpx_codec_ctx_t codec;\n+  vpx_codec_enc_cfg_t enc_cfg;\n+  SvcContext svc_ctx;\n+  uint32_t i;\n+  uint32_t frame_cnt = 0;\n+  vpx_image_t raw;\n+  vpx_codec_err_t res;\n+  int pts = 0;            /* PTS starts at 0 */\n+  int frame_duration = 1; /* 1 timebase tick per frame */\n+  FILE *infile = NULL;\n+  int end_of_stream = 0;\n+  int frames_received = 0;\n+#if OUTPUT_RC_STATS\n+  VpxVideoWriter *outfile[VPX_TS_MAX_LAYERS] = {NULL};\n+  struct RateControlStats rc;\n+  vpx_svc_layer_id_t layer_id;\n+  int sl, tl;\n+  double sum_bitrate = 0.0;\n+  double sum_bitrate2 = 0.0;\n+  double framerate  = 30.0;\n+#endif\n+  memset(&svc_ctx, 0, sizeof(svc_ctx));\n+  svc_ctx.log_print = 1;\n+  exec_name = argv[0];\n+  parse_command_line(argc, argv, &app_input, &svc_ctx, &enc_cfg);\n+\n+  // Allocate image buffer\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  if (!vpx_img_alloc(&raw, enc_cfg.g_input_bit_depth == 8 ?\n+                         VPX_IMG_FMT_I420 : VPX_IMG_FMT_I42016,\n+                     enc_cfg.g_w, enc_cfg.g_h, 32)) {\n+    die(\""Failed to allocate image %dx%d\\n\"", enc_cfg.g_w, enc_cfg.g_h);\n+  }\n+#else\n+  if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, enc_cfg.g_w, enc_cfg.g_h, 32)) {\n+    die(\""Failed to allocate image %dx%d\\n\"", enc_cfg.g_w, enc_cfg.g_h);\n+  }\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+\n+  if (!(infile = fopen(app_input.input_filename, \""rb\"")))\n+    die(\""Failed to open %s for reading\\n\"", app_input.input_filename);\n+\n+  // Initialize codec\n+  if (vpx_svc_init(&svc_ctx, &codec, vpx_codec_vp9_cx(), &enc_cfg) !=\n+      VPX_CODEC_OK)\n+    die(\""Failed to initialize encoder\\n\"");\n+\n+#if OUTPUT_RC_STATS\n+  if (svc_ctx.output_rc_stat) {\n+    set_rate_control_stats(&rc, &enc_cfg);\n+    framerate = enc_cfg.g_timebase.den / enc_cfg.g_timebase.num;\n+  }\n+#endif\n+\n+  info.codec_fourcc = VP9_FOURCC;\n+  info.time_base.numerator = enc_cfg.g_timebase.num;\n+  info.time_base.denominator = enc_cfg.g_timebase.den;\n+\n+  if (!(app_input.passes == 2 && app_input.pass == 1)) {\n+    // We don't save the bitstream for the 1st pass on two pass rate control\n+    writer = vpx_video_writer_open(app_input.output_filename, kContainerIVF,\n+                                   &info);\n+    if (!writer)\n+      die(\""Failed to open %s for writing\\n\"", app_input.output_filename);\n+  }\n+#if OUTPUT_RC_STATS\n+  // For now, just write temporal layer streams.\n+  // TODO(wonkap): do spatial by re-writing superframe.\n+  if (svc_ctx.output_rc_stat) {\n+    for (tl = 0; tl < enc_cfg.ts_number_layers; ++tl) {\n+      char file_name[PATH_MAX];\n+\n+      snprintf(file_name, sizeof(file_name), \""%s_t%d.ivf\"",\n+               app_input.output_filename, tl);\n+      outfile[tl] = vpx_video_writer_open(file_name, kContainerIVF, &info);\n+      if (!outfile[tl])\n+        die(\""Failed to open %s for writing\"", file_name);\n+    }\n+  }\n+#endif\n+\n+  // skip initial frames\n+  for (i = 0; i < app_input.frames_to_skip; ++i)\n+    vpx_img_read(&raw, infile);\n+\n+  if (svc_ctx.speed != -1)\n+    vpx_codec_control(&codec, VP8E_SET_CPUUSED, svc_ctx.speed);\n+  if (svc_ctx.threads)\n+    vpx_codec_control(&codec, VP9E_SET_TILE_COLUMNS, (svc_ctx.threads >> 1));\n+\n+  // Encode frames\n+  while (!end_of_stream) {\n+    vpx_codec_iter_t iter = NULL;\n+    const vpx_codec_cx_pkt_t *cx_pkt;\n+    if (frame_cnt >= app_input.frames_to_code || !vpx_img_read(&raw, infile)) {\n+      // We need one extra vpx_svc_encode call at end of stream to flush\n+      // encoder and get remaining data\n+      end_of_stream = 1;\n+    }\n+\n+    res = vpx_svc_encode(&svc_ctx, &codec, (end_of_stream ? NULL : &raw),\n+                         pts, frame_duration, svc_ctx.speed >= 5 ?\n+                         VPX_DL_REALTIME : VPX_DL_GOOD_QUALITY);\n+\n+    printf(\""%s\"", vpx_svc_get_message(&svc_ctx));\n+    if (res != VPX_CODEC_OK) {\n+      die_codec(&codec, \""Failed to encode frame\"");\n+    }\n+\n+    while ((cx_pkt = vpx_codec_get_cx_data(&codec, &iter)) != NULL) {\n+      switch (cx_pkt->kind) {\n+        case VPX_CODEC_CX_FRAME_PKT: {\n+          if (cx_pkt->data.frame.sz > 0) {\n+#if OUTPUT_RC_STATS\n+            uint32_t sizes[8];\n+            int count = 0;\n+#endif\n+            vpx_video_writer_write_frame(writer,\n+                                         cx_pkt->data.frame.buf,\n+                                         cx_pkt->data.frame.sz,\n+                                         cx_pkt->data.frame.pts);\n+#if OUTPUT_RC_STATS\n+            // TODO(marpan/wonkap): Put this (to line728) in separate function.\n+            if (svc_ctx.output_rc_stat) {\n+              vpx_codec_control(&codec, VP9E_GET_SVC_LAYER_ID, &layer_id);\n+              parse_superframe_index(cx_pkt->data.frame.buf,\n+                                     cx_pkt->data.frame.sz, sizes, &count);\n+              for (sl = 0; sl < enc_cfg.ss_number_layers; ++sl) {\n+                ++rc.layer_input_frames[sl * enc_cfg.ts_number_layers +\n+                                        layer_id.temporal_layer_id];\n+              }\n+              for (tl = layer_id.temporal_layer_id;\n+                  tl < enc_cfg.ts_number_layers; ++tl) {\n+                vpx_video_writer_write_frame(outfile[tl],\n+                                             cx_pkt->data.frame.buf,\n+                                             cx_pkt->data.frame.sz,\n+                                             cx_pkt->data.frame.pts);\n+              }\n+\n+              for (sl = 0; sl < enc_cfg.ss_number_layers; ++sl) {\n+                for (tl = layer_id.temporal_layer_id;\n+                    tl < enc_cfg.ts_number_layers; ++tl) {\n+                  const int layer = sl * enc_cfg.ts_number_layers + tl;\n+                  ++rc.layer_tot_enc_frames[layer];\n+                  rc.layer_encoding_bitrate[layer] += 8.0 * sizes[sl];\n+                  // Keep count of rate control stats per layer, for non-key\n+                  // frames.\n+                  if (tl == layer_id.temporal_layer_id &&\n+                      !(cx_pkt->data.frame.flags & VPX_FRAME_IS_KEY)) {\n+                    rc.layer_avg_frame_size[layer] += 8.0 * sizes[sl];\n+                    rc.layer_avg_rate_mismatch[layer] +=\n+                        fabs(8.0 * sizes[sl] - rc.layer_pfb[layer]) /\n+                        rc.layer_pfb[layer];\n+                    ++rc.layer_enc_frames[layer];\n+                  }\n+                }\n+              }\n+\n+              // Update for short-time encoding bitrate states, for moving\n+              // window of size rc->window, shifted by rc->window / 2.\n+              // Ignore first window segment, due to key frame.\n+              if (frame_cnt > rc.window_size) {\n+                tl = layer_id.temporal_layer_id;\n+                for (sl = 0; sl < enc_cfg.ss_number_layers; ++sl) {\n+                  sum_bitrate += 0.001 * 8.0 * sizes[sl] * framerate;\n+                }\n+                if (frame_cnt % rc.window_size == 0) {\n+                  rc.window_count += 1;\n+                  rc.avg_st_encoding_bitrate += sum_bitrate / rc.window_size;\n+                  rc.variance_st_encoding_bitrate +=\n+                      (sum_bitrate / rc.window_size) *\n+                      (sum_bitrate / rc.window_size);\n+                  sum_bitrate = 0.0;\n+                }\n+              }\n+\n+              // Second shifted window.\n+              if (frame_cnt > rc.window_size + rc.window_size / 2) {\n+               tl = layer_id.temporal_layer_id;\n+               for (sl = 0; sl < enc_cfg.ss_number_layers; ++sl) {\n+                 sum_bitrate2 += 0.001 * 8.0 * sizes[sl] * framerate;\n+               }\n+\n+               if (frame_cnt > 2 * rc.window_size &&\n+                  frame_cnt % rc.window_size == 0) {\n+                 rc.window_count += 1;\n+                 rc.avg_st_encoding_bitrate += sum_bitrate2 / rc.window_size;\n+                 rc.variance_st_encoding_bitrate +=\n+                    (sum_bitrate2 / rc.window_size) *\n+                    (sum_bitrate2 / rc.window_size);\n+                 sum_bitrate2 = 0.0;\n+               }\n+              }\n+            }\n+#endif\n+          }\n+\n+          printf(\""SVC frame: %d, kf: %d, size: %d, pts: %d\\n\"", frames_received,\n+                 !!(cx_pkt->data.frame.flags & VPX_FRAME_IS_KEY),\n+                 (int)cx_pkt->data.frame.sz, (int)cx_pkt->data.frame.pts);\n+          ++frames_received;\n+          break;\n+        }\n+        case VPX_CODEC_STATS_PKT: {\n+          stats_write(&app_input.rc_stats,\n+                      cx_pkt->data.twopass_stats.buf,\n+                      cx_pkt->data.twopass_stats.sz);\n+          break;\n+        }\n+        default: {\n+          break;\n+        }\n+      }\n+    }\n+\n+    if (!end_of_stream) {\n+      ++frame_cnt;\n+      pts += frame_duration;\n+    }\n+  }\n+  printf(\""Processed %d frames\\n\"", frame_cnt);\n+  fclose(infile);\n+#if OUTPUT_RC_STATS\n+  if (svc_ctx.output_rc_stat) {\n+    printout_rate_control_summary(&rc, &enc_cfg, frame_cnt);\n+    printf(\""\\n\"");\n+  }\n+#endif\n+  if (vpx_codec_destroy(&codec)) die_codec(&codec, \""Failed to destroy codec\"");\n+  if (app_input.passes == 2)\n+    stats_close(&app_input.rc_stats, 1);\n+  if (writer) {\n+    vpx_video_writer_close(writer);\n+  }\n+#if OUTPUT_RC_STATS\n+  if (svc_ctx.output_rc_stat) {\n+    for (tl = 0; tl < enc_cfg.ts_number_layers; ++tl) {\n+      vpx_video_writer_close(outfile[tl]);\n+    }\n+  }\n+#endif\n+  vpx_img_free(&raw);\n+  // display average size, psnr\n+  printf(\""%s\"", vpx_svc_dump_statistics(&svc_ctx));\n+  vpx_svc_release(&svc_ctx);\n+  return EXIT_SUCCESS;\n+}\n""}<_**next**_>{""filename"": ""libvpx/examples/vpx_temporal_svc_encoder.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/examples/vpx_temporal_svc_encoder.c"", ""patch"": ""@@ -0,0 +1,827 @@\n\n+/*\n+ *  Copyright (c) 2012 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+//  This is an example demonstrating how to implement a multi-layer VPx\n+//  encoding scheme based on temporal scalability for video applications\n+//  that benefit from a scalable bitstream.\n+\n+#include <assert.h>\n+#include <math.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \""./vpx_config.h\""\n+#include \""../vpx_ports/vpx_timer.h\""\n+#include \""vpx/vp8cx.h\""\n+#include \""vpx/vpx_encoder.h\""\n+\n+#include \""../tools_common.h\""\n+#include \""../video_writer.h\""\n+\n+static const char *exec_name;\n+\n+void usage_exit(void) {\n+  exit(EXIT_FAILURE);\n+}\n+\n+// Denoiser states, for temporal denoising.\n+enum denoiserState {\n+  kDenoiserOff,\n+  kDenoiserOnYOnly,\n+  kDenoiserOnYUV,\n+  kDenoiserOnYUVAggressive,\n+  kDenoiserOnAdaptive\n+};\n+\n+static int mode_to_num_layers[12] = {1, 2, 2, 3, 3, 3, 3, 5, 2, 3, 3, 3};\n+\n+// For rate control encoding stats.\n+struct RateControlMetrics {\n+  // Number of input frames per layer.\n+  int layer_input_frames[VPX_TS_MAX_LAYERS];\n+  // Total (cumulative) number of encoded frames per layer.\n+  int layer_tot_enc_frames[VPX_TS_MAX_LAYERS];\n+  // Number of encoded non-key frames per layer.\n+  int layer_enc_frames[VPX_TS_MAX_LAYERS];\n+  // Framerate per layer layer (cumulative).\n+  double layer_framerate[VPX_TS_MAX_LAYERS];\n+  // Target average frame size per layer (per-frame-bandwidth per layer).\n+  double layer_pfb[VPX_TS_MAX_LAYERS];\n+  // Actual average frame size per layer.\n+  double layer_avg_frame_size[VPX_TS_MAX_LAYERS];\n+  // Average rate mismatch per layer (|target - actual| / target).\n+  double layer_avg_rate_mismatch[VPX_TS_MAX_LAYERS];\n+  // Actual encoding bitrate per layer (cumulative).\n+  double layer_encoding_bitrate[VPX_TS_MAX_LAYERS];\n+  // Average of the short-time encoder actual bitrate.\n+  // TODO(marpan): Should we add these short-time stats for each layer?\n+  double avg_st_encoding_bitrate;\n+  // Variance of the short-time encoder actual bitrate.\n+  double variance_st_encoding_bitrate;\n+  // Window (number of frames) for computing short-timee encoding bitrate.\n+  int window_size;\n+  // Number of window measurements.\n+  int window_count;\n+  int layer_target_bitrate[VPX_MAX_LAYERS];\n+};\n+\n+// Note: these rate control metrics assume only 1 key frame in the\n+// sequence (i.e., first frame only). So for temporal pattern# 7\n+// (which has key frame for every frame on base layer), the metrics\n+// computation will be off/wrong.\n+// TODO(marpan): Update these metrics to account for multiple key frames\n+// in the stream.\n+static void set_rate_control_metrics(struct RateControlMetrics *rc,\n+                                     vpx_codec_enc_cfg_t *cfg) {\n+  unsigned int i = 0;\n+  // Set the layer (cumulative) framerate and the target layer (non-cumulative)\n+  // per-frame-bandwidth, for the rate control encoding stats below.\n+  const double framerate = cfg->g_timebase.den / cfg->g_timebase.num;\n+  rc->layer_framerate[0] = framerate / cfg->ts_rate_decimator[0];\n+  rc->layer_pfb[0] = 1000.0 * rc->layer_target_bitrate[0] /\n+      rc->layer_framerate[0];\n+  for (i = 0; i < cfg->ts_number_layers; ++i) {\n+    if (i > 0) {\n+      rc->layer_framerate[i] = framerate / cfg->ts_rate_decimator[i];\n+      rc->layer_pfb[i] = 1000.0 *\n+          (rc->layer_target_bitrate[i] - rc->layer_target_bitrate[i - 1]) /\n+          (rc->layer_framerate[i] - rc->layer_framerate[i - 1]);\n+    }\n+    rc->layer_input_frames[i] = 0;\n+    rc->layer_enc_frames[i] = 0;\n+    rc->layer_tot_enc_frames[i] = 0;\n+    rc->layer_encoding_bitrate[i] = 0.0;\n+    rc->layer_avg_frame_size[i] = 0.0;\n+    rc->layer_avg_rate_mismatch[i] = 0.0;\n+  }\n+  rc->window_count = 0;\n+  rc->window_size = 15;\n+  rc->avg_st_encoding_bitrate = 0.0;\n+  rc->variance_st_encoding_bitrate = 0.0;\n+}\n+\n+static void printout_rate_control_summary(struct RateControlMetrics *rc,\n+                                          vpx_codec_enc_cfg_t *cfg,\n+                                          int frame_cnt) {\n+  unsigned int i = 0;\n+  int tot_num_frames = 0;\n+  double perc_fluctuation = 0.0;\n+  printf(\""Total number of processed frames: %d\\n\\n\"", frame_cnt -1);\n+  printf(\""Rate control layer stats for %d layer(s):\\n\\n\"",\n+      cfg->ts_number_layers);\n+  for (i = 0; i < cfg->ts_number_layers; ++i) {\n+    const int num_dropped = (i > 0) ?\n+        (rc->layer_input_frames[i] - rc->layer_enc_frames[i]) :\n+        (rc->layer_input_frames[i] - rc->layer_enc_frames[i] - 1);\n+    tot_num_frames += rc->layer_input_frames[i];\n+    rc->layer_encoding_bitrate[i] = 0.001 * rc->layer_framerate[i] *\n+        rc->layer_encoding_bitrate[i] / tot_num_frames;\n+    rc->layer_avg_frame_size[i] = rc->layer_avg_frame_size[i] /\n+        rc->layer_enc_frames[i];\n+    rc->layer_avg_rate_mismatch[i] = 100.0 * rc->layer_avg_rate_mismatch[i] /\n+        rc->layer_enc_frames[i];\n+    printf(\""For layer#: %d \\n\"", i);\n+    printf(\""Bitrate (target vs actual): %d %f \\n\"", rc->layer_target_bitrate[i],\n+           rc->layer_encoding_bitrate[i]);\n+    printf(\""Average frame size (target vs actual): %f %f \\n\"", rc->layer_pfb[i],\n+           rc->layer_avg_frame_size[i]);\n+    printf(\""Average rate_mismatch: %f \\n\"", rc->layer_avg_rate_mismatch[i]);\n+    printf(\""Number of input frames, encoded (non-key) frames, \""\n+        \""and perc dropped frames: %d %d %f \\n\"", rc->layer_input_frames[i],\n+        rc->layer_enc_frames[i],\n+        100.0 * num_dropped / rc->layer_input_frames[i]);\n+    printf(\""\\n\"");\n+  }\n+  rc->avg_st_encoding_bitrate = rc->avg_st_encoding_bitrate / rc->window_count;\n+  rc->variance_st_encoding_bitrate =\n+      rc->variance_st_encoding_bitrate / rc->window_count -\n+      (rc->avg_st_encoding_bitrate * rc->avg_st_encoding_bitrate);\n+  perc_fluctuation = 100.0 * sqrt(rc->variance_st_encoding_bitrate) /\n+      rc->avg_st_encoding_bitrate;\n+  printf(\""Short-time stats, for window of %d frames: \\n\"",rc->window_size);\n+  printf(\""Average, rms-variance, and percent-fluct: %f %f %f \\n\"",\n+         rc->avg_st_encoding_bitrate,\n+         sqrt(rc->variance_st_encoding_bitrate),\n+         perc_fluctuation);\n+  if ((frame_cnt - 1) != tot_num_frames)\n+    die(\""Error: Number of input frames not equal to output! \\n\"");\n+}\n+\n+// Temporal scaling parameters:\n+// NOTE: The 3 prediction frames cannot be used interchangeably due to\n+// differences in the way they are handled throughout the code. The\n+// frames should be allocated to layers in the order LAST, GF, ARF.\n+// Other combinations work, but may produce slightly inferior results.\n+static void set_temporal_layer_pattern(int layering_mode,\n+                                       vpx_codec_enc_cfg_t *cfg,\n+                                       int *layer_flags,\n+                                       int *flag_periodicity) {\n+  switch (layering_mode) {\n+    case 0: {\n+      // 1-layer.\n+      int ids[1] = {0};\n+      cfg->ts_periodicity = 1;\n+      *flag_periodicity = 1;\n+      cfg->ts_number_layers = 1;\n+      cfg->ts_rate_decimator[0] = 1;\n+      memcpy(cfg->ts_layer_id, ids, sizeof(ids));\n+      // Update L only.\n+      layer_flags[0] = VPX_EFLAG_FORCE_KF  | VP8_EFLAG_NO_UPD_GF |\n+          VP8_EFLAG_NO_UPD_ARF;\n+      break;\n+    }\n+    case 1: {\n+      // 2-layers, 2-frame period.\n+      int ids[2] = {0, 1};\n+      cfg->ts_periodicity = 2;\n+      *flag_periodicity = 2;\n+      cfg->ts_number_layers = 2;\n+      cfg->ts_rate_decimator[0] = 2;\n+      cfg->ts_rate_decimator[1] = 1;\n+      memcpy(cfg->ts_layer_id, ids, sizeof(ids));\n+#if 1\n+      // 0=L, 1=GF, Intra-layer prediction enabled.\n+      layer_flags[0] = VPX_EFLAG_FORCE_KF  | VP8_EFLAG_NO_UPD_GF |\n+          VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF;\n+      layer_flags[1] = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST |\n+          VP8_EFLAG_NO_REF_ARF;\n+#else\n+       // 0=L, 1=GF, Intra-layer prediction disabled.\n+      layer_flags[0] = VPX_EFLAG_FORCE_KF  | VP8_EFLAG_NO_UPD_GF |\n+          VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF;\n+      layer_flags[1] = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST |\n+          VP8_EFLAG_NO_REF_ARF | VP8_EFLAG_NO_REF_LAST;\n+#endif\n+      break;\n+    }\n+    case 2: {\n+      // 2-layers, 3-frame period.\n+      int ids[3] = {0, 1, 1};\n+      cfg->ts_periodicity = 3;\n+      *flag_periodicity = 3;\n+      cfg->ts_number_layers = 2;\n+      cfg->ts_rate_decimator[0] = 3;\n+      cfg->ts_rate_decimator[1] = 1;\n+      memcpy(cfg->ts_layer_id, ids, sizeof(ids));\n+      // 0=L, 1=GF, Intra-layer prediction enabled.\n+      layer_flags[0] = VPX_EFLAG_FORCE_KF  | VP8_EFLAG_NO_REF_GF |\n+          VP8_EFLAG_NO_REF_ARF | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF;\n+      layer_flags[1] =\n+      layer_flags[2] = VP8_EFLAG_NO_REF_GF  | VP8_EFLAG_NO_REF_ARF |\n+          VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST;\n+      break;\n+    }\n+    case 3: {\n+      // 3-layers, 6-frame period.\n+      int ids[6] = {0, 2, 2, 1, 2, 2};\n+      cfg->ts_periodicity = 6;\n+      *flag_periodicity = 6;\n+      cfg->ts_number_layers = 3;\n+      cfg->ts_rate_decimator[0] = 6;\n+      cfg->ts_rate_decimator[1] = 3;\n+      cfg->ts_rate_decimator[2] = 1;\n+      memcpy(cfg->ts_layer_id, ids, sizeof(ids));\n+      // 0=L, 1=GF, 2=ARF, Intra-layer prediction enabled.\n+      layer_flags[0] = VPX_EFLAG_FORCE_KF  | VP8_EFLAG_NO_REF_GF |\n+          VP8_EFLAG_NO_REF_ARF | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF;\n+      layer_flags[3] = VP8_EFLAG_NO_REF_ARF | VP8_EFLAG_NO_UPD_ARF |\n+          VP8_EFLAG_NO_UPD_LAST;\n+      layer_flags[1] =\n+      layer_flags[2] =\n+      layer_flags[4] =\n+      layer_flags[5] = VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_LAST;\n+      break;\n+    }\n+    case 4: {\n+      // 3-layers, 4-frame period.\n+      int ids[4] = {0, 2, 1, 2};\n+      cfg->ts_periodicity = 4;\n+      *flag_periodicity = 4;\n+      cfg->ts_number_layers = 3;\n+      cfg->ts_rate_decimator[0] = 4;\n+      cfg->ts_rate_decimator[1] = 2;\n+      cfg->ts_rate_decimator[2] = 1;\n+      memcpy(cfg->ts_layer_id, ids, sizeof(ids));\n+      // 0=L, 1=GF, 2=ARF, Intra-layer prediction disabled.\n+      layer_flags[0] = VPX_EFLAG_FORCE_KF  | VP8_EFLAG_NO_REF_GF |\n+          VP8_EFLAG_NO_REF_ARF | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF;\n+      layer_flags[2] = VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF |\n+          VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST;\n+      layer_flags[1] =\n+      layer_flags[3] = VP8_EFLAG_NO_REF_ARF | VP8_EFLAG_NO_UPD_LAST |\n+          VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF;\n+      break;\n+    }\n+    case 5: {\n+      // 3-layers, 4-frame period.\n+      int ids[4] = {0, 2, 1, 2};\n+      cfg->ts_periodicity = 4;\n+      *flag_periodicity = 4;\n+      cfg->ts_number_layers     = 3;\n+      cfg->ts_rate_decimator[0] = 4;\n+      cfg->ts_rate_decimator[1] = 2;\n+      cfg->ts_rate_decimator[2] = 1;\n+      memcpy(cfg->ts_layer_id, ids, sizeof(ids));\n+      // 0=L, 1=GF, 2=ARF, Intra-layer prediction enabled in layer 1, disabled\n+      // in layer 2.\n+      layer_flags[0] = VPX_EFLAG_FORCE_KF  | VP8_EFLAG_NO_REF_GF |\n+          VP8_EFLAG_NO_REF_ARF | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF;\n+      layer_flags[2] = VP8_EFLAG_NO_REF_ARF | VP8_EFLAG_NO_UPD_LAST |\n+          VP8_EFLAG_NO_UPD_ARF;\n+      layer_flags[1] =\n+      layer_flags[3] = VP8_EFLAG_NO_REF_ARF | VP8_EFLAG_NO_UPD_LAST |\n+          VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF;\n+      break;\n+    }\n+    case 6: {\n+      // 3-layers, 4-frame period.\n+      int ids[4] = {0, 2, 1, 2};\n+      cfg->ts_periodicity = 4;\n+      *flag_periodicity = 4;\n+      cfg->ts_number_layers = 3;\n+      cfg->ts_rate_decimator[0] = 4;\n+      cfg->ts_rate_decimator[1] = 2;\n+      cfg->ts_rate_decimator[2] = 1;\n+      memcpy(cfg->ts_layer_id, ids, sizeof(ids));\n+      // 0=L, 1=GF, 2=ARF, Intra-layer prediction enabled.\n+      layer_flags[0] = VPX_EFLAG_FORCE_KF  | VP8_EFLAG_NO_REF_GF |\n+          VP8_EFLAG_NO_REF_ARF | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF;\n+      layer_flags[2] = VP8_EFLAG_NO_REF_ARF | VP8_EFLAG_NO_UPD_LAST |\n+          VP8_EFLAG_NO_UPD_ARF;\n+      layer_flags[1] =\n+      layer_flags[3] = VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF;\n+      break;\n+    }\n+    case 7: {\n+      // NOTE: Probably of academic interest only.\n+      // 5-layers, 16-frame period.\n+      int ids[16] = {0, 4, 3, 4, 2, 4, 3, 4, 1, 4, 3, 4, 2, 4, 3, 4};\n+      cfg->ts_periodicity = 16;\n+      *flag_periodicity = 16;\n+      cfg->ts_number_layers = 5;\n+      cfg->ts_rate_decimator[0] = 16;\n+      cfg->ts_rate_decimator[1] = 8;\n+      cfg->ts_rate_decimator[2] = 4;\n+      cfg->ts_rate_decimator[3] = 2;\n+      cfg->ts_rate_decimator[4] = 1;\n+      memcpy(cfg->ts_layer_id, ids, sizeof(ids));\n+      layer_flags[0]  = VPX_EFLAG_FORCE_KF;\n+      layer_flags[1]  =\n+      layer_flags[3]  =\n+      layer_flags[5]  =\n+      layer_flags[7]  =\n+      layer_flags[9]  =\n+      layer_flags[11] =\n+      layer_flags[13] =\n+      layer_flags[15] = VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF |\n+          VP8_EFLAG_NO_UPD_ARF;\n+      layer_flags[2]  =\n+      layer_flags[6]  =\n+      layer_flags[10] =\n+      layer_flags[14] = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_GF;\n+      layer_flags[4] =\n+      layer_flags[12] = VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_UPD_ARF;\n+      layer_flags[8]  = VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF;\n+      break;\n+    }\n+    case 8: {\n+      // 2-layers, with sync point at first frame of layer 1.\n+      int ids[2] = {0, 1};\n+      cfg->ts_periodicity = 2;\n+      *flag_periodicity = 8;\n+      cfg->ts_number_layers = 2;\n+      cfg->ts_rate_decimator[0] = 2;\n+      cfg->ts_rate_decimator[1] = 1;\n+      memcpy(cfg->ts_layer_id, ids, sizeof(ids));\n+      // 0=L, 1=GF.\n+      // ARF is used as predictor for all frames, and is only updated on\n+      // key frame. Sync point every 8 frames.\n+\n+      // Layer 0: predict from L and ARF, update L and G.\n+      layer_flags[0] = VPX_EFLAG_FORCE_KF  | VP8_EFLAG_NO_REF_GF |\n+          VP8_EFLAG_NO_UPD_ARF;\n+      // Layer 1: sync point: predict from L and ARF, and update G.\n+      layer_flags[1] = VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_UPD_LAST |\n+          VP8_EFLAG_NO_UPD_ARF;\n+      // Layer 0, predict from L and ARF, update L.\n+      layer_flags[2] = VP8_EFLAG_NO_REF_GF  | VP8_EFLAG_NO_UPD_GF |\n+          VP8_EFLAG_NO_UPD_ARF;\n+      // Layer 1: predict from L, G and ARF, and update G.\n+      layer_flags[3] = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST |\n+          VP8_EFLAG_NO_UPD_ENTROPY;\n+      // Layer 0.\n+      layer_flags[4] = layer_flags[2];\n+      // Layer 1.\n+      layer_flags[5] = layer_flags[3];\n+      // Layer 0.\n+      layer_flags[6] = layer_flags[4];\n+      // Layer 1.\n+      layer_flags[7] = layer_flags[5];\n+     break;\n+    }\n+    case 9: {\n+      // 3-layers: Sync points for layer 1 and 2 every 8 frames.\n+      int ids[4] = {0, 2, 1, 2};\n+      cfg->ts_periodicity = 4;\n+      *flag_periodicity = 8;\n+      cfg->ts_number_layers = 3;\n+      cfg->ts_rate_decimator[0] = 4;\n+      cfg->ts_rate_decimator[1] = 2;\n+      cfg->ts_rate_decimator[2] = 1;\n+      memcpy(cfg->ts_layer_id, ids, sizeof(ids));\n+      // 0=L, 1=GF, 2=ARF.\n+      layer_flags[0] = VPX_EFLAG_FORCE_KF  | VP8_EFLAG_NO_REF_GF |\n+          VP8_EFLAG_NO_REF_ARF | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF;\n+      layer_flags[1] = VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF |\n+          VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF;\n+      layer_flags[2] = VP8_EFLAG_NO_REF_GF   | VP8_EFLAG_NO_REF_ARF |\n+          VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_ARF;\n+      layer_flags[3] =\n+      layer_flags[5] = VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF;\n+      layer_flags[4] = VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF |\n+          VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF;\n+      layer_flags[6] = VP8_EFLAG_NO_REF_ARF | VP8_EFLAG_NO_UPD_LAST |\n+          VP8_EFLAG_NO_UPD_ARF;\n+      layer_flags[7] = VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF |\n+          VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_ENTROPY;\n+      break;\n+    }\n+    case 10: {\n+      // 3-layers structure where ARF is used as predictor for all frames,\n+      // and is only updated on key frame.\n+      // Sync points for layer 1 and 2 every 8 frames.\n+\n+      int ids[4] = {0, 2, 1, 2};\n+      cfg->ts_periodicity = 4;\n+      *flag_periodicity = 8;\n+      cfg->ts_number_layers = 3;\n+      cfg->ts_rate_decimator[0] = 4;\n+      cfg->ts_rate_decimator[1] = 2;\n+      cfg->ts_rate_decimator[2] = 1;\n+      memcpy(cfg->ts_layer_id, ids, sizeof(ids));\n+      // 0=L, 1=GF, 2=ARF.\n+      // Layer 0: predict from L and ARF; update L and G.\n+      layer_flags[0] = VPX_EFLAG_FORCE_KF | VP8_EFLAG_NO_UPD_ARF |\n+          VP8_EFLAG_NO_REF_GF;\n+      // Layer 2: sync point: predict from L and ARF; update none.\n+      layer_flags[1] = VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_UPD_GF |\n+          VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST |\n+          VP8_EFLAG_NO_UPD_ENTROPY;\n+      // Layer 1: sync point: predict from L and ARF; update G.\n+      layer_flags[2] = VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_UPD_ARF |\n+          VP8_EFLAG_NO_UPD_LAST;\n+      // Layer 2: predict from L, G, ARF; update none.\n+      layer_flags[3] = VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF |\n+          VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_ENTROPY;\n+      // Layer 0: predict from L and ARF; update L.\n+      layer_flags[4] = VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF |\n+          VP8_EFLAG_NO_REF_GF;\n+      // Layer 2: predict from L, G, ARF; update none.\n+      layer_flags[5] = layer_flags[3];\n+      // Layer 1: predict from L, G, ARF; update G.\n+      layer_flags[6] = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST;\n+      // Layer 2: predict from L, G, ARF; update none.\n+      layer_flags[7] = layer_flags[3];\n+      break;\n+    }\n+    case 11:\n+    default: {\n+      // 3-layers structure as in case 10, but no sync/refresh points for\n+      // layer 1 and 2.\n+      int ids[4] = {0, 2, 1, 2};\n+      cfg->ts_periodicity = 4;\n+      *flag_periodicity = 8;\n+      cfg->ts_number_layers = 3;\n+      cfg->ts_rate_decimator[0] = 4;\n+      cfg->ts_rate_decimator[1] = 2;\n+      cfg->ts_rate_decimator[2] = 1;\n+      memcpy(cfg->ts_layer_id, ids, sizeof(ids));\n+      // 0=L, 1=GF, 2=ARF.\n+      // Layer 0: predict from L and ARF; update L.\n+      layer_flags[0] = VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF |\n+          VP8_EFLAG_NO_REF_GF;\n+      layer_flags[4] = layer_flags[0];\n+      // Layer 1: predict from L, G, ARF; update G.\n+      layer_flags[2] = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST;\n+      layer_flags[6] = layer_flags[2];\n+      // Layer 2: predict from L, G, ARF; update none.\n+      layer_flags[1] = VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF |\n+          VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_ENTROPY;\n+      layer_flags[3] = layer_flags[1];\n+      layer_flags[5] = layer_flags[1];\n+      layer_flags[7] = layer_flags[1];\n+      break;\n+    }\n+  }\n+}\n+\n+int main(int argc, char **argv) {\n+  VpxVideoWriter *outfile[VPX_TS_MAX_LAYERS] = {NULL};\n+  vpx_codec_ctx_t codec;\n+  vpx_codec_enc_cfg_t cfg;\n+  int frame_cnt = 0;\n+  vpx_image_t raw;\n+  vpx_codec_err_t res;\n+  unsigned int width;\n+  unsigned int height;\n+  int speed;\n+  int frame_avail;\n+  int got_data;\n+  int flags = 0;\n+  unsigned int i;\n+  int pts = 0;  // PTS starts at 0.\n+  int frame_duration = 1;  // 1 timebase tick per frame.\n+  int layering_mode = 0;\n+  int layer_flags[VPX_TS_MAX_PERIODICITY] = {0};\n+  int flag_periodicity = 1;\n+#if VPX_ENCODER_ABI_VERSION > (4 + VPX_CODEC_ABI_VERSION)\n+  vpx_svc_layer_id_t layer_id = {0, 0};\n+#else\n+  vpx_svc_layer_id_t layer_id = {0};\n+#endif\n+  const VpxInterface *encoder = NULL;\n+  FILE *infile = NULL;\n+  struct RateControlMetrics rc;\n+  int64_t cx_time = 0;\n+  const int min_args_base = 11;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  vpx_bit_depth_t bit_depth = VPX_BITS_8;\n+  int input_bit_depth = 8;\n+  const int min_args = min_args_base + 1;\n+#else\n+  const int min_args = min_args_base;\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+  double sum_bitrate = 0.0;\n+  double sum_bitrate2 = 0.0;\n+  double framerate  = 30.0;\n+\n+  exec_name = argv[0];\n+  // Check usage and arguments.\n+  if (argc < min_args) {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    die(\""Usage: %s <infile> <outfile> <codec_type(vp8/vp9)> <width> <height> \""\n+        \""<rate_num> <rate_den> <speed> <frame_drop_threshold> <mode> \""\n+        \""<Rate_0> ... <Rate_nlayers-1> <bit-depth> \\n\"", argv[0]);\n+#else\n+    die(\""Usage: %s <infile> <outfile> <codec_type(vp8/vp9)> <width> <height> \""\n+        \""<rate_num> <rate_den> <speed> <frame_drop_threshold> <mode> \""\n+        \""<Rate_0> ... <Rate_nlayers-1> \\n\"", argv[0]);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+  }\n+\n+  encoder = get_vpx_encoder_by_name(argv[3]);\n+  if (!encoder)\n+    die(\""Unsupported codec.\"");\n+\n+  printf(\""Using %s\\n\"", vpx_codec_iface_name(encoder->codec_interface()));\n+\n+  width = strtol(argv[4], NULL, 0);\n+  height = strtol(argv[5], NULL, 0);\n+  if (width < 16 || width % 2 || height < 16 || height % 2) {\n+    die(\""Invalid resolution: %d x %d\"", width, height);\n+  }\n+\n+  layering_mode = strtol(argv[10], NULL, 0);\n+  if (layering_mode < 0 || layering_mode > 12) {\n+    die(\""Invalid layering mode (0..12) %s\"", argv[10]);\n+  }\n+\n+  if (argc != min_args + mode_to_num_layers[layering_mode]) {\n+    die(\""Invalid number of arguments\"");\n+  }\n+\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  switch (strtol(argv[argc-1], NULL, 0)) {\n+    case 8:\n+      bit_depth = VPX_BITS_8;\n+      input_bit_depth = 8;\n+      break;\n+    case 10:\n+      bit_depth = VPX_BITS_10;\n+      input_bit_depth = 10;\n+      break;\n+    case 12:\n+      bit_depth = VPX_BITS_12;\n+      input_bit_depth = 12;\n+      break;\n+    default:\n+      die(\""Invalid bit depth (8, 10, 12) %s\"", argv[argc-1]);\n+  }\n+  if (!vpx_img_alloc(&raw,\n+                     bit_depth == VPX_BITS_8 ? VPX_IMG_FMT_I420 :\n+                                               VPX_IMG_FMT_I42016,\n+                     width, height, 32)) {\n+    die(\""Failed to allocate image\"", width, height);\n+  }\n+#else\n+  if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, width, height, 32)) {\n+    die(\""Failed to allocate image\"", width, height);\n+  }\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+\n+  // Populate encoder configuration.\n+  res = vpx_codec_enc_config_default(encoder->codec_interface(), &cfg, 0);\n+  if (res) {\n+    printf(\""Failed to get config: %s\\n\"", vpx_codec_err_to_string(res));\n+    return EXIT_FAILURE;\n+  }\n+\n+  // Update the default configuration with our settings.\n+  cfg.g_w = width;\n+  cfg.g_h = height;\n+\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  if (bit_depth != VPX_BITS_8) {\n+    cfg.g_bit_depth = bit_depth;\n+    cfg.g_input_bit_depth = input_bit_depth;\n+    cfg.g_profile = 2;\n+  }\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+\n+  // Timebase format e.g. 30fps: numerator=1, demoninator = 30.\n+  cfg.g_timebase.num = strtol(argv[6], NULL, 0);\n+  cfg.g_timebase.den = strtol(argv[7], NULL, 0);\n+\n+  speed = strtol(argv[8], NULL, 0);\n+  if (speed < 0) {\n+    die(\""Invalid speed setting: must be positive\"");\n+  }\n+\n+  for (i = min_args_base;\n+       (int)i < min_args_base + mode_to_num_layers[layering_mode];\n+       ++i) {\n+    rc.layer_target_bitrate[i - 11] = strtol(argv[i], NULL, 0);\n+    if (strncmp(encoder->name, \""vp8\"", 3) == 0)\n+      cfg.ts_target_bitrate[i - 11] = rc.layer_target_bitrate[i - 11];\n+    else if (strncmp(encoder->name, \""vp9\"", 3) == 0)\n+      cfg.layer_target_bitrate[i - 11] = rc.layer_target_bitrate[i - 11];\n+  }\n+\n+  // Real time parameters.\n+  cfg.rc_dropframe_thresh = strtol(argv[9], NULL, 0);\n+  cfg.rc_end_usage = VPX_CBR;\n+  cfg.rc_min_quantizer = 2;\n+  cfg.rc_max_quantizer = 56;\n+  if (strncmp(encoder->name, \""vp9\"", 3) == 0)\n+    cfg.rc_max_quantizer = 52;\n+  cfg.rc_undershoot_pct = 50;\n+  cfg.rc_overshoot_pct = 50;\n+  cfg.rc_buf_initial_sz = 500;\n+  cfg.rc_buf_optimal_sz = 600;\n+  cfg.rc_buf_sz = 1000;\n+\n+  // Disable dynamic resizing by default.\n+  cfg.rc_resize_allowed = 0;\n+\n+  // Use 1 thread as default.\n+  cfg.g_threads = 1;\n+\n+  // Enable error resilient mode.\n+  cfg.g_error_resilient = 1;\n+  cfg.g_lag_in_frames   = 0;\n+  cfg.kf_mode = VPX_KF_AUTO;\n+\n+  // Disable automatic keyframe placement.\n+  cfg.kf_min_dist = cfg.kf_max_dist = 3000;\n+\n+  cfg.temporal_layering_mode = VP9E_TEMPORAL_LAYERING_MODE_BYPASS;\n+\n+  set_temporal_layer_pattern(layering_mode,\n+                             &cfg,\n+                             layer_flags,\n+                             &flag_periodicity);\n+\n+  set_rate_control_metrics(&rc, &cfg);\n+\n+  // Target bandwidth for the whole stream.\n+  // Set to layer_target_bitrate for highest layer (total bitrate).\n+  cfg.rc_target_bitrate = rc.layer_target_bitrate[cfg.ts_number_layers - 1];\n+\n+  // Open input file.\n+  if (!(infile = fopen(argv[1], \""rb\""))) {\n+    die(\""Failed to open %s for reading\"", argv[1]);\n+  }\n+\n+  framerate = cfg.g_timebase.den / cfg.g_timebase.num;\n+  // Open an output file for each stream.\n+  for (i = 0; i < cfg.ts_number_layers; ++i) {\n+    char file_name[PATH_MAX];\n+    VpxVideoInfo info;\n+    info.codec_fourcc = encoder->fourcc;\n+    info.frame_width = cfg.g_w;\n+    info.frame_height = cfg.g_h;\n+    info.time_base.numerator = cfg.g_timebase.num;\n+    info.time_base.denominator = cfg.g_timebase.den;\n+\n+    snprintf(file_name, sizeof(file_name), \""%s_%d.ivf\"", argv[2], i);\n+    outfile[i] = vpx_video_writer_open(file_name, kContainerIVF, &info);\n+    if (!outfile[i])\n+      die(\""Failed to open %s for writing\"", file_name);\n+\n+    assert(outfile[i] != NULL);\n+  }\n+  // No spatial layers in this encoder.\n+  cfg.ss_number_layers = 1;\n+\n+  // Initialize codec.\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  if (vpx_codec_enc_init(\n+          &codec, encoder->codec_interface(), &cfg,\n+          bit_depth == VPX_BITS_8 ? 0 : VPX_CODEC_USE_HIGHBITDEPTH))\n+#else\n+  if (vpx_codec_enc_init(&codec, encoder->codec_interface(), &cfg, 0))\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+    die_codec(&codec, \""Failed to initialize encoder\"");\n+\n+  if (strncmp(encoder->name, \""vp8\"", 3) == 0) {\n+    vpx_codec_control(&codec, VP8E_SET_CPUUSED, -speed);\n+    vpx_codec_control(&codec, VP8E_SET_NOISE_SENSITIVITY, kDenoiserOff);\n+    vpx_codec_control(&codec, VP8E_SET_STATIC_THRESHOLD, 0);\n+  } else if (strncmp(encoder->name, \""vp9\"", 3) == 0) {\n+    vpx_svc_extra_cfg_t svc_params;\n+    vpx_codec_control(&codec, VP8E_SET_CPUUSED, speed);\n+    vpx_codec_control(&codec, VP9E_SET_AQ_MODE, 3);\n+    vpx_codec_control(&codec, VP9E_SET_FRAME_PERIODIC_BOOST, 0);\n+    vpx_codec_control(&codec, VP9E_SET_NOISE_SENSITIVITY, 0);\n+    vpx_codec_control(&codec, VP8E_SET_STATIC_THRESHOLD, 0);\n+    vpx_codec_control(&codec, VP9E_SET_TUNE_CONTENT, 0);\n+    vpx_codec_control(&codec, VP9E_SET_TILE_COLUMNS, (cfg.g_threads >> 1));\n+    if (vpx_codec_control(&codec, VP9E_SET_SVC, layering_mode > 0 ? 1: 0))\n+      die_codec(&codec, \""Failed to set SVC\"");\n+    for (i = 0; i < cfg.ts_number_layers; ++i) {\n+      svc_params.max_quantizers[i] = cfg.rc_max_quantizer;\n+      svc_params.min_quantizers[i] = cfg.rc_min_quantizer;\n+    }\n+    svc_params.scaling_factor_num[0] = cfg.g_h;\n+    svc_params.scaling_factor_den[0] = cfg.g_h;\n+    vpx_codec_control(&codec, VP9E_SET_SVC_PARAMETERS, &svc_params);\n+  }\n+  if (strncmp(encoder->name, \""vp8\"", 3) == 0) {\n+    vpx_codec_control(&codec, VP8E_SET_SCREEN_CONTENT_MODE, 0);\n+  }\n+  vpx_codec_control(&codec, VP8E_SET_TOKEN_PARTITIONS, 1);\n+  // This controls the maximum target size of the key frame.\n+  // For generating smaller key frames, use a smaller max_intra_size_pct\n+  // value, like 100 or 200.\n+  {\n+    const int max_intra_size_pct = 900;\n+    vpx_codec_control(&codec, VP8E_SET_MAX_INTRA_BITRATE_PCT,\n+                      max_intra_size_pct);\n+  }\n+\n+  frame_avail = 1;\n+  while (frame_avail || got_data) {\n+    struct vpx_usec_timer timer;\n+    vpx_codec_iter_t iter = NULL;\n+    const vpx_codec_cx_pkt_t *pkt;\n+#if VPX_ENCODER_ABI_VERSION > (4 + VPX_CODEC_ABI_VERSION)\n+    // Update the temporal layer_id. No spatial layers in this test.\n+    layer_id.spatial_layer_id = 0;\n+#endif\n+    layer_id.temporal_layer_id =\n+        cfg.ts_layer_id[frame_cnt % cfg.ts_periodicity];\n+    if (strncmp(encoder->name, \""vp9\"", 3) == 0) {\n+      vpx_codec_control(&codec, VP9E_SET_SVC_LAYER_ID, &layer_id);\n+    } else if (strncmp(encoder->name, \""vp8\"", 3) == 0) {\n+      vpx_codec_control(&codec, VP8E_SET_TEMPORAL_LAYER_ID,\n+                        layer_id.temporal_layer_id);\n+    }\n+    flags = layer_flags[frame_cnt % flag_periodicity];\n+    if (layering_mode == 0)\n+      flags = 0;\n+    frame_avail = vpx_img_read(&raw, infile);\n+    if (frame_avail)\n+      ++rc.layer_input_frames[layer_id.temporal_layer_id];\n+    vpx_usec_timer_start(&timer);\n+    if (vpx_codec_encode(&codec, frame_avail? &raw : NULL, pts, 1, flags,\n+        VPX_DL_REALTIME)) {\n+      die_codec(&codec, \""Failed to encode frame\"");\n+    }\n+    vpx_usec_timer_mark(&timer);\n+    cx_time += vpx_usec_timer_elapsed(&timer);\n+    // Reset KF flag.\n+    if (layering_mode != 7) {\n+      layer_flags[0] &= ~VPX_EFLAG_FORCE_KF;\n+    }\n+    got_data = 0;\n+    while ( (pkt = vpx_codec_get_cx_data(&codec, &iter)) ) {\n+      got_data = 1;\n+      switch (pkt->kind) {\n+        case VPX_CODEC_CX_FRAME_PKT:\n+          for (i = cfg.ts_layer_id[frame_cnt % cfg.ts_periodicity];\n+              i < cfg.ts_number_layers; ++i) {\n+            vpx_video_writer_write_frame(outfile[i], pkt->data.frame.buf,\n+                                         pkt->data.frame.sz, pts);\n+            ++rc.layer_tot_enc_frames[i];\n+            rc.layer_encoding_bitrate[i] += 8.0 * pkt->data.frame.sz;\n+            // Keep count of rate control stats per layer (for non-key frames).\n+            if (i == cfg.ts_layer_id[frame_cnt % cfg.ts_periodicity] &&\n+                !(pkt->data.frame.flags & VPX_FRAME_IS_KEY)) {\n+              rc.layer_avg_frame_size[i] += 8.0 * pkt->data.frame.sz;\n+              rc.layer_avg_rate_mismatch[i] +=\n+                  fabs(8.0 * pkt->data.frame.sz - rc.layer_pfb[i]) /\n+                  rc.layer_pfb[i];\n+              ++rc.layer_enc_frames[i];\n+            }\n+          }\n+          // Update for short-time encoding bitrate states, for moving window\n+          // of size rc->window, shifted by rc->window / 2.\n+          // Ignore first window segment, due to key frame.\n+          if (frame_cnt > rc.window_size) {\n+            sum_bitrate += 0.001 * 8.0 * pkt->data.frame.sz * framerate;\n+            if (frame_cnt % rc.window_size == 0) {\n+              rc.window_count += 1;\n+              rc.avg_st_encoding_bitrate += sum_bitrate / rc.window_size;\n+              rc.variance_st_encoding_bitrate +=\n+                  (sum_bitrate / rc.window_size) *\n+                  (sum_bitrate / rc.window_size);\n+              sum_bitrate = 0.0;\n+            }\n+          }\n+          // Second shifted window.\n+          if (frame_cnt > rc.window_size + rc.window_size / 2) {\n+            sum_bitrate2 += 0.001 * 8.0 * pkt->data.frame.sz * framerate;\n+            if (frame_cnt > 2 * rc.window_size &&\n+                frame_cnt % rc.window_size == 0) {\n+              rc.window_count += 1;\n+              rc.avg_st_encoding_bitrate += sum_bitrate2 / rc.window_size;\n+              rc.variance_st_encoding_bitrate +=\n+                  (sum_bitrate2 / rc.window_size) *\n+                  (sum_bitrate2 / rc.window_size);\n+              sum_bitrate2 = 0.0;\n+            }\n+          }\n+          break;\n+          default:\n+            break;\n+      }\n+    }\n+    ++frame_cnt;\n+    pts += frame_duration;\n+  }\n+  fclose(infile);\n+  printout_rate_control_summary(&rc, &cfg, frame_cnt);\n+  printf(\""\\n\"");\n+  printf(\""Frame cnt and encoding time/FPS stats for encoding: %d %f %f \\n\"",\n+          frame_cnt,\n+          1000 * (float)cx_time / (double)(frame_cnt * 1000000),\n+          1000000 * (double)frame_cnt / (double)cx_time);\n+\n+  if (vpx_codec_destroy(&codec))\n+    die_codec(&codec, \""Failed to destroy codec\"");\n+\n+  // Try to rewrite the output file headers with the actual frame count.\n+  for (i = 0; i < cfg.ts_number_layers; ++i)\n+    vpx_video_writer_close(outfile[i]);\n+\n+  vpx_img_free(&raw);\n+  return EXIT_SUCCESS;\n+}\n""}<_**next**_>{""filename"": ""libvpx/libs.doxy_template"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/libs.doxy_template"", ""patch"": ""@@ -36,7 +36,7 @@\n\n # The PROJECT_NAME tag is a single word (or a sequence of words surrounded\n # by quotes) that should identify the project.\n \n-PROJECT_NAME           = \""WebM VP8 Codec SDK\""\n+PROJECT_NAME           = \""WebM Codec SDK\""\n \n # The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)\n # base path where the generated documentation will be put.\n@@ -415,12 +415,6 @@\n\n \n SHOW_USED_FILES        = YES\n \n-# If the sources in your project are distributed over multiple directories\n-# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy\n-# in the documentation. The default is NO.\n-\n-SHOW_DIRECTORIES       = NO\n-\n # The FILE_VERSION_FILTER tag can be used to specify a program or script that\n # doxygen should invoke to get the current version for each file (typically from the\n # version control system). Doxygen will invoke the program by executing (via\n@@ -715,12 +709,6 @@\n\n \n HTML_STYLESHEET        =\n \n-# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes,\n-# files or namespaces will be aligned in HTML using tables. If set to\n-# NO a bullet list will be used.\n-\n-HTML_ALIGN_MEMBERS     = YES\n-\n # If the GENERATE_HTMLHELP tag is set to YES, additional index files\n # will be generated that can be used as input for tools like the\n # Microsoft HTML help workshop to generate a compressed HTML help file (.chm)\n""}<_**next**_>{""filename"": ""libvpx/libs.mk"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/libs.mk"", ""patch"": ""@@ -18,32 +18,6 @@\n\n endif\n \n #\n-# Calculate platform- and compiler-specific offsets for hand coded assembly\n-#\n-ifeq ($(filter icc gcc,$(TGT_CC)), $(TGT_CC))\n-OFFSET_PATTERN:='^[a-zA-Z0-9_]* EQU'\n-define asm_offsets_template\n-$$(BUILD_PFX)$(1): $$(BUILD_PFX)$(2).S\n-\t@echo \""    [CREATE] $$@\""\n-\t$$(qexec)LC_ALL=C grep $$(OFFSET_PATTERN) $$< | tr -d '$$$$\\#' $$(ADS2GAS) > $$@\n-$$(BUILD_PFX)$(2).S: $(2)\n-CLEAN-OBJS += $$(BUILD_PFX)$(1) $(2).S\n-endef\n-else\n-  ifeq ($(filter rvct,$(TGT_CC)), $(TGT_CC))\n-define asm_offsets_template\n-$$(BUILD_PFX)$(1): obj_int_extract\n-$$(BUILD_PFX)$(1): $$(BUILD_PFX)$(2).o\n-\t@echo \""    [CREATE] $$@\""\n-\t$$(qexec)./obj_int_extract rvds $$< $$(ADS2GAS) > $$@\n-OBJS-yes += $$(BUILD_PFX)$(2).o\n-CLEAN-OBJS += $$(BUILD_PFX)$(1)\n-$$(filter %$$(ASM).o,$$(OBJS-yes)): $$(BUILD_PFX)$(1)\n-endef\n-endif # rvct\n-endif # !gcc\n-\n-#\n # Rule to generate runtime cpu detection files\n #\n define rtcd_h_template\n@@ -51,7 +25,7 @@\n\n \t@echo \""    [CREATE] $$@\""\n \t$$(qexec)$$(SRC_PATH_BARE)/build/make/rtcd.pl --arch=$$(TGT_ISA) \\\n           --sym=$(1) \\\n-          --config=$$(CONFIG_DIR)$$(target)$$(if $$(FAT_ARCHS),,-$$(TOOLCHAIN)).mk \\\n+          --config=$$(CONFIG_DIR)$$(target)-$$(TOOLCHAIN).mk \\\n           $$(RTCD_OPTIONS) $$^ > $$@\n CLEAN-OBJS += $$(BUILD_PFX)$(1).h\n RTCD += $$(BUILD_PFX)$(1).h\n@@ -60,13 +34,6 @@\n\n CODEC_SRCS-yes += CHANGELOG\n CODEC_SRCS-yes += libs.mk\n \n-# If this is a universal (fat) binary, then all the subarchitectures have\n-# already been built and our job is to stitch them together. The\n-# BUILD_LIBVPX variable indicates whether we should be building\n-# (compiling, linking) the library. The LIPO_LIBVPX variable indicates\n-# that we're stitching.\n-$(eval $(if $(filter universal%,$(TOOLCHAIN)),LIPO_LIBVPX,BUILD_LIBVPX):=yes)\n-\n include $(SRC_PATH_BARE)/vpx/vpx_codec.mk\n CODEC_SRCS-yes += $(addprefix vpx/,$(call enabled,API_SRCS))\n CODEC_DOC_SRCS += $(addprefix vpx/,$(call enabled,API_DOC_SRCS))\n@@ -80,6 +47,12 @@\n\n include $(SRC_PATH_BARE)/vpx_ports/vpx_ports.mk\n CODEC_SRCS-yes += $(addprefix vpx_ports/,$(call enabled,PORTS_SRCS))\n \n+include $(SRC_PATH_BARE)/vpx_dsp/vpx_dsp.mk\n+CODEC_SRCS-yes += $(addprefix vpx_dsp/,$(call enabled,DSP_SRCS))\n+\n+include $(SRC_PATH_BARE)/vpx_util/vpx_util.mk\n+CODEC_SRCS-yes += $(addprefix vpx_util/,$(call enabled,UTIL_SRCS))\n+\n ifneq ($(CONFIG_VP8_ENCODER)$(CONFIG_VP8_DECODER),)\n   VP8_PREFIX=vp8/\n   include $(SRC_PATH_BARE)/$(VP8_PREFIX)vp8_common.mk\n@@ -115,7 +88,7 @@\n\n   CODEC_EXPORTS-yes += $(addprefix $(VP9_PREFIX),$(VP9_CX_EXPORTS))\n   CODEC_SRCS-yes += $(VP9_PREFIX)vp9cx.mk vpx/vp8.h vpx/vp8cx.h\n   INSTALL-LIBS-yes += include/vpx/vp8.h include/vpx/vp8cx.h\n-  INSTALL-LIBS-yes += include/vpx/svc_context.h\n+  INSTALL-LIBS-$(CONFIG_SPATIAL_SVC) += include/vpx/svc_context.h\n   INSTALL_MAPS += include/vpx/% $(SRC_PATH_BARE)/$(VP9_PREFIX)/%\n   CODEC_DOC_SRCS += vpx/vp8.h vpx/vp8cx.h\n   CODEC_DOC_SECTIONS += vp9 vp9_encoder\n@@ -133,6 +106,42 @@\n\n   CODEC_DOC_SECTIONS += vp9 vp9_decoder\n endif\n \n+VP9_PREFIX=vp9/\n+$(BUILD_PFX)$(VP9_PREFIX)%.c.o: CFLAGS += -Wextra\n+\n+#  VP10 make file\n+ifneq ($(CONFIG_VP10_ENCODER)$(CONFIG_VP10_DECODER),)\n+  VP10_PREFIX=vp10/\n+  include $(SRC_PATH_BARE)/$(VP10_PREFIX)vp10_common.mk\n+endif\n+\n+ifeq ($(CONFIG_VP10_ENCODER),yes)\n+  VP10_PREFIX=vp10/\n+  include $(SRC_PATH_BARE)/$(VP10_PREFIX)vp10cx.mk\n+  CODEC_SRCS-yes += $(addprefix $(VP10_PREFIX),$(call enabled,VP10_CX_SRCS))\n+  CODEC_EXPORTS-yes += $(addprefix $(VP10_PREFIX),$(VP10_CX_EXPORTS))\n+  CODEC_SRCS-yes += $(VP10_PREFIX)vp10cx.mk vpx/vp8.h vpx/vp8cx.h\n+  INSTALL-LIBS-yes += include/vpx/vp8.h include/vpx/vp8cx.h\n+  INSTALL-LIBS-$(CONFIG_SPATIAL_SVC) += include/vpx/svc_context.h\n+  INSTALL_MAPS += include/vpx/% $(SRC_PATH_BARE)/$(VP10_PREFIX)/%\n+  CODEC_DOC_SRCS += vpx/vp8.h vpx/vp8cx.h\n+  CODEC_DOC_SECTIONS += vp9 vp9_encoder\n+endif\n+\n+ifeq ($(CONFIG_VP10_DECODER),yes)\n+  VP10_PREFIX=vp10/\n+  include $(SRC_PATH_BARE)/$(VP10_PREFIX)vp10dx.mk\n+  CODEC_SRCS-yes += $(addprefix $(VP10_PREFIX),$(call enabled,VP10_DX_SRCS))\n+  CODEC_EXPORTS-yes += $(addprefix $(VP10_PREFIX),$(VP10_DX_EXPORTS))\n+  CODEC_SRCS-yes += $(VP10_PREFIX)vp10dx.mk vpx/vp8.h vpx/vp8dx.h\n+  INSTALL-LIBS-yes += include/vpx/vp8.h include/vpx/vp8dx.h\n+  INSTALL_MAPS += include/vpx/% $(SRC_PATH_BARE)/$(VP10_PREFIX)/%\n+  CODEC_DOC_SRCS += vpx/vp8.h vpx/vp8dx.h\n+  CODEC_DOC_SECTIONS += vp9 vp9_decoder\n+endif\n+\n+VP10_PREFIX=vp10/\n+$(BUILD_PFX)$(VP10_PREFIX)%.c.o: CFLAGS += -Wextra\n \n ifeq ($(CONFIG_ENCODERS),yes)\n   CODEC_DOC_SECTIONS += encoder\n@@ -161,18 +170,18 @@\n\n INSTALL_MAPS += $(foreach p,$(VS_PLATFORMS),$(LIBSUBDIR)/$(p)/%  $(p)/Debug/%)\n endif\n \n-CODEC_SRCS-$(BUILD_LIBVPX) += build/make/version.sh\n-CODEC_SRCS-$(BUILD_LIBVPX) += build/make/rtcd.pl\n-CODEC_SRCS-$(BUILD_LIBVPX) += vpx_ports/emmintrin_compat.h\n-CODEC_SRCS-$(BUILD_LIBVPX) += vpx_ports/mem_ops.h\n-CODEC_SRCS-$(BUILD_LIBVPX) += vpx_ports/mem_ops_aligned.h\n-CODEC_SRCS-$(BUILD_LIBVPX) += vpx_ports/vpx_once.h\n-CODEC_SRCS-$(BUILD_LIBVPX) += $(BUILD_PFX)vpx_config.c\n+CODEC_SRCS-yes += build/make/version.sh\n+CODEC_SRCS-yes += build/make/rtcd.pl\n+CODEC_SRCS-yes += vpx_ports/emmintrin_compat.h\n+CODEC_SRCS-yes += vpx_ports/mem_ops.h\n+CODEC_SRCS-yes += vpx_ports/mem_ops_aligned.h\n+CODEC_SRCS-yes += vpx_ports/vpx_once.h\n+CODEC_SRCS-yes += $(BUILD_PFX)vpx_config.c\n INSTALL-SRCS-no += $(BUILD_PFX)vpx_config.c\n ifeq ($(ARCH_X86)$(ARCH_X86_64),yes)\n-CODEC_SRCS-$(BUILD_LIBVPX) += third_party/x86inc/x86inc.asm\n+INSTALL-SRCS-$(CONFIG_CODEC_SRCS) += third_party/x86inc/x86inc.asm\n endif\n-CODEC_EXPORTS-$(BUILD_LIBVPX) += vpx/exports_com\n+CODEC_EXPORTS-yes += vpx/exports_com\n CODEC_EXPORTS-$(CONFIG_ENCODERS) += vpx/exports_enc\n CODEC_EXPORTS-$(CONFIG_DECODERS) += vpx/exports_dec\n \n@@ -203,32 +212,13 @@\n\n # based build systems.\n libvpx_srcs.txt:\n \t@echo \""    [CREATE] $@\""\n-\t@echo $(CODEC_SRCS) | xargs -n1 echo | sort -u > $@\n+\t@echo $(CODEC_SRCS) | xargs -n1 echo | LC_ALL=C sort -u > $@\n CLEAN-OBJS += libvpx_srcs.txt\n \n \n ifeq ($(CONFIG_EXTERNAL_BUILD),yes)\n ifeq ($(CONFIG_MSVS),yes)\n \n-obj_int_extract.bat: $(SRC_PATH_BARE)/build/$(MSVS_ARCH_DIR)/obj_int_extract.bat\n-\t@cp $^ $@\n-\n-obj_int_extract.$(VCPROJ_SFX): obj_int_extract.bat\n-obj_int_extract.$(VCPROJ_SFX): $(SRC_PATH_BARE)/build/make/obj_int_extract.c\n-\t@echo \""    [CREATE] $@\""\n-\t$(qexec)$(GEN_VCPROJ) \\\n-    --exe \\\n-    --target=$(TOOLCHAIN) \\\n-    --name=obj_int_extract \\\n-    --ver=$(CONFIG_VS_VERSION) \\\n-    --proj-guid=E1360C65-D375-4335-8057-7ED99CC3F9B2 \\\n-    $(if $(CONFIG_STATIC_MSVCRT),--static-crt) \\\n-    --out=$@ $^ \\\n-    -I. \\\n-    -I\""$(SRC_PATH_BARE)\"" \\\n-\n-PROJECTS-$(BUILD_LIBVPX) += obj_int_extract.$(VCPROJ_SFX)\n-\n vpx.def: $(call enabled,CODEC_EXPORTS)\n \t@echo \""    [CREATE] $@\""\n \t$(qexec)$(SRC_PATH_BARE)/build/make/gen_msvs_def.sh\\\n@@ -243,7 +233,7 @@\n\n     vpx_config.asm \\\n     vpx_ports/x86_abi_support.asm \\\n \n-vpx.$(VCPROJ_SFX): $(CODEC_SRCS) vpx.def obj_int_extract.$(VCPROJ_SFX)\n+vpx.$(VCPROJ_SFX): $(CODEC_SRCS) vpx.def\n \t@echo \""    [CREATE] $@\""\n \t$(qexec)$(GEN_VCPROJ) \\\n             $(if $(CONFIG_SHARED),--dll,--lib) \\\n@@ -253,11 +243,12 @@\n\n             --proj-guid=DCE19DAF-69AC-46DB-B14A-39F0FAA5DB74 \\\n             --module-def=vpx.def \\\n             --ver=$(CONFIG_VS_VERSION) \\\n+            --src-path-bare=\""$(SRC_PATH_BARE)\"" \\\n             --out=$@ $(CFLAGS) \\\n             $(filter-out $(addprefix %, $(ASM_INCLUDES)), $^) \\\n             --src-path-bare=\""$(SRC_PATH_BARE)\"" \\\n \n-PROJECTS-$(BUILD_LIBVPX) += vpx.$(VCPROJ_SFX)\n+PROJECTS-yes += vpx.$(VCPROJ_SFX)\n \n vpx.$(VCPROJ_SFX): vpx_config.asm\n vpx.$(VCPROJ_SFX): $(RTCD)\n@@ -265,32 +256,42 @@\n\n endif\n else\n LIBVPX_OBJS=$(call objs,$(CODEC_SRCS))\n-OBJS-$(BUILD_LIBVPX) += $(LIBVPX_OBJS)\n-LIBS-$(if $(BUILD_LIBVPX),$(CONFIG_STATIC)) += $(BUILD_PFX)libvpx.a $(BUILD_PFX)libvpx_g.a\n+OBJS-yes += $(LIBVPX_OBJS)\n+LIBS-$(if yes,$(CONFIG_STATIC)) += $(BUILD_PFX)libvpx.a $(BUILD_PFX)libvpx_g.a\n $(BUILD_PFX)libvpx_g.a: $(LIBVPX_OBJS)\n \n-\n-BUILD_LIBVPX_SO         := $(if $(BUILD_LIBVPX),$(CONFIG_SHARED))\n-\n+SO_VERSION_MAJOR := 2\n+SO_VERSION_MINOR := 0\n+SO_VERSION_PATCH := 0\n ifeq ($(filter darwin%,$(TGT_OS)),$(TGT_OS))\n-LIBVPX_SO               := libvpx.$(VERSION_MAJOR).dylib\n+LIBVPX_SO               := libvpx.$(SO_VERSION_MAJOR).dylib\n+SHARED_LIB_SUF          := .dylib\n EXPORT_FILE             := libvpx.syms\n LIBVPX_SO_SYMLINKS      := $(addprefix $(LIBSUBDIR)/, \\\n                              libvpx.dylib  )\n else\n-LIBVPX_SO               := libvpx.so.$(VERSION_MAJOR).$(VERSION_MINOR).$(VERSION_PATCH)\n+ifeq ($(filter os2%,$(TGT_OS)),$(TGT_OS))\n+LIBVPX_SO               := libvpx$(SO_VERSION_MAJOR).dll\n+SHARED_LIB_SUF          := _dll.a\n+EXPORT_FILE             := libvpx.def\n+LIBVPX_SO_SYMLINKS      :=\n+LIBVPX_SO_IMPLIB        := libvpx_dll.a\n+else\n+LIBVPX_SO               := libvpx.so.$(SO_VERSION_MAJOR).$(SO_VERSION_MINOR).$(SO_VERSION_PATCH)\n+SHARED_LIB_SUF          := .so\n EXPORT_FILE             := libvpx.ver\n-SYM_LINK                := libvpx.so\n LIBVPX_SO_SYMLINKS      := $(addprefix $(LIBSUBDIR)/, \\\n-                             libvpx.so libvpx.so.$(VERSION_MAJOR) \\\n-                             libvpx.so.$(VERSION_MAJOR).$(VERSION_MINOR))\n+                             libvpx.so libvpx.so.$(SO_VERSION_MAJOR) \\\n+                             libvpx.so.$(SO_VERSION_MAJOR).$(SO_VERSION_MINOR))\n+endif\n endif\n \n-LIBS-$(BUILD_LIBVPX_SO) += $(BUILD_PFX)$(LIBVPX_SO)\\\n-                           $(notdir $(LIBVPX_SO_SYMLINKS))\n+LIBS-$(CONFIG_SHARED) += $(BUILD_PFX)$(LIBVPX_SO)\\\n+                           $(notdir $(LIBVPX_SO_SYMLINKS)) \\\n+                           $(if $(LIBVPX_SO_IMPLIB), $(BUILD_PFX)$(LIBVPX_SO_IMPLIB))\n $(BUILD_PFX)$(LIBVPX_SO): $(LIBVPX_OBJS) $(EXPORT_FILE)\n $(BUILD_PFX)$(LIBVPX_SO): extralibs += -lm\n-$(BUILD_PFX)$(LIBVPX_SO): SONAME = libvpx.so.$(VERSION_MAJOR)\n+$(BUILD_PFX)$(LIBVPX_SO): SONAME = libvpx.so.$(SO_VERSION_MAJOR)\n $(BUILD_PFX)$(LIBVPX_SO): EXPORTS_FILE = $(EXPORT_FILE)\n \n libvpx.ver: $(call enabled,CODEC_EXPORTS)\n@@ -305,6 +306,19 @@\n\n \t$(qexec)awk '{print \""_\""$$2}' $^ >$@\n CLEAN-OBJS += libvpx.syms\n \n+libvpx.def: $(call enabled,CODEC_EXPORTS)\n+\t@echo \""    [CREATE] $@\""\n+\t$(qexec)echo LIBRARY $(LIBVPX_SO:.dll=) INITINSTANCE TERMINSTANCE > $@\n+\t$(qexec)echo \""DATA MULTIPLE NONSHARED\"" >> $@\n+\t$(qexec)echo \""EXPORTS\"" >> $@\n+\t$(qexec)awk '!/vpx_svc_*/ {print \""_\""$$2}' $^ >>$@\n+CLEAN-OBJS += libvpx.def\n+\n+libvpx_dll.a: $(LIBVPX_SO)\n+\t@echo \""    [IMPLIB] $@\""\n+\t$(qexec)emximp -o $@ $<\n+CLEAN-OBJS += libvpx_dll.a\n+\n define libvpx_symlink_template\n $(1): $(2)\n \t@echo \""    [LN]     $(2) $$@\""\n@@ -320,11 +334,12 @@\n\n     $(LIBVPX_SO)))\n \n \n-INSTALL-LIBS-$(BUILD_LIBVPX_SO) += $(LIBVPX_SO_SYMLINKS)\n-INSTALL-LIBS-$(BUILD_LIBVPX_SO) += $(LIBSUBDIR)/$(LIBVPX_SO)\n+INSTALL-LIBS-$(CONFIG_SHARED) += $(LIBVPX_SO_SYMLINKS)\n+INSTALL-LIBS-$(CONFIG_SHARED) += $(LIBSUBDIR)/$(LIBVPX_SO)\n+INSTALL-LIBS-$(CONFIG_SHARED) += $(if $(LIBVPX_SO_IMPLIB),$(LIBSUBDIR)/$(LIBVPX_SO_IMPLIB))\n \n \n-LIBS-$(BUILD_LIBVPX) += vpx.pc\n+LIBS-yes += vpx.pc\n vpx.pc: config.mk libs.mk\n \t@echo \""    [CREATE] $@\""\n \t$(qexec)echo '# pkg-config file from libvpx $(VERSION_STRING)' > $@\n@@ -350,9 +365,6 @@\n\n CLEAN-OBJS += vpx.pc\n endif\n \n-LIBS-$(LIPO_LIBVPX) += libvpx.a\n-$(eval $(if $(LIPO_LIBVPX),$(call lipo_lib_template,libvpx.a)))\n-\n #\n # Rule to make assembler configuration file from C configuration file\n #\n@@ -373,7 +385,7 @@\n\n endif\n \n #\n-# Add assembler dependencies for configuration and offsets\n+# Add assembler dependencies for configuration.\n #\n $(filter %.s.o,$(OBJS-yes)):     $(BUILD_PFX)vpx_config.asm\n $(filter %$(ASM).o,$(OBJS-yes)): $(BUILD_PFX)vpx_config.asm\n@@ -391,14 +403,18 @@\n\n \n include $(SRC_PATH_BARE)/test/test.mk\n LIBVPX_TEST_SRCS=$(addprefix test/,$(call enabled,LIBVPX_TEST_SRCS))\n-LIBVPX_TEST_BINS=./test_libvpx$(EXE_SFX)\n+LIBVPX_TEST_BIN=./test_libvpx$(EXE_SFX)\n LIBVPX_TEST_DATA=$(addprefix $(LIBVPX_TEST_DATA_PATH)/,\\\n                      $(call enabled,LIBVPX_TEST_DATA))\n libvpx_test_data_url=http://downloads.webmproject.org/test_data/libvpx/$(1)\n \n+TEST_INTRA_PRED_SPEED_BIN=./test_intra_pred_speed$(EXE_SFX)\n+TEST_INTRA_PRED_SPEED_SRCS=$(addprefix test/,$(call enabled,TEST_INTRA_PRED_SPEED_SRCS))\n+TEST_INTRA_PRED_SPEED_OBJS := $(sort $(call objs,$(TEST_INTRA_PRED_SPEED_SRCS)))\n+\n libvpx_test_srcs.txt:\n \t@echo \""    [CREATE] $@\""\n-\t@echo $(LIBVPX_TEST_SRCS) | xargs -n1 echo | sort -u > $@\n+\t@echo $(LIBVPX_TEST_SRCS) | xargs -n1 echo | LC_ALL=C sort -u > $@\n CLEAN-OBJS += libvpx_test_srcs.txt\n \n $(LIBVPX_TEST_DATA): $(SRC_PATH_BARE)/test/test-data.sha1\n@@ -407,12 +423,16 @@\n\n             curl -L -o $@ $(call libvpx_test_data_url,$(@F))\n \n testdata:: $(LIBVPX_TEST_DATA)\n-\t$(qexec)if [ -x \""$$(which sha1sum)\"" ]; then\\\n+\t$(qexec)[ -x \""$$(which sha1sum)\"" ] && sha1sum=sha1sum;\\\n+          [ -x \""$$(which shasum)\"" ] && sha1sum=shasum;\\\n+          [ -x \""$$(which sha1)\"" ] && sha1sum=sha1;\\\n+          if [ -n \""$${sha1sum}\"" ]; then\\\n+            set -e;\\\n             echo \""Checking test data:\"";\\\n             if [ -n \""$(LIBVPX_TEST_DATA)\"" ]; then\\\n                 for f in $(call enabled,LIBVPX_TEST_DATA); do\\\n                     grep $$f $(SRC_PATH_BARE)/test/test-data.sha1 |\\\n-                        (cd $(LIBVPX_TEST_DATA_PATH); sha1sum -c);\\\n+                        (cd $(LIBVPX_TEST_DATA_PATH); $${sha1sum} -c);\\\n                 done; \\\n             fi; \\\n         else\\\n@@ -447,6 +467,7 @@\n\n             -D_VARIADIC_MAX=10 \\\n             --proj-guid=CD837F5F-52D8-4314-A370-895D614166A7 \\\n             --ver=$(CONFIG_VS_VERSION) \\\n+            --src-path-bare=\""$(SRC_PATH_BARE)\"" \\\n             $(if $(CONFIG_STATIC_MSVCRT),--static-crt) \\\n             --out=$@ $(INTERNAL_CFLAGS) $(CFLAGS) \\\n             -I. -I\""$(SRC_PATH_BARE)/third_party/googletest/src/include\"" \\\n@@ -454,7 +475,25 @@\n\n \n PROJECTS-$(CONFIG_MSVS) += test_libvpx.$(VCPROJ_SFX)\n \n-LIBVPX_TEST_BINS := $(addprefix $(TGT_OS:win64=x64)/Release/,$(notdir $(LIBVPX_TEST_BINS)))\n+LIBVPX_TEST_BIN := $(addprefix $(TGT_OS:win64=x64)/Release/,$(notdir $(LIBVPX_TEST_BIN)))\n+\n+ifneq ($(strip $(TEST_INTRA_PRED_SPEED_OBJS)),)\n+PROJECTS-$(CONFIG_MSVS) += test_intra_pred_speed.$(VCPROJ_SFX)\n+test_intra_pred_speed.$(VCPROJ_SFX): $(TEST_INTRA_PRED_SPEED_SRCS) vpx.$(VCPROJ_SFX) gtest.$(VCPROJ_SFX)\n+\t@echo \""    [CREATE] $@\""\n+\t$(qexec)$(GEN_VCPROJ) \\\n+            --exe \\\n+            --target=$(TOOLCHAIN) \\\n+            --name=test_intra_pred_speed \\\n+            -D_VARIADIC_MAX=10 \\\n+            --proj-guid=CD837F5F-52D8-4314-A370-895D614166A7 \\\n+            --ver=$(CONFIG_VS_VERSION) \\\n+            --src-path-bare=\""$(SRC_PATH_BARE)\"" \\\n+            $(if $(CONFIG_STATIC_MSVCRT),--static-crt) \\\n+            --out=$@ $(INTERNAL_CFLAGS) $(CFLAGS) \\\n+            -I. -I\""$(SRC_PATH_BARE)/third_party/googletest/src/include\"" \\\n+            -L. -l$(CODEC_LIB) -l$(GTEST_LIB) $^\n+endif  # TEST_INTRA_PRED_SPEED\n endif\n else\n \n@@ -465,45 +504,54 @@\n\n # Disabling pthreads globally will cause issues on darwin and possibly elsewhere\n $(GTEST_OBJS) $(GTEST_OBJS:.o=.d): CXXFLAGS += -DGTEST_HAS_PTHREAD=0\n endif\n-$(GTEST_OBJS) $(GTEST_OBJS:.o=.d): CXXFLAGS += -I$(SRC_PATH_BARE)/third_party/googletest/src\n-$(GTEST_OBJS) $(GTEST_OBJS:.o=.d): CXXFLAGS += -I$(SRC_PATH_BARE)/third_party/googletest/src/include\n-OBJS-$(BUILD_LIBVPX) += $(GTEST_OBJS)\n-LIBS-$(BUILD_LIBVPX) += $(BUILD_PFX)libgtest.a $(BUILD_PFX)libgtest_g.a\n+GTEST_INCLUDES := -I$(SRC_PATH_BARE)/third_party/googletest/src\n+GTEST_INCLUDES += -I$(SRC_PATH_BARE)/third_party/googletest/src/include\n+$(GTEST_OBJS) $(GTEST_OBJS:.o=.d): CXXFLAGS += $(GTEST_INCLUDES)\n+OBJS-yes += $(GTEST_OBJS)\n+LIBS-yes += $(BUILD_PFX)libgtest.a $(BUILD_PFX)libgtest_g.a\n $(BUILD_PFX)libgtest_g.a: $(GTEST_OBJS)\n \n LIBVPX_TEST_OBJS=$(sort $(call objs,$(LIBVPX_TEST_SRCS)))\n-$(LIBVPX_TEST_OBJS) $(LIBVPX_TEST_OBJS:.o=.d): CXXFLAGS += -I$(SRC_PATH_BARE)/third_party/googletest/src\n-$(LIBVPX_TEST_OBJS) $(LIBVPX_TEST_OBJS:.o=.d): CXXFLAGS += -I$(SRC_PATH_BARE)/third_party/googletest/src/include\n-OBJS-$(BUILD_LIBVPX) += $(LIBVPX_TEST_OBJS)\n-BINS-$(BUILD_LIBVPX) += $(LIBVPX_TEST_BINS)\n+$(LIBVPX_TEST_OBJS) $(LIBVPX_TEST_OBJS:.o=.d): CXXFLAGS += $(GTEST_INCLUDES)\n+OBJS-yes += $(LIBVPX_TEST_OBJS)\n+BINS-yes += $(LIBVPX_TEST_BIN)\n \n CODEC_LIB=$(if $(CONFIG_DEBUG_LIBS),vpx_g,vpx)\n-CODEC_LIB_SUF=$(if $(CONFIG_SHARED),.so,.a)\n-$(foreach bin,$(LIBVPX_TEST_BINS),\\\n-    $(if $(BUILD_LIBVPX),$(eval $(bin): \\\n-        lib$(CODEC_LIB)$(CODEC_LIB_SUF) libgtest.a ))\\\n-    $(if $(BUILD_LIBVPX),$(eval $(call linkerxx_template,$(bin),\\\n-        $(LIBVPX_TEST_OBJS) \\\n-        -L. -lvpx -lgtest $(extralibs) -lm)\\\n-        )))\\\n-    $(if $(LIPO_LIBS),$(eval $(call lipo_bin_template,$(bin))))\\\n+CODEC_LIB_SUF=$(if $(CONFIG_SHARED),$(SHARED_LIB_SUF),.a)\n+TEST_LIBS := lib$(CODEC_LIB)$(CODEC_LIB_SUF) libgtest.a\n+$(LIBVPX_TEST_BIN): $(TEST_LIBS)\n+$(eval $(call linkerxx_template,$(LIBVPX_TEST_BIN), \\\n+              $(LIBVPX_TEST_OBJS) \\\n+              -L. -lvpx -lgtest $(extralibs) -lm))\n \n-endif\n+ifneq ($(strip $(TEST_INTRA_PRED_SPEED_OBJS)),)\n+$(TEST_INTRA_PRED_SPEED_OBJS) $(TEST_INTRA_PRED_SPEED_OBJS:.o=.d): CXXFLAGS += $(GTEST_INCLUDES)\n+OBJS-yes += $(TEST_INTRA_PRED_SPEED_OBJS)\n+BINS-yes += $(TEST_INTRA_PRED_SPEED_BIN)\n+\n+$(TEST_INTRA_PRED_SPEED_BIN): $(TEST_LIBS)\n+$(eval $(call linkerxx_template,$(TEST_INTRA_PRED_SPEED_BIN), \\\n+              $(TEST_INTRA_PRED_SPEED_OBJS) \\\n+              -L. -lvpx -lgtest $(extralibs) -lm))\n+endif  # TEST_INTRA_PRED_SPEED\n+\n+endif  # CONFIG_UNIT_TESTS\n \n # Install test sources only if codec source is included\n INSTALL-SRCS-$(CONFIG_CODEC_SRCS) += $(patsubst $(SRC_PATH_BARE)/%,%,\\\n     $(shell find $(SRC_PATH_BARE)/third_party/googletest -type f))\n INSTALL-SRCS-$(CONFIG_CODEC_SRCS) += $(LIBVPX_TEST_SRCS)\n+INSTALL-SRCS-$(CONFIG_CODEC_SRCS) += $(TEST_INTRA_PRED_SPEED_SRCS)\n \n define test_shard_template\n test:: test_shard.$(1)\n-test_shard.$(1): $(LIBVPX_TEST_BINS) testdata\n+test-no-data-check:: test_shard_ndc.$(1)\n+test_shard.$(1) test_shard_ndc.$(1): $(LIBVPX_TEST_BIN)\n \t@set -e; \\\n-\t for t in $(LIBVPX_TEST_BINS); do \\\n-\t   export GTEST_SHARD_INDEX=$(1); \\\n-\t   export GTEST_TOTAL_SHARDS=$(2); \\\n-\t   $$$$t; \\\n-\t done\n+\t export GTEST_SHARD_INDEX=$(1); \\\n+\t export GTEST_TOTAL_SHARDS=$(2); \\\n+\t $(LIBVPX_TEST_BIN)\n+test_shard.$(1): testdata\n .PHONY: test_shard.$(1)\n endef\n \n@@ -522,12 +570,65 @@\n\n \t@echo \""    [CREATE] $@\""\n \t@rm -f $@\n \t@echo \""INPUT += $^\"" >> $@\n-\t@echo \""PREDEFINED = VPX_CODEC_DISABLE_COMPAT\"" >> $@\n \t@echo \""INCLUDE_PATH += .\"" >> $@;\n \t@echo \""ENABLED_SECTIONS += $(sort $(CODEC_DOC_SECTIONS))\"" >> $@\n \n ## Generate rtcd.h for all objects\n+ifeq ($(CONFIG_DEPENDENCY_TRACKING),yes)\n $(OBJS-yes:.o=.d): $(RTCD)\n+else\n+$(OBJS-yes): $(RTCD)\n+endif\n \n ## Update the global src list\n SRCS += $(CODEC_SRCS) $(LIBVPX_TEST_SRCS) $(GTEST_SRCS)\n+\n+##\n+## vpxdec/vpxenc tests.\n+##\n+ifeq ($(CONFIG_UNIT_TESTS),yes)\n+TEST_BIN_PATH = .\n+ifeq ($(CONFIG_MSVS),yes)\n+# MSVC will build both Debug and Release configurations of tools in a\n+# sub directory named for the current target. Assume the user wants to\n+# run the Release tools, and assign TEST_BIN_PATH accordingly.\n+# TODO(tomfinegan): Is this adequate for ARM?\n+# TODO(tomfinegan): Support running the debug versions of tools?\n+TEST_BIN_PATH := $(addsuffix /$(TGT_OS:win64=x64)/Release, $(TEST_BIN_PATH))\n+endif\n+utiltest utiltest-no-data-check:\n+\t$(qexec)$(SRC_PATH_BARE)/test/vpxdec.sh \\\n+\t\t--test-data-path $(LIBVPX_TEST_DATA_PATH) \\\n+\t\t--bin-path $(TEST_BIN_PATH)\n+\t$(qexec)$(SRC_PATH_BARE)/test/vpxenc.sh \\\n+\t\t--test-data-path $(LIBVPX_TEST_DATA_PATH) \\\n+\t\t--bin-path $(TEST_BIN_PATH)\n+utiltest: testdata\n+else\n+utiltest utiltest-no-data-check:\n+\t@echo Unit tests must be enabled to make the utiltest target.\n+endif\n+\n+##\n+## Example tests.\n+##\n+ifeq ($(CONFIG_UNIT_TESTS),yes)\n+# All non-MSVC targets output example targets in a sub dir named examples.\n+EXAMPLES_BIN_PATH = examples\n+ifeq ($(CONFIG_MSVS),yes)\n+# MSVC will build both Debug and Release configurations of the examples in a\n+# sub directory named for the current target. Assume the user wants to\n+# run the Release tools, and assign EXAMPLES_BIN_PATH accordingly.\n+# TODO(tomfinegan): Is this adequate for ARM?\n+# TODO(tomfinegan): Support running the debug versions of tools?\n+EXAMPLES_BIN_PATH := $(TGT_OS:win64=x64)/Release\n+endif\n+exampletest exampletest-no-data-check: examples\n+\t$(qexec)$(SRC_PATH_BARE)/test/examples.sh \\\n+\t\t--test-data-path $(LIBVPX_TEST_DATA_PATH) \\\n+\t\t--bin-path $(EXAMPLES_BIN_PATH)\n+exampletest: testdata\n+else\n+exampletest exampletest-no-data-check:\n+\t@echo Unit tests must be enabled to make the exampletest target.\n+endif\n""}<_**next**_>{""filename"": ""libvpx/mainpage.dox"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/mainpage.dox"", ""patch"": ""@@ -1,4 +1,4 @@\n\n-/*!\\mainpage WebM VP8 Codec SDK\n+/*!\\mainpage WebM Codec SDK\n \n   \\section main_contents Page Contents\n   - \\ref main_intro\n@@ -6,11 +6,11 @@\n\n   - \\ref main_support\n \n   \\section main_intro Introduction\n-  Welcome to the WebM VP8 Codec SDK. This SDK allows you to integrate your\n-  applications with the VP8 video codec, a high quality, royalty free, open\n-  source codec deployed on millions of computers and devices worldwide.\n+  Welcome to the WebM Codec SDK. This SDK allows you to integrate your\n+  applications with the VP8 and VP9 video codecs, high quality, royalty free,\n+  open source codecs deployed on billions of computers and devices worldwide.\n \n-  This distribution of the WebM VP8 Codec SDK includes the following support:\n+  This distribution of the WebM Codec SDK includes the following support:\n \n   \\if vp8_encoder\n   - \\ref vp8_encoder\n@@ -28,12 +28,12 @@\n\n   - Read the \\ref samples \""sample code\"" for examples of how to interact with the\n     codec.\n   - \\ref codec reference\n-    \\if encoder\n-    - \\ref encoder reference\n-    \\endif\n-    \\if decoder\n-    - \\ref decoder reference\n-    \\endif\n+  \\if encoder\n+  - \\ref encoder reference\n+  \\endif\n+  \\if decoder\n+  - \\ref decoder reference\n+  \\endif\n \n   \\section main_support Support Options & FAQ\n   The WebM project is an open source project supported by its community. For\n""}<_**next**_>{""filename"": ""libvpx/md5_utils.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/md5_utils.c"", ""patch"": ""@@ -24,7 +24,7 @@\n\n \n #include \""md5_utils.h\""\n \n-void\n+static void\n byteSwap(UWORD32 *buf, unsigned words) {\n   md5byte *p;\n \n""}<_**next**_>{""filename"": ""libvpx/rate_hist.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/rate_hist.c"", ""patch"": ""@@ -88,6 +88,9 @@\n\n   if (now < cfg->rc_buf_initial_sz)\n     return;\n \n+  if (!cfg->rc_target_bitrate)\n+    return;\n+\n   then = now;\n \n   /* Sum the size over the past rc_buf_sz ms */\n""}<_**next**_>{""filename"": ""libvpx/solution.mk"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/solution.mk"", ""patch"": ""@@ -9,7 +9,7 @@\n\n ##\n \n # libvpx reverse dependencies (targets that depend on libvpx)\n-VPX_NONDEPS=$(addsuffix .$(VCPROJ_SFX),vpx gtest obj_int_extract)\n+VPX_NONDEPS=$(addsuffix .$(VCPROJ_SFX),vpx gtest)\n VPX_RDEPS=$(foreach vcp,\\\n               $(filter-out $(VPX_NONDEPS),$^), --dep=$(vcp:.$(VCPROJ_SFX)=):vpx)\n \n@@ -17,7 +17,6 @@\n\n \t@echo \""    [CREATE] $@\""\n \t$(SRC_PATH_BARE)/build/make/gen_msvs_sln.sh \\\n             $(if $(filter vpx.$(VCPROJ_SFX),$^),$(VPX_RDEPS)) \\\n-            --dep=vpx:obj_int_extract \\\n             --dep=test_libvpx:gtest \\\n             --ver=$(CONFIG_VS_VERSION)\\\n             --out=$@ $^\n""}<_**next**_>{""filename"": ""libvpx/test/acm_random.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/acm_random.h"", ""patch"": ""@@ -29,14 +29,14 @@\n\n   uint16_t Rand16(void) {\n     const uint32_t value =\n         random_.Generate(testing::internal::Random::kMaxRange);\n-    return (value >> 16) & 0xffff;\n+    return (value >> 15) & 0xffff;\n   }\n \n   uint8_t Rand8(void) {\n     const uint32_t value =\n         random_.Generate(testing::internal::Random::kMaxRange);\n     // There's a bit more entropy in the upper bits of this implementation.\n-    return (value >> 24) & 0xff;\n+    return (value >> 23) & 0xff;\n   }\n \n   uint8_t Rand8Extremes(void) {\n""}<_**next**_>{""filename"": ""libvpx/test/active_map_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/active_map_test.cc"", ""patch"": ""@@ -38,7 +38,7 @@\n\n     if (video->frame() == 1) {\n       encoder->Control(VP8E_SET_CPUUSED, cpu_used_);\n     } else if (video->frame() == 3) {\n-      vpx_active_map_t map = {0};\n+      vpx_active_map_t map = vpx_active_map_t();\n       uint8_t active_map[9 * 13] = {\n         1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n         1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n@@ -57,7 +57,7 @@\n\n       map.active_map = active_map;\n       encoder->Control(VP8E_SET_ACTIVEMAP, &map);\n     } else if (video->frame() == 15) {\n-      vpx_active_map_t map = {0};\n+      vpx_active_map_t map = vpx_active_map_t();\n       map.cols = (kWidth + 15) / 16;\n       map.rows = (kHeight + 15) / 16;\n       map.active_map = NULL;\n@@ -83,9 +83,6 @@\n\n   ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n }\n \n-#define VP9_FACTORY \\\n-  static_cast<const libvpx_test::CodecFactory *>(&libvpx_test::kVP9)\n-\n VP9_INSTANTIATE_TEST_CASE(ActiveMapTest,\n                           ::testing::Values(::libvpx_test::kRealTime),\n                           ::testing::Range(0, 6));\n""}<_**next**_>{""filename"": ""libvpx/test/android/Android.mk"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/android/Android.mk"", ""patch"": ""@@ -14,8 +14,14 @@\n\n BINDINGS_DIR := $(CUR_WD)/../../..\n LOCAL_PATH := $(CUR_WD)/../../..\n \n+#libwebm\n+include $(CLEAR_VARS)\n+include $(BINDINGS_DIR)/libvpx/third_party/libwebm/Android.mk\n+LOCAL_PATH := $(CUR_WD)/../../..\n+\n #libvpx\n include $(CLEAR_VARS)\n+LOCAL_STATIC_LIBRARIES := libwebm\n include $(BINDINGS_DIR)/libvpx/build/make/Android.mk\n LOCAL_PATH := $(CUR_WD)/../..\n \n@@ -33,10 +39,18 @@\n\n include $(CLEAR_VARS)\n LOCAL_ARM_MODE := arm\n LOCAL_MODULE := libvpx_test\n-LOCAL_STATIC_LIBRARIES := gtest\n-LOCAL_SHARED_LIBRARIES := vpx\n+LOCAL_STATIC_LIBRARIES := gtest libwebm\n+\n+ifeq ($(ENABLE_SHARED),1)\n+  LOCAL_SHARED_LIBRARIES := vpx\n+else\n+  LOCAL_STATIC_LIBRARIES += vpx\n+endif\n+\n include $(LOCAL_PATH)/test/test.mk\n LOCAL_C_INCLUDES := $(BINDINGS_DIR)\n FILTERED_SRC := $(sort $(filter %.cc %.c, $(LIBVPX_TEST_SRCS-yes)))\n LOCAL_SRC_FILES := $(addprefix ./test/, $(FILTERED_SRC))\n+# some test files depend on *_rtcd.h, ensure they're generated first.\n+$(eval $(call rtcd_dep_template))\n include $(BUILD_EXECUTABLE)\n""}<_**next**_>{""filename"": ""libvpx/test/android/README"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/android/README"", ""patch"": ""@@ -3,7 +3,7 @@\n\n ./libvpx/configure --target=armv7-android-gcc --enable-external-build \\\n   --enable-postproc --disable-install-srcs --enable-multi-res-encoding \\\n   --enable-temporal-denoising --disable-unit-tests --disable-install-docs \\\n-  --disable-examples --disable-runtime-cpu-detect --sdk=$NDK\n+  --disable-examples --disable-runtime-cpu-detect --sdk-path=$NDK\n \n 2) From the parent directory, invoke ndk-build:\n NDK_PROJECT_PATH=. ndk-build APP_BUILD_SCRIPT=./libvpx/test/android/Android.mk \\\n""}<_**next**_>{""filename"": ""libvpx/test/aq_segment_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/aq_segment_test.cc"", ""patch"": ""@@ -7,8 +7,6 @@\n\n  *  in the file PATENTS.  All contributing project authors may\n  *  be found in the AUTHORS file in the root of the source tree.\n  */\n-#include <climits>\n-#include <vector>\n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n #include \""test/codec_factory.h\""\n #include \""test/encode_test_driver.h\""\n@@ -17,11 +15,12 @@\n\n \n namespace {\n \n-class AqSegmentTest : public ::libvpx_test::EncoderTest,\n-    public ::libvpx_test::CodecTestWith2Params<\n-        libvpx_test::TestMode, int> {\n+class AqSegmentTest\n+    : public ::libvpx_test::EncoderTest,\n+      public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, int> {\n  protected:\n   AqSegmentTest() : EncoderTest(GET_PARAM(0)) {}\n+  virtual ~AqSegmentTest() {}\n \n   virtual void SetUp() {\n     InitializeConfig();\n@@ -39,10 +38,6 @@\n\n     }\n   }\n \n-  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n-    if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) {\n-    }\n-  }\n   int set_cpu_used_;\n   int aq_mode_;\n };\n@@ -107,13 +102,8 @@\n\n   ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n }\n \n-using std::tr1::make_tuple;\n-\n-#define VP9_FACTORY \\\n-  static_cast<const libvpx_test::CodecFactory*> (&libvpx_test::kVP9)\n-\n VP9_INSTANTIATE_TEST_CASE(AqSegmentTest,\n                           ::testing::Values(::libvpx_test::kRealTime,\n                                             ::libvpx_test::kOnePassGood),\n-                                            ::testing::Range(3, 9));\n+                          ::testing::Range(3, 9));\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/blockiness_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/blockiness_test.cc"", ""patch"": ""@@ -0,0 +1,229 @@\n\n+/*\n+ *  Copyright (c) 2012 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <limits.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vpx_config.h\""\n+#if CONFIG_VP9_ENCODER\n+#include \""./vp9_rtcd.h\""\n+#endif\n+\n+#include \""test/acm_random.h\""\n+#include \""test/clear_system_state.h\""\n+#include \""test/register_state_check.h\""\n+#include \""test/util.h\""\n+\n+#include \""vpx_mem/vpx_mem.h\""\n+\n+\n+extern \""C\""\n+double vp9_get_blockiness(const unsigned char *img1, int img1_pitch,\n+                          const unsigned char *img2, int img2_pitch,\n+                          int width, int height);\n+\n+using libvpx_test::ACMRandom;\n+\n+namespace {\n+class BlockinessTestBase : public ::testing::Test {\n+ public:\n+  BlockinessTestBase(int width, int height) : width_(width), height_(height) {}\n+\n+  static void SetUpTestCase() {\n+    source_data_ = reinterpret_cast<uint8_t*>(\n+        vpx_memalign(kDataAlignment, kDataBufferSize));\n+    reference_data_ = reinterpret_cast<uint8_t*>(\n+        vpx_memalign(kDataAlignment, kDataBufferSize));\n+  }\n+\n+  static void TearDownTestCase() {\n+    vpx_free(source_data_);\n+    source_data_ = NULL;\n+    vpx_free(reference_data_);\n+    reference_data_ = NULL;\n+  }\n+\n+  virtual void TearDown() {\n+    libvpx_test::ClearSystemState();\n+  }\n+\n+ protected:\n+  // Handle frames up to 640x480\n+  static const int kDataAlignment = 16;\n+  static const int kDataBufferSize = 640*480;\n+\n+  virtual void SetUp() {\n+    source_stride_ = (width_ + 31) & ~31;\n+    reference_stride_ = width_ * 2;\n+    rnd_.Reset(ACMRandom::DeterministicSeed());\n+  }\n+\n+  void FillConstant(uint8_t *data, int stride, uint8_t fill_constant,\n+                    int width, int height) {\n+    for (int h = 0; h < height; ++h) {\n+      for (int w = 0; w < width; ++w) {\n+        data[h * stride + w] = fill_constant;\n+      }\n+    }\n+  }\n+\n+  void FillConstant(uint8_t *data, int stride, uint8_t fill_constant) {\n+    FillConstant(data, stride, fill_constant, width_, height_);\n+  }\n+\n+  void FillRandom(uint8_t *data, int stride, int width, int height) {\n+    for (int h = 0; h < height; ++h) {\n+      for (int w = 0; w < width; ++w) {\n+        data[h * stride + w] = rnd_.Rand8();\n+      }\n+    }\n+  }\n+\n+  void FillRandom(uint8_t *data, int stride) {\n+    FillRandom(data, stride, width_, height_);\n+  }\n+\n+  void FillRandomBlocky(uint8_t *data, int stride) {\n+    for (int h = 0; h < height_; h += 4) {\n+      for (int w = 0; w < width_; w += 4) {\n+        FillRandom(data + h * stride + w, stride, 4, 4);\n+      }\n+    }\n+  }\n+\n+  void FillCheckerboard(uint8_t *data, int stride) {\n+    for (int h = 0; h < height_; h += 4) {\n+      for (int w = 0; w < width_; w += 4) {\n+        if (((h/4) ^ (w/4)) & 1)\n+          FillConstant(data + h * stride + w, stride, 255, 4, 4);\n+        else\n+          FillConstant(data + h * stride + w, stride, 0, 4, 4);\n+      }\n+    }\n+  }\n+\n+  void Blur(uint8_t *data, int stride, int taps) {\n+    int sum = 0;\n+    int half_taps = taps / 2;\n+    for (int h = 0; h < height_; ++h) {\n+      for (int w = 0; w < taps; ++w) {\n+        sum += data[w + h * stride];\n+      }\n+      for (int w = taps; w < width_; ++w) {\n+        sum += data[w + h * stride] - data[w - taps + h * stride];\n+        data[w - half_taps + h * stride] = (sum + half_taps) / taps;\n+      }\n+    }\n+    for (int w = 0; w < width_; ++w) {\n+      for (int h = 0; h < taps; ++h) {\n+        sum += data[h + w * stride];\n+      }\n+      for (int h = taps; h < height_; ++h) {\n+        sum += data[w + h * stride] - data[(h - taps) * stride + w];\n+        data[(h - half_taps) * stride + w] = (sum + half_taps) / taps;\n+      }\n+    }\n+  }\n+  int width_, height_;\n+  static uint8_t* source_data_;\n+  int source_stride_;\n+  static uint8_t* reference_data_;\n+  int reference_stride_;\n+\n+  ACMRandom rnd_;\n+};\n+\n+#if CONFIG_VP9_ENCODER\n+typedef std::tr1::tuple<int, int> BlockinessParam;\n+class BlockinessVP9Test\n+    : public BlockinessTestBase,\n+      public ::testing::WithParamInterface<BlockinessParam> {\n+ public:\n+  BlockinessVP9Test() : BlockinessTestBase(GET_PARAM(0), GET_PARAM(1)) {}\n+\n+ protected:\n+  int CheckBlockiness() {\n+    return vp9_get_blockiness(source_data_, source_stride_,\n+                              reference_data_, reference_stride_,\n+                              width_, height_);\n+  }\n+};\n+#endif  // CONFIG_VP9_ENCODER\n+\n+uint8_t* BlockinessTestBase::source_data_ = NULL;\n+uint8_t* BlockinessTestBase::reference_data_ = NULL;\n+\n+#if CONFIG_VP9_ENCODER\n+TEST_P(BlockinessVP9Test, SourceBlockierThanReference) {\n+  // Source is blockier than reference.\n+  FillRandomBlocky(source_data_, source_stride_);\n+  FillConstant(reference_data_, reference_stride_, 128);\n+  int super_blocky = CheckBlockiness();\n+\n+  EXPECT_EQ(0, super_blocky) << \""Blocky source should produce 0 blockiness.\"";\n+}\n+\n+TEST_P(BlockinessVP9Test, ReferenceBlockierThanSource) {\n+  // Source is blockier than reference.\n+  FillConstant(source_data_, source_stride_, 128);\n+  FillRandomBlocky(reference_data_, reference_stride_);\n+  int super_blocky = CheckBlockiness();\n+\n+  EXPECT_GT(super_blocky, 0.0)\n+      << \""Blocky reference should score high for blockiness.\"";\n+}\n+\n+TEST_P(BlockinessVP9Test, BlurringDecreasesBlockiness) {\n+  // Source is blockier than reference.\n+  FillConstant(source_data_, source_stride_, 128);\n+  FillRandomBlocky(reference_data_, reference_stride_);\n+  int super_blocky = CheckBlockiness();\n+\n+  Blur(reference_data_, reference_stride_, 4);\n+  int less_blocky = CheckBlockiness();\n+\n+  EXPECT_GT(super_blocky, less_blocky)\n+      << \""A straight blur should decrease blockiness.\"";\n+}\n+\n+TEST_P(BlockinessVP9Test, WorstCaseBlockiness) {\n+  // Source is blockier than reference.\n+  FillConstant(source_data_, source_stride_, 128);\n+  FillCheckerboard(reference_data_, reference_stride_);\n+\n+  int super_blocky = CheckBlockiness();\n+\n+  Blur(reference_data_, reference_stride_, 4);\n+  int less_blocky = CheckBlockiness();\n+\n+  EXPECT_GT(super_blocky, less_blocky)\n+      << \""A straight blur should decrease blockiness.\"";\n+}\n+#endif  // CONFIG_VP9_ENCODER\n+\n+\n+using std::tr1::make_tuple;\n+\n+//------------------------------------------------------------------------------\n+// C functions\n+\n+#if CONFIG_VP9_ENCODER\n+const BlockinessParam c_vp9_tests[] = {\n+  make_tuple(320, 240),\n+  make_tuple(318, 242),\n+  make_tuple(318, 238),\n+};\n+INSTANTIATE_TEST_CASE_P(C, BlockinessVP9Test, ::testing::ValuesIn(c_vp9_tests));\n+#endif\n+\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/borders_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/borders_test.cc"", ""patch"": ""@@ -80,4 +80,7 @@\n\n \n VP9_INSTANTIATE_TEST_CASE(BordersTest, ::testing::Values(\n     ::libvpx_test::kTwoPassGood));\n+\n+VP10_INSTANTIATE_TEST_CASE(BordersTest, ::testing::Values(\n+    ::libvpx_test::kTwoPassGood));\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/byte_alignment_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/byte_alignment_test.cc"", ""patch"": ""@@ -0,0 +1,189 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <string>\n+\n+#include \""./vpx_config.h\""\n+#include \""test/codec_factory.h\""\n+#include \""test/decode_test_driver.h\""\n+#include \""test/md5_helper.h\""\n+#include \""test/util.h\""\n+#if CONFIG_WEBM_IO\n+#include \""test/webm_video_source.h\""\n+#endif\n+\n+namespace {\n+\n+const int kLegacyByteAlignment = 0;\n+const int kLegacyYPlaneByteAlignment = 32;\n+const int kNumPlanesToCheck = 3;\n+const char kVP9TestFile[] = \""vp90-2-02-size-lf-1920x1080.webm\"";\n+const char kVP9Md5File[] = \""vp90-2-02-size-lf-1920x1080.webm.md5\"";\n+\n+#if CONFIG_WEBM_IO\n+\n+struct ByteAlignmentTestParam {\n+  int byte_alignment;\n+  vpx_codec_err_t expected_value;\n+  bool decode_remaining;\n+};\n+\n+const ByteAlignmentTestParam kBaTestParams[] = {\n+  {kLegacyByteAlignment, VPX_CODEC_OK, true},\n+  {32, VPX_CODEC_OK, true},\n+  {64, VPX_CODEC_OK, true},\n+  {128, VPX_CODEC_OK, true},\n+  {256, VPX_CODEC_OK, true},\n+  {512, VPX_CODEC_OK, true},\n+  {1024, VPX_CODEC_OK, true},\n+  {1, VPX_CODEC_INVALID_PARAM, false},\n+  {-2, VPX_CODEC_INVALID_PARAM, false},\n+  {4, VPX_CODEC_INVALID_PARAM, false},\n+  {16, VPX_CODEC_INVALID_PARAM, false},\n+  {255, VPX_CODEC_INVALID_PARAM, false},\n+  {2048, VPX_CODEC_INVALID_PARAM, false},\n+};\n+\n+// Class for testing byte alignment of reference buffers.\n+class ByteAlignmentTest\n+    : public ::testing::TestWithParam<ByteAlignmentTestParam> {\n+ protected:\n+  ByteAlignmentTest()\n+      : video_(NULL),\n+        decoder_(NULL),\n+        md5_file_(NULL) {}\n+\n+  virtual void SetUp() {\n+    video_ = new libvpx_test::WebMVideoSource(kVP9TestFile);\n+    ASSERT_TRUE(video_ != NULL);\n+    video_->Init();\n+    video_->Begin();\n+\n+    const vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n+    decoder_ = new libvpx_test::VP9Decoder(cfg, 0);\n+    ASSERT_TRUE(decoder_ != NULL);\n+\n+    OpenMd5File(kVP9Md5File);\n+  }\n+\n+  virtual void TearDown() {\n+    if (md5_file_ != NULL)\n+      fclose(md5_file_);\n+\n+    delete decoder_;\n+    delete video_;\n+  }\n+\n+  void SetByteAlignment(int byte_alignment, vpx_codec_err_t expected_value) {\n+    decoder_->Control(VP9_SET_BYTE_ALIGNMENT, byte_alignment, expected_value);\n+  }\n+\n+  vpx_codec_err_t DecodeOneFrame(int byte_alignment_to_check) {\n+    const vpx_codec_err_t res =\n+        decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());\n+    CheckDecodedFrames(byte_alignment_to_check);\n+    if (res == VPX_CODEC_OK)\n+      video_->Next();\n+    return res;\n+  }\n+\n+  vpx_codec_err_t DecodeRemainingFrames(int byte_alignment_to_check) {\n+    for (; video_->cxdata() != NULL; video_->Next()) {\n+      const vpx_codec_err_t res =\n+          decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());\n+      if (res != VPX_CODEC_OK)\n+        return res;\n+      CheckDecodedFrames(byte_alignment_to_check);\n+    }\n+    return VPX_CODEC_OK;\n+  }\n+\n+ private:\n+  // Check if |data| is aligned to |byte_alignment_to_check|.\n+  // |byte_alignment_to_check| must be a power of 2.\n+  void CheckByteAlignment(const uint8_t *data, int byte_alignment_to_check) {\n+    ASSERT_EQ(0u, reinterpret_cast<size_t>(data) % byte_alignment_to_check);\n+  }\n+\n+  // Iterate through the planes of the decoded frames and check for\n+  // alignment based off |byte_alignment_to_check|.\n+  void CheckDecodedFrames(int byte_alignment_to_check) {\n+    libvpx_test::DxDataIterator dec_iter = decoder_->GetDxData();\n+    const vpx_image_t *img;\n+\n+    // Get decompressed data\n+    while ((img = dec_iter.Next()) != NULL) {\n+      if (byte_alignment_to_check == kLegacyByteAlignment) {\n+        CheckByteAlignment(img->planes[0], kLegacyYPlaneByteAlignment);\n+      } else {\n+        for (int i = 0; i < kNumPlanesToCheck; ++i) {\n+          CheckByteAlignment(img->planes[i], byte_alignment_to_check);\n+        }\n+      }\n+      CheckMd5(*img);\n+    }\n+  }\n+\n+  // TODO(fgalligan): Move the MD5 testing code into another class.\n+  void OpenMd5File(const std::string &md5_file_name_) {\n+    md5_file_ = libvpx_test::OpenTestDataFile(md5_file_name_);\n+    ASSERT_TRUE(md5_file_ != NULL) << \""MD5 file open failed. Filename: \""\n+        << md5_file_name_;\n+  }\n+\n+  void CheckMd5(const vpx_image_t &img) {\n+    ASSERT_TRUE(md5_file_ != NULL);\n+    char expected_md5[33];\n+    char junk[128];\n+\n+    // Read correct md5 checksums.\n+    const int res = fscanf(md5_file_, \""%s  %s\"", expected_md5, junk);\n+    ASSERT_NE(EOF, res) << \""Read md5 data failed\"";\n+    expected_md5[32] = '\\0';\n+\n+    ::libvpx_test::MD5 md5_res;\n+    md5_res.Add(&img);\n+    const char *const actual_md5 = md5_res.Get();\n+\n+    // Check md5 match.\n+    ASSERT_STREQ(expected_md5, actual_md5) << \""MD5 checksums don't match\"";\n+  }\n+\n+  libvpx_test::WebMVideoSource *video_;\n+  libvpx_test::VP9Decoder *decoder_;\n+  FILE *md5_file_;\n+};\n+\n+TEST_F(ByteAlignmentTest, SwitchByteAlignment) {\n+  const int num_elements = 14;\n+  const int byte_alignments[] = { 0, 32, 64, 128, 256, 512, 1024,\n+                                  0, 1024, 32, 512, 64, 256, 128 };\n+\n+  for (int i = 0; i < num_elements; ++i) {\n+    SetByteAlignment(byte_alignments[i], VPX_CODEC_OK);\n+    ASSERT_EQ(VPX_CODEC_OK, DecodeOneFrame(byte_alignments[i]));\n+  }\n+  SetByteAlignment(byte_alignments[0], VPX_CODEC_OK);\n+  ASSERT_EQ(VPX_CODEC_OK, DecodeRemainingFrames(byte_alignments[0]));\n+}\n+\n+TEST_P(ByteAlignmentTest, TestAlignment) {\n+  const ByteAlignmentTestParam t = GetParam();\n+  SetByteAlignment(t.byte_alignment, t.expected_value);\n+  if (t.decode_remaining)\n+    ASSERT_EQ(VPX_CODEC_OK, DecodeRemainingFrames(t.byte_alignment));\n+}\n+\n+INSTANTIATE_TEST_CASE_P(Alignments, ByteAlignmentTest,\n+                        ::testing::ValuesIn(kBaTestParams));\n+\n+#endif  // CONFIG_WEBM_IO\n+\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/codec_factory.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/codec_factory.h"", ""patch"": ""@@ -13,10 +13,10 @@\n\n #include \""./vpx_config.h\""\n #include \""vpx/vpx_decoder.h\""\n #include \""vpx/vpx_encoder.h\""\n-#if CONFIG_VP8_ENCODER || CONFIG_VP9_ENCODER\n+#if CONFIG_VP8_ENCODER || CONFIG_VP9_ENCODER || CONFIG_VP10_ENCODER\n #include \""vpx/vp8cx.h\""\n #endif\n-#if CONFIG_VP8_DECODER || CONFIG_VP9_DECODER\n+#if CONFIG_VP8_DECODER || CONFIG_VP9_DECODER || CONFIG_VP10_DECODER\n #include \""vpx/vp8dx.h\""\n #endif\n \n@@ -35,6 +35,11 @@\n\n   virtual Decoder* CreateDecoder(vpx_codec_dec_cfg_t cfg,\n                                  unsigned long deadline) const = 0;\n \n+  virtual Decoder* CreateDecoder(vpx_codec_dec_cfg_t cfg,\n+                                 const vpx_codec_flags_t flags,\n+                                 unsigned long deadline)  // NOLINT(runtime/int)\n+                                 const = 0;\n+\n   virtual Encoder* CreateEncoder(vpx_codec_enc_cfg_t cfg,\n                                  unsigned long deadline,\n                                  const unsigned long init_flags,\n@@ -72,6 +77,10 @@\n\n   VP8Decoder(vpx_codec_dec_cfg_t cfg, unsigned long deadline)\n       : Decoder(cfg, deadline) {}\n \n+  VP8Decoder(vpx_codec_dec_cfg_t cfg, const vpx_codec_flags_t flag,\n+             unsigned long deadline)  // NOLINT\n+      : Decoder(cfg, flag, deadline) {}\n+\n  protected:\n   virtual vpx_codec_iface_t* CodecInterface() const {\n #if CONFIG_VP8_DECODER\n@@ -104,8 +113,14 @@\n\n \n   virtual Decoder* CreateDecoder(vpx_codec_dec_cfg_t cfg,\n                                  unsigned long deadline) const {\n+    return CreateDecoder(cfg, 0, deadline);\n+  }\n+\n+  virtual Decoder* CreateDecoder(vpx_codec_dec_cfg_t cfg,\n+                                 const vpx_codec_flags_t flags,\n+                                 unsigned long deadline) const {  // NOLINT\n #if CONFIG_VP8_DECODER\n-    return new VP8Decoder(cfg, deadline);\n+    return new VP8Decoder(cfg, flags, deadline);\n #else\n     return NULL;\n #endif\n@@ -154,6 +169,10 @@\n\n   VP9Decoder(vpx_codec_dec_cfg_t cfg, unsigned long deadline)\n       : Decoder(cfg, deadline) {}\n \n+  VP9Decoder(vpx_codec_dec_cfg_t cfg, const vpx_codec_flags_t flag,\n+             unsigned long deadline)  // NOLINT\n+      : Decoder(cfg, flag, deadline) {}\n+\n  protected:\n   virtual vpx_codec_iface_t* CodecInterface() const {\n #if CONFIG_VP9_DECODER\n@@ -186,8 +205,14 @@\n\n \n   virtual Decoder* CreateDecoder(vpx_codec_dec_cfg_t cfg,\n                                  unsigned long deadline) const {\n+    return CreateDecoder(cfg, 0, deadline);\n+  }\n+\n+  virtual Decoder* CreateDecoder(vpx_codec_dec_cfg_t cfg,\n+                                 const vpx_codec_flags_t flags,\n+                                 unsigned long deadline) const {  // NOLINT\n #if CONFIG_VP9_DECODER\n-    return new VP9Decoder(cfg, deadline);\n+    return new VP9Decoder(cfg, flags, deadline);\n #else\n     return NULL;\n #endif\n@@ -208,6 +233,8 @@\n\n                                                int usage) const {\n #if CONFIG_VP9_ENCODER\n     return vpx_codec_enc_config_default(&vpx_codec_vp9_cx_algo, cfg, usage);\n+#elif CONFIG_VP10_ENCODER\n+    return vpx_codec_enc_config_default(&vpx_codec_vp10_cx_algo, cfg, usage);\n #else\n     return VPX_CODEC_INCAPABLE;\n #endif\n@@ -226,7 +253,96 @@\n\n #define VP9_INSTANTIATE_TEST_CASE(test, ...)\n #endif  // CONFIG_VP9\n \n+/*\n+ * VP10 Codec Definitions\n+ */\n+#if CONFIG_VP10\n+class VP10Decoder : public Decoder {\n+ public:\n+  VP10Decoder(vpx_codec_dec_cfg_t cfg, unsigned long deadline)\n+      : Decoder(cfg, deadline) {}\n+\n+  VP10Decoder(vpx_codec_dec_cfg_t cfg, const vpx_codec_flags_t flag,\n+              unsigned long deadline)  // NOLINT\n+      : Decoder(cfg, flag, deadline) {}\n+\n+ protected:\n+  virtual vpx_codec_iface_t* CodecInterface() const {\n+#if CONFIG_VP10_DECODER\n+    return &vpx_codec_vp10_dx_algo;\n+#else\n+    return NULL;\n+#endif\n+  }\n+};\n+\n+class VP10Encoder : public Encoder {\n+ public:\n+  VP10Encoder(vpx_codec_enc_cfg_t cfg, unsigned long deadline,\n+              const unsigned long init_flags, TwopassStatsStore *stats)\n+      : Encoder(cfg, deadline, init_flags, stats) {}\n+\n+ protected:\n+  virtual vpx_codec_iface_t* CodecInterface() const {\n+#if CONFIG_VP10_ENCODER\n+    return &vpx_codec_vp10_cx_algo;\n+#else\n+    return NULL;\n+#endif\n+  }\n+};\n+\n+class VP10CodecFactory : public CodecFactory {\n+ public:\n+  VP10CodecFactory() : CodecFactory() {}\n+\n+  virtual Decoder* CreateDecoder(vpx_codec_dec_cfg_t cfg,\n+                                 unsigned long deadline) const {\n+    return CreateDecoder(cfg, 0, deadline);\n+  }\n+\n+  virtual Decoder* CreateDecoder(vpx_codec_dec_cfg_t cfg,\n+                                 const vpx_codec_flags_t flags,\n+                                 unsigned long deadline) const {  // NOLINT\n+#if CONFIG_VP10_DECODER\n+    return new VP10Decoder(cfg, flags, deadline);\n+#else\n+    return NULL;\n+#endif\n+  }\n+\n+  virtual Encoder* CreateEncoder(vpx_codec_enc_cfg_t cfg,\n+                                 unsigned long deadline,\n+                                 const unsigned long init_flags,\n+                                 TwopassStatsStore *stats) const {\n+#if CONFIG_VP10_ENCODER\n+    return new VP10Encoder(cfg, deadline, init_flags, stats);\n+#else\n+    return NULL;\n+#endif\n+  }\n+\n+  virtual vpx_codec_err_t DefaultEncoderConfig(vpx_codec_enc_cfg_t *cfg,\n+                                               int usage) const {\n+#if CONFIG_VP10_ENCODER\n+    return vpx_codec_enc_config_default(&vpx_codec_vp10_cx_algo, cfg, usage);\n+#else\n+    return VPX_CODEC_INCAPABLE;\n+#endif\n+  }\n+};\n+\n+const libvpx_test::VP10CodecFactory kVP10;\n+\n+#define VP10_INSTANTIATE_TEST_CASE(test, ...)\\\n+  INSTANTIATE_TEST_CASE_P(VP10, test, \\\n+      ::testing::Combine( \\\n+          ::testing::Values(static_cast<const libvpx_test::CodecFactory*>( \\\n+               &libvpx_test::kVP10)), \\\n+          __VA_ARGS__))\n+#else\n+#define VP10_INSTANTIATE_TEST_CASE(test, ...)\n+#endif  // CONFIG_VP10\n \n }  // namespace libvpx_test\n-\n #endif  // TEST_CODEC_FACTORY_H_\n""}<_**next**_>{""filename"": ""libvpx/test/consistency_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/consistency_test.cc"", ""patch"": ""@@ -0,0 +1,224 @@\n\n+/*\n+ *  Copyright (c) 2012 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <limits.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vpx_config.h\""\n+#if CONFIG_VP9_ENCODER\n+#include \""./vp9_rtcd.h\""\n+#endif\n+\n+#include \""test/acm_random.h\""\n+#include \""test/clear_system_state.h\""\n+#include \""test/register_state_check.h\""\n+#include \""test/util.h\""\n+#include \""vpx_dsp/ssim.h\""\n+#include \""vpx_mem/vpx_mem.h\""\n+\n+extern \""C\""\n+double vpx_get_ssim_metrics(uint8_t *img1, int img1_pitch,\n+                            uint8_t *img2, int img2_pitch,\n+                            int width, int height,\n+                            Ssimv *sv2, Metrics *m,\n+                            int do_inconsistency);\n+\n+using libvpx_test::ACMRandom;\n+\n+namespace {\n+class ConsistencyTestBase : public ::testing::Test {\n+ public:\n+  ConsistencyTestBase(int width, int height) : width_(width), height_(height) {}\n+\n+  static void SetUpTestCase() {\n+    source_data_[0] = reinterpret_cast<uint8_t*>(\n+        vpx_memalign(kDataAlignment, kDataBufferSize));\n+    reference_data_[0] = reinterpret_cast<uint8_t*>(\n+        vpx_memalign(kDataAlignment, kDataBufferSize));\n+    source_data_[1] = reinterpret_cast<uint8_t*>(\n+        vpx_memalign(kDataAlignment, kDataBufferSize));\n+    reference_data_[1] = reinterpret_cast<uint8_t*>(\n+        vpx_memalign(kDataAlignment, kDataBufferSize));\n+    ssim_array_ = new Ssimv[kDataBufferSize / 16];\n+  }\n+\n+  static void ClearSsim() {\n+    memset(ssim_array_, 0, kDataBufferSize / 16);\n+  }\n+  static void TearDownTestCase() {\n+    vpx_free(source_data_[0]);\n+    source_data_[0] = NULL;\n+    vpx_free(reference_data_[0]);\n+    reference_data_[0] = NULL;\n+    vpx_free(source_data_[1]);\n+    source_data_[1] = NULL;\n+    vpx_free(reference_data_[1]);\n+    reference_data_[1] = NULL;\n+\n+    delete[] ssim_array_;\n+  }\n+\n+  virtual void TearDown() {\n+    libvpx_test::ClearSystemState();\n+  }\n+\n+ protected:\n+  // Handle frames up to 640x480\n+  static const int kDataAlignment = 16;\n+  static const int kDataBufferSize = 640*480;\n+\n+  virtual void SetUp() {\n+    source_stride_ = (width_ + 31) & ~31;\n+    reference_stride_ = width_ * 2;\n+    rnd_.Reset(ACMRandom::DeterministicSeed());\n+  }\n+\n+  void FillRandom(uint8_t *data, int stride, int width, int height) {\n+    for (int h = 0; h < height; ++h) {\n+      for (int w = 0; w < width; ++w) {\n+        data[h * stride + w] = rnd_.Rand8();\n+      }\n+    }\n+  }\n+\n+  void FillRandom(uint8_t *data, int stride) {\n+    FillRandom(data, stride, width_, height_);\n+  }\n+\n+  void Copy(uint8_t *reference, uint8_t *source) {\n+    memcpy(reference, source, kDataBufferSize);\n+  }\n+\n+  void Blur(uint8_t *data, int stride, int taps) {\n+    int sum = 0;\n+    int half_taps = taps / 2;\n+    for (int h = 0; h < height_; ++h) {\n+      for (int w = 0; w < taps; ++w) {\n+        sum += data[w + h * stride];\n+      }\n+      for (int w = taps; w < width_; ++w) {\n+        sum += data[w + h * stride] - data[w - taps + h * stride];\n+        data[w - half_taps + h * stride] = (sum + half_taps) / taps;\n+      }\n+    }\n+    for (int w = 0; w < width_; ++w) {\n+      for (int h = 0; h < taps; ++h) {\n+        sum += data[h + w * stride];\n+      }\n+      for (int h = taps; h < height_; ++h) {\n+        sum += data[w + h * stride] - data[(h - taps) * stride + w];\n+        data[(h - half_taps) * stride + w] = (sum + half_taps) / taps;\n+      }\n+    }\n+  }\n+  int width_, height_;\n+  static uint8_t* source_data_[2];\n+  int source_stride_;\n+  static uint8_t* reference_data_[2];\n+  int reference_stride_;\n+  static Ssimv *ssim_array_;\n+  Metrics metrics_;\n+\n+  ACMRandom rnd_;\n+};\n+\n+#if CONFIG_VP9_ENCODER\n+typedef std::tr1::tuple<int, int> ConsistencyParam;\n+class ConsistencyVP9Test\n+    : public ConsistencyTestBase,\n+      public ::testing::WithParamInterface<ConsistencyParam> {\n+ public:\n+  ConsistencyVP9Test() : ConsistencyTestBase(GET_PARAM(0), GET_PARAM(1)) {}\n+\n+ protected:\n+  double CheckConsistency(int frame) {\n+    EXPECT_LT(frame, 2)<< \""Frame to check has to be less than 2.\"";\n+    return\n+        vpx_get_ssim_metrics(source_data_[frame], source_stride_,\n+                             reference_data_[frame], reference_stride_,\n+                             width_, height_, ssim_array_, &metrics_, 1);\n+  }\n+};\n+#endif  // CONFIG_VP9_ENCODER\n+\n+uint8_t* ConsistencyTestBase::source_data_[2] = {NULL, NULL};\n+uint8_t* ConsistencyTestBase::reference_data_[2] = {NULL, NULL};\n+Ssimv* ConsistencyTestBase::ssim_array_ = NULL;\n+\n+#if CONFIG_VP9_ENCODER\n+TEST_P(ConsistencyVP9Test, ConsistencyIsZero) {\n+  FillRandom(source_data_[0], source_stride_);\n+  Copy(source_data_[1], source_data_[0]);\n+  Copy(reference_data_[0], source_data_[0]);\n+  Blur(reference_data_[0], reference_stride_, 3);\n+  Copy(reference_data_[1], source_data_[0]);\n+  Blur(reference_data_[1], reference_stride_, 3);\n+\n+  double inconsistency = CheckConsistency(1);\n+  inconsistency = CheckConsistency(0);\n+  EXPECT_EQ(inconsistency, 0.0)\n+      << \""Should have 0 inconsistency if they are exactly the same.\"";\n+\n+  // If sources are not consistent reference frames inconsistency should\n+  // be less than if the source is consistent.\n+  FillRandom(source_data_[0], source_stride_);\n+  FillRandom(source_data_[1], source_stride_);\n+  FillRandom(reference_data_[0], reference_stride_);\n+  FillRandom(reference_data_[1], reference_stride_);\n+  CheckConsistency(0);\n+  inconsistency = CheckConsistency(1);\n+\n+  Copy(source_data_[1], source_data_[0]);\n+  CheckConsistency(0);\n+  double inconsistency2 = CheckConsistency(1);\n+  EXPECT_LT(inconsistency, inconsistency2)\n+      << \""Should have less inconsistency if source itself is inconsistent.\"";\n+\n+  // Less of a blur should be less inconsistent than more blur coming off a\n+  // a frame with no blur.\n+  ClearSsim();\n+  FillRandom(source_data_[0], source_stride_);\n+  Copy(source_data_[1], source_data_[0]);\n+  Copy(reference_data_[0], source_data_[0]);\n+  Copy(reference_data_[1], source_data_[0]);\n+  Blur(reference_data_[1], reference_stride_, 4);\n+  CheckConsistency(0);\n+  inconsistency = CheckConsistency(1);\n+  ClearSsim();\n+  Copy(reference_data_[1], source_data_[0]);\n+  Blur(reference_data_[1], reference_stride_, 8);\n+  CheckConsistency(0);\n+  inconsistency2 = CheckConsistency(1);\n+\n+  EXPECT_LT(inconsistency, inconsistency2)\n+      << \""Stronger Blur should produce more inconsistency.\"";\n+}\n+#endif  // CONFIG_VP9_ENCODER\n+\n+\n+using std::tr1::make_tuple;\n+\n+//------------------------------------------------------------------------------\n+// C functions\n+\n+#if CONFIG_VP9_ENCODER\n+const ConsistencyParam c_vp9_tests[] = {\n+  make_tuple(320, 240),\n+  make_tuple(318, 242),\n+  make_tuple(318, 238),\n+};\n+INSTANTIATE_TEST_CASE_P(C, ConsistencyVP9Test,\n+                        ::testing::ValuesIn(c_vp9_tests));\n+#endif\n+\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/convolve_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/convolve_test.cc"", ""patch"": ""@@ -9,40 +9,65 @@\n\n  */\n \n #include <string.h>\n-#include \""test/acm_random.h\""\n-#include \""test/register_state_check.h\""\n-#include \""test/util.h\""\n+\n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n \n #include \""./vpx_config.h\""\n #include \""./vp9_rtcd.h\""\n+#include \""./vpx_dsp_rtcd.h\""\n+#include \""test/acm_random.h\""\n+#include \""test/clear_system_state.h\""\n+#include \""test/register_state_check.h\""\n+#include \""test/util.h\""\n+#include \""vp9/common/vp9_common.h\""\n #include \""vp9/common/vp9_filter.h\""\n+#include \""vpx_dsp/vpx_dsp_common.h\""\n+#include \""vpx_dsp/vpx_filter.h\""\n #include \""vpx_mem/vpx_mem.h\""\n #include \""vpx_ports/mem.h\""\n \n namespace {\n-typedef void (*convolve_fn_t)(const uint8_t *src, ptrdiff_t src_stride,\n-                              uint8_t *dst, ptrdiff_t dst_stride,\n-                              const int16_t *filter_x, int filter_x_stride,\n-                              const int16_t *filter_y, int filter_y_stride,\n-                              int w, int h);\n+\n+static const unsigned int kMaxDimension = 64;\n+\n+typedef void (*ConvolveFunc)(const uint8_t *src, ptrdiff_t src_stride,\n+                             uint8_t *dst, ptrdiff_t dst_stride,\n+                             const int16_t *filter_x, int filter_x_stride,\n+                             const int16_t *filter_y, int filter_y_stride,\n+                             int w, int h);\n \n struct ConvolveFunctions {\n-  ConvolveFunctions(convolve_fn_t h8, convolve_fn_t h8_avg,\n-                    convolve_fn_t v8, convolve_fn_t v8_avg,\n-                    convolve_fn_t hv8, convolve_fn_t hv8_avg)\n-      : h8_(h8), v8_(v8), hv8_(hv8), h8_avg_(h8_avg), v8_avg_(v8_avg),\n-        hv8_avg_(hv8_avg) {}\n+  ConvolveFunctions(ConvolveFunc copy, ConvolveFunc avg,\n+                    ConvolveFunc h8, ConvolveFunc h8_avg,\n+                    ConvolveFunc v8, ConvolveFunc v8_avg,\n+                    ConvolveFunc hv8, ConvolveFunc hv8_avg,\n+                    ConvolveFunc sh8, ConvolveFunc sh8_avg,\n+                    ConvolveFunc sv8, ConvolveFunc sv8_avg,\n+                    ConvolveFunc shv8, ConvolveFunc shv8_avg,\n+                    int bd)\n+      : copy_(copy), avg_(avg), h8_(h8), v8_(v8), hv8_(hv8), h8_avg_(h8_avg),\n+        v8_avg_(v8_avg), hv8_avg_(hv8_avg), sh8_(sh8), sv8_(sv8), shv8_(shv8),\n+        sh8_avg_(sh8_avg), sv8_avg_(sv8_avg), shv8_avg_(shv8_avg),\n+        use_highbd_(bd) {}\n \n-  convolve_fn_t h8_;\n-  convolve_fn_t v8_;\n-  convolve_fn_t hv8_;\n-  convolve_fn_t h8_avg_;\n-  convolve_fn_t v8_avg_;\n-  convolve_fn_t hv8_avg_;\n+  ConvolveFunc copy_;\n+  ConvolveFunc avg_;\n+  ConvolveFunc h8_;\n+  ConvolveFunc v8_;\n+  ConvolveFunc hv8_;\n+  ConvolveFunc h8_avg_;\n+  ConvolveFunc v8_avg_;\n+  ConvolveFunc hv8_avg_;\n+  ConvolveFunc sh8_;        // scaled horiz\n+  ConvolveFunc sv8_;        // scaled vert\n+  ConvolveFunc shv8_;       // scaled horiz/vert\n+  ConvolveFunc sh8_avg_;    // scaled avg horiz\n+  ConvolveFunc sv8_avg_;    // scaled avg vert\n+  ConvolveFunc shv8_avg_;   // scaled avg horiz/vert\n+  int use_highbd_;  // 0 if high bitdepth not used, else the actual bit depth.\n };\n \n-typedef std::tr1::tuple<int, int, const ConvolveFunctions*> convolve_param_t;\n+typedef std::tr1::tuple<int, int, const ConvolveFunctions *> ConvolveParam;\n \n // Reference 8-tap subpixel filter, slightly modified to fit into this test.\n #define VP9_FILTER_WEIGHT 128\n@@ -68,71 +93,66 @@\n\n   const int kInterp_Extend = 4;\n   const unsigned int intermediate_height =\n       (kInterp_Extend - 1) + output_height + kInterp_Extend;\n+  unsigned int i, j;\n \n-  /* Size of intermediate_buffer is max_intermediate_height * filter_max_width,\n-   * where max_intermediate_height = (kInterp_Extend - 1) + filter_max_height\n-   *                                 + kInterp_Extend\n-   *                               = 3 + 16 + 4\n-   *                               = 23\n-   * and filter_max_width = 16\n-   */\n-  uint8_t intermediate_buffer[71 * 64];\n+  // Size of intermediate_buffer is max_intermediate_height * filter_max_width,\n+  // where max_intermediate_height = (kInterp_Extend - 1) + filter_max_height\n+  //                                 + kInterp_Extend\n+  //                               = 3 + 16 + 4\n+  //                               = 23\n+  // and filter_max_width          = 16\n+  //\n+  uint8_t intermediate_buffer[71 * kMaxDimension];\n   const int intermediate_next_stride = 1 - intermediate_height * output_width;\n \n   // Horizontal pass (src -> transposed intermediate).\n-  {\n-    uint8_t *output_ptr = intermediate_buffer;\n-    const int src_next_row_stride = src_stride - output_width;\n-    unsigned int i, j;\n-    src_ptr -= (kInterp_Extend - 1) * src_stride + (kInterp_Extend - 1);\n-    for (i = 0; i < intermediate_height; ++i) {\n-      for (j = 0; j < output_width; ++j) {\n-        // Apply filter...\n-        const int temp = (src_ptr[0] * HFilter[0]) +\n-                         (src_ptr[1] * HFilter[1]) +\n-                         (src_ptr[2] * HFilter[2]) +\n-                         (src_ptr[3] * HFilter[3]) +\n-                         (src_ptr[4] * HFilter[4]) +\n-                         (src_ptr[5] * HFilter[5]) +\n-                         (src_ptr[6] * HFilter[6]) +\n-                         (src_ptr[7] * HFilter[7]) +\n-                         (VP9_FILTER_WEIGHT >> 1);  // Rounding\n+  uint8_t *output_ptr = intermediate_buffer;\n+  const int src_next_row_stride = src_stride - output_width;\n+  src_ptr -= (kInterp_Extend - 1) * src_stride + (kInterp_Extend - 1);\n+  for (i = 0; i < intermediate_height; ++i) {\n+    for (j = 0; j < output_width; ++j) {\n+      // Apply filter...\n+      const int temp = (src_ptr[0] * HFilter[0]) +\n+          (src_ptr[1] * HFilter[1]) +\n+          (src_ptr[2] * HFilter[2]) +\n+          (src_ptr[3] * HFilter[3]) +\n+          (src_ptr[4] * HFilter[4]) +\n+          (src_ptr[5] * HFilter[5]) +\n+          (src_ptr[6] * HFilter[6]) +\n+          (src_ptr[7] * HFilter[7]) +\n+          (VP9_FILTER_WEIGHT >> 1);  // Rounding\n \n-        // Normalize back to 0-255...\n-        *output_ptr = clip_pixel(temp >> VP9_FILTER_SHIFT);\n-        ++src_ptr;\n-        output_ptr += intermediate_height;\n-      }\n-      src_ptr += src_next_row_stride;\n-      output_ptr += intermediate_next_stride;\n+      // Normalize back to 0-255...\n+      *output_ptr = clip_pixel(temp >> VP9_FILTER_SHIFT);\n+      ++src_ptr;\n+      output_ptr += intermediate_height;\n     }\n+    src_ptr += src_next_row_stride;\n+    output_ptr += intermediate_next_stride;\n   }\n \n   // Vertical pass (transposed intermediate -> dst).\n-  {\n-    uint8_t *src_ptr = intermediate_buffer;\n-    const int dst_next_row_stride = dst_stride - output_width;\n-    unsigned int i, j;\n-    for (i = 0; i < output_height; ++i) {\n-      for (j = 0; j < output_width; ++j) {\n-        // Apply filter...\n-        const int temp = (src_ptr[0] * VFilter[0]) +\n-                         (src_ptr[1] * VFilter[1]) +\n-                         (src_ptr[2] * VFilter[2]) +\n-                         (src_ptr[3] * VFilter[3]) +\n-                         (src_ptr[4] * VFilter[4]) +\n-                         (src_ptr[5] * VFilter[5]) +\n-                         (src_ptr[6] * VFilter[6]) +\n-                         (src_ptr[7] * VFilter[7]) +\n-                         (VP9_FILTER_WEIGHT >> 1);  // Rounding\n+  src_ptr = intermediate_buffer;\n+  const int dst_next_row_stride = dst_stride - output_width;\n+  for (i = 0; i < output_height; ++i) {\n+    for (j = 0; j < output_width; ++j) {\n+      // Apply filter...\n+      const int temp = (src_ptr[0] * VFilter[0]) +\n+          (src_ptr[1] * VFilter[1]) +\n+          (src_ptr[2] * VFilter[2]) +\n+          (src_ptr[3] * VFilter[3]) +\n+          (src_ptr[4] * VFilter[4]) +\n+          (src_ptr[5] * VFilter[5]) +\n+          (src_ptr[6] * VFilter[6]) +\n+          (src_ptr[7] * VFilter[7]) +\n+          (VP9_FILTER_WEIGHT >> 1);  // Rounding\n \n-        // Normalize back to 0-255...\n-        *dst_ptr++ = clip_pixel(temp >> VP9_FILTER_SHIFT);\n-        src_ptr += intermediate_height;\n-      }\n-      src_ptr += intermediate_next_stride;\n-      dst_ptr += dst_next_row_stride;\n+      // Normalize back to 0-255...\n+      *dst_ptr++ = clip_pixel(temp >> VP9_FILTER_SHIFT);\n+      src_ptr += intermediate_height;\n     }\n+    src_ptr += intermediate_next_stride;\n+    dst_ptr += dst_next_row_stride;\n   }\n }\n \n@@ -159,17 +179,138 @@\n\n                                 unsigned int dst_stride,\n                                 unsigned int output_width,\n                                 unsigned int output_height) {\n-  uint8_t tmp[64 * 64];\n+  uint8_t tmp[kMaxDimension * kMaxDimension];\n \n-  assert(output_width <= 64);\n-  assert(output_height <= 64);\n+  assert(output_width <= kMaxDimension);\n+  assert(output_height <= kMaxDimension);\n   filter_block2d_8_c(src_ptr, src_stride, HFilter, VFilter, tmp, 64,\n                      output_width, output_height);\n   block2d_average_c(tmp, 64, dst_ptr, dst_stride,\n                     output_width, output_height);\n }\n \n-class ConvolveTest : public ::testing::TestWithParam<convolve_param_t> {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+void highbd_filter_block2d_8_c(const uint16_t *src_ptr,\n+                               const unsigned int src_stride,\n+                               const int16_t *HFilter,\n+                               const int16_t *VFilter,\n+                               uint16_t *dst_ptr,\n+                               unsigned int dst_stride,\n+                               unsigned int output_width,\n+                               unsigned int output_height,\n+                               int bd) {\n+  // Between passes, we use an intermediate buffer whose height is extended to\n+  // have enough horizontally filtered values as input for the vertical pass.\n+  // This buffer is allocated to be big enough for the largest block type we\n+  // support.\n+  const int kInterp_Extend = 4;\n+  const unsigned int intermediate_height =\n+      (kInterp_Extend - 1) + output_height + kInterp_Extend;\n+\n+  /* Size of intermediate_buffer is max_intermediate_height * filter_max_width,\n+   * where max_intermediate_height = (kInterp_Extend - 1) + filter_max_height\n+   *                                 + kInterp_Extend\n+   *                               = 3 + 16 + 4\n+   *                               = 23\n+   * and filter_max_width = 16\n+   */\n+  uint16_t intermediate_buffer[71 * kMaxDimension];\n+  const int intermediate_next_stride = 1 - intermediate_height * output_width;\n+\n+  // Horizontal pass (src -> transposed intermediate).\n+  {\n+    uint16_t *output_ptr = intermediate_buffer;\n+    const int src_next_row_stride = src_stride - output_width;\n+    unsigned int i, j;\n+    src_ptr -= (kInterp_Extend - 1) * src_stride + (kInterp_Extend - 1);\n+    for (i = 0; i < intermediate_height; ++i) {\n+      for (j = 0; j < output_width; ++j) {\n+        // Apply filter...\n+        const int temp = (src_ptr[0] * HFilter[0]) +\n+                         (src_ptr[1] * HFilter[1]) +\n+                         (src_ptr[2] * HFilter[2]) +\n+                         (src_ptr[3] * HFilter[3]) +\n+                         (src_ptr[4] * HFilter[4]) +\n+                         (src_ptr[5] * HFilter[5]) +\n+                         (src_ptr[6] * HFilter[6]) +\n+                         (src_ptr[7] * HFilter[7]) +\n+                         (VP9_FILTER_WEIGHT >> 1);  // Rounding\n+\n+        // Normalize back to 0-255...\n+        *output_ptr = clip_pixel_highbd(temp >> VP9_FILTER_SHIFT, bd);\n+        ++src_ptr;\n+        output_ptr += intermediate_height;\n+      }\n+      src_ptr += src_next_row_stride;\n+      output_ptr += intermediate_next_stride;\n+    }\n+  }\n+\n+  // Vertical pass (transposed intermediate -> dst).\n+  {\n+    uint16_t *src_ptr = intermediate_buffer;\n+    const int dst_next_row_stride = dst_stride - output_width;\n+    unsigned int i, j;\n+    for (i = 0; i < output_height; ++i) {\n+      for (j = 0; j < output_width; ++j) {\n+        // Apply filter...\n+        const int temp = (src_ptr[0] * VFilter[0]) +\n+                         (src_ptr[1] * VFilter[1]) +\n+                         (src_ptr[2] * VFilter[2]) +\n+                         (src_ptr[3] * VFilter[3]) +\n+                         (src_ptr[4] * VFilter[4]) +\n+                         (src_ptr[5] * VFilter[5]) +\n+                         (src_ptr[6] * VFilter[6]) +\n+                         (src_ptr[7] * VFilter[7]) +\n+                         (VP9_FILTER_WEIGHT >> 1);  // Rounding\n+\n+        // Normalize back to 0-255...\n+        *dst_ptr++ = clip_pixel_highbd(temp >> VP9_FILTER_SHIFT, bd);\n+        src_ptr += intermediate_height;\n+      }\n+      src_ptr += intermediate_next_stride;\n+      dst_ptr += dst_next_row_stride;\n+    }\n+  }\n+}\n+\n+void highbd_block2d_average_c(uint16_t *src,\n+                              unsigned int src_stride,\n+                              uint16_t *output_ptr,\n+                              unsigned int output_stride,\n+                              unsigned int output_width,\n+                              unsigned int output_height,\n+                              int bd) {\n+  unsigned int i, j;\n+  for (i = 0; i < output_height; ++i) {\n+    for (j = 0; j < output_width; ++j) {\n+      output_ptr[j] = (output_ptr[j] + src[i * src_stride + j] + 1) >> 1;\n+    }\n+    output_ptr += output_stride;\n+  }\n+}\n+\n+void highbd_filter_average_block2d_8_c(const uint16_t *src_ptr,\n+                                       const unsigned int src_stride,\n+                                       const int16_t *HFilter,\n+                                       const int16_t *VFilter,\n+                                       uint16_t *dst_ptr,\n+                                       unsigned int dst_stride,\n+                                       unsigned int output_width,\n+                                       unsigned int output_height,\n+                                       int bd) {\n+  uint16_t tmp[kMaxDimension * kMaxDimension];\n+\n+  assert(output_width <= kMaxDimension);\n+  assert(output_height <= kMaxDimension);\n+  highbd_filter_block2d_8_c(src_ptr, src_stride, HFilter, VFilter, tmp, 64,\n+                            output_width, output_height, bd);\n+  highbd_block2d_average_c(tmp, 64, dst_ptr, dst_stride,\n+                           output_width, output_height, bd);\n+}\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+\n+class ConvolveTest : public ::testing::TestWithParam<ConvolveParam> {\n  public:\n   static void SetUpTestCase() {\n     // Force input_ to be unaligned, output to be 16 byte aligned.\n@@ -177,13 +318,36 @@\n\n         vpx_memalign(kDataAlignment, kInputBufferSize + 1)) + 1;\n     output_ = reinterpret_cast<uint8_t*>(\n         vpx_memalign(kDataAlignment, kOutputBufferSize));\n+    output_ref_ = reinterpret_cast<uint8_t*>(\n+        vpx_memalign(kDataAlignment, kOutputBufferSize));\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    input16_ = reinterpret_cast<uint16_t*>(\n+        vpx_memalign(kDataAlignment,\n+                     (kInputBufferSize + 1) * sizeof(uint16_t))) + 1;\n+    output16_ = reinterpret_cast<uint16_t*>(\n+        vpx_memalign(kDataAlignment, (kOutputBufferSize) * sizeof(uint16_t)));\n+    output16_ref_ = reinterpret_cast<uint16_t*>(\n+        vpx_memalign(kDataAlignment, (kOutputBufferSize) * sizeof(uint16_t)));\n+#endif\n   }\n \n+  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n+\n   static void TearDownTestCase() {\n     vpx_free(input_ - 1);\n     input_ = NULL;\n     vpx_free(output_);\n     output_ = NULL;\n+    vpx_free(output_ref_);\n+    output_ref_ = NULL;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    vpx_free(input16_ - 1);\n+    input16_ = NULL;\n+    vpx_free(output16_);\n+    output16_ = NULL;\n+    vpx_free(output16_ref_);\n+    output16_ref_ = NULL;\n+#endif\n   }\n \n  protected:\n@@ -191,7 +355,6 @@\n\n   static const int kOuterBlockSize = 256;\n   static const int kInputStride = kOuterBlockSize;\n   static const int kOutputStride = kOuterBlockSize;\n-  static const int kMaxDimension = 64;\n   static const int kInputBufferSize = kOuterBlockSize * kOuterBlockSize;\n   static const int kOutputBufferSize = kOuterBlockSize * kOuterBlockSize;\n \n@@ -212,6 +375,12 @@\n\n \n   virtual void SetUp() {\n     UUT_ = GET_PARAM(2);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    if (UUT_->use_highbd_ != 0)\n+      mask_ = (1 << UUT_->use_highbd_) - 1;\n+    else\n+      mask_ = 255;\n+#endif\n     /* Set up guard blocks for an inner block centered in the outer block */\n     for (int i = 0; i < kOutputBufferSize; ++i) {\n       if (IsIndexInBorder(i))\n@@ -221,12 +390,33 @@\n\n     }\n \n     ::libvpx_test::ACMRandom prng;\n-    for (int i = 0; i < kInputBufferSize; ++i)\n-      input_[i] = prng.Rand8Extremes();\n+    for (int i = 0; i < kInputBufferSize; ++i) {\n+      if (i & 1) {\n+        input_[i] = 255;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        input16_[i] = mask_;\n+#endif\n+      } else {\n+        input_[i] = prng.Rand8Extremes();\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        input16_[i] = prng.Rand16() & mask_;\n+#endif\n+      }\n+    }\n   }\n \n   void SetConstantInput(int value) {\n     memset(input_, value, kInputBufferSize);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    vpx_memset16(input16_, value, kInputBufferSize);\n+#endif\n+  }\n+\n+  void CopyOutputToRef() {\n+    memcpy(output_ref_, output_, kOutputBufferSize);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    memcpy(output16_ref_, output16_, kOutputBufferSize);\n+#endif\n   }\n \n   void CheckGuardBlocks() {\n@@ -236,39 +426,197 @@\n\n     }\n   }\n \n-  uint8_t* input() const {\n+  uint8_t *input() const {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    if (UUT_->use_highbd_ == 0) {\n+      return input_ + BorderTop() * kOuterBlockSize + BorderLeft();\n+    } else {\n+      return CONVERT_TO_BYTEPTR(input16_ + BorderTop() * kOuterBlockSize +\n+                                BorderLeft());\n+    }\n+#else\n     return input_ + BorderTop() * kOuterBlockSize + BorderLeft();\n+#endif\n   }\n \n-  uint8_t* output() const {\n+  uint8_t *output() const {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    if (UUT_->use_highbd_ == 0) {\n+      return output_ + BorderTop() * kOuterBlockSize + BorderLeft();\n+    } else {\n+      return CONVERT_TO_BYTEPTR(output16_ + BorderTop() * kOuterBlockSize +\n+                                BorderLeft());\n+    }\n+#else\n     return output_ + BorderTop() * kOuterBlockSize + BorderLeft();\n+#endif\n+  }\n+\n+  uint8_t *output_ref() const {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    if (UUT_->use_highbd_ == 0) {\n+      return output_ref_ + BorderTop() * kOuterBlockSize + BorderLeft();\n+    } else {\n+      return CONVERT_TO_BYTEPTR(output16_ref_ + BorderTop() * kOuterBlockSize +\n+                                BorderLeft());\n+    }\n+#else\n+    return output_ref_ + BorderTop() * kOuterBlockSize + BorderLeft();\n+#endif\n+  }\n+\n+  uint16_t lookup(uint8_t *list, int index) const {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    if (UUT_->use_highbd_ == 0) {\n+      return list[index];\n+    } else {\n+      return CONVERT_TO_SHORTPTR(list)[index];\n+    }\n+#else\n+    return list[index];\n+#endif\n+  }\n+\n+  void assign_val(uint8_t *list, int index, uint16_t val) const {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    if (UUT_->use_highbd_ == 0) {\n+      list[index] = (uint8_t) val;\n+    } else {\n+      CONVERT_TO_SHORTPTR(list)[index] = val;\n+    }\n+#else\n+    list[index] = (uint8_t) val;\n+#endif\n+  }\n+\n+  void wrapper_filter_average_block2d_8_c(const uint8_t *src_ptr,\n+                                          const unsigned int src_stride,\n+                                          const int16_t *HFilter,\n+                                          const int16_t *VFilter,\n+                                          uint8_t *dst_ptr,\n+                                          unsigned int dst_stride,\n+                                          unsigned int output_width,\n+                                          unsigned int output_height) {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    if (UUT_->use_highbd_ == 0) {\n+      filter_average_block2d_8_c(src_ptr, src_stride, HFilter, VFilter,\n+                                 dst_ptr, dst_stride, output_width,\n+                                 output_height);\n+    } else {\n+      highbd_filter_average_block2d_8_c(CONVERT_TO_SHORTPTR(src_ptr),\n+                                        src_stride, HFilter, VFilter,\n+                                        CONVERT_TO_SHORTPTR(dst_ptr),\n+                                        dst_stride, output_width, output_height,\n+                                        UUT_->use_highbd_);\n+    }\n+#else\n+    filter_average_block2d_8_c(src_ptr, src_stride, HFilter, VFilter,\n+                               dst_ptr, dst_stride, output_width,\n+                               output_height);\n+#endif\n+  }\n+\n+  void wrapper_filter_block2d_8_c(const uint8_t *src_ptr,\n+                                  const unsigned int src_stride,\n+                                  const int16_t *HFilter,\n+                                  const int16_t *VFilter,\n+                                  uint8_t *dst_ptr,\n+                                  unsigned int dst_stride,\n+                                  unsigned int output_width,\n+                                  unsigned int output_height) {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    if (UUT_->use_highbd_ == 0) {\n+      filter_block2d_8_c(src_ptr, src_stride, HFilter, VFilter,\n+                         dst_ptr, dst_stride, output_width, output_height);\n+    } else {\n+      highbd_filter_block2d_8_c(CONVERT_TO_SHORTPTR(src_ptr), src_stride,\n+                                HFilter, VFilter,\n+                                CONVERT_TO_SHORTPTR(dst_ptr), dst_stride,\n+                                output_width, output_height, UUT_->use_highbd_);\n+    }\n+#else\n+    filter_block2d_8_c(src_ptr, src_stride, HFilter, VFilter,\n+                       dst_ptr, dst_stride, output_width, output_height);\n+#endif\n   }\n \n   const ConvolveFunctions* UUT_;\n   static uint8_t* input_;\n   static uint8_t* output_;\n+  static uint8_t* output_ref_;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  static uint16_t* input16_;\n+  static uint16_t* output16_;\n+  static uint16_t* output16_ref_;\n+  int mask_;\n+#endif\n };\n+\n uint8_t* ConvolveTest::input_ = NULL;\n uint8_t* ConvolveTest::output_ = NULL;\n+uint8_t* ConvolveTest::output_ref_ = NULL;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+uint16_t* ConvolveTest::input16_ = NULL;\n+uint16_t* ConvolveTest::output16_ = NULL;\n+uint16_t* ConvolveTest::output16_ref_ = NULL;\n+#endif\n \n TEST_P(ConvolveTest, GuardBlocks) {\n   CheckGuardBlocks();\n }\n \n+TEST_P(ConvolveTest, Copy) {\n+  uint8_t* const in = input();\n+  uint8_t* const out = output();\n+\n+  ASM_REGISTER_STATE_CHECK(\n+      UUT_->copy_(in, kInputStride, out, kOutputStride, NULL, 0, NULL, 0,\n+                  Width(), Height()));\n+\n+  CheckGuardBlocks();\n+\n+  for (int y = 0; y < Height(); ++y)\n+    for (int x = 0; x < Width(); ++x)\n+      ASSERT_EQ(lookup(out, y * kOutputStride + x),\n+                lookup(in, y * kInputStride + x))\n+          << \""(\"" << x << \"",\"" << y << \"")\"";\n+}\n+\n+TEST_P(ConvolveTest, Avg) {\n+  uint8_t* const in = input();\n+  uint8_t* const out = output();\n+  uint8_t* const out_ref = output_ref();\n+  CopyOutputToRef();\n+\n+  ASM_REGISTER_STATE_CHECK(\n+      UUT_->avg_(in, kInputStride, out, kOutputStride, NULL, 0, NULL, 0,\n+                Width(), Height()));\n+\n+  CheckGuardBlocks();\n+\n+  for (int y = 0; y < Height(); ++y)\n+    for (int x = 0; x < Width(); ++x)\n+      ASSERT_EQ(lookup(out, y * kOutputStride + x),\n+                ROUND_POWER_OF_TWO(lookup(in, y * kInputStride + x) +\n+                                   lookup(out_ref, y * kOutputStride + x), 1))\n+          << \""(\"" << x << \"",\"" << y << \"")\"";\n+}\n+\n TEST_P(ConvolveTest, CopyHoriz) {\n   uint8_t* const in = input();\n   uint8_t* const out = output();\n   DECLARE_ALIGNED(256, const int16_t, filter8[8]) = {0, 0, 0, 128, 0, 0, 0, 0};\n \n-  REGISTER_STATE_CHECK(\n-      UUT_->h8_(in, kInputStride, out, kOutputStride, filter8, 16, filter8, 16,\n-                Width(), Height()));\n+  ASM_REGISTER_STATE_CHECK(\n+      UUT_->sh8_(in, kInputStride, out, kOutputStride, filter8, 16, filter8, 16,\n+                 Width(), Height()));\n \n   CheckGuardBlocks();\n \n   for (int y = 0; y < Height(); ++y)\n     for (int x = 0; x < Width(); ++x)\n-      ASSERT_EQ(out[y * kOutputStride + x], in[y * kInputStride + x])\n+      ASSERT_EQ(lookup(out, y * kOutputStride + x),\n+                lookup(in, y * kInputStride + x))\n           << \""(\"" << x << \"",\"" << y << \"")\"";\n }\n \n@@ -277,15 +625,16 @@\n\n   uint8_t* const out = output();\n   DECLARE_ALIGNED(256, const int16_t, filter8[8]) = {0, 0, 0, 128, 0, 0, 0, 0};\n \n-  REGISTER_STATE_CHECK(\n-      UUT_->v8_(in, kInputStride, out, kOutputStride, filter8, 16, filter8, 16,\n-                Width(), Height()));\n+  ASM_REGISTER_STATE_CHECK(\n+      UUT_->sv8_(in, kInputStride, out, kOutputStride, filter8, 16, filter8, 16,\n+                 Width(), Height()));\n \n   CheckGuardBlocks();\n \n   for (int y = 0; y < Height(); ++y)\n     for (int x = 0; x < Width(); ++x)\n-      ASSERT_EQ(out[y * kOutputStride + x], in[y * kInputStride + x])\n+      ASSERT_EQ(lookup(out, y * kOutputStride + x),\n+                lookup(in, y * kInputStride + x))\n           << \""(\"" << x << \"",\"" << y << \"")\"";\n }\n \n@@ -294,31 +643,26 @@\n\n   uint8_t* const out = output();\n   DECLARE_ALIGNED(256, const int16_t, filter8[8]) = {0, 0, 0, 128, 0, 0, 0, 0};\n \n-  REGISTER_STATE_CHECK(\n-      UUT_->hv8_(in, kInputStride, out, kOutputStride, filter8, 16, filter8, 16,\n-                 Width(), Height()));\n+  ASM_REGISTER_STATE_CHECK(\n+      UUT_->shv8_(in, kInputStride, out, kOutputStride, filter8, 16, filter8,\n+                  16, Width(), Height()));\n \n   CheckGuardBlocks();\n \n   for (int y = 0; y < Height(); ++y)\n     for (int x = 0; x < Width(); ++x)\n-      ASSERT_EQ(out[y * kOutputStride + x], in[y * kInputStride + x])\n+      ASSERT_EQ(lookup(out, y * kOutputStride + x),\n+                lookup(in, y * kInputStride + x))\n           << \""(\"" << x << \"",\"" << y << \"")\"";\n }\n \n-const int16_t (*kTestFilterList[])[8] = {\n-  vp9_bilinear_filters,\n-  vp9_sub_pel_filters_8,\n-  vp9_sub_pel_filters_8s,\n-  vp9_sub_pel_filters_8lp\n-};\n-const int kNumFilterBanks = sizeof(kTestFilterList) /\n-                            sizeof(kTestFilterList[0]);\n+const int kNumFilterBanks = 4;\n const int kNumFilters = 16;\n \n TEST(ConvolveTest, FiltersWontSaturateWhenAddedPairwise) {\n   for (int filter_bank = 0; filter_bank < kNumFilterBanks; ++filter_bank) {\n-    const int16_t (*filters)[8] = kTestFilterList[filter_bank];\n+    const InterpKernel *filters =\n+        vp9_filter_kernels[static_cast<INTERP_FILTER>(filter_bank)];\n     for (int i = 0; i < kNumFilters; i++) {\n       const int p0 = filters[i][0] + filters[i][1];\n       const int p1 = filters[i][2] + filters[i][3];\n@@ -341,40 +685,57 @@\n\n TEST_P(ConvolveTest, MatchesReferenceSubpixelFilter) {\n   uint8_t* const in = input();\n   uint8_t* const out = output();\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  uint8_t ref8[kOutputStride * kMaxDimension];\n+  uint16_t ref16[kOutputStride * kMaxDimension];\n+  uint8_t* ref;\n+  if (UUT_->use_highbd_ == 0) {\n+    ref = ref8;\n+  } else {\n+    ref = CONVERT_TO_BYTEPTR(ref16);\n+  }\n+#else\n   uint8_t ref[kOutputStride * kMaxDimension];\n-\n+#endif\n \n   for (int filter_bank = 0; filter_bank < kNumFilterBanks; ++filter_bank) {\n-    const int16_t (*filters)[8] = kTestFilterList[filter_bank];\n+    const InterpKernel *filters =\n+        vp9_filter_kernels[static_cast<INTERP_FILTER>(filter_bank)];\n \n     for (int filter_x = 0; filter_x < kNumFilters; ++filter_x) {\n       for (int filter_y = 0; filter_y < kNumFilters; ++filter_y) {\n-        filter_block2d_8_c(in, kInputStride,\n-                           filters[filter_x], filters[filter_y],\n-                           ref, kOutputStride,\n-                           Width(), Height());\n+        wrapper_filter_block2d_8_c(in, kInputStride,\n+                                   filters[filter_x], filters[filter_y],\n+                                   ref, kOutputStride,\n+                                   Width(), Height());\n \n-        if (filters == vp9_sub_pel_filters_8lp || (filter_x && filter_y))\n-          REGISTER_STATE_CHECK(\n+        if (filter_x && filter_y)\n+          ASM_REGISTER_STATE_CHECK(\n               UUT_->hv8_(in, kInputStride, out, kOutputStride,\n                          filters[filter_x], 16, filters[filter_y], 16,\n                          Width(), Height()));\n         else if (filter_y)\n-          REGISTER_STATE_CHECK(\n+          ASM_REGISTER_STATE_CHECK(\n               UUT_->v8_(in, kInputStride, out, kOutputStride,\n                         kInvalidFilter, 16, filters[filter_y], 16,\n                         Width(), Height()));\n-        else\n-          REGISTER_STATE_CHECK(\n+        else if (filter_x)\n+          ASM_REGISTER_STATE_CHECK(\n               UUT_->h8_(in, kInputStride, out, kOutputStride,\n                         filters[filter_x], 16, kInvalidFilter, 16,\n                         Width(), Height()));\n+        else\n+          ASM_REGISTER_STATE_CHECK(\n+              UUT_->copy_(in, kInputStride, out, kOutputStride,\n+                          kInvalidFilter, 0, kInvalidFilter, 0,\n+                          Width(), Height()));\n \n         CheckGuardBlocks();\n \n         for (int y = 0; y < Height(); ++y)\n           for (int x = 0; x < Width(); ++x)\n-            ASSERT_EQ(ref[y * kOutputStride + x], out[y * kOutputStride + x])\n+            ASSERT_EQ(lookup(ref, y * kOutputStride + x),\n+                      lookup(out, y * kOutputStride + x))\n                 << \""mismatch at (\"" << x << \"",\"" << y << \""), \""\n                 << \""filters (\"" << filter_bank << \"",\""\n                 << filter_x << \"",\"" << filter_y << \"")\"";\n@@ -386,54 +747,77 @@\n\n TEST_P(ConvolveTest, MatchesReferenceAveragingSubpixelFilter) {\n   uint8_t* const in = input();\n   uint8_t* const out = output();\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  uint8_t ref8[kOutputStride * kMaxDimension];\n+  uint16_t ref16[kOutputStride * kMaxDimension];\n+  uint8_t* ref;\n+  if (UUT_->use_highbd_ == 0) {\n+    ref = ref8;\n+  } else {\n+    ref = CONVERT_TO_BYTEPTR(ref16);\n+  }\n+#else\n   uint8_t ref[kOutputStride * kMaxDimension];\n+#endif\n \n   // Populate ref and out with some random data\n   ::libvpx_test::ACMRandom prng;\n   for (int y = 0; y < Height(); ++y) {\n     for (int x = 0; x < Width(); ++x) {\n-      const uint8_t r = prng.Rand8Extremes();\n+      uint16_t r;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      if (UUT_->use_highbd_ == 0 || UUT_->use_highbd_ == 8) {\n+        r = prng.Rand8Extremes();\n+      } else {\n+        r = prng.Rand16() & mask_;\n+      }\n+#else\n+      r = prng.Rand8Extremes();\n+#endif\n \n-      out[y * kOutputStride + x] = r;\n-      ref[y * kOutputStride + x] = r;\n+      assign_val(out, y * kOutputStride + x, r);\n+      assign_val(ref, y * kOutputStride + x, r);\n     }\n   }\n \n-  const int kNumFilterBanks = sizeof(kTestFilterList) /\n-      sizeof(kTestFilterList[0]);\n-\n   for (int filter_bank = 0; filter_bank < kNumFilterBanks; ++filter_bank) {\n-    const int16_t (*filters)[8] = kTestFilterList[filter_bank];\n-    const int kNumFilters = 16;\n+    const InterpKernel *filters =\n+        vp9_filter_kernels[static_cast<INTERP_FILTER>(filter_bank)];\n \n     for (int filter_x = 0; filter_x < kNumFilters; ++filter_x) {\n       for (int filter_y = 0; filter_y < kNumFilters; ++filter_y) {\n-        filter_average_block2d_8_c(in, kInputStride,\n-                                   filters[filter_x], filters[filter_y],\n-                                   ref, kOutputStride,\n-                                   Width(), Height());\n+        wrapper_filter_average_block2d_8_c(in, kInputStride,\n+                                           filters[filter_x], filters[filter_y],\n+                                           ref, kOutputStride,\n+                                           Width(), Height());\n \n-        if (filters == vp9_sub_pel_filters_8lp || (filter_x && filter_y))\n-          REGISTER_STATE_CHECK(\n+        if (filter_x && filter_y)\n+          ASM_REGISTER_STATE_CHECK(\n               UUT_->hv8_avg_(in, kInputStride, out, kOutputStride,\n                              filters[filter_x], 16, filters[filter_y], 16,\n                              Width(), Height()));\n         else if (filter_y)\n-          REGISTER_STATE_CHECK(\n+          ASM_REGISTER_STATE_CHECK(\n               UUT_->v8_avg_(in, kInputStride, out, kOutputStride,\n-                            filters[filter_x], 16, filters[filter_y], 16,\n+                            kInvalidFilter, 16, filters[filter_y], 16,\n+                            Width(), Height()));\n+        else if (filter_x)\n+          ASM_REGISTER_STATE_CHECK(\n+              UUT_->h8_avg_(in, kInputStride, out, kOutputStride,\n+                            filters[filter_x], 16, kInvalidFilter, 16,\n                             Width(), Height()));\n         else\n-          REGISTER_STATE_CHECK(\n-              UUT_->h8_avg_(in, kInputStride, out, kOutputStride,\n-                            filters[filter_x], 16, filters[filter_y], 16,\n-                            Width(), Height()));\n+          ASM_REGISTER_STATE_CHECK(\n+              UUT_->avg_(in, kInputStride, out, kOutputStride,\n+                          kInvalidFilter, 0, kInvalidFilter, 0,\n+                          Width(), Height()));\n \n         CheckGuardBlocks();\n \n         for (int y = 0; y < Height(); ++y)\n           for (int x = 0; x < Width(); ++x)\n-            ASSERT_EQ(ref[y * kOutputStride + x], out[y * kOutputStride + x])\n+            ASSERT_EQ(lookup(ref, y * kOutputStride + x),\n+                      lookup(out, y * kOutputStride + x))\n                 << \""mismatch at (\"" << x << \"",\"" << y << \""), \""\n                 << \""filters (\"" << filter_bank << \"",\""\n                 << filter_x << \"",\"" << filter_y << \"")\"";\n@@ -442,108 +826,102 @@\n\n   }\n }\n \n-DECLARE_ALIGNED(256, const int16_t, kChangeFilters[16][8]) = {\n-    { 0,   0,   0,   0,   0,   0,   0, 128},\n-    { 0,   0,   0,   0,   0,   0, 128},\n-    { 0,   0,   0,   0,   0, 128},\n-    { 0,   0,   0,   0, 128},\n-    { 0,   0,   0, 128},\n-    { 0,   0, 128},\n-    { 0, 128},\n-    { 128},\n-    { 0,   0,   0,   0,   0,   0,   0, 128},\n-    { 0,   0,   0,   0,   0,   0, 128},\n-    { 0,   0,   0,   0,   0, 128},\n-    { 0,   0,   0,   0, 128},\n-    { 0,   0,   0, 128},\n-    { 0,   0, 128},\n-    { 0, 128},\n-    { 128}\n-};\n-\n-/* This test exercises the horizontal and vertical filter functions. */\n-TEST_P(ConvolveTest, ChangeFilterWorks) {\n-  uint8_t* const in = input();\n-  uint8_t* const out = output();\n-\n-  /* Assume that the first input sample is at the 8/16th position. */\n-  const int kInitialSubPelOffset = 8;\n-\n-  /* Filters are 8-tap, so the first filter tap will be applied to the pixel\n-   * at position -3 with respect to the current filtering position. Since\n-   * kInitialSubPelOffset is set to 8, we first select sub-pixel filter 8,\n-   * which is non-zero only in the last tap. So, applying the filter at the\n-   * current input position will result in an output equal to the pixel at\n-   * offset +4 (-3 + 7) with respect to the current filtering position.\n-   */\n-  const int kPixelSelected = 4;\n-\n-  /* Assume that each output pixel requires us to step on by 17/16th pixels in\n-   * the input.\n-   */\n-  const int kInputPixelStep = 17;\n-\n-  /* The filters are setup in such a way that the expected output produces\n-   * sets of 8 identical output samples. As the filter position moves to the\n-   * next 1/16th pixel position the only active (=128) filter tap moves one\n-   * position to the left, resulting in the same input pixel being replicated\n-   * in to the output for 8 consecutive samples. After each set of 8 positions\n-   * the filters select a different input pixel. kFilterPeriodAdjust below\n-   * computes which input pixel is written to the output for a specified\n-   * x or y position.\n-   */\n-\n-  /* Test the horizontal filter. */\n-  REGISTER_STATE_CHECK(UUT_->h8_(in, kInputStride, out, kOutputStride,\n-                                 kChangeFilters[kInitialSubPelOffset],\n-                                 kInputPixelStep, NULL, 0, Width(), Height()));\n-\n-  for (int x = 0; x < Width(); ++x) {\n-    const int kFilterPeriodAdjust = (x >> 3) << 3;\n-    const int ref_x =\n-        kPixelSelected + ((kInitialSubPelOffset\n-            + kFilterPeriodAdjust * kInputPixelStep)\n-                          >> SUBPEL_BITS);\n-    ASSERT_EQ(in[ref_x], out[x]) << \""x == \"" << x << \""width = \"" << Width();\n+TEST_P(ConvolveTest, FilterExtremes) {\n+  uint8_t *const in = input();\n+  uint8_t *const out = output();\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  uint8_t ref8[kOutputStride * kMaxDimension];\n+  uint16_t ref16[kOutputStride * kMaxDimension];\n+  uint8_t *ref;\n+  if (UUT_->use_highbd_ == 0) {\n+    ref = ref8;\n+  } else {\n+    ref = CONVERT_TO_BYTEPTR(ref16);\n   }\n+#else\n+  uint8_t ref[kOutputStride * kMaxDimension];\n+#endif\n \n-  /* Test the vertical filter. */\n-  REGISTER_STATE_CHECK(UUT_->v8_(in, kInputStride, out, kOutputStride,\n-                                 NULL, 0, kChangeFilters[kInitialSubPelOffset],\n-                                 kInputPixelStep, Width(), Height()));\n-\n+  // Populate ref and out with some random data\n+  ::libvpx_test::ACMRandom prng;\n   for (int y = 0; y < Height(); ++y) {\n-    const int kFilterPeriodAdjust = (y >> 3) << 3;\n-    const int ref_y =\n-        kPixelSelected + ((kInitialSubPelOffset\n-            + kFilterPeriodAdjust * kInputPixelStep)\n-                          >> SUBPEL_BITS);\n-    ASSERT_EQ(in[ref_y * kInputStride], out[y * kInputStride]) << \""y == \"" << y;\n-  }\n-\n-  /* Test the horizontal and vertical filters in combination. */\n-  REGISTER_STATE_CHECK(UUT_->hv8_(in, kInputStride, out, kOutputStride,\n-                                  kChangeFilters[kInitialSubPelOffset],\n-                                  kInputPixelStep,\n-                                  kChangeFilters[kInitialSubPelOffset],\n-                                  kInputPixelStep,\n-                                  Width(), Height()));\n-\n-  for (int y = 0; y < Height(); ++y) {\n-    const int kFilterPeriodAdjustY = (y >> 3) << 3;\n-    const int ref_y =\n-        kPixelSelected + ((kInitialSubPelOffset\n-            + kFilterPeriodAdjustY * kInputPixelStep)\n-                          >> SUBPEL_BITS);\n     for (int x = 0; x < Width(); ++x) {\n-      const int kFilterPeriodAdjustX = (x >> 3) << 3;\n-      const int ref_x =\n-          kPixelSelected + ((kInitialSubPelOffset\n-              + kFilterPeriodAdjustX * kInputPixelStep)\n-                            >> SUBPEL_BITS);\n+      uint16_t r;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      if (UUT_->use_highbd_ == 0 || UUT_->use_highbd_ == 8) {\n+        r = prng.Rand8Extremes();\n+      } else {\n+        r = prng.Rand16() & mask_;\n+      }\n+#else\n+      r = prng.Rand8Extremes();\n+#endif\n+      assign_val(out, y * kOutputStride + x, r);\n+      assign_val(ref, y * kOutputStride + x, r);\n+    }\n+  }\n \n-      ASSERT_EQ(in[ref_y * kInputStride + ref_x], out[y * kOutputStride + x])\n-          << \""x == \"" << x << \"", y == \"" << y;\n+  for (int axis = 0; axis < 2; axis++) {\n+    int seed_val = 0;\n+    while (seed_val < 256) {\n+      for (int y = 0; y < 8; ++y) {\n+        for (int x = 0; x < 8; ++x) {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+            assign_val(in, y * kOutputStride + x - SUBPEL_TAPS / 2 + 1,\n+                       ((seed_val >> (axis ? y : x)) & 1) * mask_);\n+#else\n+            assign_val(in, y * kOutputStride + x - SUBPEL_TAPS / 2 + 1,\n+                       ((seed_val >> (axis ? y : x)) & 1) * 255);\n+#endif\n+          if (axis) seed_val++;\n+        }\n+        if (axis)\n+          seed_val-= 8;\n+        else\n+          seed_val++;\n+      }\n+      if (axis) seed_val += 8;\n+\n+      for (int filter_bank = 0; filter_bank < kNumFilterBanks; ++filter_bank) {\n+        const InterpKernel *filters =\n+            vp9_filter_kernels[static_cast<INTERP_FILTER>(filter_bank)];\n+        for (int filter_x = 0; filter_x < kNumFilters; ++filter_x) {\n+          for (int filter_y = 0; filter_y < kNumFilters; ++filter_y) {\n+            wrapper_filter_block2d_8_c(in, kInputStride,\n+                                       filters[filter_x], filters[filter_y],\n+                                       ref, kOutputStride,\n+                                       Width(), Height());\n+            if (filter_x && filter_y)\n+              ASM_REGISTER_STATE_CHECK(\n+                  UUT_->hv8_(in, kInputStride, out, kOutputStride,\n+                             filters[filter_x], 16, filters[filter_y], 16,\n+                             Width(), Height()));\n+            else if (filter_y)\n+              ASM_REGISTER_STATE_CHECK(\n+                  UUT_->v8_(in, kInputStride, out, kOutputStride,\n+                            kInvalidFilter, 16, filters[filter_y], 16,\n+                            Width(), Height()));\n+            else if (filter_x)\n+              ASM_REGISTER_STATE_CHECK(\n+                  UUT_->h8_(in, kInputStride, out, kOutputStride,\n+                            filters[filter_x], 16, kInvalidFilter, 16,\n+                            Width(), Height()));\n+            else\n+              ASM_REGISTER_STATE_CHECK(\n+                  UUT_->copy_(in, kInputStride, out, kOutputStride,\n+                              kInvalidFilter, 0, kInvalidFilter, 0,\n+                              Width(), Height()));\n+\n+            for (int y = 0; y < Height(); ++y)\n+              for (int x = 0; x < Width(); ++x)\n+                ASSERT_EQ(lookup(ref, y * kOutputStride + x),\n+                          lookup(out, y * kOutputStride + x))\n+                    << \""mismatch at (\"" << x << \"",\"" << y << \""), \""\n+                    << \""filters (\"" << filter_bank << \"",\""\n+                    << filter_x << \"",\"" << filter_y << \"")\"";\n+          }\n+        }\n+      }\n     }\n   }\n }\n@@ -553,22 +931,24 @@\n\n TEST_P(ConvolveTest, CheckScalingFiltering) {\n   uint8_t* const in = input();\n   uint8_t* const out = output();\n+  const InterpKernel *const eighttap = vp9_filter_kernels[EIGHTTAP];\n \n   SetConstantInput(127);\n \n   for (int frac = 0; frac < 16; ++frac) {\n     for (int step = 1; step <= 32; ++step) {\n       /* Test the horizontal and vertical filters in combination. */\n-      REGISTER_STATE_CHECK(UUT_->hv8_(in, kInputStride, out, kOutputStride,\n-                                      vp9_sub_pel_filters_8[frac], step,\n-                                      vp9_sub_pel_filters_8[frac], step,\n-                                      Width(), Height()));\n+      ASM_REGISTER_STATE_CHECK(UUT_->shv8_(in, kInputStride, out, kOutputStride,\n+                                           eighttap[frac], step,\n+                                           eighttap[frac], step,\n+                                           Width(), Height()));\n \n       CheckGuardBlocks();\n \n       for (int y = 0; y < Height(); ++y) {\n         for (int x = 0; x < Width(); ++x) {\n-          ASSERT_EQ(in[y * kInputStride + x], out[y * kOutputStride + x])\n+          ASSERT_EQ(lookup(in, y * kInputStride + x),\n+                    lookup(out, y * kOutputStride + x))\n               << \""x == \"" << x << \"", y == \"" << y\n               << \"", frac == \"" << frac << \"", step == \"" << step;\n         }\n@@ -579,10 +959,590 @@\n\n \n using std::tr1::make_tuple;\n \n+#if CONFIG_VP9_HIGHBITDEPTH\n+#if HAVE_SSE2 && ARCH_X86_64\n+void wrap_convolve8_horiz_sse2_8(const uint8_t *src, ptrdiff_t src_stride,\n+                                 uint8_t *dst, ptrdiff_t dst_stride,\n+                                 const int16_t *filter_x,\n+                                 int filter_x_stride,\n+                                 const int16_t *filter_y,\n+                                 int filter_y_stride,\n+                                 int w, int h) {\n+  vpx_highbd_convolve8_horiz_sse2(src, src_stride, dst, dst_stride, filter_x,\n+                                  filter_x_stride, filter_y, filter_y_stride,\n+                                  w, h, 8);\n+}\n+\n+void wrap_convolve8_avg_horiz_sse2_8(const uint8_t *src, ptrdiff_t src_stride,\n+                                     uint8_t *dst, ptrdiff_t dst_stride,\n+                                     const int16_t *filter_x,\n+                                     int filter_x_stride,\n+                                     const int16_t *filter_y,\n+                                     int filter_y_stride,\n+                                     int w, int h) {\n+  vpx_highbd_convolve8_avg_horiz_sse2(src, src_stride, dst, dst_stride,\n+                                      filter_x, filter_x_stride,\n+                                      filter_y, filter_y_stride, w, h, 8);\n+}\n+\n+void wrap_convolve8_vert_sse2_8(const uint8_t *src, ptrdiff_t src_stride,\n+                                uint8_t *dst, ptrdiff_t dst_stride,\n+                                const int16_t *filter_x,\n+                                int filter_x_stride,\n+                                const int16_t *filter_y,\n+                                int filter_y_stride,\n+                                int w, int h) {\n+  vpx_highbd_convolve8_vert_sse2(src, src_stride, dst, dst_stride,\n+                                 filter_x, filter_x_stride,\n+                                 filter_y, filter_y_stride, w, h, 8);\n+}\n+\n+void wrap_convolve8_avg_vert_sse2_8(const uint8_t *src, ptrdiff_t src_stride,\n+                                    uint8_t *dst, ptrdiff_t dst_stride,\n+                                    const int16_t *filter_x,\n+                                    int filter_x_stride,\n+                                    const int16_t *filter_y,\n+                                    int filter_y_stride,\n+                                    int w, int h) {\n+  vpx_highbd_convolve8_avg_vert_sse2(src, src_stride, dst, dst_stride,\n+                                     filter_x, filter_x_stride,\n+                                     filter_y, filter_y_stride, w, h, 8);\n+}\n+\n+void wrap_convolve8_sse2_8(const uint8_t *src, ptrdiff_t src_stride,\n+                           uint8_t *dst, ptrdiff_t dst_stride,\n+                           const int16_t *filter_x,\n+                           int filter_x_stride,\n+                           const int16_t *filter_y,\n+                           int filter_y_stride,\n+                           int w, int h) {\n+  vpx_highbd_convolve8_sse2(src, src_stride, dst, dst_stride,\n+                            filter_x, filter_x_stride,\n+                            filter_y, filter_y_stride, w, h, 8);\n+}\n+\n+void wrap_convolve8_avg_sse2_8(const uint8_t *src, ptrdiff_t src_stride,\n+                               uint8_t *dst, ptrdiff_t dst_stride,\n+                               const int16_t *filter_x,\n+                               int filter_x_stride,\n+                               const int16_t *filter_y,\n+                               int filter_y_stride,\n+                               int w, int h) {\n+  vpx_highbd_convolve8_avg_sse2(src, src_stride, dst, dst_stride,\n+                                filter_x, filter_x_stride,\n+                                filter_y, filter_y_stride, w, h, 8);\n+}\n+\n+void wrap_convolve8_horiz_sse2_10(const uint8_t *src, ptrdiff_t src_stride,\n+                                  uint8_t *dst, ptrdiff_t dst_stride,\n+                                  const int16_t *filter_x,\n+                                  int filter_x_stride,\n+                                  const int16_t *filter_y,\n+                                  int filter_y_stride,\n+                                  int w, int h) {\n+  vpx_highbd_convolve8_horiz_sse2(src, src_stride, dst, dst_stride,\n+                                  filter_x, filter_x_stride,\n+                                  filter_y, filter_y_stride, w, h, 10);\n+}\n+\n+void wrap_convolve8_avg_horiz_sse2_10(const uint8_t *src, ptrdiff_t src_stride,\n+                                      uint8_t *dst, ptrdiff_t dst_stride,\n+                                      const int16_t *filter_x,\n+                                      int filter_x_stride,\n+                                      const int16_t *filter_y,\n+                                      int filter_y_stride,\n+                                      int w, int h) {\n+  vpx_highbd_convolve8_avg_horiz_sse2(src, src_stride, dst, dst_stride,\n+                                      filter_x, filter_x_stride,\n+                                      filter_y, filter_y_stride, w, h, 10);\n+}\n+\n+void wrap_convolve8_vert_sse2_10(const uint8_t *src, ptrdiff_t src_stride,\n+                                 uint8_t *dst, ptrdiff_t dst_stride,\n+                                 const int16_t *filter_x,\n+                                 int filter_x_stride,\n+                                 const int16_t *filter_y,\n+                                 int filter_y_stride,\n+                                 int w, int h) {\n+  vpx_highbd_convolve8_vert_sse2(src, src_stride, dst, dst_stride,\n+                                 filter_x, filter_x_stride,\n+                                 filter_y, filter_y_stride, w, h, 10);\n+}\n+\n+void wrap_convolve8_avg_vert_sse2_10(const uint8_t *src, ptrdiff_t src_stride,\n+                                     uint8_t *dst, ptrdiff_t dst_stride,\n+                                     const int16_t *filter_x,\n+                                     int filter_x_stride,\n+                                     const int16_t *filter_y,\n+                                     int filter_y_stride,\n+                                     int w, int h) {\n+  vpx_highbd_convolve8_avg_vert_sse2(src, src_stride, dst, dst_stride,\n+                                     filter_x, filter_x_stride,\n+                                     filter_y, filter_y_stride, w, h, 10);\n+}\n+\n+void wrap_convolve8_sse2_10(const uint8_t *src, ptrdiff_t src_stride,\n+                            uint8_t *dst, ptrdiff_t dst_stride,\n+                            const int16_t *filter_x,\n+                            int filter_x_stride,\n+                            const int16_t *filter_y,\n+                            int filter_y_stride,\n+                            int w, int h) {\n+  vpx_highbd_convolve8_sse2(src, src_stride, dst, dst_stride,\n+                            filter_x, filter_x_stride,\n+                            filter_y, filter_y_stride, w, h, 10);\n+}\n+\n+void wrap_convolve8_avg_sse2_10(const uint8_t *src, ptrdiff_t src_stride,\n+                                uint8_t *dst, ptrdiff_t dst_stride,\n+                                const int16_t *filter_x,\n+                                int filter_x_stride,\n+                                const int16_t *filter_y,\n+                                int filter_y_stride,\n+                                int w, int h) {\n+  vpx_highbd_convolve8_avg_sse2(src, src_stride, dst, dst_stride,\n+                                filter_x, filter_x_stride,\n+                                filter_y, filter_y_stride, w, h, 10);\n+}\n+\n+void wrap_convolve8_horiz_sse2_12(const uint8_t *src, ptrdiff_t src_stride,\n+                                  uint8_t *dst, ptrdiff_t dst_stride,\n+                                  const int16_t *filter_x,\n+                                  int filter_x_stride,\n+                                  const int16_t *filter_y,\n+                                  int filter_y_stride,\n+                                  int w, int h) {\n+  vpx_highbd_convolve8_horiz_sse2(src, src_stride, dst, dst_stride,\n+                                  filter_x, filter_x_stride,\n+                                  filter_y, filter_y_stride, w, h, 12);\n+}\n+\n+void wrap_convolve8_avg_horiz_sse2_12(const uint8_t *src, ptrdiff_t src_stride,\n+                                      uint8_t *dst, ptrdiff_t dst_stride,\n+                                      const int16_t *filter_x,\n+                                      int filter_x_stride,\n+                                      const int16_t *filter_y,\n+                                      int filter_y_stride,\n+                                      int w, int h) {\n+  vpx_highbd_convolve8_avg_horiz_sse2(src, src_stride, dst, dst_stride,\n+                                      filter_x, filter_x_stride,\n+                                      filter_y, filter_y_stride, w, h, 12);\n+}\n+\n+void wrap_convolve8_vert_sse2_12(const uint8_t *src, ptrdiff_t src_stride,\n+                                 uint8_t *dst, ptrdiff_t dst_stride,\n+                                 const int16_t *filter_x,\n+                                 int filter_x_stride,\n+                                 const int16_t *filter_y,\n+                                 int filter_y_stride,\n+                                 int w, int h) {\n+  vpx_highbd_convolve8_vert_sse2(src, src_stride, dst, dst_stride,\n+                                 filter_x, filter_x_stride,\n+                                 filter_y, filter_y_stride, w, h, 12);\n+}\n+\n+void wrap_convolve8_avg_vert_sse2_12(const uint8_t *src, ptrdiff_t src_stride,\n+                                     uint8_t *dst, ptrdiff_t dst_stride,\n+                                     const int16_t *filter_x,\n+                                     int filter_x_stride,\n+                                     const int16_t *filter_y,\n+                                     int filter_y_stride,\n+                                     int w, int h) {\n+  vpx_highbd_convolve8_avg_vert_sse2(src, src_stride, dst, dst_stride,\n+                                     filter_x, filter_x_stride,\n+                                     filter_y, filter_y_stride, w, h, 12);\n+}\n+\n+void wrap_convolve8_sse2_12(const uint8_t *src, ptrdiff_t src_stride,\n+                            uint8_t *dst, ptrdiff_t dst_stride,\n+                            const int16_t *filter_x,\n+                            int filter_x_stride,\n+                            const int16_t *filter_y,\n+                            int filter_y_stride,\n+                            int w, int h) {\n+  vpx_highbd_convolve8_sse2(src, src_stride, dst, dst_stride,\n+                            filter_x, filter_x_stride,\n+                            filter_y, filter_y_stride, w, h, 12);\n+}\n+\n+void wrap_convolve8_avg_sse2_12(const uint8_t *src, ptrdiff_t src_stride,\n+                                uint8_t *dst, ptrdiff_t dst_stride,\n+                                const int16_t *filter_x,\n+                                int filter_x_stride,\n+                                const int16_t *filter_y,\n+                                int filter_y_stride,\n+                                int w, int h) {\n+  vpx_highbd_convolve8_avg_sse2(src, src_stride, dst, dst_stride,\n+                                filter_x, filter_x_stride,\n+                                filter_y, filter_y_stride, w, h, 12);\n+}\n+#endif  // HAVE_SSE2 && ARCH_X86_64\n+\n+void wrap_convolve_copy_c_8(const uint8_t *src, ptrdiff_t src_stride,\n+                            uint8_t *dst, ptrdiff_t dst_stride,\n+                            const int16_t *filter_x,\n+                            int filter_x_stride,\n+                            const int16_t *filter_y,\n+                            int filter_y_stride,\n+                            int w, int h) {\n+  vpx_highbd_convolve_copy_c(src, src_stride, dst, dst_stride,\n+                             filter_x, filter_x_stride,\n+                             filter_y, filter_y_stride, w, h, 8);\n+}\n+\n+void wrap_convolve_avg_c_8(const uint8_t *src, ptrdiff_t src_stride,\n+                           uint8_t *dst, ptrdiff_t dst_stride,\n+                           const int16_t *filter_x,\n+                           int filter_x_stride,\n+                           const int16_t *filter_y,\n+                           int filter_y_stride,\n+                           int w, int h) {\n+  vpx_highbd_convolve_avg_c(src, src_stride, dst, dst_stride,\n+                            filter_x, filter_x_stride,\n+                            filter_y, filter_y_stride, w, h, 8);\n+}\n+\n+void wrap_convolve8_horiz_c_8(const uint8_t *src, ptrdiff_t src_stride,\n+                              uint8_t *dst, ptrdiff_t dst_stride,\n+                              const int16_t *filter_x,\n+                              int filter_x_stride,\n+                              const int16_t *filter_y,\n+                              int filter_y_stride,\n+                              int w, int h) {\n+  vpx_highbd_convolve8_horiz_c(src, src_stride, dst, dst_stride,\n+                               filter_x, filter_x_stride,\n+                               filter_y, filter_y_stride, w, h, 8);\n+}\n+\n+void wrap_convolve8_avg_horiz_c_8(const uint8_t *src, ptrdiff_t src_stride,\n+                                  uint8_t *dst, ptrdiff_t dst_stride,\n+                                  const int16_t *filter_x,\n+                                  int filter_x_stride,\n+                                  const int16_t *filter_y,\n+                                  int filter_y_stride,\n+                                  int w, int h) {\n+  vpx_highbd_convolve8_avg_horiz_c(src, src_stride, dst, dst_stride,\n+                                   filter_x, filter_x_stride,\n+                                   filter_y, filter_y_stride, w, h, 8);\n+}\n+\n+void wrap_convolve8_vert_c_8(const uint8_t *src, ptrdiff_t src_stride,\n+                             uint8_t *dst, ptrdiff_t dst_stride,\n+                             const int16_t *filter_x,\n+                             int filter_x_stride,\n+                             const int16_t *filter_y,\n+                             int filter_y_stride,\n+                             int w, int h) {\n+  vpx_highbd_convolve8_vert_c(src, src_stride, dst, dst_stride,\n+                              filter_x, filter_x_stride,\n+                              filter_y, filter_y_stride, w, h, 8);\n+}\n+\n+void wrap_convolve8_avg_vert_c_8(const uint8_t *src, ptrdiff_t src_stride,\n+                                 uint8_t *dst, ptrdiff_t dst_stride,\n+                                 const int16_t *filter_x,\n+                                 int filter_x_stride,\n+                                 const int16_t *filter_y,\n+                                 int filter_y_stride,\n+                                 int w, int h) {\n+  vpx_highbd_convolve8_avg_vert_c(src, src_stride, dst, dst_stride,\n+                                  filter_x, filter_x_stride,\n+                                  filter_y, filter_y_stride, w, h, 8);\n+}\n+\n+void wrap_convolve8_c_8(const uint8_t *src, ptrdiff_t src_stride,\n+                        uint8_t *dst, ptrdiff_t dst_stride,\n+                        const int16_t *filter_x,\n+                        int filter_x_stride,\n+                        const int16_t *filter_y,\n+                        int filter_y_stride,\n+                        int w, int h) {\n+  vpx_highbd_convolve8_c(src, src_stride, dst, dst_stride,\n+                         filter_x, filter_x_stride,\n+                         filter_y, filter_y_stride, w, h, 8);\n+}\n+\n+void wrap_convolve8_avg_c_8(const uint8_t *src, ptrdiff_t src_stride,\n+                            uint8_t *dst, ptrdiff_t dst_stride,\n+                            const int16_t *filter_x,\n+                            int filter_x_stride,\n+                            const int16_t *filter_y,\n+                            int filter_y_stride,\n+                            int w, int h) {\n+  vpx_highbd_convolve8_avg_c(src, src_stride, dst, dst_stride,\n+                             filter_x, filter_x_stride,\n+                             filter_y, filter_y_stride, w, h, 8);\n+}\n+\n+void wrap_convolve_copy_c_10(const uint8_t *src, ptrdiff_t src_stride,\n+                             uint8_t *dst, ptrdiff_t dst_stride,\n+                             const int16_t *filter_x,\n+                             int filter_x_stride,\n+                             const int16_t *filter_y,\n+                             int filter_y_stride,\n+                             int w, int h) {\n+  vpx_highbd_convolve_copy_c(src, src_stride, dst, dst_stride,\n+                             filter_x, filter_x_stride,\n+                             filter_y, filter_y_stride, w, h, 10);\n+}\n+\n+void wrap_convolve_avg_c_10(const uint8_t *src, ptrdiff_t src_stride,\n+                            uint8_t *dst, ptrdiff_t dst_stride,\n+                            const int16_t *filter_x,\n+                            int filter_x_stride,\n+                            const int16_t *filter_y,\n+                            int filter_y_stride,\n+                            int w, int h) {\n+  vpx_highbd_convolve_avg_c(src, src_stride, dst, dst_stride,\n+                            filter_x, filter_x_stride,\n+                            filter_y, filter_y_stride, w, h, 10);\n+}\n+\n+void wrap_convolve8_horiz_c_10(const uint8_t *src, ptrdiff_t src_stride,\n+                               uint8_t *dst, ptrdiff_t dst_stride,\n+                               const int16_t *filter_x,\n+                               int filter_x_stride,\n+                               const int16_t *filter_y,\n+                               int filter_y_stride,\n+                               int w, int h) {\n+  vpx_highbd_convolve8_horiz_c(src, src_stride, dst, dst_stride,\n+                               filter_x, filter_x_stride,\n+                               filter_y, filter_y_stride, w, h, 10);\n+}\n+\n+void wrap_convolve8_avg_horiz_c_10(const uint8_t *src, ptrdiff_t src_stride,\n+                                   uint8_t *dst, ptrdiff_t dst_stride,\n+                                   const int16_t *filter_x,\n+                                   int filter_x_stride,\n+                                   const int16_t *filter_y,\n+                                   int filter_y_stride,\n+                                   int w, int h) {\n+  vpx_highbd_convolve8_avg_horiz_c(src, src_stride, dst, dst_stride,\n+                                   filter_x, filter_x_stride,\n+                                   filter_y, filter_y_stride, w, h, 10);\n+}\n+\n+void wrap_convolve8_vert_c_10(const uint8_t *src, ptrdiff_t src_stride,\n+                              uint8_t *dst, ptrdiff_t dst_stride,\n+                              const int16_t *filter_x,\n+                              int filter_x_stride,\n+                              const int16_t *filter_y,\n+                              int filter_y_stride,\n+                              int w, int h) {\n+  vpx_highbd_convolve8_vert_c(src, src_stride, dst, dst_stride,\n+                              filter_x, filter_x_stride,\n+                              filter_y, filter_y_stride, w, h, 10);\n+}\n+\n+void wrap_convolve8_avg_vert_c_10(const uint8_t *src, ptrdiff_t src_stride,\n+                                  uint8_t *dst, ptrdiff_t dst_stride,\n+                                  const int16_t *filter_x,\n+                                  int filter_x_stride,\n+                                  const int16_t *filter_y,\n+                                  int filter_y_stride,\n+                                  int w, int h) {\n+  vpx_highbd_convolve8_avg_vert_c(src, src_stride, dst, dst_stride,\n+                                  filter_x, filter_x_stride,\n+                                  filter_y, filter_y_stride, w, h, 10);\n+}\n+\n+void wrap_convolve8_c_10(const uint8_t *src, ptrdiff_t src_stride,\n+                         uint8_t *dst, ptrdiff_t dst_stride,\n+                         const int16_t *filter_x,\n+                         int filter_x_stride,\n+                         const int16_t *filter_y,\n+                         int filter_y_stride,\n+                         int w, int h) {\n+  vpx_highbd_convolve8_c(src, src_stride, dst, dst_stride,\n+                         filter_x, filter_x_stride,\n+                         filter_y, filter_y_stride, w, h, 10);\n+}\n+\n+void wrap_convolve8_avg_c_10(const uint8_t *src, ptrdiff_t src_stride,\n+                             uint8_t *dst, ptrdiff_t dst_stride,\n+                             const int16_t *filter_x,\n+                             int filter_x_stride,\n+                             const int16_t *filter_y,\n+                             int filter_y_stride,\n+                             int w, int h) {\n+  vpx_highbd_convolve8_avg_c(src, src_stride, dst, dst_stride,\n+                             filter_x, filter_x_stride,\n+                             filter_y, filter_y_stride, w, h, 10);\n+}\n+\n+void wrap_convolve_copy_c_12(const uint8_t *src, ptrdiff_t src_stride,\n+                             uint8_t *dst, ptrdiff_t dst_stride,\n+                             const int16_t *filter_x,\n+                             int filter_x_stride,\n+                             const int16_t *filter_y,\n+                             int filter_y_stride,\n+                             int w, int h) {\n+  vpx_highbd_convolve_copy_c(src, src_stride, dst, dst_stride,\n+                             filter_x, filter_x_stride,\n+                             filter_y, filter_y_stride, w, h, 12);\n+}\n+\n+void wrap_convolve_avg_c_12(const uint8_t *src, ptrdiff_t src_stride,\n+                            uint8_t *dst, ptrdiff_t dst_stride,\n+                            const int16_t *filter_x,\n+                            int filter_x_stride,\n+                            const int16_t *filter_y,\n+                            int filter_y_stride,\n+                            int w, int h) {\n+  vpx_highbd_convolve_avg_c(src, src_stride, dst, dst_stride,\n+                            filter_x, filter_x_stride,\n+                            filter_y, filter_y_stride, w, h, 12);\n+}\n+\n+void wrap_convolve8_horiz_c_12(const uint8_t *src, ptrdiff_t src_stride,\n+                               uint8_t *dst, ptrdiff_t dst_stride,\n+                               const int16_t *filter_x,\n+                               int filter_x_stride,\n+                               const int16_t *filter_y,\n+                               int filter_y_stride,\n+                               int w, int h) {\n+  vpx_highbd_convolve8_horiz_c(src, src_stride, dst, dst_stride,\n+                               filter_x, filter_x_stride,\n+                               filter_y, filter_y_stride, w, h, 12);\n+}\n+\n+void wrap_convolve8_avg_horiz_c_12(const uint8_t *src, ptrdiff_t src_stride,\n+                                   uint8_t *dst, ptrdiff_t dst_stride,\n+                                   const int16_t *filter_x,\n+                                   int filter_x_stride,\n+                                   const int16_t *filter_y,\n+                                   int filter_y_stride,\n+                                   int w, int h) {\n+  vpx_highbd_convolve8_avg_horiz_c(src, src_stride, dst, dst_stride,\n+                                   filter_x, filter_x_stride,\n+                                   filter_y, filter_y_stride, w, h, 12);\n+}\n+\n+void wrap_convolve8_vert_c_12(const uint8_t *src, ptrdiff_t src_stride,\n+                              uint8_t *dst, ptrdiff_t dst_stride,\n+                              const int16_t *filter_x,\n+                              int filter_x_stride,\n+                              const int16_t *filter_y,\n+                              int filter_y_stride,\n+                              int w, int h) {\n+  vpx_highbd_convolve8_vert_c(src, src_stride, dst, dst_stride,\n+                              filter_x, filter_x_stride,\n+                              filter_y, filter_y_stride, w, h, 12);\n+}\n+\n+void wrap_convolve8_avg_vert_c_12(const uint8_t *src, ptrdiff_t src_stride,\n+                                  uint8_t *dst, ptrdiff_t dst_stride,\n+                                  const int16_t *filter_x,\n+                                  int filter_x_stride,\n+                                  const int16_t *filter_y,\n+                                  int filter_y_stride,\n+                                  int w, int h) {\n+  vpx_highbd_convolve8_avg_vert_c(src, src_stride, dst, dst_stride,\n+                                  filter_x, filter_x_stride,\n+                                  filter_y, filter_y_stride, w, h, 12);\n+}\n+\n+void wrap_convolve8_c_12(const uint8_t *src, ptrdiff_t src_stride,\n+                         uint8_t *dst, ptrdiff_t dst_stride,\n+                         const int16_t *filter_x,\n+                         int filter_x_stride,\n+                         const int16_t *filter_y,\n+                         int filter_y_stride,\n+                         int w, int h) {\n+  vpx_highbd_convolve8_c(src, src_stride, dst, dst_stride,\n+                         filter_x, filter_x_stride,\n+                         filter_y, filter_y_stride, w, h, 12);\n+}\n+\n+void wrap_convolve8_avg_c_12(const uint8_t *src, ptrdiff_t src_stride,\n+                             uint8_t *dst, ptrdiff_t dst_stride,\n+                             const int16_t *filter_x,\n+                             int filter_x_stride,\n+                             const int16_t *filter_y,\n+                             int filter_y_stride,\n+                             int w, int h) {\n+  vpx_highbd_convolve8_avg_c(src, src_stride, dst, dst_stride,\n+                             filter_x, filter_x_stride,\n+                             filter_y, filter_y_stride, w, h, 12);\n+}\n+\n const ConvolveFunctions convolve8_c(\n-    vp9_convolve8_horiz_c, vp9_convolve8_avg_horiz_c,\n-    vp9_convolve8_vert_c, vp9_convolve8_avg_vert_c,\n-    vp9_convolve8_c, vp9_convolve8_avg_c);\n+    wrap_convolve_copy_c_8, wrap_convolve_avg_c_8,\n+    wrap_convolve8_horiz_c_8, wrap_convolve8_avg_horiz_c_8,\n+    wrap_convolve8_vert_c_8, wrap_convolve8_avg_vert_c_8,\n+    wrap_convolve8_c_8, wrap_convolve8_avg_c_8,\n+    wrap_convolve8_horiz_c_8, wrap_convolve8_avg_horiz_c_8,\n+    wrap_convolve8_vert_c_8, wrap_convolve8_avg_vert_c_8,\n+    wrap_convolve8_c_8, wrap_convolve8_avg_c_8, 8);\n+INSTANTIATE_TEST_CASE_P(C_8, ConvolveTest, ::testing::Values(\n+    make_tuple(4, 4, &convolve8_c),\n+    make_tuple(8, 4, &convolve8_c),\n+    make_tuple(4, 8, &convolve8_c),\n+    make_tuple(8, 8, &convolve8_c),\n+    make_tuple(16, 8, &convolve8_c),\n+    make_tuple(8, 16, &convolve8_c),\n+    make_tuple(16, 16, &convolve8_c),\n+    make_tuple(32, 16, &convolve8_c),\n+    make_tuple(16, 32, &convolve8_c),\n+    make_tuple(32, 32, &convolve8_c),\n+    make_tuple(64, 32, &convolve8_c),\n+    make_tuple(32, 64, &convolve8_c),\n+    make_tuple(64, 64, &convolve8_c)));\n+const ConvolveFunctions convolve10_c(\n+    wrap_convolve_copy_c_10, wrap_convolve_avg_c_10,\n+    wrap_convolve8_horiz_c_10, wrap_convolve8_avg_horiz_c_10,\n+    wrap_convolve8_vert_c_10, wrap_convolve8_avg_vert_c_10,\n+    wrap_convolve8_c_10, wrap_convolve8_avg_c_10,\n+    wrap_convolve8_horiz_c_10, wrap_convolve8_avg_horiz_c_10,\n+    wrap_convolve8_vert_c_10, wrap_convolve8_avg_vert_c_10,\n+    wrap_convolve8_c_10, wrap_convolve8_avg_c_10, 10);\n+INSTANTIATE_TEST_CASE_P(C_10, ConvolveTest, ::testing::Values(\n+    make_tuple(4, 4, &convolve10_c),\n+    make_tuple(8, 4, &convolve10_c),\n+    make_tuple(4, 8, &convolve10_c),\n+    make_tuple(8, 8, &convolve10_c),\n+    make_tuple(16, 8, &convolve10_c),\n+    make_tuple(8, 16, &convolve10_c),\n+    make_tuple(16, 16, &convolve10_c),\n+    make_tuple(32, 16, &convolve10_c),\n+    make_tuple(16, 32, &convolve10_c),\n+    make_tuple(32, 32, &convolve10_c),\n+    make_tuple(64, 32, &convolve10_c),\n+    make_tuple(32, 64, &convolve10_c),\n+    make_tuple(64, 64, &convolve10_c)));\n+const ConvolveFunctions convolve12_c(\n+    wrap_convolve_copy_c_12, wrap_convolve_avg_c_12,\n+    wrap_convolve8_horiz_c_12, wrap_convolve8_avg_horiz_c_12,\n+    wrap_convolve8_vert_c_12, wrap_convolve8_avg_vert_c_12,\n+    wrap_convolve8_c_12, wrap_convolve8_avg_c_12,\n+    wrap_convolve8_horiz_c_12, wrap_convolve8_avg_horiz_c_12,\n+    wrap_convolve8_vert_c_12, wrap_convolve8_avg_vert_c_12,\n+    wrap_convolve8_c_12, wrap_convolve8_avg_c_12, 12);\n+INSTANTIATE_TEST_CASE_P(C_12, ConvolveTest, ::testing::Values(\n+    make_tuple(4, 4, &convolve12_c),\n+    make_tuple(8, 4, &convolve12_c),\n+    make_tuple(4, 8, &convolve12_c),\n+    make_tuple(8, 8, &convolve12_c),\n+    make_tuple(16, 8, &convolve12_c),\n+    make_tuple(8, 16, &convolve12_c),\n+    make_tuple(16, 16, &convolve12_c),\n+    make_tuple(32, 16, &convolve12_c),\n+    make_tuple(16, 32, &convolve12_c),\n+    make_tuple(32, 32, &convolve12_c),\n+    make_tuple(64, 32, &convolve12_c),\n+    make_tuple(32, 64, &convolve12_c),\n+    make_tuple(64, 64, &convolve12_c)));\n+\n+#else\n+\n+const ConvolveFunctions convolve8_c(\n+    vpx_convolve_copy_c, vpx_convolve_avg_c,\n+    vpx_convolve8_horiz_c, vpx_convolve8_avg_horiz_c,\n+    vpx_convolve8_vert_c, vpx_convolve8_avg_vert_c,\n+    vpx_convolve8_c, vpx_convolve8_avg_c,\n+    vpx_scaled_horiz_c, vpx_scaled_avg_horiz_c,\n+    vpx_scaled_vert_c, vpx_scaled_avg_vert_c,\n+    vpx_scaled_2d_c, vpx_scaled_avg_2d_c, 0);\n \n INSTANTIATE_TEST_CASE_P(C, ConvolveTest, ::testing::Values(\n     make_tuple(4, 4, &convolve8_c),\n@@ -598,12 +1558,87 @@\n\n     make_tuple(64, 32, &convolve8_c),\n     make_tuple(32, 64, &convolve8_c),\n     make_tuple(64, 64, &convolve8_c)));\n+#endif\n \n-#if HAVE_SSE2\n+#if HAVE_SSE2 && ARCH_X86_64\n+#if CONFIG_VP9_HIGHBITDEPTH\n const ConvolveFunctions convolve8_sse2(\n-    vp9_convolve8_horiz_sse2, vp9_convolve8_avg_horiz_sse2,\n-    vp9_convolve8_vert_sse2, vp9_convolve8_avg_vert_sse2,\n-    vp9_convolve8_sse2, vp9_convolve8_avg_sse2);\n+    wrap_convolve_copy_c_8, wrap_convolve_avg_c_8,\n+    wrap_convolve8_horiz_sse2_8, wrap_convolve8_avg_horiz_sse2_8,\n+    wrap_convolve8_vert_sse2_8, wrap_convolve8_avg_vert_sse2_8,\n+    wrap_convolve8_sse2_8, wrap_convolve8_avg_sse2_8,\n+    wrap_convolve8_horiz_sse2_8, wrap_convolve8_avg_horiz_sse2_8,\n+    wrap_convolve8_vert_sse2_8, wrap_convolve8_avg_vert_sse2_8,\n+    wrap_convolve8_sse2_8, wrap_convolve8_avg_sse2_8, 8);\n+const ConvolveFunctions convolve10_sse2(\n+    wrap_convolve_copy_c_10, wrap_convolve_avg_c_10,\n+    wrap_convolve8_horiz_sse2_10, wrap_convolve8_avg_horiz_sse2_10,\n+    wrap_convolve8_vert_sse2_10, wrap_convolve8_avg_vert_sse2_10,\n+    wrap_convolve8_sse2_10, wrap_convolve8_avg_sse2_10,\n+    wrap_convolve8_horiz_sse2_10, wrap_convolve8_avg_horiz_sse2_10,\n+    wrap_convolve8_vert_sse2_10, wrap_convolve8_avg_vert_sse2_10,\n+    wrap_convolve8_sse2_10, wrap_convolve8_avg_sse2_10, 10);\n+const ConvolveFunctions convolve12_sse2(\n+    wrap_convolve_copy_c_12, wrap_convolve_avg_c_12,\n+    wrap_convolve8_horiz_sse2_12, wrap_convolve8_avg_horiz_sse2_12,\n+    wrap_convolve8_vert_sse2_12, wrap_convolve8_avg_vert_sse2_12,\n+    wrap_convolve8_sse2_12, wrap_convolve8_avg_sse2_12,\n+    wrap_convolve8_horiz_sse2_12, wrap_convolve8_avg_horiz_sse2_12,\n+    wrap_convolve8_vert_sse2_12, wrap_convolve8_avg_vert_sse2_12,\n+    wrap_convolve8_sse2_12, wrap_convolve8_avg_sse2_12, 12);\n+INSTANTIATE_TEST_CASE_P(SSE2, ConvolveTest, ::testing::Values(\n+    make_tuple(4, 4, &convolve8_sse2),\n+    make_tuple(8, 4, &convolve8_sse2),\n+    make_tuple(4, 8, &convolve8_sse2),\n+    make_tuple(8, 8, &convolve8_sse2),\n+    make_tuple(16, 8, &convolve8_sse2),\n+    make_tuple(8, 16, &convolve8_sse2),\n+    make_tuple(16, 16, &convolve8_sse2),\n+    make_tuple(32, 16, &convolve8_sse2),\n+    make_tuple(16, 32, &convolve8_sse2),\n+    make_tuple(32, 32, &convolve8_sse2),\n+    make_tuple(64, 32, &convolve8_sse2),\n+    make_tuple(32, 64, &convolve8_sse2),\n+    make_tuple(64, 64, &convolve8_sse2),\n+    make_tuple(4, 4, &convolve10_sse2),\n+    make_tuple(8, 4, &convolve10_sse2),\n+    make_tuple(4, 8, &convolve10_sse2),\n+    make_tuple(8, 8, &convolve10_sse2),\n+    make_tuple(16, 8, &convolve10_sse2),\n+    make_tuple(8, 16, &convolve10_sse2),\n+    make_tuple(16, 16, &convolve10_sse2),\n+    make_tuple(32, 16, &convolve10_sse2),\n+    make_tuple(16, 32, &convolve10_sse2),\n+    make_tuple(32, 32, &convolve10_sse2),\n+    make_tuple(64, 32, &convolve10_sse2),\n+    make_tuple(32, 64, &convolve10_sse2),\n+    make_tuple(64, 64, &convolve10_sse2),\n+    make_tuple(4, 4, &convolve12_sse2),\n+    make_tuple(8, 4, &convolve12_sse2),\n+    make_tuple(4, 8, &convolve12_sse2),\n+    make_tuple(8, 8, &convolve12_sse2),\n+    make_tuple(16, 8, &convolve12_sse2),\n+    make_tuple(8, 16, &convolve12_sse2),\n+    make_tuple(16, 16, &convolve12_sse2),\n+    make_tuple(32, 16, &convolve12_sse2),\n+    make_tuple(16, 32, &convolve12_sse2),\n+    make_tuple(32, 32, &convolve12_sse2),\n+    make_tuple(64, 32, &convolve12_sse2),\n+    make_tuple(32, 64, &convolve12_sse2),\n+    make_tuple(64, 64, &convolve12_sse2)));\n+#else\n+const ConvolveFunctions convolve8_sse2(\n+#if CONFIG_USE_X86INC\n+    vpx_convolve_copy_sse2, vpx_convolve_avg_sse2,\n+#else\n+    vpx_convolve_copy_c, vpx_convolve_avg_c,\n+#endif  // CONFIG_USE_X86INC\n+    vpx_convolve8_horiz_sse2, vpx_convolve8_avg_horiz_sse2,\n+    vpx_convolve8_vert_sse2, vpx_convolve8_avg_vert_sse2,\n+    vpx_convolve8_sse2, vpx_convolve8_avg_sse2,\n+    vpx_scaled_horiz_c, vpx_scaled_avg_horiz_c,\n+    vpx_scaled_vert_c, vpx_scaled_avg_vert_c,\n+    vpx_scaled_2d_c, vpx_scaled_avg_2d_c, 0);\n \n INSTANTIATE_TEST_CASE_P(SSE2, ConvolveTest, ::testing::Values(\n     make_tuple(4, 4, &convolve8_sse2),\n@@ -619,13 +1654,18 @@\n\n     make_tuple(64, 32, &convolve8_sse2),\n     make_tuple(32, 64, &convolve8_sse2),\n     make_tuple(64, 64, &convolve8_sse2)));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n #endif\n \n #if HAVE_SSSE3\n const ConvolveFunctions convolve8_ssse3(\n-    vp9_convolve8_horiz_ssse3, vp9_convolve8_avg_horiz_ssse3,\n-    vp9_convolve8_vert_ssse3, vp9_convolve8_avg_vert_ssse3,\n-    vp9_convolve8_ssse3, vp9_convolve8_avg_ssse3);\n+    vpx_convolve_copy_c, vpx_convolve_avg_c,\n+    vpx_convolve8_horiz_ssse3, vpx_convolve8_avg_horiz_ssse3,\n+    vpx_convolve8_vert_ssse3, vpx_convolve8_avg_vert_ssse3,\n+    vpx_convolve8_ssse3, vpx_convolve8_avg_ssse3,\n+    vpx_scaled_horiz_c, vpx_scaled_avg_horiz_c,\n+    vpx_scaled_vert_c, vpx_scaled_avg_vert_c,\n+    vpx_scaled_2d_c, vpx_scaled_avg_2d_c, 0);\n \n INSTANTIATE_TEST_CASE_P(SSSE3, ConvolveTest, ::testing::Values(\n     make_tuple(4, 4, &convolve8_ssse3),\n@@ -643,11 +1683,52 @@\n\n     make_tuple(64, 64, &convolve8_ssse3)));\n #endif\n \n+#if HAVE_AVX2 && HAVE_SSSE3\n+const ConvolveFunctions convolve8_avx2(\n+    vpx_convolve_copy_c, vpx_convolve_avg_c,\n+    vpx_convolve8_horiz_avx2, vpx_convolve8_avg_horiz_ssse3,\n+    vpx_convolve8_vert_avx2, vpx_convolve8_avg_vert_ssse3,\n+    vpx_convolve8_avx2, vpx_convolve8_avg_ssse3,\n+    vpx_scaled_horiz_c, vpx_scaled_avg_horiz_c,\n+    vpx_scaled_vert_c, vpx_scaled_avg_vert_c,\n+    vpx_scaled_2d_c, vpx_scaled_avg_2d_c, 0);\n+\n+INSTANTIATE_TEST_CASE_P(AVX2, ConvolveTest, ::testing::Values(\n+    make_tuple(4, 4, &convolve8_avx2),\n+    make_tuple(8, 4, &convolve8_avx2),\n+    make_tuple(4, 8, &convolve8_avx2),\n+    make_tuple(8, 8, &convolve8_avx2),\n+    make_tuple(8, 16, &convolve8_avx2),\n+    make_tuple(16, 8, &convolve8_avx2),\n+    make_tuple(16, 16, &convolve8_avx2),\n+    make_tuple(32, 16, &convolve8_avx2),\n+    make_tuple(16, 32, &convolve8_avx2),\n+    make_tuple(32, 32, &convolve8_avx2),\n+    make_tuple(64, 32, &convolve8_avx2),\n+    make_tuple(32, 64, &convolve8_avx2),\n+    make_tuple(64, 64, &convolve8_avx2)));\n+#endif  // HAVE_AVX2 && HAVE_SSSE3\n+\n #if HAVE_NEON\n+#if HAVE_NEON_ASM\n const ConvolveFunctions convolve8_neon(\n-    vp9_convolve8_horiz_neon, vp9_convolve8_avg_horiz_neon,\n-    vp9_convolve8_vert_neon, vp9_convolve8_avg_vert_neon,\n-    vp9_convolve8_neon, vp9_convolve8_avg_neon);\n+    vpx_convolve_copy_neon, vpx_convolve_avg_neon,\n+    vpx_convolve8_horiz_neon, vpx_convolve8_avg_horiz_neon,\n+    vpx_convolve8_vert_neon, vpx_convolve8_avg_vert_neon,\n+    vpx_convolve8_neon, vpx_convolve8_avg_neon,\n+    vpx_scaled_horiz_c, vpx_scaled_avg_horiz_c,\n+    vpx_scaled_vert_c, vpx_scaled_avg_vert_c,\n+    vpx_scaled_2d_c, vpx_scaled_avg_2d_c, 0);\n+#else  // HAVE_NEON\n+const ConvolveFunctions convolve8_neon(\n+    vpx_convolve_copy_neon, vpx_convolve_avg_neon,\n+    vpx_convolve8_horiz_neon, vpx_convolve8_avg_horiz_neon,\n+    vpx_convolve8_vert_neon, vpx_convolve8_avg_vert_neon,\n+    vpx_convolve8_neon, vpx_convolve8_avg_neon,\n+    vpx_scaled_horiz_c, vpx_scaled_avg_horiz_c,\n+    vpx_scaled_vert_c, vpx_scaled_avg_vert_c,\n+    vpx_scaled_2d_c, vpx_scaled_avg_2d_c, 0);\n+#endif  // HAVE_NEON_ASM\n \n INSTANTIATE_TEST_CASE_P(NEON, ConvolveTest, ::testing::Values(\n     make_tuple(4, 4, &convolve8_neon),\n@@ -663,13 +1744,17 @@\n\n     make_tuple(64, 32, &convolve8_neon),\n     make_tuple(32, 64, &convolve8_neon),\n     make_tuple(64, 64, &convolve8_neon)));\n-#endif\n+#endif  // HAVE_NEON\n \n #if HAVE_DSPR2\n const ConvolveFunctions convolve8_dspr2(\n-    vp9_convolve8_horiz_dspr2, vp9_convolve8_avg_horiz_dspr2,\n-    vp9_convolve8_vert_dspr2, vp9_convolve8_avg_vert_dspr2,\n-    vp9_convolve8_dspr2, vp9_convolve8_avg_dspr2);\n+    vpx_convolve_copy_dspr2, vpx_convolve_avg_dspr2,\n+    vpx_convolve8_horiz_dspr2, vpx_convolve8_avg_horiz_dspr2,\n+    vpx_convolve8_vert_dspr2, vpx_convolve8_avg_vert_dspr2,\n+    vpx_convolve8_dspr2, vpx_convolve8_avg_dspr2,\n+    vpx_scaled_horiz_c, vpx_scaled_avg_horiz_c,\n+    vpx_scaled_vert_c, vpx_scaled_avg_vert_c,\n+    vpx_scaled_2d_c, vpx_scaled_avg_2d_c, 0);\n \n INSTANTIATE_TEST_CASE_P(DSPR2, ConvolveTest, ::testing::Values(\n     make_tuple(4, 4, &convolve8_dspr2),\n@@ -686,4 +1771,30 @@\n\n     make_tuple(32, 64, &convolve8_dspr2),\n     make_tuple(64, 64, &convolve8_dspr2)));\n #endif\n+\n+#if HAVE_MSA\n+const ConvolveFunctions convolve8_msa(\n+    vpx_convolve_copy_msa, vpx_convolve_avg_msa,\n+    vpx_convolve8_horiz_msa, vpx_convolve8_avg_horiz_msa,\n+    vpx_convolve8_vert_msa, vpx_convolve8_avg_vert_msa,\n+    vpx_convolve8_msa, vpx_convolve8_avg_msa,\n+    vpx_scaled_horiz_c, vpx_scaled_avg_horiz_c,\n+    vpx_scaled_vert_c, vpx_scaled_avg_vert_c,\n+    vpx_scaled_2d_c, vpx_scaled_avg_2d_c, 0);\n+\n+INSTANTIATE_TEST_CASE_P(MSA, ConvolveTest, ::testing::Values(\n+    make_tuple(4, 4, &convolve8_msa),\n+    make_tuple(8, 4, &convolve8_msa),\n+    make_tuple(4, 8, &convolve8_msa),\n+    make_tuple(8, 8, &convolve8_msa),\n+    make_tuple(16, 8, &convolve8_msa),\n+    make_tuple(8, 16, &convolve8_msa),\n+    make_tuple(16, 16, &convolve8_msa),\n+    make_tuple(32, 16, &convolve8_msa),\n+    make_tuple(16, 32, &convolve8_msa),\n+    make_tuple(32, 32, &convolve8_msa),\n+    make_tuple(64, 32, &convolve8_msa),\n+    make_tuple(32, 64, &convolve8_msa),\n+    make_tuple(64, 64, &convolve8_msa)));\n+#endif  // HAVE_MSA\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/cpu_speed_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/cpu_speed_test.cc"", ""patch"": ""@@ -7,45 +7,65 @@\n\n  *  in the file PATENTS.  All contributing project authors may\n  *  be found in the AUTHORS file in the root of the source tree.\n  */\n-#include <climits>\n-#include <vector>\n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n #include \""test/codec_factory.h\""\n #include \""test/encode_test_driver.h\""\n #include \""test/i420_video_source.h\""\n #include \""test/util.h\""\n+#include \""test/y4m_video_source.h\""\n \n namespace {\n \n-class CpuSpeedTest : public ::libvpx_test::EncoderTest,\n-    public ::libvpx_test::CodecTestWith2Params<\n-        libvpx_test::TestMode, int> {\n+const int kMaxPSNR = 100;\n+\n+class CpuSpeedTest\n+    : public ::libvpx_test::EncoderTest,\n+      public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, int> {\n  protected:\n-  CpuSpeedTest() : EncoderTest(GET_PARAM(0)) {}\n+  CpuSpeedTest()\n+      : EncoderTest(GET_PARAM(0)),\n+        encoding_mode_(GET_PARAM(1)),\n+        set_cpu_used_(GET_PARAM(2)),\n+        min_psnr_(kMaxPSNR) {}\n   virtual ~CpuSpeedTest() {}\n \n   virtual void SetUp() {\n     InitializeConfig();\n-    SetMode(GET_PARAM(1));\n-    set_cpu_used_ = GET_PARAM(2);\n+    SetMode(encoding_mode_);\n+    if (encoding_mode_ != ::libvpx_test::kRealTime) {\n+      cfg_.g_lag_in_frames = 25;\n+      cfg_.rc_end_usage = VPX_VBR;\n+    } else {\n+      cfg_.g_lag_in_frames = 0;\n+      cfg_.rc_end_usage = VPX_CBR;\n+    }\n+  }\n+\n+  virtual void BeginPassHook(unsigned int /*pass*/) {\n+    min_psnr_ = kMaxPSNR;\n   }\n \n   virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                   ::libvpx_test::Encoder *encoder) {\n     if (video->frame() == 1) {\n       encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n-      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n-      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n-      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n-      encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n+      if (encoding_mode_ != ::libvpx_test::kRealTime) {\n+        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n+        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n+        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n+        encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n+      }\n     }\n   }\n \n-  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n-    if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) {\n-    }\n+  virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n+    if (pkt->data.psnr.psnr[0] < min_psnr_)\n+      min_psnr_ = pkt->data.psnr.psnr[0];\n   }\n+\n+  ::libvpx_test::TestMode encoding_mode_;\n   int set_cpu_used_;\n+  double min_psnr_;\n };\n \n TEST_P(CpuSpeedTest, TestQ0) {\n@@ -53,7 +73,6 @@\n\n   // without a mismatch when passing in a very low max q.  This pushes\n   // the encoder to producing lots of big partitions which will likely\n   // extend into the border and test the border condition.\n-  cfg_.g_lag_in_frames = 25;\n   cfg_.rc_2pass_vbr_minsection_pct = 5;\n   cfg_.rc_2pass_vbr_minsection_pct = 2000;\n   cfg_.rc_target_bitrate = 400;\n@@ -63,16 +82,32 @@\n\n   ::libvpx_test::I420VideoSource video(\""hantro_odd.yuv\"", 208, 144, 30, 1, 0,\n                                        20);\n \n+  init_flags_ = VPX_CODEC_USE_PSNR;\n+\n   ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+  EXPECT_GE(min_psnr_, kMaxPSNR);\n }\n \n+TEST_P(CpuSpeedTest, TestScreencastQ0) {\n+  ::libvpx_test::Y4mVideoSource video(\""screendata.y4m\"", 0, 25);\n+  cfg_.g_timebase = video.timebase();\n+  cfg_.rc_2pass_vbr_minsection_pct = 5;\n+  cfg_.rc_2pass_vbr_minsection_pct = 2000;\n+  cfg_.rc_target_bitrate = 400;\n+  cfg_.rc_max_quantizer = 0;\n+  cfg_.rc_min_quantizer = 0;\n+\n+  init_flags_ = VPX_CODEC_USE_PSNR;\n+\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+  EXPECT_GE(min_psnr_, kMaxPSNR);\n+}\n \n TEST_P(CpuSpeedTest, TestEncodeHighBitrate) {\n   // Validate that this non multiple of 64 wide clip encodes and decodes\n   // without a mismatch when passing in a very low max q.  This pushes\n   // the encoder to producing lots of big partitions which will likely\n   // extend into the border and test the border condition.\n-  cfg_.g_lag_in_frames = 25;\n   cfg_.rc_2pass_vbr_minsection_pct = 5;\n   cfg_.rc_2pass_vbr_minsection_pct = 2000;\n   cfg_.rc_target_bitrate = 12000;\n@@ -84,12 +119,11 @@\n\n \n   ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n }\n+\n TEST_P(CpuSpeedTest, TestLowBitrate) {\n   // Validate that this clip encodes and decodes without a mismatch\n   // when passing in a very high min q.  This pushes the encoder to producing\n   // lots of small partitions which might will test the other condition.\n-\n-  cfg_.g_lag_in_frames = 25;\n   cfg_.rc_2pass_vbr_minsection_pct = 5;\n   cfg_.rc_2pass_vbr_minsection_pct = 2000;\n   cfg_.rc_target_bitrate = 200;\n@@ -101,13 +135,14 @@\n\n   ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n }\n \n-using std::tr1::make_tuple;\n-\n-#define VP9_FACTORY \\\n-  static_cast<const libvpx_test::CodecFactory*> (&libvpx_test::kVP9)\n-\n VP9_INSTANTIATE_TEST_CASE(\n     CpuSpeedTest,\n+    ::testing::Values(::libvpx_test::kTwoPassGood, ::libvpx_test::kOnePassGood,\n+                      ::libvpx_test::kRealTime),\n+    ::testing::Range(0, 9));\n+\n+VP10_INSTANTIATE_TEST_CASE(\n+    CpuSpeedTest,\n     ::testing::Values(::libvpx_test::kTwoPassGood, ::libvpx_test::kOnePassGood),\n-    ::testing::Range(0, 8));\n+    ::testing::Range(0, 3));\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/cq_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/cq_test.cc"", ""patch"": ""@@ -8,6 +8,7 @@\n\n  *  be found in the AUTHORS file in the root of the source tree.\n  */\n #include <cmath>\n+#include <map>\n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n #include \""test/codec_factory.h\""\n #include \""test/encode_test_driver.h\""\n@@ -24,6 +25,28 @@\n\n \n class CQTest : public ::libvpx_test::EncoderTest,\n     public ::libvpx_test::CodecTestWithParam<int> {\n+ public:\n+  // maps the cqlevel to the bitrate produced.\n+  typedef std::map<int, uint32_t> BitrateMap;\n+\n+  static void SetUpTestCase() {\n+    bitrates_.clear();\n+  }\n+\n+  static void TearDownTestCase() {\n+    ASSERT_TRUE(!HasFailure())\n+        << \""skipping bitrate validation due to earlier failure.\"";\n+    uint32_t prev_actual_bitrate = kCQTargetBitrate;\n+    for (BitrateMap::const_iterator iter = bitrates_.begin();\n+         iter != bitrates_.end(); ++iter) {\n+      const uint32_t cq_actual_bitrate = iter->second;\n+      EXPECT_LE(cq_actual_bitrate, prev_actual_bitrate)\n+          << \""cq_level: \"" << iter->first\n+          << \"", bitrate should decrease with increase in CQ level.\"";\n+      prev_actual_bitrate = cq_actual_bitrate;\n+    }\n+  }\n+\n  protected:\n   CQTest() : EncoderTest(GET_PARAM(0)), cq_level_(GET_PARAM(1)) {\n     init_flags_ = VPX_CODEC_USE_PSNR;\n@@ -66,9 +89,12 @@\n\n     return pow(10.0, avg_psnr / 10.0) / file_size_;\n   }\n \n+  int cq_level() const { return cq_level_; }\n   size_t file_size() const { return file_size_; }\n   int n_frames() const { return n_frames_; }\n \n+  static BitrateMap bitrates_;\n+\n  private:\n   int cq_level_;\n   size_t file_size_;\n@@ -76,7 +102,8 @@\n\n   int n_frames_;\n };\n \n-unsigned int prev_actual_bitrate = kCQTargetBitrate;\n+CQTest::BitrateMap CQTest::bitrates_;\n+\n TEST_P(CQTest, LinearPSNRIsHigherForCQLevel) {\n   const vpx_rational timebase = { 33333333, 1000000000 };\n   cfg_.g_timebase = timebase;\n@@ -91,8 +118,7 @@\n\n   const unsigned int cq_actual_bitrate =\n       static_cast<unsigned int>(file_size()) * 8 * 30 / (n_frames() * 1000);\n   EXPECT_LE(cq_actual_bitrate, kCQTargetBitrate);\n-  EXPECT_LE(cq_actual_bitrate, prev_actual_bitrate);\n-  prev_actual_bitrate = cq_actual_bitrate;\n+  bitrates_[cq_level()] = cq_actual_bitrate;\n \n   // try targeting the approximate same bitrate with VBR mode\n   cfg_.rc_end_usage = VPX_VBR;\n""}<_**next**_>{""filename"": ""libvpx/test/datarate_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/datarate_test.cc"", ""patch"": ""@@ -14,6 +14,7 @@\n\n #include \""test/i420_video_source.h\""\n #include \""test/util.h\""\n #include \""test/y4m_video_source.h\""\n+#include \""vpx/vpx_codec.h\""\n \n namespace {\n \n@@ -38,10 +39,25 @@\n\n     first_drop_ = 0;\n     bits_total_ = 0;\n     duration_ = 0.0;\n+    denoiser_offon_test_ = 0;\n+    denoiser_offon_period_ = -1;\n   }\n \n   virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                   ::libvpx_test::Encoder *encoder) {\n+    if (video->frame() == 0)\n+      encoder->Control(VP8E_SET_NOISE_SENSITIVITY, denoiser_on_);\n+\n+    if (denoiser_offon_test_) {\n+      ASSERT_GT(denoiser_offon_period_, 0)\n+          << \""denoiser_offon_period_ is not positive.\"";\n+      if ((video->frame() + 1) % denoiser_offon_period_ == 0) {\n+        // Flip denoiser_on_ periodically\n+        denoiser_on_ ^= 1;\n+      }\n+      encoder->Control(VP8E_SET_NOISE_SENSITIVITY, denoiser_on_);\n+    }\n+\n     const vpx_rational_t tb = video->timebase();\n     timebase_ = static_cast<double>(tb.num) / tb.den;\n     duration_ = 0;\n@@ -120,9 +136,67 @@\n\n   double file_datarate_;\n   double effective_datarate_;\n   size_t bits_in_last_frame_;\n+  int denoiser_on_;\n+  int denoiser_offon_test_;\n+  int denoiser_offon_period_;\n };\n \n+#if CONFIG_TEMPORAL_DENOISING\n+// Check basic datarate targeting, for a single bitrate, but loop over the\n+// various denoiser settings.\n+TEST_P(DatarateTestLarge, DenoiserLevels) {\n+  cfg_.rc_buf_initial_sz = 500;\n+  cfg_.rc_dropframe_thresh = 1;\n+  cfg_.rc_max_quantizer = 56;\n+  cfg_.rc_end_usage = VPX_CBR;\n+  ::libvpx_test::I420VideoSource video(\""hantro_collage_w352h288.yuv\"", 352, 288,\n+                                       30, 1, 0, 140);\n+  for (int j = 1; j < 5; ++j) {\n+    // Run over the denoiser levels.\n+    // For the temporal denoiser (#if CONFIG_TEMPORAL_DENOISING) the level j\n+    // refers to the 4 denoiser modes: denoiserYonly, denoiserOnYUV,\n+    // denoiserOnAggressive, and denoiserOnAdaptive.\n+    // For the spatial denoiser (if !CONFIG_TEMPORAL_DENOISING), the level j\n+    // refers to the blur thresholds: 20, 40, 60 80.\n+    // The j = 0 case (denoiser off) is covered in the tests below.\n+    denoiser_on_ = j;\n+    cfg_.rc_target_bitrate = 300;\n+    ResetModel();\n+    ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+    ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_ * 0.95)\n+        << \"" The datarate for the file exceeds the target!\"";\n+\n+    ASSERT_LE(cfg_.rc_target_bitrate, file_datarate_ * 1.3)\n+        << \"" The datarate for the file missed the target!\"";\n+  }\n+}\n+\n+// Check basic datarate targeting, for a single bitrate, when denoiser is off\n+// and on.\n+TEST_P(DatarateTestLarge, DenoiserOffOn) {\n+  cfg_.rc_buf_initial_sz = 500;\n+  cfg_.rc_dropframe_thresh = 1;\n+  cfg_.rc_max_quantizer = 56;\n+  cfg_.rc_end_usage = VPX_CBR;\n+  ::libvpx_test::I420VideoSource video(\""hantro_collage_w352h288.yuv\"", 352, 288,\n+                                       30, 1, 0, 299);\n+  cfg_.rc_target_bitrate = 300;\n+  ResetModel();\n+  // The denoiser is off by default.\n+  denoiser_on_ = 0;\n+  // Set the offon test flag.\n+  denoiser_offon_test_ = 1;\n+  denoiser_offon_period_ = 100;\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+  ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_ * 0.95)\n+      << \"" The datarate for the file exceeds the target!\"";\n+  ASSERT_LE(cfg_.rc_target_bitrate, file_datarate_ * 1.3)\n+      << \"" The datarate for the file missed the target!\"";\n+}\n+#endif  // CONFIG_TEMPORAL_DENOISING\n+\n TEST_P(DatarateTestLarge, BasicBufferModel) {\n+  denoiser_on_ = 0;\n   cfg_.rc_buf_initial_sz = 500;\n   cfg_.rc_dropframe_thresh = 1;\n   cfg_.rc_max_quantizer = 56;\n@@ -145,7 +219,7 @@\n\n     cfg_.rc_target_bitrate = i;\n     ResetModel();\n     ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n-    ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_)\n+    ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_ * 0.95)\n         << \"" The datarate for the file exceeds the target!\"";\n \n     ASSERT_LE(cfg_.rc_target_bitrate, file_datarate_ * 1.3)\n@@ -154,6 +228,7 @@\n\n }\n \n TEST_P(DatarateTestLarge, ChangingDropFrameThresh) {\n+  denoiser_on_ = 0;\n   cfg_.rc_buf_initial_sz = 500;\n   cfg_.rc_max_quantizer = 36;\n   cfg_.rc_end_usage = VPX_CBR;\n@@ -203,10 +278,14 @@\n\n     tot_frame_number_ = 0;\n     first_drop_ = 0;\n     num_drops_ = 0;\n+    // Denoiser is off by default.\n+    denoiser_on_ = 0;\n     // For testing up to 3 layers.\n     for (int i = 0; i < 3; ++i) {\n       bits_total_[i] = 0;\n     }\n+    denoiser_offon_test_ = 0;\n+    denoiser_offon_period_ = -1;\n   }\n \n   //\n@@ -274,21 +353,30 @@\n\n \n   virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                   ::libvpx_test::Encoder *encoder) {\n-    if (video->frame() == 1) {\n+    if (video->frame() == 0)\n       encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n+\n+    if (denoiser_offon_test_) {\n+      ASSERT_GT(denoiser_offon_period_, 0)\n+          << \""denoiser_offon_period_ is not positive.\"";\n+      if ((video->frame() + 1) % denoiser_offon_period_ == 0) {\n+        // Flip denoiser_on_ periodically\n+        denoiser_on_ ^= 1;\n+      }\n     }\n+\n+    encoder->Control(VP9E_SET_NOISE_SENSITIVITY, denoiser_on_);\n+\n     if (cfg_.ts_number_layers > 1) {\n-      if (video->frame() == 1) {\n+      if (video->frame() == 0) {\n         encoder->Control(VP9E_SET_SVC, 1);\n       }\n-      vpx_svc_layer_id_t layer_id = {0, 0};\n+      vpx_svc_layer_id_t layer_id;\n       layer_id.spatial_layer_id = 0;\n       frame_flags_ = SetFrameFlags(video->frame(), cfg_.ts_number_layers);\n       layer_id.temporal_layer_id = SetLayerId(video->frame(),\n                                               cfg_.ts_number_layers);\n-      if (video->frame() > 0) {\n-       encoder->Control(VP9E_SET_SVC_LAYER_ID, &layer_id);\n-      }\n+      encoder->Control(VP9E_SET_SVC_LAYER_ID, &layer_id);\n     }\n     const vpx_rational_t tb = video->timebase();\n     timebase_ = static_cast<double>(tb.num) / tb.den;\n@@ -357,6 +445,9 @@\n\n   int64_t bits_in_buffer_model_;\n   vpx_codec_pts_t first_drop_;\n   int num_drops_;\n+  int denoiser_on_;\n+  int denoiser_offon_test_;\n+  int denoiser_offon_period_;\n };\n \n // Check basic rate targeting,\n@@ -447,7 +538,7 @@\n\n         << \"" The first dropped frame for drop_thresh \"" << i\n         << \"" > first dropped frame for drop_thresh \""\n         << i - kDropFrameThreshTestStep;\n-    ASSERT_GE(num_drops_, last_num_drops)\n+    ASSERT_GE(num_drops_, last_num_drops * 0.90)\n         << \"" The number of dropped frames for drop_thresh \"" << i\n         << \"" < number of dropped frames for drop_thresh \""\n         << i - kDropFrameThreshTestStep;\n@@ -473,20 +564,25 @@\n\n   cfg_.ts_rate_decimator[0] = 2;\n   cfg_.ts_rate_decimator[1] = 1;\n \n+  cfg_.temporal_layering_mode = VP9E_TEMPORAL_LAYERING_MODE_BYPASS;\n+\n+  if (deadline_ == VPX_DL_REALTIME)\n+    cfg_.g_error_resilient = 1;\n+\n   ::libvpx_test::I420VideoSource video(\""hantro_collage_w352h288.yuv\"", 352, 288,\n                                        30, 1, 0, 200);\n   for (int i = 200; i <= 800; i += 200) {\n     cfg_.rc_target_bitrate = i;\n     ResetModel();\n     // 60-40 bitrate allocation for 2 temporal layers.\n-    cfg_.ts_target_bitrate[0] = 60 * cfg_.rc_target_bitrate / 100;\n-    cfg_.ts_target_bitrate[1] = cfg_.rc_target_bitrate;\n+    cfg_.layer_target_bitrate[0] = 60 * cfg_.rc_target_bitrate / 100;\n+    cfg_.layer_target_bitrate[1] = cfg_.rc_target_bitrate;\n     ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n     for (int j = 0; j < static_cast<int>(cfg_.ts_number_layers); ++j) {\n-      ASSERT_GE(effective_datarate_[j], cfg_.ts_target_bitrate[j] * 0.85)\n+      ASSERT_GE(effective_datarate_[j], cfg_.layer_target_bitrate[j] * 0.85)\n           << \"" The datarate for the file is lower than target by too much, \""\n               \""for layer: \"" << j;\n-      ASSERT_LE(effective_datarate_[j], cfg_.ts_target_bitrate[j] * 1.15)\n+      ASSERT_LE(effective_datarate_[j], cfg_.layer_target_bitrate[j] * 1.15)\n           << \"" The datarate for the file is greater than target by too much, \""\n               \""for layer: \"" << j;\n     }\n@@ -511,21 +607,27 @@\n\n   cfg_.ts_rate_decimator[1] = 2;\n   cfg_.ts_rate_decimator[2] = 1;\n \n+  cfg_.temporal_layering_mode = VP9E_TEMPORAL_LAYERING_MODE_BYPASS;\n+\n   ::libvpx_test::I420VideoSource video(\""hantro_collage_w352h288.yuv\"", 352, 288,\n                                        30, 1, 0, 200);\n   for (int i = 200; i <= 800; i += 200) {\n     cfg_.rc_target_bitrate = i;\n     ResetModel();\n     // 40-20-40 bitrate allocation for 3 temporal layers.\n-    cfg_.ts_target_bitrate[0] = 40 * cfg_.rc_target_bitrate / 100;\n-    cfg_.ts_target_bitrate[1] = 60 * cfg_.rc_target_bitrate / 100;\n-    cfg_.ts_target_bitrate[2] = cfg_.rc_target_bitrate;\n+    cfg_.layer_target_bitrate[0] = 40 * cfg_.rc_target_bitrate / 100;\n+    cfg_.layer_target_bitrate[1] = 60 * cfg_.rc_target_bitrate / 100;\n+    cfg_.layer_target_bitrate[2] = cfg_.rc_target_bitrate;\n     ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n     for (int j = 0; j < static_cast<int>(cfg_.ts_number_layers); ++j) {\n-      ASSERT_GE(effective_datarate_[j], cfg_.ts_target_bitrate[j] * 0.85)\n+      // TODO(yaowu): Work out more stable rc control strategy and\n+      //              Adjust the thresholds to be tighter than .75.\n+      ASSERT_GE(effective_datarate_[j], cfg_.layer_target_bitrate[j] * 0.75)\n           << \"" The datarate for the file is lower than target by too much, \""\n               \""for layer: \"" << j;\n-      ASSERT_LE(effective_datarate_[j], cfg_.ts_target_bitrate[j] * 1.15)\n+      // TODO(yaowu): Work out more stable rc control strategy and\n+      //              Adjust the thresholds to be tighter than 1.25.\n+      ASSERT_LE(effective_datarate_[j], cfg_.layer_target_bitrate[j] * 1.25)\n           << \"" The datarate for the file is greater than target by too much, \""\n               \""for layer: \"" << j;\n     }\n@@ -553,32 +655,324 @@\n\n   cfg_.ts_rate_decimator[1] = 2;\n   cfg_.ts_rate_decimator[2] = 1;\n \n+  cfg_.temporal_layering_mode = VP9E_TEMPORAL_LAYERING_MODE_BYPASS;\n+\n   ::libvpx_test::I420VideoSource video(\""hantro_collage_w352h288.yuv\"", 352, 288,\n                                        30, 1, 0, 200);\n   cfg_.rc_target_bitrate = 200;\n   ResetModel();\n   // 40-20-40 bitrate allocation for 3 temporal layers.\n-  cfg_.ts_target_bitrate[0] = 40 * cfg_.rc_target_bitrate / 100;\n-  cfg_.ts_target_bitrate[1] = 60 * cfg_.rc_target_bitrate / 100;\n-  cfg_.ts_target_bitrate[2] = cfg_.rc_target_bitrate;\n+  cfg_.layer_target_bitrate[0] = 40 * cfg_.rc_target_bitrate / 100;\n+  cfg_.layer_target_bitrate[1] = 60 * cfg_.rc_target_bitrate / 100;\n+  cfg_.layer_target_bitrate[2] = cfg_.rc_target_bitrate;\n   ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n   for (int j = 0; j < static_cast<int>(cfg_.ts_number_layers); ++j) {\n-    ASSERT_GE(effective_datarate_[j], cfg_.ts_target_bitrate[j] * 0.85)\n+    ASSERT_GE(effective_datarate_[j], cfg_.layer_target_bitrate[j] * 0.85)\n         << \"" The datarate for the file is lower than target by too much, \""\n             \""for layer: \"" << j;\n-    ASSERT_LE(effective_datarate_[j], cfg_.ts_target_bitrate[j] * 1.15)\n+    ASSERT_LE(effective_datarate_[j], cfg_.layer_target_bitrate[j] * 1.15)\n         << \"" The datarate for the file is greater than target by too much, \""\n             \""for layer: \"" << j;\n     // Expect some frame drops in this test: for this 200 frames test,\n     // expect at least 10% and not more than 60% drops.\n     ASSERT_GE(num_drops_, 20);\n-    ASSERT_LE(num_drops_, 120);\n+    ASSERT_LE(num_drops_, 130);\n   }\n }\n \n+#if CONFIG_VP9_TEMPORAL_DENOISING\n+// Check basic datarate targeting, for a single bitrate, when denoiser is on.\n+TEST_P(DatarateTestVP9Large, DenoiserLevels) {\n+  cfg_.rc_buf_initial_sz = 500;\n+  cfg_.rc_buf_optimal_sz = 500;\n+  cfg_.rc_buf_sz = 1000;\n+  cfg_.rc_dropframe_thresh = 1;\n+  cfg_.rc_min_quantizer = 2;\n+  cfg_.rc_max_quantizer = 56;\n+  cfg_.rc_end_usage = VPX_CBR;\n+  cfg_.g_lag_in_frames = 0;\n+\n+  ::libvpx_test::I420VideoSource video(\""hantro_collage_w352h288.yuv\"", 352, 288,\n+                                       30, 1, 0, 140);\n+\n+  // For the temporal denoiser (#if CONFIG_VP9_TEMPORAL_DENOISING),\n+  // there is only one denoiser mode: denoiserYonly(which is 1),\n+  // but may add more modes in the future.\n+  cfg_.rc_target_bitrate = 300;\n+  ResetModel();\n+  // Turn on the denoiser.\n+  denoiser_on_ = 1;\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+  ASSERT_GE(effective_datarate_[0], cfg_.rc_target_bitrate * 0.85)\n+      << \"" The datarate for the file is lower than target by too much!\"";\n+  ASSERT_LE(effective_datarate_[0], cfg_.rc_target_bitrate * 1.15)\n+      << \"" The datarate for the file is greater than target by too much!\"";\n+}\n+\n+// Check basic datarate targeting, for a single bitrate, when denoiser is off\n+// and on.\n+TEST_P(DatarateTestVP9Large, DenoiserOffOn) {\n+  cfg_.rc_buf_initial_sz = 500;\n+  cfg_.rc_buf_optimal_sz = 500;\n+  cfg_.rc_buf_sz = 1000;\n+  cfg_.rc_dropframe_thresh = 1;\n+  cfg_.rc_min_quantizer = 2;\n+  cfg_.rc_max_quantizer = 56;\n+  cfg_.rc_end_usage = VPX_CBR;\n+  cfg_.g_lag_in_frames = 0;\n+\n+  ::libvpx_test::I420VideoSource video(\""hantro_collage_w352h288.yuv\"", 352, 288,\n+                                       30, 1, 0, 299);\n+\n+  // For the temporal denoiser (#if CONFIG_VP9_TEMPORAL_DENOISING),\n+  // there is only one denoiser mode: denoiserYonly(which is 1),\n+  // but may add more modes in the future.\n+  cfg_.rc_target_bitrate = 300;\n+  ResetModel();\n+  // The denoiser is off by default.\n+  denoiser_on_ = 0;\n+  // Set the offon test flag.\n+  denoiser_offon_test_ = 1;\n+  denoiser_offon_period_ = 100;\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+  ASSERT_GE(effective_datarate_[0], cfg_.rc_target_bitrate * 0.85)\n+      << \"" The datarate for the file is lower than target by too much!\"";\n+  ASSERT_LE(effective_datarate_[0], cfg_.rc_target_bitrate * 1.15)\n+      << \"" The datarate for the file is greater than target by too much!\"";\n+}\n+#endif  // CONFIG_VP9_TEMPORAL_DENOISING\n+\n+class DatarateOnePassCbrSvc : public ::libvpx_test::EncoderTest,\n+    public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, int> {\n+ public:\n+  DatarateOnePassCbrSvc() : EncoderTest(GET_PARAM(0)) {}\n+  virtual ~DatarateOnePassCbrSvc() {}\n+ protected:\n+  virtual void SetUp() {\n+    InitializeConfig();\n+    SetMode(GET_PARAM(1));\n+    speed_setting_ = GET_PARAM(2);\n+    ResetModel();\n+  }\n+  virtual void ResetModel() {\n+    last_pts_ = 0;\n+    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;\n+    frame_number_ = 0;\n+    first_drop_ = 0;\n+    bits_total_ = 0;\n+    duration_ = 0.0;\n+    mismatch_psnr_ = 0.0;\n+    mismatch_nframes_ = 0;\n+  }\n+  virtual void BeginPassHook(unsigned int /*pass*/) {\n+  }\n+  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n+                                  ::libvpx_test::Encoder *encoder) {\n+    if (video->frame() == 0) {\n+      int i;\n+      for (i = 0; i < 2; ++i) {\n+        svc_params_.max_quantizers[i] = 63;\n+        svc_params_.min_quantizers[i] = 0;\n+      }\n+      svc_params_.scaling_factor_num[0] = 144;\n+      svc_params_.scaling_factor_den[0] = 288;\n+      svc_params_.scaling_factor_num[1] = 288;\n+      svc_params_.scaling_factor_den[1] = 288;\n+      encoder->Control(VP9E_SET_SVC, 1);\n+      encoder->Control(VP9E_SET_SVC_PARAMETERS, &svc_params_);\n+      encoder->Control(VP8E_SET_CPUUSED, speed_setting_);\n+      encoder->Control(VP9E_SET_TILE_COLUMNS, 0);\n+      encoder->Control(VP8E_SET_MAX_INTRA_BITRATE_PCT, 300);\n+      encoder->Control(VP9E_SET_TILE_COLUMNS, (cfg_.g_threads >> 1));\n+    }\n+    const vpx_rational_t tb = video->timebase();\n+    timebase_ = static_cast<double>(tb.num) / tb.den;\n+    duration_ = 0;\n+  }\n+  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n+    vpx_codec_pts_t duration = pkt->data.frame.pts - last_pts_;\n+    if (last_pts_ == 0)\n+      duration = 1;\n+    bits_in_buffer_model_ += static_cast<int64_t>(\n+        duration * timebase_ * cfg_.rc_target_bitrate * 1000);\n+    const bool key_frame = (pkt->data.frame.flags & VPX_FRAME_IS_KEY)\n+                         ? true: false;\n+    if (!key_frame) {\n+      ASSERT_GE(bits_in_buffer_model_, 0) << \""Buffer Underrun at frame \""\n+          << pkt->data.frame.pts;\n+    }\n+    const size_t frame_size_in_bits = pkt->data.frame.sz * 8;\n+    bits_in_buffer_model_ -= frame_size_in_bits;\n+    bits_total_ += frame_size_in_bits;\n+    if (!first_drop_ && duration > 1)\n+      first_drop_ = last_pts_ + 1;\n+    last_pts_ = pkt->data.frame.pts;\n+    bits_in_last_frame_ = frame_size_in_bits;\n+    ++frame_number_;\n+  }\n+  virtual void EndPassHook(void) {\n+    if (bits_total_) {\n+      const double file_size_in_kb = bits_total_ / 1000.;  // bits per kilobit\n+      duration_ = (last_pts_ + 1) * timebase_;\n+      effective_datarate_ = (bits_total_ - bits_in_last_frame_) / 1000.0\n+          / (cfg_.rc_buf_initial_sz / 1000.0 + duration_);\n+      file_datarate_ = file_size_in_kb / duration_;\n+    }\n+  }\n+\n+  virtual void MismatchHook(const vpx_image_t *img1,\n+                            const vpx_image_t *img2) {\n+    double mismatch_psnr = compute_psnr(img1, img2);\n+    mismatch_psnr_ += mismatch_psnr;\n+    ++mismatch_nframes_;\n+  }\n+\n+  unsigned int GetMismatchFrames() {\n+    return mismatch_nframes_;\n+  }\n+\n+  vpx_codec_pts_t last_pts_;\n+  int64_t bits_in_buffer_model_;\n+  double timebase_;\n+  int frame_number_;\n+  vpx_codec_pts_t first_drop_;\n+  int64_t bits_total_;\n+  double duration_;\n+  double file_datarate_;\n+  double effective_datarate_;\n+  size_t bits_in_last_frame_;\n+  vpx_svc_extra_cfg_t svc_params_;\n+  int speed_setting_;\n+  double mismatch_psnr_;\n+  int mismatch_nframes_;\n+};\n+static void assign_layer_bitrates(vpx_codec_enc_cfg_t *const enc_cfg,\n+    const vpx_svc_extra_cfg_t *svc_params,\n+    int spatial_layers,\n+    int temporal_layers,\n+    int temporal_layering_mode,\n+    unsigned int total_rate) {\n+  int sl, spatial_layer_target;\n+  float total = 0;\n+  float alloc_ratio[VPX_MAX_LAYERS] = {0};\n+  for (sl = 0; sl < spatial_layers; ++sl) {\n+    if (svc_params->scaling_factor_den[sl] > 0) {\n+      alloc_ratio[sl] = (float)(svc_params->scaling_factor_num[sl] *\n+          1.0 / svc_params->scaling_factor_den[sl]);\n+      total += alloc_ratio[sl];\n+    }\n+  }\n+  for (sl = 0; sl < spatial_layers; ++sl) {\n+    enc_cfg->ss_target_bitrate[sl] = spatial_layer_target =\n+        (unsigned int)(enc_cfg->rc_target_bitrate *\n+            alloc_ratio[sl] / total);\n+    const int index = sl * temporal_layers;\n+    if (temporal_layering_mode == 3) {\n+      enc_cfg->layer_target_bitrate[index] =\n+          spatial_layer_target >> 1;\n+      enc_cfg->layer_target_bitrate[index + 1] =\n+          (spatial_layer_target >> 1) + (spatial_layer_target >> 2);\n+      enc_cfg->layer_target_bitrate[index + 2] =\n+          spatial_layer_target;\n+    } else if (temporal_layering_mode == 2) {\n+      enc_cfg->layer_target_bitrate[index] =\n+          spatial_layer_target * 2 / 3;\n+      enc_cfg->layer_target_bitrate[index + 1] =\n+          spatial_layer_target;\n+    }\n+  }\n+}\n+\n+// Check basic rate targeting for 1 pass CBR SVC: 2 spatial layers and\n+// 3 temporal layers. Run CIF clip with 1 thread.\n+TEST_P(DatarateOnePassCbrSvc, OnePassCbrSvc) {\n+  cfg_.rc_buf_initial_sz = 500;\n+  cfg_.rc_buf_optimal_sz = 500;\n+  cfg_.rc_buf_sz = 1000;\n+  cfg_.rc_min_quantizer = 0;\n+  cfg_.rc_max_quantizer = 63;\n+  cfg_.rc_end_usage = VPX_CBR;\n+  cfg_.g_lag_in_frames = 0;\n+  cfg_.ss_number_layers = 2;\n+  cfg_.ts_number_layers = 3;\n+  cfg_.ts_rate_decimator[0] = 4;\n+  cfg_.ts_rate_decimator[1] = 2;\n+  cfg_.ts_rate_decimator[2] = 1;\n+  cfg_.g_error_resilient = 1;\n+  cfg_.g_threads = 1;\n+  cfg_.temporal_layering_mode = 3;\n+  svc_params_.scaling_factor_num[0] = 144;\n+  svc_params_.scaling_factor_den[0] = 288;\n+  svc_params_.scaling_factor_num[1] = 288;\n+  svc_params_.scaling_factor_den[1] = 288;\n+  // TODO(wonkap/marpan): No frame drop for now, we need to implement correct\n+  // frame dropping for SVC.\n+  cfg_.rc_dropframe_thresh = 0;\n+  ::libvpx_test::I420VideoSource video(\""hantro_collage_w352h288.yuv\"", 352, 288,\n+                                       30, 1, 0, 200);\n+  // TODO(wonkap/marpan): Check that effective_datarate for each layer hits the\n+  // layer target_bitrate. Also check if test can pass at lower bitrate (~200k).\n+  for (int i = 400; i <= 800; i += 200) {\n+    cfg_.rc_target_bitrate = i;\n+    ResetModel();\n+    assign_layer_bitrates(&cfg_, &svc_params_, cfg_.ss_number_layers,\n+        cfg_.ts_number_layers, cfg_.temporal_layering_mode,\n+        cfg_.rc_target_bitrate);\n+    ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+    ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_ * 0.85)\n+            << \"" The datarate for the file exceeds the target by too much!\"";\n+    ASSERT_LE(cfg_.rc_target_bitrate, file_datarate_ * 1.15)\n+        << \"" The datarate for the file is lower than the target by too much!\"";\n+    EXPECT_EQ(GetMismatchFrames(), (unsigned int) 0);\n+  }\n+}\n+\n+// Check basic rate targeting for 1 pass CBR SVC: 2 spatial layers and\n+// 3 temporal layers. Run HD clip with 4 threads.\n+TEST_P(DatarateOnePassCbrSvc, OnePassCbrSvc4threads) {\n+  cfg_.rc_buf_initial_sz = 500;\n+  cfg_.rc_buf_optimal_sz = 500;\n+  cfg_.rc_buf_sz = 1000;\n+  cfg_.rc_min_quantizer = 0;\n+  cfg_.rc_max_quantizer = 63;\n+  cfg_.rc_end_usage = VPX_CBR;\n+  cfg_.g_lag_in_frames = 0;\n+  cfg_.ss_number_layers = 2;\n+  cfg_.ts_number_layers = 3;\n+  cfg_.ts_rate_decimator[0] = 4;\n+  cfg_.ts_rate_decimator[1] = 2;\n+  cfg_.ts_rate_decimator[2] = 1;\n+  cfg_.g_error_resilient = 1;\n+  cfg_.g_threads = 4;\n+  cfg_.temporal_layering_mode = 3;\n+  svc_params_.scaling_factor_num[0] = 144;\n+  svc_params_.scaling_factor_den[0] = 288;\n+  svc_params_.scaling_factor_num[1] = 288;\n+  svc_params_.scaling_factor_den[1] = 288;\n+  // TODO(wonkap/marpan): No frame drop for now, we need to implement correct\n+  // frame dropping for SVC.\n+  cfg_.rc_dropframe_thresh = 0;\n+  ::libvpx_test::I420VideoSource video(\""niklas_1280_720_30.y4m\"", 1280, 720,\n+                                       30, 1, 0, 300);\n+  cfg_.rc_target_bitrate = 800;\n+  ResetModel();\n+  assign_layer_bitrates(&cfg_, &svc_params_, cfg_.ss_number_layers,\n+      cfg_.ts_number_layers, cfg_.temporal_layering_mode,\n+      cfg_.rc_target_bitrate);\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+  ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_ * 0.85)\n+          << \"" The datarate for the file exceeds the target by too much!\"";\n+  ASSERT_LE(cfg_.rc_target_bitrate, file_datarate_ * 1.15)\n+      << \"" The datarate for the file is lower than the target by too much!\"";\n+  EXPECT_EQ(GetMismatchFrames(), (unsigned int) 0);\n+}\n+\n VP8_INSTANTIATE_TEST_CASE(DatarateTestLarge, ALL_TEST_MODES);\n VP9_INSTANTIATE_TEST_CASE(DatarateTestVP9Large,\n                           ::testing::Values(::libvpx_test::kOnePassGood,\n-                          ::libvpx_test::kRealTime),\n+                                            ::libvpx_test::kRealTime),\n                           ::testing::Range(2, 7));\n+VP9_INSTANTIATE_TEST_CASE(DatarateOnePassCbrSvc,\n+                          ::testing::Values(::libvpx_test::kRealTime),\n+                          ::testing::Range(5, 8));\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/dct16x16_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/dct16x16_test.cc"", ""patch"": ""@@ -13,18 +13,18 @@\n\n #include <string.h>\n \n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vp9_rtcd.h\""\n+#include \""./vpx_dsp_rtcd.h\""\n #include \""test/acm_random.h\""\n #include \""test/clear_system_state.h\""\n #include \""test/register_state_check.h\""\n #include \""test/util.h\""\n-\n-#include \""./vp9_rtcd.h\""\n #include \""vp9/common/vp9_entropy.h\""\n+#include \""vp9/common/vp9_scan.h\""\n+#include \""vpx/vpx_codec.h\""\n #include \""vpx/vpx_integer.h\""\n-\n-extern \""C\"" {\n-void vp9_idct16x16_256_add_c(const int16_t *input, uint8_t *output, int pitch);\n-}\n+#include \""vpx_ports/mem.h\""\n \n using libvpx_test::ACMRandom;\n \n@@ -258,32 +258,100 @@\n\n   }\n }\n \n-typedef void (*fdct_t)(const int16_t *in, int16_t *out, int stride);\n-typedef void (*idct_t)(const int16_t *in, uint8_t *out, int stride);\n-typedef void (*fht_t) (const int16_t *in, int16_t *out, int stride,\n-                       int tx_type);\n-typedef void (*iht_t) (const int16_t *in, uint8_t *out, int stride,\n-                       int tx_type);\n+typedef void (*FdctFunc)(const int16_t *in, tran_low_t *out, int stride);\n+typedef void (*IdctFunc)(const tran_low_t *in, uint8_t *out, int stride);\n+typedef void (*FhtFunc)(const int16_t *in, tran_low_t *out, int stride,\n+                        int tx_type);\n+typedef void (*IhtFunc)(const tran_low_t *in, uint8_t *out, int stride,\n+                        int tx_type);\n \n-typedef std::tr1::tuple<fdct_t, idct_t, int> dct_16x16_param_t;\n-typedef std::tr1::tuple<fht_t, iht_t, int> ht_16x16_param_t;\n+typedef std::tr1::tuple<FdctFunc, IdctFunc, int, vpx_bit_depth_t> Dct16x16Param;\n+typedef std::tr1::tuple<FhtFunc, IhtFunc, int, vpx_bit_depth_t> Ht16x16Param;\n+typedef std::tr1::tuple<IdctFunc, IdctFunc, int, vpx_bit_depth_t>\n+    Idct16x16Param;\n \n-void fdct16x16_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n-  vp9_fdct16x16_c(in, out, stride);\n+void fdct16x16_ref(const int16_t *in, tran_low_t *out, int stride,\n+                   int /*tx_type*/) {\n+  vpx_fdct16x16_c(in, out, stride);\n }\n \n-void fht16x16_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n+void idct16x16_ref(const tran_low_t *in, uint8_t *dest, int stride,\n+                   int /*tx_type*/) {\n+  vpx_idct16x16_256_add_c(in, dest, stride);\n+}\n+\n+void fht16x16_ref(const int16_t *in, tran_low_t *out, int stride,\n+                  int tx_type) {\n   vp9_fht16x16_c(in, out, stride, tx_type);\n }\n \n+void iht16x16_ref(const tran_low_t *in, uint8_t *dest, int stride,\n+                  int tx_type) {\n+  vp9_iht16x16_256_add_c(in, dest, stride, tx_type);\n+}\n+\n+#if CONFIG_VP9_HIGHBITDEPTH\n+void idct16x16_10(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct16x16_256_add_c(in, out, stride, 10);\n+}\n+\n+void idct16x16_12(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct16x16_256_add_c(in, out, stride, 12);\n+}\n+\n+void idct16x16_10_ref(const tran_low_t *in, uint8_t *out, int stride,\n+                      int tx_type) {\n+  idct16x16_10(in, out, stride);\n+}\n+\n+void idct16x16_12_ref(const tran_low_t *in, uint8_t *out, int stride,\n+                      int tx_type) {\n+  idct16x16_12(in, out, stride);\n+}\n+\n+void iht16x16_10(const tran_low_t *in, uint8_t *out, int stride, int tx_type) {\n+  vp9_highbd_iht16x16_256_add_c(in, out, stride, tx_type, 10);\n+}\n+\n+void iht16x16_12(const tran_low_t *in, uint8_t *out, int stride, int tx_type) {\n+  vp9_highbd_iht16x16_256_add_c(in, out, stride, tx_type, 12);\n+}\n+\n+void idct16x16_10_add_10_c(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct16x16_10_add_c(in, out, stride, 10);\n+}\n+\n+void idct16x16_10_add_12_c(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct16x16_10_add_c(in, out, stride, 12);\n+}\n+\n+#if HAVE_SSE2\n+void idct16x16_256_add_10_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct16x16_256_add_sse2(in, out, stride, 10);\n+}\n+\n+void idct16x16_256_add_12_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct16x16_256_add_sse2(in, out, stride, 12);\n+}\n+\n+void idct16x16_10_add_10_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct16x16_10_add_sse2(in, out, stride, 10);\n+}\n+\n+void idct16x16_10_add_12_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct16x16_10_add_sse2(in, out, stride, 12);\n+}\n+#endif  // HAVE_SSE2\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+\n class Trans16x16TestBase {\n  public:\n   virtual ~Trans16x16TestBase() {}\n \n  protected:\n-  virtual void RunFwdTxfm(int16_t *in, int16_t *out, int stride) = 0;\n+  virtual void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) = 0;\n \n-  virtual void RunInvTxfm(int16_t *out, uint8_t *dst, int stride) = 0;\n+  virtual void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) = 0;\n \n   void RunAccuracyCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n@@ -291,24 +359,49 @@\n\n     int64_t total_error = 0;\n     const int count_test_block = 10000;\n     for (int i = 0; i < count_test_block; ++i) {\n-      DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, kNumCoeffs);\n-      DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, kNumCoeffs);\n-      DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);\n-      DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);\n+      DECLARE_ALIGNED(16, int16_t, test_input_block[kNumCoeffs]);\n+      DECLARE_ALIGNED(16, tran_low_t, test_temp_block[kNumCoeffs]);\n+      DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n+      DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n+      DECLARE_ALIGNED(16, uint16_t, src16[kNumCoeffs]);\n+#endif\n \n-      // Initialize a test block with input range [-255, 255].\n+      // Initialize a test block with input range [-mask_, mask_].\n       for (int j = 0; j < kNumCoeffs; ++j) {\n-        src[j] = rnd.Rand8();\n-        dst[j] = rnd.Rand8();\n-        test_input_block[j] = src[j] - dst[j];\n+        if (bit_depth_ == VPX_BITS_8) {\n+          src[j] = rnd.Rand8();\n+          dst[j] = rnd.Rand8();\n+          test_input_block[j] = src[j] - dst[j];\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        } else {\n+          src16[j] = rnd.Rand16() & mask_;\n+          dst16[j] = rnd.Rand16() & mask_;\n+          test_input_block[j] = src16[j] - dst16[j];\n+#endif\n+        }\n       }\n \n-      REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,\n-                                      test_temp_block, pitch_));\n-      REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));\n+      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,\n+                                          test_temp_block, pitch_));\n+      if (bit_depth_ == VPX_BITS_8) {\n+        ASM_REGISTER_STATE_CHECK(\n+            RunInvTxfm(test_temp_block, dst, pitch_));\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        ASM_REGISTER_STATE_CHECK(\n+            RunInvTxfm(test_temp_block, CONVERT_TO_BYTEPTR(dst16), pitch_));\n+#endif\n+      }\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        const uint32_t diff =\n+            bit_depth_ == VPX_BITS_8 ?  dst[j] - src[j] : dst16[j] - src16[j];\n+#else\n         const uint32_t diff = dst[j] - src[j];\n+#endif\n         const uint32_t error = diff * diff;\n         if (max_error < error)\n           max_error = error;\n@@ -316,27 +409,27 @@\n\n       }\n     }\n \n-    EXPECT_GE(1u, max_error)\n+    EXPECT_GE(1u  << 2 * (bit_depth_ - 8), max_error)\n         << \""Error: 16x16 FHT/IHT has an individual round trip error > 1\"";\n \n-    EXPECT_GE(count_test_block , total_error)\n+    EXPECT_GE(count_test_block << 2 * (bit_depth_ - 8), total_error)\n         << \""Error: 16x16 FHT/IHT has average round trip error > 1 per block\"";\n   }\n \n   void RunCoeffCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 1000;\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);\n+    DECLARE_ALIGNED(16, int16_t, input_block[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);\n \n     for (int i = 0; i < count_test_block; ++i) {\n-      // Initialize a test block with input range [-255, 255].\n+      // Initialize a test block with input range [-mask_, mask_].\n       for (int j = 0; j < kNumCoeffs; ++j)\n-        input_block[j] = rnd.Rand8() - rnd.Rand8();\n+        input_block[j] = (rnd.Rand16() & mask_) - (rnd.Rand16() & mask_);\n \n       fwd_txfm_ref(input_block, output_ref_block, pitch_, tx_type_);\n-      REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));\n+      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));\n \n       // The minimum quant value is 4.\n       for (int j = 0; j < kNumCoeffs; ++j)\n@@ -347,63 +440,148 @@\n\n   void RunMemCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 1000;\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, input_extreme_block, kNumCoeffs);\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);\n+    DECLARE_ALIGNED(16, int16_t, input_extreme_block[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);\n \n     for (int i = 0; i < count_test_block; ++i) {\n-      // Initialize a test block with input range [-255, 255].\n+      // Initialize a test block with input range [-mask_, mask_].\n       for (int j = 0; j < kNumCoeffs; ++j) {\n-        input_block[j] = rnd.Rand8() - rnd.Rand8();\n-        input_extreme_block[j] = rnd.Rand8() % 2 ? 255 : -255;\n+        input_extreme_block[j] = rnd.Rand8() % 2 ? mask_ : -mask_;\n       }\n-      if (i == 0)\n+      if (i == 0) {\n         for (int j = 0; j < kNumCoeffs; ++j)\n-          input_extreme_block[j] = 255;\n-      if (i == 1)\n+          input_extreme_block[j] = mask_;\n+      } else if (i == 1) {\n         for (int j = 0; j < kNumCoeffs; ++j)\n-          input_extreme_block[j] = -255;\n+          input_extreme_block[j] = -mask_;\n+      }\n \n       fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);\n-      REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,\n-                                      output_block, pitch_));\n+      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,\n+                                          output_block, pitch_));\n \n       // The minimum quant value is 4.\n       for (int j = 0; j < kNumCoeffs; ++j) {\n         EXPECT_EQ(output_block[j], output_ref_block[j]);\n-        EXPECT_GE(4 * DCT_MAX_VALUE, abs(output_block[j]))\n+        EXPECT_GE(4 * DCT_MAX_VALUE << (bit_depth_ - 8), abs(output_block[j]))\n             << \""Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE\"";\n       }\n     }\n   }\n \n+  void RunQuantCheck(int dc_thred, int ac_thred) {\n+    ACMRandom rnd(ACMRandom::DeterministicSeed());\n+    const int count_test_block = 100000;\n+    DECLARE_ALIGNED(16, int16_t, input_extreme_block[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);\n+\n+    DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint8_t, ref[kNumCoeffs]);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint16_t, ref16[kNumCoeffs]);\n+#endif\n+\n+    for (int i = 0; i < count_test_block; ++i) {\n+      // Initialize a test block with input range [-mask_, mask_].\n+      for (int j = 0; j < kNumCoeffs; ++j) {\n+        input_extreme_block[j] = rnd.Rand8() % 2 ? mask_ : -mask_;\n+      }\n+      if (i == 0)\n+        for (int j = 0; j < kNumCoeffs; ++j)\n+          input_extreme_block[j] = mask_;\n+      if (i == 1)\n+        for (int j = 0; j < kNumCoeffs; ++j)\n+          input_extreme_block[j] = -mask_;\n+\n+      fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);\n+\n+      // clear reconstructed pixel buffers\n+      memset(dst, 0, kNumCoeffs * sizeof(uint8_t));\n+      memset(ref, 0, kNumCoeffs * sizeof(uint8_t));\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      memset(dst16, 0, kNumCoeffs * sizeof(uint16_t));\n+      memset(ref16, 0, kNumCoeffs * sizeof(uint16_t));\n+#endif\n+\n+      // quantization with maximum allowed step sizes\n+      output_ref_block[0] = (output_ref_block[0] / dc_thred) * dc_thred;\n+      for (int j = 1; j < kNumCoeffs; ++j)\n+        output_ref_block[j] = (output_ref_block[j] / ac_thred) * ac_thred;\n+      if (bit_depth_ == VPX_BITS_8) {\n+        inv_txfm_ref(output_ref_block, ref, pitch_, tx_type_);\n+        ASM_REGISTER_STATE_CHECK(RunInvTxfm(output_ref_block, dst, pitch_));\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        inv_txfm_ref(output_ref_block, CONVERT_TO_BYTEPTR(ref16), pitch_,\n+                     tx_type_);\n+        ASM_REGISTER_STATE_CHECK(RunInvTxfm(output_ref_block,\n+                                            CONVERT_TO_BYTEPTR(dst16), pitch_));\n+#endif\n+      }\n+      if (bit_depth_ == VPX_BITS_8) {\n+        for (int j = 0; j < kNumCoeffs; ++j)\n+          EXPECT_EQ(ref[j], dst[j]);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        for (int j = 0; j < kNumCoeffs; ++j)\n+          EXPECT_EQ(ref16[j], dst16[j]);\n+#endif\n+      }\n+    }\n+  }\n+\n   void RunInvAccuracyCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 1000;\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, in, kNumCoeffs);\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, coeff, kNumCoeffs);\n-    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);\n-    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);\n+    DECLARE_ALIGNED(16, int16_t, in[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint16_t, src16[kNumCoeffs]);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n \n     for (int i = 0; i < count_test_block; ++i) {\n       double out_r[kNumCoeffs];\n \n       // Initialize a test block with input range [-255, 255].\n       for (int j = 0; j < kNumCoeffs; ++j) {\n-        src[j] = rnd.Rand8();\n-        dst[j] = rnd.Rand8();\n-        in[j] = src[j] - dst[j];\n+        if (bit_depth_ == VPX_BITS_8) {\n+          src[j] = rnd.Rand8();\n+          dst[j] = rnd.Rand8();\n+          in[j] = src[j] - dst[j];\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        } else {\n+          src16[j] = rnd.Rand16() & mask_;\n+          dst16[j] = rnd.Rand16() & mask_;\n+          in[j] = src16[j] - dst16[j];\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+        }\n       }\n \n       reference_16x16_dct_2d(in, out_r);\n       for (int j = 0; j < kNumCoeffs; ++j)\n-        coeff[j] = round(out_r[j]);\n+        coeff[j] = static_cast<tran_low_t>(round(out_r[j]));\n \n-      REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, 16));\n+      if (bit_depth_ == VPX_BITS_8) {\n+        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, 16));\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, CONVERT_TO_BYTEPTR(dst16),\n+                                            16));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+      }\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        const uint32_t diff =\n+            bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n+#else\n         const uint32_t diff = dst[j] - src[j];\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n         const uint32_t error = diff * diff;\n         EXPECT_GE(1u, error)\n             << \""Error: 16x16 IDCT has error \"" << error\n@@ -411,14 +589,75 @@\n\n       }\n     }\n   }\n+\n+  void CompareInvReference(IdctFunc ref_txfm, int thresh) {\n+    ACMRandom rnd(ACMRandom::DeterministicSeed());\n+    const int count_test_block = 10000;\n+    const int eob = 10;\n+    const int16_t *scan = vp9_default_scan_orders[TX_16X16].scan;\n+    DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint8_t, ref[kNumCoeffs]);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint16_t, ref16[kNumCoeffs]);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+\n+    for (int i = 0; i < count_test_block; ++i) {\n+      for (int j = 0; j < kNumCoeffs; ++j) {\n+        if (j < eob) {\n+          // Random values less than the threshold, either positive or negative\n+          coeff[scan[j]] = rnd(thresh) * (1 - 2 * (i % 2));\n+        } else {\n+          coeff[scan[j]] = 0;\n+        }\n+        if (bit_depth_ == VPX_BITS_8) {\n+          dst[j] = 0;\n+          ref[j] = 0;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        } else {\n+          dst16[j] = 0;\n+          ref16[j] = 0;\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+        }\n+      }\n+      if (bit_depth_ == VPX_BITS_8) {\n+        ref_txfm(coeff, ref, pitch_);\n+        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, pitch_));\n+      } else {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        ref_txfm(coeff, CONVERT_TO_BYTEPTR(ref16), pitch_);\n+        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, CONVERT_TO_BYTEPTR(dst16),\n+                                 pitch_));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+      }\n+\n+      for (int j = 0; j < kNumCoeffs; ++j) {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        const uint32_t diff =\n+            bit_depth_ == VPX_BITS_8 ? dst[j] - ref[j] : dst16[j] - ref16[j];\n+#else\n+        const uint32_t diff = dst[j] - ref[j];\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+        const uint32_t error = diff * diff;\n+        EXPECT_EQ(0u, error)\n+            << \""Error: 16x16 IDCT Comparison has error \"" << error\n+            << \"" at index \"" << j;\n+      }\n+    }\n+  }\n+\n   int pitch_;\n   int tx_type_;\n-  fht_t fwd_txfm_ref;\n+  vpx_bit_depth_t bit_depth_;\n+  int mask_;\n+  FhtFunc fwd_txfm_ref;\n+  IhtFunc inv_txfm_ref;\n };\n \n class Trans16x16DCT\n     : public Trans16x16TestBase,\n-      public ::testing::TestWithParam<dct_16x16_param_t> {\n+      public ::testing::TestWithParam<Dct16x16Param> {\n  public:\n   virtual ~Trans16x16DCT() {}\n \n@@ -426,21 +665,39 @@\n\n     fwd_txfm_ = GET_PARAM(0);\n     inv_txfm_ = GET_PARAM(1);\n     tx_type_  = GET_PARAM(2);\n+    bit_depth_ = GET_PARAM(3);\n     pitch_    = 16;\n     fwd_txfm_ref = fdct16x16_ref;\n+    inv_txfm_ref = idct16x16_ref;\n+    mask_ = (1 << bit_depth_) - 1;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    switch (bit_depth_) {\n+      case VPX_BITS_10:\n+        inv_txfm_ref = idct16x16_10_ref;\n+        break;\n+      case VPX_BITS_12:\n+        inv_txfm_ref = idct16x16_12_ref;\n+        break;\n+      default:\n+        inv_txfm_ref = idct16x16_ref;\n+        break;\n+    }\n+#else\n+    inv_txfm_ref = idct16x16_ref;\n+#endif\n   }\n   virtual void TearDown() { libvpx_test::ClearSystemState(); }\n \n  protected:\n-  void RunFwdTxfm(int16_t *in, int16_t *out, int stride) {\n+  void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) {\n     fwd_txfm_(in, out, stride);\n   }\n-  void RunInvTxfm(int16_t *out, uint8_t *dst, int stride) {\n+  void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n     inv_txfm_(out, dst, stride);\n   }\n \n-  fdct_t fwd_txfm_;\n-  idct_t inv_txfm_;\n+  FdctFunc fwd_txfm_;\n+  IdctFunc inv_txfm_;\n };\n \n TEST_P(Trans16x16DCT, AccuracyCheck) {\n@@ -455,13 +712,19 @@\n\n   RunMemCheck();\n }\n \n+TEST_P(Trans16x16DCT, QuantCheck) {\n+  // Use maximally allowed quantization step sizes for DC and AC\n+  // coefficients respectively.\n+  RunQuantCheck(1336, 1828);\n+}\n+\n TEST_P(Trans16x16DCT, InvAccuracyCheck) {\n   RunInvAccuracyCheck();\n }\n \n class Trans16x16HT\n     : public Trans16x16TestBase,\n-      public ::testing::TestWithParam<ht_16x16_param_t> {\n+      public ::testing::TestWithParam<Ht16x16Param> {\n  public:\n   virtual ~Trans16x16HT() {}\n \n@@ -469,21 +732,39 @@\n\n     fwd_txfm_ = GET_PARAM(0);\n     inv_txfm_ = GET_PARAM(1);\n     tx_type_  = GET_PARAM(2);\n+    bit_depth_ = GET_PARAM(3);\n     pitch_    = 16;\n     fwd_txfm_ref = fht16x16_ref;\n+    inv_txfm_ref = iht16x16_ref;\n+    mask_ = (1 << bit_depth_) - 1;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    switch (bit_depth_) {\n+      case VPX_BITS_10:\n+        inv_txfm_ref = iht16x16_10;\n+        break;\n+      case VPX_BITS_12:\n+        inv_txfm_ref = iht16x16_12;\n+        break;\n+      default:\n+        inv_txfm_ref = iht16x16_ref;\n+        break;\n+    }\n+#else\n+    inv_txfm_ref = iht16x16_ref;\n+#endif\n   }\n   virtual void TearDown() { libvpx_test::ClearSystemState(); }\n \n  protected:\n-  void RunFwdTxfm(int16_t *in, int16_t *out, int stride) {\n+  void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) {\n     fwd_txfm_(in, out, stride, tx_type_);\n   }\n-  void RunInvTxfm(int16_t *out, uint8_t *dst, int stride) {\n+  void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n     inv_txfm_(out, dst, stride, tx_type_);\n   }\n \n-  fht_t fwd_txfm_;\n-  iht_t inv_txfm_;\n+  FhtFunc fwd_txfm_;\n+  IhtFunc inv_txfm_;\n };\n \n TEST_P(Trans16x16HT, AccuracyCheck) {\n@@ -498,40 +779,162 @@\n\n   RunMemCheck();\n }\n \n+TEST_P(Trans16x16HT, QuantCheck) {\n+  // The encoder skips any non-DC intra prediction modes,\n+  // when the quantization step size goes beyond 988.\n+  RunQuantCheck(429, 729);\n+}\n+\n+class InvTrans16x16DCT\n+    : public Trans16x16TestBase,\n+      public ::testing::TestWithParam<Idct16x16Param> {\n+ public:\n+  virtual ~InvTrans16x16DCT() {}\n+\n+  virtual void SetUp() {\n+    ref_txfm_ = GET_PARAM(0);\n+    inv_txfm_ = GET_PARAM(1);\n+    thresh_ = GET_PARAM(2);\n+    bit_depth_ = GET_PARAM(3);\n+    pitch_ = 16;\n+    mask_ = (1 << bit_depth_) - 1;\n+}\n+  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n+\n+ protected:\n+  void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) {}\n+  void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n+    inv_txfm_(out, dst, stride);\n+  }\n+\n+  IdctFunc ref_txfm_;\n+  IdctFunc inv_txfm_;\n+  int thresh_;\n+};\n+\n+TEST_P(InvTrans16x16DCT, CompareReference) {\n+  CompareInvReference(ref_txfm_, thresh_);\n+}\n+\n using std::tr1::make_tuple;\n \n+#if CONFIG_VP9_HIGHBITDEPTH\n INSTANTIATE_TEST_CASE_P(\n     C, Trans16x16DCT,\n     ::testing::Values(\n-        make_tuple(&vp9_fdct16x16_c, &vp9_idct16x16_256_add_c, 0)));\n+        make_tuple(&vpx_highbd_fdct16x16_c, &idct16x16_10, 0, VPX_BITS_10),\n+        make_tuple(&vpx_highbd_fdct16x16_c, &idct16x16_12, 0, VPX_BITS_12),\n+        make_tuple(&vpx_fdct16x16_c, &vpx_idct16x16_256_add_c, 0, VPX_BITS_8)));\n+#else\n+INSTANTIATE_TEST_CASE_P(\n+    C, Trans16x16DCT,\n+    ::testing::Values(\n+        make_tuple(&vpx_fdct16x16_c, &vpx_idct16x16_256_add_c, 0, VPX_BITS_8)));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+\n+#if CONFIG_VP9_HIGHBITDEPTH\n INSTANTIATE_TEST_CASE_P(\n     C, Trans16x16HT,\n     ::testing::Values(\n-        make_tuple(&vp9_fht16x16_c, &vp9_iht16x16_256_add_c, 0),\n-        make_tuple(&vp9_fht16x16_c, &vp9_iht16x16_256_add_c, 1),\n-        make_tuple(&vp9_fht16x16_c, &vp9_iht16x16_256_add_c, 2),\n-        make_tuple(&vp9_fht16x16_c, &vp9_iht16x16_256_add_c, 3)));\n+        make_tuple(&vp9_highbd_fht16x16_c, &iht16x16_10, 0, VPX_BITS_10),\n+        make_tuple(&vp9_highbd_fht16x16_c, &iht16x16_10, 1, VPX_BITS_10),\n+        make_tuple(&vp9_highbd_fht16x16_c, &iht16x16_10, 2, VPX_BITS_10),\n+        make_tuple(&vp9_highbd_fht16x16_c, &iht16x16_10, 3, VPX_BITS_10),\n+        make_tuple(&vp9_highbd_fht16x16_c, &iht16x16_12, 0, VPX_BITS_12),\n+        make_tuple(&vp9_highbd_fht16x16_c, &iht16x16_12, 1, VPX_BITS_12),\n+        make_tuple(&vp9_highbd_fht16x16_c, &iht16x16_12, 2, VPX_BITS_12),\n+        make_tuple(&vp9_highbd_fht16x16_c, &iht16x16_12, 3, VPX_BITS_12),\n+        make_tuple(&vp9_fht16x16_c, &vp9_iht16x16_256_add_c, 0, VPX_BITS_8),\n+        make_tuple(&vp9_fht16x16_c, &vp9_iht16x16_256_add_c, 1, VPX_BITS_8),\n+        make_tuple(&vp9_fht16x16_c, &vp9_iht16x16_256_add_c, 2, VPX_BITS_8),\n+        make_tuple(&vp9_fht16x16_c, &vp9_iht16x16_256_add_c, 3, VPX_BITS_8)));\n+#else\n+INSTANTIATE_TEST_CASE_P(\n+    C, Trans16x16HT,\n+    ::testing::Values(\n+        make_tuple(&vp9_fht16x16_c, &vp9_iht16x16_256_add_c, 0, VPX_BITS_8),\n+        make_tuple(&vp9_fht16x16_c, &vp9_iht16x16_256_add_c, 1, VPX_BITS_8),\n+        make_tuple(&vp9_fht16x16_c, &vp9_iht16x16_256_add_c, 2, VPX_BITS_8),\n+        make_tuple(&vp9_fht16x16_c, &vp9_iht16x16_256_add_c, 3, VPX_BITS_8)));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n \n-#if HAVE_NEON\n+#if HAVE_NEON_ASM && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n INSTANTIATE_TEST_CASE_P(\n     NEON, Trans16x16DCT,\n     ::testing::Values(\n-        make_tuple(&vp9_fdct16x16_c,\n-                   &vp9_idct16x16_256_add_neon, 0)));\n+        make_tuple(&vpx_fdct16x16_c,\n+                   &vpx_idct16x16_256_add_neon, 0, VPX_BITS_8)));\n #endif\n \n-#if HAVE_SSE2\n+#if HAVE_SSE2 && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n INSTANTIATE_TEST_CASE_P(\n     SSE2, Trans16x16DCT,\n     ::testing::Values(\n-        make_tuple(&vp9_fdct16x16_sse2,\n-                   &vp9_idct16x16_256_add_sse2, 0)));\n+        make_tuple(&vpx_fdct16x16_sse2,\n+                   &vpx_idct16x16_256_add_sse2, 0, VPX_BITS_8)));\n INSTANTIATE_TEST_CASE_P(\n     SSE2, Trans16x16HT,\n     ::testing::Values(\n-        make_tuple(&vp9_fht16x16_sse2, &vp9_iht16x16_256_add_sse2, 0),\n-        make_tuple(&vp9_fht16x16_sse2, &vp9_iht16x16_256_add_sse2, 1),\n-        make_tuple(&vp9_fht16x16_sse2, &vp9_iht16x16_256_add_sse2, 2),\n-        make_tuple(&vp9_fht16x16_sse2, &vp9_iht16x16_256_add_sse2, 3)));\n-#endif\n+        make_tuple(&vp9_fht16x16_sse2, &vp9_iht16x16_256_add_sse2, 0,\n+                   VPX_BITS_8),\n+        make_tuple(&vp9_fht16x16_sse2, &vp9_iht16x16_256_add_sse2, 1,\n+                   VPX_BITS_8),\n+        make_tuple(&vp9_fht16x16_sse2, &vp9_iht16x16_256_add_sse2, 2,\n+                   VPX_BITS_8),\n+        make_tuple(&vp9_fht16x16_sse2, &vp9_iht16x16_256_add_sse2, 3,\n+                   VPX_BITS_8)));\n+#endif  // HAVE_SSE2 && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+\n+#if HAVE_SSE2 && CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, Trans16x16DCT,\n+    ::testing::Values(\n+        make_tuple(&vpx_highbd_fdct16x16_sse2,\n+                   &idct16x16_10, 0, VPX_BITS_10),\n+        make_tuple(&vpx_highbd_fdct16x16_c,\n+                   &idct16x16_256_add_10_sse2, 0, VPX_BITS_10),\n+        make_tuple(&vpx_highbd_fdct16x16_sse2,\n+                   &idct16x16_12, 0, VPX_BITS_12),\n+        make_tuple(&vpx_highbd_fdct16x16_c,\n+                   &idct16x16_256_add_12_sse2, 0, VPX_BITS_12),\n+        make_tuple(&vpx_fdct16x16_sse2,\n+                   &vpx_idct16x16_256_add_c, 0, VPX_BITS_8)));\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, Trans16x16HT,\n+    ::testing::Values(\n+        make_tuple(&vp9_fht16x16_sse2, &vp9_iht16x16_256_add_c, 0, VPX_BITS_8),\n+        make_tuple(&vp9_fht16x16_sse2, &vp9_iht16x16_256_add_c, 1, VPX_BITS_8),\n+        make_tuple(&vp9_fht16x16_sse2, &vp9_iht16x16_256_add_c, 2, VPX_BITS_8),\n+        make_tuple(&vp9_fht16x16_sse2, &vp9_iht16x16_256_add_c, 3,\n+                   VPX_BITS_8)));\n+// Optimizations take effect at a threshold of 3155, so we use a value close to\n+// that to test both branches.\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, InvTrans16x16DCT,\n+    ::testing::Values(\n+        make_tuple(&idct16x16_10_add_10_c,\n+                   &idct16x16_10_add_10_sse2, 3167, VPX_BITS_10),\n+        make_tuple(&idct16x16_10,\n+                   &idct16x16_256_add_10_sse2, 3167, VPX_BITS_10),\n+        make_tuple(&idct16x16_10_add_12_c,\n+                   &idct16x16_10_add_12_sse2, 3167, VPX_BITS_12),\n+        make_tuple(&idct16x16_12,\n+                   &idct16x16_256_add_12_sse2, 3167, VPX_BITS_12)));\n+#endif  // HAVE_SSE2 && CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+\n+#if HAVE_MSA && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+INSTANTIATE_TEST_CASE_P(\n+    MSA, Trans16x16DCT,\n+    ::testing::Values(\n+        make_tuple(&vpx_fdct16x16_msa,\n+                   &vpx_idct16x16_256_add_msa, 0, VPX_BITS_8)));\n+INSTANTIATE_TEST_CASE_P(\n+    MSA, Trans16x16HT,\n+    ::testing::Values(\n+        make_tuple(&vp9_fht16x16_msa, &vp9_iht16x16_256_add_msa, 0, VPX_BITS_8),\n+        make_tuple(&vp9_fht16x16_msa, &vp9_iht16x16_256_add_msa, 1, VPX_BITS_8),\n+        make_tuple(&vp9_fht16x16_msa, &vp9_iht16x16_256_add_msa, 2, VPX_BITS_8),\n+        make_tuple(&vp9_fht16x16_msa, &vp9_iht16x16_256_add_msa, 3,\n+                   VPX_BITS_8)));\n+#endif  // HAVE_MSA && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/dct32x32_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/dct32x32_test.cc"", ""patch"": ""@@ -13,15 +13,18 @@\n\n #include <string.h>\n \n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vp9_rtcd.h\""\n+#include \""./vpx_config.h\""\n+#include \""./vpx_dsp_rtcd.h\""\n #include \""test/acm_random.h\""\n #include \""test/clear_system_state.h\""\n #include \""test/register_state_check.h\""\n #include \""test/util.h\""\n-\n-#include \""./vpx_config.h\""\n-#include \""./vp9_rtcd.h\""\n #include \""vp9/common/vp9_entropy.h\""\n+#include \""vpx/vpx_codec.h\""\n #include \""vpx/vpx_integer.h\""\n+#include \""vpx_ports/mem.h\""\n \n using libvpx_test::ACMRandom;\n \n@@ -37,7 +40,7 @@\n\n \n const int kNumCoeffs = 1024;\n const double kPi = 3.141592653589793238462643383279502884;\n-void reference_32x32_dct_1d(const double in[32], double out[32], int stride) {\n+void reference_32x32_dct_1d(const double in[32], double out[32]) {\n   const double kInvSqrt2 = 0.707106781186547524400844362104;\n   for (int k = 0; k < 32; k++) {\n     out[k] = 0.0;\n@@ -55,7 +58,7 @@\n\n     double temp_in[32], temp_out[32];\n     for (int j = 0; j < 32; ++j)\n       temp_in[j] = input[j*32 + i];\n-    reference_32x32_dct_1d(temp_in, temp_out, 1);\n+    reference_32x32_dct_1d(temp_in, temp_out);\n     for (int j = 0; j < 32; ++j)\n       output[j * 32 + i] = temp_out[j];\n   }\n@@ -64,19 +67,34 @@\n\n     double temp_in[32], temp_out[32];\n     for (int j = 0; j < 32; ++j)\n       temp_in[j] = output[j + i*32];\n-    reference_32x32_dct_1d(temp_in, temp_out, 1);\n+    reference_32x32_dct_1d(temp_in, temp_out);\n     // Scale by some magic number\n     for (int j = 0; j < 32; ++j)\n       output[j + i * 32] = temp_out[j] / 4;\n   }\n }\n \n-typedef void (*fwd_txfm_t)(const int16_t *in, int16_t *out, int stride);\n-typedef void (*inv_txfm_t)(const int16_t *in, uint8_t *out, int stride);\n+typedef void (*FwdTxfmFunc)(const int16_t *in, tran_low_t *out, int stride);\n+typedef void (*InvTxfmFunc)(const tran_low_t *in, uint8_t *out, int stride);\n \n-typedef std::tr1::tuple<fwd_txfm_t, inv_txfm_t, int> trans_32x32_param_t;\n+typedef std::tr1::tuple<FwdTxfmFunc, InvTxfmFunc, int, vpx_bit_depth_t>\n+    Trans32x32Param;\n \n-class Trans32x32Test : public ::testing::TestWithParam<trans_32x32_param_t> {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+void idct32x32_8(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct32x32_1024_add_c(in, out, stride, 8);\n+}\n+\n+void idct32x32_10(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct32x32_1024_add_c(in, out, stride, 10);\n+}\n+\n+void idct32x32_12(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct32x32_1024_add_c(in, out, stride, 12);\n+}\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+\n+class Trans32x32Test : public ::testing::TestWithParam<Trans32x32Param> {\n  public:\n   virtual ~Trans32x32Test() {}\n   virtual void SetUp() {\n@@ -84,39 +102,67 @@\n\n     inv_txfm_ = GET_PARAM(1);\n     version_  = GET_PARAM(2);  // 0: high precision forward transform\n                                // 1: low precision version for rd loop\n+    bit_depth_ = GET_PARAM(3);\n+    mask_ = (1 << bit_depth_) - 1;\n   }\n \n   virtual void TearDown() { libvpx_test::ClearSystemState(); }\n \n  protected:\n   int version_;\n-  fwd_txfm_t fwd_txfm_;\n-  inv_txfm_t inv_txfm_;\n+  vpx_bit_depth_t bit_depth_;\n+  int mask_;\n+  FwdTxfmFunc fwd_txfm_;\n+  InvTxfmFunc inv_txfm_;\n };\n \n TEST_P(Trans32x32Test, AccuracyCheck) {\n   ACMRandom rnd(ACMRandom::DeterministicSeed());\n   uint32_t max_error = 0;\n   int64_t total_error = 0;\n-  const int count_test_block = 1000;\n-  DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, kNumCoeffs);\n-  DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, kNumCoeffs);\n-  DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);\n-  DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);\n+  const int count_test_block = 10000;\n+  DECLARE_ALIGNED(16, int16_t, test_input_block[kNumCoeffs]);\n+  DECLARE_ALIGNED(16, tran_low_t, test_temp_block[kNumCoeffs]);\n+  DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n+  DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n+  DECLARE_ALIGNED(16, uint16_t, src16[kNumCoeffs]);\n+#endif\n \n   for (int i = 0; i < count_test_block; ++i) {\n-    // Initialize a test block with input range [-255, 255].\n+    // Initialize a test block with input range [-mask_, mask_].\n     for (int j = 0; j < kNumCoeffs; ++j) {\n-      src[j] = rnd.Rand8();\n-      dst[j] = rnd.Rand8();\n-      test_input_block[j] = src[j] - dst[j];\n+      if (bit_depth_ == VPX_BITS_8) {\n+        src[j] = rnd.Rand8();\n+        dst[j] = rnd.Rand8();\n+        test_input_block[j] = src[j] - dst[j];\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        src16[j] = rnd.Rand16() & mask_;\n+        dst16[j] = rnd.Rand16() & mask_;\n+        test_input_block[j] = src16[j] - dst16[j];\n+#endif\n+      }\n     }\n \n-    REGISTER_STATE_CHECK(fwd_txfm_(test_input_block, test_temp_block, 32));\n-    REGISTER_STATE_CHECK(inv_txfm_(test_temp_block, dst, 32));\n+    ASM_REGISTER_STATE_CHECK(fwd_txfm_(test_input_block, test_temp_block, 32));\n+    if (bit_depth_ == VPX_BITS_8) {\n+      ASM_REGISTER_STATE_CHECK(inv_txfm_(test_temp_block, dst, 32));\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    } else {\n+      ASM_REGISTER_STATE_CHECK(inv_txfm_(test_temp_block,\n+                                         CONVERT_TO_BYTEPTR(dst16), 32));\n+#endif\n+    }\n \n     for (int j = 0; j < kNumCoeffs; ++j) {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      const uint32_t diff =\n+          bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n+#else\n       const uint32_t diff = dst[j] - src[j];\n+#endif\n       const uint32_t error = diff * diff;\n       if (max_error < error)\n         max_error = error;\n@@ -129,10 +175,10 @@\n\n     total_error /= 45;\n   }\n \n-  EXPECT_GE(1u, max_error)\n+  EXPECT_GE(1u << 2 * (bit_depth_ - 8), max_error)\n       << \""Error: 32x32 FDCT/IDCT has an individual round-trip error > 1\"";\n \n-  EXPECT_GE(count_test_block, total_error)\n+  EXPECT_GE(count_test_block << 2 * (bit_depth_ - 8), total_error)\n       << \""Error: 32x32 FDCT/IDCT has average round-trip error > 1 per block\"";\n }\n \n@@ -140,17 +186,17 @@\n\n   ACMRandom rnd(ACMRandom::DeterministicSeed());\n   const int count_test_block = 1000;\n \n-  DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);\n-  DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);\n-  DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);\n+  DECLARE_ALIGNED(16, int16_t, input_block[kNumCoeffs]);\n+  DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);\n+  DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);\n \n   for (int i = 0; i < count_test_block; ++i) {\n     for (int j = 0; j < kNumCoeffs; ++j)\n-      input_block[j] = rnd.Rand8() - rnd.Rand8();\n+      input_block[j] = (rnd.Rand16() & mask_) - (rnd.Rand16() & mask_);\n \n     const int stride = 32;\n-    vp9_fdct32x32_c(input_block, output_ref_block, stride);\n-    REGISTER_STATE_CHECK(fwd_txfm_(input_block, output_block, stride));\n+    vpx_fdct32x32_c(input_block, output_ref_block, stride);\n+    ASM_REGISTER_STATE_CHECK(fwd_txfm_(input_block, output_block, stride));\n \n     if (version_ == 0) {\n       for (int j = 0; j < kNumCoeffs; ++j)\n@@ -168,27 +214,27 @@\n\n   ACMRandom rnd(ACMRandom::DeterministicSeed());\n   const int count_test_block = 2000;\n \n-  DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);\n-  DECLARE_ALIGNED_ARRAY(16, int16_t, input_extreme_block, kNumCoeffs);\n-  DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);\n-  DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);\n+  DECLARE_ALIGNED(16, int16_t, input_extreme_block[kNumCoeffs]);\n+  DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);\n+  DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);\n \n   for (int i = 0; i < count_test_block; ++i) {\n-    // Initialize a test block with input range [-255, 255].\n+    // Initialize a test block with input range [-mask_, mask_].\n     for (int j = 0; j < kNumCoeffs; ++j) {\n-      input_block[j] = rnd.Rand8() - rnd.Rand8();\n-      input_extreme_block[j] = rnd.Rand8() & 1 ? 255 : -255;\n+      input_extreme_block[j] = rnd.Rand8() & 1 ? mask_ : -mask_;\n     }\n-    if (i == 0)\n+    if (i == 0) {\n       for (int j = 0; j < kNumCoeffs; ++j)\n-        input_extreme_block[j] = 255;\n-    if (i == 1)\n+        input_extreme_block[j] = mask_;\n+    } else if (i == 1) {\n       for (int j = 0; j < kNumCoeffs; ++j)\n-        input_extreme_block[j] = -255;\n+        input_extreme_block[j] = -mask_;\n+    }\n \n     const int stride = 32;\n-    vp9_fdct32x32_c(input_extreme_block, output_ref_block, stride);\n-    REGISTER_STATE_CHECK(fwd_txfm_(input_extreme_block, output_block, stride));\n+    vpx_fdct32x32_c(input_extreme_block, output_ref_block, stride);\n+    ASM_REGISTER_STATE_CHECK(\n+        fwd_txfm_(input_extreme_block, output_block, stride));\n \n     // The minimum quant value is 4.\n     for (int j = 0; j < kNumCoeffs; ++j) {\n@@ -199,9 +245,9 @@\n\n         EXPECT_GE(6, abs(output_block[j] - output_ref_block[j]))\n             << \""Error: 32x32 FDCT rd has mismatched coefficients\"";\n       }\n-      EXPECT_GE(4 * DCT_MAX_VALUE, abs(output_ref_block[j]))\n+      EXPECT_GE(4 * DCT_MAX_VALUE << (bit_depth_ - 8), abs(output_ref_block[j]))\n           << \""Error: 32x32 FDCT C has coefficient larger than 4*DCT_MAX_VALUE\"";\n-      EXPECT_GE(4 * DCT_MAX_VALUE, abs(output_block[j]))\n+      EXPECT_GE(4 * DCT_MAX_VALUE << (bit_depth_ - 8), abs(output_block[j]))\n           << \""Error: 32x32 FDCT has coefficient larger than \""\n           << \""4*DCT_MAX_VALUE\"";\n     }\n@@ -211,27 +257,50 @@\n\n TEST_P(Trans32x32Test, InverseAccuracy) {\n   ACMRandom rnd(ACMRandom::DeterministicSeed());\n   const int count_test_block = 1000;\n-  DECLARE_ALIGNED_ARRAY(16, int16_t, in, kNumCoeffs);\n-  DECLARE_ALIGNED_ARRAY(16, int16_t, coeff, kNumCoeffs);\n-  DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);\n-  DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);\n+  DECLARE_ALIGNED(16, int16_t, in[kNumCoeffs]);\n+  DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n+  DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n+  DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n+  DECLARE_ALIGNED(16, uint16_t, src16[kNumCoeffs]);\n+#endif\n \n   for (int i = 0; i < count_test_block; ++i) {\n     double out_r[kNumCoeffs];\n \n     // Initialize a test block with input range [-255, 255]\n     for (int j = 0; j < kNumCoeffs; ++j) {\n-      src[j] = rnd.Rand8();\n-      dst[j] = rnd.Rand8();\n-      in[j] = src[j] - dst[j];\n+      if (bit_depth_ == VPX_BITS_8) {\n+        src[j] = rnd.Rand8();\n+        dst[j] = rnd.Rand8();\n+        in[j] = src[j] - dst[j];\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        src16[j] = rnd.Rand16() & mask_;\n+        dst16[j] = rnd.Rand16() & mask_;\n+        in[j] = src16[j] - dst16[j];\n+#endif\n+      }\n     }\n \n     reference_32x32_dct_2d(in, out_r);\n     for (int j = 0; j < kNumCoeffs; ++j)\n-      coeff[j] = round(out_r[j]);\n-    REGISTER_STATE_CHECK(inv_txfm_(coeff, dst, 32));\n+      coeff[j] = static_cast<tran_low_t>(round(out_r[j]));\n+    if (bit_depth_ == VPX_BITS_8) {\n+      ASM_REGISTER_STATE_CHECK(inv_txfm_(coeff, dst, 32));\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    } else {\n+      ASM_REGISTER_STATE_CHECK(inv_txfm_(coeff, CONVERT_TO_BYTEPTR(dst16), 32));\n+#endif\n+    }\n     for (int j = 0; j < kNumCoeffs; ++j) {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      const int diff =\n+          bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n+#else\n       const int diff = dst[j] - src[j];\n+#endif\n       const int error = diff * diff;\n       EXPECT_GE(1, error)\n           << \""Error: 32x32 IDCT has error \"" << error\n@@ -242,39 +311,85 @@\n\n \n using std::tr1::make_tuple;\n \n+#if CONFIG_VP9_HIGHBITDEPTH\n INSTANTIATE_TEST_CASE_P(\n     C, Trans32x32Test,\n     ::testing::Values(\n-        make_tuple(&vp9_fdct32x32_c, &vp9_idct32x32_1024_add_c, 0),\n-        make_tuple(&vp9_fdct32x32_rd_c, &vp9_idct32x32_1024_add_c, 1)));\n+        make_tuple(&vpx_highbd_fdct32x32_c,\n+                   &idct32x32_10, 0, VPX_BITS_10),\n+        make_tuple(&vpx_highbd_fdct32x32_rd_c,\n+                   &idct32x32_10, 1, VPX_BITS_10),\n+        make_tuple(&vpx_highbd_fdct32x32_c,\n+                   &idct32x32_12, 0, VPX_BITS_12),\n+        make_tuple(&vpx_highbd_fdct32x32_rd_c,\n+                   &idct32x32_12, 1, VPX_BITS_12),\n+        make_tuple(&vpx_fdct32x32_c,\n+                   &vpx_idct32x32_1024_add_c, 0, VPX_BITS_8),\n+        make_tuple(&vpx_fdct32x32_rd_c,\n+                   &vpx_idct32x32_1024_add_c, 1, VPX_BITS_8)));\n+#else\n+INSTANTIATE_TEST_CASE_P(\n+    C, Trans32x32Test,\n+    ::testing::Values(\n+        make_tuple(&vpx_fdct32x32_c,\n+                   &vpx_idct32x32_1024_add_c, 0, VPX_BITS_8),\n+        make_tuple(&vpx_fdct32x32_rd_c,\n+                   &vpx_idct32x32_1024_add_c, 1, VPX_BITS_8)));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n \n-#if HAVE_NEON\n+#if HAVE_NEON_ASM && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n INSTANTIATE_TEST_CASE_P(\n     NEON, Trans32x32Test,\n     ::testing::Values(\n-        make_tuple(&vp9_fdct32x32_c,\n-                   &vp9_idct32x32_1024_add_neon, 0),\n-        make_tuple(&vp9_fdct32x32_rd_c,\n-                   &vp9_idct32x32_1024_add_neon, 1)));\n-#endif\n+        make_tuple(&vpx_fdct32x32_c,\n+                   &vpx_idct32x32_1024_add_neon, 0, VPX_BITS_8),\n+        make_tuple(&vpx_fdct32x32_rd_c,\n+                   &vpx_idct32x32_1024_add_neon, 1, VPX_BITS_8)));\n+#endif  // HAVE_NEON_ASM && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n \n-#if HAVE_SSE2\n+#if HAVE_SSE2 && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n INSTANTIATE_TEST_CASE_P(\n     SSE2, Trans32x32Test,\n     ::testing::Values(\n-        make_tuple(&vp9_fdct32x32_sse2,\n-                   &vp9_idct32x32_1024_add_sse2, 0),\n-        make_tuple(&vp9_fdct32x32_rd_sse2,\n-                   &vp9_idct32x32_1024_add_sse2, 1)));\n-#endif\n+        make_tuple(&vpx_fdct32x32_sse2,\n+                   &vpx_idct32x32_1024_add_sse2, 0, VPX_BITS_8),\n+        make_tuple(&vpx_fdct32x32_rd_sse2,\n+                   &vpx_idct32x32_1024_add_sse2, 1, VPX_BITS_8)));\n+#endif  // HAVE_SSE2 && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n \n-#if HAVE_AVX2\n+#if HAVE_SSE2 && CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, Trans32x32Test,\n+    ::testing::Values(\n+        make_tuple(&vpx_highbd_fdct32x32_sse2, &idct32x32_10, 0, VPX_BITS_10),\n+        make_tuple(&vpx_highbd_fdct32x32_rd_sse2, &idct32x32_10, 1,\n+                   VPX_BITS_10),\n+        make_tuple(&vpx_highbd_fdct32x32_sse2, &idct32x32_12, 0, VPX_BITS_12),\n+        make_tuple(&vpx_highbd_fdct32x32_rd_sse2, &idct32x32_12, 1,\n+                   VPX_BITS_12),\n+        make_tuple(&vpx_fdct32x32_sse2, &vpx_idct32x32_1024_add_c, 0,\n+                   VPX_BITS_8),\n+        make_tuple(&vpx_fdct32x32_rd_sse2, &vpx_idct32x32_1024_add_c, 1,\n+                   VPX_BITS_8)));\n+#endif  // HAVE_SSE2 && CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+\n+#if HAVE_AVX2 && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n INSTANTIATE_TEST_CASE_P(\n     AVX2, Trans32x32Test,\n     ::testing::Values(\n-        make_tuple(&vp9_fdct32x32_avx2,\n-                   &vp9_idct32x32_1024_add_sse2, 0),\n-        make_tuple(&vp9_fdct32x32_rd_avx2,\n-                   &vp9_idct32x32_1024_add_sse2, 1)));\n-#endif\n+        make_tuple(&vpx_fdct32x32_avx2,\n+                   &vpx_idct32x32_1024_add_sse2, 0, VPX_BITS_8),\n+        make_tuple(&vpx_fdct32x32_rd_avx2,\n+                   &vpx_idct32x32_1024_add_sse2, 1, VPX_BITS_8)));\n+#endif  // HAVE_AVX2 && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+\n+#if HAVE_MSA && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+INSTANTIATE_TEST_CASE_P(\n+    MSA, Trans32x32Test,\n+    ::testing::Values(\n+        make_tuple(&vpx_fdct32x32_msa,\n+                   &vpx_idct32x32_1024_add_msa, 0, VPX_BITS_8),\n+        make_tuple(&vpx_fdct32x32_rd_msa,\n+                   &vpx_idct32x32_1024_add_msa, 1, VPX_BITS_8)));\n+#endif  // HAVE_MSA && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/decode_api_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/decode_api_test.cc"", ""patch"": ""@@ -0,0 +1,151 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vpx_config.h\""\n+#include \""test/ivf_video_source.h\""\n+#include \""vpx/vp8dx.h\""\n+#include \""vpx/vpx_decoder.h\""\n+\n+namespace {\n+\n+#define NELEMENTS(x) static_cast<int>(sizeof(x) / sizeof(x[0]))\n+\n+TEST(DecodeAPI, InvalidParams) {\n+  static const vpx_codec_iface_t *kCodecs[] = {\n+#if CONFIG_VP8_DECODER\n+    &vpx_codec_vp8_dx_algo,\n+#endif\n+#if CONFIG_VP9_DECODER\n+    &vpx_codec_vp9_dx_algo,\n+#endif\n+#if CONFIG_VP10_DECODER\n+    &vpx_codec_vp10_dx_algo,\n+#endif\n+  };\n+  uint8_t buf[1] = {0};\n+  vpx_codec_ctx_t dec;\n+\n+  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_dec_init(NULL, NULL, NULL, 0));\n+  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_dec_init(&dec, NULL, NULL, 0));\n+  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_decode(NULL, NULL, 0, NULL, 0));\n+  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_decode(NULL, buf, 0, NULL, 0));\n+  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n+            vpx_codec_decode(NULL, buf, NELEMENTS(buf), NULL, 0));\n+  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n+            vpx_codec_decode(NULL, NULL, NELEMENTS(buf), NULL, 0));\n+  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_destroy(NULL));\n+  EXPECT_TRUE(vpx_codec_error(NULL) != NULL);\n+\n+  for (int i = 0; i < NELEMENTS(kCodecs); ++i) {\n+    EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n+              vpx_codec_dec_init(NULL, kCodecs[i], NULL, 0));\n+\n+    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_dec_init(&dec, kCodecs[i], NULL, 0));\n+    EXPECT_EQ(VPX_CODEC_UNSUP_BITSTREAM,\n+              vpx_codec_decode(&dec, buf, NELEMENTS(buf), NULL, 0));\n+    EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n+              vpx_codec_decode(&dec, NULL, NELEMENTS(buf), NULL, 0));\n+    EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n+              vpx_codec_decode(&dec, buf, 0, NULL, 0));\n+\n+    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_destroy(&dec));\n+  }\n+}\n+\n+#if CONFIG_VP8_DECODER\n+TEST(DecodeAPI, OptionalParams) {\n+  vpx_codec_ctx_t dec;\n+\n+#if CONFIG_ERROR_CONCEALMENT\n+  EXPECT_EQ(VPX_CODEC_OK, vpx_codec_dec_init(&dec, &vpx_codec_vp8_dx_algo, NULL,\n+                                             VPX_CODEC_USE_ERROR_CONCEALMENT));\n+#else\n+  EXPECT_EQ(VPX_CODEC_INCAPABLE,\n+            vpx_codec_dec_init(&dec, &vpx_codec_vp8_dx_algo, NULL,\n+                               VPX_CODEC_USE_ERROR_CONCEALMENT));\n+#endif  // CONFIG_ERROR_CONCEALMENT\n+}\n+#endif  // CONFIG_VP8_DECODER\n+\n+#if CONFIG_VP9_DECODER\n+// Test VP9 codec controls after a decode error to ensure the code doesn't\n+// misbehave.\n+void TestVp9Controls(vpx_codec_ctx_t *dec) {\n+  static const int kControls[] = {\n+    VP8D_GET_LAST_REF_UPDATES,\n+    VP8D_GET_FRAME_CORRUPTED,\n+    VP9D_GET_DISPLAY_SIZE,\n+    VP9D_GET_FRAME_SIZE\n+  };\n+  int val[2];\n+\n+  for (int i = 0; i < NELEMENTS(kControls); ++i) {\n+    const vpx_codec_err_t res = vpx_codec_control_(dec, kControls[i], val);\n+    switch (kControls[i]) {\n+      case VP8D_GET_FRAME_CORRUPTED:\n+        EXPECT_EQ(VPX_CODEC_ERROR, res) << kControls[i];\n+        break;\n+      default:\n+        EXPECT_EQ(VPX_CODEC_OK, res) << kControls[i];\n+        break;\n+    }\n+    EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n+              vpx_codec_control_(dec, kControls[i], NULL));\n+  }\n+\n+  vp9_ref_frame_t ref;\n+  ref.idx = 0;\n+  EXPECT_EQ(VPX_CODEC_ERROR, vpx_codec_control(dec, VP9_GET_REFERENCE, &ref));\n+  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n+            vpx_codec_control(dec, VP9_GET_REFERENCE, NULL));\n+\n+  vpx_ref_frame_t ref_copy;\n+  const int width = 352;\n+  const int height = 288;\n+  ASSERT_TRUE(\n+      vpx_img_alloc(&ref_copy.img, VPX_IMG_FMT_I420, width, height, 1) != NULL);\n+  ref_copy.frame_type = VP8_LAST_FRAME;\n+  EXPECT_EQ(VPX_CODEC_ERROR,\n+            vpx_codec_control(dec, VP8_COPY_REFERENCE, &ref_copy));\n+  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n+            vpx_codec_control(dec, VP8_COPY_REFERENCE, NULL));\n+  vpx_img_free(&ref_copy.img);\n+}\n+\n+TEST(DecodeAPI, Vp9InvalidDecode) {\n+  const vpx_codec_iface_t *const codec = &vpx_codec_vp9_dx_algo;\n+  const char filename[] =\n+      \""invalid-vp90-2-00-quantizer-00.webm.ivf.s5861_r01-05_b6-.v2.ivf\"";\n+  libvpx_test::IVFVideoSource video(filename);\n+  video.Init();\n+  video.Begin();\n+  ASSERT_TRUE(!HasFailure());\n+\n+  vpx_codec_ctx_t dec;\n+  EXPECT_EQ(VPX_CODEC_OK, vpx_codec_dec_init(&dec, codec, NULL, 0));\n+  const uint32_t frame_size = static_cast<uint32_t>(video.frame_size());\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  EXPECT_EQ(VPX_CODEC_MEM_ERROR,\n+            vpx_codec_decode(&dec, video.cxdata(), frame_size, NULL, 0));\n+#else\n+  EXPECT_EQ(VPX_CODEC_UNSUP_BITSTREAM,\n+            vpx_codec_decode(&dec, video.cxdata(), frame_size, NULL, 0));\n+#endif\n+  vpx_codec_iter_t iter = NULL;\n+  EXPECT_EQ(NULL, vpx_codec_get_frame(&dec, &iter));\n+\n+  TestVp9Controls(&dec);\n+  EXPECT_EQ(VPX_CODEC_OK, vpx_codec_destroy(&dec));\n+}\n+#endif  // CONFIG_VP9_DECODER\n+\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/decode_perf_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/decode_perf_test.cc"", ""patch"": ""@@ -8,13 +8,17 @@\n\n  *  be found in the AUTHORS file in the root of the source tree.\n  */\n \n+#include <string>\n #include \""test/codec_factory.h\""\n #include \""test/decode_test_driver.h\""\n+#include \""test/encode_test_driver.h\""\n+#include \""test/i420_video_source.h\""\n #include \""test/ivf_video_source.h\""\n #include \""test/md5_helper.h\""\n #include \""test/util.h\""\n #include \""test/webm_video_source.h\""\n #include \""vpx_ports/vpx_timer.h\""\n+#include \""./ivfenc.h\""\n #include \""./vpx_version.h\""\n \n using std::tr1::make_tuple;\n@@ -24,14 +28,16 @@\n\n #define VIDEO_NAME 0\n #define THREADS 1\n \n+const int kMaxPsnr = 100;\n const double kUsecsInSec = 1000000.0;\n+const char kNewEncodeOutputFile[] = \""new_encode.ivf\"";\n \n /*\n  DecodePerfTest takes a tuple of filename + number of threads to decode with\n  */\n-typedef std::tr1::tuple<const char *, unsigned> decode_perf_param_t;\n+typedef std::tr1::tuple<const char *, unsigned> DecodePerfParam;\n \n-const decode_perf_param_t kVP9DecodePerfVectors[] = {\n+const DecodePerfParam kVP9DecodePerfVectors[] = {\n   make_tuple(\""vp90-2-bbb_426x240_tile_1x1_180kbps.webm\"", 1),\n   make_tuple(\""vp90-2-bbb_640x360_tile_1x2_337kbps.webm\"", 2),\n   make_tuple(\""vp90-2-bbb_854x480_tile_1x2_651kbps.webm\"", 2),\n@@ -47,7 +53,9 @@\n\n   make_tuple(\""vp90-2-tos_426x178_tile_1x1_181kbps.webm\"", 1),\n   make_tuple(\""vp90-2-tos_640x266_tile_1x2_336kbps.webm\"", 2),\n   make_tuple(\""vp90-2-tos_854x356_tile_1x2_656kbps.webm\"", 2),\n+  make_tuple(\""vp90-2-tos_854x356_tile_1x2_fpm_546kbps.webm\"", 2),\n   make_tuple(\""vp90-2-tos_1280x534_tile_1x4_1306kbps.webm\"", 4),\n+  make_tuple(\""vp90-2-tos_1280x534_tile_1x4_fpm_952kbps.webm\"", 4),\n   make_tuple(\""vp90-2-tos_1920x800_tile_1x4_fpm_2335kbps.webm\"", 4),\n };\n \n@@ -62,7 +70,7 @@\n\n    power/temp/min max frame decode times/etc\n  */\n \n-class DecodePerfTest : public ::testing::TestWithParam<decode_perf_param_t> {\n+class DecodePerfTest : public ::testing::TestWithParam<DecodePerfParam> {\n };\n \n TEST_P(DecodePerfTest, PerfTest) {\n@@ -72,7 +80,7 @@\n\n   libvpx_test::WebMVideoSource video(video_name);\n   video.Init();\n \n-  vpx_codec_dec_cfg_t cfg = {0};\n+  vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n   cfg.threads = threads;\n   libvpx_test::VP9Decoder decoder(cfg, 0);\n \n@@ -90,6 +98,7 @@\n\n   const double fps = double(frames) / elapsed_secs;\n \n   printf(\""{\\n\"");\n+  printf(\""\\t\\\""type\\\"" : \\\""decode_perf_test\\\"",\\n\"");\n   printf(\""\\t\\\""version\\\"" : \\\""%s\\\"",\\n\"", VERSION_STRING_NOSP);\n   printf(\""\\t\\\""videoName\\\"" : \\\""%s\\\"",\\n\"", video_name);\n   printf(\""\\t\\\""threadCount\\\"" : %u,\\n\"", threads);\n@@ -102,4 +111,163 @@\n\n INSTANTIATE_TEST_CASE_P(VP9, DecodePerfTest,\n                         ::testing::ValuesIn(kVP9DecodePerfVectors));\n \n+class VP9NewEncodeDecodePerfTest :\n+    public ::libvpx_test::EncoderTest,\n+    public ::libvpx_test::CodecTestWithParam<libvpx_test::TestMode> {\n+ protected:\n+  VP9NewEncodeDecodePerfTest()\n+      : EncoderTest(GET_PARAM(0)),\n+        encoding_mode_(GET_PARAM(1)),\n+        speed_(0),\n+        outfile_(0),\n+        out_frames_(0) {\n+  }\n+\n+  virtual ~VP9NewEncodeDecodePerfTest() {}\n+\n+  virtual void SetUp() {\n+    InitializeConfig();\n+    SetMode(encoding_mode_);\n+\n+    cfg_.g_lag_in_frames = 25;\n+    cfg_.rc_min_quantizer = 2;\n+    cfg_.rc_max_quantizer = 56;\n+    cfg_.rc_dropframe_thresh = 0;\n+    cfg_.rc_undershoot_pct = 50;\n+    cfg_.rc_overshoot_pct = 50;\n+    cfg_.rc_buf_sz = 1000;\n+    cfg_.rc_buf_initial_sz = 500;\n+    cfg_.rc_buf_optimal_sz = 600;\n+    cfg_.rc_resize_allowed = 0;\n+    cfg_.rc_end_usage = VPX_VBR;\n+  }\n+\n+  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n+                                  ::libvpx_test::Encoder *encoder) {\n+    if (video->frame() == 1) {\n+      encoder->Control(VP8E_SET_CPUUSED, speed_);\n+      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING, 1);\n+      encoder->Control(VP9E_SET_TILE_COLUMNS, 2);\n+    }\n+  }\n+\n+  virtual void BeginPassHook(unsigned int /*pass*/) {\n+    const std::string data_path = getenv(\""LIBVPX_TEST_DATA_PATH\"");\n+    const std::string path_to_source = data_path + \""/\"" + kNewEncodeOutputFile;\n+    outfile_ = fopen(path_to_source.c_str(), \""wb\"");\n+    ASSERT_TRUE(outfile_ != NULL);\n+  }\n+\n+  virtual void EndPassHook() {\n+    if (outfile_ != NULL) {\n+      if (!fseek(outfile_, 0, SEEK_SET))\n+        ivf_write_file_header(outfile_, &cfg_, VP9_FOURCC, out_frames_);\n+      fclose(outfile_);\n+      outfile_ = NULL;\n+    }\n+  }\n+\n+  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n+    ++out_frames_;\n+\n+    // Write initial file header if first frame.\n+    if (pkt->data.frame.pts == 0)\n+      ivf_write_file_header(outfile_, &cfg_, VP9_FOURCC, out_frames_);\n+\n+    // Write frame header and data.\n+    ivf_write_frame_header(outfile_, out_frames_, pkt->data.frame.sz);\n+    ASSERT_EQ(fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_),\n+              pkt->data.frame.sz);\n+  }\n+\n+  virtual bool DoDecode() { return false; }\n+\n+  void set_speed(unsigned int speed) {\n+    speed_ = speed;\n+  }\n+\n+ private:\n+  libvpx_test::TestMode encoding_mode_;\n+  uint32_t speed_;\n+  FILE *outfile_;\n+  uint32_t out_frames_;\n+};\n+\n+struct EncodePerfTestVideo {\n+  EncodePerfTestVideo(const char *name_, uint32_t width_, uint32_t height_,\n+                      uint32_t bitrate_, int frames_)\n+      : name(name_),\n+        width(width_),\n+        height(height_),\n+        bitrate(bitrate_),\n+        frames(frames_) {}\n+  const char *name;\n+  uint32_t width;\n+  uint32_t height;\n+  uint32_t bitrate;\n+  int frames;\n+};\n+\n+const EncodePerfTestVideo kVP9EncodePerfTestVectors[] = {\n+  EncodePerfTestVideo(\""niklas_1280_720_30.yuv\"", 1280, 720, 600, 470),\n+};\n+\n+TEST_P(VP9NewEncodeDecodePerfTest, PerfTest) {\n+  SetUp();\n+\n+  // TODO(JBB): Make this work by going through the set of given files.\n+  const int i = 0;\n+  const vpx_rational timebase = { 33333333, 1000000000 };\n+  cfg_.g_timebase = timebase;\n+  cfg_.rc_target_bitrate = kVP9EncodePerfTestVectors[i].bitrate;\n+\n+  init_flags_ = VPX_CODEC_USE_PSNR;\n+\n+  const char *video_name = kVP9EncodePerfTestVectors[i].name;\n+  libvpx_test::I420VideoSource video(\n+      video_name,\n+      kVP9EncodePerfTestVectors[i].width,\n+      kVP9EncodePerfTestVectors[i].height,\n+      timebase.den, timebase.num, 0,\n+      kVP9EncodePerfTestVectors[i].frames);\n+  set_speed(2);\n+\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+\n+  const uint32_t threads = 4;\n+\n+  libvpx_test::IVFVideoSource decode_video(kNewEncodeOutputFile);\n+  decode_video.Init();\n+\n+  vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n+  cfg.threads = threads;\n+  libvpx_test::VP9Decoder decoder(cfg, 0);\n+\n+  vpx_usec_timer t;\n+  vpx_usec_timer_start(&t);\n+\n+  for (decode_video.Begin(); decode_video.cxdata() != NULL;\n+       decode_video.Next()) {\n+    decoder.DecodeFrame(decode_video.cxdata(), decode_video.frame_size());\n+  }\n+\n+  vpx_usec_timer_mark(&t);\n+  const double elapsed_secs =\n+      static_cast<double>(vpx_usec_timer_elapsed(&t)) / kUsecsInSec;\n+  const unsigned decode_frames = decode_video.frame_number();\n+  const double fps = static_cast<double>(decode_frames) / elapsed_secs;\n+\n+  printf(\""{\\n\"");\n+  printf(\""\\t\\\""type\\\"" : \\\""decode_perf_test\\\"",\\n\"");\n+  printf(\""\\t\\\""version\\\"" : \\\""%s\\\"",\\n\"", VERSION_STRING_NOSP);\n+  printf(\""\\t\\\""videoName\\\"" : \\\""%s\\\"",\\n\"", kNewEncodeOutputFile);\n+  printf(\""\\t\\\""threadCount\\\"" : %u,\\n\"", threads);\n+  printf(\""\\t\\\""decodeTimeSecs\\\"" : %f,\\n\"", elapsed_secs);\n+  printf(\""\\t\\\""totalFrames\\\"" : %u,\\n\"", decode_frames);\n+  printf(\""\\t\\\""framesPerSecond\\\"" : %f\\n\"", fps);\n+  printf(\""}\\n\"");\n+}\n+\n+VP9_INSTANTIATE_TEST_CASE(\n+  VP9NewEncodeDecodePerfTest, ::testing::Values(::libvpx_test::kTwoPassGood));\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/decode_test_driver.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/decode_test_driver.cc"", ""patch"": ""@@ -7,35 +7,95 @@\n\n  *  in the file PATENTS.  All contributing project authors may\n  *  be found in the AUTHORS file in the root of the source tree.\n  */\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n #include \""test/codec_factory.h\""\n #include \""test/decode_test_driver.h\""\n-#include \""third_party/googletest/src/include/gtest/gtest.h\""\n #include \""test/register_state_check.h\""\n #include \""test/video_source.h\""\n \n namespace libvpx_test {\n \n+const char kVP8Name[] = \""WebM Project VP8\"";\n+\n+vpx_codec_err_t Decoder::PeekStream(const uint8_t *cxdata, size_t size,\n+                                    vpx_codec_stream_info_t *stream_info) {\n+  return vpx_codec_peek_stream_info(CodecInterface(),\n+                                    cxdata, static_cast<unsigned int>(size),\n+                                    stream_info);\n+}\n+\n vpx_codec_err_t Decoder::DecodeFrame(const uint8_t *cxdata, size_t size) {\n+  return DecodeFrame(cxdata, size, NULL);\n+}\n+\n+vpx_codec_err_t Decoder::DecodeFrame(const uint8_t *cxdata, size_t size,\n+                                     void *user_priv) {\n   vpx_codec_err_t res_dec;\n   InitOnce();\n-  REGISTER_STATE_CHECK(\n+  API_REGISTER_STATE_CHECK(\n       res_dec = vpx_codec_decode(&decoder_,\n                                  cxdata, static_cast<unsigned int>(size),\n-                                 NULL, 0));\n+                                 user_priv, 0));\n   return res_dec;\n }\n \n-void DecoderTest::RunLoop(CompressedVideoSource *video) {\n-  vpx_codec_dec_cfg_t dec_cfg = {0};\n-  Decoder* const decoder = codec_->CreateDecoder(dec_cfg, 0);\n+bool Decoder::IsVP8() const {\n+  const char *codec_name = GetDecoderName();\n+  return strncmp(kVP8Name, codec_name, sizeof(kVP8Name) - 1) == 0;\n+}\n+\n+void DecoderTest::HandlePeekResult(Decoder *const decoder,\n+                                   CompressedVideoSource *video,\n+                                   const vpx_codec_err_t res_peek) {\n+  const bool is_vp8 = decoder->IsVP8();\n+  if (is_vp8) {\n+    /* Vp8's implementation of PeekStream returns an error if the frame you\n+     * pass it is not a keyframe, so we only expect VPX_CODEC_OK on the first\n+     * frame, which must be a keyframe. */\n+    if (video->frame_number() == 0)\n+      ASSERT_EQ(VPX_CODEC_OK, res_peek) << \""Peek return failed: \""\n+                                        << vpx_codec_err_to_string(res_peek);\n+  } else {\n+    /* The Vp9 implementation of PeekStream returns an error only if the\n+     * data passed to it isn't a valid Vp9 chunk. */\n+    ASSERT_EQ(VPX_CODEC_OK, res_peek) << \""Peek return failed: \""\n+                                      << vpx_codec_err_to_string(res_peek);\n+  }\n+}\n+\n+void DecoderTest::RunLoop(CompressedVideoSource *video,\n+                          const vpx_codec_dec_cfg_t &dec_cfg) {\n+  Decoder* const decoder = codec_->CreateDecoder(dec_cfg, flags_, 0);\n   ASSERT_TRUE(decoder != NULL);\n+  bool end_of_file = false;\n \n   // Decode frames.\n-  for (video->Begin(); video->cxdata(); video->Next()) {\n+  for (video->Begin(); !::testing::Test::HasFailure() && !end_of_file;\n+       video->Next()) {\n     PreDecodeFrameHook(*video, decoder);\n-    vpx_codec_err_t res_dec = decoder->DecodeFrame(video->cxdata(),\n-                                                   video->frame_size());\n-    ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n+\n+    vpx_codec_stream_info_t stream_info;\n+    stream_info.sz = sizeof(stream_info);\n+\n+    if (video->cxdata() != NULL) {\n+      const vpx_codec_err_t res_peek = decoder->PeekStream(video->cxdata(),\n+                                                           video->frame_size(),\n+                                                           &stream_info);\n+      HandlePeekResult(decoder, video, res_peek);\n+      ASSERT_FALSE(::testing::Test::HasFailure());\n+\n+      vpx_codec_err_t res_dec = decoder->DecodeFrame(video->cxdata(),\n+                                                     video->frame_size());\n+      if (!HandleDecodeResult(res_dec, *video, decoder))\n+        break;\n+    } else {\n+      // Signal end of the file to the decoder.\n+      const vpx_codec_err_t res_dec = decoder->DecodeFrame(NULL, 0);\n+      ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n+      end_of_file = true;\n+    }\n \n     DxDataIterator dec_iter = decoder->GetDxData();\n     const vpx_image_t *img = NULL;\n@@ -44,7 +104,20 @@\n\n     while ((img = dec_iter.Next()))\n       DecompressedFrameHook(*img, video->frame_number());\n   }\n-\n   delete decoder;\n }\n+\n+void DecoderTest::RunLoop(CompressedVideoSource *video) {\n+  vpx_codec_dec_cfg_t dec_cfg = vpx_codec_dec_cfg_t();\n+  RunLoop(video, dec_cfg);\n+}\n+\n+void DecoderTest::set_cfg(const vpx_codec_dec_cfg_t &dec_cfg) {\n+  memcpy(&cfg_, &dec_cfg, sizeof(cfg_));\n+}\n+\n+void DecoderTest::set_flags(const vpx_codec_flags_t flags) {\n+  flags_ = flags;\n+}\n+\n }  // namespace libvpx_test\n""}<_**next**_>{""filename"": ""libvpx/test/decode_test_driver.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/decode_test_driver.h"", ""patch"": ""@@ -41,7 +41,13 @@\n\n class Decoder {\n  public:\n   Decoder(vpx_codec_dec_cfg_t cfg, unsigned long deadline)\n-      : cfg_(cfg), deadline_(deadline), init_done_(false) {\n+      : cfg_(cfg), flags_(0), deadline_(deadline), init_done_(false) {\n+    memset(&decoder_, 0, sizeof(decoder_));\n+  }\n+\n+  Decoder(vpx_codec_dec_cfg_t cfg, const vpx_codec_flags_t flag,\n+          unsigned long deadline)  // NOLINT\n+      : cfg_(cfg), flags_(flag), deadline_(deadline), init_done_(false) {\n     memset(&decoder_, 0, sizeof(decoder_));\n   }\n \n@@ -49,8 +55,14 @@\n\n     vpx_codec_destroy(&decoder_);\n   }\n \n+  vpx_codec_err_t PeekStream(const uint8_t *cxdata, size_t size,\n+                             vpx_codec_stream_info_t *stream_info);\n+\n   vpx_codec_err_t DecodeFrame(const uint8_t *cxdata, size_t size);\n \n+  vpx_codec_err_t DecodeFrame(const uint8_t *cxdata, size_t size,\n+                              void *user_priv);\n+\n   DxDataIterator GetDxData() {\n     return DxDataIterator(&decoder_);\n   }\n@@ -60,9 +72,7 @@\n\n   }\n \n   void Control(int ctrl_id, int arg) {\n-    InitOnce();\n-    const vpx_codec_err_t res = vpx_codec_control_(&decoder_, ctrl_id, arg);\n-    ASSERT_EQ(VPX_CODEC_OK, res) << DecodeError();\n+    Control(ctrl_id, arg, VPX_CODEC_OK);\n   }\n \n   void Control(int ctrl_id, const void *arg) {\n@@ -71,6 +81,12 @@\n\n     ASSERT_EQ(VPX_CODEC_OK, res) << DecodeError();\n   }\n \n+  void Control(int ctrl_id, int arg, vpx_codec_err_t expected_value) {\n+    InitOnce();\n+    const vpx_codec_err_t res = vpx_codec_control_(&decoder_, ctrl_id, arg);\n+    ASSERT_EQ(expected_value, res) << DecodeError();\n+  }\n+\n   const char* DecodeError() {\n     const char *detail = vpx_codec_error_detail(&decoder_);\n     return detail ? detail : vpx_codec_error(&decoder_);\n@@ -85,6 +101,16 @@\n\n         &decoder_, cb_get, cb_release, user_priv);\n   }\n \n+  const char* GetDecoderName() const {\n+    return vpx_codec_iface_name(CodecInterface());\n+  }\n+\n+  bool IsVP8() const;\n+\n+  vpx_codec_ctx_t * GetDecoder() {\n+    return &decoder_;\n+  }\n+\n  protected:\n   virtual vpx_codec_iface_t* CodecInterface() const = 0;\n \n@@ -92,7 +118,7 @@\n\n     if (!init_done_) {\n       const vpx_codec_err_t res = vpx_codec_dec_init(&decoder_,\n                                                      CodecInterface(),\n-                                                     &cfg_, 0);\n+                                                     &cfg_, flags_);\n       ASSERT_EQ(VPX_CODEC_OK, res) << DecodeError();\n       init_done_ = true;\n     }\n@@ -100,6 +126,7 @@\n\n \n   vpx_codec_ctx_t     decoder_;\n   vpx_codec_dec_cfg_t cfg_;\n+  vpx_codec_flags_t   flags_;\n   unsigned int        deadline_;\n   bool                init_done_;\n };\n@@ -109,21 +136,44 @@\n\n  public:\n   // Main decoding loop\n   virtual void RunLoop(CompressedVideoSource *video);\n+  virtual void RunLoop(CompressedVideoSource *video,\n+                       const vpx_codec_dec_cfg_t &dec_cfg);\n+\n+  virtual void set_cfg(const vpx_codec_dec_cfg_t &dec_cfg);\n+  virtual void set_flags(const vpx_codec_flags_t flags);\n \n   // Hook to be called before decompressing every frame.\n-  virtual void PreDecodeFrameHook(const CompressedVideoSource& video,\n-                                  Decoder *decoder) {}\n+  virtual void PreDecodeFrameHook(const CompressedVideoSource& /*video*/,\n+                                  Decoder* /*decoder*/) {}\n+\n+  // Hook to be called to handle decode result. Return true to continue.\n+  virtual bool HandleDecodeResult(const vpx_codec_err_t res_dec,\n+                                  const CompressedVideoSource& /*video*/,\n+                                  Decoder *decoder) {\n+    EXPECT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n+    return VPX_CODEC_OK == res_dec;\n+  }\n \n   // Hook to be called on every decompressed frame.\n-  virtual void DecompressedFrameHook(const vpx_image_t& img,\n-                                     const unsigned int frame_number) {}\n+  virtual void DecompressedFrameHook(const vpx_image_t& /*img*/,\n+                                     const unsigned int /*frame_number*/) {}\n+\n+  // Hook to be called on peek result\n+  virtual void HandlePeekResult(Decoder* const decoder,\n+                                CompressedVideoSource *video,\n+                                const vpx_codec_err_t res_peek);\n \n  protected:\n-  explicit DecoderTest(const CodecFactory *codec) : codec_(codec) {}\n+  explicit DecoderTest(const CodecFactory *codec)\n+      : codec_(codec),\n+        cfg_(),\n+        flags_(0) {}\n \n   virtual ~DecoderTest() {}\n \n   const CodecFactory *codec_;\n+  vpx_codec_dec_cfg_t cfg_;\n+  vpx_codec_flags_t   flags_;\n };\n \n }  // namespace libvpx_test\n""}<_**next**_>{""filename"": ""libvpx/test/decode_to_md5.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/decode_to_md5.sh"", ""patch"": ""@@ -0,0 +1,73 @@\n\n+#!/bin/sh\n+##\n+##  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+##\n+##  Use of this source code is governed by a BSD-style license\n+##  that can be found in the LICENSE file in the root of the source\n+##  tree. An additional intellectual property rights grant can be found\n+##  in the file PATENTS.  All contributing project authors may\n+##  be found in the AUTHORS file in the root of the source tree.\n+##\n+##  This file tests the libvpx decode_to_md5 example. To add new tests to this\n+##  file, do the following:\n+##    1. Write a shell function (this is your test).\n+##    2. Add the function to decode_to_md5_tests (on a new line).\n+##\n+. $(dirname $0)/tools_common.sh\n+\n+# Environment check: Make sure input is available:\n+#   $VP8_IVF_FILE and $VP9_IVF_FILE are required.\n+decode_to_md5_verify_environment() {\n+  if [ ! -e \""${VP8_IVF_FILE}\"" ] || [ ! -e \""${VP9_IVF_FILE}\"" ]; then\n+    echo \""Libvpx test data must exist in LIBVPX_TEST_DATA_PATH.\""\n+    return 1\n+  fi\n+}\n+\n+# Runs decode_to_md5 on $1 and captures the md5 sum for the final frame. $2 is\n+# interpreted as codec name and used solely to name the output file. $3 is the\n+# expected md5 sum: It must match that of the final frame.\n+decode_to_md5() {\n+  local decoder=\""${LIBVPX_BIN_PATH}/decode_to_md5${VPX_TEST_EXE_SUFFIX}\""\n+  local input_file=\""$1\""\n+  local codec=\""$2\""\n+  local expected_md5=\""$3\""\n+  local output_file=\""${VPX_TEST_OUTPUT_DIR}/decode_to_md5_${codec}\""\n+\n+  if [ ! -x \""${decoder}\"" ]; then\n+    elog \""${decoder} does not exist or is not executable.\""\n+    return 1\n+  fi\n+\n+  eval \""${VPX_TEST_PREFIX}\"" \""${decoder}\"" \""${input_file}\"" \""${output_file}\"" \\\n+      ${devnull}\n+\n+  [ -e \""${output_file}\"" ] || return 1\n+\n+  local md5_last_frame=\""$(tail -n1 \""${output_file}\"" | awk '{print $1}')\""\n+  local actual_md5=\""$(echo \""${md5_last_frame}\"" | awk '{print $1}')\""\n+  [ \""${actual_md5}\"" = \""${expected_md5}\"" ] || return 1\n+}\n+\n+decode_to_md5_vp8() {\n+  # expected MD5 sum for the last frame.\n+  local expected_md5=\""56794d911b02190212bca92f88ad60c6\""\n+\n+  if [ \""$(vp8_decode_available)\"" = \""yes\"" ]; then\n+    decode_to_md5 \""${VP8_IVF_FILE}\"" \""vp8\"" \""${expected_md5}\""\n+  fi\n+}\n+\n+decode_to_md5_vp9() {\n+  # expected MD5 sum for the last frame.\n+  local expected_md5=\""2952c0eae93f3dadd1aa84c50d3fd6d2\""\n+\n+  if [ \""$(vp9_decode_available)\"" = \""yes\"" ]; then\n+    decode_to_md5 \""${VP9_IVF_FILE}\"" \""vp9\"" \""${expected_md5}\""\n+  fi\n+}\n+\n+decode_to_md5_tests=\""decode_to_md5_vp8\n+                     decode_to_md5_vp9\""\n+\n+run_tests decode_to_md5_verify_environment \""${decode_to_md5_tests}\""\n""}<_**next**_>{""filename"": ""libvpx/test/decode_with_drops.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/decode_with_drops.sh"", ""patch"": ""@@ -0,0 +1,79 @@\n\n+#!/bin/sh\n+##\n+##  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+##\n+##  Use of this source code is governed by a BSD-style license\n+##  that can be found in the LICENSE file in the root of the source\n+##  tree. An additional intellectual property rights grant can be found\n+##  in the file PATENTS.  All contributing project authors may\n+##  be found in the AUTHORS file in the root of the source tree.\n+##\n+##  This file tests the libvpx decode_with_drops example. To add new tests to\n+##  this file, do the following:\n+##    1. Write a shell function (this is your test).\n+##    2. Add the function to decode_with_drops_tests (on a new line).\n+##\n+. $(dirname $0)/tools_common.sh\n+\n+# Environment check: Make sure input is available:\n+#   $VP8_IVF_FILE and $VP9_IVF_FILE are required.\n+decode_with_drops_verify_environment() {\n+  if [ ! -e \""${VP8_IVF_FILE}\"" ] || [ ! -e \""${VP9_IVF_FILE}\"" ]; then\n+    echo \""Libvpx test data must exist in LIBVPX_TEST_DATA_PATH.\""\n+    return 1\n+  fi\n+}\n+\n+# Runs decode_with_drops on $1, $2 is interpreted as codec name and used solely\n+# to name the output file. $3 is the drop mode, and is passed directly to\n+# decode_with_drops.\n+decode_with_drops() {\n+  local decoder=\""${LIBVPX_BIN_PATH}/decode_with_drops${VPX_TEST_EXE_SUFFIX}\""\n+  local input_file=\""$1\""\n+  local codec=\""$2\""\n+  local output_file=\""${VPX_TEST_OUTPUT_DIR}/decode_with_drops_${codec}\""\n+  local drop_mode=\""$3\""\n+\n+  if [ ! -x \""${decoder}\"" ]; then\n+    elog \""${decoder} does not exist or is not executable.\""\n+    return 1\n+  fi\n+\n+  eval \""${VPX_TEST_PREFIX}\"" \""${decoder}\"" \""${input_file}\"" \""${output_file}\"" \\\n+      \""${drop_mode}\"" ${devnull}\n+\n+  [ -e \""${output_file}\"" ] || return 1\n+}\n+\n+# Decodes $VP8_IVF_FILE while dropping frames, twice: once in sequence mode,\n+# and once in pattern mode.\n+# Note: This test assumes that $VP8_IVF_FILE has exactly 29 frames, and could\n+# break if the file is modified.\n+decode_with_drops_vp8() {\n+  if [ \""$(vp8_decode_available)\"" = \""yes\"" ]; then\n+    # Test sequence mode: Drop frames 2-28.\n+    decode_with_drops \""${VP8_IVF_FILE}\"" \""vp8\"" \""2-28\""\n+\n+    # Test pattern mode: Drop 3 of every 4 frames.\n+    decode_with_drops \""${VP8_IVF_FILE}\"" \""vp8\"" \""3/4\""\n+  fi\n+}\n+\n+# Decodes $VP9_IVF_FILE while dropping frames, twice: once in sequence mode,\n+# and once in pattern mode.\n+# Note: This test assumes that $VP9_IVF_FILE has exactly 20 frames, and could\n+# break if the file is modified.\n+decode_with_drops_vp9() {\n+  if [ \""$(vp9_decode_available)\"" = \""yes\"" ]; then\n+    # Test sequence mode: Drop frames 2-28.\n+    decode_with_drops \""${VP9_IVF_FILE}\"" \""vp9\"" \""2-19\""\n+\n+    # Test pattern mode: Drop 3 of every 4 frames.\n+    decode_with_drops \""${VP9_IVF_FILE}\"" \""vp9\"" \""3/4\""\n+  fi\n+}\n+\n+decode_with_drops_tests=\""decode_with_drops_vp8\n+                         decode_with_drops_vp9\""\n+\n+run_tests decode_with_drops_verify_environment \""${decode_with_drops_tests}\""\n""}<_**next**_>{""filename"": ""libvpx/test/encode_perf_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/encode_perf_test.cc"", ""patch"": ""@@ -0,0 +1,202 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+#include <string>\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+#include \""./vpx_config.h\""\n+#include \""./vpx_version.h\""\n+#include \""test/codec_factory.h\""\n+#include \""test/encode_test_driver.h\""\n+#include \""test/i420_video_source.h\""\n+#include \""test/util.h\""\n+#include \""test/y4m_video_source.h\""\n+#include \""vpx_ports/vpx_timer.h\""\n+\n+namespace {\n+\n+const int kMaxPsnr = 100;\n+const double kUsecsInSec = 1000000.0;\n+\n+struct EncodePerfTestVideo {\n+  EncodePerfTestVideo(const char *name_, uint32_t width_, uint32_t height_,\n+                      uint32_t bitrate_, int frames_)\n+      : name(name_),\n+        width(width_),\n+        height(height_),\n+        bitrate(bitrate_),\n+        frames(frames_) {}\n+  const char *name;\n+  uint32_t width;\n+  uint32_t height;\n+  uint32_t bitrate;\n+  int frames;\n+};\n+\n+const EncodePerfTestVideo kVP9EncodePerfTestVectors[] = {\n+  EncodePerfTestVideo(\""desktop_640_360_30.yuv\"", 640, 360, 200, 2484),\n+  EncodePerfTestVideo(\""kirland_640_480_30.yuv\"", 640, 480, 200, 300),\n+  EncodePerfTestVideo(\""macmarcomoving_640_480_30.yuv\"", 640, 480, 200, 987),\n+  EncodePerfTestVideo(\""macmarcostationary_640_480_30.yuv\"", 640, 480, 200, 718),\n+  EncodePerfTestVideo(\""niklas_640_480_30.yuv\"", 640, 480, 200, 471),\n+  EncodePerfTestVideo(\""tacomanarrows_640_480_30.yuv\"", 640, 480, 200, 300),\n+  EncodePerfTestVideo(\""tacomasmallcameramovement_640_480_30.yuv\"",\n+                      640, 480, 200, 300),\n+  EncodePerfTestVideo(\""thaloundeskmtg_640_480_30.yuv\"", 640, 480, 200, 300),\n+  EncodePerfTestVideo(\""niklas_1280_720_30.yuv\"", 1280, 720, 600, 470),\n+};\n+\n+const int kEncodePerfTestSpeeds[] = { 5, 6, 7, 8 };\n+const int kEncodePerfTestThreads[] = { 1, 2, 4 };\n+\n+#define NELEMENTS(x) (sizeof((x)) / sizeof((x)[0]))\n+\n+class VP9EncodePerfTest\n+    : public ::libvpx_test::EncoderTest,\n+      public ::libvpx_test::CodecTestWithParam<libvpx_test::TestMode> {\n+ protected:\n+  VP9EncodePerfTest()\n+      : EncoderTest(GET_PARAM(0)),\n+        min_psnr_(kMaxPsnr),\n+        nframes_(0),\n+        encoding_mode_(GET_PARAM(1)),\n+        speed_(0),\n+        threads_(1) {}\n+\n+  virtual ~VP9EncodePerfTest() {}\n+\n+  virtual void SetUp() {\n+    InitializeConfig();\n+    SetMode(encoding_mode_);\n+\n+    cfg_.g_lag_in_frames = 0;\n+    cfg_.rc_min_quantizer = 2;\n+    cfg_.rc_max_quantizer = 56;\n+    cfg_.rc_dropframe_thresh = 0;\n+    cfg_.rc_undershoot_pct = 50;\n+    cfg_.rc_overshoot_pct = 50;\n+    cfg_.rc_buf_sz = 1000;\n+    cfg_.rc_buf_initial_sz = 500;\n+    cfg_.rc_buf_optimal_sz = 600;\n+    cfg_.rc_resize_allowed = 0;\n+    cfg_.rc_end_usage = VPX_CBR;\n+    cfg_.g_error_resilient = 1;\n+    cfg_.g_threads = threads_;\n+  }\n+\n+  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n+                                  ::libvpx_test::Encoder *encoder) {\n+    if (video->frame() == 0) {\n+      const int log2_tile_columns = 3;\n+      encoder->Control(VP8E_SET_CPUUSED, speed_);\n+      encoder->Control(VP9E_SET_TILE_COLUMNS, log2_tile_columns);\n+      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING, 1);\n+      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 0);\n+    }\n+  }\n+\n+  virtual void BeginPassHook(unsigned int /*pass*/) {\n+    min_psnr_ = kMaxPsnr;\n+    nframes_ = 0;\n+  }\n+\n+  virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n+    if (pkt->data.psnr.psnr[0] < min_psnr_) {\n+      min_psnr_= pkt->data.psnr.psnr[0];\n+    }\n+  }\n+\n+  // for performance reasons don't decode\n+  virtual bool DoDecode() { return 0; }\n+\n+  double min_psnr() const {\n+    return min_psnr_;\n+  }\n+\n+  void set_speed(unsigned int speed) {\n+    speed_ = speed;\n+  }\n+\n+  void set_threads(unsigned int threads) {\n+    threads_ = threads;\n+  }\n+\n+ private:\n+  double min_psnr_;\n+  unsigned int nframes_;\n+  libvpx_test::TestMode encoding_mode_;\n+  unsigned speed_;\n+  unsigned int threads_;\n+};\n+\n+TEST_P(VP9EncodePerfTest, PerfTest) {\n+  for (size_t i = 0; i < NELEMENTS(kVP9EncodePerfTestVectors); ++i) {\n+    for (size_t j = 0; j < NELEMENTS(kEncodePerfTestSpeeds); ++j) {\n+      for (size_t k = 0; k < NELEMENTS(kEncodePerfTestThreads); ++k) {\n+        if (kVP9EncodePerfTestVectors[i].width < 512 &&\n+            kEncodePerfTestThreads[k] > 1)\n+          continue;\n+        else if (kVP9EncodePerfTestVectors[i].width < 1024 &&\n+                 kEncodePerfTestThreads[k] > 2)\n+          continue;\n+\n+        set_threads(kEncodePerfTestThreads[k]);\n+        SetUp();\n+\n+        const vpx_rational timebase = { 33333333, 1000000000 };\n+        cfg_.g_timebase = timebase;\n+        cfg_.rc_target_bitrate = kVP9EncodePerfTestVectors[i].bitrate;\n+\n+        init_flags_ = VPX_CODEC_USE_PSNR;\n+\n+        const unsigned frames = kVP9EncodePerfTestVectors[i].frames;\n+        const char *video_name = kVP9EncodePerfTestVectors[i].name;\n+        libvpx_test::I420VideoSource video(\n+            video_name,\n+            kVP9EncodePerfTestVectors[i].width,\n+            kVP9EncodePerfTestVectors[i].height,\n+            timebase.den, timebase.num, 0,\n+            kVP9EncodePerfTestVectors[i].frames);\n+        set_speed(kEncodePerfTestSpeeds[j]);\n+\n+        vpx_usec_timer t;\n+        vpx_usec_timer_start(&t);\n+\n+        ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+\n+        vpx_usec_timer_mark(&t);\n+        const double elapsed_secs = vpx_usec_timer_elapsed(&t) / kUsecsInSec;\n+        const double fps = frames / elapsed_secs;\n+        const double minimum_psnr = min_psnr();\n+        std::string display_name(video_name);\n+        if (kEncodePerfTestThreads[k] > 1) {\n+          char thread_count[32];\n+          snprintf(thread_count, sizeof(thread_count), \""_t-%d\"",\n+                   kEncodePerfTestThreads[k]);\n+          display_name += thread_count;\n+        }\n+\n+        printf(\""{\\n\"");\n+        printf(\""\\t\\\""type\\\"" : \\\""encode_perf_test\\\"",\\n\"");\n+        printf(\""\\t\\\""version\\\"" : \\\""%s\\\"",\\n\"", VERSION_STRING_NOSP);\n+        printf(\""\\t\\\""videoName\\\"" : \\\""%s\\\"",\\n\"", display_name.c_str());\n+        printf(\""\\t\\\""encodeTimeSecs\\\"" : %f,\\n\"", elapsed_secs);\n+        printf(\""\\t\\\""totalFrames\\\"" : %u,\\n\"", frames);\n+        printf(\""\\t\\\""framesPerSecond\\\"" : %f,\\n\"", fps);\n+        printf(\""\\t\\\""minPsnr\\\"" : %f,\\n\"", minimum_psnr);\n+        printf(\""\\t\\\""speed\\\"" : %d,\\n\"", kEncodePerfTestSpeeds[j]);\n+        printf(\""\\t\\\""threads\\\"" : %d\\n\"", kEncodePerfTestThreads[k]);\n+        printf(\""}\\n\"");\n+      }\n+    }\n+  }\n+}\n+\n+VP9_INSTANTIATE_TEST_CASE(\n+    VP9EncodePerfTest, ::testing::Values(::libvpx_test::kRealTime));\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/encode_test_driver.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/encode_test_driver.cc"", ""patch"": ""@@ -8,15 +8,59 @@\n\n  *  be found in the AUTHORS file in the root of the source tree.\n  */\n \n-#include \""./vpx_config.h\""\n-#include \""test/codec_factory.h\""\n-#include \""test/encode_test_driver.h\""\n-#include \""test/decode_test_driver.h\""\n-#include \""test/register_state_check.h\""\n-#include \""test/video_source.h\""\n+#include <string>\n+\n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n \n+#include \""./vpx_config.h\""\n+#include \""test/codec_factory.h\""\n+#include \""test/decode_test_driver.h\""\n+#include \""test/encode_test_driver.h\""\n+#include \""test/register_state_check.h\""\n+#include \""test/video_source.h\""\n+\n namespace libvpx_test {\n+void Encoder::InitEncoder(VideoSource *video) {\n+  vpx_codec_err_t res;\n+  const vpx_image_t *img = video->img();\n+\n+  if (video->img() && !encoder_.priv) {\n+    cfg_.g_w = img->d_w;\n+    cfg_.g_h = img->d_h;\n+    cfg_.g_timebase = video->timebase();\n+    cfg_.rc_twopass_stats_in = stats_->buf();\n+\n+    res = vpx_codec_enc_init(&encoder_, CodecInterface(), &cfg_,\n+                             init_flags_);\n+    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n+\n+#if CONFIG_VP9_ENCODER\n+    if (CodecInterface() == &vpx_codec_vp9_cx_algo) {\n+      // Default to 1 tile column for VP9.\n+      const int log2_tile_columns = 0;\n+      res = vpx_codec_control_(&encoder_, VP9E_SET_TILE_COLUMNS,\n+                               log2_tile_columns);\n+      ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n+    } else\n+#endif\n+#if CONFIG_VP10_ENCODER\n+    if (CodecInterface() == &vpx_codec_vp10_cx_algo) {\n+      // Default to 1 tile column for VP10.\n+      const int log2_tile_columns = 0;\n+      res = vpx_codec_control_(&encoder_, VP9E_SET_TILE_COLUMNS,\n+                               log2_tile_columns);\n+      ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n+    } else\n+#endif\n+    {\n+#if CONFIG_VP8_ENCODER\n+      ASSERT_EQ(&vpx_codec_vp8_cx_algo, CodecInterface())\n+          << \""Unknown Codec Interface\"";\n+#endif\n+    }\n+  }\n+}\n+\n void Encoder::EncodeFrame(VideoSource *video, const unsigned long frame_flags) {\n   if (video->img())\n     EncodeFrameInternal(*video, frame_flags);\n@@ -39,17 +83,6 @@\n\n   vpx_codec_err_t res;\n   const vpx_image_t *img = video.img();\n \n-  // Handle first frame initialization\n-  if (!encoder_.priv) {\n-    cfg_.g_w = img->d_w;\n-    cfg_.g_h = img->d_h;\n-    cfg_.g_timebase = video.timebase();\n-    cfg_.rc_twopass_stats_in = stats_->buf();\n-    res = vpx_codec_enc_init(&encoder_, CodecInterface(), &cfg_,\n-                             init_flags_);\n-    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n-  }\n-\n   // Handle frame resizing\n   if (cfg_.g_w != img->d_w || cfg_.g_h != img->d_h) {\n     cfg_.g_w = img->d_w;\n@@ -59,9 +92,8 @@\n\n   }\n \n   // Encode the frame\n-  REGISTER_STATE_CHECK(\n-      res = vpx_codec_encode(&encoder_,\n-                             video.img(), video.pts(), video.duration(),\n+  API_REGISTER_STATE_CHECK(\n+      res = vpx_codec_encode(&encoder_, img, video.pts(), video.duration(),\n                              frame_flags, deadline_));\n   ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n }\n@@ -69,11 +101,15 @@\n\n void Encoder::Flush() {\n   const vpx_codec_err_t res = vpx_codec_encode(&encoder_, NULL, 0, 0, 0,\n                                                deadline_);\n-  ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n+  if (!encoder_.priv)\n+    ASSERT_EQ(VPX_CODEC_ERROR, res) << EncoderError();\n+  else\n+    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n }\n \n void EncoderTest::InitializeConfig() {\n   const vpx_codec_err_t res = codec_->DefaultEncoderConfig(&cfg_, 0);\n+  dec_cfg_ = vpx_codec_dec_cfg_t();\n   ASSERT_EQ(VPX_CODEC_OK, res);\n }\n \n@@ -107,6 +143,7 @@\n\n static bool compare_img(const vpx_image_t *img1,\n                         const vpx_image_t *img2) {\n   bool match = (img1->fmt == img2->fmt) &&\n+               (img1->cs == img2->cs) &&\n                (img1->d_w == img2->d_w) &&\n                (img1->d_h == img2->d_h);\n \n@@ -130,13 +167,13 @@\n\n   return match;\n }\n \n-void EncoderTest::MismatchHook(const vpx_image_t *img1,\n-                               const vpx_image_t *img2) {\n+void EncoderTest::MismatchHook(const vpx_image_t* /*img1*/,\n+                               const vpx_image_t* /*img2*/) {\n   ASSERT_TRUE(0) << \""Encode/Decode mismatch found\"";\n }\n \n void EncoderTest::RunLoop(VideoSource *video) {\n-  vpx_codec_dec_cfg_t dec_cfg = {0};\n+  vpx_codec_dec_cfg_t dec_cfg = vpx_codec_dec_cfg_t();\n \n   stats_.Reset();\n \n@@ -155,9 +192,18 @@\n\n     Encoder* const encoder = codec_->CreateEncoder(cfg_, deadline_, init_flags_,\n                                                    &stats_);\n     ASSERT_TRUE(encoder != NULL);\n-    Decoder* const decoder = codec_->CreateDecoder(dec_cfg, 0);\n+\n+    video->Begin();\n+    encoder->InitEncoder(video);\n+\n+    unsigned long dec_init_flags = 0;  // NOLINT\n+    // Use fragment decoder if encoder outputs partitions.\n+    // NOTE: fragment decoder and partition encoder are only supported by VP8.\n+    if (init_flags_ & VPX_CODEC_USE_OUTPUT_PARTITION)\n+      dec_init_flags |= VPX_CODEC_USE_INPUT_FRAGMENTS;\n+    Decoder* const decoder = codec_->CreateDecoder(dec_cfg, dec_init_flags, 0);\n     bool again;\n-    for (again = true, video->Begin(); again; video->Next()) {\n+    for (again = true; again; video->Next()) {\n       again = (video->img() != NULL);\n \n       PreEncodeFrameHook(video);\n@@ -177,7 +223,10 @@\n\n             if (decoder && DoDecode()) {\n               vpx_codec_err_t res_dec = decoder->DecodeFrame(\n                   (const uint8_t*)pkt->data.frame.buf, pkt->data.frame.sz);\n-              ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n+\n+              if (!HandleDecodeResult(res_dec, *video, decoder))\n+                break;\n+\n               has_dxdata = true;\n             }\n             ASSERT_GE(pkt->data.frame.pts, last_pts_);\n@@ -194,6 +243,13 @@\n\n         }\n       }\n \n+      // Flush the decoder when there are no more fragments.\n+      if ((init_flags_ & VPX_CODEC_USE_OUTPUT_PARTITION) && has_dxdata) {\n+        const vpx_codec_err_t res_dec = decoder->DecodeFrame(NULL, 0);\n+        if (!HandleDecodeResult(res_dec, *video, decoder))\n+          break;\n+      }\n+\n       if (has_dxdata && has_cxdata) {\n         const vpx_image_t *img_enc = encoder->GetPreviewFrame();\n         DxDataIterator dec_iter = decoder->GetDxData();\n""}<_**next**_>{""filename"": ""libvpx/test/encode_test_driver.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/encode_test_driver.h"", ""patch"": ""@@ -13,12 +13,13 @@\n\n #include <string>\n #include <vector>\n \n-#include \""./vpx_config.h\""\n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n-#include \""vpx/vpx_encoder.h\""\n-#if CONFIG_VP8_ENCODER || CONFIG_VP9_ENCODER\n+\n+#include \""./vpx_config.h\""\n+#if CONFIG_VP8_ENCODER || CONFIG_VP9_ENCODER || CONFIG_VP10_ENCODER\n #include \""vpx/vp8cx.h\""\n #endif\n+#include \""vpx/vpx_encoder.h\""\n \n namespace libvpx_test {\n \n@@ -104,6 +105,8 @@\n\n     return CxDataIterator(&encoder_);\n   }\n \n+  void InitEncoder(VideoSource *video);\n+\n   const vpx_image_t *GetPreviewFrame() {\n     return vpx_codec_get_preview_frame(&encoder_);\n   }\n@@ -131,13 +134,23 @@\n\n     ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n   }\n \n-#if CONFIG_VP8_ENCODER || CONFIG_VP9_ENCODER\n+  void Control(int ctrl_id, struct vpx_svc_parameters *arg) {\n+    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n+    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n+  }\n+#if CONFIG_VP8_ENCODER || CONFIG_VP9_ENCODER || CONFIG_VP10_ENCODER\n   void Control(int ctrl_id, vpx_active_map_t *arg) {\n     const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n     ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n   }\n #endif\n \n+  void Config(const vpx_codec_enc_cfg_t *cfg) {\n+    const vpx_codec_err_t res = vpx_codec_enc_config_set(&encoder_, cfg);\n+    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n+    cfg_ = *cfg;\n+  }\n+\n   void set_deadline(unsigned long deadline) {\n     deadline_ = deadline;\n   }\n@@ -175,7 +188,10 @@\n\n  protected:\n   explicit EncoderTest(const CodecFactory *codec)\n       : codec_(codec), abort_(false), init_flags_(0), frame_flags_(0),\n-        last_pts_(0) {}\n+        last_pts_(0) {\n+    // Default to 1 thread.\n+    cfg_.g_threads = 1;\n+  }\n \n   virtual ~EncoderTest() {}\n \n@@ -185,24 +201,30 @@\n\n   // Map the TestMode enum to the deadline_ and passes_ variables.\n   void SetMode(TestMode mode);\n \n+  // Set encoder flag.\n+  void set_init_flags(unsigned long flag) {  // NOLINT(runtime/int)\n+    init_flags_ = flag;\n+  }\n+\n   // Main loop\n   virtual void RunLoop(VideoSource *video);\n \n   // Hook to be called at the beginning of a pass.\n-  virtual void BeginPassHook(unsigned int pass) {}\n+  virtual void BeginPassHook(unsigned int /*pass*/) {}\n \n   // Hook to be called at the end of a pass.\n   virtual void EndPassHook() {}\n \n   // Hook to be called before encoding a frame.\n-  virtual void PreEncodeFrameHook(VideoSource *video) {}\n-  virtual void PreEncodeFrameHook(VideoSource *video, Encoder *encoder) {}\n+  virtual void PreEncodeFrameHook(VideoSource* /*video*/) {}\n+  virtual void PreEncodeFrameHook(VideoSource* /*video*/,\n+                                  Encoder* /*encoder*/) {}\n \n   // Hook to be called on every compressed data packet.\n-  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {}\n+  virtual void FramePktHook(const vpx_codec_cx_pkt_t* /*pkt*/) {}\n \n   // Hook to be called on every PSNR packet.\n-  virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {}\n+  virtual void PSNRPktHook(const vpx_codec_cx_pkt_t* /*pkt*/) {}\n \n   // Hook to determine whether the encode loop should continue.\n   virtual bool Continue() const {\n@@ -218,17 +240,26 @@\n\n                             const vpx_image_t *img2);\n \n   // Hook to be called on every decompressed frame.\n-  virtual void DecompressedFrameHook(const vpx_image_t& img,\n-                                     vpx_codec_pts_t pts) {}\n+  virtual void DecompressedFrameHook(const vpx_image_t& /*img*/,\n+                                     vpx_codec_pts_t /*pts*/) {}\n+\n+  // Hook to be called to handle decode result. Return true to continue.\n+  virtual bool HandleDecodeResult(const vpx_codec_err_t res_dec,\n+                                  const VideoSource& /*video*/,\n+                                  Decoder *decoder) {\n+    EXPECT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n+    return VPX_CODEC_OK == res_dec;\n+  }\n \n   // Hook that can modify the encoder's output data\n-  virtual const vpx_codec_cx_pkt_t * MutateEncoderOutputHook(\n+  virtual const vpx_codec_cx_pkt_t *MutateEncoderOutputHook(\n       const vpx_codec_cx_pkt_t *pkt) {\n     return pkt;\n   }\n \n   bool                 abort_;\n   vpx_codec_enc_cfg_t  cfg_;\n+  vpx_codec_dec_cfg_t  dec_cfg_;\n   unsigned int         passes_;\n   unsigned long        deadline_;\n   TwopassStatsStore    stats_;\n""}<_**next**_>{""filename"": ""libvpx/test/error_resilience_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/error_resilience_test.cc"", ""patch"": ""@@ -37,6 +37,7 @@\n\n   void Reset() {\n     error_nframes_ = 0;\n     droppable_nframes_ = 0;\n+    pattern_switch_ = 0;\n   }\n \n   virtual void SetUp() {\n@@ -56,22 +57,77 @@\n\n     nframes_++;\n   }\n \n-  virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video) {\n+  //\n+  // Frame flags and layer id for temporal layers.\n+  // For two layers, test pattern is:\n+  //   1     3\n+  // 0    2     .....\n+  // LAST is updated on base/layer 0, GOLDEN  updated on layer 1.\n+  // Non-zero pattern_switch parameter means pattern will switch to\n+  // not using LAST for frame_num >= pattern_switch.\n+  int SetFrameFlags(int frame_num,\n+                    int num_temp_layers,\n+                    int pattern_switch) {\n+    int frame_flags = 0;\n+    if (num_temp_layers == 2) {\n+        if (frame_num % 2 == 0) {\n+          if (frame_num < pattern_switch || pattern_switch == 0) {\n+            // Layer 0: predict from LAST and ARF, update LAST.\n+            frame_flags = VP8_EFLAG_NO_REF_GF |\n+                          VP8_EFLAG_NO_UPD_GF |\n+                          VP8_EFLAG_NO_UPD_ARF;\n+          } else {\n+            // Layer 0: predict from GF and ARF, update GF.\n+            frame_flags = VP8_EFLAG_NO_REF_LAST |\n+                          VP8_EFLAG_NO_UPD_LAST |\n+                          VP8_EFLAG_NO_UPD_ARF;\n+          }\n+        } else {\n+          if (frame_num < pattern_switch || pattern_switch == 0) {\n+            // Layer 1: predict from L, GF, and ARF, update GF.\n+            frame_flags = VP8_EFLAG_NO_UPD_ARF |\n+                          VP8_EFLAG_NO_UPD_LAST;\n+          } else {\n+            // Layer 1: predict from GF and ARF, update GF.\n+            frame_flags = VP8_EFLAG_NO_REF_LAST |\n+                          VP8_EFLAG_NO_UPD_LAST |\n+                          VP8_EFLAG_NO_UPD_ARF;\n+          }\n+        }\n+    }\n+    return frame_flags;\n+  }\n+\n+  virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n+                                  ::libvpx_test::Encoder *encoder) {\n     frame_flags_ &= ~(VP8_EFLAG_NO_UPD_LAST |\n                       VP8_EFLAG_NO_UPD_GF |\n                       VP8_EFLAG_NO_UPD_ARF);\n-    if (droppable_nframes_ > 0 &&\n-        (cfg_.g_pass == VPX_RC_LAST_PASS || cfg_.g_pass == VPX_RC_ONE_PASS)) {\n+    // For temporal layer case.\n+    if (cfg_.ts_number_layers > 1) {\n+      frame_flags_ = SetFrameFlags(video->frame(),\n+                                   cfg_.ts_number_layers,\n+                                   pattern_switch_);\n       for (unsigned int i = 0; i < droppable_nframes_; ++i) {\n         if (droppable_frames_[i] == video->frame()) {\n-          std::cout << \""             Encoding droppable frame: \""\n+          std::cout << \""Encoding droppable frame: \""\n                     << droppable_frames_[i] << \""\\n\"";\n-          frame_flags_ |= (VP8_EFLAG_NO_UPD_LAST |\n-                           VP8_EFLAG_NO_UPD_GF |\n-                           VP8_EFLAG_NO_UPD_ARF);\n-          return;\n         }\n       }\n+    } else {\n+       if (droppable_nframes_ > 0 &&\n+         (cfg_.g_pass == VPX_RC_LAST_PASS || cfg_.g_pass == VPX_RC_ONE_PASS)) {\n+         for (unsigned int i = 0; i < droppable_nframes_; ++i) {\n+           if (droppable_frames_[i] == video->frame()) {\n+             std::cout << \""Encoding droppable frame: \""\n+                       << droppable_frames_[i] << \""\\n\"";\n+             frame_flags_ |= (VP8_EFLAG_NO_UPD_LAST |\n+                              VP8_EFLAG_NO_UPD_GF |\n+                              VP8_EFLAG_NO_UPD_ARF);\n+             return;\n+           }\n+         }\n+       }\n     }\n   }\n \n@@ -133,11 +189,16 @@\n\n     return mismatch_nframes_;\n   }\n \n+  void SetPatternSwitch(int frame_switch) {\n+     pattern_switch_ = frame_switch;\n+   }\n+\n  private:\n   double psnr_;\n   unsigned int nframes_;\n   unsigned int error_nframes_;\n   unsigned int droppable_nframes_;\n+  unsigned int pattern_switch_;\n   double mismatch_psnr_;\n   unsigned int mismatch_nframes_;\n   unsigned int error_frames_[kMaxErrorFrames];\n@@ -236,7 +297,291 @@\n\n #endif\n }\n \n-VP8_INSTANTIATE_TEST_CASE(ErrorResilienceTestLarge, ONE_PASS_TEST_MODES);\n-VP9_INSTANTIATE_TEST_CASE(ErrorResilienceTestLarge, ONE_PASS_TEST_MODES);\n+// Check for successful decoding and no encoder/decoder mismatch\n+// if we lose (i.e., drop before decoding) the enhancement layer frames for a\n+// two layer temporal pattern. The base layer does not predict from the top\n+// layer, so successful decoding is expected.\n+TEST_P(ErrorResilienceTestLarge, 2LayersDropEnhancement) {\n+  const vpx_rational timebase = { 33333333, 1000000000 };\n+  cfg_.g_timebase = timebase;\n+  cfg_.rc_target_bitrate = 500;\n+  cfg_.g_lag_in_frames = 0;\n \n+  cfg_.rc_end_usage = VPX_CBR;\n+  // 2 Temporal layers, no spatial layers, CBR mode.\n+  cfg_.ss_number_layers = 1;\n+  cfg_.ts_number_layers = 2;\n+  cfg_.ts_rate_decimator[0] = 2;\n+  cfg_.ts_rate_decimator[1] = 1;\n+  cfg_.ts_periodicity = 2;\n+  cfg_.ts_target_bitrate[0] = 60 * cfg_.rc_target_bitrate / 100;\n+  cfg_.ts_target_bitrate[1] = cfg_.rc_target_bitrate;\n+\n+  init_flags_ = VPX_CODEC_USE_PSNR;\n+\n+  libvpx_test::I420VideoSource video(\""hantro_collage_w352h288.yuv\"", 352, 288,\n+                                     timebase.den, timebase.num, 0, 40);\n+\n+  // Error resilient mode ON.\n+  cfg_.g_error_resilient = 1;\n+  cfg_.kf_mode = VPX_KF_DISABLED;\n+  SetPatternSwitch(0);\n+\n+  // The odd frames are the enhancement layer for 2 layer pattern, so set\n+  // those frames as droppable. Drop the last 7 frames.\n+  unsigned int num_droppable_frames = 7;\n+  unsigned int droppable_frame_list[] = {27, 29, 31, 33, 35, 37, 39};\n+  SetDroppableFrames(num_droppable_frames, droppable_frame_list);\n+  SetErrorFrames(num_droppable_frames, droppable_frame_list);\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+  // Test that no mismatches have been found\n+  std::cout << \""             Mismatch frames: \""\n+            << GetMismatchFrames() << \""\\n\"";\n+  EXPECT_EQ(GetMismatchFrames(), (unsigned int) 0);\n+\n+  // Reset previously set of error/droppable frames.\n+  Reset();\n+}\n+\n+// Check for successful decoding and no encoder/decoder mismatch\n+// for a two layer temporal pattern, where at some point in the\n+// sequence, the LAST ref is not used anymore.\n+TEST_P(ErrorResilienceTestLarge, 2LayersNoRefLast) {\n+  const vpx_rational timebase = { 33333333, 1000000000 };\n+  cfg_.g_timebase = timebase;\n+  cfg_.rc_target_bitrate = 500;\n+  cfg_.g_lag_in_frames = 0;\n+\n+  cfg_.rc_end_usage = VPX_CBR;\n+  // 2 Temporal layers, no spatial layers, CBR mode.\n+  cfg_.ss_number_layers = 1;\n+  cfg_.ts_number_layers = 2;\n+  cfg_.ts_rate_decimator[0] = 2;\n+  cfg_.ts_rate_decimator[1] = 1;\n+  cfg_.ts_periodicity = 2;\n+  cfg_.ts_target_bitrate[0] = 60 * cfg_.rc_target_bitrate / 100;\n+  cfg_.ts_target_bitrate[1] = cfg_.rc_target_bitrate;\n+\n+  init_flags_ = VPX_CODEC_USE_PSNR;\n+\n+  libvpx_test::I420VideoSource video(\""hantro_collage_w352h288.yuv\"", 352, 288,\n+                                     timebase.den, timebase.num, 0, 100);\n+\n+  // Error resilient mode ON.\n+  cfg_.g_error_resilient = 1;\n+  cfg_.kf_mode = VPX_KF_DISABLED;\n+  SetPatternSwitch(60);\n+\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+  // Test that no mismatches have been found\n+  std::cout << \""             Mismatch frames: \""\n+            << GetMismatchFrames() << \""\\n\"";\n+  EXPECT_EQ(GetMismatchFrames(), (unsigned int) 0);\n+\n+  // Reset previously set of error/droppable frames.\n+  Reset();\n+}\n+\n+class ErrorResilienceTestLargeCodecControls : public ::libvpx_test::EncoderTest,\n+    public ::libvpx_test::CodecTestWithParam<libvpx_test::TestMode> {\n+ protected:\n+  ErrorResilienceTestLargeCodecControls()\n+      : EncoderTest(GET_PARAM(0)),\n+        encoding_mode_(GET_PARAM(1)) {\n+    Reset();\n+  }\n+\n+  virtual ~ErrorResilienceTestLargeCodecControls() {}\n+\n+  void Reset() {\n+    last_pts_ = 0;\n+    tot_frame_number_ = 0;\n+    // For testing up to 3 layers.\n+    for (int i = 0; i < 3; ++i) {\n+      bits_total_[i] = 0;\n+    }\n+    duration_ = 0.0;\n+  }\n+\n+  virtual void SetUp() {\n+    InitializeConfig();\n+    SetMode(encoding_mode_);\n+  }\n+\n+  //\n+  // Frame flags and layer id for temporal layers.\n+  //\n+\n+  // For two layers, test pattern is:\n+  //   1     3\n+  // 0    2     .....\n+  // For three layers, test pattern is:\n+  //   1      3    5      7\n+  //      2           6\n+  // 0          4            ....\n+  // LAST is always update on base/layer 0, GOLDEN is updated on layer 1,\n+  // and ALTREF is updated on top layer for 3 layer pattern.\n+  int SetFrameFlags(int frame_num, int num_temp_layers) {\n+    int frame_flags = 0;\n+    if (num_temp_layers == 2) {\n+      if (frame_num % 2 == 0) {\n+        // Layer 0: predict from L and ARF, update L.\n+        frame_flags = VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_UPD_GF |\n+                      VP8_EFLAG_NO_UPD_ARF;\n+      } else {\n+        // Layer 1: predict from L, G and ARF, and update G.\n+        frame_flags = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST |\n+                      VP8_EFLAG_NO_UPD_ENTROPY;\n+      }\n+    } else if (num_temp_layers == 3) {\n+      if (frame_num % 4 == 0) {\n+        // Layer 0: predict from L, update L.\n+        frame_flags = VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF |\n+                      VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF;\n+      } else if ((frame_num - 2) % 4 == 0) {\n+        // Layer 1: predict from L, G,  update G.\n+        frame_flags = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST |\n+                      VP8_EFLAG_NO_REF_ARF;\n+      }  else if ((frame_num - 1) % 2 == 0) {\n+        // Layer 2: predict from L, G, ARF; update ARG.\n+        frame_flags = VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_LAST;\n+      }\n+    }\n+    return frame_flags;\n+  }\n+\n+  int SetLayerId(int frame_num, int num_temp_layers) {\n+    int layer_id = 0;\n+    if (num_temp_layers == 2) {\n+      if (frame_num % 2 == 0) {\n+        layer_id = 0;\n+      } else {\n+         layer_id = 1;\n+      }\n+    } else if (num_temp_layers == 3) {\n+      if (frame_num % 4 == 0) {\n+        layer_id = 0;\n+      } else if ((frame_num - 2) % 4 == 0) {\n+        layer_id = 1;\n+      } else if ((frame_num - 1) % 2 == 0) {\n+        layer_id = 2;\n+      }\n+    }\n+    return layer_id;\n+  }\n+\n+  virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n+                                  libvpx_test::Encoder *encoder) {\n+    if (cfg_.ts_number_layers > 1) {\n+        int layer_id = SetLayerId(video->frame(), cfg_.ts_number_layers);\n+        int frame_flags = SetFrameFlags(video->frame(), cfg_.ts_number_layers);\n+        if (video->frame() > 0) {\n+          encoder->Control(VP8E_SET_TEMPORAL_LAYER_ID, layer_id);\n+          encoder->Control(VP8E_SET_FRAME_FLAGS, frame_flags);\n+        }\n+       const vpx_rational_t tb = video->timebase();\n+       timebase_ = static_cast<double>(tb.num) / tb.den;\n+       duration_ = 0;\n+       return;\n+    }\n+  }\n+\n+  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n+    // Time since last timestamp = duration.\n+    vpx_codec_pts_t duration = pkt->data.frame.pts - last_pts_;\n+    if (duration > 1) {\n+      // Update counter for total number of frames (#frames input to encoder).\n+      // Needed for setting the proper layer_id below.\n+      tot_frame_number_ += static_cast<int>(duration - 1);\n+    }\n+    int layer = SetLayerId(tot_frame_number_, cfg_.ts_number_layers);\n+    const size_t frame_size_in_bits = pkt->data.frame.sz * 8;\n+    // Update the total encoded bits. For temporal layers, update the cumulative\n+    // encoded bits per layer.\n+    for (int i = layer; i < static_cast<int>(cfg_.ts_number_layers); ++i) {\n+      bits_total_[i] += frame_size_in_bits;\n+    }\n+    // Update the most recent pts.\n+    last_pts_ = pkt->data.frame.pts;\n+    ++tot_frame_number_;\n+  }\n+\n+  virtual void EndPassHook(void) {\n+    duration_ = (last_pts_ + 1) * timebase_;\n+    if (cfg_.ts_number_layers  > 1) {\n+      for (int layer = 0; layer < static_cast<int>(cfg_.ts_number_layers);\n+          ++layer) {\n+        if (bits_total_[layer]) {\n+          // Effective file datarate:\n+          effective_datarate_[layer] = (bits_total_[layer] / 1000.0) / duration_;\n+        }\n+      }\n+    }\n+  }\n+\n+  double effective_datarate_[3];\n+   private:\n+    libvpx_test::TestMode encoding_mode_;\n+    vpx_codec_pts_t last_pts_;\n+    double timebase_;\n+    int64_t bits_total_[3];\n+    double duration_;\n+    int tot_frame_number_;\n+  };\n+\n+// Check two codec controls used for:\n+// (1) for setting temporal layer id, and (2) for settings encoder flags.\n+// This test invokes those controls for each frame, and verifies encoder/decoder\n+// mismatch and basic rate control response.\n+// TODO(marpan): Maybe move this test to datarate_test.cc.\n+TEST_P(ErrorResilienceTestLargeCodecControls, CodecControl3TemporalLayers) {\n+  cfg_.rc_buf_initial_sz = 500;\n+  cfg_.rc_buf_optimal_sz = 500;\n+  cfg_.rc_buf_sz = 1000;\n+  cfg_.rc_dropframe_thresh = 1;\n+  cfg_.rc_min_quantizer = 2;\n+  cfg_.rc_max_quantizer = 56;\n+  cfg_.rc_end_usage = VPX_CBR;\n+  cfg_.rc_dropframe_thresh = 1;\n+  cfg_.g_lag_in_frames = 0;\n+  cfg_.kf_mode = VPX_KF_DISABLED;\n+  cfg_.g_error_resilient = 1;\n+\n+  // 3 Temporal layers. Framerate decimation (4, 2, 1).\n+  cfg_.ts_number_layers = 3;\n+  cfg_.ts_rate_decimator[0] = 4;\n+  cfg_.ts_rate_decimator[1] = 2;\n+  cfg_.ts_rate_decimator[2] = 1;\n+  cfg_.ts_periodicity = 4;\n+  cfg_.ts_layer_id[0] = 0;\n+  cfg_.ts_layer_id[1] = 2;\n+  cfg_.ts_layer_id[2] = 1;\n+  cfg_.ts_layer_id[3] = 2;\n+\n+  ::libvpx_test::I420VideoSource video(\""hantro_collage_w352h288.yuv\"", 352, 288,\n+                                       30, 1, 0, 200);\n+  for (int i = 200; i <= 800; i += 200) {\n+    cfg_.rc_target_bitrate = i;\n+    Reset();\n+    // 40-20-40 bitrate allocation for 3 temporal layers.\n+    cfg_.ts_target_bitrate[0] = 40 * cfg_.rc_target_bitrate / 100;\n+    cfg_.ts_target_bitrate[1] = 60 * cfg_.rc_target_bitrate / 100;\n+    cfg_.ts_target_bitrate[2] = cfg_.rc_target_bitrate;\n+    ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+    for (int j = 0; j < static_cast<int>(cfg_.ts_number_layers); ++j) {\n+      ASSERT_GE(effective_datarate_[j], cfg_.ts_target_bitrate[j] * 0.75)\n+          << \"" The datarate for the file is lower than target by too much, \""\n+              \""for layer: \"" << j;\n+      ASSERT_LE(effective_datarate_[j], cfg_.ts_target_bitrate[j] * 1.25)\n+          << \"" The datarate for the file is greater than target by too much, \""\n+              \""for layer: \"" << j;\n+    }\n+  }\n+}\n+\n+VP8_INSTANTIATE_TEST_CASE(ErrorResilienceTestLarge, ONE_PASS_TEST_MODES);\n+VP8_INSTANTIATE_TEST_CASE(ErrorResilienceTestLargeCodecControls,\n+                          ONE_PASS_TEST_MODES);\n+VP9_INSTANTIATE_TEST_CASE(ErrorResilienceTestLarge, ONE_PASS_TEST_MODES);\n+VP10_INSTANTIATE_TEST_CASE(ErrorResilienceTestLarge, ONE_PASS_TEST_MODES);\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/examples.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/examples.sh"", ""patch"": ""@@ -0,0 +1,29 @@\n\n+#!/bin/sh\n+##\n+##  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+##\n+##  Use of this source code is governed by a BSD-style license\n+##  that can be found in the LICENSE file in the root of the source\n+##  tree. An additional intellectual property rights grant can be found\n+##  in the file PATENTS.  All contributing project authors may\n+##  be found in the AUTHORS file in the root of the source tree.\n+##\n+##  This file runs all of the tests for the libvpx examples.\n+##\n+. $(dirname $0)/tools_common.sh\n+\n+example_tests=$(ls $(dirname $0)/*.sh)\n+\n+# List of script names to exclude.\n+exclude_list=\""examples tools_common\""\n+\n+# Filter out the scripts in $exclude_list.\n+for word in ${exclude_list}; do\n+  example_tests=$(filter_strings \""${example_tests}\"" \""${word}\"" exclude)\n+done\n+\n+for test in ${example_tests}; do\n+  # Source each test script so that exporting variables can be avoided.\n+  VPX_TEST_NAME=\""$(basename ${test%.*})\""\n+  . \""${test}\""\n+done\n""}<_**next**_>{""filename"": ""libvpx/test/external_frame_buffer_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/external_frame_buffer_test.cc"", ""patch"": ""@@ -10,13 +10,16 @@\n\n \n #include <string>\n \n+#include \""./vpx_config.h\""\n #include \""test/codec_factory.h\""\n #include \""test/decode_test_driver.h\""\n #include \""test/ivf_video_source.h\""\n #include \""test/md5_helper.h\""\n #include \""test/test_vectors.h\""\n #include \""test/util.h\""\n+#if CONFIG_WEBM_IO\n #include \""test/webm_video_source.h\""\n+#endif\n \n namespace {\n \n@@ -68,6 +71,7 @@\n\n     if (ext_fb_list_[idx].size < min_size) {\n       delete [] ext_fb_list_[idx].data;\n       ext_fb_list_[idx].data = new uint8_t[min_size];\n+      memset(ext_fb_list_[idx].data, 0, min_size);\n       ext_fb_list_[idx].size = min_size;\n     }\n \n@@ -93,13 +97,19 @@\n\n     return 0;\n   }\n \n-  // Marks the external frame buffer that |fb| is pointing too as free.\n+  // Marks the external frame buffer that |fb| is pointing to as free.\n   // Returns < 0 on an error.\n   int ReturnFrameBuffer(vpx_codec_frame_buffer_t *fb) {\n-    EXPECT_TRUE(fb != NULL);\n+    if (fb == NULL) {\n+      EXPECT_TRUE(fb != NULL);\n+      return -1;\n+    }\n     ExternalFrameBuffer *const ext_fb =\n         reinterpret_cast<ExternalFrameBuffer*>(fb->priv);\n-    EXPECT_TRUE(ext_fb != NULL);\n+    if (ext_fb == NULL) {\n+      EXPECT_TRUE(ext_fb != NULL);\n+      return -1;\n+    }\n     EXPECT_EQ(1, ext_fb->in_use);\n     ext_fb->in_use = 0;\n     return 0;\n@@ -267,6 +277,7 @@\n\n   ExternalFrameBufferList fb_list_;\n };\n \n+#if CONFIG_WEBM_IO\n // Class for testing passing in external frame buffers to libvpx.\n class ExternalFrameBufferTest : public ::testing::Test {\n  protected:\n@@ -281,7 +292,7 @@\n\n     video_->Init();\n     video_->Begin();\n \n-    vpx_codec_dec_cfg_t cfg = {0};\n+    vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n     decoder_ = new libvpx_test::VP9Decoder(cfg, 0);\n     ASSERT_TRUE(decoder_ != NULL);\n   }\n@@ -340,6 +351,7 @@\n\n   int num_buffers_;\n   ExternalFrameBufferList fb_list_;\n };\n+#endif  // CONFIG_WEBM_IO\n \n // This test runs through the set of test vectors, and decodes them.\n // Libvpx will call into the application to allocate a frame buffer when\n@@ -366,7 +378,13 @@\n\n   if (filename.substr(filename.length() - 3, 3) == \""ivf\"") {\n     video = new libvpx_test::IVFVideoSource(filename);\n   } else {\n+#if CONFIG_WEBM_IO\n     video = new libvpx_test::WebMVideoSource(filename);\n+#else\n+    fprintf(stderr, \""WebM IO is disabled, skipping test vector %s\\n\"",\n+            filename.c_str());\n+    return;\n+#endif\n   }\n   ASSERT_TRUE(video != NULL);\n   video->Init();\n@@ -380,6 +398,7 @@\n\n   delete video;\n }\n \n+#if CONFIG_WEBM_IO\n TEST_F(ExternalFrameBufferTest, MinFrameBuffers) {\n   // Minimum number of external frame buffers for VP9 is\n   // #VP9_MAXIMUM_REF_BUFFERS + #VPX_MAXIMUM_WORK_BUFFERS.\n@@ -460,6 +479,7 @@\n\n             SetFrameBufferFunctions(\n                 num_buffers, get_vp9_frame_buffer, release_vp9_frame_buffer));\n }\n+#endif  // CONFIG_WEBM_IO\n \n VP9_INSTANTIATE_TEST_CASE(ExternalFrameBufferMD5Test,\n                           ::testing::ValuesIn(libvpx_test::kVP9TestVectors,\n""}<_**next**_>{""filename"": ""libvpx/test/fdct4x4_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/fdct4x4_test.cc"", ""patch"": ""@@ -13,74 +13,140 @@\n\n #include <string.h>\n \n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vp9_rtcd.h\""\n+#include \""./vpx_dsp_rtcd.h\""\n #include \""test/acm_random.h\""\n #include \""test/clear_system_state.h\""\n #include \""test/register_state_check.h\""\n #include \""test/util.h\""\n-\n-#include \""./vp9_rtcd.h\""\n #include \""vp9/common/vp9_entropy.h\""\n+#include \""vpx/vpx_codec.h\""\n #include \""vpx/vpx_integer.h\""\n-\n-extern \""C\"" {\n-void vp9_idct4x4_16_add_c(const int16_t *input, uint8_t *output, int pitch);\n-}\n+#include \""vpx_ports/mem.h\""\n \n using libvpx_test::ACMRandom;\n \n namespace {\n const int kNumCoeffs = 16;\n-typedef void (*fdct_t)(const int16_t *in, int16_t *out, int stride);\n-typedef void (*idct_t)(const int16_t *in, uint8_t *out, int stride);\n-typedef void (*fht_t) (const int16_t *in, int16_t *out, int stride,\n-                       int tx_type);\n-typedef void (*iht_t) (const int16_t *in, uint8_t *out, int stride,\n-                       int tx_type);\n+typedef void (*FdctFunc)(const int16_t *in, tran_low_t *out, int stride);\n+typedef void (*IdctFunc)(const tran_low_t *in, uint8_t *out, int stride);\n+typedef void (*FhtFunc)(const int16_t *in, tran_low_t *out, int stride,\n+                        int tx_type);\n+typedef void (*IhtFunc)(const tran_low_t *in, uint8_t *out, int stride,\n+                        int tx_type);\n \n-typedef std::tr1::tuple<fdct_t, idct_t, int> dct_4x4_param_t;\n-typedef std::tr1::tuple<fht_t, iht_t, int> ht_4x4_param_t;\n+typedef std::tr1::tuple<FdctFunc, IdctFunc, int, vpx_bit_depth_t> Dct4x4Param;\n+typedef std::tr1::tuple<FhtFunc, IhtFunc, int, vpx_bit_depth_t> Ht4x4Param;\n \n-void fdct4x4_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n-  vp9_fdct4x4_c(in, out, stride);\n+void fdct4x4_ref(const int16_t *in, tran_low_t *out, int stride,\n+                 int tx_type) {\n+  vpx_fdct4x4_c(in, out, stride);\n }\n \n-void fht4x4_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n+void fht4x4_ref(const int16_t *in, tran_low_t *out, int stride, int tx_type) {\n   vp9_fht4x4_c(in, out, stride, tx_type);\n }\n \n+void fwht4x4_ref(const int16_t *in, tran_low_t *out, int stride,\n+                 int tx_type) {\n+  vp9_fwht4x4_c(in, out, stride);\n+}\n+\n+#if CONFIG_VP9_HIGHBITDEPTH\n+void idct4x4_10(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct4x4_16_add_c(in, out, stride, 10);\n+}\n+\n+void idct4x4_12(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct4x4_16_add_c(in, out, stride, 12);\n+}\n+\n+void iht4x4_10(const tran_low_t *in, uint8_t *out, int stride, int tx_type) {\n+  vp9_highbd_iht4x4_16_add_c(in, out, stride, tx_type, 10);\n+}\n+\n+void iht4x4_12(const tran_low_t *in, uint8_t *out, int stride, int tx_type) {\n+  vp9_highbd_iht4x4_16_add_c(in, out, stride, tx_type, 12);\n+}\n+\n+void iwht4x4_10(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_iwht4x4_16_add_c(in, out, stride, 10);\n+}\n+\n+void iwht4x4_12(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_iwht4x4_16_add_c(in, out, stride, 12);\n+}\n+\n+#if HAVE_SSE2\n+void idct4x4_10_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct4x4_16_add_sse2(in, out, stride, 10);\n+}\n+\n+void idct4x4_12_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct4x4_16_add_sse2(in, out, stride, 12);\n+}\n+#endif  // HAVE_SSE2\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+\n class Trans4x4TestBase {\n  public:\n   virtual ~Trans4x4TestBase() {}\n \n  protected:\n-  virtual void RunFwdTxfm(const int16_t *in, int16_t *out, int stride) = 0;\n+  virtual void RunFwdTxfm(const int16_t *in, tran_low_t *out, int stride) = 0;\n \n-  virtual void RunInvTxfm(const int16_t *out, uint8_t *dst, int stride) = 0;\n+  virtual void RunInvTxfm(const tran_low_t *out, uint8_t *dst, int stride) = 0;\n \n-  void RunAccuracyCheck() {\n+  void RunAccuracyCheck(int limit) {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     uint32_t max_error = 0;\n     int64_t total_error = 0;\n     const int count_test_block = 10000;\n     for (int i = 0; i < count_test_block; ++i) {\n-      DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, kNumCoeffs);\n-      DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, kNumCoeffs);\n-      DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);\n-      DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);\n+      DECLARE_ALIGNED(16, int16_t, test_input_block[kNumCoeffs]);\n+      DECLARE_ALIGNED(16, tran_low_t, test_temp_block[kNumCoeffs]);\n+      DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n+      DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n+      DECLARE_ALIGNED(16, uint16_t, src16[kNumCoeffs]);\n+#endif\n \n       // Initialize a test block with input range [-255, 255].\n       for (int j = 0; j < kNumCoeffs; ++j) {\n-        src[j] = rnd.Rand8();\n-        dst[j] = rnd.Rand8();\n-        test_input_block[j] = src[j] - dst[j];\n+        if (bit_depth_ == VPX_BITS_8) {\n+          src[j] = rnd.Rand8();\n+          dst[j] = rnd.Rand8();\n+          test_input_block[j] = src[j] - dst[j];\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        } else {\n+          src16[j] = rnd.Rand16() & mask_;\n+          dst16[j] = rnd.Rand16() & mask_;\n+          test_input_block[j] = src16[j] - dst16[j];\n+#endif\n+        }\n       }\n \n-      REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,\n-                                      test_temp_block, pitch_));\n-      REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));\n+      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,\n+                                          test_temp_block, pitch_));\n+      if (bit_depth_ == VPX_BITS_8) {\n+        ASM_REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        ASM_REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block,\n+                                            CONVERT_TO_BYTEPTR(dst16), pitch_));\n+#endif\n+      }\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        const uint32_t diff =\n+            bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n+#else\n+        ASSERT_EQ(VPX_BITS_8, bit_depth_);\n         const uint32_t diff = dst[j] - src[j];\n+#endif\n         const uint32_t error = diff * diff;\n         if (max_error < error)\n           max_error = error;\n@@ -88,27 +154,29 @@\n\n       }\n     }\n \n-    EXPECT_GE(1u, max_error)\n-        << \""Error: 4x4 FHT/IHT has an individual round trip error > 1\"";\n+    EXPECT_GE(static_cast<uint32_t>(limit), max_error)\n+        << \""Error: 4x4 FHT/IHT has an individual round trip error > \""\n+        << limit;\n \n-    EXPECT_GE(count_test_block , total_error)\n-        << \""Error: 4x4 FHT/IHT has average round trip error > 1 per block\"";\n+    EXPECT_GE(count_test_block * limit, total_error)\n+        << \""Error: 4x4 FHT/IHT has average round trip error > \"" << limit\n+        << \"" per block\"";\n   }\n \n   void RunCoeffCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 5000;\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);\n+    DECLARE_ALIGNED(16, int16_t, input_block[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);\n \n     for (int i = 0; i < count_test_block; ++i) {\n-      // Initialize a test block with input range [-255, 255].\n+      // Initialize a test block with input range [-mask_, mask_].\n       for (int j = 0; j < kNumCoeffs; ++j)\n-        input_block[j] = rnd.Rand8() - rnd.Rand8();\n+        input_block[j] = (rnd.Rand16() & mask_) - (rnd.Rand16() & mask_);\n \n       fwd_txfm_ref(input_block, output_ref_block, pitch_, tx_type_);\n-      REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));\n+      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));\n \n       // The minimum quant value is 4.\n       for (int j = 0; j < kNumCoeffs; ++j)\n@@ -119,62 +187,85 @@\n\n   void RunMemCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 5000;\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, input_extreme_block, kNumCoeffs);\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);\n+    DECLARE_ALIGNED(16, int16_t, input_extreme_block[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);\n \n     for (int i = 0; i < count_test_block; ++i) {\n-      // Initialize a test block with input range [-255, 255].\n+      // Initialize a test block with input range [-mask_, mask_].\n       for (int j = 0; j < kNumCoeffs; ++j) {\n-        input_block[j] = rnd.Rand8() - rnd.Rand8();\n-        input_extreme_block[j] = rnd.Rand8() % 2 ? 255 : -255;\n+        input_extreme_block[j] = rnd.Rand8() % 2 ? mask_ : -mask_;\n       }\n-      if (i == 0)\n+      if (i == 0) {\n         for (int j = 0; j < kNumCoeffs; ++j)\n-          input_extreme_block[j] = 255;\n-      if (i == 1)\n+          input_extreme_block[j] = mask_;\n+      } else if (i == 1) {\n         for (int j = 0; j < kNumCoeffs; ++j)\n-          input_extreme_block[j] = -255;\n+          input_extreme_block[j] = -mask_;\n+      }\n \n       fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);\n-      REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,\n-                                      output_block, pitch_));\n+      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,\n+                                          output_block, pitch_));\n \n       // The minimum quant value is 4.\n       for (int j = 0; j < kNumCoeffs; ++j) {\n         EXPECT_EQ(output_block[j], output_ref_block[j]);\n-        EXPECT_GE(4 * DCT_MAX_VALUE, abs(output_block[j]))\n-            << \""Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE\"";\n+        EXPECT_GE(4 * DCT_MAX_VALUE << (bit_depth_ - 8), abs(output_block[j]))\n+            << \""Error: 4x4 FDCT has coefficient larger than 4*DCT_MAX_VALUE\"";\n       }\n     }\n   }\n \n-  void RunInvAccuracyCheck() {\n+  void RunInvAccuracyCheck(int limit) {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 1000;\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, in, kNumCoeffs);\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, coeff, kNumCoeffs);\n-    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);\n-    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);\n+    DECLARE_ALIGNED(16, int16_t, in[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint16_t, src16[kNumCoeffs]);\n+#endif\n \n     for (int i = 0; i < count_test_block; ++i) {\n-      // Initialize a test block with input range [-255, 255].\n+      // Initialize a test block with input range [-mask_, mask_].\n       for (int j = 0; j < kNumCoeffs; ++j) {\n-        src[j] = rnd.Rand8();\n-        dst[j] = rnd.Rand8();\n-        in[j] = src[j] - dst[j];\n+        if (bit_depth_ == VPX_BITS_8) {\n+          src[j] = rnd.Rand8();\n+          dst[j] = rnd.Rand8();\n+          in[j] = src[j] - dst[j];\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        } else {\n+          src16[j] = rnd.Rand16() & mask_;\n+          dst16[j] = rnd.Rand16() & mask_;\n+          in[j] = src16[j] - dst16[j];\n+#endif\n+        }\n       }\n \n       fwd_txfm_ref(in, coeff, pitch_, tx_type_);\n \n-      REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, pitch_));\n+      if (bit_depth_ == VPX_BITS_8) {\n+        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, pitch_));\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, CONVERT_TO_BYTEPTR(dst16),\n+                                            pitch_));\n+#endif\n+      }\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        const uint32_t diff =\n+            bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n+#else\n         const uint32_t diff = dst[j] - src[j];\n+#endif\n         const uint32_t error = diff * diff;\n-        EXPECT_GE(1u, error)\n-            << \""Error: 16x16 IDCT has error \"" << error\n+        EXPECT_GE(static_cast<uint32_t>(limit), error)\n+            << \""Error: 4x4 IDCT has error \"" << error\n             << \"" at index \"" << j;\n       }\n     }\n@@ -182,12 +273,14 @@\n\n \n   int pitch_;\n   int tx_type_;\n-  fht_t fwd_txfm_ref;\n+  FhtFunc fwd_txfm_ref;\n+  vpx_bit_depth_t bit_depth_;\n+  int mask_;\n };\n \n class Trans4x4DCT\n     : public Trans4x4TestBase,\n-      public ::testing::TestWithParam<dct_4x4_param_t> {\n+      public ::testing::TestWithParam<Dct4x4Param> {\n  public:\n   virtual ~Trans4x4DCT() {}\n \n@@ -197,23 +290,25 @@\n\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 4;\n     fwd_txfm_ref = fdct4x4_ref;\n+    bit_depth_ = GET_PARAM(3);\n+    mask_ = (1 << bit_depth_) - 1;\n   }\n   virtual void TearDown() { libvpx_test::ClearSystemState(); }\n \n  protected:\n-  void RunFwdTxfm(const int16_t *in, int16_t *out, int stride) {\n+  void RunFwdTxfm(const int16_t *in, tran_low_t *out, int stride) {\n     fwd_txfm_(in, out, stride);\n   }\n-  void RunInvTxfm(const int16_t *out, uint8_t *dst, int stride) {\n+  void RunInvTxfm(const tran_low_t *out, uint8_t *dst, int stride) {\n     inv_txfm_(out, dst, stride);\n   }\n \n-  fdct_t fwd_txfm_;\n-  idct_t inv_txfm_;\n+  FdctFunc fwd_txfm_;\n+  IdctFunc inv_txfm_;\n };\n \n TEST_P(Trans4x4DCT, AccuracyCheck) {\n-  RunAccuracyCheck();\n+  RunAccuracyCheck(1);\n }\n \n TEST_P(Trans4x4DCT, CoeffCheck) {\n@@ -225,12 +320,12 @@\n\n }\n \n TEST_P(Trans4x4DCT, InvAccuracyCheck) {\n-  RunInvAccuracyCheck();\n+  RunInvAccuracyCheck(1);\n }\n \n class Trans4x4HT\n     : public Trans4x4TestBase,\n-      public ::testing::TestWithParam<ht_4x4_param_t> {\n+      public ::testing::TestWithParam<Ht4x4Param> {\n  public:\n   virtual ~Trans4x4HT() {}\n \n@@ -240,24 +335,26 @@\n\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 4;\n     fwd_txfm_ref = fht4x4_ref;\n+    bit_depth_ = GET_PARAM(3);\n+    mask_ = (1 << bit_depth_) - 1;\n   }\n   virtual void TearDown() { libvpx_test::ClearSystemState(); }\n \n  protected:\n-  void RunFwdTxfm(const int16_t *in, int16_t *out, int stride) {\n+  void RunFwdTxfm(const int16_t *in, tran_low_t *out, int stride) {\n     fwd_txfm_(in, out, stride, tx_type_);\n   }\n \n-  void RunInvTxfm(const int16_t *out, uint8_t *dst, int stride) {\n+  void RunInvTxfm(const tran_low_t *out, uint8_t *dst, int stride) {\n     inv_txfm_(out, dst, stride, tx_type_);\n   }\n \n-  fht_t fwd_txfm_;\n-  iht_t inv_txfm_;\n+  FhtFunc fwd_txfm_;\n+  IhtFunc inv_txfm_;\n };\n \n TEST_P(Trans4x4HT, AccuracyCheck) {\n-  RunAccuracyCheck();\n+  RunAccuracyCheck(1);\n }\n \n TEST_P(Trans4x4HT, CoeffCheck) {\n@@ -269,51 +366,189 @@\n\n }\n \n TEST_P(Trans4x4HT, InvAccuracyCheck) {\n-  RunInvAccuracyCheck();\n+  RunInvAccuracyCheck(1);\n }\n \n+class Trans4x4WHT\n+    : public Trans4x4TestBase,\n+      public ::testing::TestWithParam<Dct4x4Param> {\n+ public:\n+  virtual ~Trans4x4WHT() {}\n+\n+  virtual void SetUp() {\n+    fwd_txfm_ = GET_PARAM(0);\n+    inv_txfm_ = GET_PARAM(1);\n+    tx_type_  = GET_PARAM(2);\n+    pitch_    = 4;\n+    fwd_txfm_ref = fwht4x4_ref;\n+    bit_depth_ = GET_PARAM(3);\n+    mask_ = (1 << bit_depth_) - 1;\n+  }\n+  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n+\n+ protected:\n+  void RunFwdTxfm(const int16_t *in, tran_low_t *out, int stride) {\n+    fwd_txfm_(in, out, stride);\n+  }\n+  void RunInvTxfm(const tran_low_t *out, uint8_t *dst, int stride) {\n+    inv_txfm_(out, dst, stride);\n+  }\n+\n+  FdctFunc fwd_txfm_;\n+  IdctFunc inv_txfm_;\n+};\n+\n+TEST_P(Trans4x4WHT, AccuracyCheck) {\n+  RunAccuracyCheck(0);\n+}\n+\n+TEST_P(Trans4x4WHT, CoeffCheck) {\n+  RunCoeffCheck();\n+}\n+\n+TEST_P(Trans4x4WHT, MemCheck) {\n+  RunMemCheck();\n+}\n+\n+TEST_P(Trans4x4WHT, InvAccuracyCheck) {\n+  RunInvAccuracyCheck(0);\n+}\n using std::tr1::make_tuple;\n \n+#if CONFIG_VP9_HIGHBITDEPTH\n INSTANTIATE_TEST_CASE_P(\n     C, Trans4x4DCT,\n     ::testing::Values(\n-        make_tuple(&vp9_fdct4x4_c, &vp9_idct4x4_16_add_c, 0)));\n+        make_tuple(&vpx_highbd_fdct4x4_c, &idct4x4_10, 0, VPX_BITS_10),\n+        make_tuple(&vpx_highbd_fdct4x4_c, &idct4x4_12, 0, VPX_BITS_12),\n+        make_tuple(&vpx_fdct4x4_c, &vpx_idct4x4_16_add_c, 0, VPX_BITS_8)));\n+#else\n+INSTANTIATE_TEST_CASE_P(\n+    C, Trans4x4DCT,\n+    ::testing::Values(\n+        make_tuple(&vpx_fdct4x4_c, &vpx_idct4x4_16_add_c, 0, VPX_BITS_8)));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+\n+#if CONFIG_VP9_HIGHBITDEPTH\n INSTANTIATE_TEST_CASE_P(\n     C, Trans4x4HT,\n     ::testing::Values(\n-        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_c, 0),\n-        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_c, 1),\n-        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_c, 2),\n-        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_c, 3)));\n+        make_tuple(&vp9_highbd_fht4x4_c, &iht4x4_10, 0, VPX_BITS_10),\n+        make_tuple(&vp9_highbd_fht4x4_c, &iht4x4_10, 1, VPX_BITS_10),\n+        make_tuple(&vp9_highbd_fht4x4_c, &iht4x4_10, 2, VPX_BITS_10),\n+        make_tuple(&vp9_highbd_fht4x4_c, &iht4x4_10, 3, VPX_BITS_10),\n+        make_tuple(&vp9_highbd_fht4x4_c, &iht4x4_12, 0, VPX_BITS_12),\n+        make_tuple(&vp9_highbd_fht4x4_c, &iht4x4_12, 1, VPX_BITS_12),\n+        make_tuple(&vp9_highbd_fht4x4_c, &iht4x4_12, 2, VPX_BITS_12),\n+        make_tuple(&vp9_highbd_fht4x4_c, &iht4x4_12, 3, VPX_BITS_12),\n+        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_c, 0, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_c, 1, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_c, 2, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_c, 3, VPX_BITS_8)));\n+#else\n+INSTANTIATE_TEST_CASE_P(\n+    C, Trans4x4HT,\n+    ::testing::Values(\n+        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_c, 0, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_c, 1, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_c, 2, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_c, 3, VPX_BITS_8)));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n \n-#if HAVE_NEON\n+#if CONFIG_VP9_HIGHBITDEPTH\n+INSTANTIATE_TEST_CASE_P(\n+    C, Trans4x4WHT,\n+    ::testing::Values(\n+        make_tuple(&vp9_highbd_fwht4x4_c, &iwht4x4_10, 0, VPX_BITS_10),\n+        make_tuple(&vp9_highbd_fwht4x4_c, &iwht4x4_12, 0, VPX_BITS_12),\n+        make_tuple(&vp9_fwht4x4_c, &vpx_iwht4x4_16_add_c, 0, VPX_BITS_8)));\n+#else\n+INSTANTIATE_TEST_CASE_P(\n+    C, Trans4x4WHT,\n+    ::testing::Values(\n+        make_tuple(&vp9_fwht4x4_c, &vpx_iwht4x4_16_add_c, 0, VPX_BITS_8)));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+\n+#if HAVE_NEON_ASM && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n INSTANTIATE_TEST_CASE_P(\n     NEON, Trans4x4DCT,\n     ::testing::Values(\n-        make_tuple(&vp9_fdct4x4_c,\n-                   &vp9_idct4x4_16_add_neon, 0)));\n+        make_tuple(&vpx_fdct4x4_c,\n+                   &vpx_idct4x4_16_add_neon, 0, VPX_BITS_8)));\n+#endif  // HAVE_NEON_ASM && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+\n+#if HAVE_NEON && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n INSTANTIATE_TEST_CASE_P(\n-    DISABLED_NEON, Trans4x4HT,\n+    NEON, Trans4x4HT,\n     ::testing::Values(\n-        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_neon, 0),\n-        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_neon, 1),\n-        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_neon, 2),\n-        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_neon, 3)));\n+        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_neon, 0, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_neon, 1, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_neon, 2, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_c, &vp9_iht4x4_16_add_neon, 3, VPX_BITS_8)));\n+#endif  // HAVE_NEON && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+\n+#if CONFIG_USE_X86INC && HAVE_MMX && !CONFIG_VP9_HIGHBITDEPTH && \\\n+    !CONFIG_EMULATE_HARDWARE\n+INSTANTIATE_TEST_CASE_P(\n+    MMX, Trans4x4WHT,\n+    ::testing::Values(\n+        make_tuple(&vp9_fwht4x4_mmx, &vpx_iwht4x4_16_add_c, 0, VPX_BITS_8)));\n #endif\n \n-#if HAVE_SSE2\n+#if CONFIG_USE_X86INC && HAVE_SSE2 && !CONFIG_VP9_HIGHBITDEPTH && \\\n+    !CONFIG_EMULATE_HARDWARE\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, Trans4x4WHT,\n+    ::testing::Values(\n+        make_tuple(&vp9_fwht4x4_c, &vpx_iwht4x4_16_add_sse2, 0, VPX_BITS_8)));\n+#endif\n+\n+#if HAVE_SSE2 && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n INSTANTIATE_TEST_CASE_P(\n     SSE2, Trans4x4DCT,\n     ::testing::Values(\n-        make_tuple(&vp9_fdct4x4_sse2,\n-                   &vp9_idct4x4_16_add_sse2, 0)));\n+        make_tuple(&vpx_fdct4x4_sse2,\n+                   &vpx_idct4x4_16_add_sse2, 0, VPX_BITS_8)));\n INSTANTIATE_TEST_CASE_P(\n     SSE2, Trans4x4HT,\n     ::testing::Values(\n-        make_tuple(&vp9_fht4x4_sse2, &vp9_iht4x4_16_add_sse2, 0),\n-        make_tuple(&vp9_fht4x4_sse2, &vp9_iht4x4_16_add_sse2, 1),\n-        make_tuple(&vp9_fht4x4_sse2, &vp9_iht4x4_16_add_sse2, 2),\n-        make_tuple(&vp9_fht4x4_sse2, &vp9_iht4x4_16_add_sse2, 3)));\n-#endif\n+        make_tuple(&vp9_fht4x4_sse2, &vp9_iht4x4_16_add_sse2, 0, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_sse2, &vp9_iht4x4_16_add_sse2, 1, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_sse2, &vp9_iht4x4_16_add_sse2, 2, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_sse2, &vp9_iht4x4_16_add_sse2, 3, VPX_BITS_8)));\n+#endif  // HAVE_SSE2 && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n \n+#if HAVE_SSE2 && CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, Trans4x4DCT,\n+    ::testing::Values(\n+        make_tuple(&vpx_highbd_fdct4x4_c,    &idct4x4_10_sse2, 0, VPX_BITS_10),\n+        make_tuple(&vpx_highbd_fdct4x4_sse2, &idct4x4_10_sse2, 0, VPX_BITS_10),\n+        make_tuple(&vpx_highbd_fdct4x4_c,    &idct4x4_12_sse2, 0, VPX_BITS_12),\n+        make_tuple(&vpx_highbd_fdct4x4_sse2, &idct4x4_12_sse2, 0, VPX_BITS_12),\n+        make_tuple(&vpx_fdct4x4_sse2,      &vpx_idct4x4_16_add_c, 0,\n+                   VPX_BITS_8)));\n+\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, Trans4x4HT,\n+    ::testing::Values(\n+        make_tuple(&vp9_fht4x4_sse2, &vp9_iht4x4_16_add_c, 0, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_sse2, &vp9_iht4x4_16_add_c, 1, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_sse2, &vp9_iht4x4_16_add_c, 2, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_sse2, &vp9_iht4x4_16_add_c, 3, VPX_BITS_8)));\n+#endif  // HAVE_SSE2 && CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+\n+#if HAVE_MSA && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+INSTANTIATE_TEST_CASE_P(\n+    MSA, Trans4x4DCT,\n+    ::testing::Values(\n+        make_tuple(&vpx_fdct4x4_msa, &vpx_idct4x4_16_add_msa, 0, VPX_BITS_8)));\n+INSTANTIATE_TEST_CASE_P(\n+    MSA, Trans4x4HT,\n+    ::testing::Values(\n+        make_tuple(&vp9_fht4x4_msa, &vp9_iht4x4_16_add_msa, 0, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_msa, &vp9_iht4x4_16_add_msa, 1, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_msa, &vp9_iht4x4_16_add_msa, 2, VPX_BITS_8),\n+        make_tuple(&vp9_fht4x4_msa, &vp9_iht4x4_16_add_msa, 3, VPX_BITS_8)));\n+#endif  // HAVE_MSA && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/fdct8x8_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/fdct8x8_test.cc"", ""patch"": ""@@ -13,52 +13,139 @@\n\n #include <string.h>\n \n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vp9_rtcd.h\""\n+#include \""./vpx_dsp_rtcd.h\""\n #include \""test/acm_random.h\""\n #include \""test/clear_system_state.h\""\n #include \""test/register_state_check.h\""\n #include \""test/util.h\""\n-\n-#include \""./vp9_rtcd.h\""\n #include \""vp9/common/vp9_entropy.h\""\n+#include \""vp9/common/vp9_scan.h\""\n+#include \""vpx/vpx_codec.h\""\n #include \""vpx/vpx_integer.h\""\n-\n-extern \""C\"" {\n-void vp9_idct8x8_64_add_c(const int16_t *input, uint8_t *output, int pitch);\n-}\n+#include \""vpx_ports/mem.h\""\n \n using libvpx_test::ACMRandom;\n \n namespace {\n-typedef void (*fdct_t)(const int16_t *in, int16_t *out, int stride);\n-typedef void (*idct_t)(const int16_t *in, uint8_t *out, int stride);\n-typedef void (*fht_t) (const int16_t *in, int16_t *out, int stride,\n-                       int tx_type);\n-typedef void (*iht_t) (const int16_t *in, uint8_t *out, int stride,\n-                       int tx_type);\n \n-typedef std::tr1::tuple<fdct_t, idct_t, int> dct_8x8_param_t;\n-typedef std::tr1::tuple<fht_t, iht_t, int> ht_8x8_param_t;\n+const int kNumCoeffs = 64;\n+const double kPi = 3.141592653589793238462643383279502884;\n \n-void fdct8x8_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n-  vp9_fdct8x8_c(in, out, stride);\n+const int kSignBiasMaxDiff255 = 1500;\n+const int kSignBiasMaxDiff15 = 10000;\n+\n+typedef void (*FdctFunc)(const int16_t *in, tran_low_t *out, int stride);\n+typedef void (*IdctFunc)(const tran_low_t *in, uint8_t *out, int stride);\n+typedef void (*FhtFunc)(const int16_t *in, tran_low_t *out, int stride,\n+                        int tx_type);\n+typedef void (*IhtFunc)(const tran_low_t *in, uint8_t *out, int stride,\n+                        int tx_type);\n+\n+typedef std::tr1::tuple<FdctFunc, IdctFunc, int, vpx_bit_depth_t> Dct8x8Param;\n+typedef std::tr1::tuple<FhtFunc, IhtFunc, int, vpx_bit_depth_t> Ht8x8Param;\n+typedef std::tr1::tuple<IdctFunc, IdctFunc, int, vpx_bit_depth_t> Idct8x8Param;\n+\n+void reference_8x8_dct_1d(const double in[8], double out[8], int stride) {\n+  const double kInvSqrt2 = 0.707106781186547524400844362104;\n+  for (int k = 0; k < 8; k++) {\n+    out[k] = 0.0;\n+    for (int n = 0; n < 8; n++)\n+      out[k] += in[n] * cos(kPi * (2 * n + 1) * k / 16.0);\n+    if (k == 0)\n+      out[k] = out[k] * kInvSqrt2;\n+  }\n }\n \n-void fht8x8_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n+void reference_8x8_dct_2d(const int16_t input[kNumCoeffs],\n+                          double output[kNumCoeffs]) {\n+  // First transform columns\n+  for (int i = 0; i < 8; ++i) {\n+    double temp_in[8], temp_out[8];\n+    for (int j = 0; j < 8; ++j)\n+      temp_in[j] = input[j*8 + i];\n+    reference_8x8_dct_1d(temp_in, temp_out, 1);\n+    for (int j = 0; j < 8; ++j)\n+      output[j * 8 + i] = temp_out[j];\n+  }\n+  // Then transform rows\n+  for (int i = 0; i < 8; ++i) {\n+    double temp_in[8], temp_out[8];\n+    for (int j = 0; j < 8; ++j)\n+      temp_in[j] = output[j + i*8];\n+    reference_8x8_dct_1d(temp_in, temp_out, 1);\n+    // Scale by some magic number\n+    for (int j = 0; j < 8; ++j)\n+      output[j + i * 8] = temp_out[j] * 2;\n+  }\n+}\n+\n+\n+void fdct8x8_ref(const int16_t *in, tran_low_t *out, int stride, int tx_type) {\n+  vpx_fdct8x8_c(in, out, stride);\n+}\n+\n+void fht8x8_ref(const int16_t *in, tran_low_t *out, int stride, int tx_type) {\n   vp9_fht8x8_c(in, out, stride, tx_type);\n }\n \n+#if CONFIG_VP9_HIGHBITDEPTH\n+void idct8x8_10(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct8x8_64_add_c(in, out, stride, 10);\n+}\n+\n+void idct8x8_12(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct8x8_64_add_c(in, out, stride, 12);\n+}\n+\n+void iht8x8_10(const tran_low_t *in, uint8_t *out, int stride, int tx_type) {\n+  vp9_highbd_iht8x8_64_add_c(in, out, stride, tx_type, 10);\n+}\n+\n+void iht8x8_12(const tran_low_t *in, uint8_t *out, int stride, int tx_type) {\n+  vp9_highbd_iht8x8_64_add_c(in, out, stride, tx_type, 12);\n+}\n+\n+void idct8x8_10_add_10_c(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct8x8_10_add_c(in, out, stride, 10);\n+}\n+\n+void idct8x8_10_add_12_c(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct8x8_10_add_c(in, out, stride, 12);\n+}\n+\n+#if HAVE_SSE2\n+void idct8x8_10_add_10_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct8x8_10_add_sse2(in, out, stride, 10);\n+}\n+\n+void idct8x8_10_add_12_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct8x8_10_add_sse2(in, out, stride, 12);\n+}\n+\n+void idct8x8_64_add_10_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct8x8_64_add_sse2(in, out, stride, 10);\n+}\n+\n+void idct8x8_64_add_12_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n+  vpx_highbd_idct8x8_64_add_sse2(in, out, stride, 12);\n+}\n+#endif  // HAVE_SSE2\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+\n class FwdTrans8x8TestBase {\n  public:\n   virtual ~FwdTrans8x8TestBase() {}\n \n  protected:\n-  virtual void RunFwdTxfm(int16_t *in, int16_t *out, int stride) = 0;\n-  virtual void RunInvTxfm(int16_t *out, uint8_t *dst, int stride) = 0;\n+  virtual void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) = 0;\n+  virtual void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) = 0;\n \n   void RunSignBiasCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, test_output_block, 64);\n+    DECLARE_ALIGNED(16, int16_t, test_input_block[64]);\n+    DECLARE_ALIGNED(16, tran_low_t, test_output_block[64]);\n     int count_sign_block[64][2];\n     const int count_test_block = 100000;\n \n@@ -67,8 +154,9 @@\n\n     for (int i = 0; i < count_test_block; ++i) {\n       // Initialize a test block with input range [-255, 255].\n       for (int j = 0; j < 64; ++j)\n-        test_input_block[j] = rnd.Rand8() - rnd.Rand8();\n-      REGISTER_STATE_CHECK(\n+        test_input_block[j] = ((rnd.Rand16() >> (16 - bit_depth_)) & mask_) -\n+                              ((rnd.Rand16() >> (16 - bit_depth_)) & mask_);\n+      ASM_REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_output_block, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n@@ -81,8 +169,8 @@\n\n \n     for (int j = 0; j < 64; ++j) {\n       const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n-      const int max_diff = 1125;\n-      EXPECT_LT(diff, max_diff)\n+      const int max_diff = kSignBiasMaxDiff255;\n+      EXPECT_LT(diff, max_diff << (bit_depth_ - 8))\n           << \""Error: 8x8 FDCT/FHT has a sign bias > \""\n           << 1. * max_diff / count_test_block * 100 << \""%\""\n           << \"" for input range [-255, 255] at index \"" << j\n@@ -94,10 +182,11 @@\n\n     memset(count_sign_block, 0, sizeof(count_sign_block));\n \n     for (int i = 0; i < count_test_block; ++i) {\n-      // Initialize a test block with input range [-15, 15].\n+      // Initialize a test block with input range [-mask_ / 16, mask_ / 16].\n       for (int j = 0; j < 64; ++j)\n-        test_input_block[j] = (rnd.Rand8() >> 4) - (rnd.Rand8() >> 4);\n-      REGISTER_STATE_CHECK(\n+        test_input_block[j] = ((rnd.Rand16() & mask_) >> 4) -\n+                              ((rnd.Rand16() & mask_) >> 4);\n+      ASM_REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_output_block, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n@@ -110,9 +199,9 @@\n\n \n     for (int j = 0; j < 64; ++j) {\n       const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n-      const int max_diff = 10000;\n-      EXPECT_LT(diff, max_diff)\n-          << \""Error: 4x4 FDCT/FHT has a sign bias > \""\n+      const int max_diff = kSignBiasMaxDiff15;\n+      EXPECT_LT(diff, max_diff << (bit_depth_ - 8))\n+          << \""Error: 8x8 FDCT/FHT has a sign bias > \""\n           << 1. * max_diff / count_test_block * 100 << \""%\""\n           << \"" for input range [-15, 15] at index \"" << j\n           << \"" count0: \"" << count_sign_block[j][0]\n@@ -126,20 +215,32 @@\n\n     int max_error = 0;\n     int total_error = 0;\n     const int count_test_block = 100000;\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, 64);\n-    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, 64);\n-    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, 64);\n+    DECLARE_ALIGNED(16, int16_t, test_input_block[64]);\n+    DECLARE_ALIGNED(16, tran_low_t, test_temp_block[64]);\n+    DECLARE_ALIGNED(16, uint8_t, dst[64]);\n+    DECLARE_ALIGNED(16, uint8_t, src[64]);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    DECLARE_ALIGNED(16, uint16_t, dst16[64]);\n+    DECLARE_ALIGNED(16, uint16_t, src16[64]);\n+#endif\n \n     for (int i = 0; i < count_test_block; ++i) {\n-      // Initialize a test block with input range [-255, 255].\n+      // Initialize a test block with input range [-mask_, mask_].\n       for (int j = 0; j < 64; ++j) {\n-        src[j] = rnd.Rand8();\n-        dst[j] = rnd.Rand8();\n-        test_input_block[j] = src[j] - dst[j];\n+        if (bit_depth_ == VPX_BITS_8) {\n+          src[j] = rnd.Rand8();\n+          dst[j] = rnd.Rand8();\n+          test_input_block[j] = src[j] - dst[j];\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        } else {\n+          src16[j] = rnd.Rand16() & mask_;\n+          dst16[j] = rnd.Rand16() & mask_;\n+          test_input_block[j] = src16[j] - dst16[j];\n+#endif\n+        }\n       }\n \n-      REGISTER_STATE_CHECK(\n+      ASM_REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_temp_block, pitch_));\n       for (int j = 0; j < 64; ++j) {\n           if (test_temp_block[j] > 0) {\n@@ -152,11 +253,23 @@\n\n             test_temp_block[j] *= 4;\n           }\n       }\n-      REGISTER_STATE_CHECK(\n-          RunInvTxfm(test_temp_block, dst, pitch_));\n+      if (bit_depth_ == VPX_BITS_8) {\n+        ASM_REGISTER_STATE_CHECK(\n+            RunInvTxfm(test_temp_block, dst, pitch_));\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        ASM_REGISTER_STATE_CHECK(\n+            RunInvTxfm(test_temp_block, CONVERT_TO_BYTEPTR(dst16), pitch_));\n+#endif\n+      }\n \n       for (int j = 0; j < 64; ++j) {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        const int diff =\n+            bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n+#else\n         const int diff = dst[j] - src[j];\n+#endif\n         const int error = diff * diff;\n         if (max_error < error)\n           max_error = error;\n@@ -164,11 +277,11 @@\n\n       }\n     }\n \n-    EXPECT_GE(1, max_error)\n+    EXPECT_GE(1 << 2 * (bit_depth_ - 8), max_error)\n       << \""Error: 8x8 FDCT/IDCT or FHT/IHT has an individual\""\n       << \"" roundtrip error > 1\"";\n \n-    EXPECT_GE(count_test_block/5, total_error)\n+    EXPECT_GE((count_test_block << 2 * (bit_depth_ - 8))/5, total_error)\n       << \""Error: 8x8 FDCT/IDCT or FHT/IHT has average roundtrip \""\n       << \""error > 1/5 per block\"";\n   }\n@@ -177,51 +290,247 @@\n\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     int max_error = 0;\n     int total_error = 0;\n+    int total_coeff_error = 0;\n     const int count_test_block = 100000;\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);\n-    DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, 64);\n-    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, 64);\n-    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, 64);\n+    DECLARE_ALIGNED(16, int16_t, test_input_block[64]);\n+    DECLARE_ALIGNED(16, tran_low_t, test_temp_block[64]);\n+    DECLARE_ALIGNED(16, tran_low_t, ref_temp_block[64]);\n+    DECLARE_ALIGNED(16, uint8_t, dst[64]);\n+    DECLARE_ALIGNED(16, uint8_t, src[64]);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    DECLARE_ALIGNED(16, uint16_t, dst16[64]);\n+    DECLARE_ALIGNED(16, uint16_t, src16[64]);\n+#endif\n \n     for (int i = 0; i < count_test_block; ++i) {\n-      // Initialize a test block with input range [-255, 255].\n+      // Initialize a test block with input range [-mask_, mask_].\n       for (int j = 0; j < 64; ++j) {\n-        src[j] = rnd.Rand8() % 2 ? 255 : 0;\n-        dst[j] = src[j] > 0 ? 0 : 255;\n-        test_input_block[j] = src[j] - dst[j];\n+        if (bit_depth_ == VPX_BITS_8) {\n+          if (i == 0) {\n+            src[j] = 255;\n+            dst[j] = 0;\n+          } else if (i == 1) {\n+            src[j] = 0;\n+            dst[j] = 255;\n+          } else {\n+            src[j] = rnd.Rand8() % 2 ? 255 : 0;\n+            dst[j] = rnd.Rand8() % 2 ? 255 : 0;\n+          }\n+          test_input_block[j] = src[j] - dst[j];\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        } else {\n+          if (i == 0) {\n+            src16[j] = mask_;\n+            dst16[j] = 0;\n+          } else if (i == 1) {\n+            src16[j] = 0;\n+            dst16[j] = mask_;\n+          } else {\n+            src16[j] = rnd.Rand8() % 2 ? mask_ : 0;\n+            dst16[j] = rnd.Rand8() % 2 ? mask_ : 0;\n+          }\n+          test_input_block[j] = src16[j] - dst16[j];\n+#endif\n+        }\n       }\n \n-      REGISTER_STATE_CHECK(\n+      ASM_REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_temp_block, pitch_));\n-      REGISTER_STATE_CHECK(\n-          RunInvTxfm(test_temp_block, dst, pitch_));\n+      ASM_REGISTER_STATE_CHECK(\n+          fwd_txfm_ref(test_input_block, ref_temp_block, pitch_, tx_type_));\n+      if (bit_depth_ == VPX_BITS_8) {\n+        ASM_REGISTER_STATE_CHECK(\n+            RunInvTxfm(test_temp_block, dst, pitch_));\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        ASM_REGISTER_STATE_CHECK(\n+            RunInvTxfm(test_temp_block, CONVERT_TO_BYTEPTR(dst16), pitch_));\n+#endif\n+      }\n \n       for (int j = 0; j < 64; ++j) {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        const int diff =\n+            bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n+#else\n         const int diff = dst[j] - src[j];\n+#endif\n         const int error = diff * diff;\n         if (max_error < error)\n           max_error = error;\n         total_error += error;\n+\n+        const int coeff_diff = test_temp_block[j] - ref_temp_block[j];\n+        total_coeff_error += abs(coeff_diff);\n       }\n \n-      EXPECT_GE(1, max_error)\n+      EXPECT_GE(1 << 2 * (bit_depth_ - 8), max_error)\n           << \""Error: Extremal 8x8 FDCT/IDCT or FHT/IHT has\""\n           << \""an individual roundtrip error > 1\"";\n \n-      EXPECT_GE(count_test_block/5, total_error)\n+      EXPECT_GE((count_test_block << 2 * (bit_depth_ - 8))/5, total_error)\n           << \""Error: Extremal 8x8 FDCT/IDCT or FHT/IHT has average\""\n           << \"" roundtrip error > 1/5 per block\"";\n+\n+      EXPECT_EQ(0, total_coeff_error)\n+          << \""Error: Extremal 8x8 FDCT/FHT has\""\n+          << \""overflow issues in the intermediate steps > 1\"";\n     }\n   }\n \n+  void RunInvAccuracyCheck() {\n+    ACMRandom rnd(ACMRandom::DeterministicSeed());\n+    const int count_test_block = 1000;\n+    DECLARE_ALIGNED(16, int16_t, in[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    DECLARE_ALIGNED(16, uint16_t, src16[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n+#endif\n+\n+    for (int i = 0; i < count_test_block; ++i) {\n+      double out_r[kNumCoeffs];\n+\n+      // Initialize a test block with input range [-255, 255].\n+      for (int j = 0; j < kNumCoeffs; ++j) {\n+        if (bit_depth_ == VPX_BITS_8) {\n+          src[j] = rnd.Rand8() % 2 ? 255 : 0;\n+          dst[j] = src[j] > 0 ? 0 : 255;\n+          in[j] = src[j] - dst[j];\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        } else {\n+          src16[j] = rnd.Rand8() % 2 ? mask_ : 0;\n+          dst16[j] = src16[j] > 0 ? 0 : mask_;\n+          in[j] = src16[j] - dst16[j];\n+#endif\n+        }\n+      }\n+\n+      reference_8x8_dct_2d(in, out_r);\n+      for (int j = 0; j < kNumCoeffs; ++j)\n+        coeff[j] = static_cast<tran_low_t>(round(out_r[j]));\n+\n+      if (bit_depth_ == VPX_BITS_8) {\n+        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, pitch_));\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, CONVERT_TO_BYTEPTR(dst16),\n+                                            pitch_));\n+#endif\n+      }\n+\n+      for (int j = 0; j < kNumCoeffs; ++j) {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        const uint32_t diff =\n+            bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n+#else\n+        const uint32_t diff = dst[j] - src[j];\n+#endif\n+        const uint32_t error = diff * diff;\n+        EXPECT_GE(1u << 2 * (bit_depth_ - 8), error)\n+            << \""Error: 8x8 IDCT has error \"" << error\n+            << \"" at index \"" << j;\n+      }\n+    }\n+  }\n+\n+  void RunFwdAccuracyCheck() {\n+    ACMRandom rnd(ACMRandom::DeterministicSeed());\n+    const int count_test_block = 1000;\n+    DECLARE_ALIGNED(16, int16_t, in[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, tran_low_t, coeff_r[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n+\n+    for (int i = 0; i < count_test_block; ++i) {\n+      double out_r[kNumCoeffs];\n+\n+      // Initialize a test block with input range [-mask_, mask_].\n+      for (int j = 0; j < kNumCoeffs; ++j)\n+        in[j] = rnd.Rand8() % 2 == 0 ? mask_ : -mask_;\n+\n+      RunFwdTxfm(in, coeff, pitch_);\n+      reference_8x8_dct_2d(in, out_r);\n+      for (int j = 0; j < kNumCoeffs; ++j)\n+        coeff_r[j] = static_cast<tran_low_t>(round(out_r[j]));\n+\n+      for (int j = 0; j < kNumCoeffs; ++j) {\n+        const uint32_t diff = coeff[j] - coeff_r[j];\n+        const uint32_t error = diff * diff;\n+        EXPECT_GE(9u << 2 * (bit_depth_ - 8), error)\n+            << \""Error: 8x8 DCT has error \"" << error\n+            << \"" at index \"" << j;\n+      }\n+    }\n+  }\n+\n+void CompareInvReference(IdctFunc ref_txfm, int thresh) {\n+    ACMRandom rnd(ACMRandom::DeterministicSeed());\n+    const int count_test_block = 10000;\n+    const int eob = 12;\n+    DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint8_t, ref[kNumCoeffs]);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n+    DECLARE_ALIGNED(16, uint16_t, ref16[kNumCoeffs]);\n+#endif\n+    const int16_t *scan = vp9_default_scan_orders[TX_8X8].scan;\n+\n+    for (int i = 0; i < count_test_block; ++i) {\n+      for (int j = 0; j < kNumCoeffs; ++j) {\n+        if (j < eob) {\n+          // Random values less than the threshold, either positive or negative\n+          coeff[scan[j]] = rnd(thresh) * (1-2*(i%2));\n+        } else {\n+          coeff[scan[j]] = 0;\n+        }\n+        if (bit_depth_ == VPX_BITS_8) {\n+          dst[j] = 0;\n+          ref[j] = 0;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        } else {\n+          dst16[j] = 0;\n+          ref16[j] = 0;\n+#endif\n+        }\n+      }\n+      if (bit_depth_ == VPX_BITS_8) {\n+        ref_txfm(coeff, ref, pitch_);\n+        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, pitch_));\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        ref_txfm(coeff, CONVERT_TO_BYTEPTR(ref16), pitch_);\n+        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, CONVERT_TO_BYTEPTR(dst16),\n+                                            pitch_));\n+#endif\n+      }\n+\n+      for (int j = 0; j < kNumCoeffs; ++j) {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        const uint32_t diff =\n+            bit_depth_ == VPX_BITS_8 ? dst[j] - ref[j] : dst16[j] - ref16[j];\n+#else\n+        const uint32_t diff = dst[j] - ref[j];\n+#endif\n+        const uint32_t error = diff * diff;\n+        EXPECT_EQ(0u, error)\n+            << \""Error: 8x8 IDCT has error \"" << error\n+            << \"" at index \"" << j;\n+      }\n+    }\n+  }\n   int pitch_;\n   int tx_type_;\n-  fht_t fwd_txfm_ref;\n+  FhtFunc fwd_txfm_ref;\n+  vpx_bit_depth_t bit_depth_;\n+  int mask_;\n };\n \n class FwdTrans8x8DCT\n     : public FwdTrans8x8TestBase,\n-      public ::testing::TestWithParam<dct_8x8_param_t> {\n+      public ::testing::TestWithParam<Dct8x8Param> {\n  public:\n   virtual ~FwdTrans8x8DCT() {}\n \n@@ -231,20 +540,22 @@\n\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 8;\n     fwd_txfm_ref = fdct8x8_ref;\n+    bit_depth_ = GET_PARAM(3);\n+    mask_ = (1 << bit_depth_) - 1;\n   }\n \n   virtual void TearDown() { libvpx_test::ClearSystemState(); }\n \n  protected:\n-  void RunFwdTxfm(int16_t *in, int16_t *out, int stride) {\n+  void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) {\n     fwd_txfm_(in, out, stride);\n   }\n-  void RunInvTxfm(int16_t *out, uint8_t *dst, int stride) {\n+  void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n     inv_txfm_(out, dst, stride);\n   }\n \n-  fdct_t fwd_txfm_;\n-  idct_t inv_txfm_;\n+  FdctFunc fwd_txfm_;\n+  IdctFunc inv_txfm_;\n };\n \n TEST_P(FwdTrans8x8DCT, SignBiasCheck) {\n@@ -259,9 +570,17 @@\n\n   RunExtremalCheck();\n }\n \n+TEST_P(FwdTrans8x8DCT, FwdAccuracyCheck) {\n+  RunFwdAccuracyCheck();\n+}\n+\n+TEST_P(FwdTrans8x8DCT, InvAccuracyCheck) {\n+  RunInvAccuracyCheck();\n+}\n+\n class FwdTrans8x8HT\n     : public FwdTrans8x8TestBase,\n-      public ::testing::TestWithParam<ht_8x8_param_t> {\n+      public ::testing::TestWithParam<Ht8x8Param> {\n  public:\n   virtual ~FwdTrans8x8HT() {}\n \n@@ -271,20 +590,22 @@\n\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 8;\n     fwd_txfm_ref = fht8x8_ref;\n+    bit_depth_ = GET_PARAM(3);\n+    mask_ = (1 << bit_depth_) - 1;\n   }\n \n   virtual void TearDown() { libvpx_test::ClearSystemState(); }\n \n  protected:\n-  void RunFwdTxfm(int16_t *in, int16_t *out, int stride) {\n+  void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) {\n     fwd_txfm_(in, out, stride, tx_type_);\n   }\n-  void RunInvTxfm(int16_t *out, uint8_t *dst, int stride) {\n+  void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n     inv_txfm_(out, dst, stride, tx_type_);\n   }\n \n-  fht_t fwd_txfm_;\n-  iht_t inv_txfm_;\n+  FhtFunc fwd_txfm_;\n+  IhtFunc inv_txfm_;\n };\n \n TEST_P(FwdTrans8x8HT, SignBiasCheck) {\n@@ -299,45 +620,170 @@\n\n   RunExtremalCheck();\n }\n \n+class InvTrans8x8DCT\n+    : public FwdTrans8x8TestBase,\n+      public ::testing::TestWithParam<Idct8x8Param> {\n+ public:\n+  virtual ~InvTrans8x8DCT() {}\n+\n+  virtual void SetUp() {\n+    ref_txfm_ = GET_PARAM(0);\n+    inv_txfm_ = GET_PARAM(1);\n+    thresh_ = GET_PARAM(2);\n+    pitch_ = 8;\n+    bit_depth_ = GET_PARAM(3);\n+    mask_ = (1 << bit_depth_) - 1;\n+  }\n+\n+  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n+\n+ protected:\n+  void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n+    inv_txfm_(out, dst, stride);\n+  }\n+  void RunFwdTxfm(int16_t *out, tran_low_t *dst, int stride) {}\n+\n+  IdctFunc ref_txfm_;\n+  IdctFunc inv_txfm_;\n+  int thresh_;\n+};\n+\n+TEST_P(InvTrans8x8DCT, CompareReference) {\n+  CompareInvReference(ref_txfm_, thresh_);\n+}\n+\n using std::tr1::make_tuple;\n \n+#if CONFIG_VP9_HIGHBITDEPTH\n INSTANTIATE_TEST_CASE_P(\n     C, FwdTrans8x8DCT,\n     ::testing::Values(\n-        make_tuple(&vp9_fdct8x8_c, &vp9_idct8x8_64_add_c, 0)));\n+        make_tuple(&vpx_fdct8x8_c, &vpx_idct8x8_64_add_c, 0, VPX_BITS_8),\n+        make_tuple(&vpx_highbd_fdct8x8_c, &idct8x8_10, 0, VPX_BITS_10),\n+        make_tuple(&vpx_highbd_fdct8x8_c, &idct8x8_12, 0, VPX_BITS_12)));\n+#else\n+INSTANTIATE_TEST_CASE_P(\n+    C, FwdTrans8x8DCT,\n+    ::testing::Values(\n+        make_tuple(&vpx_fdct8x8_c, &vpx_idct8x8_64_add_c, 0, VPX_BITS_8)));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+\n+#if CONFIG_VP9_HIGHBITDEPTH\n INSTANTIATE_TEST_CASE_P(\n     C, FwdTrans8x8HT,\n     ::testing::Values(\n-        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_c, 0),\n-        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_c, 1),\n-        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_c, 2),\n-        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_c, 3)));\n+        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_c, 0, VPX_BITS_8),\n+        make_tuple(&vp9_highbd_fht8x8_c, &iht8x8_10, 0, VPX_BITS_10),\n+        make_tuple(&vp9_highbd_fht8x8_c, &iht8x8_10, 1, VPX_BITS_10),\n+        make_tuple(&vp9_highbd_fht8x8_c, &iht8x8_10, 2, VPX_BITS_10),\n+        make_tuple(&vp9_highbd_fht8x8_c, &iht8x8_10, 3, VPX_BITS_10),\n+        make_tuple(&vp9_highbd_fht8x8_c, &iht8x8_12, 0, VPX_BITS_12),\n+        make_tuple(&vp9_highbd_fht8x8_c, &iht8x8_12, 1, VPX_BITS_12),\n+        make_tuple(&vp9_highbd_fht8x8_c, &iht8x8_12, 2, VPX_BITS_12),\n+        make_tuple(&vp9_highbd_fht8x8_c, &iht8x8_12, 3, VPX_BITS_12),\n+        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_c, 1, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_c, 2, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_c, 3, VPX_BITS_8)));\n+#else\n+INSTANTIATE_TEST_CASE_P(\n+    C, FwdTrans8x8HT,\n+    ::testing::Values(\n+        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_c, 0, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_c, 1, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_c, 2, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_c, 3, VPX_BITS_8)));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n \n-#if HAVE_NEON\n+#if HAVE_NEON_ASM && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n INSTANTIATE_TEST_CASE_P(\n     NEON, FwdTrans8x8DCT,\n     ::testing::Values(\n-        make_tuple(&vp9_fdct8x8_c, &vp9_idct8x8_64_add_neon, 0)));\n-INSTANTIATE_TEST_CASE_P(\n-    DISABLED_NEON, FwdTrans8x8HT,\n-    ::testing::Values(\n-        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_neon, 0),\n-        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_neon, 1),\n-        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_neon, 2),\n-        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_neon, 3)));\n-#endif\n+        make_tuple(&vpx_fdct8x8_neon, &vpx_idct8x8_64_add_neon, 0,\n+                   VPX_BITS_8)));\n+#endif  // HAVE_NEON_ASM && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n \n-#if HAVE_SSE2\n+#if HAVE_NEON && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+INSTANTIATE_TEST_CASE_P(\n+    NEON, FwdTrans8x8HT,\n+    ::testing::Values(\n+        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_neon, 0, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_neon, 1, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_neon, 2, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_c, &vp9_iht8x8_64_add_neon, 3, VPX_BITS_8)));\n+#endif  // HAVE_NEON && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+\n+#if HAVE_SSE2 && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n INSTANTIATE_TEST_CASE_P(\n     SSE2, FwdTrans8x8DCT,\n     ::testing::Values(\n-        make_tuple(&vp9_fdct8x8_sse2, &vp9_idct8x8_64_add_sse2, 0)));\n+        make_tuple(&vpx_fdct8x8_sse2, &vpx_idct8x8_64_add_sse2, 0,\n+                   VPX_BITS_8)));\n INSTANTIATE_TEST_CASE_P(\n     SSE2, FwdTrans8x8HT,\n     ::testing::Values(\n-        make_tuple(&vp9_fht8x8_sse2, &vp9_iht8x8_64_add_sse2, 0),\n-        make_tuple(&vp9_fht8x8_sse2, &vp9_iht8x8_64_add_sse2, 1),\n-        make_tuple(&vp9_fht8x8_sse2, &vp9_iht8x8_64_add_sse2, 2),\n-        make_tuple(&vp9_fht8x8_sse2, &vp9_iht8x8_64_add_sse2, 3)));\n+        make_tuple(&vp9_fht8x8_sse2, &vp9_iht8x8_64_add_sse2, 0, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_sse2, &vp9_iht8x8_64_add_sse2, 1, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_sse2, &vp9_iht8x8_64_add_sse2, 2, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_sse2, &vp9_iht8x8_64_add_sse2, 3, VPX_BITS_8)));\n+#endif  // HAVE_SSE2 && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+\n+#if HAVE_SSE2 && CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, FwdTrans8x8DCT,\n+    ::testing::Values(\n+        make_tuple(&vpx_fdct8x8_sse2, &vpx_idct8x8_64_add_c, 0, VPX_BITS_8),\n+        make_tuple(&vpx_highbd_fdct8x8_c,\n+                   &idct8x8_64_add_10_sse2, 12, VPX_BITS_10),\n+        make_tuple(&vpx_highbd_fdct8x8_sse2,\n+                   &idct8x8_64_add_10_sse2, 12, VPX_BITS_10),\n+        make_tuple(&vpx_highbd_fdct8x8_c,\n+                   &idct8x8_64_add_12_sse2, 12, VPX_BITS_12),\n+        make_tuple(&vpx_highbd_fdct8x8_sse2,\n+                   &idct8x8_64_add_12_sse2, 12, VPX_BITS_12)));\n+\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, FwdTrans8x8HT,\n+    ::testing::Values(\n+        make_tuple(&vp9_fht8x8_sse2, &vp9_iht8x8_64_add_c, 0, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_sse2, &vp9_iht8x8_64_add_c, 1, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_sse2, &vp9_iht8x8_64_add_c, 2, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_sse2, &vp9_iht8x8_64_add_c, 3, VPX_BITS_8)));\n+\n+// Optimizations take effect at a threshold of 6201, so we use a value close to\n+// that to test both branches.\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, InvTrans8x8DCT,\n+    ::testing::Values(\n+        make_tuple(&idct8x8_10_add_10_c,\n+                   &idct8x8_10_add_10_sse2, 6225, VPX_BITS_10),\n+        make_tuple(&idct8x8_10,\n+                   &idct8x8_64_add_10_sse2, 6225, VPX_BITS_10),\n+        make_tuple(&idct8x8_10_add_12_c,\n+                   &idct8x8_10_add_12_sse2, 6225, VPX_BITS_12),\n+        make_tuple(&idct8x8_12,\n+                   &idct8x8_64_add_12_sse2, 6225, VPX_BITS_12)));\n+#endif  // HAVE_SSE2 && CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+\n+#if HAVE_SSSE3 && CONFIG_USE_X86INC && ARCH_X86_64 && \\\n+    !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+INSTANTIATE_TEST_CASE_P(\n+    SSSE3, FwdTrans8x8DCT,\n+    ::testing::Values(\n+        make_tuple(&vpx_fdct8x8_ssse3, &vpx_idct8x8_64_add_ssse3, 0,\n+                   VPX_BITS_8)));\n #endif\n+\n+#if HAVE_MSA && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+INSTANTIATE_TEST_CASE_P(\n+    MSA, FwdTrans8x8DCT,\n+    ::testing::Values(\n+        make_tuple(&vpx_fdct8x8_msa, &vpx_idct8x8_64_add_msa, 0, VPX_BITS_8)));\n+INSTANTIATE_TEST_CASE_P(\n+    MSA, FwdTrans8x8HT,\n+    ::testing::Values(\n+        make_tuple(&vp9_fht8x8_msa, &vp9_iht8x8_64_add_msa, 0, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_msa, &vp9_iht8x8_64_add_msa, 1, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_msa, &vp9_iht8x8_64_add_msa, 2, VPX_BITS_8),\n+        make_tuple(&vp9_fht8x8_msa, &vp9_iht8x8_64_add_msa, 3, VPX_BITS_8)));\n+#endif  // HAVE_MSA && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/frame_size_tests.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/frame_size_tests.cc"", ""patch"": ""@@ -0,0 +1,96 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+#include \""test/codec_factory.h\""\n+#include \""test/video_source.h\""\n+\n+namespace {\n+\n+class VP9FrameSizeTestsLarge\n+    : public ::libvpx_test::EncoderTest,\n+      public ::testing::Test {\n+ protected:\n+  VP9FrameSizeTestsLarge() : EncoderTest(&::libvpx_test::kVP9),\n+                             expected_res_(VPX_CODEC_OK) {}\n+  virtual ~VP9FrameSizeTestsLarge() {}\n+\n+  virtual void SetUp() {\n+    InitializeConfig();\n+    SetMode(::libvpx_test::kRealTime);\n+  }\n+\n+  virtual bool HandleDecodeResult(const vpx_codec_err_t res_dec,\n+                                  const libvpx_test::VideoSource& /*video*/,\n+                                  libvpx_test::Decoder *decoder) {\n+    EXPECT_EQ(expected_res_, res_dec) << decoder->DecodeError();\n+    return !::testing::Test::HasFailure();\n+  }\n+\n+  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n+                                  ::libvpx_test::Encoder *encoder) {\n+    if (video->frame() == 1) {\n+      encoder->Control(VP8E_SET_CPUUSED, 7);\n+      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n+      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n+      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n+      encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n+    }\n+  }\n+\n+  int expected_res_;\n+};\n+\n+TEST_F(VP9FrameSizeTestsLarge, TestInvalidSizes) {\n+  ::libvpx_test::RandomVideoSource video;\n+\n+#if CONFIG_SIZE_LIMIT\n+  video.SetSize(DECODE_WIDTH_LIMIT + 16, DECODE_HEIGHT_LIMIT + 16);\n+  video.set_limit(2);\n+  expected_res_ = VPX_CODEC_CORRUPT_FRAME;\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+#endif\n+}\n+\n+TEST_F(VP9FrameSizeTestsLarge, ValidSizes) {\n+  ::libvpx_test::RandomVideoSource video;\n+\n+#if CONFIG_SIZE_LIMIT\n+  video.SetSize(DECODE_WIDTH_LIMIT, DECODE_HEIGHT_LIMIT);\n+  video.set_limit(2);\n+  expected_res_ = VPX_CODEC_OK;\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+#else\n+  // This test produces a pretty large single frame allocation,  (roughly\n+  // 25 megabits). The encoder allocates a good number of these frames\n+  // one for each lag in frames (for 2 pass), and then one for each possible\n+  // reference buffer (8) - we can end up with up to 30 buffers of roughly this\n+  // size or almost 1 gig of memory.\n+  // In total the allocations will exceed 2GiB which may cause a failure with\n+  // mingw + wine, use a smaller size in that case.\n+#if defined(_WIN32) && !defined(_WIN64)\n+  video.SetSize(4096, 3072);\n+#else\n+  video.SetSize(4096, 4096);\n+#endif\n+  video.set_limit(2);\n+  expected_res_ = VPX_CODEC_OK;\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+#endif\n+}\n+\n+TEST_F(VP9FrameSizeTestsLarge, OneByOneVideo) {\n+  ::libvpx_test::RandomVideoSource video;\n+\n+  video.SetSize(1, 1);\n+  video.set_limit(2);\n+  expected_res_ = VPX_CODEC_OK;\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+}\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/i420_video_source.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/i420_video_source.h"", ""patch"": ""@@ -13,104 +13,22 @@\n\n #include <cstdlib>\n #include <string>\n \n-#include \""test/video_source.h\""\n+#include \""test/yuv_video_source.h\""\n \n namespace libvpx_test {\n \n // This class extends VideoSource to allow parsing of raw yv12\n // so that we can do actual file encodes.\n-class I420VideoSource : public VideoSource {\n+class I420VideoSource : public YUVVideoSource {\n  public:\n   I420VideoSource(const std::string &file_name,\n                   unsigned int width, unsigned int height,\n                   int rate_numerator, int rate_denominator,\n                   unsigned int start, int limit)\n-      : file_name_(file_name),\n-        input_file_(NULL),\n-        img_(NULL),\n-        start_(start),\n-        limit_(limit),\n-        frame_(0),\n-        width_(0),\n-        height_(0),\n-        framerate_numerator_(rate_numerator),\n-        framerate_denominator_(rate_denominator) {\n-    // This initializes raw_sz_, width_, height_ and allocates an img.\n-    SetSize(width, height);\n-  }\n-\n-  virtual ~I420VideoSource() {\n-    vpx_img_free(img_);\n-    if (input_file_)\n-      fclose(input_file_);\n-  }\n-\n-  virtual void Begin() {\n-    if (input_file_)\n-      fclose(input_file_);\n-    input_file_ = OpenTestDataFile(file_name_);\n-    ASSERT_TRUE(input_file_ != NULL) << \""Input file open failed. Filename: \""\n-        << file_name_;\n-    if (start_) {\n-      fseek(input_file_, static_cast<unsigned>(raw_sz_) * start_, SEEK_SET);\n-    }\n-\n-    frame_ = start_;\n-    FillFrame();\n-  }\n-\n-  virtual void Next() {\n-    ++frame_;\n-    FillFrame();\n-  }\n-\n-  virtual vpx_image_t *img() const { return (frame_ < limit_) ? img_ : NULL;  }\n-\n-  // Models a stream where Timebase = 1/FPS, so pts == frame.\n-  virtual vpx_codec_pts_t pts() const { return frame_; }\n-\n-  virtual unsigned long duration() const { return 1; }\n-\n-  virtual vpx_rational_t timebase() const {\n-    const vpx_rational_t t = { framerate_denominator_, framerate_numerator_ };\n-    return t;\n-  }\n-\n-  virtual unsigned int frame() const { return frame_; }\n-\n-  virtual unsigned int limit() const { return limit_; }\n-\n-  void SetSize(unsigned int width, unsigned int height) {\n-    if (width != width_ || height != height_) {\n-      vpx_img_free(img_);\n-      img_ = vpx_img_alloc(NULL, VPX_IMG_FMT_I420, width, height, 1);\n-      ASSERT_TRUE(img_ != NULL);\n-      width_ = width;\n-      height_ = height;\n-      raw_sz_ = width * height * 3 / 2;\n-    }\n-  }\n-\n-  virtual void FillFrame() {\n-    ASSERT_TRUE(input_file_ != NULL);\n-    // Read a frame from input_file.\n-    if (fread(img_->img_data, raw_sz_, 1, input_file_) == 0) {\n-      limit_ = frame_;\n-    }\n-  }\n-\n- protected:\n-  std::string file_name_;\n-  FILE *input_file_;\n-  vpx_image_t *img_;\n-  size_t raw_sz_;\n-  unsigned int start_;\n-  unsigned int limit_;\n-  unsigned int frame_;\n-  unsigned int width_;\n-  unsigned int height_;\n-  int framerate_numerator_;\n-  int framerate_denominator_;\n+      : YUVVideoSource(file_name, VPX_IMG_FMT_I420,\n+                       width, height,\n+                       rate_numerator, rate_denominator,\n+                       start, limit) {}\n };\n \n }  // namespace libvpx_test\n""}<_**next**_>{""filename"": ""libvpx/test/idct8x8_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/idct8x8_test.cc"", ""patch"": ""@@ -14,8 +14,7 @@\n\n \n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n \n-#include \""./vp9_rtcd.h\""\n-\n+#include \""./vpx_dsp_rtcd.h\""\n #include \""test/acm_random.h\""\n #include \""vpx/vpx_integer.h\""\n \n@@ -109,7 +108,8 @@\n\n   ACMRandom rnd(ACMRandom::DeterministicSeed());\n   const int count_test_block = 10000;\n   for (int i = 0; i < count_test_block; ++i) {\n-    int16_t input[64], coeff[64];\n+    int16_t input[64];\n+    tran_low_t coeff[64];\n     double output_r[64];\n     uint8_t dst[64], src[64];\n \n@@ -124,7 +124,7 @@\n\n     reference_dct_2d(input, output_r);\n     for (int j = 0; j < 64; ++j)\n       coeff[j] = round(output_r[j]);\n-    vp9_idct8x8_64_add_c(coeff, dst, 8);\n+    vpx_idct8x8_64_add_c(coeff, dst, 8);\n     for (int j = 0; j < 64; ++j) {\n       const int diff = dst[j] - src[j];\n       const int error = diff * diff;\n""}<_**next**_>{""filename"": ""libvpx/test/idct_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/idct_test.cc"", ""patch"": ""@@ -10,17 +10,18 @@\n\n \n #include \""./vpx_config.h\""\n #include \""./vp8_rtcd.h\""\n-#include \""test/clear_system_state.h\""\n-#include \""test/register_state_check.h\""\n+\n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n \n+#include \""test/clear_system_state.h\""\n+#include \""test/register_state_check.h\""\n #include \""vpx/vpx_integer.h\""\n \n-typedef void (*idct_fn_t)(int16_t *input, unsigned char *pred_ptr,\n-                          int pred_stride, unsigned char *dst_ptr,\n-                          int dst_stride);\n+typedef void (*IdctFunc)(int16_t *input, unsigned char *pred_ptr,\n+                         int pred_stride, unsigned char *dst_ptr,\n+                         int dst_stride);\n namespace {\n-class IDCTTest : public ::testing::TestWithParam<idct_fn_t> {\n+class IDCTTest : public ::testing::TestWithParam<IdctFunc> {\n  protected:\n   virtual void SetUp() {\n     int i;\n@@ -33,7 +34,7 @@\n\n \n   virtual void TearDown() { libvpx_test::ClearSystemState(); }\n \n-  idct_fn_t UUT;\n+  IdctFunc UUT;\n   int16_t input[16];\n   unsigned char output[256];\n   unsigned char predict[256];\n@@ -52,7 +53,7 @@\n\n TEST_P(IDCTTest, TestAllZeros) {\n   int i;\n \n-  REGISTER_STATE_CHECK(UUT(input, output, 16, output, 16));\n+  ASM_REGISTER_STATE_CHECK(UUT(input, output, 16, output, 16));\n \n   for (i = 0; i < 256; i++)\n     if ((i & 0xF) < 4 && i < 64)\n@@ -65,7 +66,7 @@\n\n   int i;\n \n   input[0] = 4;\n-  REGISTER_STATE_CHECK(UUT(input, output, 16, output, 16));\n+  ASM_REGISTER_STATE_CHECK(UUT(input, output, 16, output, 16));\n \n   for (i = 0; i < 256; i++)\n     if ((i & 0xF) < 4 && i < 64)\n@@ -79,7 +80,7 @@\n\n \n   for (i = 0; i < 256; i++) predict[i] = i;\n   input[0] = 4;\n-  REGISTER_STATE_CHECK(UUT(input, predict, 16, output, 16));\n+  ASM_REGISTER_STATE_CHECK(UUT(input, predict, 16, output, 16));\n \n   for (i = 0; i < 256; i++)\n     if ((i & 0xF) < 4 && i < 64)\n@@ -93,7 +94,7 @@\n\n \n   for (i = 0; i < 16; i++) input[i] = i;\n \n-  REGISTER_STATE_CHECK(UUT(input, output, 16, output, 16));\n+  ASM_REGISTER_STATE_CHECK(UUT(input, output, 16, output, 16));\n \n   for (i = 0; i < 256; i++)\n     if ((i & 0xF) > 3 || i > 63)\n@@ -113,4 +114,8 @@\n\n INSTANTIATE_TEST_CASE_P(MMX, IDCTTest,\n                         ::testing::Values(vp8_short_idct4x4llm_mmx));\n #endif\n+#if HAVE_MSA\n+INSTANTIATE_TEST_CASE_P(MSA, IDCTTest,\n+                        ::testing::Values(vp8_short_idct4x4llm_msa));\n+#endif\n }\n""}<_**next**_>{""filename"": ""libvpx/test/intrapred_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/intrapred_test.cc"", ""patch"": ""@@ -8,15 +8,15 @@\n\n  *  be found in the AUTHORS file in the root of the source tree.\n  */\n \n-\n #include <string.h>\n-#include \""test/acm_random.h\""\n-#include \""test/clear_system_state.h\""\n-#include \""test/register_state_check.h\""\n+\n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n \n #include \""./vpx_config.h\""\n #include \""./vp8_rtcd.h\""\n+#include \""test/acm_random.h\""\n+#include \""test/clear_system_state.h\""\n+#include \""test/register_state_check.h\""\n #include \""vp8/common/blockd.h\""\n #include \""vpx_mem/vpx_mem.h\""\n \n@@ -216,16 +216,16 @@\n\n   int num_planes_;\n };\n \n-typedef void (*intra_pred_y_fn_t)(MACROBLOCKD *x,\n-                                  uint8_t *yabove_row,\n-                                  uint8_t *yleft,\n-                                  int left_stride,\n-                                  uint8_t *ypred_ptr,\n-                                  int y_stride);\n+typedef void (*IntraPredYFunc)(MACROBLOCKD *x,\n+                               uint8_t *yabove_row,\n+                               uint8_t *yleft,\n+                               int left_stride,\n+                               uint8_t *ypred_ptr,\n+                               int y_stride);\n \n class IntraPredYTest\n     : public IntraPredBase,\n-      public ::testing::TestWithParam<intra_pred_y_fn_t> {\n+      public ::testing::TestWithParam<IntraPredYFunc> {\n  public:\n   static void SetUpTestCase() {\n     mb_ = reinterpret_cast<MACROBLOCKD*>(\n@@ -261,13 +261,13 @@\n\n \n   virtual void Predict(MB_PREDICTION_MODE mode) {\n     mbptr_->mode_info_context->mbmi.mode = mode;\n-    REGISTER_STATE_CHECK(pred_fn_(mbptr_,\n-                                  data_ptr_[0] - kStride,\n-                                  data_ptr_[0] - 1, kStride,\n-                                  data_ptr_[0], kStride));\n+    ASM_REGISTER_STATE_CHECK(pred_fn_(mbptr_,\n+                                      data_ptr_[0] - kStride,\n+                                      data_ptr_[0] - 1, kStride,\n+                                      data_ptr_[0], kStride));\n   }\n \n-  intra_pred_y_fn_t pred_fn_;\n+  IntraPredYFunc pred_fn_;\n   static uint8_t* data_array_;\n   static MACROBLOCKD * mb_;\n   static MODE_INFO *mi_;\n@@ -294,20 +294,30 @@\n\n                         ::testing::Values(\n                             vp8_build_intra_predictors_mby_s_ssse3));\n #endif\n+#if HAVE_NEON\n+INSTANTIATE_TEST_CASE_P(NEON, IntraPredYTest,\n+                        ::testing::Values(\n+                            vp8_build_intra_predictors_mby_s_neon));\n+#endif\n+#if HAVE_MSA\n+INSTANTIATE_TEST_CASE_P(MSA, IntraPredYTest,\n+                        ::testing::Values(\n+                            vp8_build_intra_predictors_mby_s_msa));\n+#endif\n \n-typedef void (*intra_pred_uv_fn_t)(MACROBLOCKD *x,\n-                                   uint8_t *uabove_row,\n-                                   uint8_t *vabove_row,\n-                                   uint8_t *uleft,\n-                                   uint8_t *vleft,\n-                                   int left_stride,\n-                                   uint8_t *upred_ptr,\n-                                   uint8_t *vpred_ptr,\n-                                   int pred_stride);\n+typedef void (*IntraPredUvFunc)(MACROBLOCKD *x,\n+                                uint8_t *uabove_row,\n+                                uint8_t *vabove_row,\n+                                uint8_t *uleft,\n+                                uint8_t *vleft,\n+                                int left_stride,\n+                                uint8_t *upred_ptr,\n+                                uint8_t *vpred_ptr,\n+                                int pred_stride);\n \n class IntraPredUVTest\n     : public IntraPredBase,\n-      public ::testing::TestWithParam<intra_pred_uv_fn_t> {\n+      public ::testing::TestWithParam<IntraPredUvFunc> {\n  public:\n   static void SetUpTestCase() {\n     mb_ = reinterpret_cast<MACROBLOCKD*>(\n@@ -349,7 +359,7 @@\n\n              data_ptr_[0], data_ptr_[1], kStride);\n   }\n \n-  intra_pred_uv_fn_t pred_fn_;\n+  IntraPredUvFunc pred_fn_;\n   // We use 24 so that the data pointer of the first pixel in each row of\n   // each macroblock is 8-byte aligned, and this gives us access to the\n   // top-left and top-right corner pixels belonging to the top-left/right\n@@ -382,5 +392,15 @@\n\n                         ::testing::Values(\n                             vp8_build_intra_predictors_mbuv_s_ssse3));\n #endif\n+#if HAVE_NEON\n+INSTANTIATE_TEST_CASE_P(NEON, IntraPredUVTest,\n+                        ::testing::Values(\n+                            vp8_build_intra_predictors_mbuv_s_neon));\n+#endif\n+#if HAVE_MSA\n+INSTANTIATE_TEST_CASE_P(MSA, IntraPredUVTest,\n+                        ::testing::Values(\n+                            vp8_build_intra_predictors_mbuv_s_msa));\n+#endif\n \n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/invalid_file_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/invalid_file_test.cc"", ""patch"": ""@@ -0,0 +1,169 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+#include \""./vpx_config.h\""\n+#include \""test/codec_factory.h\""\n+#include \""test/decode_test_driver.h\""\n+#include \""test/ivf_video_source.h\""\n+#include \""test/util.h\""\n+#if CONFIG_WEBM_IO\n+#include \""test/webm_video_source.h\""\n+#endif\n+#include \""vpx_mem/vpx_mem.h\""\n+\n+namespace {\n+\n+struct DecodeParam {\n+  int threads;\n+  const char *filename;\n+};\n+\n+std::ostream &operator<<(std::ostream &os, const DecodeParam &dp) {\n+  return os << \""threads: \"" << dp.threads << \"" file: \"" << dp.filename;\n+}\n+\n+class InvalidFileTest\n+    : public ::libvpx_test::DecoderTest,\n+      public ::libvpx_test::CodecTestWithParam<DecodeParam> {\n+ protected:\n+  InvalidFileTest() : DecoderTest(GET_PARAM(0)), res_file_(NULL) {}\n+\n+  virtual ~InvalidFileTest() {\n+    if (res_file_ != NULL)\n+      fclose(res_file_);\n+  }\n+\n+  void OpenResFile(const std::string &res_file_name_) {\n+    res_file_ = libvpx_test::OpenTestDataFile(res_file_name_);\n+    ASSERT_TRUE(res_file_ != NULL) << \""Result file open failed. Filename: \""\n+        << res_file_name_;\n+  }\n+\n+  virtual bool HandleDecodeResult(\n+      const vpx_codec_err_t res_dec,\n+      const libvpx_test::CompressedVideoSource &video,\n+      libvpx_test::Decoder *decoder) {\n+    EXPECT_TRUE(res_file_ != NULL);\n+    int expected_res_dec;\n+\n+    // Read integer result.\n+    const int res = fscanf(res_file_, \""%d\"", &expected_res_dec);\n+    EXPECT_NE(res, EOF) << \""Read result data failed\"";\n+\n+    // Check results match.\n+    EXPECT_EQ(expected_res_dec, res_dec)\n+        << \""Results don't match: frame number = \"" << video.frame_number()\n+        << \"". (\"" << decoder->DecodeError() << \"")\"";\n+\n+    return !HasFailure();\n+  }\n+\n+  void RunTest() {\n+    const DecodeParam input = GET_PARAM(1);\n+    libvpx_test::CompressedVideoSource *video = NULL;\n+    vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n+    cfg.threads = input.threads;\n+    const std::string filename = input.filename;\n+\n+    // Open compressed video file.\n+    if (filename.substr(filename.length() - 3, 3) == \""ivf\"") {\n+      video = new libvpx_test::IVFVideoSource(filename);\n+    } else if (filename.substr(filename.length() - 4, 4) == \""webm\"") {\n+#if CONFIG_WEBM_IO\n+      video = new libvpx_test::WebMVideoSource(filename);\n+#else\n+      fprintf(stderr, \""WebM IO is disabled, skipping test vector %s\\n\"",\n+              filename.c_str());\n+      return;\n+#endif\n+    }\n+    video->Init();\n+\n+    // Construct result file name. The file holds a list of expected integer\n+    // results, one for each decoded frame.  Any result that doesn't match\n+    // the files list will cause a test failure.\n+    const std::string res_filename = filename + \"".res\"";\n+    OpenResFile(res_filename);\n+\n+    // Decode frame, and check the md5 matching.\n+    ASSERT_NO_FATAL_FAILURE(RunLoop(video, cfg));\n+    delete video;\n+  }\n+\n+ private:\n+  FILE *res_file_;\n+};\n+\n+TEST_P(InvalidFileTest, ReturnCode) {\n+  RunTest();\n+}\n+\n+const DecodeParam kVP9InvalidFileTests[] = {\n+  {1, \""invalid-vp90-02-v2.webm\""},\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  {1, \""invalid-vp90-2-00-quantizer-00.webm.ivf.s5861_r01-05_b6-.v2.ivf\""},\n+#endif\n+  {1, \""invalid-vp90-03-v3.webm\""},\n+  {1, \""invalid-vp90-2-00-quantizer-11.webm.ivf.s52984_r01-05_b6-.ivf\""},\n+  {1, \""invalid-vp90-2-00-quantizer-11.webm.ivf.s52984_r01-05_b6-z.ivf\""},\n+  {1, \""invalid-vp90-2-12-droppable_1.ivf.s3676_r01-05_b6-.ivf\""},\n+  {1, \""invalid-vp90-2-05-resize.ivf.s59293_r01-05_b6-.ivf\""},\n+  {1, \""invalid-vp90-2-09-subpixel-00.ivf.s20492_r01-05_b6-.v2.ivf\""},\n+  {1, \""invalid-vp91-2-mixedrefcsp-444to420.ivf\""},\n+  {1, \""invalid-vp90-2-12-droppable_1.ivf.s73804_r01-05_b6-.ivf\""},\n+  {1, \""invalid-vp90-2-03-size-224x196.webm.ivf.s44156_r01-05_b6-.ivf\""},\n+  {1, \""invalid-vp90-2-03-size-202x210.webm.ivf.s113306_r01-05_b6-.ivf\""},\n+};\n+\n+VP9_INSTANTIATE_TEST_CASE(InvalidFileTest,\n+                          ::testing::ValuesIn(kVP9InvalidFileTests));\n+\n+// This class will include test vectors that are expected to fail\n+// peek. However they are still expected to have no fatal failures.\n+class InvalidFileInvalidPeekTest : public InvalidFileTest {\n+ protected:\n+  InvalidFileInvalidPeekTest() : InvalidFileTest() {}\n+  virtual void HandlePeekResult(libvpx_test::Decoder *const /*decoder*/,\n+                                libvpx_test::CompressedVideoSource* /*video*/,\n+                                const vpx_codec_err_t /*res_peek*/) {}\n+};\n+\n+TEST_P(InvalidFileInvalidPeekTest, ReturnCode) {\n+  RunTest();\n+}\n+\n+const DecodeParam kVP9InvalidFileInvalidPeekTests[] = {\n+  {1, \""invalid-vp90-01-v2.webm\""},\n+};\n+\n+VP9_INSTANTIATE_TEST_CASE(InvalidFileInvalidPeekTest,\n+                          ::testing::ValuesIn(kVP9InvalidFileInvalidPeekTests));\n+\n+const DecodeParam kMultiThreadedVP9InvalidFileTests[] = {\n+  {4, \""invalid-vp90-2-08-tile_1x4_frame_parallel_all_key.webm\""},\n+  {4, \""invalid-\""\n+      \""vp90-2-08-tile_1x2_frame_parallel.webm.ivf.s47039_r01-05_b6-.ivf\""},\n+  {4, \""invalid-vp90-2-08-tile_1x8_frame_parallel.webm.ivf.s288_r01-05_b6-.ivf\""},\n+  {2, \""invalid-vp90-2-09-aq2.webm.ivf.s3984_r01-05_b6-.v2.ivf\""},\n+  {4, \""invalid-vp90-2-09-subpixel-00.ivf.s19552_r01-05_b6-.v2.ivf\""},\n+};\n+\n+INSTANTIATE_TEST_CASE_P(\n+    VP9MultiThreaded, InvalidFileTest,\n+    ::testing::Combine(\n+        ::testing::Values(\n+            static_cast<const libvpx_test::CodecFactory*>(&libvpx_test::kVP9)),\n+        ::testing::ValuesIn(kMultiThreadedVP9InvalidFileTests)));\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/lpf_8_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/lpf_8_test.cc"", ""patch"": ""@@ -0,0 +1,716 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <cmath>\n+#include <cstdlib>\n+#include <string>\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vpx_config.h\""\n+#include \""./vpx_dsp_rtcd.h\""\n+#include \""test/acm_random.h\""\n+#include \""test/clear_system_state.h\""\n+#include \""test/register_state_check.h\""\n+#include \""test/util.h\""\n+#include \""vp9/common/vp9_entropy.h\""\n+#include \""vp9/common/vp9_loopfilter.h\""\n+#include \""vpx/vpx_integer.h\""\n+\n+using libvpx_test::ACMRandom;\n+\n+namespace {\n+// Horizontally and Vertically need 32x32: 8  Coeffs preceeding filtered section\n+//                                         16 Coefs within filtered section\n+//                                         8  Coeffs following filtered section\n+const int kNumCoeffs = 1024;\n+\n+const int number_of_iterations = 10000;\n+\n+#if CONFIG_VP9_HIGHBITDEPTH\n+typedef void (*loop_op_t)(uint16_t *s, int p, const uint8_t *blimit,\n+                          const uint8_t *limit, const uint8_t *thresh,\n+                          int count, int bd);\n+typedef void (*dual_loop_op_t)(uint16_t *s, int p, const uint8_t *blimit0,\n+                               const uint8_t *limit0, const uint8_t *thresh0,\n+                               const uint8_t *blimit1, const uint8_t *limit1,\n+                               const uint8_t *thresh1, int bd);\n+#else\n+typedef void (*loop_op_t)(uint8_t *s, int p, const uint8_t *blimit,\n+                          const uint8_t *limit, const uint8_t *thresh,\n+                          int count);\n+typedef void (*dual_loop_op_t)(uint8_t *s, int p, const uint8_t *blimit0,\n+                               const uint8_t *limit0, const uint8_t *thresh0,\n+                               const uint8_t *blimit1, const uint8_t *limit1,\n+                               const uint8_t *thresh1);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+\n+typedef std::tr1::tuple<loop_op_t, loop_op_t, int, int> loop8_param_t;\n+typedef std::tr1::tuple<dual_loop_op_t, dual_loop_op_t, int> dualloop8_param_t;\n+\n+#if HAVE_SSE2\n+#if CONFIG_VP9_HIGHBITDEPTH\n+void wrapper_vertical_16_sse2(uint16_t *s, int p, const uint8_t *blimit,\n+                              const uint8_t *limit, const uint8_t *thresh,\n+                              int count, int bd) {\n+  vpx_highbd_lpf_vertical_16_sse2(s, p, blimit, limit, thresh, bd);\n+}\n+\n+void wrapper_vertical_16_c(uint16_t *s, int p, const uint8_t *blimit,\n+                           const uint8_t *limit, const uint8_t *thresh,\n+                           int count, int bd) {\n+  vpx_highbd_lpf_vertical_16_c(s, p, blimit, limit, thresh, bd);\n+}\n+\n+void wrapper_vertical_16_dual_sse2(uint16_t *s, int p, const uint8_t *blimit,\n+                                   const uint8_t *limit, const uint8_t *thresh,\n+                                   int count, int bd) {\n+  vpx_highbd_lpf_vertical_16_dual_sse2(s, p, blimit, limit, thresh, bd);\n+}\n+\n+void wrapper_vertical_16_dual_c(uint16_t *s, int p, const uint8_t *blimit,\n+                                const uint8_t *limit, const uint8_t *thresh,\n+                                int count, int bd) {\n+  vpx_highbd_lpf_vertical_16_dual_c(s, p, blimit, limit, thresh, bd);\n+}\n+#else\n+void wrapper_vertical_16_sse2(uint8_t *s, int p, const uint8_t *blimit,\n+                              const uint8_t *limit, const uint8_t *thresh,\n+                              int count) {\n+  vpx_lpf_vertical_16_sse2(s, p, blimit, limit, thresh);\n+}\n+\n+void wrapper_vertical_16_c(uint8_t *s, int p, const uint8_t *blimit,\n+                           const uint8_t *limit, const uint8_t *thresh,\n+                           int count) {\n+  vpx_lpf_vertical_16_c(s, p, blimit, limit, thresh);\n+}\n+\n+void wrapper_vertical_16_dual_sse2(uint8_t *s, int p, const uint8_t *blimit,\n+                                   const uint8_t *limit, const uint8_t *thresh,\n+                                   int count) {\n+  vpx_lpf_vertical_16_dual_sse2(s, p, blimit, limit, thresh);\n+}\n+\n+void wrapper_vertical_16_dual_c(uint8_t *s, int p, const uint8_t *blimit,\n+                                const uint8_t *limit, const uint8_t *thresh,\n+                                int count) {\n+  vpx_lpf_vertical_16_dual_c(s, p, blimit, limit, thresh);\n+}\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+#endif  // HAVE_SSE2\n+\n+#if HAVE_NEON_ASM\n+#if CONFIG_VP9_HIGHBITDEPTH\n+// No neon high bitdepth functions.\n+#else\n+void wrapper_vertical_16_neon(uint8_t *s, int p, const uint8_t *blimit,\n+                              const uint8_t *limit, const uint8_t *thresh,\n+                              int count) {\n+  vpx_lpf_vertical_16_neon(s, p, blimit, limit, thresh);\n+}\n+\n+void wrapper_vertical_16_c(uint8_t *s, int p, const uint8_t *blimit,\n+                           const uint8_t *limit, const uint8_t *thresh,\n+                           int count) {\n+  vpx_lpf_vertical_16_c(s, p, blimit, limit, thresh);\n+}\n+\n+void wrapper_vertical_16_dual_neon(uint8_t *s, int p, const uint8_t *blimit,\n+                                   const uint8_t *limit, const uint8_t *thresh,\n+                                   int count) {\n+  vpx_lpf_vertical_16_dual_neon(s, p, blimit, limit, thresh);\n+}\n+\n+void wrapper_vertical_16_dual_c(uint8_t *s, int p, const uint8_t *blimit,\n+                                const uint8_t *limit, const uint8_t *thresh,\n+                                int count) {\n+  vpx_lpf_vertical_16_dual_c(s, p, blimit, limit, thresh);\n+}\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+#endif  // HAVE_NEON_ASM\n+\n+#if HAVE_MSA && (!CONFIG_VP9_HIGHBITDEPTH)\n+void wrapper_vertical_16_msa(uint8_t *s, int p, const uint8_t *blimit,\n+                             const uint8_t *limit, const uint8_t *thresh,\n+                             int count) {\n+  vpx_lpf_vertical_16_msa(s, p, blimit, limit, thresh);\n+}\n+\n+void wrapper_vertical_16_c(uint8_t *s, int p, const uint8_t *blimit,\n+                           const uint8_t *limit, const uint8_t *thresh,\n+                           int count) {\n+  vpx_lpf_vertical_16_c(s, p, blimit, limit, thresh);\n+}\n+#endif  // HAVE_MSA && (!CONFIG_VP9_HIGHBITDEPTH)\n+\n+class Loop8Test6Param : public ::testing::TestWithParam<loop8_param_t> {\n+ public:\n+  virtual ~Loop8Test6Param() {}\n+  virtual void SetUp() {\n+    loopfilter_op_ = GET_PARAM(0);\n+    ref_loopfilter_op_ = GET_PARAM(1);\n+    bit_depth_ = GET_PARAM(2);\n+    count_ = GET_PARAM(3);\n+    mask_ = (1 << bit_depth_) - 1;\n+  }\n+\n+  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n+\n+ protected:\n+  int bit_depth_;\n+  int count_;\n+  int mask_;\n+  loop_op_t loopfilter_op_;\n+  loop_op_t ref_loopfilter_op_;\n+};\n+\n+class Loop8Test9Param : public ::testing::TestWithParam<dualloop8_param_t> {\n+ public:\n+  virtual ~Loop8Test9Param() {}\n+  virtual void SetUp() {\n+    loopfilter_op_ = GET_PARAM(0);\n+    ref_loopfilter_op_ = GET_PARAM(1);\n+    bit_depth_ = GET_PARAM(2);\n+    mask_ = (1 << bit_depth_) - 1;\n+  }\n+\n+  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n+\n+ protected:\n+  int bit_depth_;\n+  int mask_;\n+  dual_loop_op_t loopfilter_op_;\n+  dual_loop_op_t ref_loopfilter_op_;\n+};\n+\n+TEST_P(Loop8Test6Param, OperationCheck) {\n+  ACMRandom rnd(ACMRandom::DeterministicSeed());\n+  const int count_test_block = number_of_iterations;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  int32_t bd = bit_depth_;\n+  DECLARE_ALIGNED(16, uint16_t, s[kNumCoeffs]);\n+  DECLARE_ALIGNED(16, uint16_t, ref_s[kNumCoeffs]);\n+#else\n+  DECLARE_ALIGNED(8, uint8_t, s[kNumCoeffs]);\n+  DECLARE_ALIGNED(8, uint8_t, ref_s[kNumCoeffs]);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+  int err_count_total = 0;\n+  int first_failure = -1;\n+  for (int i = 0; i < count_test_block; ++i) {\n+    int err_count = 0;\n+    uint8_t tmp = static_cast<uint8_t>(rnd(3 * MAX_LOOP_FILTER + 4));\n+    DECLARE_ALIGNED(16, const uint8_t, blimit[16]) = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    tmp = static_cast<uint8_t>(rnd(MAX_LOOP_FILTER));\n+    DECLARE_ALIGNED(16, const uint8_t, limit[16])  = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    tmp = rnd.Rand8();\n+    DECLARE_ALIGNED(16, const uint8_t, thresh[16]) = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    int32_t p = kNumCoeffs/32;\n+\n+    uint16_t tmp_s[kNumCoeffs];\n+    int j = 0;\n+    while (j < kNumCoeffs) {\n+      uint8_t val = rnd.Rand8();\n+      if (val & 0x80) {  // 50% chance to choose a new value.\n+        tmp_s[j] = rnd.Rand16();\n+        j++;\n+      } else {  // 50% chance to repeat previous value in row X times\n+        int k = 0;\n+        while (k++ < ((val & 0x1f) + 1) && j < kNumCoeffs) {\n+          if (j < 1) {\n+            tmp_s[j] = rnd.Rand16();\n+          } else if (val & 0x20) {  // Increment by an value within the limit\n+            tmp_s[j] = (tmp_s[j - 1] + (*limit - 1));\n+          } else {  // Decrement by an value within the limit\n+            tmp_s[j] = (tmp_s[j - 1] - (*limit - 1));\n+          }\n+          j++;\n+        }\n+      }\n+    }\n+    for (j = 0; j < kNumCoeffs; j++) {\n+      if (i % 2) {\n+        s[j] = tmp_s[j] & mask_;\n+      } else {\n+        s[j] = tmp_s[p * (j % p) + j / p] & mask_;\n+      }\n+      ref_s[j] = s[j];\n+    }\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    ref_loopfilter_op_(ref_s + 8 + p * 8, p, blimit, limit, thresh, count_, bd);\n+    ASM_REGISTER_STATE_CHECK(\n+        loopfilter_op_(s + 8 + p * 8, p, blimit, limit, thresh, count_, bd));\n+#else\n+    ref_loopfilter_op_(ref_s+8+p*8, p, blimit, limit, thresh, count_);\n+    ASM_REGISTER_STATE_CHECK(\n+        loopfilter_op_(s + 8 + p * 8, p, blimit, limit, thresh, count_));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+\n+    for (int j = 0; j < kNumCoeffs; ++j) {\n+      err_count += ref_s[j] != s[j];\n+    }\n+    if (err_count && !err_count_total) {\n+      first_failure = i;\n+    }\n+    err_count_total += err_count;\n+  }\n+  EXPECT_EQ(0, err_count_total)\n+      << \""Error: Loop8Test6Param, C output doesn't match SSE2 \""\n+         \""loopfilter output. \""\n+      << \""First failed at test case \"" << first_failure;\n+}\n+\n+TEST_P(Loop8Test6Param, ValueCheck) {\n+  ACMRandom rnd(ACMRandom::DeterministicSeed());\n+  const int count_test_block = number_of_iterations;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  const int32_t bd = bit_depth_;\n+  DECLARE_ALIGNED(16, uint16_t, s[kNumCoeffs]);\n+  DECLARE_ALIGNED(16, uint16_t, ref_s[kNumCoeffs]);\n+#else\n+  DECLARE_ALIGNED(8, uint8_t, s[kNumCoeffs]);\n+  DECLARE_ALIGNED(8, uint8_t, ref_s[kNumCoeffs]);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+  int err_count_total = 0;\n+  int first_failure = -1;\n+\n+  // NOTE: The code in vp9_loopfilter.c:update_sharpness computes mblim as a\n+  // function of sharpness_lvl and the loopfilter lvl as:\n+  // block_inside_limit = lvl >> ((sharpness_lvl > 0) + (sharpness_lvl > 4));\n+  // ...\n+  // memset(lfi->lfthr[lvl].mblim, (2 * (lvl + 2) + block_inside_limit),\n+  //        SIMD_WIDTH);\n+  // This means that the largest value for mblim will occur when sharpness_lvl\n+  // is equal to 0, and lvl is equal to its greatest value (MAX_LOOP_FILTER).\n+  // In this case block_inside_limit will be equal to MAX_LOOP_FILTER and\n+  // therefore mblim will be equal to (2 * (lvl + 2) + block_inside_limit) =\n+  // 2 * (MAX_LOOP_FILTER + 2) + MAX_LOOP_FILTER = 3 * MAX_LOOP_FILTER + 4\n+\n+  for (int i = 0; i < count_test_block; ++i) {\n+    int err_count = 0;\n+    uint8_t tmp = static_cast<uint8_t>(rnd(3 * MAX_LOOP_FILTER + 4));\n+    DECLARE_ALIGNED(16, const uint8_t, blimit[16]) = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    tmp = static_cast<uint8_t>(rnd(MAX_LOOP_FILTER));\n+    DECLARE_ALIGNED(16, const uint8_t, limit[16])  = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    tmp = rnd.Rand8();\n+    DECLARE_ALIGNED(16, const uint8_t, thresh[16]) = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    int32_t p = kNumCoeffs / 32;\n+    for (int j = 0; j < kNumCoeffs; ++j) {\n+      s[j] = rnd.Rand16() & mask_;\n+      ref_s[j] = s[j];\n+    }\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    ref_loopfilter_op_(ref_s + 8 + p * 8, p, blimit, limit, thresh, count_, bd);\n+    ASM_REGISTER_STATE_CHECK(\n+        loopfilter_op_(s + 8 + p * 8, p, blimit, limit, thresh, count_, bd));\n+#else\n+    ref_loopfilter_op_(ref_s+8+p*8, p, blimit, limit, thresh, count_);\n+    ASM_REGISTER_STATE_CHECK(\n+        loopfilter_op_(s + 8 + p * 8, p, blimit, limit, thresh, count_));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+    for (int j = 0; j < kNumCoeffs; ++j) {\n+      err_count += ref_s[j] != s[j];\n+    }\n+    if (err_count && !err_count_total) {\n+      first_failure = i;\n+    }\n+    err_count_total += err_count;\n+  }\n+  EXPECT_EQ(0, err_count_total)\n+      << \""Error: Loop8Test6Param, C output doesn't match SSE2 \""\n+         \""loopfilter output. \""\n+      << \""First failed at test case \"" << first_failure;\n+}\n+\n+TEST_P(Loop8Test9Param, OperationCheck) {\n+  ACMRandom rnd(ACMRandom::DeterministicSeed());\n+  const int count_test_block = number_of_iterations;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  const int32_t bd = bit_depth_;\n+  DECLARE_ALIGNED(16, uint16_t, s[kNumCoeffs]);\n+  DECLARE_ALIGNED(16, uint16_t, ref_s[kNumCoeffs]);\n+#else\n+  DECLARE_ALIGNED(8,  uint8_t,  s[kNumCoeffs]);\n+  DECLARE_ALIGNED(8,  uint8_t,  ref_s[kNumCoeffs]);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+  int err_count_total = 0;\n+  int first_failure = -1;\n+  for (int i = 0; i < count_test_block; ++i) {\n+    int err_count = 0;\n+    uint8_t tmp = static_cast<uint8_t>(rnd(3 * MAX_LOOP_FILTER + 4));\n+    DECLARE_ALIGNED(16, const uint8_t, blimit0[16]) = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    tmp = static_cast<uint8_t>(rnd(MAX_LOOP_FILTER));\n+    DECLARE_ALIGNED(16, const uint8_t, limit0[16])  = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    tmp = rnd.Rand8();\n+    DECLARE_ALIGNED(16, const uint8_t, thresh0[16]) = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    tmp = static_cast<uint8_t>(rnd(3 * MAX_LOOP_FILTER + 4));\n+    DECLARE_ALIGNED(16, const uint8_t, blimit1[16]) = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    tmp = static_cast<uint8_t>(rnd(MAX_LOOP_FILTER));\n+    DECLARE_ALIGNED(16, const uint8_t, limit1[16])  = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    tmp = rnd.Rand8();\n+    DECLARE_ALIGNED(16, const uint8_t, thresh1[16]) = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    int32_t p = kNumCoeffs / 32;\n+    uint16_t tmp_s[kNumCoeffs];\n+    int j = 0;\n+    const uint8_t limit = *limit0 < *limit1 ? *limit0 : *limit1;\n+    while (j < kNumCoeffs) {\n+      uint8_t val = rnd.Rand8();\n+      if (val & 0x80) {  // 50% chance to choose a new value.\n+        tmp_s[j] = rnd.Rand16();\n+        j++;\n+      } else {  // 50% chance to repeat previous value in row X times.\n+        int k = 0;\n+        while (k++ < ((val & 0x1f) + 1) && j < kNumCoeffs) {\n+          if (j < 1) {\n+            tmp_s[j] = rnd.Rand16();\n+          } else if (val & 0x20) {  // Increment by a value within the limit.\n+            tmp_s[j] = (tmp_s[j - 1] + (limit - 1));\n+          } else {  // Decrement by an value within the limit.\n+            tmp_s[j] = (tmp_s[j - 1] - (limit - 1));\n+          }\n+          j++;\n+        }\n+      }\n+    }\n+    for (j = 0; j < kNumCoeffs; j++) {\n+      if (i % 2) {\n+        s[j] = tmp_s[j] & mask_;\n+      } else {\n+        s[j] = tmp_s[p * (j % p) + j / p] & mask_;\n+      }\n+      ref_s[j] = s[j];\n+    }\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    ref_loopfilter_op_(ref_s + 8 + p * 8, p, blimit0, limit0, thresh0,\n+                       blimit1, limit1, thresh1, bd);\n+    ASM_REGISTER_STATE_CHECK(\n+        loopfilter_op_(s + 8 + p * 8, p, blimit0, limit0, thresh0,\n+                       blimit1, limit1, thresh1, bd));\n+#else\n+    ref_loopfilter_op_(ref_s + 8 + p * 8, p, blimit0, limit0, thresh0,\n+                       blimit1, limit1, thresh1);\n+    ASM_REGISTER_STATE_CHECK(\n+        loopfilter_op_(s + 8 + p * 8, p, blimit0, limit0, thresh0,\n+                       blimit1, limit1, thresh1));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+    for (int j = 0; j < kNumCoeffs; ++j) {\n+      err_count += ref_s[j] != s[j];\n+    }\n+    if (err_count && !err_count_total) {\n+      first_failure = i;\n+    }\n+    err_count_total += err_count;\n+  }\n+  EXPECT_EQ(0, err_count_total)\n+      << \""Error: Loop8Test9Param, C output doesn't match SSE2 \""\n+         \""loopfilter output. \""\n+      << \""First failed at test case \"" << first_failure;\n+}\n+\n+TEST_P(Loop8Test9Param, ValueCheck) {\n+  ACMRandom rnd(ACMRandom::DeterministicSeed());\n+  const int count_test_block = number_of_iterations;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  DECLARE_ALIGNED(16, uint16_t, s[kNumCoeffs]);\n+  DECLARE_ALIGNED(16, uint16_t, ref_s[kNumCoeffs]);\n+#else\n+  DECLARE_ALIGNED(8,  uint8_t, s[kNumCoeffs]);\n+  DECLARE_ALIGNED(8,  uint8_t, ref_s[kNumCoeffs]);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+  int err_count_total = 0;\n+  int first_failure = -1;\n+  for (int i = 0; i < count_test_block; ++i) {\n+    int err_count = 0;\n+    uint8_t tmp = static_cast<uint8_t>(rnd(3 * MAX_LOOP_FILTER + 4));\n+    DECLARE_ALIGNED(16, const uint8_t, blimit0[16]) = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    tmp = static_cast<uint8_t>(rnd(MAX_LOOP_FILTER));\n+    DECLARE_ALIGNED(16, const uint8_t, limit0[16])  = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    tmp = rnd.Rand8();\n+    DECLARE_ALIGNED(16, const uint8_t, thresh0[16]) = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    tmp = static_cast<uint8_t>(rnd(3 * MAX_LOOP_FILTER + 4));\n+    DECLARE_ALIGNED(16, const uint8_t, blimit1[16]) = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    tmp = static_cast<uint8_t>(rnd(MAX_LOOP_FILTER));\n+    DECLARE_ALIGNED(16, const uint8_t, limit1[16])  = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    tmp = rnd.Rand8();\n+    DECLARE_ALIGNED(16, const uint8_t, thresh1[16]) = {\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n+        tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp\n+    };\n+    int32_t p = kNumCoeffs / 32;  // TODO(pdlf) can we have non-square here?\n+    for (int j = 0; j < kNumCoeffs; ++j) {\n+      s[j] = rnd.Rand16() & mask_;\n+      ref_s[j] = s[j];\n+    }\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    const int32_t bd = bit_depth_;\n+    ref_loopfilter_op_(ref_s + 8 + p * 8, p, blimit0, limit0, thresh0,\n+                       blimit1, limit1, thresh1, bd);\n+    ASM_REGISTER_STATE_CHECK(\n+        loopfilter_op_(s + 8 + p * 8, p, blimit0, limit0,\n+                       thresh0, blimit1, limit1, thresh1, bd));\n+#else\n+    ref_loopfilter_op_(ref_s + 8 + p * 8, p, blimit0, limit0, thresh0,\n+                       blimit1, limit1, thresh1);\n+    ASM_REGISTER_STATE_CHECK(\n+        loopfilter_op_(s + 8 + p * 8, p, blimit0, limit0, thresh0,\n+                       blimit1, limit1, thresh1));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+    for (int j = 0; j < kNumCoeffs; ++j) {\n+      err_count += ref_s[j] != s[j];\n+    }\n+    if (err_count && !err_count_total) {\n+      first_failure = i;\n+    }\n+    err_count_total += err_count;\n+  }\n+  EXPECT_EQ(0, err_count_total)\n+      << \""Error: Loop8Test9Param, C output doesn't match SSE2\""\n+         \""loopfilter output. \""\n+      << \""First failed at test case \"" << first_failure;\n+}\n+\n+using std::tr1::make_tuple;\n+\n+#if HAVE_SSE2\n+#if CONFIG_VP9_HIGHBITDEPTH\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, Loop8Test6Param,\n+    ::testing::Values(\n+        make_tuple(&vpx_highbd_lpf_horizontal_4_sse2,\n+                   &vpx_highbd_lpf_horizontal_4_c, 8, 1),\n+        make_tuple(&vpx_highbd_lpf_vertical_4_sse2,\n+                   &vpx_highbd_lpf_vertical_4_c, 8, 1),\n+        make_tuple(&vpx_highbd_lpf_horizontal_8_sse2,\n+                   &vpx_highbd_lpf_horizontal_8_c, 8, 1),\n+        make_tuple(&vpx_highbd_lpf_horizontal_16_sse2,\n+                   &vpx_highbd_lpf_horizontal_16_c, 8, 1),\n+        make_tuple(&vpx_highbd_lpf_horizontal_16_sse2,\n+                   &vpx_highbd_lpf_horizontal_16_c, 8, 2),\n+        make_tuple(&vpx_highbd_lpf_vertical_8_sse2,\n+                   &vpx_highbd_lpf_vertical_8_c, 8, 1),\n+        make_tuple(&wrapper_vertical_16_sse2,\n+                   &wrapper_vertical_16_c, 8, 1),\n+        make_tuple(&vpx_highbd_lpf_horizontal_4_sse2,\n+                   &vpx_highbd_lpf_horizontal_4_c, 10, 1),\n+        make_tuple(&vpx_highbd_lpf_vertical_4_sse2,\n+                   &vpx_highbd_lpf_vertical_4_c, 10, 1),\n+        make_tuple(&vpx_highbd_lpf_horizontal_8_sse2,\n+                   &vpx_highbd_lpf_horizontal_8_c, 10, 1),\n+        make_tuple(&vpx_highbd_lpf_horizontal_16_sse2,\n+                   &vpx_highbd_lpf_horizontal_16_c, 10, 1),\n+        make_tuple(&vpx_highbd_lpf_horizontal_16_sse2,\n+                   &vpx_highbd_lpf_horizontal_16_c, 10, 2),\n+        make_tuple(&vpx_highbd_lpf_vertical_8_sse2,\n+                   &vpx_highbd_lpf_vertical_8_c, 10, 1),\n+        make_tuple(&wrapper_vertical_16_sse2,\n+                   &wrapper_vertical_16_c, 10, 1),\n+        make_tuple(&vpx_highbd_lpf_horizontal_4_sse2,\n+                   &vpx_highbd_lpf_horizontal_4_c, 12, 1),\n+        make_tuple(&vpx_highbd_lpf_vertical_4_sse2,\n+                   &vpx_highbd_lpf_vertical_4_c, 12, 1),\n+        make_tuple(&vpx_highbd_lpf_horizontal_8_sse2,\n+                   &vpx_highbd_lpf_horizontal_8_c, 12, 1),\n+        make_tuple(&vpx_highbd_lpf_horizontal_16_sse2,\n+                   &vpx_highbd_lpf_horizontal_16_c, 12, 1),\n+        make_tuple(&vpx_highbd_lpf_horizontal_16_sse2,\n+                   &vpx_highbd_lpf_horizontal_16_c, 12, 2),\n+        make_tuple(&vpx_highbd_lpf_vertical_8_sse2,\n+                   &vpx_highbd_lpf_vertical_8_c, 12, 1),\n+        make_tuple(&wrapper_vertical_16_sse2,\n+                   &wrapper_vertical_16_c, 12, 1),\n+        make_tuple(&wrapper_vertical_16_dual_sse2,\n+                   &wrapper_vertical_16_dual_c, 8, 1),\n+        make_tuple(&wrapper_vertical_16_dual_sse2,\n+                   &wrapper_vertical_16_dual_c, 10, 1),\n+        make_tuple(&wrapper_vertical_16_dual_sse2,\n+                   &wrapper_vertical_16_dual_c, 12, 1)));\n+#else\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, Loop8Test6Param,\n+    ::testing::Values(\n+        make_tuple(&vpx_lpf_horizontal_8_sse2, &vpx_lpf_horizontal_8_c, 8, 1),\n+        make_tuple(&vpx_lpf_horizontal_16_sse2, &vpx_lpf_horizontal_16_c, 8, 1),\n+        make_tuple(&vpx_lpf_horizontal_16_sse2, &vpx_lpf_horizontal_16_c, 8, 2),\n+        make_tuple(&vpx_lpf_vertical_8_sse2, &vpx_lpf_vertical_8_c, 8, 1),\n+        make_tuple(&wrapper_vertical_16_sse2, &wrapper_vertical_16_c, 8, 1)));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+#endif\n+\n+#if HAVE_AVX2 && (!CONFIG_VP9_HIGHBITDEPTH)\n+INSTANTIATE_TEST_CASE_P(\n+    AVX2, Loop8Test6Param,\n+    ::testing::Values(\n+        make_tuple(&vpx_lpf_horizontal_16_avx2, &vpx_lpf_horizontal_16_c, 8, 1),\n+        make_tuple(&vpx_lpf_horizontal_16_avx2, &vpx_lpf_horizontal_16_c, 8,\n+                   2)));\n+#endif\n+\n+#if HAVE_SSE2\n+#if CONFIG_VP9_HIGHBITDEPTH\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, Loop8Test9Param,\n+    ::testing::Values(\n+        make_tuple(&vpx_highbd_lpf_horizontal_4_dual_sse2,\n+                   &vpx_highbd_lpf_horizontal_4_dual_c, 8),\n+        make_tuple(&vpx_highbd_lpf_horizontal_8_dual_sse2,\n+                   &vpx_highbd_lpf_horizontal_8_dual_c, 8),\n+        make_tuple(&vpx_highbd_lpf_vertical_4_dual_sse2,\n+                   &vpx_highbd_lpf_vertical_4_dual_c, 8),\n+        make_tuple(&vpx_highbd_lpf_vertical_8_dual_sse2,\n+                   &vpx_highbd_lpf_vertical_8_dual_c, 8),\n+        make_tuple(&vpx_highbd_lpf_horizontal_4_dual_sse2,\n+                   &vpx_highbd_lpf_horizontal_4_dual_c, 10),\n+        make_tuple(&vpx_highbd_lpf_horizontal_8_dual_sse2,\n+                   &vpx_highbd_lpf_horizontal_8_dual_c, 10),\n+        make_tuple(&vpx_highbd_lpf_vertical_4_dual_sse2,\n+                   &vpx_highbd_lpf_vertical_4_dual_c, 10),\n+        make_tuple(&vpx_highbd_lpf_vertical_8_dual_sse2,\n+                   &vpx_highbd_lpf_vertical_8_dual_c, 10),\n+        make_tuple(&vpx_highbd_lpf_horizontal_4_dual_sse2,\n+                   &vpx_highbd_lpf_horizontal_4_dual_c, 12),\n+        make_tuple(&vpx_highbd_lpf_horizontal_8_dual_sse2,\n+                   &vpx_highbd_lpf_horizontal_8_dual_c, 12),\n+        make_tuple(&vpx_highbd_lpf_vertical_4_dual_sse2,\n+                   &vpx_highbd_lpf_vertical_4_dual_c, 12),\n+        make_tuple(&vpx_highbd_lpf_vertical_8_dual_sse2,\n+                   &vpx_highbd_lpf_vertical_8_dual_c, 12)));\n+#else\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, Loop8Test9Param,\n+    ::testing::Values(\n+        make_tuple(&vpx_lpf_horizontal_4_dual_sse2,\n+                   &vpx_lpf_horizontal_4_dual_c, 8),\n+        make_tuple(&vpx_lpf_horizontal_8_dual_sse2,\n+                   &vpx_lpf_horizontal_8_dual_c, 8),\n+        make_tuple(&vpx_lpf_vertical_4_dual_sse2,\n+                   &vpx_lpf_vertical_4_dual_c, 8),\n+        make_tuple(&vpx_lpf_vertical_8_dual_sse2,\n+                   &vpx_lpf_vertical_8_dual_c, 8)));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+#endif\n+\n+#if HAVE_NEON\n+#if CONFIG_VP9_HIGHBITDEPTH\n+// No neon high bitdepth functions.\n+#else\n+INSTANTIATE_TEST_CASE_P(\n+    NEON, Loop8Test6Param,\n+    ::testing::Values(\n+#if HAVE_NEON_ASM\n+// Using #if inside the macro is unsupported on MSVS but the tests are not\n+// currently built for MSVS with ARM and NEON.\n+        make_tuple(&vpx_lpf_horizontal_16_neon,\n+                   &vpx_lpf_horizontal_16_c, 8, 1),\n+        make_tuple(&vpx_lpf_horizontal_16_neon,\n+                   &vpx_lpf_horizontal_16_c, 8, 2),\n+        make_tuple(&wrapper_vertical_16_neon,\n+                   &wrapper_vertical_16_c, 8, 1),\n+        make_tuple(&wrapper_vertical_16_dual_neon,\n+                   &wrapper_vertical_16_dual_c, 8, 1),\n+#endif  // HAVE_NEON_ASM\n+        make_tuple(&vpx_lpf_horizontal_8_neon,\n+                   &vpx_lpf_horizontal_8_c, 8, 1),\n+        make_tuple(&vpx_lpf_vertical_8_neon,\n+                   &vpx_lpf_vertical_8_c, 8, 1),\n+        make_tuple(&vpx_lpf_horizontal_4_neon,\n+                   &vpx_lpf_horizontal_4_c, 8, 1),\n+        make_tuple(&vpx_lpf_vertical_4_neon,\n+                   &vpx_lpf_vertical_4_c, 8, 1)));\n+INSTANTIATE_TEST_CASE_P(\n+    NEON, Loop8Test9Param,\n+    ::testing::Values(\n+#if HAVE_NEON_ASM\n+        make_tuple(&vpx_lpf_horizontal_8_dual_neon,\n+                   &vpx_lpf_horizontal_8_dual_c, 8),\n+        make_tuple(&vpx_lpf_vertical_8_dual_neon,\n+                   &vpx_lpf_vertical_8_dual_c, 8),\n+#endif  // HAVE_NEON_ASM\n+        make_tuple(&vpx_lpf_horizontal_4_dual_neon,\n+                   &vpx_lpf_horizontal_4_dual_c, 8),\n+        make_tuple(&vpx_lpf_vertical_4_dual_neon,\n+                   &vpx_lpf_vertical_4_dual_c, 8)));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+#endif  // HAVE_NEON\n+\n+#if HAVE_MSA && (!CONFIG_VP9_HIGHBITDEPTH)\n+INSTANTIATE_TEST_CASE_P(\n+    MSA, Loop8Test6Param,\n+    ::testing::Values(\n+        make_tuple(&vpx_lpf_horizontal_8_msa, &vpx_lpf_horizontal_8_c, 8, 1),\n+        make_tuple(&vpx_lpf_horizontal_16_msa, &vpx_lpf_horizontal_16_c, 8, 1),\n+        make_tuple(&vpx_lpf_horizontal_16_msa, &vpx_lpf_horizontal_16_c, 8, 2),\n+        make_tuple(&vpx_lpf_vertical_8_msa, &vpx_lpf_vertical_8_c, 8, 1),\n+        make_tuple(&wrapper_vertical_16_msa, &wrapper_vertical_16_c, 8, 1)));\n+\n+INSTANTIATE_TEST_CASE_P(\n+    MSA, Loop8Test9Param,\n+    ::testing::Values(\n+        make_tuple(&vpx_lpf_horizontal_4_dual_msa,\n+                   &vpx_lpf_horizontal_4_dual_c, 8),\n+        make_tuple(&vpx_lpf_horizontal_8_dual_msa,\n+                   &vpx_lpf_horizontal_8_dual_c, 8),\n+        make_tuple(&vpx_lpf_vertical_4_dual_msa,\n+                   &vpx_lpf_vertical_4_dual_c, 8),\n+        make_tuple(&vpx_lpf_vertical_8_dual_msa,\n+                   &vpx_lpf_vertical_8_dual_c, 8)));\n+#endif  // HAVE_MSA && (!CONFIG_VP9_HIGHBITDEPTH)\n+\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/md5_helper.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/md5_helper.h"", ""patch"": ""@@ -28,10 +28,12 @@\n\n       // plane, we never want to round down and thus skip a pixel so if\n       // we are shifting by 1 (chroma_shift) we add 1 before doing the shift.\n       // This works only for chroma_shift of 0 and 1.\n+      const int bytes_per_sample =\n+          (img->fmt & VPX_IMG_FMT_HIGHBITDEPTH) ? 2 : 1;\n       const int h = plane ? (img->d_h + img->y_chroma_shift) >>\n                     img->y_chroma_shift : img->d_h;\n-      const int w = plane ? (img->d_w + img->x_chroma_shift) >>\n-                    img->x_chroma_shift : img->d_w;\n+      const int w = (plane ? (img->d_w + img->x_chroma_shift) >>\n+                     img->x_chroma_shift : img->d_w) * bytes_per_sample;\n \n       for (int y = 0; y < h; ++y) {\n         MD5Update(&md5_, buf, w);\n@@ -40,6 +42,10 @@\n\n     }\n   }\n \n+  void Add(const uint8_t *data, size_t size) {\n+    MD5Update(&md5_, data, static_cast<uint32_t>(size));\n+  }\n+\n   const char *Get(void) {\n     static const char hex[16] = {\n       '0', '1', '2', '3', '4', '5', '6', '7',\n""}<_**next**_>{""filename"": ""libvpx/test/partial_idct_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/partial_idct_test.cc"", ""patch"": ""@@ -13,12 +13,13 @@\n\n #include <string.h>\n \n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vp9_rtcd.h\""\n+#include \""./vpx_dsp_rtcd.h\""\n #include \""test/acm_random.h\""\n #include \""test/clear_system_state.h\""\n #include \""test/register_state_check.h\""\n #include \""test/util.h\""\n-\n-#include \""./vp9_rtcd.h\""\n #include \""vp9/common/vp9_blockd.h\""\n #include \""vp9/common/vp9_scan.h\""\n #include \""vpx/vpx_integer.h\""\n@@ -26,20 +27,22 @@\n\n using libvpx_test::ACMRandom;\n \n namespace {\n-typedef void (*fwd_txfm_t)(const int16_t *in, int16_t *out, int stride);\n-typedef void (*inv_txfm_t)(const int16_t *in, uint8_t *out, int stride);\n-typedef std::tr1::tuple<inv_txfm_t,\n-                        inv_txfm_t,\n-                        TX_SIZE, int> partial_itxfm_param_t;\n+typedef void (*FwdTxfmFunc)(const int16_t *in, tran_low_t *out, int stride);\n+typedef void (*InvTxfmFunc)(const tran_low_t *in, uint8_t *out, int stride);\n+typedef std::tr1::tuple<FwdTxfmFunc,\n+                        InvTxfmFunc,\n+                        InvTxfmFunc,\n+                        TX_SIZE, int> PartialInvTxfmParam;\n const int kMaxNumCoeffs = 1024;\n-class PartialIDctTest : public ::testing::TestWithParam<partial_itxfm_param_t> {\n+class PartialIDctTest : public ::testing::TestWithParam<PartialInvTxfmParam> {\n  public:\n   virtual ~PartialIDctTest() {}\n   virtual void SetUp() {\n-    full_itxfm_ = GET_PARAM(0);\n-    partial_itxfm_ = GET_PARAM(1);\n-    tx_size_  = GET_PARAM(2);\n-    last_nonzero_ = GET_PARAM(3);\n+    ftxfm_ = GET_PARAM(0);\n+    full_itxfm_ = GET_PARAM(1);\n+    partial_itxfm_ = GET_PARAM(2);\n+    tx_size_  = GET_PARAM(3);\n+    last_nonzero_ = GET_PARAM(4);\n   }\n \n   virtual void TearDown() { libvpx_test::ClearSystemState(); }\n@@ -47,10 +50,90 @@\n\n  protected:\n   int last_nonzero_;\n   TX_SIZE tx_size_;\n-  inv_txfm_t full_itxfm_;\n-  inv_txfm_t partial_itxfm_;\n+  FwdTxfmFunc ftxfm_;\n+  InvTxfmFunc full_itxfm_;\n+  InvTxfmFunc partial_itxfm_;\n };\n \n+TEST_P(PartialIDctTest, RunQuantCheck) {\n+  ACMRandom rnd(ACMRandom::DeterministicSeed());\n+  int size;\n+  switch (tx_size_) {\n+    case TX_4X4:\n+      size = 4;\n+      break;\n+    case TX_8X8:\n+      size = 8;\n+      break;\n+    case TX_16X16:\n+      size = 16;\n+      break;\n+    case TX_32X32:\n+      size = 32;\n+      break;\n+    default:\n+      FAIL() << \""Wrong Size!\"";\n+      break;\n+  }\n+  DECLARE_ALIGNED(16, tran_low_t, test_coef_block1[kMaxNumCoeffs]);\n+  DECLARE_ALIGNED(16, tran_low_t, test_coef_block2[kMaxNumCoeffs]);\n+  DECLARE_ALIGNED(16, uint8_t, dst1[kMaxNumCoeffs]);\n+  DECLARE_ALIGNED(16, uint8_t, dst2[kMaxNumCoeffs]);\n+\n+  const int count_test_block = 1000;\n+  const int block_size = size * size;\n+\n+  DECLARE_ALIGNED(16, int16_t, input_extreme_block[kMaxNumCoeffs]);\n+  DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kMaxNumCoeffs]);\n+\n+  int max_error = 0;\n+  for (int i = 0; i < count_test_block; ++i) {\n+    // clear out destination buffer\n+    memset(dst1, 0, sizeof(*dst1) * block_size);\n+    memset(dst2, 0, sizeof(*dst2) * block_size);\n+    memset(test_coef_block1, 0, sizeof(*test_coef_block1) * block_size);\n+    memset(test_coef_block2, 0, sizeof(*test_coef_block2) * block_size);\n+\n+    ACMRandom rnd(ACMRandom::DeterministicSeed());\n+\n+    for (int i = 0; i < count_test_block; ++i) {\n+      // Initialize a test block with input range [-255, 255].\n+      if (i == 0) {\n+        for (int j = 0; j < block_size; ++j)\n+          input_extreme_block[j] = 255;\n+      } else if (i == 1) {\n+        for (int j = 0; j < block_size; ++j)\n+          input_extreme_block[j] = -255;\n+      } else {\n+        for (int j = 0; j < block_size; ++j) {\n+          input_extreme_block[j] = rnd.Rand8() % 2 ? 255 : -255;\n+        }\n+      }\n+\n+      ftxfm_(input_extreme_block, output_ref_block, size);\n+\n+      // quantization with maximum allowed step sizes\n+      test_coef_block1[0] = (output_ref_block[0] / 1336) * 1336;\n+      for (int j = 1; j < last_nonzero_; ++j)\n+        test_coef_block1[vp9_default_scan_orders[tx_size_].scan[j]]\n+                         = (output_ref_block[j] / 1828) * 1828;\n+    }\n+\n+    ASM_REGISTER_STATE_CHECK(full_itxfm_(test_coef_block1, dst1, size));\n+    ASM_REGISTER_STATE_CHECK(partial_itxfm_(test_coef_block1, dst2, size));\n+\n+    for (int j = 0; j < block_size; ++j) {\n+      const int diff = dst1[j] - dst2[j];\n+      const int error = diff * diff;\n+      if (max_error < error)\n+        max_error = error;\n+    }\n+  }\n+\n+  EXPECT_EQ(0, max_error)\n+      << \""Error: partial inverse transform produces different results\"";\n+}\n+\n TEST_P(PartialIDctTest, ResultsMatch) {\n   ACMRandom rnd(ACMRandom::DeterministicSeed());\n   int size;\n@@ -71,10 +154,10 @@\n\n       FAIL() << \""Wrong Size!\"";\n       break;\n   }\n-  DECLARE_ALIGNED_ARRAY(16, int16_t, test_coef_block1, kMaxNumCoeffs);\n-  DECLARE_ALIGNED_ARRAY(16, int16_t, test_coef_block2, kMaxNumCoeffs);\n-  DECLARE_ALIGNED_ARRAY(16, uint8_t, dst1, kMaxNumCoeffs);\n-  DECLARE_ALIGNED_ARRAY(16, uint8_t, dst2, kMaxNumCoeffs);\n+  DECLARE_ALIGNED(16, tran_low_t, test_coef_block1[kMaxNumCoeffs]);\n+  DECLARE_ALIGNED(16, tran_low_t, test_coef_block2[kMaxNumCoeffs]);\n+  DECLARE_ALIGNED(16, uint8_t, dst1[kMaxNumCoeffs]);\n+  DECLARE_ALIGNED(16, uint8_t, dst2[kMaxNumCoeffs]);\n   const int count_test_block = 1000;\n   const int max_coeff = 32766 / 4;\n   const int block_size = size * size;\n@@ -100,8 +183,8 @@\n\n     memcpy(test_coef_block2, test_coef_block1,\n            sizeof(*test_coef_block2) * block_size);\n \n-    REGISTER_STATE_CHECK(full_itxfm_(test_coef_block1, dst1, size));\n-    REGISTER_STATE_CHECK(partial_itxfm_(test_coef_block2, dst2, size));\n+    ASM_REGISTER_STATE_CHECK(full_itxfm_(test_coef_block1, dst1, size));\n+    ASM_REGISTER_STATE_CHECK(partial_itxfm_(test_coef_block2, dst2, size));\n \n     for (int j = 0; j < block_size; ++j) {\n       const int diff = dst1[j] - dst2[j];\n@@ -119,75 +202,142 @@\n\n INSTANTIATE_TEST_CASE_P(\n     C, PartialIDctTest,\n     ::testing::Values(\n-        make_tuple(&vp9_idct32x32_1024_add_c,\n-                   &vp9_idct32x32_34_add_c,\n+        make_tuple(&vpx_fdct32x32_c,\n+                   &vpx_idct32x32_1024_add_c,\n+                   &vpx_idct32x32_34_add_c,\n                    TX_32X32, 34),\n-        make_tuple(&vp9_idct32x32_1024_add_c,\n-                   &vp9_idct32x32_1_add_c,\n+        make_tuple(&vpx_fdct32x32_c,\n+                   &vpx_idct32x32_1024_add_c,\n+                   &vpx_idct32x32_1_add_c,\n                    TX_32X32, 1),\n-        make_tuple(&vp9_idct16x16_256_add_c,\n-                   &vp9_idct16x16_10_add_c,\n+        make_tuple(&vpx_fdct16x16_c,\n+                   &vpx_idct16x16_256_add_c,\n+                   &vpx_idct16x16_10_add_c,\n                    TX_16X16, 10),\n-        make_tuple(&vp9_idct16x16_256_add_c,\n-                   &vp9_idct16x16_1_add_c,\n+        make_tuple(&vpx_fdct16x16_c,\n+                   &vpx_idct16x16_256_add_c,\n+                   &vpx_idct16x16_1_add_c,\n                    TX_16X16, 1),\n-        make_tuple(&vp9_idct8x8_64_add_c,\n-                   &vp9_idct8x8_10_add_c,\n-                   TX_8X8, 10),\n-        make_tuple(&vp9_idct8x8_64_add_c,\n-                   &vp9_idct8x8_1_add_c,\n+        make_tuple(&vpx_fdct8x8_c,\n+                   &vpx_idct8x8_64_add_c,\n+                   &vpx_idct8x8_12_add_c,\n+                   TX_8X8, 12),\n+        make_tuple(&vpx_fdct8x8_c,\n+                   &vpx_idct8x8_64_add_c,\n+                   &vpx_idct8x8_1_add_c,\n                    TX_8X8, 1),\n-        make_tuple(&vp9_idct4x4_16_add_c,\n-                   &vp9_idct4x4_1_add_c,\n+        make_tuple(&vpx_fdct4x4_c,\n+                   &vpx_idct4x4_16_add_c,\n+                   &vpx_idct4x4_1_add_c,\n                    TX_4X4, 1)));\n-#if HAVE_NEON\n+\n+#if HAVE_NEON && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n INSTANTIATE_TEST_CASE_P(\n     NEON, PartialIDctTest,\n     ::testing::Values(\n-        make_tuple(&vp9_idct32x32_1024_add_c,\n-                   &vp9_idct32x32_1_add_neon,\n+        make_tuple(&vpx_fdct32x32_c,\n+                   &vpx_idct32x32_1024_add_c,\n+                   &vpx_idct32x32_1_add_neon,\n                    TX_32X32, 1),\n-        make_tuple(&vp9_idct16x16_256_add_c,\n-                   &vp9_idct16x16_10_add_neon,\n+        make_tuple(&vpx_fdct16x16_c,\n+                   &vpx_idct16x16_256_add_c,\n+                   &vpx_idct16x16_10_add_neon,\n                    TX_16X16, 10),\n-        make_tuple(&vp9_idct16x16_256_add_c,\n-                   &vp9_idct16x16_1_add_neon,\n+        make_tuple(&vpx_fdct16x16_c,\n+                   &vpx_idct16x16_256_add_c,\n+                   &vpx_idct16x16_1_add_neon,\n                    TX_16X16, 1),\n-        make_tuple(&vp9_idct8x8_64_add_c,\n-                   &vp9_idct8x8_10_add_neon,\n-                   TX_8X8, 10),\n-        make_tuple(&vp9_idct8x8_64_add_c,\n-                   &vp9_idct8x8_1_add_neon,\n+        make_tuple(&vpx_fdct8x8_c,\n+                   &vpx_idct8x8_64_add_c,\n+                   &vpx_idct8x8_12_add_neon,\n+                   TX_8X8, 12),\n+        make_tuple(&vpx_fdct8x8_c,\n+                   &vpx_idct8x8_64_add_c,\n+                   &vpx_idct8x8_1_add_neon,\n                    TX_8X8, 1),\n-        make_tuple(&vp9_idct4x4_16_add_c,\n-                   &vp9_idct4x4_1_add_neon,\n+        make_tuple(&vpx_fdct4x4_c,\n+                   &vpx_idct4x4_16_add_c,\n+                   &vpx_idct4x4_1_add_neon,\n                    TX_4X4, 1)));\n-#endif\n+#endif  // HAVE_NEON && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n \n-#if HAVE_SSE2\n+#if HAVE_SSE2 && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n INSTANTIATE_TEST_CASE_P(\n     SSE2, PartialIDctTest,\n     ::testing::Values(\n-        make_tuple(&vp9_idct32x32_1024_add_c,\n-                   &vp9_idct32x32_34_add_sse2,\n+        make_tuple(&vpx_fdct32x32_c,\n+                   &vpx_idct32x32_1024_add_c,\n+                   &vpx_idct32x32_34_add_sse2,\n                    TX_32X32, 34),\n-        make_tuple(&vp9_idct32x32_1024_add_c,\n-                   &vp9_idct32x32_1_add_sse2,\n+        make_tuple(&vpx_fdct32x32_c,\n+                   &vpx_idct32x32_1024_add_c,\n+                   &vpx_idct32x32_1_add_sse2,\n                    TX_32X32, 1),\n-        make_tuple(&vp9_idct16x16_256_add_c,\n-                   &vp9_idct16x16_10_add_sse2,\n+        make_tuple(&vpx_fdct16x16_c,\n+                   &vpx_idct16x16_256_add_c,\n+                   &vpx_idct16x16_10_add_sse2,\n                    TX_16X16, 10),\n-        make_tuple(&vp9_idct16x16_256_add_c,\n-                   &vp9_idct16x16_1_add_sse2,\n+        make_tuple(&vpx_fdct16x16_c,\n+                   &vpx_idct16x16_256_add_c,\n+                   &vpx_idct16x16_1_add_sse2,\n                    TX_16X16, 1),\n-        make_tuple(&vp9_idct8x8_64_add_c,\n-                   &vp9_idct8x8_10_add_sse2,\n-                   TX_8X8, 10),\n-        make_tuple(&vp9_idct8x8_64_add_c,\n-                   &vp9_idct8x8_1_add_sse2,\n+        make_tuple(&vpx_fdct8x8_c,\n+                   &vpx_idct8x8_64_add_c,\n+                   &vpx_idct8x8_12_add_sse2,\n+                   TX_8X8, 12),\n+        make_tuple(&vpx_fdct8x8_c,\n+                   &vpx_idct8x8_64_add_c,\n+                   &vpx_idct8x8_1_add_sse2,\n                    TX_8X8, 1),\n-        make_tuple(&vp9_idct4x4_16_add_c,\n-                   &vp9_idct4x4_1_add_sse2,\n+        make_tuple(&vpx_fdct4x4_c,\n+                   &vpx_idct4x4_16_add_c,\n+                   &vpx_idct4x4_1_add_sse2,\n                    TX_4X4, 1)));\n #endif\n+\n+#if HAVE_SSSE3 && CONFIG_USE_X86INC && ARCH_X86_64 && \\\n+    !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+INSTANTIATE_TEST_CASE_P(\n+    SSSE3_64, PartialIDctTest,\n+    ::testing::Values(\n+        make_tuple(&vpx_fdct8x8_c,\n+                   &vpx_idct8x8_64_add_c,\n+                   &vpx_idct8x8_12_add_ssse3,\n+                   TX_8X8, 12)));\n+#endif\n+\n+#if HAVE_MSA && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+INSTANTIATE_TEST_CASE_P(\n+    MSA, PartialIDctTest,\n+    ::testing::Values(\n+        make_tuple(&vpx_fdct32x32_c,\n+                   &vpx_idct32x32_1024_add_c,\n+                   &vpx_idct32x32_34_add_msa,\n+                   TX_32X32, 34),\n+        make_tuple(&vpx_fdct32x32_c,\n+                   &vpx_idct32x32_1024_add_c,\n+                   &vpx_idct32x32_1_add_msa,\n+                   TX_32X32, 1),\n+        make_tuple(&vpx_fdct16x16_c,\n+                   &vpx_idct16x16_256_add_c,\n+                   &vpx_idct16x16_10_add_msa,\n+                   TX_16X16, 10),\n+        make_tuple(&vpx_fdct16x16_c,\n+                   &vpx_idct16x16_256_add_c,\n+                   &vpx_idct16x16_1_add_msa,\n+                   TX_16X16, 1),\n+        make_tuple(&vpx_fdct8x8_c,\n+                   &vpx_idct8x8_64_add_c,\n+                   &vpx_idct8x8_12_add_msa,\n+                   TX_8X8, 10),\n+        make_tuple(&vpx_fdct8x8_c,\n+                   &vpx_idct8x8_64_add_c,\n+                   &vpx_idct8x8_1_add_msa,\n+                   TX_8X8, 1),\n+        make_tuple(&vpx_fdct4x4_c,\n+                   &vpx_idct4x4_16_add_c,\n+                   &vpx_idct4x4_1_add_msa,\n+                   TX_4X4, 1)));\n+#endif  // HAVE_MSA && !CONFIG_VP9_HIGHBITDEPTH && !CONFIG_EMULATE_HARDWARE\n+\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/postproc.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/postproc.sh"", ""patch"": ""@@ -0,0 +1,63 @@\n\n+#!/bin/sh\n+##\n+##  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+##\n+##  Use of this source code is governed by a BSD-style license\n+##  that can be found in the LICENSE file in the root of the source\n+##  tree. An additional intellectual property rights grant can be found\n+##  in the file PATENTS.  All contributing project authors may\n+##  be found in the AUTHORS file in the root of the source tree.\n+##\n+##  This file tests the libvpx postproc example code. To add new tests to this\n+##  file, do the following:\n+##    1. Write a shell function (this is your test).\n+##    2. Add the function to postproc_tests (on a new line).\n+##\n+. $(dirname $0)/tools_common.sh\n+\n+# Environment check: Make sure input is available:\n+#   $VP8_IVF_FILE and $VP9_IVF_FILE are required.\n+postproc_verify_environment() {\n+  if [ ! -e \""${VP8_IVF_FILE}\"" ] || [ ! -e \""${VP9_IVF_FILE}\"" ]; then\n+    echo \""Libvpx test data must exist in LIBVPX_TEST_DATA_PATH.\""\n+    return 1\n+  fi\n+}\n+\n+# Runs postproc using $1 as input file. $2 is the codec name, and is used\n+# solely to name the output file.\n+postproc() {\n+  local decoder=\""${LIBVPX_BIN_PATH}/postproc${VPX_TEST_EXE_SUFFIX}\""\n+  local input_file=\""$1\""\n+  local codec=\""$2\""\n+  local output_file=\""${VPX_TEST_OUTPUT_DIR}/postproc_${codec}.raw\""\n+\n+  if [ ! -x \""${decoder}\"" ]; then\n+    elog \""${decoder} does not exist or is not executable.\""\n+    return 1\n+  fi\n+\n+  eval \""${VPX_TEST_PREFIX}\"" \""${decoder}\"" \""${input_file}\"" \""${output_file}\"" \\\n+      ${devnull}\n+\n+  [ -e \""${output_file}\"" ] || return 1\n+}\n+\n+postproc_vp8() {\n+  if [ \""$(vp8_decode_available)\"" = \""yes\"" ]; then\n+    postproc \""${VP8_IVF_FILE}\"" vp8 || return 1\n+  fi\n+}\n+\n+postproc_vp9() {\n+  if [ \""$(vpx_config_option_enabled CONFIG_VP9_POSTPROC)\"" = \""yes\"" ]; then\n+    if [ \""$(vp9_decode_available)\"" = \""yes\"" ]; then\n+      postproc \""${VP9_IVF_FILE}\"" vp9 || return 1\n+    fi\n+  fi\n+}\n+\n+postproc_tests=\""postproc_vp8\n+                postproc_vp9\""\n+\n+run_tests postproc_verify_environment \""${postproc_tests}\""\n""}<_**next**_>{""filename"": ""libvpx/test/pp_filter_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/pp_filter_test.cc"", ""patch"": ""@@ -15,18 +15,18 @@\n\n #include \""vpx/vpx_integer.h\""\n #include \""vpx_mem/vpx_mem.h\""\n \n-typedef void (*post_proc_func_t)(unsigned char *src_ptr,\n-                                 unsigned char *dst_ptr,\n-                                 int src_pixels_per_line,\n-                                 int dst_pixels_per_line,\n-                                 int cols,\n-                                 unsigned char *flimit,\n-                                 int size);\n+typedef void (*PostProcFunc)(unsigned char *src_ptr,\n+                             unsigned char *dst_ptr,\n+                             int src_pixels_per_line,\n+                             int dst_pixels_per_line,\n+                             int cols,\n+                             unsigned char *flimit,\n+                             int size);\n \n namespace {\n \n class VP8PostProcessingFilterTest\n-    : public ::testing::TestWithParam<post_proc_func_t> {\n+    : public ::testing::TestWithParam<PostProcFunc> {\n  public:\n   virtual void TearDown() {\n     libvpx_test::ClearSystemState();\n@@ -63,12 +63,12 @@\n\n   uint8_t *const dst_image_ptr = dst_image + 8;\n   uint8_t *const flimits =\n       reinterpret_cast<uint8_t *>(vpx_memalign(16, block_width));\n-  (void)vpx_memset(flimits, 255, block_width);\n+  (void)memset(flimits, 255, block_width);\n \n   // Initialize pixels in the input:\n   //   block pixels to value 1,\n   //   border pixels to value 10.\n-  (void)vpx_memset(src_image, 10, input_size);\n+  (void)memset(src_image, 10, input_size);\n   uint8_t *pixel_ptr = src_image_ptr;\n   for (int i = 0; i < block_height; ++i) {\n     for (int j = 0; j < block_width; ++j) {\n@@ -78,10 +78,11 @@\n\n   }\n \n   // Initialize pixels in the output to 99.\n-  (void)vpx_memset(dst_image, 99, output_size);\n+  (void)memset(dst_image, 99, output_size);\n \n-  REGISTER_STATE_CHECK(GetParam()(src_image_ptr, dst_image_ptr, input_stride,\n-                                  output_stride, block_width, flimits, 16));\n+  ASM_REGISTER_STATE_CHECK(\n+      GetParam()(src_image_ptr, dst_image_ptr, input_stride,\n+                 output_stride, block_width, flimits, 16));\n \n   static const uint8_t expected_data[block_height] = {\n     4, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 4\n@@ -109,4 +110,9 @@\n\n     ::testing::Values(vp8_post_proc_down_and_across_mb_row_sse2));\n #endif\n \n+#if HAVE_MSA\n+INSTANTIATE_TEST_CASE_P(MSA, VP8PostProcessingFilterTest,\n+    ::testing::Values(vp8_post_proc_down_and_across_mb_row_msa));\n+#endif\n+\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/quantize_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/quantize_test.cc"", ""patch"": ""@@ -0,0 +1,203 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <string.h>\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vpx_config.h\""\n+#include \""./vp8_rtcd.h\""\n+#include \""test/acm_random.h\""\n+#include \""test/clear_system_state.h\""\n+#include \""test/register_state_check.h\""\n+#include \""test/util.h\""\n+#include \""vp8/common/blockd.h\""\n+#include \""vp8/common/onyx.h\""\n+#include \""vp8/encoder/block.h\""\n+#include \""vp8/encoder/onyx_int.h\""\n+#include \""vp8/encoder/quantize.h\""\n+#include \""vpx/vpx_integer.h\""\n+#include \""vpx_mem/vpx_mem.h\""\n+\n+namespace {\n+\n+const int kNumBlocks = 25;\n+const int kNumBlockEntries = 16;\n+\n+typedef void (*VP8Quantize)(BLOCK *b, BLOCKD *d);\n+\n+typedef std::tr1::tuple<VP8Quantize, VP8Quantize> VP8QuantizeParam;\n+\n+using libvpx_test::ACMRandom;\n+using std::tr1::make_tuple;\n+\n+// Create and populate a VP8_COMP instance which has a complete set of\n+// quantization inputs as well as a second MACROBLOCKD for output.\n+class QuantizeTestBase {\n+ public:\n+  virtual ~QuantizeTestBase() {\n+    vp8_remove_compressor(&vp8_comp_);\n+    vp8_comp_ = NULL;\n+    vpx_free(macroblockd_dst_);\n+    macroblockd_dst_ = NULL;\n+    libvpx_test::ClearSystemState();\n+  }\n+\n+ protected:\n+  void SetupCompressor() {\n+    rnd_.Reset(ACMRandom::DeterministicSeed());\n+\n+    // The full configuration is necessary to generate the quantization tables.\n+    VP8_CONFIG vp8_config;\n+    memset(&vp8_config, 0, sizeof(vp8_config));\n+\n+    vp8_comp_ = vp8_create_compressor(&vp8_config);\n+\n+    // Set the tables based on a quantizer of 0.\n+    vp8_set_quantizer(vp8_comp_, 0);\n+\n+    // Set up all the block/blockd pointers for the mb in vp8_comp_.\n+    vp8cx_frame_init_quantizer(vp8_comp_);\n+\n+    // Copy macroblockd from the reference to get pre-set-up dequant values.\n+    macroblockd_dst_ = reinterpret_cast<MACROBLOCKD *>(\n+        vpx_memalign(32, sizeof(*macroblockd_dst_)));\n+    memcpy(macroblockd_dst_, &vp8_comp_->mb.e_mbd, sizeof(*macroblockd_dst_));\n+    // Fix block pointers - currently they point to the blocks in the reference\n+    // structure.\n+    vp8_setup_block_dptrs(macroblockd_dst_);\n+  }\n+\n+  void UpdateQuantizer(int q) {\n+    vp8_set_quantizer(vp8_comp_, q);\n+\n+    memcpy(macroblockd_dst_, &vp8_comp_->mb.e_mbd, sizeof(*macroblockd_dst_));\n+    vp8_setup_block_dptrs(macroblockd_dst_);\n+  }\n+\n+  void FillCoeffConstant(int16_t c) {\n+    for (int i = 0; i < kNumBlocks * kNumBlockEntries; ++i) {\n+      vp8_comp_->mb.coeff[i] = c;\n+    }\n+  }\n+\n+  void FillCoeffRandom() {\n+    for (int i = 0; i < kNumBlocks * kNumBlockEntries; ++i) {\n+      vp8_comp_->mb.coeff[i] = rnd_.Rand8();\n+    }\n+  }\n+\n+  void CheckOutput() {\n+    EXPECT_EQ(0, memcmp(vp8_comp_->mb.e_mbd.qcoeff, macroblockd_dst_->qcoeff,\n+                        sizeof(*macroblockd_dst_->qcoeff) * kNumBlocks *\n+                            kNumBlockEntries))\n+        << \""qcoeff mismatch\"";\n+    EXPECT_EQ(0, memcmp(vp8_comp_->mb.e_mbd.dqcoeff, macroblockd_dst_->dqcoeff,\n+                        sizeof(*macroblockd_dst_->dqcoeff) * kNumBlocks *\n+                            kNumBlockEntries))\n+        << \""dqcoeff mismatch\"";\n+    EXPECT_EQ(0, memcmp(vp8_comp_->mb.e_mbd.eobs, macroblockd_dst_->eobs,\n+                        sizeof(*macroblockd_dst_->eobs) * kNumBlocks))\n+        << \""eobs mismatch\"";\n+  }\n+\n+  VP8_COMP *vp8_comp_;\n+  MACROBLOCKD *macroblockd_dst_;\n+\n+ private:\n+  ACMRandom rnd_;\n+};\n+\n+class QuantizeTest : public QuantizeTestBase,\n+                     public ::testing::TestWithParam<VP8QuantizeParam> {\n+ protected:\n+  virtual void SetUp() {\n+    SetupCompressor();\n+    asm_quant_ = GET_PARAM(0);\n+    c_quant_ = GET_PARAM(1);\n+  }\n+\n+  void RunComparison() {\n+    for (int i = 0; i < kNumBlocks; ++i) {\n+      ASM_REGISTER_STATE_CHECK(\n+          c_quant_(&vp8_comp_->mb.block[i], &vp8_comp_->mb.e_mbd.block[i]));\n+      ASM_REGISTER_STATE_CHECK(\n+          asm_quant_(&vp8_comp_->mb.block[i], &macroblockd_dst_->block[i]));\n+    }\n+\n+    CheckOutput();\n+  }\n+\n+ private:\n+  VP8Quantize asm_quant_;\n+  VP8Quantize c_quant_;\n+};\n+\n+TEST_P(QuantizeTest, TestZeroInput) {\n+  FillCoeffConstant(0);\n+  RunComparison();\n+}\n+\n+TEST_P(QuantizeTest, TestLargeNegativeInput) {\n+  FillCoeffConstant(0);\n+  // Generate a qcoeff which contains 512/-512 (0x0100/0xFE00) to catch issues\n+  // like BUG=883 where the constant being compared was incorrectly initialized.\n+  vp8_comp_->mb.coeff[0] = -8191;\n+  RunComparison();\n+}\n+\n+TEST_P(QuantizeTest, TestRandomInput) {\n+  FillCoeffRandom();\n+  RunComparison();\n+}\n+\n+TEST_P(QuantizeTest, TestMultipleQ) {\n+  for (int q = 0; q < QINDEX_RANGE; ++q) {\n+    UpdateQuantizer(q);\n+    FillCoeffRandom();\n+    RunComparison();\n+  }\n+}\n+\n+#if HAVE_SSE2\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, QuantizeTest,\n+    ::testing::Values(\n+        make_tuple(&vp8_fast_quantize_b_sse2, &vp8_fast_quantize_b_c),\n+        make_tuple(&vp8_regular_quantize_b_sse2, &vp8_regular_quantize_b_c)));\n+#endif  // HAVE_SSE2\n+\n+#if HAVE_SSSE3\n+INSTANTIATE_TEST_CASE_P(SSSE3, QuantizeTest,\n+                        ::testing::Values(make_tuple(&vp8_fast_quantize_b_ssse3,\n+                                                     &vp8_fast_quantize_b_c)));\n+#endif  // HAVE_SSSE3\n+\n+#if HAVE_SSE4_1\n+INSTANTIATE_TEST_CASE_P(\n+    SSE4_1, QuantizeTest,\n+    ::testing::Values(make_tuple(&vp8_regular_quantize_b_sse4_1,\n+                                 &vp8_regular_quantize_b_c)));\n+#endif  // HAVE_SSE4_1\n+\n+#if HAVE_NEON\n+INSTANTIATE_TEST_CASE_P(NEON, QuantizeTest,\n+                        ::testing::Values(make_tuple(&vp8_fast_quantize_b_neon,\n+                                                     &vp8_fast_quantize_b_c)));\n+#endif  // HAVE_NEON\n+\n+#if HAVE_MSA\n+INSTANTIATE_TEST_CASE_P(\n+    MSA, QuantizeTest,\n+    ::testing::Values(\n+        make_tuple(&vp8_fast_quantize_b_msa, &vp8_fast_quantize_b_c),\n+        make_tuple(&vp8_regular_quantize_b_msa, &vp8_regular_quantize_b_c)));\n+#endif  // HAVE_MSA\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/register_state_check.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/register_state_check.h"", ""patch"": ""@@ -13,6 +13,20 @@\n\n \n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n #include \""./vpx_config.h\""\n+#include \""vpx/vpx_integer.h\""\n+\n+// ASM_REGISTER_STATE_CHECK(asm_function)\n+//   Minimally validates the environment pre & post function execution. This\n+//   variant should be used with assembly functions which are not expected to\n+//   fully restore the system state. See platform implementations of\n+//   RegisterStateCheck for details.\n+//\n+// API_REGISTER_STATE_CHECK(api_function)\n+//   Performs all the checks done by ASM_REGISTER_STATE_CHECK() and any\n+//   additional checks to ensure the environment is in a consistent state pre &\n+//   post function execution. This variant should be used with API functions.\n+//   See platform implementations of RegisterStateCheckXXX for details.\n+//\n \n #if defined(_WIN64)\n \n@@ -35,11 +49,6 @@\n\n // Compares the state of xmm[6-15] at construction with their state at\n // destruction. These registers should be preserved by the callee on\n // Windows x64.\n-// Usage:\n-// {\n-//   RegisterStateCheck reg_check;\n-//   FunctionToVerify();\n-// }\n class RegisterStateCheck {\n  public:\n   RegisterStateCheck() { initialized_ = StoreRegisters(&pre_context_); }\n@@ -75,21 +84,19 @@\n\n   CONTEXT pre_context_;\n };\n \n-#define REGISTER_STATE_CHECK(statement) do { \\\n-  libvpx_test::RegisterStateCheck reg_check; \\\n-  statement;                               \\\n+#define ASM_REGISTER_STATE_CHECK(statement) do {  \\\n+  libvpx_test::RegisterStateCheck reg_check;      \\\n+  statement;                                      \\\n } while (false)\n \n }  // namespace libvpx_test\n \n-#elif defined(CONFIG_SHARED) && defined(HAVE_NEON) \\\n-      && !CONFIG_SHARED && HAVE_NEON\n-\n-#include \""vpx/vpx_integer.h\""\n+#elif defined(CONFIG_SHARED) && defined(HAVE_NEON_ASM) && defined(CONFIG_VP9) \\\n+      && !CONFIG_SHARED && HAVE_NEON_ASM && CONFIG_VP9\n \n extern \""C\"" {\n // Save the d8-d15 registers into store.\n-void vp9_push_neon(int64_t *store);\n+void vpx_push_neon(int64_t *store);\n }\n \n namespace libvpx_test {\n@@ -97,11 +104,6 @@\n\n // Compares the state of d8-d15 at construction with their state at\n // destruction. These registers should be preserved by the callee on\n // arm platform.\n-// Usage:\n-// {\n-//   RegisterStateCheck reg_check;\n-//   FunctionToVerify();\n-// }\n class RegisterStateCheck {\n  public:\n   RegisterStateCheck() { initialized_ = StoreRegisters(pre_store_); }\n@@ -109,7 +111,7 @@\n\n \n  private:\n   static bool StoreRegisters(int64_t store[8]) {\n-    vp9_push_neon(store);\n+    vpx_push_neon(store);\n     return true;\n   }\n \n@@ -117,7 +119,7 @@\n\n   bool Check() const {\n     if (!initialized_) return false;\n     int64_t post_store[8];\n-    vp9_push_neon(post_store);\n+    vpx_push_neon(post_store);\n     for (int i = 0; i < 8; ++i) {\n       EXPECT_EQ(pre_store_[i], post_store[i]) << \""d\""\n           << i + 8 << \"" has been modified\"";\n@@ -129,9 +131,9 @@\n\n   int64_t pre_store_[8];\n };\n \n-#define REGISTER_STATE_CHECK(statement) do { \\\n-  libvpx_test::RegisterStateCheck reg_check; \\\n-  statement;                               \\\n+#define ASM_REGISTER_STATE_CHECK(statement) do {  \\\n+  libvpx_test::RegisterStateCheck reg_check;      \\\n+  statement;                                      \\\n } while (false)\n \n }  // namespace libvpx_test\n@@ -141,10 +143,54 @@\n\n namespace libvpx_test {\n \n class RegisterStateCheck {};\n-#define REGISTER_STATE_CHECK(statement) statement\n+#define ASM_REGISTER_STATE_CHECK(statement) statement\n \n }  // namespace libvpx_test\n \n #endif  // _WIN64\n \n+#if ARCH_X86 || ARCH_X86_64\n+#if defined(__GNUC__)\n+\n+namespace libvpx_test {\n+\n+// Checks the FPU tag word pre/post execution to ensure emms has been called.\n+class RegisterStateCheckMMX {\n+ public:\n+  RegisterStateCheckMMX() {\n+    __asm__ volatile(\""fstenv %0\"" : \""=rm\""(pre_fpu_env_));\n+  }\n+  ~RegisterStateCheckMMX() { EXPECT_TRUE(Check()); }\n+\n+ private:\n+  // Checks the FPU tag word pre/post execution, returning false if not cleared\n+  // to 0xffff.\n+  bool Check() const {\n+    EXPECT_EQ(0xffff, pre_fpu_env_[4])\n+        << \""FPU was in an inconsistent state prior to call\"";\n+\n+    uint16_t post_fpu_env[14];\n+    __asm__ volatile(\""fstenv %0\"" : \""=rm\""(post_fpu_env));\n+    EXPECT_EQ(0xffff, post_fpu_env[4])\n+        << \""FPU was left in an inconsistent state after call\"";\n+    return !testing::Test::HasNonfatalFailure();\n+  }\n+\n+  uint16_t pre_fpu_env_[14];\n+};\n+\n+#define API_REGISTER_STATE_CHECK(statement) do {  \\\n+  libvpx_test::RegisterStateCheckMMX reg_check;   \\\n+  ASM_REGISTER_STATE_CHECK(statement);            \\\n+} while (false)\n+\n+}  // namespace libvpx_test\n+\n+#endif  // __GNUC__\n+#endif  // ARCH_X86 || ARCH_X86_64\n+\n+#ifndef API_REGISTER_STATE_CHECK\n+#define API_REGISTER_STATE_CHECK ASM_REGISTER_STATE_CHECK\n+#endif\n+\n #endif  // TEST_REGISTER_STATE_CHECK_H_\n""}<_**next**_>{""filename"": ""libvpx/test/resize_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/resize_test.cc"", ""patch"": ""@@ -144,6 +144,7 @@\n\n \n TEST_P(ResizeTest, TestExternalResizeWorks) {\n   ResizingVideoSource video;\n+  cfg_.g_lag_in_frames = 0;\n   ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n \n   for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n@@ -153,9 +154,9 @@\n\n     const unsigned int expected_h = ScaleForFrameNumber(frame, kInitialHeight);\n \n     EXPECT_EQ(expected_w, info->w)\n-        << \""Frame \"" << frame << \""had unexpected width\"";\n+        << \""Frame \"" << frame << \"" had unexpected width\"";\n     EXPECT_EQ(expected_h, info->h)\n-        << \""Frame \"" << frame << \""had unexpected height\"";\n+        << \""Frame \"" << frame << \"" had unexpected height\"";\n   }\n }\n \n@@ -211,8 +212,8 @@\n\n     EXPECT_NEAR(pkt->data.psnr.psnr[0], frame0_psnr_, 2.0);\n   }\n \n-  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n #if WRITE_COMPRESSED_STREAM\n+  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n     ++out_frames_;\n \n     // Write initial file header if first frame.\n@@ -222,8 +223,8 @@\n\n     // Write frame header and data.\n     write_ivf_frame_header(pkt, outfile_);\n     (void)fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_);\n-#endif\n   }\n+#endif\n \n   double frame0_psnr_;\n #if WRITE_COMPRESSED_STREAM\n@@ -260,7 +261,116 @@\n\n   }\n }\n \n+vpx_img_fmt_t CspForFrameNumber(int frame) {\n+  if (frame < 10)\n+    return VPX_IMG_FMT_I420;\n+  if (frame < 20)\n+    return VPX_IMG_FMT_I444;\n+  return VPX_IMG_FMT_I420;\n+}\n+\n+class ResizeCspTest : public ResizeTest {\n+ protected:\n+#if WRITE_COMPRESSED_STREAM\n+  ResizeCspTest()\n+      : ResizeTest(),\n+        frame0_psnr_(0.0),\n+        outfile_(NULL),\n+        out_frames_(0) {}\n+#else\n+  ResizeCspTest() : ResizeTest(), frame0_psnr_(0.0) {}\n+#endif\n+\n+  virtual ~ResizeCspTest() {}\n+\n+  virtual void BeginPassHook(unsigned int /*pass*/) {\n+#if WRITE_COMPRESSED_STREAM\n+    outfile_ = fopen(\""vp91-2-05-cspchape.ivf\"", \""wb\"");\n+#endif\n+  }\n+\n+  virtual void EndPassHook() {\n+#if WRITE_COMPRESSED_STREAM\n+    if (outfile_) {\n+      if (!fseek(outfile_, 0, SEEK_SET))\n+        write_ivf_file_header(&cfg_, out_frames_, outfile_);\n+      fclose(outfile_);\n+      outfile_ = NULL;\n+    }\n+#endif\n+  }\n+\n+  virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n+                                  libvpx_test::Encoder *encoder) {\n+    if (CspForFrameNumber(video->frame()) != VPX_IMG_FMT_I420 &&\n+        cfg_.g_profile != 1) {\n+      cfg_.g_profile = 1;\n+      encoder->Config(&cfg_);\n+    }\n+    if (CspForFrameNumber(video->frame()) == VPX_IMG_FMT_I420 &&\n+        cfg_.g_profile != 0) {\n+      cfg_.g_profile = 0;\n+      encoder->Config(&cfg_);\n+    }\n+  }\n+\n+  virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n+    if (!frame0_psnr_)\n+      frame0_psnr_ = pkt->data.psnr.psnr[0];\n+    EXPECT_NEAR(pkt->data.psnr.psnr[0], frame0_psnr_, 2.0);\n+  }\n+\n+#if WRITE_COMPRESSED_STREAM\n+  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n+    ++out_frames_;\n+\n+    // Write initial file header if first frame.\n+    if (pkt->data.frame.pts == 0)\n+      write_ivf_file_header(&cfg_, 0, outfile_);\n+\n+    // Write frame header and data.\n+    write_ivf_frame_header(pkt, outfile_);\n+    (void)fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_);\n+  }\n+#endif\n+\n+  double frame0_psnr_;\n+#if WRITE_COMPRESSED_STREAM\n+  FILE *outfile_;\n+  unsigned int out_frames_;\n+#endif\n+};\n+\n+class ResizingCspVideoSource : public ::libvpx_test::DummyVideoSource {\n+ public:\n+  ResizingCspVideoSource() {\n+    SetSize(kInitialWidth, kInitialHeight);\n+    limit_ = 30;\n+  }\n+\n+  virtual ~ResizingCspVideoSource() {}\n+\n+ protected:\n+  virtual void Next() {\n+    ++frame_;\n+    SetImageFormat(CspForFrameNumber(frame_));\n+    FillFrame();\n+  }\n+};\n+\n+TEST_P(ResizeCspTest, TestResizeCspWorks) {\n+  ResizingCspVideoSource video;\n+  init_flags_ = VPX_CODEC_USE_PSNR;\n+  cfg_.rc_min_quantizer = cfg_.rc_max_quantizer = 48;\n+  cfg_.g_lag_in_frames = 0;\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+}\n+\n VP8_INSTANTIATE_TEST_CASE(ResizeTest, ONE_PASS_TEST_MODES);\n+VP9_INSTANTIATE_TEST_CASE(ResizeTest,\n+                          ::testing::Values(::libvpx_test::kRealTime));\n VP9_INSTANTIATE_TEST_CASE(ResizeInternalTest,\n                           ::testing::Values(::libvpx_test::kOnePassBest));\n+VP9_INSTANTIATE_TEST_CASE(ResizeCspTest,\n+                          ::testing::Values(::libvpx_test::kRealTime));\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/resize_util.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/resize_util.sh"", ""patch"": ""@@ -0,0 +1,69 @@\n\n+#!/bin/sh\n+##\n+##  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+##\n+##  Use of this source code is governed by a BSD-style license\n+##  that can be found in the LICENSE file in the root of the source\n+##  tree. An additional intellectual property rights grant can be found\n+##  in the file PATENTS.  All contributing project authors may\n+##  be found in the AUTHORS file in the root of the source tree.\n+##\n+##  This file tests the libvpx resize_util example code. To add new tests to\n+##  this file, do the following:\n+##    1. Write a shell function (this is your test).\n+##    2. Add the function to resize_util_tests (on a new line).\n+##\n+. $(dirname $0)/tools_common.sh\n+\n+# Environment check: $YUV_RAW_INPUT is required.\n+resize_util_verify_environment() {\n+  if [ ! -e \""${YUV_RAW_INPUT}\"" ]; then\n+    echo \""Libvpx test data must exist in LIBVPX_TEST_DATA_PATH.\""\n+    return 1\n+  fi\n+}\n+\n+# Resizes $YUV_RAW_INPUT using the resize_util example. $1 is the output\n+# dimensions that will be passed to resize_util.\n+resize_util() {\n+  local resizer=\""${LIBVPX_BIN_PATH}/resize_util${VPX_TEST_EXE_SUFFIX}\""\n+  local output_file=\""${VPX_TEST_OUTPUT_DIR}/resize_util.raw\""\n+  local frames_to_resize=\""10\""\n+  local target_dimensions=\""$1\""\n+\n+  # resize_util is available only when CONFIG_SHARED is disabled.\n+  if [ -z \""$(vpx_config_option_enabled CONFIG_SHARED)\"" ]; then\n+    if [ ! -x \""${resizer}\"" ]; then\n+      elog \""${resizer} does not exist or is not executable.\""\n+      return 1\n+    fi\n+\n+    eval \""${VPX_TEST_PREFIX}\"" \""${resizer}\"" \""${YUV_RAW_INPUT}\"" \\\n+        \""${YUV_RAW_INPUT_WIDTH}x${YUV_RAW_INPUT_HEIGHT}\"" \\\n+        \""${target_dimensions}\"" \""${output_file}\"" ${frames_to_resize} \\\n+        ${devnull}\n+\n+    [ -e \""${output_file}\"" ] || return 1\n+  fi\n+}\n+\n+# Halves each dimension of $YUV_RAW_INPUT using resize_util().\n+resize_down() {\n+  local target_width=$((${YUV_RAW_INPUT_WIDTH} / 2))\n+  local target_height=$((${YUV_RAW_INPUT_HEIGHT} / 2))\n+\n+  resize_util \""${target_width}x${target_height}\""\n+}\n+\n+# Doubles each dimension of $YUV_RAW_INPUT using resize_util().\n+resize_up() {\n+  local target_width=$((${YUV_RAW_INPUT_WIDTH} * 2))\n+  local target_height=$((${YUV_RAW_INPUT_HEIGHT} * 2))\n+\n+  resize_util \""${target_width}x${target_height}\""\n+}\n+\n+resize_util_tests=\""resize_down\n+                   resize_up\""\n+\n+run_tests resize_util_verify_environment \""${resize_util_tests}\""\n""}<_**next**_>{""filename"": ""libvpx/test/sad_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/sad_test.cc"", ""patch"": ""@@ -13,56 +13,74 @@\n\n #include <limits.h>\n #include <stdio.h>\n \n-#include \""./vpx_config.h\""\n-#if CONFIG_VP8_ENCODER\n-#include \""./vp8_rtcd.h\""\n-#endif\n-#if CONFIG_VP9_ENCODER\n-#include \""./vp9_rtcd.h\""\n-#endif\n-#include \""vpx_mem/vpx_mem.h\""\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n \n+#include \""./vpx_config.h\""\n+#include \""./vpx_dsp_rtcd.h\""\n #include \""test/acm_random.h\""\n #include \""test/clear_system_state.h\""\n #include \""test/register_state_check.h\""\n #include \""test/util.h\""\n-#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+#include \""vpx/vpx_codec.h\""\n+#include \""vpx_mem/vpx_mem.h\""\n+#include \""vpx_ports/mem.h\""\n \n+typedef unsigned int (*SadMxNFunc)(const uint8_t *src_ptr,\n+                                   int src_stride,\n+                                   const uint8_t *ref_ptr,\n+                                   int ref_stride);\n+typedef std::tr1::tuple<int, int, SadMxNFunc, int> SadMxNParam;\n \n-typedef unsigned int (*sad_m_by_n_fn_t)(const unsigned char *source_ptr,\n-                                        int source_stride,\n-                                        const unsigned char *reference_ptr,\n-                                        int reference_stride,\n-                                        unsigned int max_sad);\n-typedef std::tr1::tuple<int, int, sad_m_by_n_fn_t> sad_m_by_n_test_param_t;\n+typedef uint32_t (*SadMxNAvgFunc)(const uint8_t *src_ptr,\n+                                  int src_stride,\n+                                  const uint8_t *ref_ptr,\n+                                  int ref_stride,\n+                                  const uint8_t *second_pred);\n+typedef std::tr1::tuple<int, int, SadMxNAvgFunc, int> SadMxNAvgParam;\n \n-typedef void (*sad_n_by_n_by_4_fn_t)(const uint8_t *src_ptr,\n-                                     int src_stride,\n-                                     const unsigned char * const ref_ptr[],\n-                                     int ref_stride,\n-                                     unsigned int *sad_array);\n-typedef std::tr1::tuple<int, int, sad_n_by_n_by_4_fn_t>\n-        sad_n_by_n_by_4_test_param_t;\n+typedef void (*SadMxNx4Func)(const uint8_t *src_ptr,\n+                             int src_stride,\n+                             const uint8_t *const ref_ptr[],\n+                             int ref_stride,\n+                             uint32_t *sad_array);\n+typedef std::tr1::tuple<int, int, SadMxNx4Func, int> SadMxNx4Param;\n \n using libvpx_test::ACMRandom;\n \n namespace {\n class SADTestBase : public ::testing::Test {\n  public:\n-  SADTestBase(int width, int height) : width_(width), height_(height) {}\n+  SADTestBase(int width, int height, int bit_depth) :\n+      width_(width), height_(height), bd_(bit_depth) {}\n \n   static void SetUpTestCase() {\n-    source_data_ = reinterpret_cast<uint8_t*>(\n+    source_data8_ = reinterpret_cast<uint8_t*>(\n         vpx_memalign(kDataAlignment, kDataBlockSize));\n-    reference_data_ = reinterpret_cast<uint8_t*>(\n+    reference_data8_ = reinterpret_cast<uint8_t*>(\n         vpx_memalign(kDataAlignment, kDataBufferSize));\n+    second_pred8_ = reinterpret_cast<uint8_t*>(\n+        vpx_memalign(kDataAlignment, 64*64));\n+    source_data16_ = reinterpret_cast<uint16_t*>(\n+        vpx_memalign(kDataAlignment, kDataBlockSize*sizeof(uint16_t)));\n+    reference_data16_ = reinterpret_cast<uint16_t*>(\n+        vpx_memalign(kDataAlignment, kDataBufferSize*sizeof(uint16_t)));\n+    second_pred16_ = reinterpret_cast<uint16_t*>(\n+        vpx_memalign(kDataAlignment, 64*64*sizeof(uint16_t)));\n   }\n \n   static void TearDownTestCase() {\n-    vpx_free(source_data_);\n-    source_data_ = NULL;\n-    vpx_free(reference_data_);\n-    reference_data_ = NULL;\n+    vpx_free(source_data8_);\n+    source_data8_ = NULL;\n+    vpx_free(reference_data8_);\n+    reference_data8_ = NULL;\n+    vpx_free(second_pred8_);\n+    second_pred8_ = NULL;\n+    vpx_free(source_data16_);\n+    source_data16_ = NULL;\n+    vpx_free(reference_data16_);\n+    reference_data16_ = NULL;\n+    vpx_free(second_pred16_);\n+    second_pred16_ = NULL;\n   }\n \n   virtual void TearDown() {\n@@ -76,142 +94,335 @@\n\n   static const int kDataBufferSize = 4 * kDataBlockSize;\n \n   virtual void SetUp() {\n+    if (bd_ == -1) {\n+      use_high_bit_depth_ = false;\n+      bit_depth_ = VPX_BITS_8;\n+      source_data_ = source_data8_;\n+      reference_data_ = reference_data8_;\n+      second_pred_ = second_pred8_;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    } else {\n+      use_high_bit_depth_ = true;\n+      bit_depth_ = static_cast<vpx_bit_depth_t>(bd_);\n+      source_data_ = CONVERT_TO_BYTEPTR(source_data16_);\n+      reference_data_ = CONVERT_TO_BYTEPTR(reference_data16_);\n+      second_pred_ = CONVERT_TO_BYTEPTR(second_pred16_);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+    }\n+    mask_ = (1 << bit_depth_) - 1;\n     source_stride_ = (width_ + 31) & ~31;\n     reference_stride_ = width_ * 2;\n     rnd_.Reset(ACMRandom::DeterministicSeed());\n   }\n \n-  virtual uint8_t* GetReference(int block_idx) {\n+  virtual uint8_t *GetReference(int block_idx) {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    if (use_high_bit_depth_)\n+      return CONVERT_TO_BYTEPTR(CONVERT_TO_SHORTPTR(reference_data_) +\n+                                block_idx * kDataBlockSize);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n     return reference_data_ + block_idx * kDataBlockSize;\n   }\n \n   // Sum of Absolute Differences. Given two blocks, calculate the absolute\n   // difference between two pixels in the same relative location; accumulate.\n-  unsigned int ReferenceSAD(unsigned int max_sad, int block_idx = 0) {\n+  unsigned int ReferenceSAD(int block_idx) {\n     unsigned int sad = 0;\n-    const uint8_t* const reference = GetReference(block_idx);\n-\n+      const uint8_t *const reference8 = GetReference(block_idx);\n+      const uint8_t *const source8 = source_data_;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      const uint16_t *const reference16 =\n+          CONVERT_TO_SHORTPTR(GetReference(block_idx));\n+      const uint16_t *const source16 = CONVERT_TO_SHORTPTR(source_data_);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n     for (int h = 0; h < height_; ++h) {\n       for (int w = 0; w < width_; ++w) {\n-        sad += abs(source_data_[h * source_stride_ + w]\n-               - reference[h * reference_stride_ + w]);\n-      }\n-      if (sad > max_sad) {\n-        break;\n+        if (!use_high_bit_depth_) {\n+          sad += abs(source8[h * source_stride_ + w] -\n+                     reference8[h * reference_stride_ + w]);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        } else {\n+          sad += abs(source16[h * source_stride_ + w] -\n+                     reference16[h * reference_stride_ + w]);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+        }\n       }\n     }\n     return sad;\n   }\n \n-  void FillConstant(uint8_t *data, int stride, uint8_t fill_constant) {\n+  // Sum of Absolute Differences Average. Given two blocks, and a prediction\n+  // calculate the absolute difference between one pixel and average of the\n+  // corresponding and predicted pixels; accumulate.\n+  unsigned int ReferenceSADavg(int block_idx) {\n+    unsigned int sad = 0;\n+    const uint8_t *const reference8 = GetReference(block_idx);\n+    const uint8_t *const source8 = source_data_;\n+    const uint8_t *const second_pred8 = second_pred_;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    const uint16_t *const reference16 =\n+        CONVERT_TO_SHORTPTR(GetReference(block_idx));\n+    const uint16_t *const source16 = CONVERT_TO_SHORTPTR(source_data_);\n+    const uint16_t *const second_pred16 = CONVERT_TO_SHORTPTR(second_pred_);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n     for (int h = 0; h < height_; ++h) {\n       for (int w = 0; w < width_; ++w) {\n-        data[h * stride + w] = fill_constant;\n+        if (!use_high_bit_depth_) {\n+          const int tmp = second_pred8[h * width_ + w] +\n+              reference8[h * reference_stride_ + w];\n+          const uint8_t comp_pred = ROUND_POWER_OF_TWO(tmp, 1);\n+          sad += abs(source8[h * source_stride_ + w] - comp_pred);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        } else {\n+          const int tmp = second_pred16[h * width_ + w] +\n+              reference16[h * reference_stride_ + w];\n+          const uint16_t comp_pred = ROUND_POWER_OF_TWO(tmp, 1);\n+          sad += abs(source16[h * source_stride_ + w] - comp_pred);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+        }\n+      }\n+    }\n+    return sad;\n+  }\n+\n+  void FillConstant(uint8_t *data, int stride, uint16_t fill_constant) {\n+    uint8_t *data8 = data;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    uint16_t *data16 = CONVERT_TO_SHORTPTR(data);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+    for (int h = 0; h < height_; ++h) {\n+      for (int w = 0; w < width_; ++w) {\n+        if (!use_high_bit_depth_) {\n+          data8[h * stride + w] = static_cast<uint8_t>(fill_constant);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        } else {\n+          data16[h * stride + w] = fill_constant;\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+        }\n       }\n     }\n   }\n \n   void FillRandom(uint8_t *data, int stride) {\n+    uint8_t *data8 = data;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    uint16_t *data16 = CONVERT_TO_SHORTPTR(data);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n     for (int h = 0; h < height_; ++h) {\n       for (int w = 0; w < width_; ++w) {\n-        data[h * stride + w] = rnd_.Rand8();\n+        if (!use_high_bit_depth_) {\n+          data8[h * stride + w] = rnd_.Rand8();\n+#if CONFIG_VP9_HIGHBITDEPTH\n+        } else {\n+          data16[h * stride + w] = rnd_.Rand16() & mask_;\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+        }\n       }\n     }\n   }\n \n-  int width_, height_;\n-  static uint8_t* source_data_;\n+  int width_, height_, mask_, bd_;\n+  vpx_bit_depth_t bit_depth_;\n+  static uint8_t *source_data_;\n+  static uint8_t *reference_data_;\n+  static uint8_t *second_pred_;\n   int source_stride_;\n-  static uint8_t* reference_data_;\n+  bool use_high_bit_depth_;\n+  static uint8_t *source_data8_;\n+  static uint8_t *reference_data8_;\n+  static uint8_t *second_pred8_;\n+  static uint16_t *source_data16_;\n+  static uint16_t *reference_data16_;\n+  static uint16_t *second_pred16_;\n   int reference_stride_;\n \n   ACMRandom rnd_;\n };\n \n-class SADTest : public SADTestBase,\n-    public ::testing::WithParamInterface<sad_m_by_n_test_param_t> {\n+class SADx4Test\n+    : public SADTestBase,\n+      public ::testing::WithParamInterface<SadMxNx4Param> {\n  public:\n-  SADTest() : SADTestBase(GET_PARAM(0), GET_PARAM(1)) {}\n-\n- protected:\n-  unsigned int SAD(unsigned int max_sad, int block_idx = 0) {\n-    unsigned int ret;\n-    const uint8_t* const reference = GetReference(block_idx);\n-\n-    REGISTER_STATE_CHECK(ret = GET_PARAM(2)(source_data_, source_stride_,\n-                                            reference, reference_stride_,\n-                                            max_sad));\n-    return ret;\n-  }\n-\n-  void CheckSad(unsigned int max_sad) {\n-    unsigned int reference_sad, exp_sad;\n-\n-    reference_sad = ReferenceSAD(max_sad);\n-    exp_sad = SAD(max_sad);\n-\n-    if (reference_sad <= max_sad) {\n-      ASSERT_EQ(exp_sad, reference_sad);\n-    } else {\n-      // Alternative implementations are not required to check max_sad\n-      ASSERT_GE(exp_sad, reference_sad);\n-    }\n-  }\n-};\n-\n-class SADx4Test : public SADTestBase,\n-    public ::testing::WithParamInterface<sad_n_by_n_by_4_test_param_t> {\n- public:\n-  SADx4Test() : SADTestBase(GET_PARAM(0), GET_PARAM(1)) {}\n+  SADx4Test() : SADTestBase(GET_PARAM(0), GET_PARAM(1), GET_PARAM(3)) {}\n \n  protected:\n   void SADs(unsigned int *results) {\n-    const uint8_t* refs[] = {GetReference(0), GetReference(1),\n-                             GetReference(2), GetReference(3)};\n+    const uint8_t *references[] = {GetReference(0), GetReference(1),\n+                                   GetReference(2), GetReference(3)};\n \n-    REGISTER_STATE_CHECK(GET_PARAM(2)(source_data_, source_stride_,\n-                                      refs, reference_stride_,\n-                                      results));\n+    ASM_REGISTER_STATE_CHECK(GET_PARAM(2)(source_data_, source_stride_,\n+                                          references, reference_stride_,\n+                                          results));\n   }\n \n   void CheckSADs() {\n     unsigned int reference_sad, exp_sad[4];\n \n     SADs(exp_sad);\n-    for (int block = 0; block < 4; block++) {\n-      reference_sad = ReferenceSAD(UINT_MAX, block);\n+    for (int block = 0; block < 4; ++block) {\n+      reference_sad = ReferenceSAD(block);\n \n-      EXPECT_EQ(exp_sad[block], reference_sad) << \""block \"" << block;\n+      EXPECT_EQ(reference_sad, exp_sad[block]) << \""block \"" << block;\n     }\n   }\n };\n \n-uint8_t* SADTestBase::source_data_ = NULL;\n-uint8_t* SADTestBase::reference_data_ = NULL;\n+class SADTest\n+    : public SADTestBase,\n+      public ::testing::WithParamInterface<SadMxNParam> {\n+ public:\n+  SADTest() : SADTestBase(GET_PARAM(0), GET_PARAM(1), GET_PARAM(3)) {}\n+\n+ protected:\n+  unsigned int SAD(int block_idx) {\n+    unsigned int ret;\n+    const uint8_t *const reference = GetReference(block_idx);\n+\n+    ASM_REGISTER_STATE_CHECK(ret = GET_PARAM(2)(source_data_, source_stride_,\n+                                                reference, reference_stride_));\n+    return ret;\n+  }\n+\n+  void CheckSAD() {\n+    const unsigned int reference_sad = ReferenceSAD(0);\n+    const unsigned int exp_sad = SAD(0);\n+\n+    ASSERT_EQ(reference_sad, exp_sad);\n+  }\n+};\n+\n+class SADavgTest\n+    : public SADTestBase,\n+      public ::testing::WithParamInterface<SadMxNAvgParam> {\n+ public:\n+  SADavgTest() : SADTestBase(GET_PARAM(0), GET_PARAM(1), GET_PARAM(3)) {}\n+\n+ protected:\n+  unsigned int SAD_avg(int block_idx) {\n+    unsigned int ret;\n+    const uint8_t *const reference = GetReference(block_idx);\n+\n+    ASM_REGISTER_STATE_CHECK(ret = GET_PARAM(2)(source_data_, source_stride_,\n+                                                reference, reference_stride_,\n+                                                second_pred_));\n+    return ret;\n+  }\n+\n+  void CheckSAD() {\n+    const unsigned int reference_sad = ReferenceSADavg(0);\n+    const unsigned int exp_sad = SAD_avg(0);\n+\n+    ASSERT_EQ(reference_sad, exp_sad);\n+  }\n+};\n+\n+uint8_t *SADTestBase::source_data_ = NULL;\n+uint8_t *SADTestBase::reference_data_ = NULL;\n+uint8_t *SADTestBase::second_pred_ = NULL;\n+uint8_t *SADTestBase::source_data8_ = NULL;\n+uint8_t *SADTestBase::reference_data8_ = NULL;\n+uint8_t *SADTestBase::second_pred8_ = NULL;\n+uint16_t *SADTestBase::source_data16_ = NULL;\n+uint16_t *SADTestBase::reference_data16_ = NULL;\n+uint16_t *SADTestBase::second_pred16_ = NULL;\n \n TEST_P(SADTest, MaxRef) {\n   FillConstant(source_data_, source_stride_, 0);\n-  FillConstant(reference_data_, reference_stride_, 255);\n-  CheckSad(UINT_MAX);\n+  FillConstant(reference_data_, reference_stride_, mask_);\n+  CheckSAD();\n+}\n+\n+TEST_P(SADTest, MaxSrc) {\n+  FillConstant(source_data_, source_stride_, mask_);\n+  FillConstant(reference_data_, reference_stride_, 0);\n+  CheckSAD();\n+}\n+\n+TEST_P(SADTest, ShortRef) {\n+  const int tmp_stride = reference_stride_;\n+  reference_stride_ >>= 1;\n+  FillRandom(source_data_, source_stride_);\n+  FillRandom(reference_data_, reference_stride_);\n+  CheckSAD();\n+  reference_stride_ = tmp_stride;\n+}\n+\n+TEST_P(SADTest, UnalignedRef) {\n+  // The reference frame, but not the source frame, may be unaligned for\n+  // certain types of searches.\n+  const int tmp_stride = reference_stride_;\n+  reference_stride_ -= 1;\n+  FillRandom(source_data_, source_stride_);\n+  FillRandom(reference_data_, reference_stride_);\n+  CheckSAD();\n+  reference_stride_ = tmp_stride;\n+}\n+\n+TEST_P(SADTest, ShortSrc) {\n+  const int tmp_stride = source_stride_;\n+  source_stride_ >>= 1;\n+  FillRandom(source_data_, source_stride_);\n+  FillRandom(reference_data_, reference_stride_);\n+  CheckSAD();\n+  source_stride_ = tmp_stride;\n+}\n+\n+TEST_P(SADavgTest, MaxRef) {\n+  FillConstant(source_data_, source_stride_, 0);\n+  FillConstant(reference_data_, reference_stride_, mask_);\n+  FillConstant(second_pred_, width_, 0);\n+  CheckSAD();\n+}\n+TEST_P(SADavgTest, MaxSrc) {\n+  FillConstant(source_data_, source_stride_, mask_);\n+  FillConstant(reference_data_, reference_stride_, 0);\n+  FillConstant(second_pred_, width_, 0);\n+  CheckSAD();\n+}\n+\n+TEST_P(SADavgTest, ShortRef) {\n+  const int tmp_stride = reference_stride_;\n+  reference_stride_ >>= 1;\n+  FillRandom(source_data_, source_stride_);\n+  FillRandom(reference_data_, reference_stride_);\n+  FillRandom(second_pred_, width_);\n+  CheckSAD();\n+  reference_stride_ = tmp_stride;\n+}\n+\n+TEST_P(SADavgTest, UnalignedRef) {\n+  // The reference frame, but not the source frame, may be unaligned for\n+  // certain types of searches.\n+  const int tmp_stride = reference_stride_;\n+  reference_stride_ -= 1;\n+  FillRandom(source_data_, source_stride_);\n+  FillRandom(reference_data_, reference_stride_);\n+  FillRandom(second_pred_, width_);\n+  CheckSAD();\n+  reference_stride_ = tmp_stride;\n+}\n+\n+TEST_P(SADavgTest, ShortSrc) {\n+  const int tmp_stride = source_stride_;\n+  source_stride_ >>= 1;\n+  FillRandom(source_data_, source_stride_);\n+  FillRandom(reference_data_, reference_stride_);\n+  FillRandom(second_pred_, width_);\n+  CheckSAD();\n+  source_stride_ = tmp_stride;\n }\n \n TEST_P(SADx4Test, MaxRef) {\n   FillConstant(source_data_, source_stride_, 0);\n-  FillConstant(GetReference(0), reference_stride_, 255);\n-  FillConstant(GetReference(1), reference_stride_, 255);\n-  FillConstant(GetReference(2), reference_stride_, 255);\n-  FillConstant(GetReference(3), reference_stride_, 255);\n+  FillConstant(GetReference(0), reference_stride_, mask_);\n+  FillConstant(GetReference(1), reference_stride_, mask_);\n+  FillConstant(GetReference(2), reference_stride_, mask_);\n+  FillConstant(GetReference(3), reference_stride_, mask_);\n   CheckSADs();\n }\n \n-TEST_P(SADTest, MaxSrc) {\n-  FillConstant(source_data_, source_stride_, 255);\n-  FillConstant(reference_data_, reference_stride_, 0);\n-  CheckSad(UINT_MAX);\n-}\n-\n TEST_P(SADx4Test, MaxSrc) {\n-  FillConstant(source_data_, source_stride_, 255);\n+  FillConstant(source_data_, source_stride_, mask_);\n   FillConstant(GetReference(0), reference_stride_, 0);\n   FillConstant(GetReference(1), reference_stride_, 0);\n   FillConstant(GetReference(2), reference_stride_, 0);\n@@ -219,15 +430,6 @@\n\n   CheckSADs();\n }\n \n-TEST_P(SADTest, ShortRef) {\n-  int tmp_stride = reference_stride_;\n-  reference_stride_ >>= 1;\n-  FillRandom(source_data_, source_stride_);\n-  FillRandom(reference_data_, reference_stride_);\n-  CheckSad(UINT_MAX);\n-  reference_stride_ = tmp_stride;\n-}\n-\n TEST_P(SADx4Test, ShortRef) {\n   int tmp_stride = reference_stride_;\n   reference_stride_ >>= 1;\n@@ -240,17 +442,6 @@\n\n   reference_stride_ = tmp_stride;\n }\n \n-TEST_P(SADTest, UnalignedRef) {\n-  // The reference frame, but not the source frame, may be unaligned for\n-  // certain types of searches.\n-  int tmp_stride = reference_stride_;\n-  reference_stride_ -= 1;\n-  FillRandom(source_data_, source_stride_);\n-  FillRandom(reference_data_, reference_stride_);\n-  CheckSad(UINT_MAX);\n-  reference_stride_ = tmp_stride;\n-}\n-\n TEST_P(SADx4Test, UnalignedRef) {\n   // The reference frame, but not the source frame, may be unaligned for\n   // certain types of searches.\n@@ -265,15 +456,6 @@\n\n   reference_stride_ = tmp_stride;\n }\n \n-TEST_P(SADTest, ShortSrc) {\n-  int tmp_stride = source_stride_;\n-  source_stride_ >>= 1;\n-  FillRandom(source_data_, source_stride_);\n-  FillRandom(reference_data_, reference_stride_);\n-  CheckSad(UINT_MAX);\n-  source_stride_ = tmp_stride;\n-}\n-\n TEST_P(SADx4Test, ShortSrc) {\n   int tmp_stride = source_stride_;\n   source_stride_ >>= 1;\n@@ -286,271 +468,743 @@\n\n   source_stride_ = tmp_stride;\n }\n \n-TEST_P(SADTest, MaxSAD) {\n-  // Verify that, when max_sad is set, the implementation does not return a\n-  // value lower than the reference.\n-  FillConstant(source_data_, source_stride_, 255);\n-  FillConstant(reference_data_, reference_stride_, 0);\n-  CheckSad(128);\n+TEST_P(SADx4Test, SrcAlignedByWidth) {\n+  uint8_t * tmp_source_data = source_data_;\n+  source_data_ += width_;\n+  FillRandom(source_data_, source_stride_);\n+  FillRandom(GetReference(0), reference_stride_);\n+  FillRandom(GetReference(1), reference_stride_);\n+  FillRandom(GetReference(2), reference_stride_);\n+  FillRandom(GetReference(3), reference_stride_);\n+  CheckSADs();\n+  source_data_ = tmp_source_data;\n }\n \n using std::tr1::make_tuple;\n \n //------------------------------------------------------------------------------\n // C functions\n-#if CONFIG_VP8_ENCODER\n-const sad_m_by_n_fn_t sad_16x16_c = vp8_sad16x16_c;\n-const sad_m_by_n_fn_t sad_8x16_c = vp8_sad8x16_c;\n-const sad_m_by_n_fn_t sad_16x8_c = vp8_sad16x8_c;\n-const sad_m_by_n_fn_t sad_8x8_c = vp8_sad8x8_c;\n-const sad_m_by_n_fn_t sad_4x4_c = vp8_sad4x4_c;\n-#endif\n-#if CONFIG_VP9_ENCODER\n-const sad_m_by_n_fn_t sad_64x64_c_vp9 = vp9_sad64x64_c;\n-const sad_m_by_n_fn_t sad_32x32_c_vp9 = vp9_sad32x32_c;\n-const sad_m_by_n_fn_t sad_16x16_c_vp9 = vp9_sad16x16_c;\n-const sad_m_by_n_fn_t sad_8x16_c_vp9 = vp9_sad8x16_c;\n-const sad_m_by_n_fn_t sad_16x8_c_vp9 = vp9_sad16x8_c;\n-const sad_m_by_n_fn_t sad_8x8_c_vp9 = vp9_sad8x8_c;\n-const sad_m_by_n_fn_t sad_8x4_c_vp9 = vp9_sad8x4_c;\n-const sad_m_by_n_fn_t sad_4x8_c_vp9 = vp9_sad4x8_c;\n-const sad_m_by_n_fn_t sad_4x4_c_vp9 = vp9_sad4x4_c;\n-#endif\n-const sad_m_by_n_test_param_t c_tests[] = {\n-#if CONFIG_VP8_ENCODER\n-  make_tuple(16, 16, sad_16x16_c),\n-  make_tuple(8, 16, sad_8x16_c),\n-  make_tuple(16, 8, sad_16x8_c),\n-  make_tuple(8, 8, sad_8x8_c),\n-  make_tuple(4, 4, sad_4x4_c),\n-#endif\n-#if CONFIG_VP9_ENCODER\n-  make_tuple(64, 64, sad_64x64_c_vp9),\n-  make_tuple(32, 32, sad_32x32_c_vp9),\n-  make_tuple(16, 16, sad_16x16_c_vp9),\n-  make_tuple(8, 16, sad_8x16_c_vp9),\n-  make_tuple(16, 8, sad_16x8_c_vp9),\n-  make_tuple(8, 8, sad_8x8_c_vp9),\n-  make_tuple(8, 4, sad_8x4_c_vp9),\n-  make_tuple(4, 8, sad_4x8_c_vp9),\n-  make_tuple(4, 4, sad_4x4_c_vp9),\n-#endif\n+const SadMxNFunc sad64x64_c = vpx_sad64x64_c;\n+const SadMxNFunc sad64x32_c = vpx_sad64x32_c;\n+const SadMxNFunc sad32x64_c = vpx_sad32x64_c;\n+const SadMxNFunc sad32x32_c = vpx_sad32x32_c;\n+const SadMxNFunc sad32x16_c = vpx_sad32x16_c;\n+const SadMxNFunc sad16x32_c = vpx_sad16x32_c;\n+const SadMxNFunc sad16x16_c = vpx_sad16x16_c;\n+const SadMxNFunc sad16x8_c = vpx_sad16x8_c;\n+const SadMxNFunc sad8x16_c = vpx_sad8x16_c;\n+const SadMxNFunc sad8x8_c = vpx_sad8x8_c;\n+const SadMxNFunc sad8x4_c = vpx_sad8x4_c;\n+const SadMxNFunc sad4x8_c = vpx_sad4x8_c;\n+const SadMxNFunc sad4x4_c = vpx_sad4x4_c;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+const SadMxNFunc highbd_sad64x64_c = vpx_highbd_sad64x64_c;\n+const SadMxNFunc highbd_sad64x32_c = vpx_highbd_sad64x32_c;\n+const SadMxNFunc highbd_sad32x64_c = vpx_highbd_sad32x64_c;\n+const SadMxNFunc highbd_sad32x32_c = vpx_highbd_sad32x32_c;\n+const SadMxNFunc highbd_sad32x16_c = vpx_highbd_sad32x16_c;\n+const SadMxNFunc highbd_sad16x32_c = vpx_highbd_sad16x32_c;\n+const SadMxNFunc highbd_sad16x16_c = vpx_highbd_sad16x16_c;\n+const SadMxNFunc highbd_sad16x8_c = vpx_highbd_sad16x8_c;\n+const SadMxNFunc highbd_sad8x16_c = vpx_highbd_sad8x16_c;\n+const SadMxNFunc highbd_sad8x8_c = vpx_highbd_sad8x8_c;\n+const SadMxNFunc highbd_sad8x4_c = vpx_highbd_sad8x4_c;\n+const SadMxNFunc highbd_sad4x8_c = vpx_highbd_sad4x8_c;\n+const SadMxNFunc highbd_sad4x4_c = vpx_highbd_sad4x4_c;\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+const SadMxNParam c_tests[] = {\n+  make_tuple(64, 64, sad64x64_c, -1),\n+  make_tuple(64, 32, sad64x32_c, -1),\n+  make_tuple(32, 64, sad32x64_c, -1),\n+  make_tuple(32, 32, sad32x32_c, -1),\n+  make_tuple(32, 16, sad32x16_c, -1),\n+  make_tuple(16, 32, sad16x32_c, -1),\n+  make_tuple(16, 16, sad16x16_c, -1),\n+  make_tuple(16, 8, sad16x8_c, -1),\n+  make_tuple(8, 16, sad8x16_c, -1),\n+  make_tuple(8, 8, sad8x8_c, -1),\n+  make_tuple(8, 4, sad8x4_c, -1),\n+  make_tuple(4, 8, sad4x8_c, -1),\n+  make_tuple(4, 4, sad4x4_c, -1),\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  make_tuple(64, 64, highbd_sad64x64_c, 8),\n+  make_tuple(64, 32, highbd_sad64x32_c, 8),\n+  make_tuple(32, 64, highbd_sad32x64_c, 8),\n+  make_tuple(32, 32, highbd_sad32x32_c, 8),\n+  make_tuple(32, 16, highbd_sad32x16_c, 8),\n+  make_tuple(16, 32, highbd_sad16x32_c, 8),\n+  make_tuple(16, 16, highbd_sad16x16_c, 8),\n+  make_tuple(16, 8, highbd_sad16x8_c, 8),\n+  make_tuple(8, 16, highbd_sad8x16_c, 8),\n+  make_tuple(8, 8, highbd_sad8x8_c, 8),\n+  make_tuple(8, 4, highbd_sad8x4_c, 8),\n+  make_tuple(4, 8, highbd_sad4x8_c, 8),\n+  make_tuple(4, 4, highbd_sad4x4_c, 8),\n+  make_tuple(64, 64, highbd_sad64x64_c, 10),\n+  make_tuple(64, 32, highbd_sad64x32_c, 10),\n+  make_tuple(32, 64, highbd_sad32x64_c, 10),\n+  make_tuple(32, 32, highbd_sad32x32_c, 10),\n+  make_tuple(32, 16, highbd_sad32x16_c, 10),\n+  make_tuple(16, 32, highbd_sad16x32_c, 10),\n+  make_tuple(16, 16, highbd_sad16x16_c, 10),\n+  make_tuple(16, 8, highbd_sad16x8_c, 10),\n+  make_tuple(8, 16, highbd_sad8x16_c, 10),\n+  make_tuple(8, 8, highbd_sad8x8_c, 10),\n+  make_tuple(8, 4, highbd_sad8x4_c, 10),\n+  make_tuple(4, 8, highbd_sad4x8_c, 10),\n+  make_tuple(4, 4, highbd_sad4x4_c, 10),\n+  make_tuple(64, 64, highbd_sad64x64_c, 12),\n+  make_tuple(64, 32, highbd_sad64x32_c, 12),\n+  make_tuple(32, 64, highbd_sad32x64_c, 12),\n+  make_tuple(32, 32, highbd_sad32x32_c, 12),\n+  make_tuple(32, 16, highbd_sad32x16_c, 12),\n+  make_tuple(16, 32, highbd_sad16x32_c, 12),\n+  make_tuple(16, 16, highbd_sad16x16_c, 12),\n+  make_tuple(16, 8, highbd_sad16x8_c, 12),\n+  make_tuple(8, 16, highbd_sad8x16_c, 12),\n+  make_tuple(8, 8, highbd_sad8x8_c, 12),\n+  make_tuple(8, 4, highbd_sad8x4_c, 12),\n+  make_tuple(4, 8, highbd_sad4x8_c, 12),\n+  make_tuple(4, 4, highbd_sad4x4_c, 12),\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n };\n INSTANTIATE_TEST_CASE_P(C, SADTest, ::testing::ValuesIn(c_tests));\n \n-#if CONFIG_VP9_ENCODER\n-const sad_n_by_n_by_4_fn_t sad_64x64x4d_c = vp9_sad64x64x4d_c;\n-const sad_n_by_n_by_4_fn_t sad_64x32x4d_c = vp9_sad64x32x4d_c;\n-const sad_n_by_n_by_4_fn_t sad_32x64x4d_c = vp9_sad32x64x4d_c;\n-const sad_n_by_n_by_4_fn_t sad_32x32x4d_c = vp9_sad32x32x4d_c;\n-const sad_n_by_n_by_4_fn_t sad_32x16x4d_c = vp9_sad32x16x4d_c;\n-const sad_n_by_n_by_4_fn_t sad_16x32x4d_c = vp9_sad16x32x4d_c;\n-const sad_n_by_n_by_4_fn_t sad_16x16x4d_c = vp9_sad16x16x4d_c;\n-const sad_n_by_n_by_4_fn_t sad_16x8x4d_c = vp9_sad16x8x4d_c;\n-const sad_n_by_n_by_4_fn_t sad_8x16x4d_c = vp9_sad8x16x4d_c;\n-const sad_n_by_n_by_4_fn_t sad_8x8x4d_c = vp9_sad8x8x4d_c;\n-const sad_n_by_n_by_4_fn_t sad_8x4x4d_c = vp9_sad8x4x4d_c;\n-const sad_n_by_n_by_4_fn_t sad_4x8x4d_c = vp9_sad4x8x4d_c;\n-const sad_n_by_n_by_4_fn_t sad_4x4x4d_c = vp9_sad4x4x4d_c;\n-INSTANTIATE_TEST_CASE_P(C, SADx4Test, ::testing::Values(\n-                        make_tuple(64, 64, sad_64x64x4d_c),\n-                        make_tuple(64, 32, sad_64x32x4d_c),\n-                        make_tuple(32, 64, sad_32x64x4d_c),\n-                        make_tuple(32, 32, sad_32x32x4d_c),\n-                        make_tuple(32, 16, sad_32x16x4d_c),\n-                        make_tuple(16, 32, sad_16x32x4d_c),\n-                        make_tuple(16, 16, sad_16x16x4d_c),\n-                        make_tuple(16, 8, sad_16x8x4d_c),\n-                        make_tuple(8, 16, sad_8x16x4d_c),\n-                        make_tuple(8, 8, sad_8x8x4d_c),\n-                        make_tuple(8, 4, sad_8x4x4d_c),\n-                        make_tuple(4, 8, sad_4x8x4d_c),\n-                        make_tuple(4, 4, sad_4x4x4d_c)));\n-#endif  // CONFIG_VP9_ENCODER\n+const SadMxNAvgFunc sad64x64_avg_c = vpx_sad64x64_avg_c;\n+const SadMxNAvgFunc sad64x32_avg_c = vpx_sad64x32_avg_c;\n+const SadMxNAvgFunc sad32x64_avg_c = vpx_sad32x64_avg_c;\n+const SadMxNAvgFunc sad32x32_avg_c = vpx_sad32x32_avg_c;\n+const SadMxNAvgFunc sad32x16_avg_c = vpx_sad32x16_avg_c;\n+const SadMxNAvgFunc sad16x32_avg_c = vpx_sad16x32_avg_c;\n+const SadMxNAvgFunc sad16x16_avg_c = vpx_sad16x16_avg_c;\n+const SadMxNAvgFunc sad16x8_avg_c = vpx_sad16x8_avg_c;\n+const SadMxNAvgFunc sad8x16_avg_c = vpx_sad8x16_avg_c;\n+const SadMxNAvgFunc sad8x8_avg_c = vpx_sad8x8_avg_c;\n+const SadMxNAvgFunc sad8x4_avg_c = vpx_sad8x4_avg_c;\n+const SadMxNAvgFunc sad4x8_avg_c = vpx_sad4x8_avg_c;\n+const SadMxNAvgFunc sad4x4_avg_c = vpx_sad4x4_avg_c;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+const SadMxNAvgFunc highbd_sad64x64_avg_c = vpx_highbd_sad64x64_avg_c;\n+const SadMxNAvgFunc highbd_sad64x32_avg_c = vpx_highbd_sad64x32_avg_c;\n+const SadMxNAvgFunc highbd_sad32x64_avg_c = vpx_highbd_sad32x64_avg_c;\n+const SadMxNAvgFunc highbd_sad32x32_avg_c = vpx_highbd_sad32x32_avg_c;\n+const SadMxNAvgFunc highbd_sad32x16_avg_c = vpx_highbd_sad32x16_avg_c;\n+const SadMxNAvgFunc highbd_sad16x32_avg_c = vpx_highbd_sad16x32_avg_c;\n+const SadMxNAvgFunc highbd_sad16x16_avg_c = vpx_highbd_sad16x16_avg_c;\n+const SadMxNAvgFunc highbd_sad16x8_avg_c = vpx_highbd_sad16x8_avg_c;\n+const SadMxNAvgFunc highbd_sad8x16_avg_c = vpx_highbd_sad8x16_avg_c;\n+const SadMxNAvgFunc highbd_sad8x8_avg_c = vpx_highbd_sad8x8_avg_c;\n+const SadMxNAvgFunc highbd_sad8x4_avg_c = vpx_highbd_sad8x4_avg_c;\n+const SadMxNAvgFunc highbd_sad4x8_avg_c = vpx_highbd_sad4x8_avg_c;\n+const SadMxNAvgFunc highbd_sad4x4_avg_c = vpx_highbd_sad4x4_avg_c;\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+const SadMxNAvgParam avg_c_tests[] = {\n+  make_tuple(64, 64, sad64x64_avg_c, -1),\n+  make_tuple(64, 32, sad64x32_avg_c, -1),\n+  make_tuple(32, 64, sad32x64_avg_c, -1),\n+  make_tuple(32, 32, sad32x32_avg_c, -1),\n+  make_tuple(32, 16, sad32x16_avg_c, -1),\n+  make_tuple(16, 32, sad16x32_avg_c, -1),\n+  make_tuple(16, 16, sad16x16_avg_c, -1),\n+  make_tuple(16, 8, sad16x8_avg_c, -1),\n+  make_tuple(8, 16, sad8x16_avg_c, -1),\n+  make_tuple(8, 8, sad8x8_avg_c, -1),\n+  make_tuple(8, 4, sad8x4_avg_c, -1),\n+  make_tuple(4, 8, sad4x8_avg_c, -1),\n+  make_tuple(4, 4, sad4x4_avg_c, -1),\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  make_tuple(64, 64, highbd_sad64x64_avg_c, 8),\n+  make_tuple(64, 32, highbd_sad64x32_avg_c, 8),\n+  make_tuple(32, 64, highbd_sad32x64_avg_c, 8),\n+  make_tuple(32, 32, highbd_sad32x32_avg_c, 8),\n+  make_tuple(32, 16, highbd_sad32x16_avg_c, 8),\n+  make_tuple(16, 32, highbd_sad16x32_avg_c, 8),\n+  make_tuple(16, 16, highbd_sad16x16_avg_c, 8),\n+  make_tuple(16, 8, highbd_sad16x8_avg_c, 8),\n+  make_tuple(8, 16, highbd_sad8x16_avg_c, 8),\n+  make_tuple(8, 8, highbd_sad8x8_avg_c, 8),\n+  make_tuple(8, 4, highbd_sad8x4_avg_c, 8),\n+  make_tuple(4, 8, highbd_sad4x8_avg_c, 8),\n+  make_tuple(4, 4, highbd_sad4x4_avg_c, 8),\n+  make_tuple(64, 64, highbd_sad64x64_avg_c, 10),\n+  make_tuple(64, 32, highbd_sad64x32_avg_c, 10),\n+  make_tuple(32, 64, highbd_sad32x64_avg_c, 10),\n+  make_tuple(32, 32, highbd_sad32x32_avg_c, 10),\n+  make_tuple(32, 16, highbd_sad32x16_avg_c, 10),\n+  make_tuple(16, 32, highbd_sad16x32_avg_c, 10),\n+  make_tuple(16, 16, highbd_sad16x16_avg_c, 10),\n+  make_tuple(16, 8, highbd_sad16x8_avg_c, 10),\n+  make_tuple(8, 16, highbd_sad8x16_avg_c, 10),\n+  make_tuple(8, 8, highbd_sad8x8_avg_c, 10),\n+  make_tuple(8, 4, highbd_sad8x4_avg_c, 10),\n+  make_tuple(4, 8, highbd_sad4x8_avg_c, 10),\n+  make_tuple(4, 4, highbd_sad4x4_avg_c, 10),\n+  make_tuple(64, 64, highbd_sad64x64_avg_c, 12),\n+  make_tuple(64, 32, highbd_sad64x32_avg_c, 12),\n+  make_tuple(32, 64, highbd_sad32x64_avg_c, 12),\n+  make_tuple(32, 32, highbd_sad32x32_avg_c, 12),\n+  make_tuple(32, 16, highbd_sad32x16_avg_c, 12),\n+  make_tuple(16, 32, highbd_sad16x32_avg_c, 12),\n+  make_tuple(16, 16, highbd_sad16x16_avg_c, 12),\n+  make_tuple(16, 8, highbd_sad16x8_avg_c, 12),\n+  make_tuple(8, 16, highbd_sad8x16_avg_c, 12),\n+  make_tuple(8, 8, highbd_sad8x8_avg_c, 12),\n+  make_tuple(8, 4, highbd_sad8x4_avg_c, 12),\n+  make_tuple(4, 8, highbd_sad4x8_avg_c, 12),\n+  make_tuple(4, 4, highbd_sad4x4_avg_c, 12),\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+};\n+INSTANTIATE_TEST_CASE_P(C, SADavgTest, ::testing::ValuesIn(avg_c_tests));\n+\n+const SadMxNx4Func sad64x64x4d_c = vpx_sad64x64x4d_c;\n+const SadMxNx4Func sad64x32x4d_c = vpx_sad64x32x4d_c;\n+const SadMxNx4Func sad32x64x4d_c = vpx_sad32x64x4d_c;\n+const SadMxNx4Func sad32x32x4d_c = vpx_sad32x32x4d_c;\n+const SadMxNx4Func sad32x16x4d_c = vpx_sad32x16x4d_c;\n+const SadMxNx4Func sad16x32x4d_c = vpx_sad16x32x4d_c;\n+const SadMxNx4Func sad16x16x4d_c = vpx_sad16x16x4d_c;\n+const SadMxNx4Func sad16x8x4d_c = vpx_sad16x8x4d_c;\n+const SadMxNx4Func sad8x16x4d_c = vpx_sad8x16x4d_c;\n+const SadMxNx4Func sad8x8x4d_c = vpx_sad8x8x4d_c;\n+const SadMxNx4Func sad8x4x4d_c = vpx_sad8x4x4d_c;\n+const SadMxNx4Func sad4x8x4d_c = vpx_sad4x8x4d_c;\n+const SadMxNx4Func sad4x4x4d_c = vpx_sad4x4x4d_c;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+const SadMxNx4Func highbd_sad64x64x4d_c = vpx_highbd_sad64x64x4d_c;\n+const SadMxNx4Func highbd_sad64x32x4d_c = vpx_highbd_sad64x32x4d_c;\n+const SadMxNx4Func highbd_sad32x64x4d_c = vpx_highbd_sad32x64x4d_c;\n+const SadMxNx4Func highbd_sad32x32x4d_c = vpx_highbd_sad32x32x4d_c;\n+const SadMxNx4Func highbd_sad32x16x4d_c = vpx_highbd_sad32x16x4d_c;\n+const SadMxNx4Func highbd_sad16x32x4d_c = vpx_highbd_sad16x32x4d_c;\n+const SadMxNx4Func highbd_sad16x16x4d_c = vpx_highbd_sad16x16x4d_c;\n+const SadMxNx4Func highbd_sad16x8x4d_c = vpx_highbd_sad16x8x4d_c;\n+const SadMxNx4Func highbd_sad8x16x4d_c = vpx_highbd_sad8x16x4d_c;\n+const SadMxNx4Func highbd_sad8x8x4d_c = vpx_highbd_sad8x8x4d_c;\n+const SadMxNx4Func highbd_sad8x4x4d_c = vpx_highbd_sad8x4x4d_c;\n+const SadMxNx4Func highbd_sad4x8x4d_c = vpx_highbd_sad4x8x4d_c;\n+const SadMxNx4Func highbd_sad4x4x4d_c = vpx_highbd_sad4x4x4d_c;\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+const SadMxNx4Param x4d_c_tests[] = {\n+  make_tuple(64, 64, sad64x64x4d_c, -1),\n+  make_tuple(64, 32, sad64x32x4d_c, -1),\n+  make_tuple(32, 64, sad32x64x4d_c, -1),\n+  make_tuple(32, 32, sad32x32x4d_c, -1),\n+  make_tuple(32, 16, sad32x16x4d_c, -1),\n+  make_tuple(16, 32, sad16x32x4d_c, -1),\n+  make_tuple(16, 16, sad16x16x4d_c, -1),\n+  make_tuple(16, 8, sad16x8x4d_c, -1),\n+  make_tuple(8, 16, sad8x16x4d_c, -1),\n+  make_tuple(8, 8, sad8x8x4d_c, -1),\n+  make_tuple(8, 4, sad8x4x4d_c, -1),\n+  make_tuple(4, 8, sad4x8x4d_c, -1),\n+  make_tuple(4, 4, sad4x4x4d_c, -1),\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  make_tuple(64, 64, highbd_sad64x64x4d_c, 8),\n+  make_tuple(64, 32, highbd_sad64x32x4d_c, 8),\n+  make_tuple(32, 64, highbd_sad32x64x4d_c, 8),\n+  make_tuple(32, 32, highbd_sad32x32x4d_c, 8),\n+  make_tuple(32, 16, highbd_sad32x16x4d_c, 8),\n+  make_tuple(16, 32, highbd_sad16x32x4d_c, 8),\n+  make_tuple(16, 16, highbd_sad16x16x4d_c, 8),\n+  make_tuple(16, 8, highbd_sad16x8x4d_c, 8),\n+  make_tuple(8, 16, highbd_sad8x16x4d_c, 8),\n+  make_tuple(8, 8, highbd_sad8x8x4d_c, 8),\n+  make_tuple(8, 4, highbd_sad8x4x4d_c, 8),\n+  make_tuple(4, 8, highbd_sad4x8x4d_c, 8),\n+  make_tuple(4, 4, highbd_sad4x4x4d_c, 8),\n+  make_tuple(64, 64, highbd_sad64x64x4d_c, 10),\n+  make_tuple(64, 32, highbd_sad64x32x4d_c, 10),\n+  make_tuple(32, 64, highbd_sad32x64x4d_c, 10),\n+  make_tuple(32, 32, highbd_sad32x32x4d_c, 10),\n+  make_tuple(32, 16, highbd_sad32x16x4d_c, 10),\n+  make_tuple(16, 32, highbd_sad16x32x4d_c, 10),\n+  make_tuple(16, 16, highbd_sad16x16x4d_c, 10),\n+  make_tuple(16, 8, highbd_sad16x8x4d_c, 10),\n+  make_tuple(8, 16, highbd_sad8x16x4d_c, 10),\n+  make_tuple(8, 8, highbd_sad8x8x4d_c, 10),\n+  make_tuple(8, 4, highbd_sad8x4x4d_c, 10),\n+  make_tuple(4, 8, highbd_sad4x8x4d_c, 10),\n+  make_tuple(4, 4, highbd_sad4x4x4d_c, 10),\n+  make_tuple(64, 64, highbd_sad64x64x4d_c, 12),\n+  make_tuple(64, 32, highbd_sad64x32x4d_c, 12),\n+  make_tuple(32, 64, highbd_sad32x64x4d_c, 12),\n+  make_tuple(32, 32, highbd_sad32x32x4d_c, 12),\n+  make_tuple(32, 16, highbd_sad32x16x4d_c, 12),\n+  make_tuple(16, 32, highbd_sad16x32x4d_c, 12),\n+  make_tuple(16, 16, highbd_sad16x16x4d_c, 12),\n+  make_tuple(16, 8, highbd_sad16x8x4d_c, 12),\n+  make_tuple(8, 16, highbd_sad8x16x4d_c, 12),\n+  make_tuple(8, 8, highbd_sad8x8x4d_c, 12),\n+  make_tuple(8, 4, highbd_sad8x4x4d_c, 12),\n+  make_tuple(4, 8, highbd_sad4x8x4d_c, 12),\n+  make_tuple(4, 4, highbd_sad4x4x4d_c, 12),\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+};\n+INSTANTIATE_TEST_CASE_P(C, SADx4Test, ::testing::ValuesIn(x4d_c_tests));\n \n //------------------------------------------------------------------------------\n // ARM functions\n #if HAVE_MEDIA\n-#if CONFIG_VP8_ENCODER\n-const sad_m_by_n_fn_t sad_16x16_armv6 = vp8_sad16x16_armv6;\n-INSTANTIATE_TEST_CASE_P(MEDIA, SADTest, ::testing::Values(\n-                        make_tuple(16, 16, sad_16x16_armv6)));\n-#endif\n-#endif\n+const SadMxNFunc sad16x16_media = vpx_sad16x16_media;\n+const SadMxNParam media_tests[] = {\n+  make_tuple(16, 16, sad16x16_media, -1),\n+};\n+INSTANTIATE_TEST_CASE_P(MEDIA, SADTest, ::testing::ValuesIn(media_tests));\n+#endif  // HAVE_MEDIA\n \n #if HAVE_NEON\n-#if CONFIG_VP8_ENCODER\n-const sad_m_by_n_fn_t sad_16x16_neon = vp8_sad16x16_neon;\n-const sad_m_by_n_fn_t sad_8x16_neon = vp8_sad8x16_neon;\n-const sad_m_by_n_fn_t sad_16x8_neon = vp8_sad16x8_neon;\n-const sad_m_by_n_fn_t sad_8x8_neon = vp8_sad8x8_neon;\n-const sad_m_by_n_fn_t sad_4x4_neon = vp8_sad4x4_neon;\n-INSTANTIATE_TEST_CASE_P(NEON, SADTest, ::testing::Values(\n-                        make_tuple(16, 16, sad_16x16_neon),\n-                        make_tuple(8, 16, sad_8x16_neon),\n-                        make_tuple(16, 8, sad_16x8_neon),\n-                        make_tuple(8, 8, sad_8x8_neon),\n-                        make_tuple(4, 4, sad_4x4_neon)));\n-#endif\n-#endif\n+const SadMxNFunc sad64x64_neon = vpx_sad64x64_neon;\n+const SadMxNFunc sad32x32_neon = vpx_sad32x32_neon;\n+const SadMxNFunc sad16x16_neon = vpx_sad16x16_neon;\n+const SadMxNFunc sad16x8_neon = vpx_sad16x8_neon;\n+const SadMxNFunc sad8x16_neon = vpx_sad8x16_neon;\n+const SadMxNFunc sad8x8_neon = vpx_sad8x8_neon;\n+const SadMxNFunc sad4x4_neon = vpx_sad4x4_neon;\n+\n+const SadMxNParam neon_tests[] = {\n+  make_tuple(64, 64, sad64x64_neon, -1),\n+  make_tuple(32, 32, sad32x32_neon, -1),\n+  make_tuple(16, 16, sad16x16_neon, -1),\n+  make_tuple(16, 8, sad16x8_neon, -1),\n+  make_tuple(8, 16, sad8x16_neon, -1),\n+  make_tuple(8, 8, sad8x8_neon, -1),\n+  make_tuple(4, 4, sad4x4_neon, -1),\n+};\n+INSTANTIATE_TEST_CASE_P(NEON, SADTest, ::testing::ValuesIn(neon_tests));\n+\n+const SadMxNx4Func sad64x64x4d_neon = vpx_sad64x64x4d_neon;\n+const SadMxNx4Func sad32x32x4d_neon = vpx_sad32x32x4d_neon;\n+const SadMxNx4Func sad16x16x4d_neon = vpx_sad16x16x4d_neon;\n+const SadMxNx4Param x4d_neon_tests[] = {\n+  make_tuple(64, 64, sad64x64x4d_neon, -1),\n+  make_tuple(32, 32, sad32x32x4d_neon, -1),\n+  make_tuple(16, 16, sad16x16x4d_neon, -1),\n+};\n+INSTANTIATE_TEST_CASE_P(NEON, SADx4Test, ::testing::ValuesIn(x4d_neon_tests));\n+#endif  // HAVE_NEON\n \n //------------------------------------------------------------------------------\n // x86 functions\n #if HAVE_MMX\n-#if CONFIG_VP8_ENCODER\n-const sad_m_by_n_fn_t sad_16x16_mmx = vp8_sad16x16_mmx;\n-const sad_m_by_n_fn_t sad_8x16_mmx = vp8_sad8x16_mmx;\n-const sad_m_by_n_fn_t sad_16x8_mmx = vp8_sad16x8_mmx;\n-const sad_m_by_n_fn_t sad_8x8_mmx = vp8_sad8x8_mmx;\n-const sad_m_by_n_fn_t sad_4x4_mmx = vp8_sad4x4_mmx;\n-#endif\n-#if CONFIG_VP9_ENCODER\n-const sad_m_by_n_fn_t sad_16x16_mmx_vp9 = vp9_sad16x16_mmx;\n-const sad_m_by_n_fn_t sad_8x16_mmx_vp9 = vp9_sad8x16_mmx;\n-const sad_m_by_n_fn_t sad_16x8_mmx_vp9 = vp9_sad16x8_mmx;\n-const sad_m_by_n_fn_t sad_8x8_mmx_vp9 = vp9_sad8x8_mmx;\n-const sad_m_by_n_fn_t sad_4x4_mmx_vp9 = vp9_sad4x4_mmx;\n-#endif\n-\n-const sad_m_by_n_test_param_t mmx_tests[] = {\n-#if CONFIG_VP8_ENCODER\n-  make_tuple(16, 16, sad_16x16_mmx),\n-  make_tuple(8, 16, sad_8x16_mmx),\n-  make_tuple(16, 8, sad_16x8_mmx),\n-  make_tuple(8, 8, sad_8x8_mmx),\n-  make_tuple(4, 4, sad_4x4_mmx),\n-#endif\n-#if CONFIG_VP9_ENCODER\n-  make_tuple(16, 16, sad_16x16_mmx_vp9),\n-  make_tuple(8, 16, sad_8x16_mmx_vp9),\n-  make_tuple(16, 8, sad_16x8_mmx_vp9),\n-  make_tuple(8, 8, sad_8x8_mmx_vp9),\n-  make_tuple(4, 4, sad_4x4_mmx_vp9),\n-#endif\n+const SadMxNFunc sad16x16_mmx = vpx_sad16x16_mmx;\n+const SadMxNFunc sad16x8_mmx = vpx_sad16x8_mmx;\n+const SadMxNFunc sad8x16_mmx = vpx_sad8x16_mmx;\n+const SadMxNFunc sad8x8_mmx = vpx_sad8x8_mmx;\n+const SadMxNFunc sad4x4_mmx = vpx_sad4x4_mmx;\n+const SadMxNParam mmx_tests[] = {\n+  make_tuple(16, 16, sad16x16_mmx, -1),\n+  make_tuple(16, 8, sad16x8_mmx, -1),\n+  make_tuple(8, 16, sad8x16_mmx, -1),\n+  make_tuple(8, 8, sad8x8_mmx, -1),\n+  make_tuple(4, 4, sad4x4_mmx, -1),\n };\n INSTANTIATE_TEST_CASE_P(MMX, SADTest, ::testing::ValuesIn(mmx_tests));\n-#endif\n+#endif  // HAVE_MMX\n \n #if HAVE_SSE\n-#if CONFIG_VP9_ENCODER\n #if CONFIG_USE_X86INC\n-const sad_m_by_n_fn_t sad_4x4_sse_vp9 = vp9_sad4x4_sse;\n-const sad_m_by_n_fn_t sad_4x8_sse_vp9 = vp9_sad4x8_sse;\n-INSTANTIATE_TEST_CASE_P(SSE, SADTest, ::testing::Values(\n-                        make_tuple(4, 4, sad_4x4_sse_vp9),\n-                        make_tuple(4, 8, sad_4x8_sse_vp9)));\n+const SadMxNFunc sad4x8_sse = vpx_sad4x8_sse;\n+const SadMxNFunc sad4x4_sse = vpx_sad4x4_sse;\n+const SadMxNParam sse_tests[] = {\n+  make_tuple(4, 8, sad4x8_sse, -1),\n+  make_tuple(4, 4, sad4x4_sse, -1),\n+};\n+INSTANTIATE_TEST_CASE_P(SSE, SADTest, ::testing::ValuesIn(sse_tests));\n \n-const sad_n_by_n_by_4_fn_t sad_4x8x4d_sse = vp9_sad4x8x4d_sse;\n-const sad_n_by_n_by_4_fn_t sad_4x4x4d_sse = vp9_sad4x4x4d_sse;\n-INSTANTIATE_TEST_CASE_P(SSE, SADx4Test, ::testing::Values(\n-                        make_tuple(4, 8, sad_4x8x4d_sse),\n-                        make_tuple(4, 4, sad_4x4x4d_sse)));\n+const SadMxNAvgFunc sad4x8_avg_sse = vpx_sad4x8_avg_sse;\n+const SadMxNAvgFunc sad4x4_avg_sse = vpx_sad4x4_avg_sse;\n+const SadMxNAvgParam avg_sse_tests[] = {\n+  make_tuple(4, 8, sad4x8_avg_sse, -1),\n+  make_tuple(4, 4, sad4x4_avg_sse, -1),\n+};\n+INSTANTIATE_TEST_CASE_P(SSE, SADavgTest, ::testing::ValuesIn(avg_sse_tests));\n+\n+const SadMxNx4Func sad4x8x4d_sse = vpx_sad4x8x4d_sse;\n+const SadMxNx4Func sad4x4x4d_sse = vpx_sad4x4x4d_sse;\n+const SadMxNx4Param x4d_sse_tests[] = {\n+  make_tuple(4, 8, sad4x8x4d_sse, -1),\n+  make_tuple(4, 4, sad4x4x4d_sse, -1),\n+};\n+INSTANTIATE_TEST_CASE_P(SSE, SADx4Test, ::testing::ValuesIn(x4d_sse_tests));\n #endif  // CONFIG_USE_X86INC\n-#endif  // CONFIG_VP9_ENCODER\n #endif  // HAVE_SSE\n \n #if HAVE_SSE2\n-#if CONFIG_VP8_ENCODER\n-const sad_m_by_n_fn_t sad_16x16_wmt = vp8_sad16x16_wmt;\n-const sad_m_by_n_fn_t sad_8x16_wmt = vp8_sad8x16_wmt;\n-const sad_m_by_n_fn_t sad_16x8_wmt = vp8_sad16x8_wmt;\n-const sad_m_by_n_fn_t sad_8x8_wmt = vp8_sad8x8_wmt;\n-const sad_m_by_n_fn_t sad_4x4_wmt = vp8_sad4x4_wmt;\n-#endif\n-#if CONFIG_VP9_ENCODER\n #if CONFIG_USE_X86INC\n-const sad_m_by_n_fn_t sad_64x64_sse2_vp9 = vp9_sad64x64_sse2;\n-const sad_m_by_n_fn_t sad_64x32_sse2_vp9 = vp9_sad64x32_sse2;\n-const sad_m_by_n_fn_t sad_32x64_sse2_vp9 = vp9_sad32x64_sse2;\n-const sad_m_by_n_fn_t sad_32x32_sse2_vp9 = vp9_sad32x32_sse2;\n-const sad_m_by_n_fn_t sad_32x16_sse2_vp9 = vp9_sad32x16_sse2;\n-const sad_m_by_n_fn_t sad_16x32_sse2_vp9 = vp9_sad16x32_sse2;\n-const sad_m_by_n_fn_t sad_16x16_sse2_vp9 = vp9_sad16x16_sse2;\n-const sad_m_by_n_fn_t sad_16x8_sse2_vp9 = vp9_sad16x8_sse2;\n-const sad_m_by_n_fn_t sad_8x16_sse2_vp9 = vp9_sad8x16_sse2;\n-const sad_m_by_n_fn_t sad_8x8_sse2_vp9 = vp9_sad8x8_sse2;\n-const sad_m_by_n_fn_t sad_8x4_sse2_vp9 = vp9_sad8x4_sse2;\n-#endif\n-#endif\n-const sad_m_by_n_test_param_t sse2_tests[] = {\n-#if CONFIG_VP8_ENCODER\n-  make_tuple(16, 16, sad_16x16_wmt),\n-  make_tuple(8, 16, sad_8x16_wmt),\n-  make_tuple(16, 8, sad_16x8_wmt),\n-  make_tuple(8, 8, sad_8x8_wmt),\n-  make_tuple(4, 4, sad_4x4_wmt),\n-#endif\n-#if CONFIG_VP9_ENCODER\n-#if CONFIG_USE_X86INC\n-  make_tuple(64, 64, sad_64x64_sse2_vp9),\n-  make_tuple(64, 32, sad_64x32_sse2_vp9),\n-  make_tuple(32, 64, sad_32x64_sse2_vp9),\n-  make_tuple(32, 32, sad_32x32_sse2_vp9),\n-  make_tuple(32, 16, sad_32x16_sse2_vp9),\n-  make_tuple(16, 32, sad_16x32_sse2_vp9),\n-  make_tuple(16, 16, sad_16x16_sse2_vp9),\n-  make_tuple(16, 8, sad_16x8_sse2_vp9),\n-  make_tuple(8, 16, sad_8x16_sse2_vp9),\n-  make_tuple(8, 8, sad_8x8_sse2_vp9),\n-  make_tuple(8, 4, sad_8x4_sse2_vp9),\n-#endif\n-#endif\n+const SadMxNFunc sad64x64_sse2 = vpx_sad64x64_sse2;\n+const SadMxNFunc sad64x32_sse2 = vpx_sad64x32_sse2;\n+const SadMxNFunc sad32x64_sse2 = vpx_sad32x64_sse2;\n+const SadMxNFunc sad32x32_sse2 = vpx_sad32x32_sse2;\n+const SadMxNFunc sad32x16_sse2 = vpx_sad32x16_sse2;\n+const SadMxNFunc sad16x32_sse2 = vpx_sad16x32_sse2;\n+const SadMxNFunc sad16x16_sse2 = vpx_sad16x16_sse2;\n+const SadMxNFunc sad16x8_sse2 = vpx_sad16x8_sse2;\n+const SadMxNFunc sad8x16_sse2 = vpx_sad8x16_sse2;\n+const SadMxNFunc sad8x8_sse2 = vpx_sad8x8_sse2;\n+const SadMxNFunc sad8x4_sse2 = vpx_sad8x4_sse2;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+const SadMxNFunc highbd_sad64x64_sse2 = vpx_highbd_sad64x64_sse2;\n+const SadMxNFunc highbd_sad64x32_sse2 = vpx_highbd_sad64x32_sse2;\n+const SadMxNFunc highbd_sad32x64_sse2 = vpx_highbd_sad32x64_sse2;\n+const SadMxNFunc highbd_sad32x32_sse2 = vpx_highbd_sad32x32_sse2;\n+const SadMxNFunc highbd_sad32x16_sse2 = vpx_highbd_sad32x16_sse2;\n+const SadMxNFunc highbd_sad16x32_sse2 = vpx_highbd_sad16x32_sse2;\n+const SadMxNFunc highbd_sad16x16_sse2 = vpx_highbd_sad16x16_sse2;\n+const SadMxNFunc highbd_sad16x8_sse2 = vpx_highbd_sad16x8_sse2;\n+const SadMxNFunc highbd_sad8x16_sse2 = vpx_highbd_sad8x16_sse2;\n+const SadMxNFunc highbd_sad8x8_sse2 = vpx_highbd_sad8x8_sse2;\n+const SadMxNFunc highbd_sad8x4_sse2 = vpx_highbd_sad8x4_sse2;\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+const SadMxNParam sse2_tests[] = {\n+  make_tuple(64, 64, sad64x64_sse2, -1),\n+  make_tuple(64, 32, sad64x32_sse2, -1),\n+  make_tuple(32, 64, sad32x64_sse2, -1),\n+  make_tuple(32, 32, sad32x32_sse2, -1),\n+  make_tuple(32, 16, sad32x16_sse2, -1),\n+  make_tuple(16, 32, sad16x32_sse2, -1),\n+  make_tuple(16, 16, sad16x16_sse2, -1),\n+  make_tuple(16, 8, sad16x8_sse2, -1),\n+  make_tuple(8, 16, sad8x16_sse2, -1),\n+  make_tuple(8, 8, sad8x8_sse2, -1),\n+  make_tuple(8, 4, sad8x4_sse2, -1),\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  make_tuple(64, 64, highbd_sad64x64_sse2, 8),\n+  make_tuple(64, 32, highbd_sad64x32_sse2, 8),\n+  make_tuple(32, 64, highbd_sad32x64_sse2, 8),\n+  make_tuple(32, 32, highbd_sad32x32_sse2, 8),\n+  make_tuple(32, 16, highbd_sad32x16_sse2, 8),\n+  make_tuple(16, 32, highbd_sad16x32_sse2, 8),\n+  make_tuple(16, 16, highbd_sad16x16_sse2, 8),\n+  make_tuple(16, 8, highbd_sad16x8_sse2, 8),\n+  make_tuple(8, 16, highbd_sad8x16_sse2, 8),\n+  make_tuple(8, 8, highbd_sad8x8_sse2, 8),\n+  make_tuple(8, 4, highbd_sad8x4_sse2, 8),\n+  make_tuple(64, 64, highbd_sad64x64_sse2, 10),\n+  make_tuple(64, 32, highbd_sad64x32_sse2, 10),\n+  make_tuple(32, 64, highbd_sad32x64_sse2, 10),\n+  make_tuple(32, 32, highbd_sad32x32_sse2, 10),\n+  make_tuple(32, 16, highbd_sad32x16_sse2, 10),\n+  make_tuple(16, 32, highbd_sad16x32_sse2, 10),\n+  make_tuple(16, 16, highbd_sad16x16_sse2, 10),\n+  make_tuple(16, 8, highbd_sad16x8_sse2, 10),\n+  make_tuple(8, 16, highbd_sad8x16_sse2, 10),\n+  make_tuple(8, 8, highbd_sad8x8_sse2, 10),\n+  make_tuple(8, 4, highbd_sad8x4_sse2, 10),\n+  make_tuple(64, 64, highbd_sad64x64_sse2, 12),\n+  make_tuple(64, 32, highbd_sad64x32_sse2, 12),\n+  make_tuple(32, 64, highbd_sad32x64_sse2, 12),\n+  make_tuple(32, 32, highbd_sad32x32_sse2, 12),\n+  make_tuple(32, 16, highbd_sad32x16_sse2, 12),\n+  make_tuple(16, 32, highbd_sad16x32_sse2, 12),\n+  make_tuple(16, 16, highbd_sad16x16_sse2, 12),\n+  make_tuple(16, 8, highbd_sad16x8_sse2, 12),\n+  make_tuple(8, 16, highbd_sad8x16_sse2, 12),\n+  make_tuple(8, 8, highbd_sad8x8_sse2, 12),\n+  make_tuple(8, 4, highbd_sad8x4_sse2, 12),\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n };\n INSTANTIATE_TEST_CASE_P(SSE2, SADTest, ::testing::ValuesIn(sse2_tests));\n \n-#if CONFIG_VP9_ENCODER\n-#if CONFIG_USE_X86INC\n-const sad_n_by_n_by_4_fn_t sad_64x64x4d_sse2 = vp9_sad64x64x4d_sse2;\n-const sad_n_by_n_by_4_fn_t sad_64x32x4d_sse2 = vp9_sad64x32x4d_sse2;\n-const sad_n_by_n_by_4_fn_t sad_32x64x4d_sse2 = vp9_sad32x64x4d_sse2;\n-const sad_n_by_n_by_4_fn_t sad_32x32x4d_sse2 = vp9_sad32x32x4d_sse2;\n-const sad_n_by_n_by_4_fn_t sad_32x16x4d_sse2 = vp9_sad32x16x4d_sse2;\n-const sad_n_by_n_by_4_fn_t sad_16x32x4d_sse2 = vp9_sad16x32x4d_sse2;\n-const sad_n_by_n_by_4_fn_t sad_16x16x4d_sse2 = vp9_sad16x16x4d_sse2;\n-const sad_n_by_n_by_4_fn_t sad_16x8x4d_sse2 = vp9_sad16x8x4d_sse2;\n-const sad_n_by_n_by_4_fn_t sad_8x16x4d_sse2 = vp9_sad8x16x4d_sse2;\n-const sad_n_by_n_by_4_fn_t sad_8x8x4d_sse2 = vp9_sad8x8x4d_sse2;\n-const sad_n_by_n_by_4_fn_t sad_8x4x4d_sse2 = vp9_sad8x4x4d_sse2;\n-INSTANTIATE_TEST_CASE_P(SSE2, SADx4Test, ::testing::Values(\n-                        make_tuple(64, 64, sad_64x64x4d_sse2),\n-                        make_tuple(64, 32, sad_64x32x4d_sse2),\n-                        make_tuple(32, 64, sad_32x64x4d_sse2),\n-                        make_tuple(32, 32, sad_32x32x4d_sse2),\n-                        make_tuple(32, 16, sad_32x16x4d_sse2),\n-                        make_tuple(16, 32, sad_16x32x4d_sse2),\n-                        make_tuple(16, 16, sad_16x16x4d_sse2),\n-                        make_tuple(16, 8, sad_16x8x4d_sse2),\n-                        make_tuple(8, 16, sad_8x16x4d_sse2),\n-                        make_tuple(8, 8, sad_8x8x4d_sse2),\n-                        make_tuple(8, 4, sad_8x4x4d_sse2)));\n-#endif\n-#endif\n-#endif\n+const SadMxNAvgFunc sad64x64_avg_sse2 = vpx_sad64x64_avg_sse2;\n+const SadMxNAvgFunc sad64x32_avg_sse2 = vpx_sad64x32_avg_sse2;\n+const SadMxNAvgFunc sad32x64_avg_sse2 = vpx_sad32x64_avg_sse2;\n+const SadMxNAvgFunc sad32x32_avg_sse2 = vpx_sad32x32_avg_sse2;\n+const SadMxNAvgFunc sad32x16_avg_sse2 = vpx_sad32x16_avg_sse2;\n+const SadMxNAvgFunc sad16x32_avg_sse2 = vpx_sad16x32_avg_sse2;\n+const SadMxNAvgFunc sad16x16_avg_sse2 = vpx_sad16x16_avg_sse2;\n+const SadMxNAvgFunc sad16x8_avg_sse2 = vpx_sad16x8_avg_sse2;\n+const SadMxNAvgFunc sad8x16_avg_sse2 = vpx_sad8x16_avg_sse2;\n+const SadMxNAvgFunc sad8x8_avg_sse2 = vpx_sad8x8_avg_sse2;\n+const SadMxNAvgFunc sad8x4_avg_sse2 = vpx_sad8x4_avg_sse2;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+const SadMxNAvgFunc highbd_sad64x64_avg_sse2 = vpx_highbd_sad64x64_avg_sse2;\n+const SadMxNAvgFunc highbd_sad64x32_avg_sse2 = vpx_highbd_sad64x32_avg_sse2;\n+const SadMxNAvgFunc highbd_sad32x64_avg_sse2 = vpx_highbd_sad32x64_avg_sse2;\n+const SadMxNAvgFunc highbd_sad32x32_avg_sse2 = vpx_highbd_sad32x32_avg_sse2;\n+const SadMxNAvgFunc highbd_sad32x16_avg_sse2 = vpx_highbd_sad32x16_avg_sse2;\n+const SadMxNAvgFunc highbd_sad16x32_avg_sse2 = vpx_highbd_sad16x32_avg_sse2;\n+const SadMxNAvgFunc highbd_sad16x16_avg_sse2 = vpx_highbd_sad16x16_avg_sse2;\n+const SadMxNAvgFunc highbd_sad16x8_avg_sse2 = vpx_highbd_sad16x8_avg_sse2;\n+const SadMxNAvgFunc highbd_sad8x16_avg_sse2 = vpx_highbd_sad8x16_avg_sse2;\n+const SadMxNAvgFunc highbd_sad8x8_avg_sse2 = vpx_highbd_sad8x8_avg_sse2;\n+const SadMxNAvgFunc highbd_sad8x4_avg_sse2 = vpx_highbd_sad8x4_avg_sse2;\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+const SadMxNAvgParam avg_sse2_tests[] = {\n+  make_tuple(64, 64, sad64x64_avg_sse2, -1),\n+  make_tuple(64, 32, sad64x32_avg_sse2, -1),\n+  make_tuple(32, 64, sad32x64_avg_sse2, -1),\n+  make_tuple(32, 32, sad32x32_avg_sse2, -1),\n+  make_tuple(32, 16, sad32x16_avg_sse2, -1),\n+  make_tuple(16, 32, sad16x32_avg_sse2, -1),\n+  make_tuple(16, 16, sad16x16_avg_sse2, -1),\n+  make_tuple(16, 8, sad16x8_avg_sse2, -1),\n+  make_tuple(8, 16, sad8x16_avg_sse2, -1),\n+  make_tuple(8, 8, sad8x8_avg_sse2, -1),\n+  make_tuple(8, 4, sad8x4_avg_sse2, -1),\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  make_tuple(64, 64, highbd_sad64x64_avg_sse2, 8),\n+  make_tuple(64, 32, highbd_sad64x32_avg_sse2, 8),\n+  make_tuple(32, 64, highbd_sad32x64_avg_sse2, 8),\n+  make_tuple(32, 32, highbd_sad32x32_avg_sse2, 8),\n+  make_tuple(32, 16, highbd_sad32x16_avg_sse2, 8),\n+  make_tuple(16, 32, highbd_sad16x32_avg_sse2, 8),\n+  make_tuple(16, 16, highbd_sad16x16_avg_sse2, 8),\n+  make_tuple(16, 8, highbd_sad16x8_avg_sse2, 8),\n+  make_tuple(8, 16, highbd_sad8x16_avg_sse2, 8),\n+  make_tuple(8, 8, highbd_sad8x8_avg_sse2, 8),\n+  make_tuple(8, 4, highbd_sad8x4_avg_sse2, 8),\n+  make_tuple(64, 64, highbd_sad64x64_avg_sse2, 10),\n+  make_tuple(64, 32, highbd_sad64x32_avg_sse2, 10),\n+  make_tuple(32, 64, highbd_sad32x64_avg_sse2, 10),\n+  make_tuple(32, 32, highbd_sad32x32_avg_sse2, 10),\n+  make_tuple(32, 16, highbd_sad32x16_avg_sse2, 10),\n+  make_tuple(16, 32, highbd_sad16x32_avg_sse2, 10),\n+  make_tuple(16, 16, highbd_sad16x16_avg_sse2, 10),\n+  make_tuple(16, 8, highbd_sad16x8_avg_sse2, 10),\n+  make_tuple(8, 16, highbd_sad8x16_avg_sse2, 10),\n+  make_tuple(8, 8, highbd_sad8x8_avg_sse2, 10),\n+  make_tuple(8, 4, highbd_sad8x4_avg_sse2, 10),\n+  make_tuple(64, 64, highbd_sad64x64_avg_sse2, 12),\n+  make_tuple(64, 32, highbd_sad64x32_avg_sse2, 12),\n+  make_tuple(32, 64, highbd_sad32x64_avg_sse2, 12),\n+  make_tuple(32, 32, highbd_sad32x32_avg_sse2, 12),\n+  make_tuple(32, 16, highbd_sad32x16_avg_sse2, 12),\n+  make_tuple(16, 32, highbd_sad16x32_avg_sse2, 12),\n+  make_tuple(16, 16, highbd_sad16x16_avg_sse2, 12),\n+  make_tuple(16, 8, highbd_sad16x8_avg_sse2, 12),\n+  make_tuple(8, 16, highbd_sad8x16_avg_sse2, 12),\n+  make_tuple(8, 8, highbd_sad8x8_avg_sse2, 12),\n+  make_tuple(8, 4, highbd_sad8x4_avg_sse2, 12),\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+};\n+INSTANTIATE_TEST_CASE_P(SSE2, SADavgTest, ::testing::ValuesIn(avg_sse2_tests));\n+\n+const SadMxNx4Func sad64x64x4d_sse2 = vpx_sad64x64x4d_sse2;\n+const SadMxNx4Func sad64x32x4d_sse2 = vpx_sad64x32x4d_sse2;\n+const SadMxNx4Func sad32x64x4d_sse2 = vpx_sad32x64x4d_sse2;\n+const SadMxNx4Func sad32x32x4d_sse2 = vpx_sad32x32x4d_sse2;\n+const SadMxNx4Func sad32x16x4d_sse2 = vpx_sad32x16x4d_sse2;\n+const SadMxNx4Func sad16x32x4d_sse2 = vpx_sad16x32x4d_sse2;\n+const SadMxNx4Func sad16x16x4d_sse2 = vpx_sad16x16x4d_sse2;\n+const SadMxNx4Func sad16x8x4d_sse2 = vpx_sad16x8x4d_sse2;\n+const SadMxNx4Func sad8x16x4d_sse2 = vpx_sad8x16x4d_sse2;\n+const SadMxNx4Func sad8x8x4d_sse2 = vpx_sad8x8x4d_sse2;\n+const SadMxNx4Func sad8x4x4d_sse2 = vpx_sad8x4x4d_sse2;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+const SadMxNx4Func highbd_sad64x64x4d_sse2 = vpx_highbd_sad64x64x4d_sse2;\n+const SadMxNx4Func highbd_sad64x32x4d_sse2 = vpx_highbd_sad64x32x4d_sse2;\n+const SadMxNx4Func highbd_sad32x64x4d_sse2 = vpx_highbd_sad32x64x4d_sse2;\n+const SadMxNx4Func highbd_sad32x32x4d_sse2 = vpx_highbd_sad32x32x4d_sse2;\n+const SadMxNx4Func highbd_sad32x16x4d_sse2 = vpx_highbd_sad32x16x4d_sse2;\n+const SadMxNx4Func highbd_sad16x32x4d_sse2 = vpx_highbd_sad16x32x4d_sse2;\n+const SadMxNx4Func highbd_sad16x16x4d_sse2 = vpx_highbd_sad16x16x4d_sse2;\n+const SadMxNx4Func highbd_sad16x8x4d_sse2 = vpx_highbd_sad16x8x4d_sse2;\n+const SadMxNx4Func highbd_sad8x16x4d_sse2 = vpx_highbd_sad8x16x4d_sse2;\n+const SadMxNx4Func highbd_sad8x8x4d_sse2 = vpx_highbd_sad8x8x4d_sse2;\n+const SadMxNx4Func highbd_sad8x4x4d_sse2 = vpx_highbd_sad8x4x4d_sse2;\n+const SadMxNx4Func highbd_sad4x8x4d_sse2 = vpx_highbd_sad4x8x4d_sse2;\n+const SadMxNx4Func highbd_sad4x4x4d_sse2 = vpx_highbd_sad4x4x4d_sse2;\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+const SadMxNx4Param x4d_sse2_tests[] = {\n+  make_tuple(64, 64, sad64x64x4d_sse2, -1),\n+  make_tuple(64, 32, sad64x32x4d_sse2, -1),\n+  make_tuple(32, 64, sad32x64x4d_sse2, -1),\n+  make_tuple(32, 32, sad32x32x4d_sse2, -1),\n+  make_tuple(32, 16, sad32x16x4d_sse2, -1),\n+  make_tuple(16, 32, sad16x32x4d_sse2, -1),\n+  make_tuple(16, 16, sad16x16x4d_sse2, -1),\n+  make_tuple(16, 8, sad16x8x4d_sse2, -1),\n+  make_tuple(8, 16, sad8x16x4d_sse2, -1),\n+  make_tuple(8, 8, sad8x8x4d_sse2, -1),\n+  make_tuple(8, 4, sad8x4x4d_sse2, -1),\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  make_tuple(64, 64, highbd_sad64x64x4d_sse2, 8),\n+  make_tuple(64, 32, highbd_sad64x32x4d_sse2, 8),\n+  make_tuple(32, 64, highbd_sad32x64x4d_sse2, 8),\n+  make_tuple(32, 32, highbd_sad32x32x4d_sse2, 8),\n+  make_tuple(32, 16, highbd_sad32x16x4d_sse2, 8),\n+  make_tuple(16, 32, highbd_sad16x32x4d_sse2, 8),\n+  make_tuple(16, 16, highbd_sad16x16x4d_sse2, 8),\n+  make_tuple(16, 8, highbd_sad16x8x4d_sse2, 8),\n+  make_tuple(8, 16, highbd_sad8x16x4d_sse2, 8),\n+  make_tuple(8, 8, highbd_sad8x8x4d_sse2, 8),\n+  make_tuple(8, 4, highbd_sad8x4x4d_sse2, 8),\n+  make_tuple(4, 8, highbd_sad4x8x4d_sse2, 8),\n+  make_tuple(4, 4, highbd_sad4x4x4d_sse2, 8),\n+  make_tuple(64, 64, highbd_sad64x64x4d_sse2, 10),\n+  make_tuple(64, 32, highbd_sad64x32x4d_sse2, 10),\n+  make_tuple(32, 64, highbd_sad32x64x4d_sse2, 10),\n+  make_tuple(32, 32, highbd_sad32x32x4d_sse2, 10),\n+  make_tuple(32, 16, highbd_sad32x16x4d_sse2, 10),\n+  make_tuple(16, 32, highbd_sad16x32x4d_sse2, 10),\n+  make_tuple(16, 16, highbd_sad16x16x4d_sse2, 10),\n+  make_tuple(16, 8, highbd_sad16x8x4d_sse2, 10),\n+  make_tuple(8, 16, highbd_sad8x16x4d_sse2, 10),\n+  make_tuple(8, 8, highbd_sad8x8x4d_sse2, 10),\n+  make_tuple(8, 4, highbd_sad8x4x4d_sse2, 10),\n+  make_tuple(4, 8, highbd_sad4x8x4d_sse2, 10),\n+  make_tuple(4, 4, highbd_sad4x4x4d_sse2, 10),\n+  make_tuple(64, 64, highbd_sad64x64x4d_sse2, 12),\n+  make_tuple(64, 32, highbd_sad64x32x4d_sse2, 12),\n+  make_tuple(32, 64, highbd_sad32x64x4d_sse2, 12),\n+  make_tuple(32, 32, highbd_sad32x32x4d_sse2, 12),\n+  make_tuple(32, 16, highbd_sad32x16x4d_sse2, 12),\n+  make_tuple(16, 32, highbd_sad16x32x4d_sse2, 12),\n+  make_tuple(16, 16, highbd_sad16x16x4d_sse2, 12),\n+  make_tuple(16, 8, highbd_sad16x8x4d_sse2, 12),\n+  make_tuple(8, 16, highbd_sad8x16x4d_sse2, 12),\n+  make_tuple(8, 8, highbd_sad8x8x4d_sse2, 12),\n+  make_tuple(8, 4, highbd_sad8x4x4d_sse2, 12),\n+  make_tuple(4, 8, highbd_sad4x8x4d_sse2, 12),\n+  make_tuple(4, 4, highbd_sad4x4x4d_sse2, 12),\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+};\n+INSTANTIATE_TEST_CASE_P(SSE2, SADx4Test, ::testing::ValuesIn(x4d_sse2_tests));\n+#endif  // CONFIG_USE_X86INC\n+#endif  // HAVE_SSE2\n \n #if HAVE_SSE3\n-#if CONFIG_VP8_ENCODER\n-const sad_n_by_n_by_4_fn_t sad_16x16x4d_sse3 = vp8_sad16x16x4d_sse3;\n-const sad_n_by_n_by_4_fn_t sad_16x8x4d_sse3 = vp8_sad16x8x4d_sse3;\n-const sad_n_by_n_by_4_fn_t sad_8x16x4d_sse3 = vp8_sad8x16x4d_sse3;\n-const sad_n_by_n_by_4_fn_t sad_8x8x4d_sse3 = vp8_sad8x8x4d_sse3;\n-const sad_n_by_n_by_4_fn_t sad_4x4x4d_sse3 = vp8_sad4x4x4d_sse3;\n-INSTANTIATE_TEST_CASE_P(SSE3, SADx4Test, ::testing::Values(\n-                        make_tuple(16, 16, sad_16x16x4d_sse3),\n-                        make_tuple(16, 8, sad_16x8x4d_sse3),\n-                        make_tuple(8, 16, sad_8x16x4d_sse3),\n-                        make_tuple(8, 8, sad_8x8x4d_sse3),\n-                        make_tuple(4, 4, sad_4x4x4d_sse3)));\n-#endif\n-#endif\n+// Only functions are x3, which do not have tests.\n+#endif  // HAVE_SSE3\n \n #if HAVE_SSSE3\n-#if CONFIG_USE_X86INC\n-#if CONFIG_VP8_ENCODER\n-const sad_m_by_n_fn_t sad_16x16_sse3 = vp8_sad16x16_sse3;\n-INSTANTIATE_TEST_CASE_P(SSE3, SADTest, ::testing::Values(\n-                        make_tuple(16, 16, sad_16x16_sse3)));\n-#endif\n-#endif\n-#endif\n+// Only functions are x3, which do not have tests.\n+#endif  // HAVE_SSSE3\n+\n+#if HAVE_SSE4_1\n+// Only functions are x8, which do not have tests.\n+#endif  // HAVE_SSE4_1\n+\n+#if HAVE_AVX2\n+const SadMxNFunc sad64x64_avx2 = vpx_sad64x64_avx2;\n+const SadMxNFunc sad64x32_avx2 = vpx_sad64x32_avx2;\n+const SadMxNFunc sad32x64_avx2 = vpx_sad32x64_avx2;\n+const SadMxNFunc sad32x32_avx2 = vpx_sad32x32_avx2;\n+const SadMxNFunc sad32x16_avx2 = vpx_sad32x16_avx2;\n+const SadMxNParam avx2_tests[] = {\n+  make_tuple(64, 64, sad64x64_avx2, -1),\n+  make_tuple(64, 32, sad64x32_avx2, -1),\n+  make_tuple(32, 64, sad32x64_avx2, -1),\n+  make_tuple(32, 32, sad32x32_avx2, -1),\n+  make_tuple(32, 16, sad32x16_avx2, -1),\n+};\n+INSTANTIATE_TEST_CASE_P(AVX2, SADTest, ::testing::ValuesIn(avx2_tests));\n+\n+const SadMxNAvgFunc sad64x64_avg_avx2 = vpx_sad64x64_avg_avx2;\n+const SadMxNAvgFunc sad64x32_avg_avx2 = vpx_sad64x32_avg_avx2;\n+const SadMxNAvgFunc sad32x64_avg_avx2 = vpx_sad32x64_avg_avx2;\n+const SadMxNAvgFunc sad32x32_avg_avx2 = vpx_sad32x32_avg_avx2;\n+const SadMxNAvgFunc sad32x16_avg_avx2 = vpx_sad32x16_avg_avx2;\n+const SadMxNAvgParam avg_avx2_tests[] = {\n+  make_tuple(64, 64, sad64x64_avg_avx2, -1),\n+  make_tuple(64, 32, sad64x32_avg_avx2, -1),\n+  make_tuple(32, 64, sad32x64_avg_avx2, -1),\n+  make_tuple(32, 32, sad32x32_avg_avx2, -1),\n+  make_tuple(32, 16, sad32x16_avg_avx2, -1),\n+};\n+INSTANTIATE_TEST_CASE_P(AVX2, SADavgTest, ::testing::ValuesIn(avg_avx2_tests));\n+\n+const SadMxNx4Func sad64x64x4d_avx2 = vpx_sad64x64x4d_avx2;\n+const SadMxNx4Func sad32x32x4d_avx2 = vpx_sad32x32x4d_avx2;\n+const SadMxNx4Param x4d_avx2_tests[] = {\n+  make_tuple(64, 64, sad64x64x4d_avx2, -1),\n+  make_tuple(32, 32, sad32x32x4d_avx2, -1),\n+};\n+INSTANTIATE_TEST_CASE_P(AVX2, SADx4Test, ::testing::ValuesIn(x4d_avx2_tests));\n+#endif  // HAVE_AVX2\n+\n+//------------------------------------------------------------------------------\n+// MIPS functions\n+#if HAVE_MSA\n+const SadMxNFunc sad64x64_msa = vpx_sad64x64_msa;\n+const SadMxNFunc sad64x32_msa = vpx_sad64x32_msa;\n+const SadMxNFunc sad32x64_msa = vpx_sad32x64_msa;\n+const SadMxNFunc sad32x32_msa = vpx_sad32x32_msa;\n+const SadMxNFunc sad32x16_msa = vpx_sad32x16_msa;\n+const SadMxNFunc sad16x32_msa = vpx_sad16x32_msa;\n+const SadMxNFunc sad16x16_msa = vpx_sad16x16_msa;\n+const SadMxNFunc sad16x8_msa = vpx_sad16x8_msa;\n+const SadMxNFunc sad8x16_msa = vpx_sad8x16_msa;\n+const SadMxNFunc sad8x8_msa = vpx_sad8x8_msa;\n+const SadMxNFunc sad8x4_msa = vpx_sad8x4_msa;\n+const SadMxNFunc sad4x8_msa = vpx_sad4x8_msa;\n+const SadMxNFunc sad4x4_msa = vpx_sad4x4_msa;\n+const SadMxNParam msa_tests[] = {\n+  make_tuple(64, 64, sad64x64_msa, -1),\n+  make_tuple(64, 32, sad64x32_msa, -1),\n+  make_tuple(32, 64, sad32x64_msa, -1),\n+  make_tuple(32, 32, sad32x32_msa, -1),\n+  make_tuple(32, 16, sad32x16_msa, -1),\n+  make_tuple(16, 32, sad16x32_msa, -1),\n+  make_tuple(16, 16, sad16x16_msa, -1),\n+  make_tuple(16, 8, sad16x8_msa, -1),\n+  make_tuple(8, 16, sad8x16_msa, -1),\n+  make_tuple(8, 8, sad8x8_msa, -1),\n+  make_tuple(8, 4, sad8x4_msa, -1),\n+  make_tuple(4, 8, sad4x8_msa, -1),\n+  make_tuple(4, 4, sad4x4_msa, -1),\n+};\n+INSTANTIATE_TEST_CASE_P(MSA, SADTest, ::testing::ValuesIn(msa_tests));\n+\n+const SadMxNAvgFunc sad64x64_avg_msa = vpx_sad64x64_avg_msa;\n+const SadMxNAvgFunc sad64x32_avg_msa = vpx_sad64x32_avg_msa;\n+const SadMxNAvgFunc sad32x64_avg_msa = vpx_sad32x64_avg_msa;\n+const SadMxNAvgFunc sad32x32_avg_msa = vpx_sad32x32_avg_msa;\n+const SadMxNAvgFunc sad32x16_avg_msa = vpx_sad32x16_avg_msa;\n+const SadMxNAvgFunc sad16x32_avg_msa = vpx_sad16x32_avg_msa;\n+const SadMxNAvgFunc sad16x16_avg_msa = vpx_sad16x16_avg_msa;\n+const SadMxNAvgFunc sad16x8_avg_msa = vpx_sad16x8_avg_msa;\n+const SadMxNAvgFunc sad8x16_avg_msa = vpx_sad8x16_avg_msa;\n+const SadMxNAvgFunc sad8x8_avg_msa = vpx_sad8x8_avg_msa;\n+const SadMxNAvgFunc sad8x4_avg_msa = vpx_sad8x4_avg_msa;\n+const SadMxNAvgFunc sad4x8_avg_msa = vpx_sad4x8_avg_msa;\n+const SadMxNAvgFunc sad4x4_avg_msa = vpx_sad4x4_avg_msa;\n+const SadMxNAvgParam avg_msa_tests[] = {\n+  make_tuple(64, 64, sad64x64_avg_msa, -1),\n+  make_tuple(64, 32, sad64x32_avg_msa, -1),\n+  make_tuple(32, 64, sad32x64_avg_msa, -1),\n+  make_tuple(32, 32, sad32x32_avg_msa, -1),\n+  make_tuple(32, 16, sad32x16_avg_msa, -1),\n+  make_tuple(16, 32, sad16x32_avg_msa, -1),\n+  make_tuple(16, 16, sad16x16_avg_msa, -1),\n+  make_tuple(16, 8, sad16x8_avg_msa, -1),\n+  make_tuple(8, 16, sad8x16_avg_msa, -1),\n+  make_tuple(8, 8, sad8x8_avg_msa, -1),\n+  make_tuple(8, 4, sad8x4_avg_msa, -1),\n+  make_tuple(4, 8, sad4x8_avg_msa, -1),\n+  make_tuple(4, 4, sad4x4_avg_msa, -1),\n+};\n+INSTANTIATE_TEST_CASE_P(MSA, SADavgTest, ::testing::ValuesIn(avg_msa_tests));\n+\n+const SadMxNx4Func sad64x64x4d_msa = vpx_sad64x64x4d_msa;\n+const SadMxNx4Func sad64x32x4d_msa = vpx_sad64x32x4d_msa;\n+const SadMxNx4Func sad32x64x4d_msa = vpx_sad32x64x4d_msa;\n+const SadMxNx4Func sad32x32x4d_msa = vpx_sad32x32x4d_msa;\n+const SadMxNx4Func sad32x16x4d_msa = vpx_sad32x16x4d_msa;\n+const SadMxNx4Func sad16x32x4d_msa = vpx_sad16x32x4d_msa;\n+const SadMxNx4Func sad16x16x4d_msa = vpx_sad16x16x4d_msa;\n+const SadMxNx4Func sad16x8x4d_msa = vpx_sad16x8x4d_msa;\n+const SadMxNx4Func sad8x16x4d_msa = vpx_sad8x16x4d_msa;\n+const SadMxNx4Func sad8x8x4d_msa = vpx_sad8x8x4d_msa;\n+const SadMxNx4Func sad8x4x4d_msa = vpx_sad8x4x4d_msa;\n+const SadMxNx4Func sad4x8x4d_msa = vpx_sad4x8x4d_msa;\n+const SadMxNx4Func sad4x4x4d_msa = vpx_sad4x4x4d_msa;\n+const SadMxNx4Param x4d_msa_tests[] = {\n+  make_tuple(64, 64, sad64x64x4d_msa, -1),\n+  make_tuple(64, 32, sad64x32x4d_msa, -1),\n+  make_tuple(32, 64, sad32x64x4d_msa, -1),\n+  make_tuple(32, 32, sad32x32x4d_msa, -1),\n+  make_tuple(32, 16, sad32x16x4d_msa, -1),\n+  make_tuple(16, 32, sad16x32x4d_msa, -1),\n+  make_tuple(16, 16, sad16x16x4d_msa, -1),\n+  make_tuple(16, 8, sad16x8x4d_msa, -1),\n+  make_tuple(8, 16, sad8x16x4d_msa, -1),\n+  make_tuple(8, 8, sad8x8x4d_msa, -1),\n+  make_tuple(8, 4, sad8x4x4d_msa, -1),\n+  make_tuple(4, 8, sad4x8x4d_msa, -1),\n+  make_tuple(4, 4, sad4x4x4d_msa, -1),\n+};\n+INSTANTIATE_TEST_CASE_P(MSA, SADx4Test, ::testing::ValuesIn(x4d_msa_tests));\n+#endif  // HAVE_MSA\n \n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/set_maps.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/set_maps.sh"", ""patch"": ""@@ -0,0 +1,59 @@\n\n+#!/bin/sh\n+##\n+##  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+##\n+##  Use of this source code is governed by a BSD-style license\n+##  that can be found in the LICENSE file in the root of the source\n+##  tree. An additional intellectual property rights grant can be found\n+##  in the file PATENTS.  All contributing project authors may\n+##  be found in the AUTHORS file in the root of the source tree.\n+##\n+##  This file tests the libvpx set_maps example. To add new tests to this file,\n+##  do the following:\n+##    1. Write a shell function (this is your test).\n+##    2. Add the function to set_maps_tests (on a new line).\n+##\n+. $(dirname $0)/tools_common.sh\n+\n+# Environment check: $YUV_RAW_INPUT is required, and set_maps must exist in\n+# $LIBVPX_BIN_PATH.\n+set_maps_verify_environment() {\n+  if [ ! -e \""${YUV_RAW_INPUT}\"" ]; then\n+    echo \""Libvpx test data must exist in LIBVPX_TEST_DATA_PATH.\""\n+    return 1\n+  fi\n+  if [ -z \""$(vpx_tool_path set_maps)\"" ]; then\n+    elog \""set_maps not found. It must exist in LIBVPX_BIN_PATH or its parent.\""\n+    return 1\n+  fi\n+}\n+\n+# Runs set_maps using the codec specified by $1.\n+set_maps() {\n+  local encoder=\""$(vpx_tool_path set_maps)\""\n+  local codec=\""$1\""\n+  local output_file=\""${VPX_TEST_OUTPUT_DIR}/set_maps_${codec}.ivf\""\n+\n+  eval \""${VPX_TEST_PREFIX}\"" \""${encoder}\"" \""${codec}\"" \""${YUV_RAW_INPUT_WIDTH}\"" \\\n+      \""${YUV_RAW_INPUT_HEIGHT}\"" \""${YUV_RAW_INPUT}\"" \""${output_file}\"" \\\n+      ${devnull}\n+\n+  [ -e \""${output_file}\"" ] || return 1\n+}\n+\n+set_maps_vp8() {\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+    set_maps vp8 || return 1\n+  fi\n+}\n+\n+set_maps_vp9() {\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+    set_maps vp9 || return 1\n+  fi\n+}\n+\n+set_maps_tests=\""set_maps_vp8\n+                set_maps_vp9\""\n+\n+run_tests set_maps_verify_environment \""${set_maps_tests}\""\n""}<_**next**_>{""filename"": ""libvpx/test/set_roi.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/set_roi.cc"", ""patch"": ""@@ -53,7 +53,7 @@\n\n   cpi.common.mb_rows = 240 >> 4;\n   cpi.common.mb_cols = 320 >> 4;\n   const int mbs = (cpi.common.mb_rows * cpi.common.mb_cols);\n-  vpx_memset(cpi.segment_feature_data, 0, sizeof(cpi.segment_feature_data));\n+  memset(cpi.segment_feature_data, 0, sizeof(cpi.segment_feature_data));\n \n   // Segment map\n   cpi.segmentation_map = reinterpret_cast<unsigned char *>(vpx_calloc(mbs, 1));\n@@ -61,9 +61,9 @@\n\n   // Allocate memory for the source memory map.\n   unsigned char *roi_map =\n     reinterpret_cast<unsigned char *>(vpx_calloc(mbs, 1));\n-  vpx_memset(&roi_map[mbs >> 2], 1, (mbs >> 2));\n-  vpx_memset(&roi_map[mbs >> 1], 2, (mbs >> 2));\n-  vpx_memset(&roi_map[mbs -(mbs >> 2)], 3, (mbs >> 2));\n+  memset(&roi_map[mbs >> 2], 1, (mbs >> 2));\n+  memset(&roi_map[mbs >> 1], 2, (mbs >> 2));\n+  memset(&roi_map[mbs -(mbs >> 2)], 3, (mbs >> 2));\n \n   // Do a test call with valid parameters.\n   int roi_retval = vp8_set_roimap(&cpi, roi_map, cpi.common.mb_rows,\n""}<_**next**_>{""filename"": ""libvpx/test/simple_decoder.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/simple_decoder.sh"", ""patch"": ""@@ -0,0 +1,61 @@\n\n+#!/bin/sh\n+##\n+##  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+##\n+##  Use of this source code is governed by a BSD-style license\n+##  that can be found in the LICENSE file in the root of the source\n+##  tree. An additional intellectual property rights grant can be found\n+##  in the file PATENTS.  All contributing project authors may\n+##  be found in the AUTHORS file in the root of the source tree.\n+##\n+##  This file tests the libvpx simple_decoder example code. To add new tests to\n+##  this file, do the following:\n+##    1. Write a shell function (this is your test).\n+##    2. Add the function to simple_decoder_tests (on a new line).\n+##\n+. $(dirname $0)/tools_common.sh\n+\n+# Environment check: Make sure input is available:\n+#   $VP8_IVF_FILE and $VP9_IVF_FILE are required.\n+simple_decoder_verify_environment() {\n+  if [ ! -e \""${VP8_IVF_FILE}\"" ] || [ ! -e \""${VP9_IVF_FILE}\"" ]; then\n+    echo \""Libvpx test data must exist in LIBVPX_TEST_DATA_PATH.\""\n+    return 1\n+  fi\n+}\n+\n+# Runs simple_decoder using $1 as input file. $2 is the codec name, and is used\n+# solely to name the output file.\n+simple_decoder() {\n+  local decoder=\""${LIBVPX_BIN_PATH}/simple_decoder${VPX_TEST_EXE_SUFFIX}\""\n+  local input_file=\""$1\""\n+  local codec=\""$2\""\n+  local output_file=\""${VPX_TEST_OUTPUT_DIR}/simple_decoder_${codec}.raw\""\n+\n+  if [ ! -x \""${decoder}\"" ]; then\n+    elog \""${decoder} does not exist or is not executable.\""\n+    return 1\n+  fi\n+\n+  eval \""${VPX_TEST_PREFIX}\"" \""${decoder}\"" \""${input_file}\"" \""${output_file}\"" \\\n+      ${devnull}\n+\n+  [ -e \""${output_file}\"" ] || return 1\n+}\n+\n+simple_decoder_vp8() {\n+  if [ \""$(vp8_decode_available)\"" = \""yes\"" ]; then\n+    simple_decoder \""${VP8_IVF_FILE}\"" vp8 || return 1\n+  fi\n+}\n+\n+simple_decoder_vp9() {\n+  if [ \""$(vp9_decode_available)\"" = \""yes\"" ]; then\n+    simple_decoder \""${VP9_IVF_FILE}\"" vp9 || return 1\n+  fi\n+}\n+\n+simple_decoder_tests=\""simple_decoder_vp8\n+                      simple_decoder_vp9\""\n+\n+run_tests simple_decoder_verify_environment \""${simple_decoder_tests}\""\n""}<_**next**_>{""filename"": ""libvpx/test/simple_encoder.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/simple_encoder.sh"", ""patch"": ""@@ -0,0 +1,62 @@\n\n+#!/bin/sh\n+##\n+##  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+##\n+##  Use of this source code is governed by a BSD-style license\n+##  that can be found in the LICENSE file in the root of the source\n+##  tree. An additional intellectual property rights grant can be found\n+##  in the file PATENTS.  All contributing project authors may\n+##  be found in the AUTHORS file in the root of the source tree.\n+##\n+##  This file tests the libvpx simple_encoder example. To add new tests to this\n+##  file, do the following:\n+##    1. Write a shell function (this is your test).\n+##    2. Add the function to simple_encoder_tests (on a new line).\n+##\n+. $(dirname $0)/tools_common.sh\n+\n+# Environment check: $YUV_RAW_INPUT is required.\n+simple_encoder_verify_environment() {\n+  if [ ! -e \""${YUV_RAW_INPUT}\"" ]; then\n+    echo \""Libvpx test data must exist in LIBVPX_TEST_DATA_PATH.\""\n+    return 1\n+  fi\n+}\n+\n+# Runs simple_encoder using the codec specified by $1.\n+simple_encoder() {\n+  local encoder=\""${LIBVPX_BIN_PATH}/simple_encoder${VPX_TEST_EXE_SUFFIX}\""\n+  local codec=\""$1\""\n+  local output_file=\""${VPX_TEST_OUTPUT_DIR}/simple_encoder_${codec}.ivf\""\n+\n+  if [ ! -x \""${encoder}\"" ]; then\n+    elog \""${encoder} does not exist or is not executable.\""\n+    return 1\n+  fi\n+\n+  eval \""${VPX_TEST_PREFIX}\"" \""${encoder}\"" \""${codec}\"" \""${YUV_RAW_INPUT_WIDTH}\"" \\\n+      \""${YUV_RAW_INPUT_HEIGHT}\"" \""${YUV_RAW_INPUT}\"" \""${output_file}\"" 9999 \\\n+      ${devnull}\n+\n+  [ -e \""${output_file}\"" ] || return 1\n+}\n+\n+simple_encoder_vp8() {\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+    simple_encoder vp8 || return 1\n+  fi\n+}\n+\n+# TODO(tomfinegan): Add a frame limit param to simple_encoder and enable this\n+# test. VP9 is just too slow right now: This test takes 4m30s+ on a fast\n+# machine.\n+DISABLED_simple_encoder_vp9() {\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+    simple_encoder vp9 || return 1\n+  fi\n+}\n+\n+simple_encoder_tests=\""simple_encoder_vp8\n+                      DISABLED_simple_encoder_vp9\""\n+\n+run_tests simple_encoder_verify_environment \""${simple_encoder_tests}\""\n""}<_**next**_>{""filename"": ""libvpx/test/sixtap_predict_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/sixtap_predict_test.cc"", ""patch"": ""@@ -11,29 +11,31 @@\n\n #include <math.h>\n #include <stdlib.h>\n #include <string.h>\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vpx_config.h\""\n+#include \""./vp8_rtcd.h\""\n #include \""test/acm_random.h\""\n #include \""test/clear_system_state.h\""\n #include \""test/register_state_check.h\""\n #include \""test/util.h\""\n-#include \""third_party/googletest/src/include/gtest/gtest.h\""\n-#include \""./vpx_config.h\""\n-#include \""./vp8_rtcd.h\""\n #include \""vpx/vpx_integer.h\""\n #include \""vpx_mem/vpx_mem.h\""\n \n namespace {\n \n-typedef void (*sixtap_predict_fn_t)(uint8_t *src_ptr,\n-                                    int  src_pixels_per_line,\n-                                    int  xoffset,\n-                                    int  yoffset,\n-                                    uint8_t *dst_ptr,\n-                                    int  dst_pitch);\n+typedef void (*SixtapPredictFunc)(uint8_t *src_ptr,\n+                                  int src_pixels_per_line,\n+                                  int xoffset,\n+                                  int yoffset,\n+                                  uint8_t *dst_ptr,\n+                                  int dst_pitch);\n \n-typedef std::tr1::tuple<int, int, sixtap_predict_fn_t> sixtap_predict_param_t;\n+typedef std::tr1::tuple<int, int, SixtapPredictFunc> SixtapPredictParam;\n \n class SixtapPredictTest\n-    : public ::testing::TestWithParam<sixtap_predict_param_t> {\n+    : public ::testing::TestWithParam<SixtapPredictParam> {\n  public:\n   static void SetUpTestCase() {\n     src_ = reinterpret_cast<uint8_t*>(vpx_memalign(kDataAlignment, kSrcSize));\n@@ -74,7 +76,7 @@\n\n \n   int width_;\n   int height_;\n-  sixtap_predict_fn_t sixtap_predict_;\n+  SixtapPredictFunc sixtap_predict_;\n   // The src stores the macroblock we will filter on, and makes it 1 byte larger\n   // in order to test unaligned access. The result is stored in dst and dst_c(c\n   // reference code result).\n@@ -143,8 +145,9 @@\n\n \n   uint8_t *src = const_cast<uint8_t*>(test_data);\n \n-  REGISTER_STATE_CHECK(sixtap_predict_(&src[kSrcStride * 2 + 2 + 1], kSrcStride,\n-                                       2, 2, dst_, kDstStride));\n+  ASM_REGISTER_STATE_CHECK(\n+      sixtap_predict_(&src[kSrcStride * 2 + 2 + 1], kSrcStride,\n+                      2, 2, dst_, kDstStride));\n \n   for (int i = 0; i < height_; ++i)\n     for (int j = 0; j < width_; ++j)\n@@ -169,7 +172,7 @@\n\n                                 xoffset, yoffset, dst_c_, kDstStride);\n \n       // Run test.\n-      REGISTER_STATE_CHECK(\n+      ASM_REGISTER_STATE_CHECK(\n           sixtap_predict_(&src_[kSrcStride * 2 + 2 + 1], kSrcStride,\n                           xoffset, yoffset, dst_, kDstStride));\n \n@@ -183,10 +186,10 @@\n\n \n using std::tr1::make_tuple;\n \n-const sixtap_predict_fn_t sixtap_16x16_c = vp8_sixtap_predict16x16_c;\n-const sixtap_predict_fn_t sixtap_8x8_c = vp8_sixtap_predict8x8_c;\n-const sixtap_predict_fn_t sixtap_8x4_c = vp8_sixtap_predict8x4_c;\n-const sixtap_predict_fn_t sixtap_4x4_c = vp8_sixtap_predict4x4_c;\n+const SixtapPredictFunc sixtap_16x16_c = vp8_sixtap_predict16x16_c;\n+const SixtapPredictFunc sixtap_8x8_c = vp8_sixtap_predict8x8_c;\n+const SixtapPredictFunc sixtap_8x4_c = vp8_sixtap_predict8x4_c;\n+const SixtapPredictFunc sixtap_4x4_c = vp8_sixtap_predict4x4_c;\n INSTANTIATE_TEST_CASE_P(\n     C, SixtapPredictTest, ::testing::Values(\n         make_tuple(16, 16, sixtap_16x16_c),\n@@ -194,9 +197,9 @@\n\n         make_tuple(8, 4, sixtap_8x4_c),\n         make_tuple(4, 4, sixtap_4x4_c)));\n #if HAVE_NEON\n-const sixtap_predict_fn_t sixtap_16x16_neon = vp8_sixtap_predict16x16_neon;\n-const sixtap_predict_fn_t sixtap_8x8_neon = vp8_sixtap_predict8x8_neon;\n-const sixtap_predict_fn_t sixtap_8x4_neon = vp8_sixtap_predict8x4_neon;\n+const SixtapPredictFunc sixtap_16x16_neon = vp8_sixtap_predict16x16_neon;\n+const SixtapPredictFunc sixtap_8x8_neon = vp8_sixtap_predict8x8_neon;\n+const SixtapPredictFunc sixtap_8x4_neon = vp8_sixtap_predict8x4_neon;\n INSTANTIATE_TEST_CASE_P(\n     DISABLED_NEON, SixtapPredictTest, ::testing::Values(\n         make_tuple(16, 16, sixtap_16x16_neon),\n@@ -204,10 +207,10 @@\n\n         make_tuple(8, 4, sixtap_8x4_neon)));\n #endif\n #if HAVE_MMX\n-const sixtap_predict_fn_t sixtap_16x16_mmx = vp8_sixtap_predict16x16_mmx;\n-const sixtap_predict_fn_t sixtap_8x8_mmx = vp8_sixtap_predict8x8_mmx;\n-const sixtap_predict_fn_t sixtap_8x4_mmx = vp8_sixtap_predict8x4_mmx;\n-const sixtap_predict_fn_t sixtap_4x4_mmx = vp8_sixtap_predict4x4_mmx;\n+const SixtapPredictFunc sixtap_16x16_mmx = vp8_sixtap_predict16x16_mmx;\n+const SixtapPredictFunc sixtap_8x8_mmx = vp8_sixtap_predict8x8_mmx;\n+const SixtapPredictFunc sixtap_8x4_mmx = vp8_sixtap_predict8x4_mmx;\n+const SixtapPredictFunc sixtap_4x4_mmx = vp8_sixtap_predict4x4_mmx;\n INSTANTIATE_TEST_CASE_P(\n     MMX, SixtapPredictTest, ::testing::Values(\n         make_tuple(16, 16, sixtap_16x16_mmx),\n@@ -216,9 +219,9 @@\n\n         make_tuple(4, 4, sixtap_4x4_mmx)));\n #endif\n #if HAVE_SSE2\n-const sixtap_predict_fn_t sixtap_16x16_sse2 = vp8_sixtap_predict16x16_sse2;\n-const sixtap_predict_fn_t sixtap_8x8_sse2 = vp8_sixtap_predict8x8_sse2;\n-const sixtap_predict_fn_t sixtap_8x4_sse2 = vp8_sixtap_predict8x4_sse2;\n+const SixtapPredictFunc sixtap_16x16_sse2 = vp8_sixtap_predict16x16_sse2;\n+const SixtapPredictFunc sixtap_8x8_sse2 = vp8_sixtap_predict8x8_sse2;\n+const SixtapPredictFunc sixtap_8x4_sse2 = vp8_sixtap_predict8x4_sse2;\n INSTANTIATE_TEST_CASE_P(\n     SSE2, SixtapPredictTest, ::testing::Values(\n         make_tuple(16, 16, sixtap_16x16_sse2),\n@@ -226,10 +229,10 @@\n\n         make_tuple(8, 4, sixtap_8x4_sse2)));\n #endif\n #if HAVE_SSSE3\n-const sixtap_predict_fn_t sixtap_16x16_ssse3 = vp8_sixtap_predict16x16_ssse3;\n-const sixtap_predict_fn_t sixtap_8x8_ssse3 = vp8_sixtap_predict8x8_ssse3;\n-const sixtap_predict_fn_t sixtap_8x4_ssse3 = vp8_sixtap_predict8x4_ssse3;\n-const sixtap_predict_fn_t sixtap_4x4_ssse3 = vp8_sixtap_predict4x4_ssse3;\n+const SixtapPredictFunc sixtap_16x16_ssse3 = vp8_sixtap_predict16x16_ssse3;\n+const SixtapPredictFunc sixtap_8x8_ssse3 = vp8_sixtap_predict8x8_ssse3;\n+const SixtapPredictFunc sixtap_8x4_ssse3 = vp8_sixtap_predict8x4_ssse3;\n+const SixtapPredictFunc sixtap_4x4_ssse3 = vp8_sixtap_predict4x4_ssse3;\n INSTANTIATE_TEST_CASE_P(\n     SSSE3, SixtapPredictTest, ::testing::Values(\n         make_tuple(16, 16, sixtap_16x16_ssse3),\n@@ -237,4 +240,16 @@\n\n         make_tuple(8, 4, sixtap_8x4_ssse3),\n         make_tuple(4, 4, sixtap_4x4_ssse3)));\n #endif\n+#if HAVE_MSA\n+const SixtapPredictFunc sixtap_16x16_msa = vp8_sixtap_predict16x16_msa;\n+const SixtapPredictFunc sixtap_8x8_msa = vp8_sixtap_predict8x8_msa;\n+const SixtapPredictFunc sixtap_8x4_msa = vp8_sixtap_predict8x4_msa;\n+const SixtapPredictFunc sixtap_4x4_msa = vp8_sixtap_predict4x4_msa;\n+INSTANTIATE_TEST_CASE_P(\n+    MSA, SixtapPredictTest, ::testing::Values(\n+        make_tuple(16, 16, sixtap_16x16_msa),\n+        make_tuple(8, 8, sixtap_8x8_msa),\n+        make_tuple(8, 4, sixtap_8x4_msa),\n+        make_tuple(4, 4, sixtap_4x4_msa)));\n+#endif\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/superframe_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/superframe_test.cc"", ""patch"": ""@@ -94,4 +94,7 @@\n\n \n VP9_INSTANTIATE_TEST_CASE(SuperframeTest, ::testing::Values(\n     ::libvpx_test::kTwoPassGood));\n+\n+VP10_INSTANTIATE_TEST_CASE(SuperframeTest, ::testing::Values(\n+    ::libvpx_test::kTwoPassGood));\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/svc_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/svc_test.cc"", ""patch"": ""@@ -13,6 +13,9 @@\n\n #include \""test/codec_factory.h\""\n #include \""test/decode_test_driver.h\""\n #include \""test/i420_video_source.h\""\n+\n+#include \""vp9/decoder/vp9_decoder.h\""\n+\n #include \""vpx/svc_context.h\""\n #include \""vpx/vp8cx.h\""\n #include \""vpx/vpx_encoder.h\""\n@@ -21,6 +24,7 @@\n\n \n using libvpx_test::CodecFactory;\n using libvpx_test::Decoder;\n+using libvpx_test::DxDataIterator;\n using libvpx_test::VP9CodecFactory;\n \n class SvcTest : public ::testing::Test {\n@@ -31,7 +35,6 @@\n\n   SvcTest()\n       : codec_iface_(0),\n         test_file_name_(\""hantro_collage_w352h288.yuv\""),\n-        stats_file_name_(\""hantro_collage_w352h288.stat\""),\n         codec_initialized_(false),\n         decoder_(0) {\n     memset(&svc_, 0, sizeof(svc_));\n@@ -42,7 +45,6 @@\n\n   virtual ~SvcTest() {}\n \n   virtual void SetUp() {\n-    svc_.encoding_mode = INTER_LAYER_PREDICTION_IP;\n     svc_.log_level = SVC_LOG_DEBUG;\n     svc_.log_print = 0;\n \n@@ -58,15 +60,254 @@\n\n     codec_enc_.kf_min_dist = 100;\n     codec_enc_.kf_max_dist = 100;\n \n-    vpx_codec_dec_cfg_t dec_cfg = {0};\n+    vpx_codec_dec_cfg_t dec_cfg = vpx_codec_dec_cfg_t();\n     VP9CodecFactory codec_factory;\n     decoder_ = codec_factory.CreateDecoder(dec_cfg, 0);\n+\n+    tile_columns_ = 0;\n+    tile_rows_ = 0;\n   }\n \n   virtual void TearDown() {\n-    vpx_svc_release(&svc_);\n+    ReleaseEncoder();\n     delete(decoder_);\n+  }\n+\n+  void InitializeEncoder() {\n+    const vpx_codec_err_t res =\n+        vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n+    EXPECT_EQ(VPX_CODEC_OK, res);\n+    vpx_codec_control(&codec_, VP8E_SET_CPUUSED, 4);  // Make the test faster\n+    vpx_codec_control(&codec_, VP9E_SET_TILE_COLUMNS, tile_columns_);\n+    vpx_codec_control(&codec_, VP9E_SET_TILE_ROWS, tile_rows_);\n+    codec_initialized_ = true;\n+  }\n+\n+  void ReleaseEncoder() {\n+    vpx_svc_release(&svc_);\n     if (codec_initialized_) vpx_codec_destroy(&codec_);\n+    codec_initialized_ = false;\n+  }\n+\n+  void GetStatsData(std::string *const stats_buf) {\n+    vpx_codec_iter_t iter = NULL;\n+    const vpx_codec_cx_pkt_t *cx_pkt;\n+\n+    while ((cx_pkt = vpx_codec_get_cx_data(&codec_, &iter)) != NULL) {\n+      if (cx_pkt->kind == VPX_CODEC_STATS_PKT) {\n+        EXPECT_GT(cx_pkt->data.twopass_stats.sz, 0U);\n+        ASSERT_TRUE(cx_pkt->data.twopass_stats.buf != NULL);\n+        stats_buf->append(static_cast<char*>(cx_pkt->data.twopass_stats.buf),\n+                          cx_pkt->data.twopass_stats.sz);\n+      }\n+    }\n+  }\n+\n+  void Pass1EncodeNFrames(const int n, const int layers,\n+                          std::string *const stats_buf) {\n+    vpx_codec_err_t res;\n+\n+    ASSERT_GT(n, 0);\n+    ASSERT_GT(layers, 0);\n+    svc_.spatial_layers = layers;\n+    codec_enc_.g_pass = VPX_RC_FIRST_PASS;\n+    InitializeEncoder();\n+\n+    libvpx_test::I420VideoSource video(test_file_name_,\n+                                       codec_enc_.g_w, codec_enc_.g_h,\n+                                       codec_enc_.g_timebase.den,\n+                                       codec_enc_.g_timebase.num, 0, 30);\n+    video.Begin();\n+\n+    for (int i = 0; i < n; ++i) {\n+      res = vpx_svc_encode(&svc_, &codec_, video.img(), video.pts(),\n+                           video.duration(), VPX_DL_GOOD_QUALITY);\n+      ASSERT_EQ(VPX_CODEC_OK, res);\n+      GetStatsData(stats_buf);\n+      video.Next();\n+    }\n+\n+    // Flush encoder and test EOS packet.\n+    res = vpx_svc_encode(&svc_, &codec_, NULL, video.pts(),\n+                         video.duration(), VPX_DL_GOOD_QUALITY);\n+    ASSERT_EQ(VPX_CODEC_OK, res);\n+    GetStatsData(stats_buf);\n+\n+    ReleaseEncoder();\n+  }\n+\n+  void StoreFrames(const size_t max_frame_received,\n+                   struct vpx_fixed_buf *const outputs,\n+                   size_t *const frame_received) {\n+    vpx_codec_iter_t iter = NULL;\n+    const vpx_codec_cx_pkt_t *cx_pkt;\n+\n+    while ((cx_pkt = vpx_codec_get_cx_data(&codec_, &iter)) != NULL) {\n+      if (cx_pkt->kind == VPX_CODEC_CX_FRAME_PKT) {\n+        const size_t frame_size = cx_pkt->data.frame.sz;\n+\n+        EXPECT_GT(frame_size, 0U);\n+        ASSERT_TRUE(cx_pkt->data.frame.buf != NULL);\n+        ASSERT_LT(*frame_received, max_frame_received);\n+\n+        if (*frame_received == 0)\n+          EXPECT_EQ(1, !!(cx_pkt->data.frame.flags & VPX_FRAME_IS_KEY));\n+\n+        outputs[*frame_received].buf = malloc(frame_size + 16);\n+        ASSERT_TRUE(outputs[*frame_received].buf != NULL);\n+        memcpy(outputs[*frame_received].buf, cx_pkt->data.frame.buf,\n+               frame_size);\n+        outputs[*frame_received].sz = frame_size;\n+        ++(*frame_received);\n+      }\n+    }\n+  }\n+\n+  void Pass2EncodeNFrames(std::string *const stats_buf,\n+                          const int n, const int layers,\n+                          struct vpx_fixed_buf *const outputs) {\n+    vpx_codec_err_t res;\n+    size_t frame_received = 0;\n+\n+    ASSERT_TRUE(outputs != NULL);\n+    ASSERT_GT(n, 0);\n+    ASSERT_GT(layers, 0);\n+    svc_.spatial_layers = layers;\n+    codec_enc_.rc_target_bitrate = 500;\n+    if (codec_enc_.g_pass == VPX_RC_LAST_PASS) {\n+      ASSERT_TRUE(stats_buf != NULL);\n+      ASSERT_GT(stats_buf->size(), 0U);\n+      codec_enc_.rc_twopass_stats_in.buf = &(*stats_buf)[0];\n+      codec_enc_.rc_twopass_stats_in.sz = stats_buf->size();\n+    }\n+    InitializeEncoder();\n+\n+    libvpx_test::I420VideoSource video(test_file_name_,\n+                                       codec_enc_.g_w, codec_enc_.g_h,\n+                                       codec_enc_.g_timebase.den,\n+                                       codec_enc_.g_timebase.num, 0, 30);\n+    video.Begin();\n+\n+    for (int i = 0; i < n; ++i) {\n+      res = vpx_svc_encode(&svc_, &codec_, video.img(), video.pts(),\n+                           video.duration(), VPX_DL_GOOD_QUALITY);\n+      ASSERT_EQ(VPX_CODEC_OK, res);\n+      StoreFrames(n, outputs, &frame_received);\n+      video.Next();\n+    }\n+\n+    // Flush encoder.\n+    res = vpx_svc_encode(&svc_, &codec_, NULL, 0,\n+                         video.duration(), VPX_DL_GOOD_QUALITY);\n+    EXPECT_EQ(VPX_CODEC_OK, res);\n+    StoreFrames(n, outputs, &frame_received);\n+\n+    EXPECT_EQ(frame_received, static_cast<size_t>(n));\n+\n+    ReleaseEncoder();\n+  }\n+\n+  void DecodeNFrames(const struct vpx_fixed_buf *const inputs, const int n) {\n+    int decoded_frames = 0;\n+    int received_frames = 0;\n+\n+    ASSERT_TRUE(inputs != NULL);\n+    ASSERT_GT(n, 0);\n+\n+    for (int i = 0; i < n; ++i) {\n+      ASSERT_TRUE(inputs[i].buf != NULL);\n+      ASSERT_GT(inputs[i].sz, 0U);\n+      const vpx_codec_err_t res_dec =\n+          decoder_->DecodeFrame(static_cast<const uint8_t *>(inputs[i].buf),\n+                                inputs[i].sz);\n+      ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder_->DecodeError();\n+      ++decoded_frames;\n+\n+      DxDataIterator dec_iter = decoder_->GetDxData();\n+      while (dec_iter.Next() != NULL) {\n+        ++received_frames;\n+      }\n+    }\n+    EXPECT_EQ(decoded_frames, n);\n+    EXPECT_EQ(received_frames, n);\n+  }\n+\n+  void DropEnhancementLayers(struct vpx_fixed_buf *const inputs,\n+                             const int num_super_frames,\n+                             const int remained_spatial_layers) {\n+    ASSERT_TRUE(inputs != NULL);\n+    ASSERT_GT(num_super_frames, 0);\n+    ASSERT_GT(remained_spatial_layers, 0);\n+\n+    for (int i = 0; i < num_super_frames; ++i) {\n+      uint32_t frame_sizes[8] = {0};\n+      int frame_count = 0;\n+      int frames_found = 0;\n+      int frame;\n+      ASSERT_TRUE(inputs[i].buf != NULL);\n+      ASSERT_GT(inputs[i].sz, 0U);\n+\n+      vpx_codec_err_t res =\n+          vp9_parse_superframe_index(static_cast<const uint8_t*>(inputs[i].buf),\n+                                     inputs[i].sz, frame_sizes, &frame_count,\n+                                     NULL, NULL);\n+      ASSERT_EQ(VPX_CODEC_OK, res);\n+\n+      if (frame_count == 0) {\n+        // There's no super frame but only a single frame.\n+        ASSERT_EQ(1, remained_spatial_layers);\n+      } else {\n+        // Found a super frame.\n+        uint8_t *frame_data = static_cast<uint8_t*>(inputs[i].buf);\n+        uint8_t *frame_start = frame_data;\n+        for (frame = 0; frame < frame_count; ++frame) {\n+          // Looking for a visible frame.\n+          if (frame_data[0] & 0x02) {\n+            ++frames_found;\n+            if (frames_found == remained_spatial_layers)\n+              break;\n+          }\n+          frame_data += frame_sizes[frame];\n+        }\n+        ASSERT_LT(frame, frame_count) << \""Couldn't find a visible frame. \""\n+            << \""remained_spatial_layers: \"" << remained_spatial_layers\n+            << \""    super_frame: \"" << i;\n+        if (frame == frame_count - 1)\n+          continue;\n+\n+        frame_data += frame_sizes[frame];\n+\n+        // We need to add one more frame for multiple frame contexts.\n+        uint8_t marker =\n+            static_cast<const uint8_t*>(inputs[i].buf)[inputs[i].sz - 1];\n+        const uint32_t mag = ((marker >> 3) & 0x3) + 1;\n+        const size_t index_sz = 2 + mag * frame_count;\n+        const size_t new_index_sz = 2 + mag * (frame + 1);\n+        marker &= 0x0f8;\n+        marker |= frame;\n+\n+        // Copy existing frame sizes.\n+        memmove(frame_data + 1, frame_start + inputs[i].sz - index_sz + 1,\n+                new_index_sz - 2);\n+        // New marker.\n+        frame_data[0] = marker;\n+        frame_data += (mag * (frame + 1) + 1);\n+\n+        *frame_data++ = marker;\n+        inputs[i].sz = frame_data - frame_start;\n+      }\n+    }\n+  }\n+\n+  void FreeBitstreamBuffers(struct vpx_fixed_buf *const inputs, const int n) {\n+    ASSERT_TRUE(inputs != NULL);\n+    ASSERT_GT(n, 0);\n+\n+    for (int i = 0; i < n; ++i) {\n+      free(inputs[i].buf);\n+      inputs[i].buf = NULL;\n+      inputs[i].sz = 0;\n+    }\n   }\n \n   SvcContext svc_;\n@@ -74,9 +315,10 @@\n\n   struct vpx_codec_enc_cfg codec_enc_;\n   vpx_codec_iface_t *codec_iface_;\n   std::string test_file_name_;\n-  std::string stats_file_name_;\n   bool codec_initialized_;\n   Decoder *decoder_;\n+  int tile_columns_;\n+  int tile_rows_;\n };\n \n TEST_F(SvcTest, SvcInit) {\n@@ -96,22 +338,13 @@\n\n   EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n \n   svc_.spatial_layers = 0;  // use default layers\n-  res = vpx_svc_init(&svc_, &codec_, codec_iface_, &codec_enc_);\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  codec_initialized_ = true;\n+  InitializeEncoder();\n   EXPECT_EQ(VPX_SS_DEFAULT_LAYERS, svc_.spatial_layers);\n }\n \n TEST_F(SvcTest, InitTwoLayers) {\n   svc_.spatial_layers = 2;\n-  vpx_svc_set_scale_factors(&svc_, \""4/16,16*16\"");  // invalid scale values\n-  vpx_codec_err_t res = vpx_svc_init(&svc_, &codec_, codec_iface_, &codec_enc_);\n-  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n-\n-  vpx_svc_set_scale_factors(&svc_, \""4/16,16/16\"");  // valid scale values\n-  res = vpx_svc_init(&svc_, &codec_, codec_iface_, &codec_enc_);\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  codec_initialized_ = true;\n+  InitializeEncoder();\n }\n \n TEST_F(SvcTest, InvalidOptions) {\n@@ -125,30 +358,18 @@\n\n }\n \n TEST_F(SvcTest, SetLayersOption) {\n-  vpx_codec_err_t res = vpx_svc_set_options(&svc_, \""layers=3\"");\n+  vpx_codec_err_t res = vpx_svc_set_options(&svc_, \""spatial-layers=3\"");\n   EXPECT_EQ(VPX_CODEC_OK, res);\n-  res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  codec_initialized_ = true;\n+  InitializeEncoder();\n   EXPECT_EQ(3, svc_.spatial_layers);\n }\n \n-TEST_F(SvcTest, SetEncodingMode) {\n-  vpx_codec_err_t res = vpx_svc_set_options(&svc_, \""encoding-mode=alt-ip\"");\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  codec_initialized_ = true;\n-  EXPECT_EQ(ALT_INTER_LAYER_PREDICTION_IP, svc_.encoding_mode);\n-}\n-\n TEST_F(SvcTest, SetMultipleOptions) {\n-  vpx_codec_err_t res = vpx_svc_set_options(&svc_, \""layers=2 encoding-mode=ip\"");\n-  res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n+  vpx_codec_err_t res =\n+      vpx_svc_set_options(&svc_, \""spatial-layers=2 scale-factors=1/3,2/3\"");\n   EXPECT_EQ(VPX_CODEC_OK, res);\n-  codec_initialized_ = true;\n+  InitializeEncoder();\n   EXPECT_EQ(2, svc_.spatial_layers);\n-  EXPECT_EQ(INTER_LAYER_PREDICTION_IP, svc_.encoding_mode);\n }\n \n TEST_F(SvcTest, SetScaleFactorsOption) {\n@@ -159,314 +380,418 @@\n\n   res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n   EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n \n-  res = vpx_svc_set_options(&svc_, \""scale-factors=1/3,2/3\"");\n+  res = vpx_svc_set_options(&svc_, \""scale-factors=1/3, 3*3\"");\n   EXPECT_EQ(VPX_CODEC_OK, res);\n   res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n+  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n+\n+  res = vpx_svc_set_options(&svc_, \""scale-factors=1/3\"");\n   EXPECT_EQ(VPX_CODEC_OK, res);\n-  codec_initialized_ = true;\n+  res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n+  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n+\n+  res = vpx_svc_set_options(&svc_, \""scale-factors=1/3,2/3\"");\n+  EXPECT_EQ(VPX_CODEC_OK, res);\n+  InitializeEncoder();\n }\n \n TEST_F(SvcTest, SetQuantizersOption) {\n   svc_.spatial_layers = 2;\n-  vpx_codec_err_t res = vpx_svc_set_options(&svc_, \""quantizers=not-quantizers\"");\n+  vpx_codec_err_t res = vpx_svc_set_options(&svc_, \""max-quantizers=nothing\"");\n   EXPECT_EQ(VPX_CODEC_OK, res);\n   res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n   EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n \n-  vpx_svc_set_options(&svc_, \""quantizers=40,45\"");\n-  res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n+  res = vpx_svc_set_options(&svc_, \""min-quantizers=nothing\"");\n   EXPECT_EQ(VPX_CODEC_OK, res);\n-  codec_initialized_ = true;\n+  res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n+  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n+\n+  res = vpx_svc_set_options(&svc_, \""max-quantizers=40\"");\n+  EXPECT_EQ(VPX_CODEC_OK, res);\n+  res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n+  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n+\n+  res = vpx_svc_set_options(&svc_, \""min-quantizers=40\"");\n+  EXPECT_EQ(VPX_CODEC_OK, res);\n+  res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n+  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n+\n+  res = vpx_svc_set_options(&svc_, \""max-quantizers=30,30 min-quantizers=40,40\"");\n+  EXPECT_EQ(VPX_CODEC_OK, res);\n+  res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n+  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n+\n+  res = vpx_svc_set_options(&svc_, \""max-quantizers=40,40 min-quantizers=30,30\"");\n+  InitializeEncoder();\n }\n \n-TEST_F(SvcTest, SetKeyFrameQuantizersOption) {\n-  svc_.spatial_layers = 2;\n-  vpx_codec_err_t res = vpx_svc_set_options(&svc_,\n-                                       \""quantizers-keyframe=not-quantizers\"");\n+TEST_F(SvcTest, SetAutoAltRefOption) {\n+  svc_.spatial_layers = 5;\n+  vpx_codec_err_t res = vpx_svc_set_options(&svc_, \""auto-alt-refs=none\"");\n   EXPECT_EQ(VPX_CODEC_OK, res);\n   res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n   EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n \n-  vpx_svc_set_options(&svc_, \""quantizers-keyframe=40,45\"");\n-  res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  codec_initialized_ = true;\n-}\n-\n-TEST_F(SvcTest, SetQuantizers) {\n-  vpx_codec_err_t res = vpx_svc_set_quantizers(NULL, \""40,30\"", 0);\n-  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n-\n-  res = vpx_svc_set_quantizers(&svc_, NULL, 0);\n-  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n-\n-  svc_.spatial_layers = 2;\n-  res = vpx_svc_set_quantizers(&svc_, \""40\"", 0);\n+  res = vpx_svc_set_options(&svc_, \""auto-alt-refs=1,1,1,1,0\"");\n   EXPECT_EQ(VPX_CODEC_OK, res);\n   res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n   EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n \n-  res = vpx_svc_set_quantizers(&svc_, \""40,30\"", 0);\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  codec_initialized_ = true;\n-}\n-\n-TEST_F(SvcTest, SetKeyFrameQuantizers) {\n-  vpx_codec_err_t res = vpx_svc_set_quantizers(NULL, \""40,31\"", 1);\n-  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n-\n-  res = vpx_svc_set_quantizers(&svc_, NULL, 1);\n-  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n-\n-  res = vpx_svc_set_quantizers(&svc_, \""40,30\"", 1);\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  codec_initialized_ = true;\n-}\n-\n-TEST_F(SvcTest, SetScaleFactors) {\n-  vpx_codec_err_t res = vpx_svc_set_scale_factors(NULL, \""4/16,16/16\"");\n-  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n-\n-  res = vpx_svc_set_scale_factors(&svc_, NULL);\n-  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n-\n-  svc_.spatial_layers = 2;\n-  res = vpx_svc_set_scale_factors(&svc_, \""4/16\"");\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n-  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n-\n-  res = vpx_svc_set_scale_factors(&svc_, \""4/16,16/16\"");\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  codec_initialized_ = true;\n+  vpx_svc_set_options(&svc_, \""auto-alt-refs=0,1,1,1,0\"");\n+  InitializeEncoder();\n }\n \n // Test that decoder can handle an SVC frame as the first frame in a sequence.\n-TEST_F(SvcTest, FirstFrameHasLayers) {\n-  svc_.spatial_layers = 2;\n-  vpx_svc_set_scale_factors(&svc_, \""4/16,16/16\"");\n-  vpx_svc_set_quantizers(&svc_, \""40,30\"", 0);\n-\n-  vpx_codec_err_t res =\n-      vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  codec_initialized_ = true;\n-\n-  libvpx_test::I420VideoSource video(test_file_name_, kWidth, kHeight,\n-                                     codec_enc_.g_timebase.den,\n-                                     codec_enc_.g_timebase.num, 0, 30);\n-  video.Begin();\n-\n-  res = vpx_svc_encode(&svc_, &codec_, video.img(), video.pts(),\n-                       video.duration(), VPX_DL_GOOD_QUALITY);\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-\n-  const vpx_codec_err_t res_dec = decoder_->DecodeFrame(\n-      static_cast<const uint8_t *>(vpx_svc_get_buffer(&svc_)),\n-      vpx_svc_get_frame_size(&svc_));\n-\n-  // this test fails with a decoder error\n-  ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder_->DecodeError();\n+TEST_F(SvcTest, OnePassEncodeOneFrame) {\n+  codec_enc_.g_pass = VPX_RC_ONE_PASS;\n+  vpx_fixed_buf output = {0};\n+  Pass2EncodeNFrames(NULL, 1, 2, &output);\n+  DecodeNFrames(&output, 1);\n+  FreeBitstreamBuffers(&output, 1);\n }\n \n-TEST_F(SvcTest, EncodeThreeFrames) {\n-  svc_.spatial_layers = 2;\n-  vpx_svc_set_scale_factors(&svc_, \""4/16,16/16\"");\n-  vpx_svc_set_quantizers(&svc_, \""40,30\"", 0);\n-\n-  vpx_codec_err_t res =\n-      vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n-  ASSERT_EQ(VPX_CODEC_OK, res);\n-  codec_initialized_ = true;\n-\n-  libvpx_test::I420VideoSource video(test_file_name_, kWidth, kHeight,\n-                                     codec_enc_.g_timebase.den,\n-                                     codec_enc_.g_timebase.num, 0, 30);\n-  // FRAME 0\n-  video.Begin();\n-  // This frame is a keyframe.\n-  res = vpx_svc_encode(&svc_, &codec_, video.img(), video.pts(),\n-                       video.duration(), VPX_DL_GOOD_QUALITY);\n-  ASSERT_EQ(VPX_CODEC_OK, res);\n-  EXPECT_EQ(1, vpx_svc_is_keyframe(&svc_));\n-\n-  vpx_codec_err_t res_dec = decoder_->DecodeFrame(\n-      static_cast<const uint8_t *>(vpx_svc_get_buffer(&svc_)),\n-      vpx_svc_get_frame_size(&svc_));\n-  ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder_->DecodeError();\n-\n-  // FRAME 1\n-  video.Next();\n-  // This is a P-frame.\n-  res = vpx_svc_encode(&svc_, &codec_, video.img(), video.pts(),\n-                       video.duration(), VPX_DL_GOOD_QUALITY);\n-  ASSERT_EQ(VPX_CODEC_OK, res);\n-  EXPECT_EQ(0, vpx_svc_is_keyframe(&svc_));\n-\n-  res_dec = decoder_->DecodeFrame(\n-      static_cast<const uint8_t *>(vpx_svc_get_buffer(&svc_)),\n-      vpx_svc_get_frame_size(&svc_));\n-  ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder_->DecodeError();\n-\n-  // FRAME 2\n-  video.Next();\n-  // This is a P-frame.\n-  res = vpx_svc_encode(&svc_, &codec_, video.img(), video.pts(),\n-                       video.duration(), VPX_DL_GOOD_QUALITY);\n-  ASSERT_EQ(VPX_CODEC_OK, res);\n-  EXPECT_EQ(0, vpx_svc_is_keyframe(&svc_));\n-\n-  res_dec = decoder_->DecodeFrame(\n-      static_cast<const uint8_t *>(vpx_svc_get_buffer(&svc_)),\n-      vpx_svc_get_frame_size(&svc_));\n-  ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder_->DecodeError();\n+TEST_F(SvcTest, OnePassEncodeThreeFrames) {\n+  codec_enc_.g_pass = VPX_RC_ONE_PASS;\n+  codec_enc_.g_lag_in_frames = 0;\n+  vpx_fixed_buf outputs[3];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(NULL, 3, 2, &outputs[0]);\n+  DecodeNFrames(&outputs[0], 3);\n+  FreeBitstreamBuffers(&outputs[0], 3);\n }\n \n-TEST_F(SvcTest, GetLayerResolution) {\n-  svc_.spatial_layers = 2;\n-  vpx_svc_set_scale_factors(&svc_, \""4/16,8/16\"");\n-  vpx_svc_set_quantizers(&svc_, \""40,30\"", 0);\n+TEST_F(SvcTest, TwoPassEncode10Frames) {\n+  // First pass encode\n+  std::string stats_buf;\n+  Pass1EncodeNFrames(10, 2, &stats_buf);\n \n-  vpx_codec_err_t res =\n-      vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  codec_initialized_ = true;\n-\n-  // ensure that requested layer is a valid layer\n-  uint32_t layer_width, layer_height;\n-  res = vpx_svc_get_layer_resolution(&svc_, svc_.spatial_layers,\n-                                     &layer_width, &layer_height);\n-  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n-\n-  res = vpx_svc_get_layer_resolution(NULL, 0, &layer_width, &layer_height);\n-  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n-\n-  res = vpx_svc_get_layer_resolution(&svc_, 0, NULL, &layer_height);\n-  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n-\n-  res = vpx_svc_get_layer_resolution(&svc_, 0, &layer_width, NULL);\n-  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n-\n-  res = vpx_svc_get_layer_resolution(&svc_, 0, &layer_width, &layer_height);\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  EXPECT_EQ(kWidth * 4 / 16, layer_width);\n-  EXPECT_EQ(kHeight * 4 / 16, layer_height);\n-\n-  res = vpx_svc_get_layer_resolution(&svc_, 1, &layer_width, &layer_height);\n-  EXPECT_EQ(VPX_CODEC_OK, res);\n-  EXPECT_EQ(kWidth * 8 / 16, layer_width);\n-  EXPECT_EQ(kHeight * 8 / 16, layer_height);\n-}\n-\n-TEST_F(SvcTest, FirstPassEncode) {\n-  svc_.spatial_layers = 2;\n-  codec_enc_.g_pass = VPX_RC_FIRST_PASS;\n-  vpx_svc_set_scale_factors(&svc_, \""4/16,16/16\"");\n-  vpx_svc_set_quantizers(&svc_, \""40,30\"", 0);\n-\n-  vpx_codec_err_t res =\n-      vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n-  ASSERT_EQ(VPX_CODEC_OK, res);\n-  codec_initialized_ = true;\n-\n-  libvpx_test::I420VideoSource video(test_file_name_, kWidth, kHeight,\n-                                     codec_enc_.g_timebase.den,\n-                                     codec_enc_.g_timebase.num, 0, 30);\n-  // FRAME 0\n-  video.Begin();\n-  res = vpx_svc_encode(&svc_, &codec_, video.img(), video.pts(),\n-                       video.duration(), VPX_DL_GOOD_QUALITY);\n-  ASSERT_EQ(VPX_CODEC_OK, res);\n-  EXPECT_GT(vpx_svc_get_rc_stats_buffer_size(&svc_), 0U);\n-\n-  // FRAME 1\n-  video.Next();\n-  res = vpx_svc_encode(&svc_, &codec_, video.img(), video.pts(),\n-                       video.duration(), VPX_DL_GOOD_QUALITY);\n-  ASSERT_EQ(VPX_CODEC_OK, res);\n-  EXPECT_GT(vpx_svc_get_rc_stats_buffer_size(&svc_), 0U);\n-\n-  // Flush encoder and test EOS packet\n-  res = vpx_svc_encode(&svc_, &codec_, NULL, video.pts(),\n-                       video.duration(), VPX_DL_GOOD_QUALITY);\n-  ASSERT_EQ(VPX_CODEC_OK, res);\n-  EXPECT_GT(vpx_svc_get_rc_stats_buffer_size(&svc_), 0U);\n-}\n-\n-TEST_F(SvcTest, SecondPassEncode) {\n-  svc_.spatial_layers = 2;\n+  // Second pass encode\n   codec_enc_.g_pass = VPX_RC_LAST_PASS;\n+  vpx_fixed_buf outputs[10];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(&stats_buf, 10, 2, &outputs[0]);\n+  DecodeNFrames(&outputs[0], 10);\n+  FreeBitstreamBuffers(&outputs[0], 10);\n+}\n \n-  FILE *const stats_file = libvpx_test::OpenTestDataFile(stats_file_name_);\n-  ASSERT_TRUE(stats_file != NULL) << \""Stats file open failed. Filename: \""\n-      << stats_file;\n+TEST_F(SvcTest, TwoPassEncode20FramesWithAltRef) {\n+  // First pass encode\n+  std::string stats_buf;\n+  Pass1EncodeNFrames(20, 2, &stats_buf);\n \n-  struct vpx_fixed_buf stats_buf;\n-  fseek(stats_file, 0, SEEK_END);\n-  stats_buf.sz = static_cast<size_t>(ftell(stats_file));\n-  fseek(stats_file, 0, SEEK_SET);\n+  // Second pass encode\n+  codec_enc_.g_pass = VPX_RC_LAST_PASS;\n+  vpx_svc_set_options(&svc_, \""auto-alt-refs=1,1\"");\n+  vpx_fixed_buf outputs[20];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(&stats_buf, 20, 2, &outputs[0]);\n+  DecodeNFrames(&outputs[0], 20);\n+  FreeBitstreamBuffers(&outputs[0], 20);\n+}\n \n-  stats_buf.buf = malloc(stats_buf.sz);\n-  ASSERT_TRUE(stats_buf.buf != NULL);\n-  const size_t bytes_read = fread(stats_buf.buf, 1, stats_buf.sz, stats_file);\n-  ASSERT_EQ(bytes_read, stats_buf.sz);\n-  fclose(stats_file);\n-  codec_enc_.rc_twopass_stats_in = stats_buf;\n+TEST_F(SvcTest, TwoPassEncode2SpatialLayersDecodeBaseLayerOnly) {\n+  // First pass encode\n+  std::string stats_buf;\n+  Pass1EncodeNFrames(10, 2, &stats_buf);\n \n+  // Second pass encode\n+  codec_enc_.g_pass = VPX_RC_LAST_PASS;\n+  vpx_svc_set_options(&svc_, \""auto-alt-refs=1,1\"");\n+  vpx_fixed_buf outputs[10];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(&stats_buf, 10, 2, &outputs[0]);\n+  DropEnhancementLayers(&outputs[0], 10, 1);\n+  DecodeNFrames(&outputs[0], 10);\n+  FreeBitstreamBuffers(&outputs[0], 10);\n+}\n+\n+TEST_F(SvcTest, TwoPassEncode5SpatialLayersDecode54321Layers) {\n+  // First pass encode\n+  std::string stats_buf;\n+  Pass1EncodeNFrames(10, 5, &stats_buf);\n+\n+  // Second pass encode\n+  codec_enc_.g_pass = VPX_RC_LAST_PASS;\n+  vpx_svc_set_options(&svc_, \""auto-alt-refs=0,1,1,1,0\"");\n+  vpx_fixed_buf outputs[10];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(&stats_buf, 10, 5, &outputs[0]);\n+\n+  DecodeNFrames(&outputs[0], 10);\n+  DropEnhancementLayers(&outputs[0], 10, 4);\n+  DecodeNFrames(&outputs[0], 10);\n+  DropEnhancementLayers(&outputs[0], 10, 3);\n+  DecodeNFrames(&outputs[0], 10);\n+  DropEnhancementLayers(&outputs[0], 10, 2);\n+  DecodeNFrames(&outputs[0], 10);\n+  DropEnhancementLayers(&outputs[0], 10, 1);\n+  DecodeNFrames(&outputs[0], 10);\n+\n+  FreeBitstreamBuffers(&outputs[0], 10);\n+}\n+\n+TEST_F(SvcTest, TwoPassEncode2SNRLayers) {\n+  // First pass encode\n+  std::string stats_buf;\n+  vpx_svc_set_options(&svc_, \""scale-factors=1/1,1/1\"");\n+  Pass1EncodeNFrames(20, 2, &stats_buf);\n+\n+  // Second pass encode\n+  codec_enc_.g_pass = VPX_RC_LAST_PASS;\n+  vpx_svc_set_options(&svc_,\n+                      \""auto-alt-refs=1,1 scale-factors=1/1,1/1\"");\n+  vpx_fixed_buf outputs[20];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(&stats_buf, 20, 2, &outputs[0]);\n+  DecodeNFrames(&outputs[0], 20);\n+  FreeBitstreamBuffers(&outputs[0], 20);\n+}\n+\n+TEST_F(SvcTest, TwoPassEncode3SNRLayersDecode321Layers) {\n+  // First pass encode\n+  std::string stats_buf;\n+  vpx_svc_set_options(&svc_, \""scale-factors=1/1,1/1,1/1\"");\n+  Pass1EncodeNFrames(20, 3, &stats_buf);\n+\n+  // Second pass encode\n+  codec_enc_.g_pass = VPX_RC_LAST_PASS;\n+  vpx_svc_set_options(&svc_,\n+                      \""auto-alt-refs=1,1,1 scale-factors=1/1,1/1,1/1\"");\n+  vpx_fixed_buf outputs[20];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(&stats_buf, 20, 3, &outputs[0]);\n+  DecodeNFrames(&outputs[0], 20);\n+  DropEnhancementLayers(&outputs[0], 20, 2);\n+  DecodeNFrames(&outputs[0], 20);\n+  DropEnhancementLayers(&outputs[0], 20, 1);\n+  DecodeNFrames(&outputs[0], 20);\n+\n+  FreeBitstreamBuffers(&outputs[0], 20);\n+}\n+\n+TEST_F(SvcTest, SetMultipleFrameContextsOption) {\n+  svc_.spatial_layers = 5;\n   vpx_codec_err_t res =\n-      vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n-  ASSERT_EQ(VPX_CODEC_OK, res);\n-  codec_initialized_ = true;\n+      vpx_svc_set_options(&svc_, \""multi-frame-contexts=1\"");\n+  EXPECT_EQ(VPX_CODEC_OK, res);\n+  res = vpx_svc_init(&svc_, &codec_, vpx_codec_vp9_cx(), &codec_enc_);\n+  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, res);\n \n-  libvpx_test::I420VideoSource video(test_file_name_, kWidth, kHeight,\n-                                     codec_enc_.g_timebase.den,\n-                                     codec_enc_.g_timebase.num, 0, 30);\n-  // FRAME 0\n-  video.Begin();\n-  // This frame is a keyframe.\n-  res = vpx_svc_encode(&svc_, &codec_, video.img(), video.pts(),\n-                       video.duration(), VPX_DL_GOOD_QUALITY);\n-  ASSERT_EQ(VPX_CODEC_OK, res);\n-  EXPECT_EQ(1, vpx_svc_is_keyframe(&svc_));\n+  svc_.spatial_layers = 2;\n+  res = vpx_svc_set_options(&svc_, \""multi-frame-contexts=1\"");\n+  InitializeEncoder();\n+}\n \n-  vpx_codec_err_t res_dec = decoder_->DecodeFrame(\n-      static_cast<const uint8_t *>(vpx_svc_get_buffer(&svc_)),\n-      vpx_svc_get_frame_size(&svc_));\n-  ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder_->DecodeError();\n+TEST_F(SvcTest, TwoPassEncode2SpatialLayersWithMultipleFrameContexts) {\n+  // First pass encode\n+  std::string stats_buf;\n+  Pass1EncodeNFrames(10, 2, &stats_buf);\n \n-  // FRAME 1\n-  video.Next();\n-  // This is a P-frame.\n-  res = vpx_svc_encode(&svc_, &codec_, video.img(), video.pts(),\n-                       video.duration(), VPX_DL_GOOD_QUALITY);\n-  ASSERT_EQ(VPX_CODEC_OK, res);\n-  EXPECT_EQ(0, vpx_svc_is_keyframe(&svc_));\n+  // Second pass encode\n+  codec_enc_.g_pass = VPX_RC_LAST_PASS;\n+  codec_enc_.g_error_resilient = 0;\n+  vpx_svc_set_options(&svc_, \""auto-alt-refs=1,1 multi-frame-contexts=1\"");\n+  vpx_fixed_buf outputs[10];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(&stats_buf, 10, 2, &outputs[0]);\n+  DecodeNFrames(&outputs[0], 10);\n+  FreeBitstreamBuffers(&outputs[0], 10);\n+}\n \n-  res_dec = decoder_->DecodeFrame(\n-      static_cast<const uint8_t *>(vpx_svc_get_buffer(&svc_)),\n-      vpx_svc_get_frame_size(&svc_));\n-  ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder_->DecodeError();\n+TEST_F(SvcTest,\n+       TwoPassEncode2SpatialLayersWithMultipleFrameContextsDecodeBaselayer) {\n+  // First pass encode\n+  std::string stats_buf;\n+  Pass1EncodeNFrames(10, 2, &stats_buf);\n \n-  // FRAME 2\n-  video.Next();\n-  // This is a P-frame.\n-  res = vpx_svc_encode(&svc_, &codec_, video.img(), video.pts(),\n-                       video.duration(), VPX_DL_GOOD_QUALITY);\n-  ASSERT_EQ(VPX_CODEC_OK, res);\n-  EXPECT_EQ(0, vpx_svc_is_keyframe(&svc_));\n+  // Second pass encode\n+  codec_enc_.g_pass = VPX_RC_LAST_PASS;\n+  codec_enc_.g_error_resilient = 0;\n+  vpx_svc_set_options(&svc_, \""auto-alt-refs=1,1 multi-frame-contexts=1\"");\n+  vpx_fixed_buf outputs[10];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(&stats_buf, 10, 2, &outputs[0]);\n+  DropEnhancementLayers(&outputs[0], 10, 1);\n+  DecodeNFrames(&outputs[0], 10);\n+  FreeBitstreamBuffers(&outputs[0], 10);\n+}\n \n-  res_dec = decoder_->DecodeFrame(\n-      static_cast<const uint8_t *>(vpx_svc_get_buffer(&svc_)),\n-      vpx_svc_get_frame_size(&svc_));\n-  ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder_->DecodeError();\n+TEST_F(SvcTest, TwoPassEncode2SNRLayersWithMultipleFrameContexts) {\n+  // First pass encode\n+  std::string stats_buf;\n+  vpx_svc_set_options(&svc_, \""scale-factors=1/1,1/1\"");\n+  Pass1EncodeNFrames(10, 2, &stats_buf);\n \n-  free(stats_buf.buf);\n+  // Second pass encode\n+  codec_enc_.g_pass = VPX_RC_LAST_PASS;\n+  codec_enc_.g_error_resilient = 0;\n+  vpx_svc_set_options(&svc_, \""auto-alt-refs=1,1 scale-factors=1/1,1/1 \""\n+                      \""multi-frame-contexts=1\"");\n+  vpx_fixed_buf outputs[10];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(&stats_buf, 10, 2, &outputs[0]);\n+  DecodeNFrames(&outputs[0], 10);\n+  FreeBitstreamBuffers(&outputs[0], 10);\n+}\n+\n+TEST_F(SvcTest,\n+       TwoPassEncode3SNRLayersWithMultipleFrameContextsDecode321Layer) {\n+  // First pass encode\n+  std::string stats_buf;\n+  vpx_svc_set_options(&svc_, \""scale-factors=1/1,1/1,1/1\"");\n+  Pass1EncodeNFrames(10, 3, &stats_buf);\n+\n+  // Second pass encode\n+  codec_enc_.g_pass = VPX_RC_LAST_PASS;\n+  codec_enc_.g_error_resilient = 0;\n+  vpx_svc_set_options(&svc_, \""auto-alt-refs=1,1,1 scale-factors=1/1,1/1,1/1 \""\n+                      \""multi-frame-contexts=1\"");\n+  vpx_fixed_buf outputs[10];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(&stats_buf, 10, 3, &outputs[0]);\n+\n+  DecodeNFrames(&outputs[0], 10);\n+  DropEnhancementLayers(&outputs[0], 10, 2);\n+  DecodeNFrames(&outputs[0], 10);\n+  DropEnhancementLayers(&outputs[0], 10, 1);\n+  DecodeNFrames(&outputs[0], 10);\n+\n+  FreeBitstreamBuffers(&outputs[0], 10);\n+}\n+\n+TEST_F(SvcTest, TwoPassEncode2TemporalLayers) {\n+  // First pass encode\n+  std::string stats_buf;\n+  vpx_svc_set_options(&svc_, \""scale-factors=1/1\"");\n+  svc_.temporal_layers = 2;\n+  Pass1EncodeNFrames(10, 1, &stats_buf);\n+\n+  // Second pass encode\n+  codec_enc_.g_pass = VPX_RC_LAST_PASS;\n+  svc_.temporal_layers = 2;\n+  vpx_svc_set_options(&svc_, \""auto-alt-refs=1 scale-factors=1/1\"");\n+  vpx_fixed_buf outputs[10];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(&stats_buf, 10, 1, &outputs[0]);\n+  DecodeNFrames(&outputs[0], 10);\n+  FreeBitstreamBuffers(&outputs[0], 10);\n+}\n+\n+TEST_F(SvcTest, TwoPassEncode2TemporalLayersWithMultipleFrameContexts) {\n+  // First pass encode\n+  std::string stats_buf;\n+  vpx_svc_set_options(&svc_, \""scale-factors=1/1\"");\n+  svc_.temporal_layers = 2;\n+  Pass1EncodeNFrames(10, 1, &stats_buf);\n+\n+  // Second pass encode\n+  codec_enc_.g_pass = VPX_RC_LAST_PASS;\n+  svc_.temporal_layers = 2;\n+  codec_enc_.g_error_resilient = 0;\n+  vpx_svc_set_options(&svc_, \""auto-alt-refs=1 scale-factors=1/1 \""\n+                      \""multi-frame-contexts=1\"");\n+  vpx_fixed_buf outputs[10];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(&stats_buf, 10, 1, &outputs[0]);\n+  DecodeNFrames(&outputs[0], 10);\n+  FreeBitstreamBuffers(&outputs[0], 10);\n+}\n+\n+TEST_F(SvcTest, TwoPassEncode2TemporalLayersDecodeBaseLayer) {\n+  // First pass encode\n+  std::string stats_buf;\n+  vpx_svc_set_options(&svc_, \""scale-factors=1/1\"");\n+  svc_.temporal_layers = 2;\n+  Pass1EncodeNFrames(10, 1, &stats_buf);\n+\n+  // Second pass encode\n+  codec_enc_.g_pass = VPX_RC_LAST_PASS;\n+  svc_.temporal_layers = 2;\n+  vpx_svc_set_options(&svc_, \""auto-alt-refs=1 scale-factors=1/1\"");\n+  vpx_fixed_buf outputs[10];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(&stats_buf, 10, 1, &outputs[0]);\n+\n+  vpx_fixed_buf base_layer[5];\n+  for (int i = 0; i < 5; ++i)\n+    base_layer[i] = outputs[i * 2];\n+\n+  DecodeNFrames(&base_layer[0], 5);\n+  FreeBitstreamBuffers(&outputs[0], 10);\n+}\n+\n+TEST_F(SvcTest,\n+       TwoPassEncode2TemporalLayersWithMultipleFrameContextsDecodeBaseLayer) {\n+  // First pass encode\n+  std::string stats_buf;\n+  vpx_svc_set_options(&svc_, \""scale-factors=1/1\"");\n+  svc_.temporal_layers = 2;\n+  Pass1EncodeNFrames(10, 1, &stats_buf);\n+\n+  // Second pass encode\n+  codec_enc_.g_pass = VPX_RC_LAST_PASS;\n+  svc_.temporal_layers = 2;\n+  codec_enc_.g_error_resilient = 0;\n+  vpx_svc_set_options(&svc_, \""auto-alt-refs=1 scale-factors=1/1 \""\n+                      \""multi-frame-contexts=1\"");\n+  vpx_fixed_buf outputs[10];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(&stats_buf, 10, 1, &outputs[0]);\n+\n+  vpx_fixed_buf base_layer[5];\n+  for (int i = 0; i < 5; ++i)\n+    base_layer[i] = outputs[i * 2];\n+\n+  DecodeNFrames(&base_layer[0], 5);\n+  FreeBitstreamBuffers(&outputs[0], 10);\n+}\n+\n+TEST_F(SvcTest, TwoPassEncode2TemporalLayersWithTiles) {\n+  // First pass encode\n+  std::string stats_buf;\n+  vpx_svc_set_options(&svc_, \""scale-factors=1/1\"");\n+  svc_.temporal_layers = 2;\n+  Pass1EncodeNFrames(10, 1, &stats_buf);\n+\n+  // Second pass encode\n+  codec_enc_.g_pass = VPX_RC_LAST_PASS;\n+  svc_.temporal_layers = 2;\n+  vpx_svc_set_options(&svc_, \""auto-alt-refs=1 scale-factors=1/1\"");\n+  codec_enc_.g_w = 704;\n+  codec_enc_.g_h = 144;\n+  tile_columns_ = 1;\n+  tile_rows_ = 1;\n+  vpx_fixed_buf outputs[10];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(&stats_buf, 10, 1, &outputs[0]);\n+  DecodeNFrames(&outputs[0], 10);\n+  FreeBitstreamBuffers(&outputs[0], 10);\n+}\n+\n+TEST_F(SvcTest,\n+       TwoPassEncode2TemporalLayersWithMultipleFrameContextsAndTiles) {\n+  // First pass encode\n+  std::string stats_buf;\n+  vpx_svc_set_options(&svc_, \""scale-factors=1/1\"");\n+  svc_.temporal_layers = 2;\n+  Pass1EncodeNFrames(10, 1, &stats_buf);\n+\n+  // Second pass encode\n+  codec_enc_.g_pass = VPX_RC_LAST_PASS;\n+  svc_.temporal_layers = 2;\n+  codec_enc_.g_error_resilient = 0;\n+  codec_enc_.g_w = 704;\n+  codec_enc_.g_h = 144;\n+  tile_columns_ = 1;\n+  tile_rows_ = 1;\n+  vpx_svc_set_options(&svc_, \""auto-alt-refs=1 scale-factors=1/1 \""\n+                      \""multi-frame-contexts=1\"");\n+  vpx_fixed_buf outputs[10];\n+  memset(&outputs[0], 0, sizeof(outputs));\n+  Pass2EncodeNFrames(&stats_buf, 10, 1, &outputs[0]);\n+  DecodeNFrames(&outputs[0], 10);\n+  FreeBitstreamBuffers(&outputs[0], 10);\n }\n \n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/test-data.mk"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/test-data.mk"", ""patch"": ""@@ -0,0 +1,770 @@\n\n+LIBVPX_TEST_SRCS-yes += test-data.mk\n+\n+# Encoder test source\n+LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += hantro_collage_w352h288.yuv\n+LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += hantro_odd.yuv\n+\n+LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += park_joy_90p_10_420.y4m\n+LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += park_joy_90p_10_422.y4m\n+LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += park_joy_90p_10_444.y4m\n+LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += park_joy_90p_10_440.yuv\n+LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += park_joy_90p_12_420.y4m\n+LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += park_joy_90p_12_422.y4m\n+LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += park_joy_90p_12_444.y4m\n+LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += park_joy_90p_12_440.yuv\n+LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += park_joy_90p_8_420_a10-1.y4m\n+LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += park_joy_90p_8_420.y4m\n+LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += park_joy_90p_8_422.y4m\n+LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += park_joy_90p_8_444.y4m\n+LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += park_joy_90p_8_440.yuv\n+\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_ENCODER) += niklas_1280_720_30.y4m\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_ENCODER) += rush_hour_444.y4m\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_ENCODER) += screendata.y4m\n+\n+# Test vectors\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-001.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-001.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-002.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-002.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-003.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-003.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-004.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-004.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-005.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-005.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-006.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-006.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-007.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-007.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-008.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-008.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-009.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-009.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-010.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-010.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-011.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-011.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-012.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-012.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-013.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-013.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-014.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-014.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-015.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-015.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-016.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-016.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-017.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-017.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-018.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-018.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-01-intra-1400.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-01-intra-1400.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-01-intra-1411.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-01-intra-1411.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-01-intra-1416.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-01-intra-1416.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-01-intra-1417.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-01-intra-1417.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-02-inter-1402.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-02-inter-1402.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-02-inter-1412.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-02-inter-1412.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-02-inter-1418.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-02-inter-1418.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-02-inter-1424.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-02-inter-1424.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-01.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-01.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-02.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-02.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-03.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-03.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-04.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-04.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1401.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1401.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1403.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1403.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1407.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1407.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1408.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1408.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1409.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1409.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1410.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1410.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1413.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1413.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1414.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1414.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1415.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1415.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1425.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1425.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1426.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1426.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1427.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1427.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1432.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1432.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1435.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1435.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1436.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1436.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1437.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1437.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1441.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1441.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1442.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1442.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-04-partitions-1404.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-04-partitions-1404.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-04-partitions-1405.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-04-partitions-1405.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-04-partitions-1406.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-04-partitions-1406.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1428.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1428.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1429.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1429.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1430.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1430.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1431.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1431.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1433.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1433.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1434.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1434.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1438.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1438.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1439.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1439.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1440.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1440.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1443.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1443.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-06-smallsize.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-06-smallsize.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-00.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-00.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-01.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-01.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-02.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-02.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-03.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-03.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-04.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-04.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-05.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-05.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-06.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-06.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-07.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-07.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-08.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-08.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-09.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-09.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-10.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-10.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-11.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-11.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-12.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-12.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-13.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-13.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-14.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-14.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-15.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-15.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-16.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-16.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-17.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-17.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-18.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-18.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-19.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-19.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-20.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-20.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-21.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-21.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-22.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-22.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-23.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-23.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-24.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-24.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-25.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-25.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-26.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-26.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-27.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-27.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-28.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-28.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-29.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-29.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-30.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-30.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-31.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-31.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-32.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-32.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-33.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-33.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-34.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-34.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-35.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-35.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-36.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-36.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-37.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-37.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-38.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-38.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-39.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-39.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-40.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-40.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-41.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-41.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-42.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-42.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-43.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-43.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-44.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-44.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-45.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-45.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-46.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-46.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-47.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-47.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-48.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-48.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-49.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-49.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-50.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-50.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-51.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-51.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-52.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-52.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-53.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-53.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-54.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-54.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-55.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-55.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-56.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-56.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-57.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-57.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-58.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-58.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-59.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-59.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-60.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-60.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-61.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-61.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-62.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-62.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-63.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-63.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-1.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-1.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-2.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-2.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-3.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-3.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-4.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-4.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-5.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-5.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-6.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-6.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-7.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-7.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x08.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x08.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x10.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x10.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x16.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x16.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x18.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x18.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x32.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x32.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x34.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x34.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x64.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x64.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x66.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x66.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x08.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x08.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x10.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x10.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x16.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x16.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x18.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x18.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x32.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x32.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x34.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x34.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x64.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x64.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x66.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x66.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x08.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x08.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x10.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x10.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x16.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x16.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x18.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x18.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x32.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x32.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x34.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x34.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x64.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x64.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x66.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x66.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x08.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x08.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x10.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x10.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x16.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x16.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x18.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x18.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x32.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x32.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x34.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x34.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x64.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x64.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x66.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x66.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x08.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x08.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x10.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x10.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x16.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x16.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x18.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x18.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x32.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x32.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x34.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x34.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x64.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x64.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x66.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x66.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x08.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x08.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x10.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x10.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x16.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x16.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x18.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x18.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x32.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x32.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x34.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x34.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x64.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x64.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x66.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x66.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x08.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x08.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x10.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x10.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x16.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x16.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x18.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x18.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x32.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x32.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x34.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x34.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x64.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x64.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x66.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x66.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x08.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x08.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x10.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x10.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x16.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x16.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x18.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x18.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x32.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x32.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x34.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x34.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x64.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x64.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x66.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x66.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-lf-1920x1080.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-lf-1920x1080.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-deltaq.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-deltaq.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x196.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x196.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x198.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x198.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x200.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x200.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x202.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x202.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x208.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x208.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x210.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x210.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x224.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x224.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x226.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x226.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x196.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x196.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x198.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x198.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x200.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x200.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x202.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x202.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x208.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x208.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x210.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x210.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x224.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x224.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x226.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x226.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x196.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x196.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x198.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x198.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x200.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x200.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x202.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x202.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x208.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x208.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x210.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x210.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x224.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x224.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x226.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x226.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x196.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x196.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x198.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x198.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x200.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x200.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x202.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x202.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x208.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x208.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x210.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x210.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x224.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x224.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x226.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x226.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x196.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x196.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x198.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x198.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x200.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x200.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x202.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x202.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x208.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x208.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x210.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x210.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x224.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x224.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x226.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x226.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x196.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x196.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x198.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x198.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x200.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x200.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x202.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x202.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x208.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x208.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x210.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x210.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x224.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x224.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x226.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x226.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x196.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x196.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x198.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x198.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x200.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x200.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x202.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x202.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x208.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x208.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x210.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x210.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x224.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x224.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x226.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x226.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x196.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x196.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x198.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x198.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x200.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x200.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x202.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x202.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x208.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x208.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x210.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x210.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x224.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x224.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x226.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x226.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-05-resize.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-05-resize.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-06-bilinear.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-06-bilinear.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-07-frame_parallel.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-07-frame_parallel.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-07-frame_parallel-1.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-07-frame_parallel-1.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile-4x1.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile-4x1.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile-4x4.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile-4x4.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x2.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x2.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x2_frame_parallel.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x2_frame_parallel.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x4.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x4.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x4_frame_parallel.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x4_frame_parallel.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x8.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x8.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x8_frame_parallel.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x8_frame_parallel.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-09-aq2.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-09-aq2.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-09-lf_deltas.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-09-lf_deltas.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-09-subpixel-00.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-09-subpixel-00.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-10-show-existing-frame.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-10-show-existing-frame.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-10-show-existing-frame2.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-10-show-existing-frame2.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-11-size-351x287.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-11-size-351x287.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-11-size-351x288.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-11-size-351x288.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-11-size-352x287.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-11-size-352x287.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-12-droppable_1.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-12-droppable_1.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-12-droppable_2.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-12-droppable_2.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-12-droppable_3.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-12-droppable_3.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-13-largescaling.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-13-largescaling.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-16.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-16.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-2-4-8-16.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-2-4-8-16.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-2.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-2.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-4.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-4.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-8.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-8.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-1.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-1.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-2.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-2.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-4.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-4.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-8-4-2-1.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-8-4-2-1.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-8.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-8.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-2-1.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-2-1.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-2-16.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-2-16.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-2-4.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-2-4.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-2-8.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-2-8.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-4-1.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-4-1.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-4-16.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-4-16.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-4-2.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-4-2.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-4-8.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-4-8.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-8-1.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-8-1.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-8-16.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-8-16.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-8-2.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-8-2.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-8-4.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-8-4.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-15-segkey.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-15-segkey.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-15-segkey_adpq.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-15-segkey_adpq.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-16-intra-only.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-16-intra-only.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-17-show-existing-frame.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-17-show-existing-frame.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-18-resize.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-18-resize.ivf.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-19-skip.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-19-skip.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-19-skip-01.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-19-skip-01.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-19-skip-02.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-19-skip-02.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp91-2-04-yuv422.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp91-2-04-yuv422.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp91-2-04-yuv440.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp91-2-04-yuv440.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp91-2-04-yuv444.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp91-2-04-yuv444.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-20-big_superframe-01.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-20-big_superframe-01.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-20-big_superframe-02.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-20-big_superframe-02.webm.md5\n+ifeq ($(CONFIG_VP9_HIGHBITDEPTH),yes)\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp92-2-20-10bit-yuv420.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp92-2-20-10bit-yuv420.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp92-2-20-12bit-yuv420.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp92-2-20-12bit-yuv420.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp93-2-20-10bit-yuv422.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp93-2-20-10bit-yuv422.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp93-2-20-12bit-yuv422.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp93-2-20-12bit-yuv422.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp93-2-20-10bit-yuv440.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp93-2-20-10bit-yuv440.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp93-2-20-12bit-yuv440.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp93-2-20-12bit-yuv440.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp93-2-20-10bit-yuv444.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp93-2-20-10bit-yuv444.webm.md5\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp93-2-20-12bit-yuv444.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp93-2-20-12bit-yuv444.webm.md5\n+endif  # CONFIG_VP9_HIGHBITDEPTH\n+\n+# Invalid files for testing libvpx error checking.\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-01-v2.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-01-v2.webm.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-02-v2.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-02-v2.webm.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-03-v3.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-03-v3.webm.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-00-quantizer-00.webm.ivf.s5861_r01-05_b6-.v2.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-00-quantizer-00.webm.ivf.s5861_r01-05_b6-.v2.ivf.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-00-quantizer-11.webm.ivf.s52984_r01-05_b6-.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-00-quantizer-11.webm.ivf.s52984_r01-05_b6-.ivf.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-00-quantizer-11.webm.ivf.s52984_r01-05_b6-z.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-00-quantizer-11.webm.ivf.s52984_r01-05_b6-z.ivf.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-03-size-202x210.webm.ivf.s113306_r01-05_b6-.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-03-size-202x210.webm.ivf.s113306_r01-05_b6-.ivf.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-03-size-224x196.webm.ivf.s44156_r01-05_b6-.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-03-size-224x196.webm.ivf.s44156_r01-05_b6-.ivf.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-05-resize.ivf.s59293_r01-05_b6-.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-05-resize.ivf.s59293_r01-05_b6-.ivf.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-08-tile_1x2_frame_parallel.webm.ivf.s47039_r01-05_b6-.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-08-tile_1x2_frame_parallel.webm.ivf.s47039_r01-05_b6-.ivf.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-08-tile_1x8_frame_parallel.webm.ivf.s288_r01-05_b6-.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-08-tile_1x8_frame_parallel.webm.ivf.s288_r01-05_b6-.ivf.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-08-tile_1x4_frame_parallel_all_key.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-08-tile_1x4_frame_parallel_all_key.webm.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-09-aq2.webm.ivf.s3984_r01-05_b6-.v2.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-09-aq2.webm.ivf.s3984_r01-05_b6-.v2.ivf.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-09-subpixel-00.ivf.s19552_r01-05_b6-.v2.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-09-subpixel-00.ivf.s19552_r01-05_b6-.v2.ivf.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-09-subpixel-00.ivf.s20492_r01-05_b6-.v2.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-09-subpixel-00.ivf.s20492_r01-05_b6-.v2.ivf.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-12-droppable_1.ivf.s3676_r01-05_b6-.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-12-droppable_1.ivf.s3676_r01-05_b6-.ivf.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-12-droppable_1.ivf.s73804_r01-05_b6-.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-12-droppable_1.ivf.s73804_r01-05_b6-.ivf.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp91-2-mixedrefcsp-444to420.ivf\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp91-2-mixedrefcsp-444to420.ivf.res\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-07-frame_parallel-1.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-07-frame_parallel-2.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += invalid-vp90-2-07-frame_parallel-3.webm\n+\n+ifeq ($(CONFIG_DECODE_PERF_TESTS),yes)\n+# Encode / Decode test\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_ENCODER) += niklas_1280_720_30.yuv\n+# BBB VP9 streams\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-bbb_426x240_tile_1x1_180kbps.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-bbb_640x360_tile_1x2_337kbps.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-bbb_854x480_tile_1x2_651kbps.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-bbb_1280x720_tile_1x4_1310kbps.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-bbb_1920x1080_tile_1x1_2581kbps.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-bbb_1920x1080_tile_1x4_2586kbps.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-bbb_1920x1080_tile_1x4_fpm_2304kbps.webm\n+# Sintel VP9 streams\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-sintel_426x182_tile_1x1_171kbps.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-sintel_640x272_tile_1x2_318kbps.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-sintel_854x364_tile_1x2_621kbps.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-sintel_1280x546_tile_1x4_1257kbps.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-sintel_1920x818_tile_1x4_fpm_2279kbps.webm\n+# TOS VP9 streams\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-tos_426x178_tile_1x1_181kbps.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-tos_640x266_tile_1x2_336kbps.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-tos_854x356_tile_1x2_656kbps.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-tos_854x356_tile_1x2_fpm_546kbps.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-tos_1280x534_tile_1x4_1306kbps.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-tos_1280x534_tile_1x4_fpm_952kbps.webm\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-tos_1920x800_tile_1x4_fpm_2335kbps.webm\n+endif  # CONFIG_DECODE_PERF_TESTS\n+\n+ifeq ($(CONFIG_ENCODE_PERF_TESTS),yes)\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_ENCODER) += desktop_640_360_30.yuv\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_ENCODER) += kirland_640_480_30.yuv\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_ENCODER) += macmarcomoving_640_480_30.yuv\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_ENCODER) += macmarcostationary_640_480_30.yuv\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_ENCODER) += niklas_1280_720_30.yuv\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_ENCODER) += niklas_640_480_30.yuv\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_ENCODER) += tacomanarrows_640_480_30.yuv\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_ENCODER) += tacomasmallcameramovement_640_480_30.yuv\n+LIBVPX_TEST_DATA-$(CONFIG_VP9_ENCODER) += thaloundeskmtg_640_480_30.yuv\n+endif  # CONFIG_ENCODE_PERF_TESTS\n+\n+# sort and remove duplicates\n+LIBVPX_TEST_DATA-yes := $(sort $(LIBVPX_TEST_DATA-yes))\n""}<_**next**_>{""filename"": ""libvpx/test/test-data.sha1"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/test-data.sha1"", ""patch"": ""@@ -1,637 +1,745 @@\n\n-d5dfb0151c9051f8c85999255645d7a23916d3c0  hantro_collage_w352h288.yuv\n-998cec53307c94aa5835aaf8d5731f6a3c7c2e5a  hantro_collage_w352h288.stat\n-b87815bf86020c592ccc7a846ba2e28ec8043902  hantro_odd.yuv\n-b1f1c3ec79114b9a0651af24ce634afb44a9a419  rush_hour_444.y4m\n-5184c46ddca8b1fadd16742e8500115bc8f749da  vp80-00-comprehensive-001.ivf\n-65bf1bbbced81b97bd030f376d1b7f61a224793f  vp80-00-comprehensive-002.ivf\n-906b4c1e99eb734504c504b3f1ad8052137ce672  vp80-00-comprehensive-003.ivf\n-ec144b1af53af895db78355785650b96dd3f0ade  vp80-00-comprehensive-004.ivf\n-afc7091785c62f1c121c4554a2830c30704587d9  vp80-00-comprehensive-005.ivf\n-42ea9d55c818145d06a9b633b8e85c6a6164fd3e  vp80-00-comprehensive-006.ivf\n-e5b3a73ab79fe024c14309d653d6bed92902ee3b  vp80-00-comprehensive-007.ivf\n-f3c50a58875930adfb84525c0ef59d7e4c08540c  vp80-00-comprehensive-008.ivf\n-4b2841fdb83db51ae322096ae468bbb9dc2c8362  vp80-00-comprehensive-009.ivf\n-efbff736e3a91ab6a98c5bc2dce65d645944c7b1  vp80-00-comprehensive-010.ivf\n-6b315102cae008d22a3d2c231be92cb704a222f8  vp80-00-comprehensive-011.ivf\n-f3214a4fea14c2d5ec689936c1613f274c859ee8  vp80-00-comprehensive-012.ivf\n-e4094e96d308c8a35b74c480a43d853c5294cd34  vp80-00-comprehensive-013.ivf\n-5b0adfaf60a69e0aaf3ec021a39d0a68fc0e1b5a  vp80-00-comprehensive-014.ivf\n-e8467688ddf26b5000664f904faf0d70506aa653  vp80-00-comprehensive-015.ivf\n-aab55582337dfd2a39ff54fb2576a91910d49337  vp80-00-comprehensive-016.ivf\n-1ba24724f80203c9bae4f1d0f99d534721980016  vp80-00-comprehensive-017.ivf\n-143a15512b46f436280ddb4d0e6411eb4af434f2  vp80-00-comprehensive-018.ivf\n-c5baeaf5714fdfb3a8bc960a8e33ac438e83b16b  vp80-01-intra-1400.ivf\n-f383955229afe3408453e316d11553d923ca60d5  vp80-01-intra-1411.ivf\n-84e1f4343f174c9f3c83f834bac3196fb325bf2c  vp80-01-intra-1416.ivf\n-fb6e712a47dd57a28a3727d2ae2c97a8b7c7ca51  vp80-01-intra-1417.ivf\n-71ea772d3e9d315b8cbecf41207b8a237c34853b  vp80-02-inter-1402.ivf\n-d85dbc4271525dcd128c503f936fe69091d1f8d0  vp80-02-inter-1412.ivf\n-d4e5d3ad56511867d025f93724d090f92ba6ec3d  vp80-02-inter-1418.ivf\n-91791cbcc37c60f35dbd8090bacb54e5ec6dd4fa  vp80-02-inter-1424.ivf\n-17fbfe2fea70f6e2f3fa6ca4efaae6c0b03b5f02  vp80-03-segmentation-01.ivf\n-3c3600dbbcde08e20d54c66fe3b7eadd4f09bdbb  vp80-03-segmentation-02.ivf\n-c156778d5340967d4b369c490848076e92f1f875  vp80-03-segmentation-03.ivf\n-d25dcff6c60e87a1af70945b8911b6b4998533b0  vp80-03-segmentation-04.ivf\n-362baba2ce454c9db21218f35e81c27a5ed0b730  vp80-03-segmentation-1401.ivf\n-d223ae7ee748ce07e74c4679bfd219e84aa9f4b0  vp80-03-segmentation-1403.ivf\n-033adf7f3a13836a3f1cffcb87c1972900f2b5c6  vp80-03-segmentation-1407.ivf\n-4d51dfbf9f3e2c590ec99d1d6f59dd731d04375f  vp80-03-segmentation-1408.ivf\n-f37a62b197c2600d75e0ccfbb31b60efdedac251  vp80-03-segmentation-1409.ivf\n-eb25bd7bfba5b2f6935018a930f42d123b1e7fcd  vp80-03-segmentation-1410.ivf\n-b9d5c436663a30c27cfff84b53a002e501258843  vp80-03-segmentation-1413.ivf\n-6da92b9d1a180cc3a8afe348ab12258f5a37be1a  vp80-03-segmentation-1414.ivf\n-a4f5842602886bd669f115f93d8a35c035cb0948  vp80-03-segmentation-1415.ivf\n-f295dceb8ef278b77251b3f9df8aee22e161d547  vp80-03-segmentation-1425.ivf\n-198dbf9f36f733200e432664cc8c5752d59779de  vp80-03-segmentation-1426.ivf\n-7704804e32f5de976803929934a7fafe101ac7b0  vp80-03-segmentation-1427.ivf\n-831ccd862ea95ca025d2f3bd8b88678752f5416d  vp80-03-segmentation-1432.ivf\n-b3c11978529289f9109f2766fcaba3ebc40e11ef  vp80-03-segmentation-1435.ivf\n-a835a731f5520ebfc1002c40121264d0020559ac  vp80-03-segmentation-1436.ivf\n-1d1732942f773bb2a5775fcb9689b1579ce28eab  vp80-03-segmentation-1437.ivf\n-db04799adfe089dfdf74dbd43cc05ede7161f99e  vp80-03-segmentation-1441.ivf\n-7caf39b3f20cfd52b998210878062e52a5edf1e6  vp80-03-segmentation-1442.ivf\n-3607f6bb4ee106c38fa1ea370dc4ff8b8cde2261  vp80-04-partitions-1404.ivf\n-93cc323b6b6867f1b12dd48773424549c6960a6b  vp80-04-partitions-1405.ivf\n-047eedb14b865bdac8a3538e63801054e0295e9c  vp80-04-partitions-1406.ivf\n-0f1233bd2bc33f56ce5e495dbd455d122339f384  vp80-05-sharpness-1428.ivf\n-51767fc136488a9535c2a4c38067c542ee2048df  vp80-05-sharpness-1429.ivf\n-9805aa107672de25d6fb8c35e20d06deca5efe18  vp80-05-sharpness-1430.ivf\n-61db6b965f9c27aebe71b85bf2d5877e58e4bbdf  vp80-05-sharpness-1431.ivf\n-10420d266290d2923555f84af38eeb96edbd3ae8  vp80-05-sharpness-1433.ivf\n-3ed24f9a80cddfdf75824ba95cdb4ff9286cb443  vp80-05-sharpness-1434.ivf\n-c87599cbecd72d4cd4f7ace3313b7a6bc6eb8163  vp80-05-sharpness-1438.ivf\n-aff51d865c2621b60510459244ea83e958e4baed  vp80-05-sharpness-1439.ivf\n-da386e72b19b5485a6af199c5eb60ef25e510dd1  vp80-05-sharpness-1440.ivf\n-6759a095203d96ccd267ce09b1b050b8cc4c2f1f  vp80-05-sharpness-1443.ivf\n-b95d3cc1d0df991e63e150a801710a72f20d9ba0  vp80-06-smallsize.ivf\n-db55ec7fd02c864ba996ff060b25b1e08611330b  vp80-00-comprehensive-001.ivf.md5\n-29db0ad011cba1e45f856d5623cd38dac3e3bf19  vp80-00-comprehensive-002.ivf.md5\n-e84f258f69e173e7d68f8f8c037a0a3766902182  vp80-00-comprehensive-003.ivf.md5\n-eb7912eaf69559a16fd82bc3f5fb1524cf4a4466  vp80-00-comprehensive-004.ivf.md5\n-4206f71c94894bd5b5b376f6c09b3817dbc65206  vp80-00-comprehensive-005.ivf.md5\n-4f89b356f6f2fecb928f330a10f804f00f5325f5  vp80-00-comprehensive-006.ivf.md5\n-2813236a32964dd8007e17648bcf035a20fcda6c  vp80-00-comprehensive-007.ivf.md5\n-10746c72098f872803c900e17c5680e451f5f498  vp80-00-comprehensive-008.ivf.md5\n-39a23d0692ce64421a7bb7cdf6ccec5928d37fff  vp80-00-comprehensive-009.ivf.md5\n-f6e3de8931a0cc659bda8fbc14050346955e72d4  vp80-00-comprehensive-010.ivf.md5\n-101683ec195b6e944f7cd1e468fc8921439363e6  vp80-00-comprehensive-011.ivf.md5\n-1f592751ce46d8688998fa0fa4fbdcda0fd4058c  vp80-00-comprehensive-012.ivf.md5\n-6066176f90ca790251e795fca1a5797d59999841  vp80-00-comprehensive-013.ivf.md5\n-2656da94ba93691f23edc4d60b3a09e2be46c217  vp80-00-comprehensive-014.ivf.md5\n-c6e0d5f5d61460c8ac8edfa4e701f10312c03133  vp80-00-comprehensive-015.ivf.md5\n-ee60fee501d8493e34e8d6a1fe315b51ed09b24a  vp80-00-comprehensive-016.ivf.md5\n-9f1914ceffcad4546c0a29de3ef591d8bea304dc  vp80-00-comprehensive-017.ivf.md5\n-e0305178fe288a9fd8082b39e2d03181edb19054  vp80-00-comprehensive-018.ivf.md5\n-612494da2fa799cc9d76dcdd835ae6c7cb2e5c05  vp80-01-intra-1400.ivf.md5\n-48ea06097ac8269c5e8c2131d3d0639f431fcf0e  vp80-01-intra-1411.ivf.md5\n-6e2ab4e7677ad0ba868083ca6bc387ee922b400c  vp80-01-intra-1416.ivf.md5\n-eca0a90348959ce3854142f8d8641b13050e8349  vp80-01-intra-1417.ivf.md5\n-920feea203145d5c2258a91c4e6991934a79a99e  vp80-02-inter-1402.ivf.md5\n-f71d97909fe2b3dd65be7e1f56c72237f0cef200  vp80-02-inter-1412.ivf.md5\n-e911254569a30bbb2a237ff8b79f69ed9da0672d  vp80-02-inter-1418.ivf.md5\n-58c789c50c9bb9cc90580bed291164a0939d28ba  vp80-02-inter-1424.ivf.md5\n-ff3e2f441327b9c20a0b37c524e0f5a48a36de7b  vp80-03-segmentation-01.ivf.md5\n-0791f417f076a542ae66fbc3426ab4d94cbd6c75  vp80-03-segmentation-02.ivf.md5\n-722e50f1a6a91c34302d68681faffc1c26d1cc57  vp80-03-segmentation-03.ivf.md5\n-c701f1885bcfb27fb8e70cc65606b289172ef889  vp80-03-segmentation-04.ivf.md5\n-f79bc9ec189a2b4807632a3d0c5bf04a178b5300  vp80-03-segmentation-1401.ivf.md5\n-b9aa4c74c0219b639811c44760d0b24cd8bb436a  vp80-03-segmentation-1403.ivf.md5\n-70d5a2207ca1891bcaebd5cf6dd88ce8d57b4334  vp80-03-segmentation-1407.ivf.md5\n-265f962ee781531f9a93b9309461316fd32b2a1d  vp80-03-segmentation-1408.ivf.md5\n-0c4ecbbd6dc042d30e626d951b65f460dd6cd563  vp80-03-segmentation-1409.ivf.md5\n-cf779af36a937f06570a0fca9db64ba133451dee  vp80-03-segmentation-1410.ivf.md5\n-0e6c5036d51ab078842f133934926c598a9cff02  vp80-03-segmentation-1413.ivf.md5\n-eb3930aaf229116c80d507516c34759c3f6cdf69  vp80-03-segmentation-1414.ivf.md5\n-123d6c0f72ee87911c4ae7538e87b7d163b22d6c  vp80-03-segmentation-1415.ivf.md5\n-e70551d1a38920e097a5d8782390b79ecaeb7505  vp80-03-segmentation-1425.ivf.md5\n-44e8f4117e46dbb302b2cfd81171cc1a1846e431  vp80-03-segmentation-1426.ivf.md5\n-52636e54aee5f95bbace37021bd67de5db767e9a  vp80-03-segmentation-1427.ivf.md5\n-b1ad3eff20215c28e295b15ef3636ed926d59cba  vp80-03-segmentation-1432.ivf.md5\n-24c22a552fa28a90e5978f67f57181cc2d7546d7  vp80-03-segmentation-1435.ivf.md5\n-96c49c390abfced18a7a8c9b9ea10af778e10edb  vp80-03-segmentation-1436.ivf.md5\n-f95eb6214571434f1f73ab7833b9ccdf47588020  vp80-03-segmentation-1437.ivf.md5\n-1c0700ca27c9b0090a7747a4b0b4dc21d1843181  vp80-03-segmentation-1441.ivf.md5\n-81d4f23ca32667ee958bae579c8f5e97ba72eb97  vp80-03-segmentation-1442.ivf.md5\n-272efcef07a3a30fbca51bfd566063d8258ec0be  vp80-04-partitions-1404.ivf.md5\n-66ed219ab812ac801b256d35cf495d193d4cf478  vp80-04-partitions-1405.ivf.md5\n-36083f37f56f502bd60ec5e07502ee9e6b8699b0  vp80-04-partitions-1406.ivf.md5\n-6ca909bf168a64c09415626294665dc1be3d1973  vp80-05-sharpness-1428.ivf.md5\n-1667d2ee2334e5fdea8a8a866f4ccf3cf76f033a  vp80-05-sharpness-1429.ivf.md5\n-71bcbe5357d36a19df5b07fbe3e27bffa8893f0a  vp80-05-sharpness-1430.ivf.md5\n-89a09b1dffce2d55770a89e58d9925c70ef79bf8  vp80-05-sharpness-1431.ivf.md5\n-08444a18b4e6ba3450c0796dd728d48c399a2dc9  vp80-05-sharpness-1433.ivf.md5\n-6d6223719a90c13e848aa2a8a6642098cdb5977a  vp80-05-sharpness-1434.ivf.md5\n-41d70bb5fa45bc88da1604a0af466930b8dd77b5  vp80-05-sharpness-1438.ivf.md5\n-086c56378df81b6cee264d7540a7b8f2b405c7a4  vp80-05-sharpness-1439.ivf.md5\n-d32dc2c4165eb266ea4c23c14a45459b363def32  vp80-05-sharpness-1440.ivf.md5\n-8c69dc3d8e563f56ffab5ad1e400d9e689dd23df  vp80-05-sharpness-1443.ivf.md5\n-d6f246df012c241b5fa6c1345019a3703d85c419  vp80-06-smallsize.ivf.md5\n-ce881e567fe1d0fbcb2d3e9e6281a1a8d74d82e0  vp90-2-00-quantizer-00.webm\n-ac5eda33407d0521c7afca43a63fd305c0cd9d13  vp90-2-00-quantizer-00.webm.md5\n-2ca0463f2cfb93d25d7dded174db70b7cb87cb48  vp90-2-00-quantizer-01.webm\n-10d98884fc6d9a5f47a2057922b8e25dd48d7786  vp90-2-00-quantizer-01.webm.md5\n-d80a2920a5e0819d69dcba8fe260c01f820f8982  vp90-2-00-quantizer-02.webm\n-c964c8e5e04165fabbf1c6ee8ee5121d35921965  vp90-2-00-quantizer-02.webm.md5\n-fdef046777b5b75c962b715d809dbe2ea331afb9  vp90-2-00-quantizer-03.webm\n-f270bee0b0c7aa2bf4c5afe098556b4f3f890faf  vp90-2-00-quantizer-03.webm.md5\n-66d98609e809394a6ac730787e6724e3badc075a  vp90-2-00-quantizer-04.webm\n-427433bfe121c4aea1095ec3124fdc174d200e3a  vp90-2-00-quantizer-04.webm.md5\n-e6e42626d8cadf0b5be16313f69212981b96fee5  vp90-2-00-quantizer-05.webm\n-c98f6a9a1af4cfd71416792827304266aad4bd46  vp90-2-00-quantizer-05.webm.md5\n-413ef09b721f5dcec1a96e937a97e5873c2e6db6  vp90-2-00-quantizer-06.webm\n-5080e940a23805c82e578e21b57fc2c511e76376  vp90-2-00-quantizer-06.webm.md5\n-4a50a5f4ac717c30dfaae8bb46702e3542e867de  vp90-2-00-quantizer-07.webm\n-76c429a02b56762e10ee4db88729d8834b3a70f4  vp90-2-00-quantizer-07.webm.md5\n-d2f4e464780bf8b7e647efa18ac777a930e62bc0  vp90-2-00-quantizer-08.webm\n-ab94aabf9316111b52d7c531962ed4123313b6ba  vp90-2-00-quantizer-08.webm.md5\n-174bc58433936dd79550398d744f1072ce7f5693  vp90-2-00-quantizer-09.webm\n-e1f7690cd83ccc56d045e17cce552544a5f03810  vp90-2-00-quantizer-09.webm.md5\n-52bc1dfd3a97b24d922eb8a31d07527891561f2a  vp90-2-00-quantizer-10.webm\n-9b37bed893b5f6a4e12f2aa40f02dd40f944d0f8  vp90-2-00-quantizer-10.webm.md5\n-10031eecafde1e1d8e6323fe2b2a1d7e77a66869  vp90-2-00-quantizer-11.webm\n-fe4620a4bb0e4f5cb9bbfedc4039a22b81b0f5c0  vp90-2-00-quantizer-11.webm.md5\n-78e9f7bb77e8e348155bbdfa12790789d1d50c34  vp90-2-00-quantizer-12.webm\n-0961d060cc8dd469c6dac8d7d75f927c0bb971b8  vp90-2-00-quantizer-12.webm.md5\n-133b77a3bbcef652552d74ffc46afbfe3b8a1cba  vp90-2-00-quantizer-13.webm\n-df29e5e0f95772af482f540d776f6b9dea4bfa29  vp90-2-00-quantizer-13.webm.md5\n-27323afdaf8987e025c27129c74c86502315a206  vp90-2-00-quantizer-14.webm\n-ce96a2cc312942f0427a463f15a392870dd69764  vp90-2-00-quantizer-14.webm.md5\n-ab58d0b41037829f6bc993910999f4af0212aafd  vp90-2-00-quantizer-15.webm\n-40f700db606501aa7cb49049624cbdde6409b122  vp90-2-00-quantizer-15.webm.md5\n-cd948e66448aafb65998815ce37241f95d7c9ee7  vp90-2-00-quantizer-16.webm\n-039b742d149c945ed79c7b9a6384352852a1c116  vp90-2-00-quantizer-16.webm.md5\n-62f56e663e13c576764e491cf08f19bd46a71999  vp90-2-00-quantizer-17.webm\n-90c5a39bf76e6b3e0a1c0d3e9b68a9fd78be963e  vp90-2-00-quantizer-17.webm.md5\n-f26ecad7263cd66a614e53ba5d7c00df181affeb  vp90-2-00-quantizer-18.webm\n-cda0a1c0fca2ec2976ae55124a8a67305508bae6  vp90-2-00-quantizer-18.webm.md5\n-94bfc4c04fcfe139a63b98c569e8c14ba98c401f  vp90-2-00-quantizer-19.webm\n-5b8ec169ccf67d8a0a8e46a62eb173f5a1dbaf4f  vp90-2-00-quantizer-19.webm.md5\n-0ee88e9318985e1e245de78c2c4a665885ab76a7  vp90-2-00-quantizer-20.webm\n-4b26f7edb4fcd3a1b4cce9ba3cb8650e3ee6e063  vp90-2-00-quantizer-20.webm.md5\n-6a995cb2b1db33da8087321df1e646f95c3e32d1  vp90-2-00-quantizer-21.webm\n-e216b4a1eceac03efcc433759be54ab8ea87b24b  vp90-2-00-quantizer-21.webm.md5\n-aa7722fc427e7180115f3c9cd96bb6b2768e7296  vp90-2-00-quantizer-22.webm\n-1aa813bd45ae831bf5e79ace4d73dfd25989a07d  vp90-2-00-quantizer-22.webm.md5\n-7677e5b929ed6d142041f19b8a9cd5822ee1504a  vp90-2-00-quantizer-23.webm\n-0de0af34abd843d5b37e58baf3ed96a6104b64c3  vp90-2-00-quantizer-23.webm.md5\n-b2995cbe1128b2d4926f1b28d01c501ecb6be8c8  vp90-2-00-quantizer-24.webm\n-db6033af2ba2f2bca62468fb4b8808e474f93923  vp90-2-00-quantizer-24.webm.md5\n-8135ba35587fd92cd4667be7896323d9b634401c  vp90-2-00-quantizer-25.webm\n-3499e00c2cc15876f61f07e3d3cfca54ebcd98fd  vp90-2-00-quantizer-25.webm.md5\n-af0fa2907746db82d345f6d831fcc1b2862a29fb  vp90-2-00-quantizer-26.webm\n-cd6fe3d14dab48886ebf65be00e6ed9616ebe5a7  vp90-2-00-quantizer-26.webm.md5\n-bd0002e91323776beb5ff11e06edcf19fc08e9b9  vp90-2-00-quantizer-27.webm\n-fe72154ef196067d6c272521012dd79706496cac  vp90-2-00-quantizer-27.webm.md5\n-fc15eb606f81455ff03df16bf3432296b002c43c  vp90-2-00-quantizer-28.webm\n-40b2e24b542206a6bfd746ef199e49ccea07678a  vp90-2-00-quantizer-28.webm.md5\n-3090bbf913cad0b2eddca7228f5ed51a58378b8d  vp90-2-00-quantizer-29.webm\n-eb59745e0912d8ed6c928268bcf265237c9ba93f  vp90-2-00-quantizer-29.webm.md5\n-c615abdca9c25e1cb110d908edbedfb3b7c92b91  vp90-2-00-quantizer-30.webm\n-ad0f4fe6733e4e7cdfe8ef8722bb341dcc7538c0  vp90-2-00-quantizer-30.webm.md5\n-037d9f242086cfb085518f6416259defa82d5fc2  vp90-2-00-quantizer-31.webm\n-4654b40792572f0a790874c6347ef9196d86c1a7  vp90-2-00-quantizer-31.webm.md5\n-505899f3f3515044c5c8b3213d9b9d16f614619d  vp90-2-00-quantizer-32.webm\n-659a2e6dd02df323f62600626859006640b445df  vp90-2-00-quantizer-32.webm.md5\n-8b32ec9c3b7e5ca8ddc6b8aea1c1cb7ca996bccc  vp90-2-00-quantizer-33.webm\n-5b175ef1120ddeba4feae1247bf381bbc4e816ce  vp90-2-00-quantizer-33.webm.md5\n-4d283755d17e287b1d099a80604398f60d7fb6ea  vp90-2-00-quantizer-34.webm\n-22a739de95acfeb27524e3700b8f678a9ad744d8  vp90-2-00-quantizer-34.webm.md5\n-4296f56a892a412d3d4f64824718dd566c4e6459  vp90-2-00-quantizer-35.webm\n-c532c9c8dc7b3506fc6a51e5c20c17ef0ac039e7  vp90-2-00-quantizer-35.webm.md5\n-6f54e11da461e4410dd9075b015e2d9bc1d07dfb  vp90-2-00-quantizer-36.webm\n-0b3573f5addea4e3eb11a0b85f068299d5bdad78  vp90-2-00-quantizer-36.webm.md5\n-210581682a26c2c4375efc785c36e07539888bc2  vp90-2-00-quantizer-37.webm\n-2b4fb6f8ba975237858e61cc8f560bcfc87cb38e  vp90-2-00-quantizer-37.webm.md5\n-a15ef31283dfc4860f837fe200eb32a445f59629  vp90-2-00-quantizer-38.webm\n-fb76771f3a795054b9936f70da7505c3ac585284  vp90-2-00-quantizer-38.webm.md5\n-1df8433a441412831daae6726df89fa70d21b14d  vp90-2-00-quantizer-39.webm\n-39e162c09a20e7e684868097766347014371fee6  vp90-2-00-quantizer-39.webm.md5\n-5330e4788ab9129dbb25a7a7d5411104521248b6  vp90-2-00-quantizer-40.webm\n-872cc0f2cc9dbf000f89eadb4d8f9940e48e00b1  vp90-2-00-quantizer-40.webm.md5\n-d88d03b982889e399a78d7a06eeb1cf30e6c2da2  vp90-2-00-quantizer-41.webm\n-5b4f7217e57fa2a221011d0b32f8d0409496b7b6  vp90-2-00-quantizer-41.webm.md5\n-9e16406e3e26955a6e17d455ef1ef64bbfa26e53  vp90-2-00-quantizer-42.webm\n-0219d090cf37daabe19256ba8e932ba4874b92e4  vp90-2-00-quantizer-42.webm.md5\n-a9b15843486fb05f8cd15437ef279782a42b75db  vp90-2-00-quantizer-43.webm\n-3c9b0b4c607f9579a31726bfcf56729334ddc686  vp90-2-00-quantizer-43.webm.md5\n-1dbc931ac446c91eabe7213efff55b596cccf07c  vp90-2-00-quantizer-44.webm\n-73bc8f675103abaef3d9f73a2742b3bffd726d23  vp90-2-00-quantizer-44.webm.md5\n-7c6c1be15beb9d6201204b018966c8c4f9777efc  vp90-2-00-quantizer-45.webm\n-c907b29da821f790c6748de61f592689312e4e36  vp90-2-00-quantizer-45.webm.md5\n-07b434da1a467580f73b32177ee11b3e00f65a0d  vp90-2-00-quantizer-46.webm\n-7b2b7ce60c50bc970bc0ada46d7a7ce440148da3  vp90-2-00-quantizer-46.webm.md5\n-233d0465fb1a6fa36e9f89bd2193ac79bd4d2809  vp90-2-00-quantizer-47.webm\n-527e0a9fb932efe915027ffe077f9e8d3a4fb139  vp90-2-00-quantizer-47.webm.md5\n-719613df7307e205c3fdb6acfb373849c5ab23c7  vp90-2-00-quantizer-48.webm\n-65ab6c9d1b682c183b201c7ff42b90343ce3e304  vp90-2-00-quantizer-48.webm.md5\n-3bf04a598325ed0eabae1598ec7f718f715ec672  vp90-2-00-quantizer-49.webm\n-ac68c4387ce11fcc998d8ba455ab9b2bb361d240  vp90-2-00-quantizer-49.webm.md5\n-d59238fb3a654931c9b65a11e7321b40d1f702e9  vp90-2-00-quantizer-50.webm\n-d0576bfede46fd55659f028f2fd28554ceb3e6cc  vp90-2-00-quantizer-50.webm.md5\n-3f579785101d4209360dd96f8c2ffe9beddf3bee  vp90-2-00-quantizer-51.webm\n-89fcfe04f4457a7f02ab4a2f94aacbb88aee5789  vp90-2-00-quantizer-51.webm.md5\n-28be5836e2fedefe4babf12fc9b79e460ab0a0f4  vp90-2-00-quantizer-52.webm\n-f3dd52b70c18345fee740220f35da9c4def2017a  vp90-2-00-quantizer-52.webm.md5\n-488ad4058c17170665b6acd1021fade9a02771e4  vp90-2-00-quantizer-53.webm\n-1cdcb1d4f3a37cf83ad235eb27ec62ed2a01afc7  vp90-2-00-quantizer-53.webm.md5\n-682978289cb28cc8c9d39bc797300e45d6039de7  vp90-2-00-quantizer-54.webm\n-36c35353f2c03cb099bd710d9994de7d9ed88834  vp90-2-00-quantizer-54.webm.md5\n-c398ce49af762a48f10cc4da9fae0769aae5f226  vp90-2-00-quantizer-55.webm\n-2cf3570542d984f167ab087f59493c7fb47e0ed2  vp90-2-00-quantizer-55.webm.md5\n-3071f18b2fce261aa82d61f81a7ae4ca9a75d0e3  vp90-2-00-quantizer-56.webm\n-d3f93f8272b6de31cffb011a26f11abb514efb12  vp90-2-00-quantizer-56.webm.md5\n-f4e8e14b1f278801a7eb6f11734780a01b1668e9  vp90-2-00-quantizer-57.webm\n-6478fdf1d7faf6db5f19dffc5e1363af358699ee  vp90-2-00-quantizer-57.webm.md5\n-307dc264f57cc618fff211fa44d7f52767ed9660  vp90-2-00-quantizer-58.webm\n-cf231d4a52d492fa692ea4194ec5eb7511fec54e  vp90-2-00-quantizer-58.webm.md5\n-1fd7cd596170afce2de0b1441b7674bda5723440  vp90-2-00-quantizer-59.webm\n-4681f7ef96f63e085c41bb1a964b0df7e67e0b38  vp90-2-00-quantizer-59.webm.md5\n-34cdcc81c0ba7085aefbb22d7b4aa9bca3dd7c62  vp90-2-00-quantizer-60.webm\n-58691ef53b6b623810e2c57ded374c77535df935  vp90-2-00-quantizer-60.webm.md5\n-e6e812406aab81021bb16e772c1db03f75906cb6  vp90-2-00-quantizer-61.webm\n-76436eace62f08ff92b61a0845e66667a027db1b  vp90-2-00-quantizer-61.webm.md5\n-84d811bceed70c950a6a08e572a6e274866e72b1  vp90-2-00-quantizer-62.webm\n-2d937cc011eeddd95222b960982da5cd18db580f  vp90-2-00-quantizer-62.webm.md5\n-0912b295ba0ea09359315315ffd67d22d046f883  vp90-2-00-quantizer-63.webm\n-5a829031055d70565f57dbcd47a6ac33619952b3  vp90-2-00-quantizer-63.webm.md5\n-0cf9e5ebe0112bdb47b5887ee5d58eb9d4727c00  vp90-2-01-sharpness-1.webm\n-5a0476be4448bae8f8ca17ea236c98793a755948  vp90-2-01-sharpness-1.webm.md5\n-51e02d7911810cdf5be8b68ac40aedab479a3179  vp90-2-01-sharpness-2.webm\n-a0ca5bc87a5ed7c7051f59078daa0d03be1b45b6  vp90-2-01-sharpness-2.webm.md5\n-0603f8ad239c07a531d948187f4dafcaf51eda8d  vp90-2-01-sharpness-3.webm\n-3af8000a69c72fe77881e3176f026c2affb78cc7  vp90-2-01-sharpness-3.webm.md5\n-4ca4839f48146252fb261ed88838d80211804841  vp90-2-01-sharpness-4.webm\n-08832a1494f84fa9edd40e080bcf2c0e80100c76  vp90-2-01-sharpness-4.webm.md5\n-95099dc8f9cbaf9b9a7dd65311923e441ff70731  vp90-2-01-sharpness-5.webm\n-93ceee30c140f0b406726c0d896b9db6031c4c7f  vp90-2-01-sharpness-5.webm.md5\n-ceb4116fb7b078d266d153233b6d62a255a34e4c  vp90-2-01-sharpness-6.webm\n-da83efe59e537ce538e8b03a6eac63cf25849c9a  vp90-2-01-sharpness-6.webm.md5\n-b5f7cd19aece3880f9d616a778e5cc24c6b9b505  vp90-2-01-sharpness-7.webm\n-2957408d20deac8633941a2169f801bae6f086e1  vp90-2-01-sharpness-7.webm.md5\n-ffc096c2ce1050450ad462b5fabd2a5220846319  vp90-2-02-size-08x08.webm\n-e36d2ed6fa2746347710b750586aafa6a01ff3ae  vp90-2-02-size-08x08.webm.md5\n-895b986f9fd55cd879472b31c6a06b82094418c8  vp90-2-02-size-08x10.webm\n-079157a19137ccaebba606f2871f45a397347150  vp90-2-02-size-08x10.webm.md5\n-1c5992203e62a2b83040ccbecd748b604e19f4c0  vp90-2-02-size-08x16.webm\n-9aa45ffdf2078f883bbed01450031b691819c144  vp90-2-02-size-08x16.webm.md5\n-d0a8953da1f85f484487408fee5da9e2a8391901  vp90-2-02-size-08x18.webm\n-59a5cc17d354c6a23e5e959d666b1456a5d49c56  vp90-2-02-size-08x18.webm.md5\n-1b13461a9fc65cb041bacfe4ea6f02d363397d61  vp90-2-02-size-08x32.webm\n-2bdddd6878f05d37d84cde056a3f5e7f926ba3d6  vp90-2-02-size-08x32.webm.md5\n-2861f0a0daadb62295b0504a1fbe5b50c79a8f59  vp90-2-02-size-08x34.webm\n-6b5812cfb8a82d378ea2913bf009e93668020147  vp90-2-02-size-08x34.webm.md5\n-02f948216d4246579dc53c47fe55d8fb264ba251  vp90-2-02-size-08x64.webm\n-84b55fdee6d9aa820c7a8c62822446184b191767  vp90-2-02-size-08x64.webm.md5\n-4b011242cbf42516efd2b197baebb61dd34562c9  vp90-2-02-size-08x66.webm\n-6b1fa0a885947b3cc0fe58f75f838e662bd9bb8b  vp90-2-02-size-08x66.webm.md5\n-4057796be9dd12df48ab607f502ae6aa70eeeab6  vp90-2-02-size-10x08.webm\n-71c752c51aec9f48de286b93f4c20e9c11cad7d0  vp90-2-02-size-10x08.webm.md5\n-6583c853fa43fc53d51743eac5f3a43a359d45d0  vp90-2-02-size-10x10.webm\n-1da524d24af1944b671d4d3f2b398d6e336584c3  vp90-2-02-size-10x10.webm.md5\n-ba442fc03ccd3a705c64c83b36f5ada67d198874  vp90-2-02-size-10x16.webm\n-7cfd960f232c34c641a4a2a9411b6fd0efb2fc50  vp90-2-02-size-10x16.webm.md5\n-cc92ed40eef14f52e4d080cb2c57939dd8326374  vp90-2-02-size-10x18.webm\n-db5626275cc55ce970b91c995e74f6838d943aca  vp90-2-02-size-10x18.webm.md5\n-3a93d501d22325e9fd4c9d8b82e2a432de33c351  vp90-2-02-size-10x32.webm\n-5cae51b0c71cfc131651f345f87583eb2903afaf  vp90-2-02-size-10x32.webm.md5\n-50d2f2b15a9a5178153db44a9e03aaf32b227f67  vp90-2-02-size-10x34.webm\n-bb0efe058122641e7f73e94497dda2b9e6c21efd  vp90-2-02-size-10x34.webm.md5\n-01624ec173e533e0b33fd9bdb91eb7360c7c9175  vp90-2-02-size-10x64.webm\n-b9c0e3b054463546356acf5157f9be92fd34732f  vp90-2-02-size-10x64.webm.md5\n-2942879baf1c09e96b14d0fc84806abfe129c706  vp90-2-02-size-10x66.webm\n-bab5f539c2f91952e187456b4beafbb4c01e25ee  vp90-2-02-size-10x66.webm.md5\n-88d2b63ca5e9ee163d8f20e8886f3df3ff301a66  vp90-2-02-size-16x08.webm\n-7f48a0fcf8c25963f3057d7f6669c5f2415834b8  vp90-2-02-size-16x08.webm.md5\n-59261eb34c15ea9b5ddd2d416215c1a8b9e6dc1f  vp90-2-02-size-16x10.webm\n-73a7c209a46dd051c9f7339b6e02ccd5b3b9fc81  vp90-2-02-size-16x10.webm.md5\n-066834fef9cf5b9a72932cf4dea5f253e14a976d  vp90-2-02-size-16x16.webm\n-faec542f52f37601cb9c480d887ae9355be99372  vp90-2-02-size-16x16.webm.md5\n-195307b4eb3192271ee4a935b0e48deef0c54cc2  vp90-2-02-size-16x18.webm\n-5a92e19e624c0376321d4d0e22c0c91995bc23e1  vp90-2-02-size-16x18.webm.md5\n-14f3f884216d7ae16ec521f024a2f2d31bbf9c1a  vp90-2-02-size-16x32.webm\n-ea622d1c817dd174556f7ee7ccfe4942b34d4845  vp90-2-02-size-16x32.webm.md5\n-2e0501100578a5da9dd47e4beea160f945bdd1ba  vp90-2-02-size-16x34.webm\n-1b8645ef64239334921c5f56b24ce815e6070b05  vp90-2-02-size-16x34.webm.md5\n-89a6797fbebebe93215f367229a9152277f5dcfe  vp90-2-02-size-16x64.webm\n-a03d8c1179ca626a8856fb416d635dbf377979cd  vp90-2-02-size-16x64.webm.md5\n-0f3a182e0750fcbae0b9eae80c7a53aabafdd18d  vp90-2-02-size-16x66.webm\n-8cb6736dc2d897c1283919a32068af377d66c59c  vp90-2-02-size-16x66.webm.md5\n-68fe70dc7914cc1d8d6dcd97388b79196ba3e7f1  vp90-2-02-size-18x08.webm\n-874c7fb505be9db3160c57cb405c4dbd5b990dc2  vp90-2-02-size-18x08.webm.md5\n-0546352dd78496d4dd86c3727ac2ff36c9e72032  vp90-2-02-size-18x10.webm\n-1d80eb36557ea5f25a386495a36f93da0f25316b  vp90-2-02-size-18x10.webm.md5\n-60fe99e5f5cc99706efa3e0b894e45cbcf0d6330  vp90-2-02-size-18x16.webm\n-1ab6cdd89a53662995d103546e6611c84f9292ab  vp90-2-02-size-18x16.webm.md5\n-f9a8f5fb749d69fd555db6ca093b7f77800c7b4f  vp90-2-02-size-18x18.webm\n-ace8a66328f7802b15f9989c2720c029c6abd279  vp90-2-02-size-18x18.webm.md5\n-a197123a527ec25913a9bf52dc8c347749e00045  vp90-2-02-size-18x32.webm\n-34fbd7036752232d1663e70d7f7cdc93f7129202  vp90-2-02-size-18x32.webm.md5\n-f219655a639a774a2c9c0a9f45c28dc0b5e75e24  vp90-2-02-size-18x34.webm\n-2c4d622a9ea548791c1a07903d3702e9774388bb  vp90-2-02-size-18x34.webm.md5\n-5308578da48c677d477a5404e19391d1303033c9  vp90-2-02-size-18x64.webm\n-e7fd4462527bac38559518ba80e41847db880f15  vp90-2-02-size-18x64.webm.md5\n-e109a7e013bd179f97e378542e1e81689ed06802  vp90-2-02-size-18x66.webm\n-45c04e422fb383c1f3be04beefaa4490e83bdb1a  vp90-2-02-size-18x66.webm.md5\n-38844cae5d99caf445f7de33c3ae78494ce36c01  vp90-2-02-size-32x08.webm\n-ad018be39e493ca2405225034b1a5b7a42af6f3a  vp90-2-02-size-32x08.webm.md5\n-7b57eaad55906f9de9903c8657a3fcb2aaf792ea  vp90-2-02-size-32x10.webm\n-2294425d4e55d275af5e25a0beac9738a1b4ee73  vp90-2-02-size-32x10.webm.md5\n-f47ca2ced0d47f761bb0a5fdcd911d3f450fdcc1  vp90-2-02-size-32x16.webm\n-ae10981d93913f0ab1f28c1146255e01769aa8c0  vp90-2-02-size-32x16.webm.md5\n-08b23ad838b6cf1fbfe3ad7e7775d95573e815fc  vp90-2-02-size-32x18.webm\n-1ba76f4c4a4ac7aabfa3ce195c1b473535eb7cc8  vp90-2-02-size-32x18.webm.md5\n-d5b88ae6c8c25c53dee74d9f1e6ca64244349a57  vp90-2-02-size-32x32.webm\n-e39c067a8ee2da52a51641eb1cb7f8eba935eb6b  vp90-2-02-size-32x32.webm.md5\n-529429920dc36bd899059fa75a767f02c8c60874  vp90-2-02-size-32x34.webm\n-56888e7834f52b106e8911e3a7fc0f473b609995  vp90-2-02-size-32x34.webm.md5\n-38e848e160391c2b1a55040aadde613b9f4bf15e  vp90-2-02-size-32x64.webm\n-8950485fb3f68b0e8be234db860e4ec5f5490fd0  vp90-2-02-size-32x64.webm.md5\n-5e8670f0b8ec9cefa8795b8959ffbe1a8e1aea94  vp90-2-02-size-32x66.webm\n-225df9d7d72ec711b0b60f4aeb65311c97db054a  vp90-2-02-size-32x66.webm.md5\n-695f929e2ce6fb11a1f180322d46c5cb1c97fa61  vp90-2-02-size-34x08.webm\n-5bb4262030018dd01883965c6aa6070185924ef6  vp90-2-02-size-34x08.webm.md5\n-5adf74ec906d2ad3f7526e06bd29f5ad7d966a90  vp90-2-02-size-34x10.webm\n-71c100b437d3e8701632ae8d65c3555339b1c68f  vp90-2-02-size-34x10.webm.md5\n-d0918923c987fba2d00193d83797b21289fe54aa  vp90-2-02-size-34x16.webm\n-5d5a52f3535b4d2698dd3d87f4a13fdc9b57163d  vp90-2-02-size-34x16.webm.md5\n-553ab0042cf87f5e668ec31b2e4b2a4b6ec196fd  vp90-2-02-size-34x18.webm\n-a164c7f3c424987df2340496e6a8cf76e973f0f1  vp90-2-02-size-34x18.webm.md5\n-baf3e233634f150de81c18ba5d8848068e1c3c54  vp90-2-02-size-34x32.webm\n-22a79d3bd1c9b85dfe8c70bb2e19f08a92a8be03  vp90-2-02-size-34x32.webm.md5\n-6d50a533774a7167350e4a7ef43c94a5622179a2  vp90-2-02-size-34x34.webm\n-0c099638e79c273546523e06704553e42eb00b00  vp90-2-02-size-34x34.webm.md5\n-698cdd0a5e895cc202c488675e682a8c537ede4f  vp90-2-02-size-34x64.webm\n-9317b63987cddab8389510a27b86f9f3d46e3fa5  vp90-2-02-size-34x64.webm.md5\n-4b5335ca06f082b6b69f584eb8e7886bdcafefd3  vp90-2-02-size-34x66.webm\n-e18d68b35428f46a84a947c646804a51ef1d7cec  vp90-2-02-size-34x66.webm.md5\n-a54ae7b494906ec928a876e8290e5574f2f9f6a2  vp90-2-02-size-64x08.webm\n-87f9f7087b6489d45e9e4b38ede2c5aef4a4928f  vp90-2-02-size-64x08.webm.md5\n-24522c70804a3c23d937df2d829ae63965b23f38  vp90-2-02-size-64x10.webm\n-447ce03938ab53bffcb4a841ee0bfaa90462dcb9  vp90-2-02-size-64x10.webm.md5\n-2a5035d035d214ae614af8051930690ef623989b  vp90-2-02-size-64x16.webm\n-84e355761dd2e0361b904c84c52a0dd0384d89cf  vp90-2-02-size-64x16.webm.md5\n-3a293ef4e270a19438e59b817fbe5f43eed4d36b  vp90-2-02-size-64x18.webm\n-666824e5ba746779eb46079e0631853dcc86d48b  vp90-2-02-size-64x18.webm.md5\n-ed32fae837095c9e8fc95d223ec68101812932c2  vp90-2-02-size-64x32.webm\n-97086eadedce1d0d9c072b585ba7b49aec69b1e7  vp90-2-02-size-64x32.webm.md5\n-696c7a7250bdfff594f4dfd88af34239092ecd00  vp90-2-02-size-64x34.webm\n-253a1d38d452e7826b086846c6f872f829c276bb  vp90-2-02-size-64x34.webm.md5\n-fc508e0e3c2e6872c60919a60b812c5232e9c2b0  vp90-2-02-size-64x64.webm\n-2cd6ebeca0f82e9f505616825c07950371b905ab  vp90-2-02-size-64x64.webm.md5\n-0f8a4fc1d6521187660425c283f08dff8c66e476  vp90-2-02-size-64x66.webm\n-5806be11a1d346be235f88d3683e69f73746166c  vp90-2-02-size-64x66.webm.md5\n-273b0c36e3658685cde250408a478116d7ae92f1  vp90-2-02-size-66x08.webm\n-23c3cd0dca20a2f71f036e77ea92025ff4e7a298  vp90-2-02-size-66x08.webm.md5\n-4844c59c3306d1e671bb0568f00e344bf797e66e  vp90-2-02-size-66x10.webm\n-e041eaf6841d775f8fde8bbb4949d2733fdaab7f  vp90-2-02-size-66x10.webm.md5\n-bdf3f1582b234fcd2805ffec59f9d716a2345302  vp90-2-02-size-66x16.webm\n-2ec85ee18119e6798968571ea6e1b93ca386e3af  vp90-2-02-size-66x16.webm.md5\n-0acce9af12b13b025d5274013da7ef6f568f075f  vp90-2-02-size-66x18.webm\n-77c4d53e2a5c96b70af9d575fe6811e0f5ee627b  vp90-2-02-size-66x18.webm.md5\n-682b36a25774bbdedcd603f504d18eb63f0167d4  vp90-2-02-size-66x32.webm\n-53728fae2a428f16d376a29f341a64ddca97996a  vp90-2-02-size-66x32.webm.md5\n-e71b70e901e29eaa6672a6aa4f37f6f5faa02bd6  vp90-2-02-size-66x34.webm\n-f69a6a555e3f614b0a35f9bfc313d8ebb35bc725  vp90-2-02-size-66x34.webm.md5\n-4151b8c29452d5c2266397a7b9bf688899a2937b  vp90-2-02-size-66x64.webm\n-69486e7fd9e380b6c97a03d3e167affc79f73840  vp90-2-02-size-66x64.webm.md5\n-68784a1ecac776fe2a3f230345af32f06f123536  vp90-2-02-size-66x66.webm\n-7f008c7f48d55e652fbd6bac405b51e0015c94f2  vp90-2-02-size-66x66.webm.md5\n-7e1bc449231ac1c5c2a11c9a6333b3e828763798  vp90-2-03-size-196x196.webm\n-6788a561466dace32d500194bf042e19cccc35e1  vp90-2-03-size-196x196.webm.md5\n-a170c9a88ec1dd854c7a471ff55fb2a97ac31870  vp90-2-03-size-196x198.webm\n-6bf9d6a8e2bdc5bf4f8a78071a3fed5ca02ad6f2  vp90-2-03-size-196x198.webm.md5\n-68f861d21c4c8b03d572c3d3fcd9f4fbf1f4503f  vp90-2-03-size-196x200.webm\n-bbfc260b2bfd872cc6054272bb6b7f959a9e1c6e  vp90-2-03-size-196x200.webm.md5\n-fc34889feeca2b7e5b27b4f1ce22d2e2b8e3e4b1  vp90-2-03-size-196x202.webm\n-158ee72af578f39aad0c3b8f4cbed2fc78b57e0f  vp90-2-03-size-196x202.webm.md5\n-dd28fb7247af534bdf5e6795a3ac429610489a0b  vp90-2-03-size-196x208.webm\n-7546be847efce2d1c0a23f807bfb03f91b764e1e  vp90-2-03-size-196x208.webm.md5\n-41d5cf5ed65b722a1b6dc035e67f978ea8ffecf8  vp90-2-03-size-196x210.webm\n-9444fdf632d6a1b6143f4cb10fed8f63c1d67ec1  vp90-2-03-size-196x210.webm.md5\n-5007bc618143437c009d6dde5fc2e86f72d37dc2  vp90-2-03-size-196x224.webm\n-858361d8f79b44df5545feabbc9754ec9ede632f  vp90-2-03-size-196x224.webm.md5\n-0bcbe357fbc776c3fa68e7117179574ed7564a44  vp90-2-03-size-196x226.webm\n-72006a5f42031a43d70a2cd9fc1958962a86628f  vp90-2-03-size-196x226.webm.md5\n-000239f048cceaac055558e97ef07078ebf65502  vp90-2-03-size-198x196.webm\n-2d6841901b72000c5340f30be602853438c1b787  vp90-2-03-size-198x196.webm.md5\n-ae75b766306a6404c3b3b35a6b6d53633c14fbdb  vp90-2-03-size-198x198.webm\n-3f2544b4f3b4b643a98f2c3b15ea5826fc702fa1  vp90-2-03-size-198x198.webm.md5\n-95ffd573fa84ccef1cd59e1583e6054f56a5c83d  vp90-2-03-size-198x200.webm\n-5d537e3c9b9c54418c79677543454c4cda3de1af  vp90-2-03-size-198x200.webm.md5\n-ecc845bf574375f469bc91bf5c75c79dc00073d6  vp90-2-03-size-198x202.webm\n-1b59f5e111265615a7a459eeda8cc9045178d228  vp90-2-03-size-198x202.webm.md5\n-432fb27144fe421b9f51cf44d2750a26133ed585  vp90-2-03-size-198x208.webm\n-a58a67f4fb357c73ca078aeecbc0f782975630b1  vp90-2-03-size-198x208.webm.md5\n-ff5058e7e6a47435046612afc8536f2040989e6f  vp90-2-03-size-198x210.webm\n-18d3be7935e52217e2e9400b6f2c681a9e45dc89  vp90-2-03-size-198x210.webm.md5\n-a0d55263c1ed2c03817454dd4ec4090d36dbc864  vp90-2-03-size-198x224.webm\n-efa366a299817e2da51c00623b165aab9fbb8d91  vp90-2-03-size-198x224.webm.md5\n-ccd142fa2920fc85bb753f049160c1c353ad1574  vp90-2-03-size-198x226.webm\n-534524a0b2dbff852e0b92ef09939db072f83243  vp90-2-03-size-198x226.webm.md5\n-0d483b94ed40abc8ab6e49f960432ee54ad9c7f1  vp90-2-03-size-200x196.webm\n-41795f548181717906e7a504ba551f06c32102ae  vp90-2-03-size-200x196.webm.md5\n-f6c2dc54e0989d50f01333fe40c91661fcbf849a  vp90-2-03-size-200x198.webm\n-43df5d8c46a40089441392e6d096c588c1079a68  vp90-2-03-size-200x198.webm.md5\n-2f6e9df82e44fc145f0d9212dcccbed3de605e23  vp90-2-03-size-200x200.webm\n-757b2ef96b82093255725bab9690bbafe27f3caf  vp90-2-03-size-200x200.webm.md5\n-40c5ea60415642a4a2e75c0d127b06309baadfab  vp90-2-03-size-200x202.webm\n-3022c4a1c625b5dc04fdb1052d17d45b4171cfba  vp90-2-03-size-200x202.webm.md5\n-6942ed5b27476bb8506d10e600d6ff60887780ca  vp90-2-03-size-200x208.webm\n-c4ab8c66f3cf2dc8e8dd7abae9ac21f4d32cd6be  vp90-2-03-size-200x208.webm.md5\n-71dbc99b83c49d1da45589b91eabb98e2f4a7b1e  vp90-2-03-size-200x210.webm\n-3f0b40da7eef7974b9bc326562f251feb67d9c7c  vp90-2-03-size-200x210.webm.md5\n-6b6b8489081cfefb377cc5f18eb754ec2383f655  vp90-2-03-size-200x224.webm\n-a259df2ac0e294492e3f9d4315baa34cab044f04  vp90-2-03-size-200x224.webm.md5\n-c9adc1c9bb07559349a0b054df4af56f7a6edbb9  vp90-2-03-size-200x226.webm\n-714cec61e3575581e4f1a0e3921f4dfdbbd316c5  vp90-2-03-size-200x226.webm.md5\n-f9bdc936bdf53f8be9ce78fecd41a21d31ff3943  vp90-2-03-size-202x196.webm\n-5b8e2e50fcea2c43b12fc067b8a9cc117af77bda  vp90-2-03-size-202x196.webm.md5\n-c7b66ea3da87613deb47ff24a111247d3c384fec  vp90-2-03-size-202x198.webm\n-517e91204b25586da943556f4adc5951c9be8bee  vp90-2-03-size-202x198.webm.md5\n-935ef56b01cfdb4265a7e24696645209ccb20970  vp90-2-03-size-202x200.webm\n-55b8ec4a2513183144a8e27564596c06c7576fce  vp90-2-03-size-202x200.webm.md5\n-849acf75e4f1d8d90046704e1103a18c64f30e35  vp90-2-03-size-202x202.webm\n-c79afc6660df2824e7df314e5bfd71f0d8acf76b  vp90-2-03-size-202x202.webm.md5\n-17b3a4d55576b770626ccb856b9f1a6c8f6ae476  vp90-2-03-size-202x208.webm\n-0b887ff30409c58f2ccdc3bfacd6be7c69f8997a  vp90-2-03-size-202x208.webm.md5\n-032d0ade4230fb2eef6d19915a7a1c9aa4a52617  vp90-2-03-size-202x210.webm\n-f78f8e79533c0c88dd2bfdcec9b1c07848568ece  vp90-2-03-size-202x210.webm.md5\n-915a38c31fe425d5b93c837121cfa8082f5ea5bc  vp90-2-03-size-202x224.webm\n-bf52a104074d0c5942aa7a5b31e11db47e43d48e  vp90-2-03-size-202x224.webm.md5\n-be5cfde35666fa435e47d544d9258215beb1cf29  vp90-2-03-size-202x226.webm\n-2fa2f87502fda756b319389c8975204e130a2e3f  vp90-2-03-size-202x226.webm.md5\n-15d908e97862b5b4bf295610df011fb9aa09909b  vp90-2-03-size-208x196.webm\n-50c60792305d6a99be376dd596a6ff979325e6cc  vp90-2-03-size-208x196.webm.md5\n-a367c7bc9fde56d6f4848cc573c7d4c1ce75e348  vp90-2-03-size-208x198.webm\n-be85fb2c8d435a75484231356f07d06ebddd13cd  vp90-2-03-size-208x198.webm.md5\n-05fd46deb7288e7253742091f56e54a9a441a187  vp90-2-03-size-208x200.webm\n-74f8ec3b3a2fe81767ed1ab36a47bc0062d6223c  vp90-2-03-size-208x200.webm.md5\n-d8985c4b386513a7385a4b3639bf91e469f1378b  vp90-2-03-size-208x202.webm\n-0614a1e8d92048852adcf605a51333f5fabc7f03  vp90-2-03-size-208x202.webm.md5\n-28b002242238479165ba4fb87ee6b442c64b32e4  vp90-2-03-size-208x208.webm\n-37de5aca59bb900228400b0e115d3229edb9dcc0  vp90-2-03-size-208x208.webm.md5\n-c545be0050c2fad7c68427dbf86c62a739e94ab3  vp90-2-03-size-208x210.webm\n-d646eccb3cd578f94b54777e32b88898bef6e17a  vp90-2-03-size-208x210.webm.md5\n-63a0cfe295b661026dd7b1bebb67acace1db766f  vp90-2-03-size-208x224.webm\n-85c0361d93bf85a335248fef2767ff43eeef23db  vp90-2-03-size-208x224.webm.md5\n-f911cc718d66e4fe8a865226088939c9eb1b7825  vp90-2-03-size-208x226.webm\n-a6d583a57876e7b7ec48625b2b2cdbcf70cab837  vp90-2-03-size-208x226.webm.md5\n-5bbb0f36da9a4683cf04e724124d8696332911bf  vp90-2-03-size-210x196.webm\n-a3580fc7816d7fbcfb54fdba501cabbd06ba2f1d  vp90-2-03-size-210x196.webm.md5\n-8db64d6f9ce36dd382013b42ae4e292deba697bc  vp90-2-03-size-210x198.webm\n-eda20f8268c7f4147bead4059e9c4897e09140a9  vp90-2-03-size-210x198.webm.md5\n-ce391505eeaf1d12406563101cd6b2dbbbb44bfc  vp90-2-03-size-210x200.webm\n-79d73b7f623082d2a00aa33e95c79d11c7d9c3a8  vp90-2-03-size-210x200.webm.md5\n-852db6fdc206e72391fc69b807f1954934679949  vp90-2-03-size-210x202.webm\n-f69414c5677ed2f2b8b37ae76429e509a92276a5  vp90-2-03-size-210x202.webm.md5\n-c424cc3edd2308da7d33f27acb36b54db5bf2595  vp90-2-03-size-210x208.webm\n-27b18562faa1b3184256f4eae8114b539b3e9d3e  vp90-2-03-size-210x208.webm.md5\n-dd029eba719d50a2851592fa8b9b2efe88904930  vp90-2-03-size-210x210.webm\n-c853a1670465eaa04ca31b3511995f1b6ed4f58f  vp90-2-03-size-210x210.webm.md5\n-d962e8ae676c54d0c3ea04ec7c04b37ae6a786e3  vp90-2-03-size-210x224.webm\n-93b793e79d987065b39ad8e2e71244368435fc25  vp90-2-03-size-210x224.webm.md5\n-3d0825fe83bcc125be1f78145ff43ca6d7588784  vp90-2-03-size-210x226.webm\n-5230f31a57ca3b5311698a12035d2644533b3ec4  vp90-2-03-size-210x226.webm.md5\n-6622f8bd9279e1ce45509a58a31a990052d45e14  vp90-2-03-size-224x196.webm\n-65411da07f60113f2be05c807879072b161d561e  vp90-2-03-size-224x196.webm.md5\n-6744ff2ee2c41eb08c62ff30880833b6d77b585b  vp90-2-03-size-224x198.webm\n-46ea3641d41acd4bff347b224646c060d5620385  vp90-2-03-size-224x198.webm.md5\n-8eb91f3416a1404705f370caecd74b2b458351b1  vp90-2-03-size-224x200.webm\n-196aefb854c8b95b9330263d6690b7ee15693ecf  vp90-2-03-size-224x200.webm.md5\n-256a5a23ef4e6d5ef2871af5afb8cd13d28cec00  vp90-2-03-size-224x202.webm\n-840ad8455dcf2be378c14b007e66fa642fc8196d  vp90-2-03-size-224x202.webm.md5\n-db4606480ab48b96c9a6ff5e639f1f1aea2a12e4  vp90-2-03-size-224x208.webm\n-40b9801d5620467499ac70fa6b7c40aaa5e1c331  vp90-2-03-size-224x208.webm.md5\n-e37159e687fe1cb24cffddfae059301adbaf4212  vp90-2-03-size-224x210.webm\n-1e4acd4b6334ae260c3eed08652d0ba8122073f2  vp90-2-03-size-224x210.webm.md5\n-0de1eb4bb6285ae621e4f2b613d2aa4a8c95a130  vp90-2-03-size-224x224.webm\n-37db449ad86fb286c2c02d94aa8fe0379c05044a  vp90-2-03-size-224x224.webm.md5\n-32ebbf903a7d7881bcfe59639f1d472371f3bf27  vp90-2-03-size-224x226.webm\n-5cc3ac5dc9f6912491aa2ddac863f8187f34c569  vp90-2-03-size-224x226.webm.md5\n-9480ff5c2c32b1870ac760c87514912616e6cf01  vp90-2-03-size-226x196.webm\n-fe83655c0f1888f0af7b047785f01ba7ca9f1324  vp90-2-03-size-226x196.webm.md5\n-09cad4221996315cdddad4e502dbfabf53ca1d6a  vp90-2-03-size-226x198.webm\n-e3ddfdc650acb95adb45abd9b634e1f09ea8ac96  vp90-2-03-size-226x198.webm.md5\n-c34f49d55fe39e3f0b607e3cc95e30244225cecb  vp90-2-03-size-226x200.webm\n-abb83edc868a3523ccd4e5523fac2efbe7c3df1f  vp90-2-03-size-226x200.webm.md5\n-d17bc08eedfc60c4c23d576a6c964a21bf854d1f  vp90-2-03-size-226x202.webm\n-1d22d2d0f375251c2d5a1acb4714bc35d963865b  vp90-2-03-size-226x202.webm.md5\n-9bd537c4f92a25596ccd29fedfe181feac948b92  vp90-2-03-size-226x208.webm\n-6feb0e7325386275719f3511ada9e248a2ae7df4  vp90-2-03-size-226x208.webm.md5\n-4487067f6cedd495b93696b44b37fe0a3e7eda14  vp90-2-03-size-226x210.webm\n-49a8fa87945f47208168d541c068e78d878075d5  vp90-2-03-size-226x210.webm.md5\n-559fea2f8da42b33c1aa1dbc34d1d6781009847a  vp90-2-03-size-226x224.webm\n-83c6d8f2969b759e10e5c6542baca1265c874c29  vp90-2-03-size-226x224.webm.md5\n-fe0af2ee47b1e5f6a66db369e2d7e9d870b38dce  vp90-2-03-size-226x226.webm\n-94ad19b8b699cea105e2ff18f0df2afd7242bcf7  vp90-2-03-size-226x226.webm.md5\n-b6524e4084d15b5d0caaa3d3d1368db30cbee69c  vp90-2-03-deltaq.webm\n-65f45ec9a55537aac76104818278e0978f94a678  vp90-2-03-deltaq.webm.md5\n-4dbb87494c7f565ffc266c98d17d0d8c7a5c5aba  vp90-2-05-resize.ivf\n-7f6d8879336239a43dbb6c9f13178cb11cf7ed09  vp90-2-05-resize.ivf.md5\n-bf61ddc1f716eba58d4c9837d4e91031d9ce4ffe  vp90-2-06-bilinear.webm\n-f6235f937552e11d8eb331ec55da6b3aa596b9ac  vp90-2-06-bilinear.webm.md5\n-495256cfd123fe777b2c0406862ed8468a1f4677  vp91-2-04-yv444.webm\n-65e3a7ffef61ab340d9140f335ecc49125970c2c  vp91-2-04-yv444.webm.md5\n-0c83a1e414fde3bccd6dc451bbaee68e59974c76  vp90-2-07-frame_parallel.webm\n-e5c2c9fb383e5bf3b563480adaeba5b7e3475ecd  vp90-2-07-frame_parallel.webm.md5\n-086c7edcffd699ae7d99d710fd7e53b18910ca5b  vp90-2-08-tile_1x2_frame_parallel.webm\n-e981ecaabb29a80e0cbc1f4002384965ce8e95bb  vp90-2-08-tile_1x2_frame_parallel.webm.md5\n-ed79be026a6f28646c5825da1c12d1fbc70f96a4  vp90-2-08-tile_1x2.webm\n-45b404e025841c9750895fc1a9f6bd384fe6a315  vp90-2-08-tile_1x2.webm.md5\n-cf8ea970c776797aae71dac8317ea926d9431cab  vp90-2-08-tile_1x4_frame_parallel.webm\n-a481fbea465010b57af5a19ebf6d4a5cfe5b9278  vp90-2-08-tile_1x4_frame_parallel.webm.md5\n-0203ec456277a01aec401e7fb6c72c9a7e5e3f9d  vp90-2-08-tile_1x4.webm\n-c9b237dfcc01c1b414fbcaa481d014a906ef7998  vp90-2-08-tile_1x4.webm.md5\n-20c75157e91ab41f82f70ffa73d5d01df8469287  vp90-2-08-tile-4x4.webm\n-ae7451810247fd13975cc257aa0301ff17102255  vp90-2-08-tile-4x4.webm.md5\n-2ec6e15422ac7a61af072dc5f27fcaf1942ce116  vp90-2-08-tile-4x1.webm\n-0094f5ee5e46345017c30e0aa4835b550212d853  vp90-2-08-tile-4x1.webm.md5\n-edea45dac4a3c2e5372339f8851d24c9bef803d6  vp90-2-09-subpixel-00.ivf\n-5428efc4bf92191faedf4a727fcd1d94966a7abc  vp90-2-09-subpixel-00.ivf.md5\n-8cdd435d89029987ee196896e21520e5f879f04d  vp90-2-bbb_1280x720_tile_1x4_1310kbps.webm\n-091b373aa2ecb59aa5c647affd5bcafcc7547364  vp90-2-bbb_1920x1080_tile_1x1_2581kbps.webm\n-87ee28032b0963a44b73a850fcc816a6dc83efbb  vp90-2-bbb_1920x1080_tile_1x4_2586kbps.webm\n-c6ce25c4bfd4bdfc2932b70428e3dfe11210ec4f  vp90-2-bbb_1920x1080_tile_1x4_fpm_2304kbps.webm\n-2064bdb22aa71c2691e0469fb62e8087a43f08f8  vp90-2-bbb_426x240_tile_1x1_180kbps.webm\n-8080eda22694910162f0996e8a962612f381a57f  vp90-2-bbb_640x360_tile_1x2_337kbps.webm\n-a484b335c27ea189c0f0d77babea4a510ce12d50  vp90-2-bbb_854x480_tile_1x2_651kbps.webm\n-3eacf1f006250be4cc5c92a7ef146e385ee62653  vp90-2-sintel_1280x546_tile_1x4_1257kbps.webm\n-217f089a16447490823127b36ce0d945522accfd  vp90-2-sintel_1920x818_tile_1x4_fpm_2279kbps.webm\n-eedb3c641e60dacbe082491a16df529a5c9187df  vp90-2-sintel_426x182_tile_1x1_171kbps.webm\n-cb7e4955af183dff33bcba0c837f0922ab066400  vp90-2-sintel_640x272_tile_1x2_318kbps.webm\n-48613f9380e2580002f8a09d6e412ea4e89a52b9  vp90-2-sintel_854x364_tile_1x2_621kbps.webm\n-990a91f24dd284562d21d714ae773dff5452cad8  vp90-2-tos_1280x534_tile_1x4_1306kbps.webm\n-b6dd558c90bca466b4bcbd03b3371648186465a7  vp90-2-tos_1920x800_tile_1x4_fpm_2335kbps.webm\n-1a9c2914ba932a38f0a143efc1ad0e318e78888b  vp90-2-tos_426x178_tile_1x1_181kbps.webm\n-a3d2b09f24debad4747a1b3066f572be4273bced  vp90-2-tos_640x266_tile_1x2_336kbps.webm\n-c64b03b5c090e6888cb39685c31f00a6b79fa45c  vp90-2-tos_854x356_tile_1x2_656kbps.webm\n-0e7cd4135b231c9cea8d76c19f9e84b6fd77acec  vp90-2-08-tile_1x8_frame_parallel.webm\n-c9b6850af28579b031791066457f4cb40df6e1c7  vp90-2-08-tile_1x8_frame_parallel.webm.md5\n-e448b6e83490bca0f8d58b4f4b1126a17baf4b0c  vp90-2-08-tile_1x8.webm\n-5e524165f0397e6141d914f4f0a66267d7658376  vp90-2-08-tile_1x8.webm.md5\n-a34e14923d6d17b1144254d8187d7f85b700a63c  vp90-2-02-size-lf-1920x1080.webm\n-e3b28ddcfaeb37fb4d132b93f92642a9ad17c22d  vp90-2-02-size-lf-1920x1080.webm.md5\n-d48c5db1b0f8e60521a7c749696b8067886033a3  vp90-2-09-aq2.webm\n-84c1599298aac78f2fc05ae2274575d10569dfa0  vp90-2-09-aq2.webm.md5\n-55fc55ed73d578ed60fad05692579873f8bad758  vp90-2-09-lf_deltas.webm\n-54638c38009198c38c8f3b25c182b709b6c1fd2e  vp90-2-09-lf_deltas.webm.md5\n-510d95f3beb3b51c572611fdaeeece12277dac30  vp90-2-10-show-existing-frame.webm\n-14d631096f4bfa2d71f7f739aec1448fb3c33bad  vp90-2-10-show-existing-frame.webm.md5\n-b4318e75f73a6a08992c7326de2fb589c2a794c7  vp90-2-11-size-351x287.webm\n-b3c48382cf7d0454e83a02497c229d27720f9e20  vp90-2-11-size-351x287.webm.md5\n-8e0096475ea2535bac71d3e2fc09e0c451c444df  vp90-2-11-size-351x288.webm\n-19e003804ec1dfc5464813b32339a15d5ba7b42f  vp90-2-11-size-351x288.webm.md5\n-40cd1d6a188d7a88b21ebac1e573d3f270ab261e  vp90-2-11-size-352x287.webm\n-68f515abe3858fc1eded46c8e6b2f727d43b5331  vp90-2-11-size-352x287.webm.md5\n-9a510769ff23db410880ec3029d433e87d17f7fc  vp90-2-12-droppable_1.ivf\n-952eaac6eefa6f62179ed1db3e922fd42fecc624  vp90-2-12-droppable_1.ivf.md5\n-9a510769ff23db410880ec3029d433e87d17f7fc  vp90-2-12-droppable_2.ivf\n-92a756469fa438220524e7fa6ac1d38c89514d17  vp90-2-12-droppable_2.ivf.md5\n-c21e97e4ba486520118d78b01a5cb6e6dc33e190  vp90-2-12-droppable_3.ivf\n-601abc9e4176c70f82ac0381365e9b151fdd24cd  vp90-2-12-droppable_3.ivf.md5\n-61c640dad23cd4f7ad811b867e7b7e3521f4e3ba  vp90-2-13-largescaling.webm\n-bca1b02eebdb088fa3f389fe0e7571e75a71f523  vp90-2-13-largescaling.webm.md5\n-c740708fa390806eebaf669909c1285ab464f886  vp90-2-14-resize-fp-tiles-1-2.webm\n-c7b85ffd8e11500f73f52e7dc5a47f57c393d47f  vp90-2-14-resize-fp-tiles-1-2.webm.md5\n-ec8faa352a08f7033c60f29f80d505e2d7daa103  vp90-2-14-resize-fp-tiles-1-4.webm\n-6852c783fb421bda5ded3d4c5a3ffc46de03fbc1  vp90-2-14-resize-fp-tiles-1-4.webm.md5\n-8af61853ac0d07c4cb5bf7c2016661ba350b3497  vp90-2-14-resize-fp-tiles-1-8.webm\n-571353bac89fea60b5706073409aa3c0d42aefe9  vp90-2-14-resize-fp-tiles-1-8.webm.md5\n-b1c187ed69931496b82ec194017a79831bafceef  vp90-2-14-resize-fp-tiles-1-16.webm\n-1c199a41afe42ce303944d70089eaaa2263b4a09  vp90-2-14-resize-fp-tiles-1-16.webm.md5\n-8eaae5a6f2dff934610b0c7a917d7f583ba74aa5  vp90-2-14-resize-fp-tiles-2-1.webm\n-db18fcf915f7ffaea6c39feab8bda6c1688af011  vp90-2-14-resize-fp-tiles-2-1.webm.md5\n-bc3046d138941e2a20e9ceec0ff6d25c25d12af3  vp90-2-14-resize-fp-tiles-4-1.webm\n-393211b808030d09a79927b17a4374b2f68a60ae  vp90-2-14-resize-fp-tiles-4-1.webm.md5\n-6e8f8e31721a0f7f68a2964e36e0e698c2e276b1  vp90-2-14-resize-fp-tiles-8-1.webm\n-491fd3cd78fb0577bfe905bb64bbf64bd7d29140  vp90-2-14-resize-fp-tiles-8-1.webm.md5\n-cc5958da2a7edf739cd2cfeb18bd05e77903087e  vp90-2-14-resize-fp-tiles-16-1.webm\n-0b58daf55aaf9063bf5b4fb33393d18b417dc428  vp90-2-14-resize-fp-tiles-16-1.webm.md5\n-821eeecc9d8c6a316134dd42d1ff057787d8047b  vp90-2-14-resize-fp-tiles-2-4.webm\n-374c549f2839a3d0b732c4e3650700144037e76c  vp90-2-14-resize-fp-tiles-2-4.webm.md5\n-dff8c8e49aacea9f4c7f22cb882da984e2a1b405  vp90-2-14-resize-fp-tiles-2-8.webm\n-e5b8820a7c823b21297d6e889e57ec401882c210  vp90-2-14-resize-fp-tiles-2-8.webm.md5\n-77629e4b23e32896aadf6e994c78bd4ffa1c7797  vp90-2-14-resize-fp-tiles-2-16.webm\n-1937f5df032664ac345d4613ad4417b4967b1230  vp90-2-14-resize-fp-tiles-2-16.webm.md5\n-380ba5702bb1ec7947697314ab0300b5c56a1665  vp90-2-14-resize-fp-tiles-4-2.webm\n-fde7b30d2aa64c1e851a4852f655d79fc542cf66  vp90-2-14-resize-fp-tiles-4-2.webm.md5\n-dc784b258ffa2abc2ae693d11792acf0bb9cb74f  vp90-2-14-resize-fp-tiles-8-2.webm\n-edf26f0130aeee8342d49c2c8f0793ad008782d9  vp90-2-14-resize-fp-tiles-8-2.webm.md5\n-8e575789fd63ebf69e8eff1b9a4351a249a73bee  vp90-2-14-resize-fp-tiles-16-2.webm\n-b6415318c1c589a1f64b9d569ce3cabbec2e0d52  vp90-2-14-resize-fp-tiles-16-2.webm.md5\n-e3adc944a11c4c5517e63664c84ebb0847b64d81  vp90-2-14-resize-fp-tiles-4-8.webm\n-03cba0532bc90a05b1990db830bf5701e24e7982  vp90-2-14-resize-fp-tiles-4-8.webm.md5\n-3b27a991eb6d78dce38efab35b7db682e8cbbee3  vp90-2-14-resize-fp-tiles-4-16.webm\n-5d16b7f82bf59f802724ddfd97abb487150b1c9d  vp90-2-14-resize-fp-tiles-4-16.webm.md5\n-d5fed8c28c1d4c7e232ebbd25cf758757313ed96  vp90-2-14-resize-fp-tiles-8-4.webm\n-5a8ff8a52cbbde7bfab569beb6d971c5f8b904f7  vp90-2-14-resize-fp-tiles-8-4.webm.md5\n-17a5faa023d77ee9dad423a4e0d3145796bbc500  vp90-2-14-resize-fp-tiles-16-4.webm\n-2ef8daa3c3e750fd745130d0a76a39fe86f0448f  vp90-2-14-resize-fp-tiles-16-4.webm.md5\n-9361e031f5cc990d8740863e310abb5167ae351e  vp90-2-14-resize-fp-tiles-8-16.webm\n-57f13a2197486584f4e1a4f82ad969f3abc5a1a2  vp90-2-14-resize-fp-tiles-8-16.webm.md5\n-5803fc6fcbfb47b7661f3fcc6499158a32b56675  vp90-2-14-resize-fp-tiles-16-8.webm\n-be0fe64a1a4933696ff92d93f9bdecdbd886dc13  vp90-2-14-resize-fp-tiles-16-8.webm.md5\n-0ac0f6d20a0afed77f742a3b9acb59fd7b9cb093  vp90-2-14-resize-fp-tiles-1-2-4-8-16.webm\n-1765315acccfe6cd12230e731369fcb15325ebfa  vp90-2-14-resize-fp-tiles-1-2-4-8-16.webm.md5\n-4a2b7a683576fe8e330c7d1c4f098ff4e70a43a8  vp90-2-14-resize-fp-tiles-16-8-4-2-1.webm\n-1ef480392112b3509cb190afbb96f9a38dd9fbac  vp90-2-14-resize-fp-tiles-16-8-4-2-1.webm.md5\n+d5dfb0151c9051f8c85999255645d7a23916d3c0 *hantro_collage_w352h288.yuv\n+b87815bf86020c592ccc7a846ba2e28ec8043902 *hantro_odd.yuv\n+76024eb753cdac6a5e5703aaea189d35c3c30ac7 *invalid-vp90-2-00-quantizer-00.webm.ivf.s5861_r01-05_b6-.v2.ivf\n+7448d8798a4380162d4b56f9b452e2f6f9e24e7a *invalid-vp90-2-00-quantizer-00.webm.ivf.s5861_r01-05_b6-.v2.ivf.res\n+83f50908c8dc0ef8760595447a2ff7727489542e *invalid-vp90-2-00-quantizer-11.webm.ivf.s52984_r01-05_b6-.ivf\n+456d1493e52d32a5c30edf44a27debc1fa6b253a *invalid-vp90-2-00-quantizer-11.webm.ivf.s52984_r01-05_b6-.ivf.res\n+c123d1f9f02fb4143abb5e271916e3a3080de8f6 *invalid-vp90-2-00-quantizer-11.webm.ivf.s52984_r01-05_b6-z.ivf\n+456d1493e52d32a5c30edf44a27debc1fa6b253a *invalid-vp90-2-00-quantizer-11.webm.ivf.s52984_r01-05_b6-z.ivf.res\n+fe346136b9b8c1e6f6084cc106485706915795e4 *invalid-vp90-01-v2.webm\n+25751f5d3b05ff03f0719ad42cd625348eb8961e *invalid-vp90-01-v2.webm.res\n+d78e2fceba5ac942246503ec8366f879c4775ca5 *invalid-vp90-02-v2.webm\n+8e2eff4af87d2b561cce2365713269e301457ef3 *invalid-vp90-02-v2.webm.res\n+df1a1453feb3c00d7d89746c7003b4163523bff3 *invalid-vp90-03-v3.webm\n+4935c62becc68c13642a03db1e6d3e2331c1c612 *invalid-vp90-03-v3.webm.res\n+d637297561dd904eb2c97a9015deeb31c4a1e8d2 *invalid-vp90-2-08-tile_1x4_frame_parallel_all_key.webm\n+3a204bdbeaa3c6458b77bcebb8366d107267f55d *invalid-vp90-2-08-tile_1x4_frame_parallel_all_key.webm.res\n+a432f96ff0a787268e2f94a8092ab161a18d1b06 *park_joy_90p_10_420.y4m\n+0b194cc312c3a2e84d156a221b0a5eb615dfddc5 *park_joy_90p_10_422.y4m\n+ff0e0a21dc2adc95b8c1b37902713700655ced17 *park_joy_90p_10_444.y4m\n+c934da6fb8cc54ee2a8c17c54cf6076dac37ead0 *park_joy_90p_10_440.yuv\n+614c32ae1eca391e867c70d19974f0d62664dd99 *park_joy_90p_12_420.y4m\n+c92825f1ea25c5c37855083a69faac6ac4641a9e *park_joy_90p_12_422.y4m\n+b592189b885b6cc85db55cc98512a197d73d3b34 *park_joy_90p_12_444.y4m\n+82c1bfcca368c2f22bad7d693d690d5499ecdd11 *park_joy_90p_12_440.yuv\n+b9e1e90aece2be6e2c90d89e6ab2372d5f8c792d *park_joy_90p_8_420_a10-1.y4m\n+4e0eb61e76f0684188d9bc9f3ce61f6b6b77bb2c *park_joy_90p_8_420.y4m\n+7a193ff7dfeb96ba5f82b2afd7afa9e1fe83d947 *park_joy_90p_8_422.y4m\n+bdb7856e6bc93599bdda05c2e773a9f22b6c6d03 *park_joy_90p_8_444.y4m\n+81e1f3843748438b8f2e71db484eb22daf72e939 *park_joy_90p_8_440.yuv\n+b1f1c3ec79114b9a0651af24ce634afb44a9a419 *rush_hour_444.y4m\n+5184c46ddca8b1fadd16742e8500115bc8f749da *vp80-00-comprehensive-001.ivf\n+65bf1bbbced81b97bd030f376d1b7f61a224793f *vp80-00-comprehensive-002.ivf\n+906b4c1e99eb734504c504b3f1ad8052137ce672 *vp80-00-comprehensive-003.ivf\n+ec144b1af53af895db78355785650b96dd3f0ade *vp80-00-comprehensive-004.ivf\n+afc7091785c62f1c121c4554a2830c30704587d9 *vp80-00-comprehensive-005.ivf\n+42ea9d55c818145d06a9b633b8e85c6a6164fd3e *vp80-00-comprehensive-006.ivf\n+e5b3a73ab79fe024c14309d653d6bed92902ee3b *vp80-00-comprehensive-007.ivf\n+f3c50a58875930adfb84525c0ef59d7e4c08540c *vp80-00-comprehensive-008.ivf\n+4b2841fdb83db51ae322096ae468bbb9dc2c8362 *vp80-00-comprehensive-009.ivf\n+efbff736e3a91ab6a98c5bc2dce65d645944c7b1 *vp80-00-comprehensive-010.ivf\n+6b315102cae008d22a3d2c231be92cb704a222f8 *vp80-00-comprehensive-011.ivf\n+f3214a4fea14c2d5ec689936c1613f274c859ee8 *vp80-00-comprehensive-012.ivf\n+e4094e96d308c8a35b74c480a43d853c5294cd34 *vp80-00-comprehensive-013.ivf\n+5b0adfaf60a69e0aaf3ec021a39d0a68fc0e1b5a *vp80-00-comprehensive-014.ivf\n+e8467688ddf26b5000664f904faf0d70506aa653 *vp80-00-comprehensive-015.ivf\n+aab55582337dfd2a39ff54fb2576a91910d49337 *vp80-00-comprehensive-016.ivf\n+1ba24724f80203c9bae4f1d0f99d534721980016 *vp80-00-comprehensive-017.ivf\n+143a15512b46f436280ddb4d0e6411eb4af434f2 *vp80-00-comprehensive-018.ivf\n+c5baeaf5714fdfb3a8bc960a8e33ac438e83b16b *vp80-01-intra-1400.ivf\n+f383955229afe3408453e316d11553d923ca60d5 *vp80-01-intra-1411.ivf\n+84e1f4343f174c9f3c83f834bac3196fb325bf2c *vp80-01-intra-1416.ivf\n+fb6e712a47dd57a28a3727d2ae2c97a8b7c7ca51 *vp80-01-intra-1417.ivf\n+71ea772d3e9d315b8cbecf41207b8a237c34853b *vp80-02-inter-1402.ivf\n+d85dbc4271525dcd128c503f936fe69091d1f8d0 *vp80-02-inter-1412.ivf\n+d4e5d3ad56511867d025f93724d090f92ba6ec3d *vp80-02-inter-1418.ivf\n+91791cbcc37c60f35dbd8090bacb54e5ec6dd4fa *vp80-02-inter-1424.ivf\n+17fbfe2fea70f6e2f3fa6ca4efaae6c0b03b5f02 *vp80-03-segmentation-01.ivf\n+3c3600dbbcde08e20d54c66fe3b7eadd4f09bdbb *vp80-03-segmentation-02.ivf\n+c156778d5340967d4b369c490848076e92f1f875 *vp80-03-segmentation-03.ivf\n+d25dcff6c60e87a1af70945b8911b6b4998533b0 *vp80-03-segmentation-04.ivf\n+362baba2ce454c9db21218f35e81c27a5ed0b730 *vp80-03-segmentation-1401.ivf\n+d223ae7ee748ce07e74c4679bfd219e84aa9f4b0 *vp80-03-segmentation-1403.ivf\n+033adf7f3a13836a3f1cffcb87c1972900f2b5c6 *vp80-03-segmentation-1407.ivf\n+4d51dfbf9f3e2c590ec99d1d6f59dd731d04375f *vp80-03-segmentation-1408.ivf\n+f37a62b197c2600d75e0ccfbb31b60efdedac251 *vp80-03-segmentation-1409.ivf\n+eb25bd7bfba5b2f6935018a930f42d123b1e7fcd *vp80-03-segmentation-1410.ivf\n+b9d5c436663a30c27cfff84b53a002e501258843 *vp80-03-segmentation-1413.ivf\n+6da92b9d1a180cc3a8afe348ab12258f5a37be1a *vp80-03-segmentation-1414.ivf\n+a4f5842602886bd669f115f93d8a35c035cb0948 *vp80-03-segmentation-1415.ivf\n+f295dceb8ef278b77251b3f9df8aee22e161d547 *vp80-03-segmentation-1425.ivf\n+198dbf9f36f733200e432664cc8c5752d59779de *vp80-03-segmentation-1426.ivf\n+7704804e32f5de976803929934a7fafe101ac7b0 *vp80-03-segmentation-1427.ivf\n+831ccd862ea95ca025d2f3bd8b88678752f5416d *vp80-03-segmentation-1432.ivf\n+b3c11978529289f9109f2766fcaba3ebc40e11ef *vp80-03-segmentation-1435.ivf\n+a835a731f5520ebfc1002c40121264d0020559ac *vp80-03-segmentation-1436.ivf\n+1d1732942f773bb2a5775fcb9689b1579ce28eab *vp80-03-segmentation-1437.ivf\n+db04799adfe089dfdf74dbd43cc05ede7161f99e *vp80-03-segmentation-1441.ivf\n+7caf39b3f20cfd52b998210878062e52a5edf1e6 *vp80-03-segmentation-1442.ivf\n+3607f6bb4ee106c38fa1ea370dc4ff8b8cde2261 *vp80-04-partitions-1404.ivf\n+93cc323b6b6867f1b12dd48773424549c6960a6b *vp80-04-partitions-1405.ivf\n+047eedb14b865bdac8a3538e63801054e0295e9c *vp80-04-partitions-1406.ivf\n+0f1233bd2bc33f56ce5e495dbd455d122339f384 *vp80-05-sharpness-1428.ivf\n+51767fc136488a9535c2a4c38067c542ee2048df *vp80-05-sharpness-1429.ivf\n+9805aa107672de25d6fb8c35e20d06deca5efe18 *vp80-05-sharpness-1430.ivf\n+61db6b965f9c27aebe71b85bf2d5877e58e4bbdf *vp80-05-sharpness-1431.ivf\n+10420d266290d2923555f84af38eeb96edbd3ae8 *vp80-05-sharpness-1433.ivf\n+3ed24f9a80cddfdf75824ba95cdb4ff9286cb443 *vp80-05-sharpness-1434.ivf\n+c87599cbecd72d4cd4f7ace3313b7a6bc6eb8163 *vp80-05-sharpness-1438.ivf\n+aff51d865c2621b60510459244ea83e958e4baed *vp80-05-sharpness-1439.ivf\n+da386e72b19b5485a6af199c5eb60ef25e510dd1 *vp80-05-sharpness-1440.ivf\n+6759a095203d96ccd267ce09b1b050b8cc4c2f1f *vp80-05-sharpness-1443.ivf\n+b95d3cc1d0df991e63e150a801710a72f20d9ba0 *vp80-06-smallsize.ivf\n+db55ec7fd02c864ba996ff060b25b1e08611330b *vp80-00-comprehensive-001.ivf.md5\n+29db0ad011cba1e45f856d5623cd38dac3e3bf19 *vp80-00-comprehensive-002.ivf.md5\n+e84f258f69e173e7d68f8f8c037a0a3766902182 *vp80-00-comprehensive-003.ivf.md5\n+eb7912eaf69559a16fd82bc3f5fb1524cf4a4466 *vp80-00-comprehensive-004.ivf.md5\n+4206f71c94894bd5b5b376f6c09b3817dbc65206 *vp80-00-comprehensive-005.ivf.md5\n+4f89b356f6f2fecb928f330a10f804f00f5325f5 *vp80-00-comprehensive-006.ivf.md5\n+2813236a32964dd8007e17648bcf035a20fcda6c *vp80-00-comprehensive-007.ivf.md5\n+10746c72098f872803c900e17c5680e451f5f498 *vp80-00-comprehensive-008.ivf.md5\n+39a23d0692ce64421a7bb7cdf6ccec5928d37fff *vp80-00-comprehensive-009.ivf.md5\n+f6e3de8931a0cc659bda8fbc14050346955e72d4 *vp80-00-comprehensive-010.ivf.md5\n+101683ec195b6e944f7cd1e468fc8921439363e6 *vp80-00-comprehensive-011.ivf.md5\n+1f592751ce46d8688998fa0fa4fbdcda0fd4058c *vp80-00-comprehensive-012.ivf.md5\n+6066176f90ca790251e795fca1a5797d59999841 *vp80-00-comprehensive-013.ivf.md5\n+2656da94ba93691f23edc4d60b3a09e2be46c217 *vp80-00-comprehensive-014.ivf.md5\n+c6e0d5f5d61460c8ac8edfa4e701f10312c03133 *vp80-00-comprehensive-015.ivf.md5\n+ee60fee501d8493e34e8d6a1fe315b51ed09b24a *vp80-00-comprehensive-016.ivf.md5\n+9f1914ceffcad4546c0a29de3ef591d8bea304dc *vp80-00-comprehensive-017.ivf.md5\n+e0305178fe288a9fd8082b39e2d03181edb19054 *vp80-00-comprehensive-018.ivf.md5\n+612494da2fa799cc9d76dcdd835ae6c7cb2e5c05 *vp80-01-intra-1400.ivf.md5\n+48ea06097ac8269c5e8c2131d3d0639f431fcf0e *vp80-01-intra-1411.ivf.md5\n+6e2ab4e7677ad0ba868083ca6bc387ee922b400c *vp80-01-intra-1416.ivf.md5\n+eca0a90348959ce3854142f8d8641b13050e8349 *vp80-01-intra-1417.ivf.md5\n+920feea203145d5c2258a91c4e6991934a79a99e *vp80-02-inter-1402.ivf.md5\n+f71d97909fe2b3dd65be7e1f56c72237f0cef200 *vp80-02-inter-1412.ivf.md5\n+e911254569a30bbb2a237ff8b79f69ed9da0672d *vp80-02-inter-1418.ivf.md5\n+58c789c50c9bb9cc90580bed291164a0939d28ba *vp80-02-inter-1424.ivf.md5\n+ff3e2f441327b9c20a0b37c524e0f5a48a36de7b *vp80-03-segmentation-01.ivf.md5\n+0791f417f076a542ae66fbc3426ab4d94cbd6c75 *vp80-03-segmentation-02.ivf.md5\n+722e50f1a6a91c34302d68681faffc1c26d1cc57 *vp80-03-segmentation-03.ivf.md5\n+c701f1885bcfb27fb8e70cc65606b289172ef889 *vp80-03-segmentation-04.ivf.md5\n+f79bc9ec189a2b4807632a3d0c5bf04a178b5300 *vp80-03-segmentation-1401.ivf.md5\n+b9aa4c74c0219b639811c44760d0b24cd8bb436a *vp80-03-segmentation-1403.ivf.md5\n+70d5a2207ca1891bcaebd5cf6dd88ce8d57b4334 *vp80-03-segmentation-1407.ivf.md5\n+265f962ee781531f9a93b9309461316fd32b2a1d *vp80-03-segmentation-1408.ivf.md5\n+0c4ecbbd6dc042d30e626d951b65f460dd6cd563 *vp80-03-segmentation-1409.ivf.md5\n+cf779af36a937f06570a0fca9db64ba133451dee *vp80-03-segmentation-1410.ivf.md5\n+0e6c5036d51ab078842f133934926c598a9cff02 *vp80-03-segmentation-1413.ivf.md5\n+eb3930aaf229116c80d507516c34759c3f6cdf69 *vp80-03-segmentation-1414.ivf.md5\n+123d6c0f72ee87911c4ae7538e87b7d163b22d6c *vp80-03-segmentation-1415.ivf.md5\n+e70551d1a38920e097a5d8782390b79ecaeb7505 *vp80-03-segmentation-1425.ivf.md5\n+44e8f4117e46dbb302b2cfd81171cc1a1846e431 *vp80-03-segmentation-1426.ivf.md5\n+52636e54aee5f95bbace37021bd67de5db767e9a *vp80-03-segmentation-1427.ivf.md5\n+b1ad3eff20215c28e295b15ef3636ed926d59cba *vp80-03-segmentation-1432.ivf.md5\n+24c22a552fa28a90e5978f67f57181cc2d7546d7 *vp80-03-segmentation-1435.ivf.md5\n+96c49c390abfced18a7a8c9b9ea10af778e10edb *vp80-03-segmentation-1436.ivf.md5\n+f95eb6214571434f1f73ab7833b9ccdf47588020 *vp80-03-segmentation-1437.ivf.md5\n+1c0700ca27c9b0090a7747a4b0b4dc21d1843181 *vp80-03-segmentation-1441.ivf.md5\n+81d4f23ca32667ee958bae579c8f5e97ba72eb97 *vp80-03-segmentation-1442.ivf.md5\n+272efcef07a3a30fbca51bfd566063d8258ec0be *vp80-04-partitions-1404.ivf.md5\n+66ed219ab812ac801b256d35cf495d193d4cf478 *vp80-04-partitions-1405.ivf.md5\n+36083f37f56f502bd60ec5e07502ee9e6b8699b0 *vp80-04-partitions-1406.ivf.md5\n+6ca909bf168a64c09415626294665dc1be3d1973 *vp80-05-sharpness-1428.ivf.md5\n+1667d2ee2334e5fdea8a8a866f4ccf3cf76f033a *vp80-05-sharpness-1429.ivf.md5\n+71bcbe5357d36a19df5b07fbe3e27bffa8893f0a *vp80-05-sharpness-1430.ivf.md5\n+89a09b1dffce2d55770a89e58d9925c70ef79bf8 *vp80-05-sharpness-1431.ivf.md5\n+08444a18b4e6ba3450c0796dd728d48c399a2dc9 *vp80-05-sharpness-1433.ivf.md5\n+6d6223719a90c13e848aa2a8a6642098cdb5977a *vp80-05-sharpness-1434.ivf.md5\n+41d70bb5fa45bc88da1604a0af466930b8dd77b5 *vp80-05-sharpness-1438.ivf.md5\n+086c56378df81b6cee264d7540a7b8f2b405c7a4 *vp80-05-sharpness-1439.ivf.md5\n+d32dc2c4165eb266ea4c23c14a45459b363def32 *vp80-05-sharpness-1440.ivf.md5\n+8c69dc3d8e563f56ffab5ad1e400d9e689dd23df *vp80-05-sharpness-1443.ivf.md5\n+d6f246df012c241b5fa6c1345019a3703d85c419 *vp80-06-smallsize.ivf.md5\n+ce881e567fe1d0fbcb2d3e9e6281a1a8d74d82e0 *vp90-2-00-quantizer-00.webm\n+ac5eda33407d0521c7afca43a63fd305c0cd9d13 *vp90-2-00-quantizer-00.webm.md5\n+2ca0463f2cfb93d25d7dded174db70b7cb87cb48 *vp90-2-00-quantizer-01.webm\n+10d98884fc6d9a5f47a2057922b8e25dd48d7786 *vp90-2-00-quantizer-01.webm.md5\n+d80a2920a5e0819d69dcba8fe260c01f820f8982 *vp90-2-00-quantizer-02.webm\n+c964c8e5e04165fabbf1c6ee8ee5121d35921965 *vp90-2-00-quantizer-02.webm.md5\n+fdef046777b5b75c962b715d809dbe2ea331afb9 *vp90-2-00-quantizer-03.webm\n+f270bee0b0c7aa2bf4c5afe098556b4f3f890faf *vp90-2-00-quantizer-03.webm.md5\n+66d98609e809394a6ac730787e6724e3badc075a *vp90-2-00-quantizer-04.webm\n+427433bfe121c4aea1095ec3124fdc174d200e3a *vp90-2-00-quantizer-04.webm.md5\n+e6e42626d8cadf0b5be16313f69212981b96fee5 *vp90-2-00-quantizer-05.webm\n+c98f6a9a1af4cfd71416792827304266aad4bd46 *vp90-2-00-quantizer-05.webm.md5\n+413ef09b721f5dcec1a96e937a97e5873c2e6db6 *vp90-2-00-quantizer-06.webm\n+5080e940a23805c82e578e21b57fc2c511e76376 *vp90-2-00-quantizer-06.webm.md5\n+4a50a5f4ac717c30dfaae8bb46702e3542e867de *vp90-2-00-quantizer-07.webm\n+76c429a02b56762e10ee4db88729d8834b3a70f4 *vp90-2-00-quantizer-07.webm.md5\n+d2f4e464780bf8b7e647efa18ac777a930e62bc0 *vp90-2-00-quantizer-08.webm\n+ab94aabf9316111b52d7c531962ed4123313b6ba *vp90-2-00-quantizer-08.webm.md5\n+174bc58433936dd79550398d744f1072ce7f5693 *vp90-2-00-quantizer-09.webm\n+e1f7690cd83ccc56d045e17cce552544a5f03810 *vp90-2-00-quantizer-09.webm.md5\n+52bc1dfd3a97b24d922eb8a31d07527891561f2a *vp90-2-00-quantizer-10.webm\n+9b37bed893b5f6a4e12f2aa40f02dd40f944d0f8 *vp90-2-00-quantizer-10.webm.md5\n+10031eecafde1e1d8e6323fe2b2a1d7e77a66869 *vp90-2-00-quantizer-11.webm\n+fe4620a4bb0e4f5cb9bbfedc4039a22b81b0f5c0 *vp90-2-00-quantizer-11.webm.md5\n+78e9f7bb77e8e348155bbdfa12790789d1d50c34 *vp90-2-00-quantizer-12.webm\n+0961d060cc8dd469c6dac8d7d75f927c0bb971b8 *vp90-2-00-quantizer-12.webm.md5\n+133b77a3bbcef652552d74ffc46afbfe3b8a1cba *vp90-2-00-quantizer-13.webm\n+df29e5e0f95772af482f540d776f6b9dea4bfa29 *vp90-2-00-quantizer-13.webm.md5\n+27323afdaf8987e025c27129c74c86502315a206 *vp90-2-00-quantizer-14.webm\n+ce96a2cc312942f0427a463f15a392870dd69764 *vp90-2-00-quantizer-14.webm.md5\n+ab58d0b41037829f6bc993910999f4af0212aafd *vp90-2-00-quantizer-15.webm\n+40f700db606501aa7cb49049624cbdde6409b122 *vp90-2-00-quantizer-15.webm.md5\n+cd948e66448aafb65998815ce37241f95d7c9ee7 *vp90-2-00-quantizer-16.webm\n+039b742d149c945ed79c7b9a6384352852a1c116 *vp90-2-00-quantizer-16.webm.md5\n+62f56e663e13c576764e491cf08f19bd46a71999 *vp90-2-00-quantizer-17.webm\n+90c5a39bf76e6b3e0a1c0d3e9b68a9fd78be963e *vp90-2-00-quantizer-17.webm.md5\n+f26ecad7263cd66a614e53ba5d7c00df181affeb *vp90-2-00-quantizer-18.webm\n+cda0a1c0fca2ec2976ae55124a8a67305508bae6 *vp90-2-00-quantizer-18.webm.md5\n+94bfc4c04fcfe139a63b98c569e8c14ba98c401f *vp90-2-00-quantizer-19.webm\n+5b8ec169ccf67d8a0a8e46a62eb173f5a1dbaf4f *vp90-2-00-quantizer-19.webm.md5\n+0ee88e9318985e1e245de78c2c4a665885ab76a7 *vp90-2-00-quantizer-20.webm\n+4b26f7edb4fcd3a1b4cce9ba3cb8650e3ee6e063 *vp90-2-00-quantizer-20.webm.md5\n+6a995cb2b1db33da8087321df1e646f95c3e32d1 *vp90-2-00-quantizer-21.webm\n+e216b4a1eceac03efcc433759be54ab8ea87b24b *vp90-2-00-quantizer-21.webm.md5\n+aa7722fc427e7180115f3c9cd96bb6b2768e7296 *vp90-2-00-quantizer-22.webm\n+1aa813bd45ae831bf5e79ace4d73dfd25989a07d *vp90-2-00-quantizer-22.webm.md5\n+7677e5b929ed6d142041f19b8a9cd5822ee1504a *vp90-2-00-quantizer-23.webm\n+0de0af34abd843d5b37e58baf3ed96a6104b64c3 *vp90-2-00-quantizer-23.webm.md5\n+b2995cbe1128b2d4926f1b28d01c501ecb6be8c8 *vp90-2-00-quantizer-24.webm\n+db6033af2ba2f2bca62468fb4b8808e474f93923 *vp90-2-00-quantizer-24.webm.md5\n+8135ba35587fd92cd4667be7896323d9b634401c *vp90-2-00-quantizer-25.webm\n+3499e00c2cc15876f61f07e3d3cfca54ebcd98fd *vp90-2-00-quantizer-25.webm.md5\n+af0fa2907746db82d345f6d831fcc1b2862a29fb *vp90-2-00-quantizer-26.webm\n+cd6fe3d14dab48886ebf65be00e6ed9616ebe5a7 *vp90-2-00-quantizer-26.webm.md5\n+bd0002e91323776beb5ff11e06edcf19fc08e9b9 *vp90-2-00-quantizer-27.webm\n+fe72154ef196067d6c272521012dd79706496cac *vp90-2-00-quantizer-27.webm.md5\n+fc15eb606f81455ff03df16bf3432296b002c43c *vp90-2-00-quantizer-28.webm\n+40b2e24b542206a6bfd746ef199e49ccea07678a *vp90-2-00-quantizer-28.webm.md5\n+3090bbf913cad0b2eddca7228f5ed51a58378b8d *vp90-2-00-quantizer-29.webm\n+eb59745e0912d8ed6c928268bcf265237c9ba93f *vp90-2-00-quantizer-29.webm.md5\n+c615abdca9c25e1cb110d908edbedfb3b7c92b91 *vp90-2-00-quantizer-30.webm\n+ad0f4fe6733e4e7cdfe8ef8722bb341dcc7538c0 *vp90-2-00-quantizer-30.webm.md5\n+037d9f242086cfb085518f6416259defa82d5fc2 *vp90-2-00-quantizer-31.webm\n+4654b40792572f0a790874c6347ef9196d86c1a7 *vp90-2-00-quantizer-31.webm.md5\n+505899f3f3515044c5c8b3213d9b9d16f614619d *vp90-2-00-quantizer-32.webm\n+659a2e6dd02df323f62600626859006640b445df *vp90-2-00-quantizer-32.webm.md5\n+8b32ec9c3b7e5ca8ddc6b8aea1c1cb7ca996bccc *vp90-2-00-quantizer-33.webm\n+5b175ef1120ddeba4feae1247bf381bbc4e816ce *vp90-2-00-quantizer-33.webm.md5\n+4d283755d17e287b1d099a80604398f60d7fb6ea *vp90-2-00-quantizer-34.webm\n+22a739de95acfeb27524e3700b8f678a9ad744d8 *vp90-2-00-quantizer-34.webm.md5\n+4296f56a892a412d3d4f64824718dd566c4e6459 *vp90-2-00-quantizer-35.webm\n+c532c9c8dc7b3506fc6a51e5c20c17ef0ac039e7 *vp90-2-00-quantizer-35.webm.md5\n+6f54e11da461e4410dd9075b015e2d9bc1d07dfb *vp90-2-00-quantizer-36.webm\n+0b3573f5addea4e3eb11a0b85f068299d5bdad78 *vp90-2-00-quantizer-36.webm.md5\n+210581682a26c2c4375efc785c36e07539888bc2 *vp90-2-00-quantizer-37.webm\n+2b4fb6f8ba975237858e61cc8f560bcfc87cb38e *vp90-2-00-quantizer-37.webm.md5\n+a15ef31283dfc4860f837fe200eb32a445f59629 *vp90-2-00-quantizer-38.webm\n+fb76771f3a795054b9936f70da7505c3ac585284 *vp90-2-00-quantizer-38.webm.md5\n+1df8433a441412831daae6726df89fa70d21b14d *vp90-2-00-quantizer-39.webm\n+39e162c09a20e7e684868097766347014371fee6 *vp90-2-00-quantizer-39.webm.md5\n+5330e4788ab9129dbb25a7a7d5411104521248b6 *vp90-2-00-quantizer-40.webm\n+872cc0f2cc9dbf000f89eadb4d8f9940e48e00b1 *vp90-2-00-quantizer-40.webm.md5\n+d88d03b982889e399a78d7a06eeb1cf30e6c2da2 *vp90-2-00-quantizer-41.webm\n+5b4f7217e57fa2a221011d0b32f8d0409496b7b6 *vp90-2-00-quantizer-41.webm.md5\n+9e16406e3e26955a6e17d455ef1ef64bbfa26e53 *vp90-2-00-quantizer-42.webm\n+0219d090cf37daabe19256ba8e932ba4874b92e4 *vp90-2-00-quantizer-42.webm.md5\n+a9b15843486fb05f8cd15437ef279782a42b75db *vp90-2-00-quantizer-43.webm\n+3c9b0b4c607f9579a31726bfcf56729334ddc686 *vp90-2-00-quantizer-43.webm.md5\n+1dbc931ac446c91eabe7213efff55b596cccf07c *vp90-2-00-quantizer-44.webm\n+73bc8f675103abaef3d9f73a2742b3bffd726d23 *vp90-2-00-quantizer-44.webm.md5\n+7c6c1be15beb9d6201204b018966c8c4f9777efc *vp90-2-00-quantizer-45.webm\n+c907b29da821f790c6748de61f592689312e4e36 *vp90-2-00-quantizer-45.webm.md5\n+07b434da1a467580f73b32177ee11b3e00f65a0d *vp90-2-00-quantizer-46.webm\n+7b2b7ce60c50bc970bc0ada46d7a7ce440148da3 *vp90-2-00-quantizer-46.webm.md5\n+233d0465fb1a6fa36e9f89bd2193ac79bd4d2809 *vp90-2-00-quantizer-47.webm\n+527e0a9fb932efe915027ffe077f9e8d3a4fb139 *vp90-2-00-quantizer-47.webm.md5\n+719613df7307e205c3fdb6acfb373849c5ab23c7 *vp90-2-00-quantizer-48.webm\n+65ab6c9d1b682c183b201c7ff42b90343ce3e304 *vp90-2-00-quantizer-48.webm.md5\n+3bf04a598325ed0eabae1598ec7f718f715ec672 *vp90-2-00-quantizer-49.webm\n+ac68c4387ce11fcc998d8ba455ab9b2bb361d240 *vp90-2-00-quantizer-49.webm.md5\n+d59238fb3a654931c9b65a11e7321b40d1f702e9 *vp90-2-00-quantizer-50.webm\n+d0576bfede46fd55659f028f2fd28554ceb3e6cc *vp90-2-00-quantizer-50.webm.md5\n+3f579785101d4209360dd96f8c2ffe9beddf3bee *vp90-2-00-quantizer-51.webm\n+89fcfe04f4457a7f02ab4a2f94aacbb88aee5789 *vp90-2-00-quantizer-51.webm.md5\n+28be5836e2fedefe4babf12fc9b79e460ab0a0f4 *vp90-2-00-quantizer-52.webm\n+f3dd52b70c18345fee740220f35da9c4def2017a *vp90-2-00-quantizer-52.webm.md5\n+488ad4058c17170665b6acd1021fade9a02771e4 *vp90-2-00-quantizer-53.webm\n+1cdcb1d4f3a37cf83ad235eb27ec62ed2a01afc7 *vp90-2-00-quantizer-53.webm.md5\n+682978289cb28cc8c9d39bc797300e45d6039de7 *vp90-2-00-quantizer-54.webm\n+36c35353f2c03cb099bd710d9994de7d9ed88834 *vp90-2-00-quantizer-54.webm.md5\n+c398ce49af762a48f10cc4da9fae0769aae5f226 *vp90-2-00-quantizer-55.webm\n+2cf3570542d984f167ab087f59493c7fb47e0ed2 *vp90-2-00-quantizer-55.webm.md5\n+3071f18b2fce261aa82d61f81a7ae4ca9a75d0e3 *vp90-2-00-quantizer-56.webm\n+d3f93f8272b6de31cffb011a26f11abb514efb12 *vp90-2-00-quantizer-56.webm.md5\n+f4e8e14b1f278801a7eb6f11734780a01b1668e9 *vp90-2-00-quantizer-57.webm\n+6478fdf1d7faf6db5f19dffc5e1363af358699ee *vp90-2-00-quantizer-57.webm.md5\n+307dc264f57cc618fff211fa44d7f52767ed9660 *vp90-2-00-quantizer-58.webm\n+cf231d4a52d492fa692ea4194ec5eb7511fec54e *vp90-2-00-quantizer-58.webm.md5\n+1fd7cd596170afce2de0b1441b7674bda5723440 *vp90-2-00-quantizer-59.webm\n+4681f7ef96f63e085c41bb1a964b0df7e67e0b38 *vp90-2-00-quantizer-59.webm.md5\n+34cdcc81c0ba7085aefbb22d7b4aa9bca3dd7c62 *vp90-2-00-quantizer-60.webm\n+58691ef53b6b623810e2c57ded374c77535df935 *vp90-2-00-quantizer-60.webm.md5\n+e6e812406aab81021bb16e772c1db03f75906cb6 *vp90-2-00-quantizer-61.webm\n+76436eace62f08ff92b61a0845e66667a027db1b *vp90-2-00-quantizer-61.webm.md5\n+84d811bceed70c950a6a08e572a6e274866e72b1 *vp90-2-00-quantizer-62.webm\n+2d937cc011eeddd95222b960982da5cd18db580f *vp90-2-00-quantizer-62.webm.md5\n+0912b295ba0ea09359315315ffd67d22d046f883 *vp90-2-00-quantizer-63.webm\n+5a829031055d70565f57dbcd47a6ac33619952b3 *vp90-2-00-quantizer-63.webm.md5\n+0cf9e5ebe0112bdb47b5887ee5d58eb9d4727c00 *vp90-2-01-sharpness-1.webm\n+5a0476be4448bae8f8ca17ea236c98793a755948 *vp90-2-01-sharpness-1.webm.md5\n+51e02d7911810cdf5be8b68ac40aedab479a3179 *vp90-2-01-sharpness-2.webm\n+a0ca5bc87a5ed7c7051f59078daa0d03be1b45b6 *vp90-2-01-sharpness-2.webm.md5\n+0603f8ad239c07a531d948187f4dafcaf51eda8d *vp90-2-01-sharpness-3.webm\n+3af8000a69c72fe77881e3176f026c2affb78cc7 *vp90-2-01-sharpness-3.webm.md5\n+4ca4839f48146252fb261ed88838d80211804841 *vp90-2-01-sharpness-4.webm\n+08832a1494f84fa9edd40e080bcf2c0e80100c76 *vp90-2-01-sharpness-4.webm.md5\n+95099dc8f9cbaf9b9a7dd65311923e441ff70731 *vp90-2-01-sharpness-5.webm\n+93ceee30c140f0b406726c0d896b9db6031c4c7f *vp90-2-01-sharpness-5.webm.md5\n+ceb4116fb7b078d266d153233b6d62a255a34e4c *vp90-2-01-sharpness-6.webm\n+da83efe59e537ce538e8b03a6eac63cf25849c9a *vp90-2-01-sharpness-6.webm.md5\n+b5f7cd19aece3880f9d616a778e5cc24c6b9b505 *vp90-2-01-sharpness-7.webm\n+2957408d20deac8633941a2169f801bae6f086e1 *vp90-2-01-sharpness-7.webm.md5\n+ffc096c2ce1050450ad462b5fabd2a5220846319 *vp90-2-02-size-08x08.webm\n+e36d2ed6fa2746347710b750586aafa6a01ff3ae *vp90-2-02-size-08x08.webm.md5\n+895b986f9fd55cd879472b31c6a06b82094418c8 *vp90-2-02-size-08x10.webm\n+079157a19137ccaebba606f2871f45a397347150 *vp90-2-02-size-08x10.webm.md5\n+1c5992203e62a2b83040ccbecd748b604e19f4c0 *vp90-2-02-size-08x16.webm\n+9aa45ffdf2078f883bbed01450031b691819c144 *vp90-2-02-size-08x16.webm.md5\n+d0a8953da1f85f484487408fee5da9e2a8391901 *vp90-2-02-size-08x18.webm\n+59a5cc17d354c6a23e5e959d666b1456a5d49c56 *vp90-2-02-size-08x18.webm.md5\n+1b13461a9fc65cb041bacfe4ea6f02d363397d61 *vp90-2-02-size-08x32.webm\n+2bdddd6878f05d37d84cde056a3f5e7f926ba3d6 *vp90-2-02-size-08x32.webm.md5\n+2861f0a0daadb62295b0504a1fbe5b50c79a8f59 *vp90-2-02-size-08x34.webm\n+6b5812cfb8a82d378ea2913bf009e93668020147 *vp90-2-02-size-08x34.webm.md5\n+02f948216d4246579dc53c47fe55d8fb264ba251 *vp90-2-02-size-08x64.webm\n+84b55fdee6d9aa820c7a8c62822446184b191767 *vp90-2-02-size-08x64.webm.md5\n+4b011242cbf42516efd2b197baebb61dd34562c9 *vp90-2-02-size-08x66.webm\n+6b1fa0a885947b3cc0fe58f75f838e662bd9bb8b *vp90-2-02-size-08x66.webm.md5\n+4057796be9dd12df48ab607f502ae6aa70eeeab6 *vp90-2-02-size-10x08.webm\n+71c752c51aec9f48de286b93f4c20e9c11cad7d0 *vp90-2-02-size-10x08.webm.md5\n+6583c853fa43fc53d51743eac5f3a43a359d45d0 *vp90-2-02-size-10x10.webm\n+1da524d24af1944b671d4d3f2b398d6e336584c3 *vp90-2-02-size-10x10.webm.md5\n+ba442fc03ccd3a705c64c83b36f5ada67d198874 *vp90-2-02-size-10x16.webm\n+7cfd960f232c34c641a4a2a9411b6fd0efb2fc50 *vp90-2-02-size-10x16.webm.md5\n+cc92ed40eef14f52e4d080cb2c57939dd8326374 *vp90-2-02-size-10x18.webm\n+db5626275cc55ce970b91c995e74f6838d943aca *vp90-2-02-size-10x18.webm.md5\n+3a93d501d22325e9fd4c9d8b82e2a432de33c351 *vp90-2-02-size-10x32.webm\n+5cae51b0c71cfc131651f345f87583eb2903afaf *vp90-2-02-size-10x32.webm.md5\n+50d2f2b15a9a5178153db44a9e03aaf32b227f67 *vp90-2-02-size-10x34.webm\n+bb0efe058122641e7f73e94497dda2b9e6c21efd *vp90-2-02-size-10x34.webm.md5\n+01624ec173e533e0b33fd9bdb91eb7360c7c9175 *vp90-2-02-size-10x64.webm\n+b9c0e3b054463546356acf5157f9be92fd34732f *vp90-2-02-size-10x64.webm.md5\n+2942879baf1c09e96b14d0fc84806abfe129c706 *vp90-2-02-size-10x66.webm\n+bab5f539c2f91952e187456b4beafbb4c01e25ee *vp90-2-02-size-10x66.webm.md5\n+88d2b63ca5e9ee163d8f20e8886f3df3ff301a66 *vp90-2-02-size-16x08.webm\n+7f48a0fcf8c25963f3057d7f6669c5f2415834b8 *vp90-2-02-size-16x08.webm.md5\n+59261eb34c15ea9b5ddd2d416215c1a8b9e6dc1f *vp90-2-02-size-16x10.webm\n+73a7c209a46dd051c9f7339b6e02ccd5b3b9fc81 *vp90-2-02-size-16x10.webm.md5\n+066834fef9cf5b9a72932cf4dea5f253e14a976d *vp90-2-02-size-16x16.webm\n+faec542f52f37601cb9c480d887ae9355be99372 *vp90-2-02-size-16x16.webm.md5\n+195307b4eb3192271ee4a935b0e48deef0c54cc2 *vp90-2-02-size-16x18.webm\n+5a92e19e624c0376321d4d0e22c0c91995bc23e1 *vp90-2-02-size-16x18.webm.md5\n+14f3f884216d7ae16ec521f024a2f2d31bbf9c1a *vp90-2-02-size-16x32.webm\n+ea622d1c817dd174556f7ee7ccfe4942b34d4845 *vp90-2-02-size-16x32.webm.md5\n+2e0501100578a5da9dd47e4beea160f945bdd1ba *vp90-2-02-size-16x34.webm\n+1b8645ef64239334921c5f56b24ce815e6070b05 *vp90-2-02-size-16x34.webm.md5\n+89a6797fbebebe93215f367229a9152277f5dcfe *vp90-2-02-size-16x64.webm\n+a03d8c1179ca626a8856fb416d635dbf377979cd *vp90-2-02-size-16x64.webm.md5\n+0f3a182e0750fcbae0b9eae80c7a53aabafdd18d *vp90-2-02-size-16x66.webm\n+8cb6736dc2d897c1283919a32068af377d66c59c *vp90-2-02-size-16x66.webm.md5\n+68fe70dc7914cc1d8d6dcd97388b79196ba3e7f1 *vp90-2-02-size-18x08.webm\n+874c7fb505be9db3160c57cb405c4dbd5b990dc2 *vp90-2-02-size-18x08.webm.md5\n+0546352dd78496d4dd86c3727ac2ff36c9e72032 *vp90-2-02-size-18x10.webm\n+1d80eb36557ea5f25a386495a36f93da0f25316b *vp90-2-02-size-18x10.webm.md5\n+60fe99e5f5cc99706efa3e0b894e45cbcf0d6330 *vp90-2-02-size-18x16.webm\n+1ab6cdd89a53662995d103546e6611c84f9292ab *vp90-2-02-size-18x16.webm.md5\n+f9a8f5fb749d69fd555db6ca093b7f77800c7b4f *vp90-2-02-size-18x18.webm\n+ace8a66328f7802b15f9989c2720c029c6abd279 *vp90-2-02-size-18x18.webm.md5\n+a197123a527ec25913a9bf52dc8c347749e00045 *vp90-2-02-size-18x32.webm\n+34fbd7036752232d1663e70d7f7cdc93f7129202 *vp90-2-02-size-18x32.webm.md5\n+f219655a639a774a2c9c0a9f45c28dc0b5e75e24 *vp90-2-02-size-18x34.webm\n+2c4d622a9ea548791c1a07903d3702e9774388bb *vp90-2-02-size-18x34.webm.md5\n+5308578da48c677d477a5404e19391d1303033c9 *vp90-2-02-size-18x64.webm\n+e7fd4462527bac38559518ba80e41847db880f15 *vp90-2-02-size-18x64.webm.md5\n+e109a7e013bd179f97e378542e1e81689ed06802 *vp90-2-02-size-18x66.webm\n+45c04e422fb383c1f3be04beefaa4490e83bdb1a *vp90-2-02-size-18x66.webm.md5\n+38844cae5d99caf445f7de33c3ae78494ce36c01 *vp90-2-02-size-32x08.webm\n+ad018be39e493ca2405225034b1a5b7a42af6f3a *vp90-2-02-size-32x08.webm.md5\n+7b57eaad55906f9de9903c8657a3fcb2aaf792ea *vp90-2-02-size-32x10.webm\n+2294425d4e55d275af5e25a0beac9738a1b4ee73 *vp90-2-02-size-32x10.webm.md5\n+f47ca2ced0d47f761bb0a5fdcd911d3f450fdcc1 *vp90-2-02-size-32x16.webm\n+ae10981d93913f0ab1f28c1146255e01769aa8c0 *vp90-2-02-size-32x16.webm.md5\n+08b23ad838b6cf1fbfe3ad7e7775d95573e815fc *vp90-2-02-size-32x18.webm\n+1ba76f4c4a4ac7aabfa3ce195c1b473535eb7cc8 *vp90-2-02-size-32x18.webm.md5\n+d5b88ae6c8c25c53dee74d9f1e6ca64244349a57 *vp90-2-02-size-32x32.webm\n+e39c067a8ee2da52a51641eb1cb7f8eba935eb6b *vp90-2-02-size-32x32.webm.md5\n+529429920dc36bd899059fa75a767f02c8c60874 *vp90-2-02-size-32x34.webm\n+56888e7834f52b106e8911e3a7fc0f473b609995 *vp90-2-02-size-32x34.webm.md5\n+38e848e160391c2b1a55040aadde613b9f4bf15e *vp90-2-02-size-32x64.webm\n+8950485fb3f68b0e8be234db860e4ec5f5490fd0 *vp90-2-02-size-32x64.webm.md5\n+5e8670f0b8ec9cefa8795b8959ffbe1a8e1aea94 *vp90-2-02-size-32x66.webm\n+225df9d7d72ec711b0b60f4aeb65311c97db054a *vp90-2-02-size-32x66.webm.md5\n+695f929e2ce6fb11a1f180322d46c5cb1c97fa61 *vp90-2-02-size-34x08.webm\n+5bb4262030018dd01883965c6aa6070185924ef6 *vp90-2-02-size-34x08.webm.md5\n+5adf74ec906d2ad3f7526e06bd29f5ad7d966a90 *vp90-2-02-size-34x10.webm\n+71c100b437d3e8701632ae8d65c3555339b1c68f *vp90-2-02-size-34x10.webm.md5\n+d0918923c987fba2d00193d83797b21289fe54aa *vp90-2-02-size-34x16.webm\n+5d5a52f3535b4d2698dd3d87f4a13fdc9b57163d *vp90-2-02-size-34x16.webm.md5\n+553ab0042cf87f5e668ec31b2e4b2a4b6ec196fd *vp90-2-02-size-34x18.webm\n+a164c7f3c424987df2340496e6a8cf76e973f0f1 *vp90-2-02-size-34x18.webm.md5\n+baf3e233634f150de81c18ba5d8848068e1c3c54 *vp90-2-02-size-34x32.webm\n+22a79d3bd1c9b85dfe8c70bb2e19f08a92a8be03 *vp90-2-02-size-34x32.webm.md5\n+6d50a533774a7167350e4a7ef43c94a5622179a2 *vp90-2-02-size-34x34.webm\n+0c099638e79c273546523e06704553e42eb00b00 *vp90-2-02-size-34x34.webm.md5\n+698cdd0a5e895cc202c488675e682a8c537ede4f *vp90-2-02-size-34x64.webm\n+9317b63987cddab8389510a27b86f9f3d46e3fa5 *vp90-2-02-size-34x64.webm.md5\n+4b5335ca06f082b6b69f584eb8e7886bdcafefd3 *vp90-2-02-size-34x66.webm\n+e18d68b35428f46a84a947c646804a51ef1d7cec *vp90-2-02-size-34x66.webm.md5\n+a54ae7b494906ec928a876e8290e5574f2f9f6a2 *vp90-2-02-size-64x08.webm\n+87f9f7087b6489d45e9e4b38ede2c5aef4a4928f *vp90-2-02-size-64x08.webm.md5\n+24522c70804a3c23d937df2d829ae63965b23f38 *vp90-2-02-size-64x10.webm\n+447ce03938ab53bffcb4a841ee0bfaa90462dcb9 *vp90-2-02-size-64x10.webm.md5\n+2a5035d035d214ae614af8051930690ef623989b *vp90-2-02-size-64x16.webm\n+84e355761dd2e0361b904c84c52a0dd0384d89cf *vp90-2-02-size-64x16.webm.md5\n+3a293ef4e270a19438e59b817fbe5f43eed4d36b *vp90-2-02-size-64x18.webm\n+666824e5ba746779eb46079e0631853dcc86d48b *vp90-2-02-size-64x18.webm.md5\n+ed32fae837095c9e8fc95d223ec68101812932c2 *vp90-2-02-size-64x32.webm\n+97086eadedce1d0d9c072b585ba7b49aec69b1e7 *vp90-2-02-size-64x32.webm.md5\n+696c7a7250bdfff594f4dfd88af34239092ecd00 *vp90-2-02-size-64x34.webm\n+253a1d38d452e7826b086846c6f872f829c276bb *vp90-2-02-size-64x34.webm.md5\n+fc508e0e3c2e6872c60919a60b812c5232e9c2b0 *vp90-2-02-size-64x64.webm\n+2cd6ebeca0f82e9f505616825c07950371b905ab *vp90-2-02-size-64x64.webm.md5\n+0f8a4fc1d6521187660425c283f08dff8c66e476 *vp90-2-02-size-64x66.webm\n+5806be11a1d346be235f88d3683e69f73746166c *vp90-2-02-size-64x66.webm.md5\n+273b0c36e3658685cde250408a478116d7ae92f1 *vp90-2-02-size-66x08.webm\n+23c3cd0dca20a2f71f036e77ea92025ff4e7a298 *vp90-2-02-size-66x08.webm.md5\n+4844c59c3306d1e671bb0568f00e344bf797e66e *vp90-2-02-size-66x10.webm\n+e041eaf6841d775f8fde8bbb4949d2733fdaab7f *vp90-2-02-size-66x10.webm.md5\n+bdf3f1582b234fcd2805ffec59f9d716a2345302 *vp90-2-02-size-66x16.webm\n+2ec85ee18119e6798968571ea6e1b93ca386e3af *vp90-2-02-size-66x16.webm.md5\n+0acce9af12b13b025d5274013da7ef6f568f075f *vp90-2-02-size-66x18.webm\n+77c4d53e2a5c96b70af9d575fe6811e0f5ee627b *vp90-2-02-size-66x18.webm.md5\n+682b36a25774bbdedcd603f504d18eb63f0167d4 *vp90-2-02-size-66x32.webm\n+53728fae2a428f16d376a29f341a64ddca97996a *vp90-2-02-size-66x32.webm.md5\n+e71b70e901e29eaa6672a6aa4f37f6f5faa02bd6 *vp90-2-02-size-66x34.webm\n+f69a6a555e3f614b0a35f9bfc313d8ebb35bc725 *vp90-2-02-size-66x34.webm.md5\n+4151b8c29452d5c2266397a7b9bf688899a2937b *vp90-2-02-size-66x64.webm\n+69486e7fd9e380b6c97a03d3e167affc79f73840 *vp90-2-02-size-66x64.webm.md5\n+68784a1ecac776fe2a3f230345af32f06f123536 *vp90-2-02-size-66x66.webm\n+7f008c7f48d55e652fbd6bac405b51e0015c94f2 *vp90-2-02-size-66x66.webm.md5\n+7e1bc449231ac1c5c2a11c9a6333b3e828763798 *vp90-2-03-size-196x196.webm\n+6788a561466dace32d500194bf042e19cccc35e1 *vp90-2-03-size-196x196.webm.md5\n+a170c9a88ec1dd854c7a471ff55fb2a97ac31870 *vp90-2-03-size-196x198.webm\n+6bf9d6a8e2bdc5bf4f8a78071a3fed5ca02ad6f2 *vp90-2-03-size-196x198.webm.md5\n+68f861d21c4c8b03d572c3d3fcd9f4fbf1f4503f *vp90-2-03-size-196x200.webm\n+bbfc260b2bfd872cc6054272bb6b7f959a9e1c6e *vp90-2-03-size-196x200.webm.md5\n+fc34889feeca2b7e5b27b4f1ce22d2e2b8e3e4b1 *vp90-2-03-size-196x202.webm\n+158ee72af578f39aad0c3b8f4cbed2fc78b57e0f *vp90-2-03-size-196x202.webm.md5\n+dd28fb7247af534bdf5e6795a3ac429610489a0b *vp90-2-03-size-196x208.webm\n+7546be847efce2d1c0a23f807bfb03f91b764e1e *vp90-2-03-size-196x208.webm.md5\n+41d5cf5ed65b722a1b6dc035e67f978ea8ffecf8 *vp90-2-03-size-196x210.webm\n+9444fdf632d6a1b6143f4cb10fed8f63c1d67ec1 *vp90-2-03-size-196x210.webm.md5\n+5007bc618143437c009d6dde5fc2e86f72d37dc2 *vp90-2-03-size-196x224.webm\n+858361d8f79b44df5545feabbc9754ec9ede632f *vp90-2-03-size-196x224.webm.md5\n+0bcbe357fbc776c3fa68e7117179574ed7564a44 *vp90-2-03-size-196x226.webm\n+72006a5f42031a43d70a2cd9fc1958962a86628f *vp90-2-03-size-196x226.webm.md5\n+000239f048cceaac055558e97ef07078ebf65502 *vp90-2-03-size-198x196.webm\n+2d6841901b72000c5340f30be602853438c1b787 *vp90-2-03-size-198x196.webm.md5\n+ae75b766306a6404c3b3b35a6b6d53633c14fbdb *vp90-2-03-size-198x198.webm\n+3f2544b4f3b4b643a98f2c3b15ea5826fc702fa1 *vp90-2-03-size-198x198.webm.md5\n+95ffd573fa84ccef1cd59e1583e6054f56a5c83d *vp90-2-03-size-198x200.webm\n+5d537e3c9b9c54418c79677543454c4cda3de1af *vp90-2-03-size-198x200.webm.md5\n+ecc845bf574375f469bc91bf5c75c79dc00073d6 *vp90-2-03-size-198x202.webm\n+1b59f5e111265615a7a459eeda8cc9045178d228 *vp90-2-03-size-198x202.webm.md5\n+432fb27144fe421b9f51cf44d2750a26133ed585 *vp90-2-03-size-198x208.webm\n+a58a67f4fb357c73ca078aeecbc0f782975630b1 *vp90-2-03-size-198x208.webm.md5\n+ff5058e7e6a47435046612afc8536f2040989e6f *vp90-2-03-size-198x210.webm\n+18d3be7935e52217e2e9400b6f2c681a9e45dc89 *vp90-2-03-size-198x210.webm.md5\n+a0d55263c1ed2c03817454dd4ec4090d36dbc864 *vp90-2-03-size-198x224.webm\n+efa366a299817e2da51c00623b165aab9fbb8d91 *vp90-2-03-size-198x224.webm.md5\n+ccd142fa2920fc85bb753f049160c1c353ad1574 *vp90-2-03-size-198x226.webm\n+534524a0b2dbff852e0b92ef09939db072f83243 *vp90-2-03-size-198x226.webm.md5\n+0d483b94ed40abc8ab6e49f960432ee54ad9c7f1 *vp90-2-03-size-200x196.webm\n+41795f548181717906e7a504ba551f06c32102ae *vp90-2-03-size-200x196.webm.md5\n+f6c2dc54e0989d50f01333fe40c91661fcbf849a *vp90-2-03-size-200x198.webm\n+43df5d8c46a40089441392e6d096c588c1079a68 *vp90-2-03-size-200x198.webm.md5\n+2f6e9df82e44fc145f0d9212dcccbed3de605e23 *vp90-2-03-size-200x200.webm\n+757b2ef96b82093255725bab9690bbafe27f3caf *vp90-2-03-size-200x200.webm.md5\n+40c5ea60415642a4a2e75c0d127b06309baadfab *vp90-2-03-size-200x202.webm\n+3022c4a1c625b5dc04fdb1052d17d45b4171cfba *vp90-2-03-size-200x202.webm.md5\n+6942ed5b27476bb8506d10e600d6ff60887780ca *vp90-2-03-size-200x208.webm\n+c4ab8c66f3cf2dc8e8dd7abae9ac21f4d32cd6be *vp90-2-03-size-200x208.webm.md5\n+71dbc99b83c49d1da45589b91eabb98e2f4a7b1e *vp90-2-03-size-200x210.webm\n+3f0b40da7eef7974b9bc326562f251feb67d9c7c *vp90-2-03-size-200x210.webm.md5\n+6b6b8489081cfefb377cc5f18eb754ec2383f655 *vp90-2-03-size-200x224.webm\n+a259df2ac0e294492e3f9d4315baa34cab044f04 *vp90-2-03-size-200x224.webm.md5\n+c9adc1c9bb07559349a0b054df4af56f7a6edbb9 *vp90-2-03-size-200x226.webm\n+714cec61e3575581e4f1a0e3921f4dfdbbd316c5 *vp90-2-03-size-200x226.webm.md5\n+f9bdc936bdf53f8be9ce78fecd41a21d31ff3943 *vp90-2-03-size-202x196.webm\n+5b8e2e50fcea2c43b12fc067b8a9cc117af77bda *vp90-2-03-size-202x196.webm.md5\n+c7b66ea3da87613deb47ff24a111247d3c384fec *vp90-2-03-size-202x198.webm\n+517e91204b25586da943556f4adc5951c9be8bee *vp90-2-03-size-202x198.webm.md5\n+935ef56b01cfdb4265a7e24696645209ccb20970 *vp90-2-03-size-202x200.webm\n+55b8ec4a2513183144a8e27564596c06c7576fce *vp90-2-03-size-202x200.webm.md5\n+849acf75e4f1d8d90046704e1103a18c64f30e35 *vp90-2-03-size-202x202.webm\n+c79afc6660df2824e7df314e5bfd71f0d8acf76b *vp90-2-03-size-202x202.webm.md5\n+17b3a4d55576b770626ccb856b9f1a6c8f6ae476 *vp90-2-03-size-202x208.webm\n+0b887ff30409c58f2ccdc3bfacd6be7c69f8997a *vp90-2-03-size-202x208.webm.md5\n+032d0ade4230fb2eef6d19915a7a1c9aa4a52617 *vp90-2-03-size-202x210.webm\n+f78f8e79533c0c88dd2bfdcec9b1c07848568ece *vp90-2-03-size-202x210.webm.md5\n+915a38c31fe425d5b93c837121cfa8082f5ea5bc *vp90-2-03-size-202x224.webm\n+bf52a104074d0c5942aa7a5b31e11db47e43d48e *vp90-2-03-size-202x224.webm.md5\n+be5cfde35666fa435e47d544d9258215beb1cf29 *vp90-2-03-size-202x226.webm\n+2fa2f87502fda756b319389c8975204e130a2e3f *vp90-2-03-size-202x226.webm.md5\n+15d908e97862b5b4bf295610df011fb9aa09909b *vp90-2-03-size-208x196.webm\n+50c60792305d6a99be376dd596a6ff979325e6cc *vp90-2-03-size-208x196.webm.md5\n+a367c7bc9fde56d6f4848cc573c7d4c1ce75e348 *vp90-2-03-size-208x198.webm\n+be85fb2c8d435a75484231356f07d06ebddd13cd *vp90-2-03-size-208x198.webm.md5\n+05fd46deb7288e7253742091f56e54a9a441a187 *vp90-2-03-size-208x200.webm\n+74f8ec3b3a2fe81767ed1ab36a47bc0062d6223c *vp90-2-03-size-208x200.webm.md5\n+d8985c4b386513a7385a4b3639bf91e469f1378b *vp90-2-03-size-208x202.webm\n+0614a1e8d92048852adcf605a51333f5fabc7f03 *vp90-2-03-size-208x202.webm.md5\n+28b002242238479165ba4fb87ee6b442c64b32e4 *vp90-2-03-size-208x208.webm\n+37de5aca59bb900228400b0e115d3229edb9dcc0 *vp90-2-03-size-208x208.webm.md5\n+c545be0050c2fad7c68427dbf86c62a739e94ab3 *vp90-2-03-size-208x210.webm\n+d646eccb3cd578f94b54777e32b88898bef6e17a *vp90-2-03-size-208x210.webm.md5\n+63a0cfe295b661026dd7b1bebb67acace1db766f *vp90-2-03-size-208x224.webm\n+85c0361d93bf85a335248fef2767ff43eeef23db *vp90-2-03-size-208x224.webm.md5\n+f911cc718d66e4fe8a865226088939c9eb1b7825 *vp90-2-03-size-208x226.webm\n+a6d583a57876e7b7ec48625b2b2cdbcf70cab837 *vp90-2-03-size-208x226.webm.md5\n+5bbb0f36da9a4683cf04e724124d8696332911bf *vp90-2-03-size-210x196.webm\n+a3580fc7816d7fbcfb54fdba501cabbd06ba2f1d *vp90-2-03-size-210x196.webm.md5\n+8db64d6f9ce36dd382013b42ae4e292deba697bc *vp90-2-03-size-210x198.webm\n+eda20f8268c7f4147bead4059e9c4897e09140a9 *vp90-2-03-size-210x198.webm.md5\n+ce391505eeaf1d12406563101cd6b2dbbbb44bfc *vp90-2-03-size-210x200.webm\n+79d73b7f623082d2a00aa33e95c79d11c7d9c3a8 *vp90-2-03-size-210x200.webm.md5\n+852db6fdc206e72391fc69b807f1954934679949 *vp90-2-03-size-210x202.webm\n+f69414c5677ed2f2b8b37ae76429e509a92276a5 *vp90-2-03-size-210x202.webm.md5\n+c424cc3edd2308da7d33f27acb36b54db5bf2595 *vp90-2-03-size-210x208.webm\n+27b18562faa1b3184256f4eae8114b539b3e9d3e *vp90-2-03-size-210x208.webm.md5\n+dd029eba719d50a2851592fa8b9b2efe88904930 *vp90-2-03-size-210x210.webm\n+c853a1670465eaa04ca31b3511995f1b6ed4f58f *vp90-2-03-size-210x210.webm.md5\n+d962e8ae676c54d0c3ea04ec7c04b37ae6a786e3 *vp90-2-03-size-210x224.webm\n+93b793e79d987065b39ad8e2e71244368435fc25 *vp90-2-03-size-210x224.webm.md5\n+3d0825fe83bcc125be1f78145ff43ca6d7588784 *vp90-2-03-size-210x226.webm\n+5230f31a57ca3b5311698a12035d2644533b3ec4 *vp90-2-03-size-210x226.webm.md5\n+6622f8bd9279e1ce45509a58a31a990052d45e14 *vp90-2-03-size-224x196.webm\n+65411da07f60113f2be05c807879072b161d561e *vp90-2-03-size-224x196.webm.md5\n+6744ff2ee2c41eb08c62ff30880833b6d77b585b *vp90-2-03-size-224x198.webm\n+46ea3641d41acd4bff347b224646c060d5620385 *vp90-2-03-size-224x198.webm.md5\n+8eb91f3416a1404705f370caecd74b2b458351b1 *vp90-2-03-size-224x200.webm\n+196aefb854c8b95b9330263d6690b7ee15693ecf *vp90-2-03-size-224x200.webm.md5\n+256a5a23ef4e6d5ef2871af5afb8cd13d28cec00 *vp90-2-03-size-224x202.webm\n+840ad8455dcf2be378c14b007e66fa642fc8196d *vp90-2-03-size-224x202.webm.md5\n+db4606480ab48b96c9a6ff5e639f1f1aea2a12e4 *vp90-2-03-size-224x208.webm\n+40b9801d5620467499ac70fa6b7c40aaa5e1c331 *vp90-2-03-size-224x208.webm.md5\n+e37159e687fe1cb24cffddfae059301adbaf4212 *vp90-2-03-size-224x210.webm\n+1e4acd4b6334ae260c3eed08652d0ba8122073f2 *vp90-2-03-size-224x210.webm.md5\n+0de1eb4bb6285ae621e4f2b613d2aa4a8c95a130 *vp90-2-03-size-224x224.webm\n+37db449ad86fb286c2c02d94aa8fe0379c05044a *vp90-2-03-size-224x224.webm.md5\n+32ebbf903a7d7881bcfe59639f1d472371f3bf27 *vp90-2-03-size-224x226.webm\n+5cc3ac5dc9f6912491aa2ddac863f8187f34c569 *vp90-2-03-size-224x226.webm.md5\n+9480ff5c2c32b1870ac760c87514912616e6cf01 *vp90-2-03-size-226x196.webm\n+fe83655c0f1888f0af7b047785f01ba7ca9f1324 *vp90-2-03-size-226x196.webm.md5\n+09cad4221996315cdddad4e502dbfabf53ca1d6a *vp90-2-03-size-226x198.webm\n+e3ddfdc650acb95adb45abd9b634e1f09ea8ac96 *vp90-2-03-size-226x198.webm.md5\n+c34f49d55fe39e3f0b607e3cc95e30244225cecb *vp90-2-03-size-226x200.webm\n+abb83edc868a3523ccd4e5523fac2efbe7c3df1f *vp90-2-03-size-226x200.webm.md5\n+d17bc08eedfc60c4c23d576a6c964a21bf854d1f *vp90-2-03-size-226x202.webm\n+1d22d2d0f375251c2d5a1acb4714bc35d963865b *vp90-2-03-size-226x202.webm.md5\n+9bd537c4f92a25596ccd29fedfe181feac948b92 *vp90-2-03-size-226x208.webm\n+6feb0e7325386275719f3511ada9e248a2ae7df4 *vp90-2-03-size-226x208.webm.md5\n+4487067f6cedd495b93696b44b37fe0a3e7eda14 *vp90-2-03-size-226x210.webm\n+49a8fa87945f47208168d541c068e78d878075d5 *vp90-2-03-size-226x210.webm.md5\n+559fea2f8da42b33c1aa1dbc34d1d6781009847a *vp90-2-03-size-226x224.webm\n+83c6d8f2969b759e10e5c6542baca1265c874c29 *vp90-2-03-size-226x224.webm.md5\n+fe0af2ee47b1e5f6a66db369e2d7e9d870b38dce *vp90-2-03-size-226x226.webm\n+94ad19b8b699cea105e2ff18f0df2afd7242bcf7 *vp90-2-03-size-226x226.webm.md5\n+b6524e4084d15b5d0caaa3d3d1368db30cbee69c *vp90-2-03-deltaq.webm\n+65f45ec9a55537aac76104818278e0978f94a678 *vp90-2-03-deltaq.webm.md5\n+4dbb87494c7f565ffc266c98d17d0d8c7a5c5aba *vp90-2-05-resize.ivf\n+7f6d8879336239a43dbb6c9f13178cb11cf7ed09 *vp90-2-05-resize.ivf.md5\n+bf61ddc1f716eba58d4c9837d4e91031d9ce4ffe *vp90-2-06-bilinear.webm\n+f6235f937552e11d8eb331ec55da6b3aa596b9ac *vp90-2-06-bilinear.webm.md5\n+0c83a1e414fde3bccd6dc451bbaee68e59974c76 *vp90-2-07-frame_parallel.webm\n+e5c2c9fb383e5bf3b563480adaeba5b7e3475ecd *vp90-2-07-frame_parallel.webm.md5\n+086c7edcffd699ae7d99d710fd7e53b18910ca5b *vp90-2-08-tile_1x2_frame_parallel.webm\n+e981ecaabb29a80e0cbc1f4002384965ce8e95bb *vp90-2-08-tile_1x2_frame_parallel.webm.md5\n+ed79be026a6f28646c5825da1c12d1fbc70f96a4 *vp90-2-08-tile_1x2.webm\n+45b404e025841c9750895fc1a9f6bd384fe6a315 *vp90-2-08-tile_1x2.webm.md5\n+cf8ea970c776797aae71dac8317ea926d9431cab *vp90-2-08-tile_1x4_frame_parallel.webm\n+a481fbea465010b57af5a19ebf6d4a5cfe5b9278 *vp90-2-08-tile_1x4_frame_parallel.webm.md5\n+0203ec456277a01aec401e7fb6c72c9a7e5e3f9d *vp90-2-08-tile_1x4.webm\n+c9b237dfcc01c1b414fbcaa481d014a906ef7998 *vp90-2-08-tile_1x4.webm.md5\n+20c75157e91ab41f82f70ffa73d5d01df8469287 *vp90-2-08-tile-4x4.webm\n+ae7451810247fd13975cc257aa0301ff17102255 *vp90-2-08-tile-4x4.webm.md5\n+2ec6e15422ac7a61af072dc5f27fcaf1942ce116 *vp90-2-08-tile-4x1.webm\n+0094f5ee5e46345017c30e0aa4835b550212d853 *vp90-2-08-tile-4x1.webm.md5\n+edea45dac4a3c2e5372339f8851d24c9bef803d6 *vp90-2-09-subpixel-00.ivf\n+5428efc4bf92191faedf4a727fcd1d94966a7abc *vp90-2-09-subpixel-00.ivf.md5\n+8cdd435d89029987ee196896e21520e5f879f04d *vp90-2-bbb_1280x720_tile_1x4_1310kbps.webm\n+091b373aa2ecb59aa5c647affd5bcafcc7547364 *vp90-2-bbb_1920x1080_tile_1x1_2581kbps.webm\n+87ee28032b0963a44b73a850fcc816a6dc83efbb *vp90-2-bbb_1920x1080_tile_1x4_2586kbps.webm\n+c6ce25c4bfd4bdfc2932b70428e3dfe11210ec4f *vp90-2-bbb_1920x1080_tile_1x4_fpm_2304kbps.webm\n+2064bdb22aa71c2691e0469fb62e8087a43f08f8 *vp90-2-bbb_426x240_tile_1x1_180kbps.webm\n+8080eda22694910162f0996e8a962612f381a57f *vp90-2-bbb_640x360_tile_1x2_337kbps.webm\n+a484b335c27ea189c0f0d77babea4a510ce12d50 *vp90-2-bbb_854x480_tile_1x2_651kbps.webm\n+3eacf1f006250be4cc5c92a7ef146e385ee62653 *vp90-2-sintel_1280x546_tile_1x4_1257kbps.webm\n+217f089a16447490823127b36ce0d945522accfd *vp90-2-sintel_1920x818_tile_1x4_fpm_2279kbps.webm\n+eedb3c641e60dacbe082491a16df529a5c9187df *vp90-2-sintel_426x182_tile_1x1_171kbps.webm\n+cb7e4955af183dff33bcba0c837f0922ab066400 *vp90-2-sintel_640x272_tile_1x2_318kbps.webm\n+48613f9380e2580002f8a09d6e412ea4e89a52b9 *vp90-2-sintel_854x364_tile_1x2_621kbps.webm\n+990a91f24dd284562d21d714ae773dff5452cad8 *vp90-2-tos_1280x534_tile_1x4_1306kbps.webm\n+aa402217577a659cfc670157735b4b8e9aa670fe *vp90-2-tos_1280x534_tile_1x4_fpm_952kbps.webm\n+b6dd558c90bca466b4bcbd03b3371648186465a7 *vp90-2-tos_1920x800_tile_1x4_fpm_2335kbps.webm\n+1a9c2914ba932a38f0a143efc1ad0e318e78888b *vp90-2-tos_426x178_tile_1x1_181kbps.webm\n+a3d2b09f24debad4747a1b3066f572be4273bced *vp90-2-tos_640x266_tile_1x2_336kbps.webm\n+c64b03b5c090e6888cb39685c31f00a6b79fa45c *vp90-2-tos_854x356_tile_1x2_656kbps.webm\n+94b533dbcf94292001e27cc51fec87f9e8c90c0b *vp90-2-tos_854x356_tile_1x2_fpm_546kbps.webm\n+0e7cd4135b231c9cea8d76c19f9e84b6fd77acec *vp90-2-08-tile_1x8_frame_parallel.webm\n+c9b6850af28579b031791066457f4cb40df6e1c7 *vp90-2-08-tile_1x8_frame_parallel.webm.md5\n+e448b6e83490bca0f8d58b4f4b1126a17baf4b0c *vp90-2-08-tile_1x8.webm\n+5e524165f0397e6141d914f4f0a66267d7658376 *vp90-2-08-tile_1x8.webm.md5\n+a34e14923d6d17b1144254d8187d7f85b700a63c *vp90-2-02-size-lf-1920x1080.webm\n+e3b28ddcfaeb37fb4d132b93f92642a9ad17c22d *vp90-2-02-size-lf-1920x1080.webm.md5\n+d48c5db1b0f8e60521a7c749696b8067886033a3 *vp90-2-09-aq2.webm\n+84c1599298aac78f2fc05ae2274575d10569dfa0 *vp90-2-09-aq2.webm.md5\n+55fc55ed73d578ed60fad05692579873f8bad758 *vp90-2-09-lf_deltas.webm\n+54638c38009198c38c8f3b25c182b709b6c1fd2e *vp90-2-09-lf_deltas.webm.md5\n+510d95f3beb3b51c572611fdaeeece12277dac30 *vp90-2-10-show-existing-frame.webm\n+14d631096f4bfa2d71f7f739aec1448fb3c33bad *vp90-2-10-show-existing-frame.webm.md5\n+d2feea7728e8d2c615981d0f47427a4a5a45d881 *vp90-2-10-show-existing-frame2.webm\n+5f7c7811baa3e4f03be1dd78c33971b727846821 *vp90-2-10-show-existing-frame2.webm.md5\n+b4318e75f73a6a08992c7326de2fb589c2a794c7 *vp90-2-11-size-351x287.webm\n+b3c48382cf7d0454e83a02497c229d27720f9e20 *vp90-2-11-size-351x287.webm.md5\n+8e0096475ea2535bac71d3e2fc09e0c451c444df *vp90-2-11-size-351x288.webm\n+19e003804ec1dfc5464813b32339a15d5ba7b42f *vp90-2-11-size-351x288.webm.md5\n+40cd1d6a188d7a88b21ebac1e573d3f270ab261e *vp90-2-11-size-352x287.webm\n+68f515abe3858fc1eded46c8e6b2f727d43b5331 *vp90-2-11-size-352x287.webm.md5\n+9a510769ff23db410880ec3029d433e87d17f7fc *vp90-2-12-droppable_1.ivf\n+952eaac6eefa6f62179ed1db3e922fd42fecc624 *vp90-2-12-droppable_1.ivf.md5\n+9a510769ff23db410880ec3029d433e87d17f7fc *vp90-2-12-droppable_2.ivf\n+92a756469fa438220524e7fa6ac1d38c89514d17 *vp90-2-12-droppable_2.ivf.md5\n+c21e97e4ba486520118d78b01a5cb6e6dc33e190 *vp90-2-12-droppable_3.ivf\n+601abc9e4176c70f82ac0381365e9b151fdd24cd *vp90-2-12-droppable_3.ivf.md5\n+61c640dad23cd4f7ad811b867e7b7e3521f4e3ba *vp90-2-13-largescaling.webm\n+bca1b02eebdb088fa3f389fe0e7571e75a71f523 *vp90-2-13-largescaling.webm.md5\n+c740708fa390806eebaf669909c1285ab464f886 *vp90-2-14-resize-fp-tiles-1-2.webm\n+c7b85ffd8e11500f73f52e7dc5a47f57c393d47f *vp90-2-14-resize-fp-tiles-1-2.webm.md5\n+ec8faa352a08f7033c60f29f80d505e2d7daa103 *vp90-2-14-resize-fp-tiles-1-4.webm\n+6852c783fb421bda5ded3d4c5a3ffc46de03fbc1 *vp90-2-14-resize-fp-tiles-1-4.webm.md5\n+8af61853ac0d07c4cb5bf7c2016661ba350b3497 *vp90-2-14-resize-fp-tiles-1-8.webm\n+571353bac89fea60b5706073409aa3c0d42aefe9 *vp90-2-14-resize-fp-tiles-1-8.webm.md5\n+b1c187ed69931496b82ec194017a79831bafceef *vp90-2-14-resize-fp-tiles-1-16.webm\n+1c199a41afe42ce303944d70089eaaa2263b4a09 *vp90-2-14-resize-fp-tiles-1-16.webm.md5\n+8eaae5a6f2dff934610b0c7a917d7f583ba74aa5 *vp90-2-14-resize-fp-tiles-2-1.webm\n+db18fcf915f7ffaea6c39feab8bda6c1688af011 *vp90-2-14-resize-fp-tiles-2-1.webm.md5\n+bc3046d138941e2a20e9ceec0ff6d25c25d12af3 *vp90-2-14-resize-fp-tiles-4-1.webm\n+393211b808030d09a79927b17a4374b2f68a60ae *vp90-2-14-resize-fp-tiles-4-1.webm.md5\n+6e8f8e31721a0f7f68a2964e36e0e698c2e276b1 *vp90-2-14-resize-fp-tiles-8-1.webm\n+491fd3cd78fb0577bfe905bb64bbf64bd7d29140 *vp90-2-14-resize-fp-tiles-8-1.webm.md5\n+cc5958da2a7edf739cd2cfeb18bd05e77903087e *vp90-2-14-resize-fp-tiles-16-1.webm\n+0b58daf55aaf9063bf5b4fb33393d18b417dc428 *vp90-2-14-resize-fp-tiles-16-1.webm.md5\n+821eeecc9d8c6a316134dd42d1ff057787d8047b *vp90-2-14-resize-fp-tiles-2-4.webm\n+374c549f2839a3d0b732c4e3650700144037e76c *vp90-2-14-resize-fp-tiles-2-4.webm.md5\n+dff8c8e49aacea9f4c7f22cb882da984e2a1b405 *vp90-2-14-resize-fp-tiles-2-8.webm\n+e5b8820a7c823b21297d6e889e57ec401882c210 *vp90-2-14-resize-fp-tiles-2-8.webm.md5\n+77629e4b23e32896aadf6e994c78bd4ffa1c7797 *vp90-2-14-resize-fp-tiles-2-16.webm\n+1937f5df032664ac345d4613ad4417b4967b1230 *vp90-2-14-resize-fp-tiles-2-16.webm.md5\n+380ba5702bb1ec7947697314ab0300b5c56a1665 *vp90-2-14-resize-fp-tiles-4-2.webm\n+fde7b30d2aa64c1e851a4852f655d79fc542cf66 *vp90-2-14-resize-fp-tiles-4-2.webm.md5\n+dc784b258ffa2abc2ae693d11792acf0bb9cb74f *vp90-2-14-resize-fp-tiles-8-2.webm\n+edf26f0130aeee8342d49c2c8f0793ad008782d9 *vp90-2-14-resize-fp-tiles-8-2.webm.md5\n+8e575789fd63ebf69e8eff1b9a4351a249a73bee *vp90-2-14-resize-fp-tiles-16-2.webm\n+b6415318c1c589a1f64b9d569ce3cabbec2e0d52 *vp90-2-14-resize-fp-tiles-16-2.webm.md5\n+e3adc944a11c4c5517e63664c84ebb0847b64d81 *vp90-2-14-resize-fp-tiles-4-8.webm\n+03cba0532bc90a05b1990db830bf5701e24e7982 *vp90-2-14-resize-fp-tiles-4-8.webm.md5\n+3b27a991eb6d78dce38efab35b7db682e8cbbee3 *vp90-2-14-resize-fp-tiles-4-16.webm\n+5d16b7f82bf59f802724ddfd97abb487150b1c9d *vp90-2-14-resize-fp-tiles-4-16.webm.md5\n+d5fed8c28c1d4c7e232ebbd25cf758757313ed96 *vp90-2-14-resize-fp-tiles-8-4.webm\n+5a8ff8a52cbbde7bfab569beb6d971c5f8b904f7 *vp90-2-14-resize-fp-tiles-8-4.webm.md5\n+17a5faa023d77ee9dad423a4e0d3145796bbc500 *vp90-2-14-resize-fp-tiles-16-4.webm\n+2ef8daa3c3e750fd745130d0a76a39fe86f0448f *vp90-2-14-resize-fp-tiles-16-4.webm.md5\n+9361e031f5cc990d8740863e310abb5167ae351e *vp90-2-14-resize-fp-tiles-8-16.webm\n+57f13a2197486584f4e1a4f82ad969f3abc5a1a2 *vp90-2-14-resize-fp-tiles-8-16.webm.md5\n+5803fc6fcbfb47b7661f3fcc6499158a32b56675 *vp90-2-14-resize-fp-tiles-16-8.webm\n+be0fe64a1a4933696ff92d93f9bdecdbd886dc13 *vp90-2-14-resize-fp-tiles-16-8.webm.md5\n+0ac0f6d20a0afed77f742a3b9acb59fd7b9cb093 *vp90-2-14-resize-fp-tiles-1-2-4-8-16.webm\n+1765315acccfe6cd12230e731369fcb15325ebfa *vp90-2-14-resize-fp-tiles-1-2-4-8-16.webm.md5\n+4a2b7a683576fe8e330c7d1c4f098ff4e70a43a8 *vp90-2-14-resize-fp-tiles-16-8-4-2-1.webm\n+1ef480392112b3509cb190afbb96f9a38dd9fbac *vp90-2-14-resize-fp-tiles-16-8-4-2-1.webm.md5\n+e615575ded499ea1d992f3b38e3baa434509cdcd *vp90-2-15-segkey.webm\n+e3ab35d4316c5e81325c50f5236ceca4bc0d35df *vp90-2-15-segkey.webm.md5\n+9b7ca2cac09d34c4a5d296c1900f93b1e2f69d0d *vp90-2-15-segkey_adpq.webm\n+8f46ba5f785d0c2170591a153e0d0d146a7c8090 *vp90-2-15-segkey_adpq.webm.md5\n+698a6910a97486b833073ef0c0b18d75dce57ee8 *vp90-2-16-intra-only.webm\n+5661b0168752969f055eec37b05fa9fa947dc7eb *vp90-2-16-intra-only.webm.md5\n+c01bb7938f9a9f25e0c37afdec2f2fb73b6cc7fa *vp90-2-17-show-existing-frame.webm\n+cc75f351818b9a619818f5cc77b9bc013d0c1e11 *vp90-2-17-show-existing-frame.webm.md5\n+013708bd043f0821a3e56fb8404d82e7a0c7af6c *vp91-2-04-yuv422.webm\n+1e58a7d23adad830a672f1733c9d2ae17890d59c *vp91-2-04-yuv422.webm.md5\n+25d78f28948789d159a9453ebc13048b818251b1 *vp91-2-04-yuv440.webm\n+81b3870b27a7f695ef6a43e87ab04bbdb5aee2f5 *vp91-2-04-yuv440.webm.md5\n+0321d507ce62dedc8a51b4e9011f7a19aed9c3dc *vp91-2-04-yuv444.webm\n+367e423dd41fdb49aa028574a2cfec5c2f325c5c *vp91-2-04-yuv444.webm.md5\n+f77673b566f686853adefe0c578ad251b7241281 *vp92-2-20-10bit-yuv420.webm\n+abdedfaddacbbe1a15ac7a54e86360f03629fb7a *vp92-2-20-10bit-yuv420.webm.md5\n+0c2c355a1b17b28537c5a3b19997c8783b69f1af *vp92-2-20-12bit-yuv420.webm\n+afb2c2798703e039189b0a15c8ac5685aa51d33f *vp92-2-20-12bit-yuv420.webm.md5\n+0d661bc6e83da33238981481efd1b1802d323d88 *vp93-2-20-10bit-yuv422.webm\n+10318907063db22eb02fad332556edbbecd443cc *vp93-2-20-10bit-yuv422.webm.md5\n+ebc6be2f7511a0bdeac0b18c67f84ba7168839c7 *vp93-2-20-12bit-yuv422.webm\n+235232267c6a1dc8a11e45d600f1c99d2f8b42d4 *vp93-2-20-12bit-yuv422.webm.md5\n+f76b11b26d4beaceac7a7e7729dd5054d095164f *vp93-2-20-10bit-yuv440.webm\n+757b33b5ac969c5999999488a731a3d1e6d9fb88 *vp93-2-20-10bit-yuv440.webm.md5\n+df8807dbd29bec795c2db9c3c18e511fbb988101 *vp93-2-20-12bit-yuv440.webm\n+ea4100930c3f59a1c23fbb33ab0ea01151cae159 *vp93-2-20-12bit-yuv440.webm.md5\n+189c1b5f404ff41a50a7fc96341085ad541314a9 *vp93-2-20-10bit-yuv444.webm\n+2dd0177c2f9d970b6e698892634c653630f91f40 *vp93-2-20-10bit-yuv444.webm.md5\n+bd44cf6e1c27343e3639df9ac21346aedd5d6973 *vp93-2-20-12bit-yuv444.webm\n+f36e5bdf5ec3213f32c0ddc82f95d82c5133bf27 *vp93-2-20-12bit-yuv444.webm.md5\n+eb438c6540eb429f74404eedfa3228d409c57874 *desktop_640_360_30.yuv\n+89e70ebd22c27d275fe14dc2f1a41841a6d8b9ab *kirland_640_480_30.yuv\n+33c533192759e5bb4f07abfbac389dc259db4686 *macmarcomoving_640_480_30.yuv\n+8bfaab121080821b8f03b23467911e59ec59b8fe *macmarcostationary_640_480_30.yuv\n+70894878d916a599842d9ad0dcd24e10c13e5467 *niklas_640_480_30.yuv\n+8784b6df2d8cc946195a90ac00540500d2e522e4 *tacomanarrows_640_480_30.yuv\n+edd86a1f5e62fd9da9a9d46078247759c2638009 *tacomasmallcameramovement_640_480_30.yuv\n+9a70e8b7d14fba9234d0e51dce876635413ce444 *thaloundeskmtg_640_480_30.yuv\n+e7d315dbf4f3928779e0dc624311196d44491d32 *niklas_1280_720_30.yuv\n+c77e4a26616add298a05dd5d12397be22c0e40c5 *vp90-2-18-resize.ivf\n+c12918cf0a716417fba2de35c3fc5ab90e52dfce *vp90-2-18-resize.ivf.md5\n+717da707afcaa1f692ff1946f291054eb75a4f06 *screendata.y4m\n+b7c1296630cdf1a7ef493d15ff4f9eb2999202f6 *invalid-vp90-2-08-tile_1x2_frame_parallel.webm.ivf.s47039_r01-05_b6-.ivf\n+0a3884edb3fd8f9d9b500223e650f7de257b67d8 *invalid-vp90-2-08-tile_1x2_frame_parallel.webm.ivf.s47039_r01-05_b6-.ivf.res\n+359e138dfb66863828397b77000ea7a83c844d02 *invalid-vp90-2-08-tile_1x8_frame_parallel.webm.ivf.s288_r01-05_b6-.ivf\n+bbd33de01c17b165b4ce00308e8a19a942023ab8 *invalid-vp90-2-08-tile_1x8_frame_parallel.webm.ivf.s288_r01-05_b6-.ivf.res\n+fac89b5735be8a86b0dc05159f996a5c3208ae32 *invalid-vp90-2-09-aq2.webm.ivf.s3984_r01-05_b6-.v2.ivf\n+0a3884edb3fd8f9d9b500223e650f7de257b67d8 *invalid-vp90-2-09-aq2.webm.ivf.s3984_r01-05_b6-.v2.ivf.res\n+4506dfdcdf8ee4250924b075a0dcf1f070f72e5a *invalid-vp90-2-09-subpixel-00.ivf.s19552_r01-05_b6-.v2.ivf\n+bcdedaf168ac225575468fda77502d2dc9fd5baa *invalid-vp90-2-09-subpixel-00.ivf.s19552_r01-05_b6-.v2.ivf.res\n+65e93f9653bcf65b022f7d225268d1a90a76e7bb *vp90-2-19-skip.webm\n+368dccdde5288c13c25695d2eacdc7402cadf613 *vp90-2-19-skip.webm.md5\n+ffe460282df2b0e7d4603c2158653ad96f574b02 *vp90-2-19-skip-01.webm\n+bd21bc9eda4a4a36b221d71ede3a139fc3c7bd85 *vp90-2-19-skip-01.webm.md5\n+178f5bd239e38cc1cc2657a7a5e1a9f52ad2d3fe *vp90-2-19-skip-02.webm\n+9020d5e260bd7df08e2b3d4b86f8623cee3daea2 *vp90-2-19-skip-02.webm.md5\n+b03c408cf23158638da18dbc3323b99a1635c68a *invalid-vp90-2-12-droppable_1.ivf.s3676_r01-05_b6-.ivf\n+0a3884edb3fd8f9d9b500223e650f7de257b67d8 *invalid-vp90-2-12-droppable_1.ivf.s3676_r01-05_b6-.ivf.res\n+5e67e24e7f53fd189e565513cef8519b1bd6c712 *invalid-vp90-2-05-resize.ivf.s59293_r01-05_b6-.ivf\n+741158f67c0d9d23726624d06bdc482ad368afc9 *invalid-vp90-2-05-resize.ivf.s59293_r01-05_b6-.ivf.res\n+8b1f7bf7e86c0976d277f60e8fcd9539e75a079a *invalid-vp90-2-09-subpixel-00.ivf.s20492_r01-05_b6-.v2.ivf\n+9c6bdf048fb2e66f07d4b4db5b32e6f303bd6109 *invalid-vp90-2-09-subpixel-00.ivf.s20492_r01-05_b6-.v2.ivf.res\n+552e372e9b78127389fb06b34545df2cec15ba6d *invalid-vp91-2-mixedrefcsp-444to420.ivf\n+a61774cf03fc584bd9f0904fc145253bb8ea6c4c *invalid-vp91-2-mixedrefcsp-444to420.ivf.res\n+812d05a64a0d83c1b504d0519927ddc5a2cdb273 *invalid-vp90-2-12-droppable_1.ivf.s73804_r01-05_b6-.ivf\n+1e472baaf5f6113459f0399a38a5a5e68d17799d *invalid-vp90-2-12-droppable_1.ivf.s73804_r01-05_b6-.ivf.res\n+f97088c7359fc8d3d5aa5eafe57bc7308b3ee124 *vp90-2-20-big_superframe-01.webm\n+47d7d409785afa33b123376de0c907336e6c7bd7 *vp90-2-20-big_superframe-01.webm.md5\n+65ade6d2786209582c50d34cfe22b3cdb033abaf *vp90-2-20-big_superframe-02.webm\n+7c0ed8d04c4d06c5411dd2e5de2411d37f092db5 *vp90-2-20-big_superframe-02.webm.md5\n+667ec8718c982aef6be07eb94f083c2efb9d2d16 *vp90-2-07-frame_parallel-1.webm\n+bfc82bf848e9c05020d61e3ffc1e62f25df81d19 *vp90-2-07-frame_parallel-1.webm.md5\n+efd5a51d175cfdacd169ed23477729dc558030dc *invalid-vp90-2-07-frame_parallel-1.webm\n+9f912712ec418be69adb910e2ca886a63c4cec08 *invalid-vp90-2-07-frame_parallel-2.webm\n+445f5a53ca9555341852997ccdd480a51540bd14 *invalid-vp90-2-07-frame_parallel-3.webm\n+d18c90709a0d03c82beadf10898b27d88fff719c *invalid-vp90-2-03-size-224x196.webm.ivf.s44156_r01-05_b6-.ivf\n+d06285d109ecbaef63b0cbcc44d70a129186f51c *invalid-vp90-2-03-size-224x196.webm.ivf.s44156_r01-05_b6-.ivf.res\n+e60d859b0ef2b331b21740cf6cb83fabe469b079 *invalid-vp90-2-03-size-202x210.webm.ivf.s113306_r01-05_b6-.ivf\n+0ae808dca4d3c1152a9576e14830b6faa39f1b4a *invalid-vp90-2-03-size-202x210.webm.ivf.s113306_r01-05_b6-.ivf.res\n+9cfc855459e7549fd015c79e8eca512b2f2cb7e3 *niklas_1280_720_30.y4m\n""}<_**next**_>{""filename"": ""libvpx/test/test.mk"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/test.mk"", ""patch"": ""@@ -15,49 +15,75 @@\n\n ##\n ## Black box tests only use the public API.\n ##\n-LIBVPX_TEST_SRCS-$(CONFIG_DECODERS)    += ../md5_utils.h ../md5_utils.c\n+LIBVPX_TEST_SRCS-yes                   += ../md5_utils.h ../md5_utils.c\n LIBVPX_TEST_SRCS-$(CONFIG_DECODERS)    += ivf_video_source.h\n LIBVPX_TEST_SRCS-$(CONFIG_ENCODERS)    += ../y4minput.h ../y4minput.c\n LIBVPX_TEST_SRCS-$(CONFIG_ENCODERS)    += aq_segment_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_ENCODERS)    += datarate_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_ENCODERS)    += error_resilience_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_ENCODERS)    += i420_video_source.h\n+LIBVPX_TEST_SRCS-$(CONFIG_ENCODERS)    += resize_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_ENCODERS)    += y4m_video_source.h\n+LIBVPX_TEST_SRCS-$(CONFIG_ENCODERS)    += yuv_video_source.h\n \n LIBVPX_TEST_SRCS-$(CONFIG_VP8_ENCODER) += altref_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP8_ENCODER) += config_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP8_ENCODER) += cq_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP8_ENCODER) += keyframe_test.cc\n \n+LIBVPX_TEST_SRCS-$(CONFIG_VP9_DECODER) += byte_alignment_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP9_DECODER) += external_frame_buffer_test.cc\n+LIBVPX_TEST_SRCS-$(CONFIG_VP9_DECODER) += invalid_file_test.cc\n+LIBVPX_TEST_SRCS-$(CONFIG_VP9_DECODER) += user_priv_test.cc\n+LIBVPX_TEST_SRCS-$(CONFIG_VP9_DECODER) += vp9_frame_parallel_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += active_map_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += borders_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += cpu_speed_test.cc\n-LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += resize_test.cc\n+LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += frame_size_tests.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += vp9_lossless_test.cc\n+LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += vp9_end_to_end_test.cc\n+LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += vp9_ethread_test.cc\n \n LIBVPX_TEST_SRCS-yes                   += decode_test_driver.cc\n LIBVPX_TEST_SRCS-yes                   += decode_test_driver.h\n-LIBVPX_TEST_SRCS-yes                   += encode_test_driver.cc\n+LIBVPX_TEST_SRCS-$(CONFIG_ENCODERS)    += encode_test_driver.cc\n LIBVPX_TEST_SRCS-yes                   += encode_test_driver.h\n \n-## WebM Parsing\n-NESTEGG_SRCS                           += ../third_party/nestegg/halloc/halloc.h\n-NESTEGG_SRCS                           += ../third_party/nestegg/halloc/src/align.h\n-NESTEGG_SRCS                           += ../third_party/nestegg/halloc/src/halloc.c\n-NESTEGG_SRCS                           += ../third_party/nestegg/halloc/src/hlist.h\n-NESTEGG_SRCS                           += ../third_party/nestegg/include/nestegg/nestegg.h\n-NESTEGG_SRCS                           += ../third_party/nestegg/src/nestegg.c\n-LIBVPX_TEST_SRCS-$(CONFIG_DECODERS)    += $(NESTEGG_SRCS)\n-LIBVPX_TEST_SRCS-$(CONFIG_DECODERS)    += webm_video_source.h\n+## IVF writing.\n+LIBVPX_TEST_SRCS-$(CONFIG_ENCODERS)    += ../ivfenc.c ../ivfenc.h\n \n+## Y4m parsing.\n+LIBVPX_TEST_SRCS-$(CONFIG_ENCODERS)    += y4m_test.cc ../y4menc.c ../y4menc.h\n+\n+## WebM Parsing\n+ifeq ($(CONFIG_WEBM_IO), yes)\n+LIBWEBM_PARSER_SRCS                    += ../third_party/libwebm/mkvparser.cpp\n+LIBWEBM_PARSER_SRCS                    += ../third_party/libwebm/mkvreader.cpp\n+LIBWEBM_PARSER_SRCS                    += ../third_party/libwebm/mkvparser.hpp\n+LIBWEBM_PARSER_SRCS                    += ../third_party/libwebm/mkvreader.hpp\n+LIBVPX_TEST_SRCS-$(CONFIG_DECODERS)    += $(LIBWEBM_PARSER_SRCS)\n+LIBVPX_TEST_SRCS-$(CONFIG_DECODERS)    += ../tools_common.h\n+LIBVPX_TEST_SRCS-$(CONFIG_DECODERS)    += ../webmdec.cc\n+LIBVPX_TEST_SRCS-$(CONFIG_DECODERS)    += ../webmdec.h\n+LIBVPX_TEST_SRCS-$(CONFIG_DECODERS)    += webm_video_source.h\n+LIBVPX_TEST_SRCS-$(CONFIG_VP9_DECODER) += vp9_skip_loopfilter_test.cc\n+endif\n+\n+LIBVPX_TEST_SRCS-$(CONFIG_DECODERS)    += decode_api_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_DECODERS)    += test_vector_test.cc\n \n-# Currently we only support decoder perf tests for vp9\n-ifeq ($(CONFIG_DECODE_PERF_TESTS)$(CONFIG_VP9_DECODER), yesyes)\n+# Currently we only support decoder perf tests for vp9. Also they read from WebM\n+# files, so WebM IO is required.\n+ifeq ($(CONFIG_DECODE_PERF_TESTS)$(CONFIG_VP9_DECODER)$(CONFIG_WEBM_IO), \\\n+      yesyesyes)\n LIBVPX_TEST_SRCS-yes                   += decode_perf_test.cc\n endif\n \n+# encode perf tests are vp9 only\n+ifeq ($(CONFIG_ENCODE_PERF_TESTS)$(CONFIG_VP9_ENCODER), yesyes)\n+LIBVPX_TEST_SRCS-yes += encode_perf_test.cc\n+endif\n+\n ##\n ## WHITE BOX TESTS\n ##\n@@ -65,6 +91,7 @@\n\n ## shared library builds don't make these functions accessible.\n ##\n ifeq ($(CONFIG_SHARED),)\n+LIBVPX_TEST_SRCS-$(CONFIG_VP9)         += lpf_8_test.cc\n \n ## VP8\n ifneq ($(CONFIG_VP8_ENCODER)$(CONFIG_VP8_DECODER),)\n@@ -72,18 +99,24 @@\n\n # These tests require both the encoder and decoder to be built.\n ifeq ($(CONFIG_VP8_ENCODER)$(CONFIG_VP8_DECODER),yesyes)\n LIBVPX_TEST_SRCS-yes                   += vp8_boolcoder_test.cc\n+LIBVPX_TEST_SRCS-yes                   += vp8_fragments_test.cc\n endif\n \n LIBVPX_TEST_SRCS-$(CONFIG_POSTPROC)    += pp_filter_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP8_DECODER) += vp8_decrypt_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP8_ENCODER) += set_roi.cc\n-LIBVPX_TEST_SRCS-$(CONFIG_VP8_ENCODER) += subtract_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP8_ENCODER) += variance_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP8_ENCODER) += vp8_fdct4x4_test.cc\n+LIBVPX_TEST_SRCS-$(CONFIG_VP8_ENCODER) += quantize_test.cc\n \n LIBVPX_TEST_SRCS-yes                   += idct_test.cc\n LIBVPX_TEST_SRCS-yes                   += intrapred_test.cc\n LIBVPX_TEST_SRCS-yes                   += sixtap_predict_test.cc\n+LIBVPX_TEST_SRCS-yes                   += vpx_scale_test.cc\n+\n+ifeq ($(CONFIG_VP8_ENCODER)$(CONFIG_TEMPORAL_DENOISING),yesyes)\n+LIBVPX_TEST_SRCS-$(HAVE_SSE2) += vp8_denoiser_sse2_test.cc\n+endif\n \n endif # VP8\n \n@@ -98,687 +131,42 @@\n\n LIBVPX_TEST_SRCS-yes                   += superframe_test.cc\n LIBVPX_TEST_SRCS-yes                   += tile_independence_test.cc\n LIBVPX_TEST_SRCS-yes                   += vp9_boolcoder_test.cc\n-\n+LIBVPX_TEST_SRCS-yes                   += vp9_encoder_parms_get_to_decoder.cc\n endif\n \n LIBVPX_TEST_SRCS-$(CONFIG_VP9)         += convolve_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP9_DECODER) += vp9_thread_test.cc\n+LIBVPX_TEST_SRCS-$(CONFIG_VP9_DECODER) += vp9_decrypt_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += dct16x16_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += dct32x32_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += fdct4x4_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += fdct8x8_test.cc\n-LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += svc_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += variance_test.cc\n LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += vp9_subtract_test.cc\n+LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += vp9_avg_test.cc\n+LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += vp9_error_block_test.cc\n+LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += vp9_quantize_test.cc\n+LIBVPX_TEST_SRCS-$(CONFIG_VP9)         += vp9_intrapred_test.cc\n+\n+ifeq ($(CONFIG_VP9_ENCODER),yes)\n+LIBVPX_TEST_SRCS-$(CONFIG_SPATIAL_SVC) += svc_test.cc\n+LIBVPX_TEST_SRCS-$(CONFIG_INTERNAL_STATS) += blockiness_test.cc\n+LIBVPX_TEST_SRCS-$(CONFIG_INTERNAL_STATS) += consistency_test.cc\n+\n+endif\n+\n+ifeq ($(CONFIG_VP9_ENCODER)$(CONFIG_VP9_TEMPORAL_DENOISING),yesyes)\n+LIBVPX_TEST_SRCS-$(HAVE_SSE2) += vp9_denoiser_sse2_test.cc\n+endif\n+LIBVPX_TEST_SRCS-$(CONFIG_VP9_ENCODER) += vp9_arf_freq_test.cc\n \n endif # VP9\n \n LIBVPX_TEST_SRCS-$(CONFIG_ENCODERS)    += sad_test.cc\n \n+TEST_INTRA_PRED_SPEED_SRCS-$(CONFIG_VP9) := test_intra_pred_speed.cc\n+TEST_INTRA_PRED_SPEED_SRCS-$(CONFIG_VP9) += ../md5_utils.h ../md5_utils.c\n+\n endif # CONFIG_SHARED\n \n-\n-##\n-## TEST DATA\n-##\n-LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += hantro_collage_w352h288.yuv\n-LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += hantro_collage_w352h288.stat\n-LIBVPX_TEST_DATA-$(CONFIG_ENCODERS) += hantro_odd.yuv\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_ENCODER) += rush_hour_444.y4m\n-\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-001.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-001.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-002.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-002.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-003.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-003.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-004.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-004.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-005.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-005.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-006.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-006.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-007.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-007.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-008.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-008.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-009.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-009.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-010.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-010.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-011.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-011.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-012.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-012.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-013.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-013.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-014.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-014.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-015.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-015.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-016.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-016.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-017.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-017.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-018.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-00-comprehensive-018.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-01-intra-1400.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-01-intra-1400.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-01-intra-1411.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-01-intra-1411.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-01-intra-1416.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-01-intra-1416.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-01-intra-1417.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-01-intra-1417.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-02-inter-1402.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-02-inter-1402.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-02-inter-1412.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-02-inter-1412.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-02-inter-1418.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-02-inter-1418.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-02-inter-1424.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-02-inter-1424.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-01.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-01.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-02.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-02.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-03.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-03.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-04.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-04.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1401.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1401.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1403.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1403.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1407.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1407.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1408.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1408.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1409.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1409.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1410.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1410.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1413.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1413.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1414.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1414.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1415.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1415.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1425.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1425.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1426.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1426.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1427.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1427.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1432.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1432.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1435.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1435.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1436.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1436.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1437.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1437.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1441.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1441.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1442.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-03-segmentation-1442.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-04-partitions-1404.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-04-partitions-1404.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-04-partitions-1405.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-04-partitions-1405.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-04-partitions-1406.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-04-partitions-1406.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1428.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1428.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1429.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1429.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1430.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1430.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1431.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1431.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1433.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1433.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1434.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1434.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1438.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1438.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1439.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1439.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1440.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1440.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1443.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-05-sharpness-1443.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-06-smallsize.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP8_DECODER) += vp80-06-smallsize.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-00.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-00.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-01.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-01.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-02.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-02.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-03.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-03.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-04.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-04.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-05.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-05.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-06.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-06.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-07.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-07.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-08.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-08.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-09.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-09.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-10.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-10.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-11.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-11.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-12.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-12.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-13.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-13.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-14.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-14.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-15.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-15.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-16.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-16.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-17.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-17.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-18.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-18.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-19.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-19.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-20.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-20.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-21.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-21.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-22.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-22.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-23.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-23.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-24.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-24.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-25.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-25.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-26.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-26.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-27.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-27.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-28.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-28.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-29.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-29.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-30.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-30.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-31.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-31.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-32.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-32.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-33.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-33.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-34.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-34.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-35.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-35.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-36.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-36.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-37.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-37.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-38.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-38.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-39.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-39.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-40.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-40.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-41.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-41.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-42.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-42.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-43.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-43.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-44.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-44.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-45.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-45.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-46.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-46.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-47.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-47.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-48.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-48.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-49.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-49.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-50.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-50.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-51.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-51.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-52.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-52.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-53.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-53.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-54.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-54.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-55.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-55.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-56.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-56.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-57.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-57.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-58.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-58.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-59.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-59.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-60.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-60.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-61.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-61.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-62.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-62.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-63.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-00-quantizer-63.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-1.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-1.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-2.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-2.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-3.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-3.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-4.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-4.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-5.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-5.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-6.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-6.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-7.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-01-sharpness-7.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x08.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x08.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x10.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x10.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x16.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x16.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x18.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x18.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x32.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x32.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x34.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x34.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x64.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x64.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x66.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-08x66.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x08.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x08.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x10.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x10.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x16.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x16.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x18.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x18.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x32.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x32.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x34.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x34.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x64.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x64.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x66.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-10x66.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x08.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x08.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x10.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x10.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x16.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x16.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x18.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x18.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x32.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x32.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x34.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x34.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x64.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x64.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x66.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-16x66.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x08.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x08.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x10.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x10.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x16.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x16.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x18.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x18.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x32.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x32.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x34.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x34.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x64.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x64.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x66.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-18x66.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x08.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x08.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x10.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x10.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x16.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x16.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x18.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x18.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x32.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x32.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x34.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x34.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x64.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x64.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x66.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-32x66.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x08.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x08.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x10.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x10.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x16.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x16.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x18.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x18.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x32.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x32.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x34.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x34.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x64.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x64.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x66.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-34x66.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x08.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x08.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x10.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x10.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x16.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x16.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x18.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x18.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x32.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x32.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x34.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x34.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x64.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x64.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x66.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-64x66.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x08.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x08.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x10.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x10.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x16.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x16.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x18.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x18.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x32.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x32.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x34.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x34.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x64.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x64.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x66.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-66x66.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-lf-1920x1080.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-02-size-lf-1920x1080.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-deltaq.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-deltaq.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x196.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x196.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x198.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x198.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x200.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x200.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x202.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x202.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x208.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x208.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x210.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x210.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x224.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x224.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x226.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-196x226.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x196.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x196.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x198.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x198.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x200.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x200.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x202.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x202.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x208.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x208.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x210.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x210.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x224.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x224.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x226.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-198x226.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x196.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x196.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x198.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x198.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x200.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x200.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x202.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x202.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x208.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x208.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x210.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x210.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x224.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x224.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x226.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-200x226.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x196.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x196.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x198.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x198.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x200.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x200.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x202.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x202.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x208.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x208.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x210.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x210.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x224.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x224.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x226.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-202x226.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x196.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x196.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x198.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x198.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x200.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x200.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x202.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x202.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x208.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x208.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x210.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x210.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x224.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x224.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x226.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-208x226.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x196.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x196.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x198.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x198.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x200.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x200.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x202.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x202.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x208.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x208.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x210.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x210.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x224.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x224.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x226.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-210x226.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x196.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x196.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x198.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x198.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x200.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x200.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x202.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x202.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x208.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x208.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x210.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x210.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x224.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x224.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x226.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-224x226.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x196.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x196.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x198.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x198.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x200.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x200.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x202.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x202.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x208.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x208.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x210.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x210.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x224.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x224.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x226.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-03-size-226x226.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-05-resize.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-05-resize.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-06-bilinear.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-06-bilinear.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-07-frame_parallel.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-07-frame_parallel.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile-4x1.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile-4x1.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile-4x4.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile-4x4.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x2.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x2.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x2_frame_parallel.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x2_frame_parallel.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x4.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x4.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x4_frame_parallel.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x4_frame_parallel.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x8.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x8.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x8_frame_parallel.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-08-tile_1x8_frame_parallel.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-09-aq2.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-09-aq2.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-09-lf_deltas.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-09-lf_deltas.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-09-subpixel-00.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-09-subpixel-00.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-10-show-existing-frame.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-10-show-existing-frame.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-11-size-351x287.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-11-size-351x287.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-11-size-351x288.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-11-size-351x288.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-11-size-352x287.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-11-size-352x287.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-12-droppable_1.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-12-droppable_1.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-12-droppable_2.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-12-droppable_2.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-12-droppable_3.ivf\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-12-droppable_3.ivf.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-13-largescaling.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-13-largescaling.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp91-2-04-yv444.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp91-2-04-yv444.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-2.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-2.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-4.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-4.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-8.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-8.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-16.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-16.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-2-1.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-2-1.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-4-1.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-4-1.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-8-1.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-8-1.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-1.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-1.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-2-4.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-2-4.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-2-8.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-2-8.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-2-16.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-2-16.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-4-2.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-4-2.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-8-2.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-8-2.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-2.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-2.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-4-8.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-4-8.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-4-16.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-4-16.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-8-4.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-8-4.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-4.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-4.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-8-16.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-8-16.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-8.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-8.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-2-4-8-16.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-1-2-4-8-16.webm.md5\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-8-4-2-1.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += vp90-2-14-resize-fp-tiles-16-8-4-2-1.webm.md5\n-\n-ifeq ($(CONFIG_DECODE_PERF_TESTS),yes)\n-# BBB VP9 streams\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-bbb_426x240_tile_1x1_180kbps.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-bbb_640x360_tile_1x2_337kbps.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-bbb_854x480_tile_1x2_651kbps.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-bbb_1280x720_tile_1x4_1310kbps.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-bbb_1920x1080_tile_1x1_2581kbps.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-bbb_1920x1080_tile_1x4_2586kbps.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-bbb_1920x1080_tile_1x4_fpm_2304kbps.webm\n-#Sintel VP9 streams\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-sintel_426x182_tile_1x1_171kbps.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-sintel_640x272_tile_1x2_318kbps.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-sintel_854x364_tile_1x2_621kbps.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-sintel_1280x546_tile_1x4_1257kbps.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-sintel_1920x818_tile_1x4_fpm_2279kbps.webm\n-# TOS VP9 streams\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-tos_426x178_tile_1x1_181kbps.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-tos_640x266_tile_1x2_336kbps.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-tos_854x356_tile_1x2_656kbps.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-tos_1280x534_tile_1x4_1306kbps.webm\n-LIBVPX_TEST_DATA-$(CONFIG_VP9_DECODER) += \\\n-  vp90-2-tos_1920x800_tile_1x4_fpm_2335kbps.webm\n-endif  # CONFIG_DECODE_PERF_TESTS\n+include $(SRC_PATH_BARE)/test/test-data.mk\n""}<_**next**_>{""filename"": ""libvpx/test/test_intra_pred_speed.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/test_intra_pred_speed.cc"", ""patch"": ""@@ -0,0 +1,384 @@\n\n+/*\n+ *  Copyright (c) 2015 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+//  Test and time VPX intra-predictor functions\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vpx_dsp_rtcd.h\""\n+#include \""test/acm_random.h\""\n+#include \""test/clear_system_state.h\""\n+#include \""test/md5_helper.h\""\n+#include \""vpx/vpx_integer.h\""\n+#include \""vpx_ports/mem.h\""\n+#include \""vpx_ports/vpx_timer.h\""\n+\n+// -----------------------------------------------------------------------------\n+\n+namespace {\n+\n+typedef void (*VpxPredFunc)(uint8_t *dst, ptrdiff_t y_stride,\n+                            const uint8_t *above, const uint8_t *left);\n+\n+const int kNumVp9IntraPredFuncs = 13;\n+const char *kVp9IntraPredNames[kNumVp9IntraPredFuncs] = {\n+  \""DC_PRED\"", \""DC_LEFT_PRED\"", \""DC_TOP_PRED\"", \""DC_128_PRED\"", \""V_PRED\"", \""H_PRED\"",\n+  \""D45_PRED\"", \""D135_PRED\"", \""D117_PRED\"", \""D153_PRED\"", \""D207_PRED\"", \""D63_PRED\"",\n+  \""TM_PRED\""\n+};\n+\n+void TestIntraPred(const char name[], VpxPredFunc const *pred_funcs,\n+                   const char *const pred_func_names[], int num_funcs,\n+                   const char *const signatures[], int block_size,\n+                   int num_pixels_per_test) {\n+  libvpx_test::ACMRandom rnd(libvpx_test::ACMRandom::DeterministicSeed());\n+  const int kBPS = 32;\n+  const int kTotalPixels = 32 * kBPS;\n+  DECLARE_ALIGNED(16, uint8_t, src[kTotalPixels]);\n+  DECLARE_ALIGNED(16, uint8_t, ref_src[kTotalPixels]);\n+  DECLARE_ALIGNED(16, uint8_t, left[kBPS]);\n+  DECLARE_ALIGNED(16, uint8_t, above_mem[2 * kBPS + 16]);\n+  uint8_t *const above = above_mem + 16;\n+  for (int i = 0; i < kTotalPixels; ++i) ref_src[i] = rnd.Rand8();\n+  for (int i = 0; i < kBPS; ++i) left[i] = rnd.Rand8();\n+  for (int i = -1; i < kBPS; ++i) above[i] = rnd.Rand8();\n+  const int kNumTests = static_cast<int>(2.e10 / num_pixels_per_test);\n+\n+  // some code assumes the top row has been extended:\n+  // d45/d63 C-code, for instance, but not the assembly.\n+  // TODO(jzern): this style of extension isn't strictly necessary.\n+  ASSERT_LE(block_size, kBPS);\n+  memset(above + block_size, above[block_size - 1], 2 * kBPS - block_size);\n+\n+  for (int k = 0; k < num_funcs; ++k) {\n+    if (pred_funcs[k] == NULL) continue;\n+    memcpy(src, ref_src, sizeof(src));\n+    vpx_usec_timer timer;\n+    vpx_usec_timer_start(&timer);\n+    for (int num_tests = 0; num_tests < kNumTests; ++num_tests) {\n+      pred_funcs[k](src, kBPS, above, left);\n+    }\n+    libvpx_test::ClearSystemState();\n+    vpx_usec_timer_mark(&timer);\n+    const int elapsed_time =\n+        static_cast<int>(vpx_usec_timer_elapsed(&timer) / 1000);\n+    libvpx_test::MD5 md5;\n+    md5.Add(src, sizeof(src));\n+    printf(\""Mode %s[%12s]: %5d ms     MD5: %s\\n\"", name, pred_func_names[k],\n+           elapsed_time, md5.Get());\n+    EXPECT_STREQ(signatures[k], md5.Get());\n+  }\n+}\n+\n+void TestIntraPred4(VpxPredFunc const *pred_funcs) {\n+  static const int kNumVp9IntraFuncs = 13;\n+  static const char *const kSignatures[kNumVp9IntraFuncs] = {\n+    \""4334156168b34ab599d9b5b30f522fe9\"",\n+    \""bc4649d5ba47c7ff178d92e475960fb0\"",\n+    \""8d316e5933326dcac24e1064794b5d12\"",\n+    \""a27270fed024eafd762c95de85f4da51\"",\n+    \""c33dff000d4256c2b8f3bf9e9bab14d2\"",\n+    \""44d8cddc2ad8f79b8ed3306051722b4f\"",\n+    \""eb54839b2bad6699d8946f01ec041cd0\"",\n+    \""ecb0d56ae5f677ea45127ce9d5c058e4\"",\n+    \""0b7936841f6813da818275944895b574\"",\n+    \""9117972ef64f91a58ff73e1731c81db2\"",\n+    \""c56d5e8c729e46825f46dd5d3b5d508a\"",\n+    \""c0889e2039bcf7bcb5d2f33cdca69adc\"",\n+    \""309a618577b27c648f9c5ee45252bc8f\"",\n+  };\n+  TestIntraPred(\""Intra4\"", pred_funcs, kVp9IntraPredNames, kNumVp9IntraFuncs,\n+                kSignatures, 4, 4 * 4 * kNumVp9IntraFuncs);\n+}\n+\n+void TestIntraPred8(VpxPredFunc const *pred_funcs) {\n+  static const int kNumVp9IntraFuncs = 13;\n+  static const char *const kSignatures[kNumVp9IntraFuncs] = {\n+    \""7694ddeeefed887faf9d339d18850928\"",\n+    \""7d726b1213591b99f736be6dec65065b\"",\n+    \""19c5711281357a485591aaf9c96c0a67\"",\n+    \""ba6b66877a089e71cd938e3b8c40caac\"",\n+    \""802440c93317e0f8ba93fab02ef74265\"",\n+    \""9e09a47a15deb0b9d8372824f9805080\"",\n+    \""b7c2d8c662268c0c427da412d7b0311d\"",\n+    \""78339c1c60bb1d67d248ab8c4da08b7f\"",\n+    \""5c97d70f7d47de1882a6cd86c165c8a9\"",\n+    \""8182bf60688b42205acd95e59e967157\"",\n+    \""08323400005a297f16d7e57e7fe1eaac\"",\n+    \""95f7bfc262329a5849eda66d8f7c68ce\"",\n+    \""815b75c8e0d91cc1ae766dc5d3e445a3\"",\n+  };\n+  TestIntraPred(\""Intra8\"", pred_funcs, kVp9IntraPredNames, kNumVp9IntraFuncs,\n+                kSignatures, 8, 8 * 8 * kNumVp9IntraFuncs);\n+}\n+\n+void TestIntraPred16(VpxPredFunc const *pred_funcs) {\n+  static const int kNumVp9IntraFuncs = 13;\n+  static const char *const kSignatures[kNumVp9IntraFuncs] = {\n+    \""b40dbb555d5d16a043dc361e6694fe53\"",\n+    \""fb08118cee3b6405d64c1fd68be878c6\"",\n+    \""6c190f341475c837cc38c2e566b64875\"",\n+    \""db5c34ccbe2c7f595d9b08b0dc2c698c\"",\n+    \""a62cbfd153a1f0b9fed13e62b8408a7a\"",\n+    \""143df5b4c89335e281103f610f5052e4\"",\n+    \""d87feb124107cdf2cfb147655aa0bb3c\"",\n+    \""7841fae7d4d47b519322e6a03eeed9dc\"",\n+    \""f6ebed3f71cbcf8d6d0516ce87e11093\"",\n+    \""3cc480297dbfeed01a1c2d78dd03d0c5\"",\n+    \""b9f69fa6532b372c545397dcb78ef311\"",\n+    \""a8fe1c70432f09d0c20c67bdb6432c4d\"",\n+    \""b8a41aa968ec108af447af4217cba91b\"",\n+  };\n+  TestIntraPred(\""Intra16\"", pred_funcs, kVp9IntraPredNames, kNumVp9IntraFuncs,\n+                kSignatures, 16, 16 * 16 * kNumVp9IntraFuncs);\n+}\n+\n+void TestIntraPred32(VpxPredFunc const *pred_funcs) {\n+  static const int kNumVp9IntraFuncs = 13;\n+  static const char *const kSignatures[kNumVp9IntraFuncs] = {\n+    \""558541656d84f9ae7896db655826febe\"",\n+    \""b3587a1f9a01495fa38c8cd3c8e2a1bf\"",\n+    \""4c6501e64f25aacc55a2a16c7e8f0255\"",\n+    \""b3b01379ba08916ef6b1b35f7d9ad51c\"",\n+    \""0f1eb38b6cbddb3d496199ef9f329071\"",\n+    \""911c06efb9ed1c3b4c104b232b55812f\"",\n+    \""9225beb0ddfa7a1d24eaa1be430a6654\"",\n+    \""0a6d584a44f8db9aa7ade2e2fdb9fc9e\"",\n+    \""b01c9076525216925f3456f034fb6eee\"",\n+    \""d267e20ad9e5cd2915d1a47254d3d149\"",\n+    \""ed012a4a5da71f36c2393023184a0e59\"",\n+    \""f162b51ed618d28b936974cff4391da5\"",\n+    \""9e1370c6d42e08d357d9612c93a71cfc\"",\n+  };\n+  TestIntraPred(\""Intra32\"", pred_funcs, kVp9IntraPredNames, kNumVp9IntraFuncs,\n+                kSignatures, 32, 32 * 32 * kNumVp9IntraFuncs);\n+}\n+\n+}  // namespace\n+\n+// Defines a test case for |arch| (e.g., C, SSE2, ...) passing the predictors\n+// to |test_func|. The test name is 'arch.test_func', e.g., C.TestIntraPred4.\n+#define INTRA_PRED_TEST(arch, test_func, dc, dc_left, dc_top, dc_128, v, h, \\\n+                        d45, d135, d117, d153, d207, d63, tm)               \\\n+  TEST(arch, test_func) {                                                   \\\n+    static const VpxPredFunc vpx_intra_pred[] = {                           \\\n+        dc,   dc_left, dc_top, dc_128, v,   h, d45,                         \\\n+        d135, d117,    d153,   d207,   d63, tm};                            \\\n+    test_func(vpx_intra_pred);                                              \\\n+  }\n+\n+// -----------------------------------------------------------------------------\n+// 4x4\n+\n+INTRA_PRED_TEST(C, TestIntraPred4, vpx_dc_predictor_4x4_c,\n+                vpx_dc_left_predictor_4x4_c, vpx_dc_top_predictor_4x4_c,\n+                vpx_dc_128_predictor_4x4_c, vpx_v_predictor_4x4_c,\n+                vpx_h_predictor_4x4_c, vpx_d45_predictor_4x4_c,\n+                vpx_d135_predictor_4x4_c, vpx_d117_predictor_4x4_c,\n+                vpx_d153_predictor_4x4_c, vpx_d207_predictor_4x4_c,\n+                vpx_d63_predictor_4x4_c, vpx_tm_predictor_4x4_c)\n+\n+#if HAVE_SSE && CONFIG_USE_X86INC\n+INTRA_PRED_TEST(SSE, TestIntraPred4, vpx_dc_predictor_4x4_sse,\n+                vpx_dc_left_predictor_4x4_sse, vpx_dc_top_predictor_4x4_sse,\n+                vpx_dc_128_predictor_4x4_sse, vpx_v_predictor_4x4_sse, NULL,\n+                NULL, NULL, NULL, NULL, NULL, NULL, vpx_tm_predictor_4x4_sse)\n+#endif  // HAVE_SSE && CONFIG_USE_X86INC\n+\n+#if HAVE_SSSE3 && CONFIG_USE_X86INC\n+INTRA_PRED_TEST(SSSE3, TestIntraPred4, NULL, NULL, NULL, NULL, NULL,\n+                vpx_h_predictor_4x4_ssse3, vpx_d45_predictor_4x4_ssse3, NULL,\n+                NULL, vpx_d153_predictor_4x4_ssse3,\n+                vpx_d207_predictor_4x4_ssse3, vpx_d63_predictor_4x4_ssse3, NULL)\n+#endif  // HAVE_SSSE3 && CONFIG_USE_X86INC\n+\n+#if HAVE_DSPR2\n+INTRA_PRED_TEST(DSPR2, TestIntraPred4, vpx_dc_predictor_4x4_dspr2, NULL, NULL,\n+                NULL, NULL, vpx_h_predictor_4x4_dspr2, NULL, NULL, NULL, NULL,\n+                NULL, NULL, vpx_tm_predictor_4x4_dspr2)\n+#endif  // HAVE_DSPR2\n+\n+#if HAVE_NEON\n+INTRA_PRED_TEST(NEON, TestIntraPred4, vpx_dc_predictor_4x4_neon,\n+                vpx_dc_left_predictor_4x4_neon, vpx_dc_top_predictor_4x4_neon,\n+                vpx_dc_128_predictor_4x4_neon, vpx_v_predictor_4x4_neon,\n+                vpx_h_predictor_4x4_neon, vpx_d45_predictor_4x4_neon,\n+                vpx_d135_predictor_4x4_neon, NULL, NULL, NULL, NULL,\n+                vpx_tm_predictor_4x4_neon)\n+#endif  // HAVE_NEON\n+\n+#if HAVE_MSA\n+INTRA_PRED_TEST(MSA, TestIntraPred4, vpx_dc_predictor_4x4_msa,\n+                vpx_dc_left_predictor_4x4_msa, vpx_dc_top_predictor_4x4_msa,\n+                vpx_dc_128_predictor_4x4_msa, vpx_v_predictor_4x4_msa,\n+                vpx_h_predictor_4x4_msa, NULL, NULL, NULL, NULL, NULL,\n+                NULL, vpx_tm_predictor_4x4_msa)\n+#endif  // HAVE_MSA\n+\n+// -----------------------------------------------------------------------------\n+// 8x8\n+\n+INTRA_PRED_TEST(C, TestIntraPred8, vpx_dc_predictor_8x8_c,\n+                vpx_dc_left_predictor_8x8_c, vpx_dc_top_predictor_8x8_c,\n+                vpx_dc_128_predictor_8x8_c, vpx_v_predictor_8x8_c,\n+                vpx_h_predictor_8x8_c, vpx_d45_predictor_8x8_c,\n+                vpx_d135_predictor_8x8_c, vpx_d117_predictor_8x8_c,\n+                vpx_d153_predictor_8x8_c, vpx_d207_predictor_8x8_c,\n+                vpx_d63_predictor_8x8_c, vpx_tm_predictor_8x8_c)\n+\n+#if HAVE_SSE && CONFIG_USE_X86INC\n+INTRA_PRED_TEST(SSE, TestIntraPred8, vpx_dc_predictor_8x8_sse,\n+                vpx_dc_left_predictor_8x8_sse, vpx_dc_top_predictor_8x8_sse,\n+                vpx_dc_128_predictor_8x8_sse, vpx_v_predictor_8x8_sse, NULL,\n+                NULL, NULL, NULL, NULL, NULL, NULL, NULL)\n+#endif  // HAVE_SSE && CONFIG_USE_X86INC\n+\n+#if HAVE_SSE2 && CONFIG_USE_X86INC\n+INTRA_PRED_TEST(SSE2, TestIntraPred8, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n+                NULL, NULL, NULL, NULL, NULL, vpx_tm_predictor_8x8_sse2)\n+#endif  // HAVE_SSE2 && CONFIG_USE_X86INC\n+\n+#if HAVE_SSSE3 && CONFIG_USE_X86INC\n+INTRA_PRED_TEST(SSSE3, TestIntraPred8, NULL, NULL, NULL, NULL, NULL,\n+                vpx_h_predictor_8x8_ssse3, vpx_d45_predictor_8x8_ssse3, NULL,\n+                NULL, vpx_d153_predictor_8x8_ssse3,\n+                vpx_d207_predictor_8x8_ssse3, vpx_d63_predictor_8x8_ssse3, NULL)\n+#endif  // HAVE_SSSE3 && CONFIG_USE_X86INC\n+\n+#if HAVE_DSPR2\n+INTRA_PRED_TEST(DSPR2, TestIntraPred8, vpx_dc_predictor_8x8_dspr2, NULL, NULL,\n+                NULL, NULL, vpx_h_predictor_8x8_dspr2, NULL, NULL, NULL, NULL,\n+                NULL, NULL, vpx_tm_predictor_8x8_c)\n+#endif  // HAVE_DSPR2\n+\n+#if HAVE_NEON\n+INTRA_PRED_TEST(NEON, TestIntraPred8, vpx_dc_predictor_8x8_neon,\n+                vpx_dc_left_predictor_8x8_neon, vpx_dc_top_predictor_8x8_neon,\n+                vpx_dc_128_predictor_8x8_neon, vpx_v_predictor_8x8_neon,\n+                vpx_h_predictor_8x8_neon, vpx_d45_predictor_8x8_neon, NULL,\n+                NULL, NULL, NULL, NULL, vpx_tm_predictor_8x8_neon)\n+\n+#endif  // HAVE_NEON\n+\n+#if HAVE_MSA\n+INTRA_PRED_TEST(MSA, TestIntraPred8, vpx_dc_predictor_8x8_msa,\n+                vpx_dc_left_predictor_8x8_msa, vpx_dc_top_predictor_8x8_msa,\n+                vpx_dc_128_predictor_8x8_msa, vpx_v_predictor_8x8_msa,\n+                vpx_h_predictor_8x8_msa, NULL, NULL, NULL, NULL, NULL,\n+                NULL, vpx_tm_predictor_8x8_msa)\n+#endif  // HAVE_MSA\n+\n+// -----------------------------------------------------------------------------\n+// 16x16\n+\n+INTRA_PRED_TEST(C, TestIntraPred16, vpx_dc_predictor_16x16_c,\n+                vpx_dc_left_predictor_16x16_c, vpx_dc_top_predictor_16x16_c,\n+                vpx_dc_128_predictor_16x16_c, vpx_v_predictor_16x16_c,\n+                vpx_h_predictor_16x16_c, vpx_d45_predictor_16x16_c,\n+                vpx_d135_predictor_16x16_c, vpx_d117_predictor_16x16_c,\n+                vpx_d153_predictor_16x16_c, vpx_d207_predictor_16x16_c,\n+                vpx_d63_predictor_16x16_c, vpx_tm_predictor_16x16_c)\n+\n+#if HAVE_SSE2 && CONFIG_USE_X86INC\n+INTRA_PRED_TEST(SSE2, TestIntraPred16, vpx_dc_predictor_16x16_sse2,\n+                vpx_dc_left_predictor_16x16_sse2,\n+                vpx_dc_top_predictor_16x16_sse2,\n+                vpx_dc_128_predictor_16x16_sse2, vpx_v_predictor_16x16_sse2,\n+                NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n+                vpx_tm_predictor_16x16_sse2)\n+#endif  // HAVE_SSE2 && CONFIG_USE_X86INC\n+\n+#if HAVE_SSSE3 && CONFIG_USE_X86INC\n+INTRA_PRED_TEST(SSSE3, TestIntraPred16, NULL, NULL, NULL, NULL, NULL,\n+                vpx_h_predictor_16x16_ssse3, vpx_d45_predictor_16x16_ssse3,\n+                NULL, NULL, vpx_d153_predictor_16x16_ssse3,\n+                vpx_d207_predictor_16x16_ssse3, vpx_d63_predictor_16x16_ssse3,\n+                NULL)\n+#endif  // HAVE_SSSE3 && CONFIG_USE_X86INC\n+\n+#if HAVE_DSPR2\n+INTRA_PRED_TEST(DSPR2, TestIntraPred16, vpx_dc_predictor_16x16_dspr2, NULL,\n+                NULL, NULL, NULL, vpx_h_predictor_16x16_dspr2, NULL, NULL, NULL,\n+                NULL, NULL, NULL, NULL)\n+#endif  // HAVE_DSPR2\n+\n+#if HAVE_NEON\n+INTRA_PRED_TEST(NEON, TestIntraPred16, vpx_dc_predictor_16x16_neon,\n+                vpx_dc_left_predictor_16x16_neon,\n+                vpx_dc_top_predictor_16x16_neon,\n+                vpx_dc_128_predictor_16x16_neon, vpx_v_predictor_16x16_neon,\n+                vpx_h_predictor_16x16_neon, vpx_d45_predictor_16x16_neon, NULL,\n+                NULL, NULL, NULL, NULL, vpx_tm_predictor_16x16_neon)\n+#endif  // HAVE_NEON\n+\n+#if HAVE_MSA\n+INTRA_PRED_TEST(MSA, TestIntraPred16, vpx_dc_predictor_16x16_msa,\n+                vpx_dc_left_predictor_16x16_msa, vpx_dc_top_predictor_16x16_msa,\n+                vpx_dc_128_predictor_16x16_msa, vpx_v_predictor_16x16_msa,\n+                vpx_h_predictor_16x16_msa, NULL, NULL, NULL, NULL, NULL,\n+                NULL, vpx_tm_predictor_16x16_msa)\n+#endif  // HAVE_MSA\n+\n+// -----------------------------------------------------------------------------\n+// 32x32\n+\n+INTRA_PRED_TEST(C, TestIntraPred32, vpx_dc_predictor_32x32_c,\n+                vpx_dc_left_predictor_32x32_c, vpx_dc_top_predictor_32x32_c,\n+                vpx_dc_128_predictor_32x32_c, vpx_v_predictor_32x32_c,\n+                vpx_h_predictor_32x32_c, vpx_d45_predictor_32x32_c,\n+                vpx_d135_predictor_32x32_c, vpx_d117_predictor_32x32_c,\n+                vpx_d153_predictor_32x32_c, vpx_d207_predictor_32x32_c,\n+                vpx_d63_predictor_32x32_c, vpx_tm_predictor_32x32_c)\n+\n+#if HAVE_SSE2 && CONFIG_USE_X86INC\n+#if ARCH_X86_64\n+INTRA_PRED_TEST(SSE2, TestIntraPred32, vpx_dc_predictor_32x32_sse2,\n+                vpx_dc_left_predictor_32x32_sse2,\n+                vpx_dc_top_predictor_32x32_sse2,\n+                vpx_dc_128_predictor_32x32_sse2, vpx_v_predictor_32x32_sse2,\n+                NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n+                vpx_tm_predictor_32x32_sse2)\n+#else\n+INTRA_PRED_TEST(SSE2, TestIntraPred32, vpx_dc_predictor_32x32_sse2,\n+                vpx_dc_left_predictor_32x32_sse2,\n+                vpx_dc_top_predictor_32x32_sse2,\n+                vpx_dc_128_predictor_32x32_sse2, vpx_v_predictor_32x32_sse2,\n+                NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL)\n+#endif  // ARCH_X86_64\n+#endif  // HAVE_SSE2 && CONFIG_USE_X86INC\n+\n+#if HAVE_SSSE3 && CONFIG_USE_X86INC\n+INTRA_PRED_TEST(SSSE3, TestIntraPred32, NULL, NULL, NULL, NULL, NULL,\n+                vpx_h_predictor_32x32_ssse3, vpx_d45_predictor_32x32_ssse3,\n+                NULL, NULL, vpx_d153_predictor_32x32_ssse3,\n+                vpx_d207_predictor_32x32_ssse3, vpx_d63_predictor_32x32_ssse3,\n+                NULL)\n+#endif  // HAVE_SSSE3 && CONFIG_USE_X86INC\n+\n+#if HAVE_NEON\n+INTRA_PRED_TEST(NEON, TestIntraPred32, vpx_dc_predictor_32x32_neon,\n+                vpx_dc_left_predictor_32x32_neon,\n+                vpx_dc_top_predictor_32x32_neon,\n+                vpx_dc_128_predictor_32x32_neon, vpx_v_predictor_32x32_neon,\n+                vpx_h_predictor_32x32_neon, NULL, NULL, NULL, NULL, NULL, NULL,\n+                vpx_tm_predictor_32x32_neon)\n+#endif  // HAVE_NEON\n+\n+#if HAVE_MSA\n+INTRA_PRED_TEST(MSA, TestIntraPred32, vpx_dc_predictor_32x32_msa,\n+                vpx_dc_left_predictor_32x32_msa, vpx_dc_top_predictor_32x32_msa,\n+                vpx_dc_128_predictor_32x32_msa, vpx_v_predictor_32x32_msa,\n+                vpx_h_predictor_32x32_msa, NULL, NULL, NULL, NULL, NULL,\n+                NULL, vpx_tm_predictor_32x32_msa)\n+#endif  // HAVE_MSA\n+\n+#include \""test/test_libvpx.cc\""\n""}<_**next**_>{""filename"": ""libvpx/test/test_libvpx.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/test_libvpx.cc"", ""patch"": ""@@ -8,6 +8,9 @@\n\n  *  be found in the AUTHORS file in the root of the source tree.\n  */\n #include <string>\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n #include \""./vpx_config.h\""\n #if ARCH_X86 || ARCH_X86_64\n #include \""vpx_ports/x86.h\""\n@@ -15,12 +18,13 @@\n\n extern \""C\"" {\n #if CONFIG_VP8\n extern void vp8_rtcd();\n-#endif\n+#endif  // CONFIG_VP8\n #if CONFIG_VP9\n extern void vp9_rtcd();\n-#endif\n+#endif  // CONFIG_VP9\n+extern void vpx_dsp_rtcd();\n+extern void vpx_scale_rtcd();\n }\n-#include \""third_party/googletest/src/include/gtest/gtest.h\""\n \n static void append_negative_gtest_filter(const char *str) {\n   std::string filter = ::testing::FLAGS_gtest_filter;\n@@ -36,21 +40,21 @@\n\n #if ARCH_X86 || ARCH_X86_64\n   const int simd_caps = x86_simd_caps();\n   if (!(simd_caps & HAS_MMX))\n-    append_negative_gtest_filter(\"":MMX/*\"");\n+    append_negative_gtest_filter(\"":MMX.*:MMX/*\"");\n   if (!(simd_caps & HAS_SSE))\n-    append_negative_gtest_filter(\"":SSE/*\"");\n+    append_negative_gtest_filter(\"":SSE.*:SSE/*\"");\n   if (!(simd_caps & HAS_SSE2))\n-    append_negative_gtest_filter(\"":SSE2/*\"");\n+    append_negative_gtest_filter(\"":SSE2.*:SSE2/*\"");\n   if (!(simd_caps & HAS_SSE3))\n-    append_negative_gtest_filter(\"":SSE3/*\"");\n+    append_negative_gtest_filter(\"":SSE3.*:SSE3/*\"");\n   if (!(simd_caps & HAS_SSSE3))\n-    append_negative_gtest_filter(\"":SSSE3/*\"");\n+    append_negative_gtest_filter(\"":SSSE3.*:SSSE3/*\"");\n   if (!(simd_caps & HAS_SSE4_1))\n-    append_negative_gtest_filter(\"":SSE4_1/*\"");\n+    append_negative_gtest_filter(\"":SSE4_1.*:SSE4_1/*\"");\n   if (!(simd_caps & HAS_AVX))\n-    append_negative_gtest_filter(\"":AVX/*\"");\n+    append_negative_gtest_filter(\"":AVX.*:AVX/*\"");\n   if (!(simd_caps & HAS_AVX2))\n-    append_negative_gtest_filter(\"":AVX2/*\"");\n+    append_negative_gtest_filter(\"":AVX2.*:AVX2/*\"");\n #endif\n \n #if !CONFIG_SHARED\n@@ -59,11 +63,13 @@\n\n \n #if CONFIG_VP8\n   vp8_rtcd();\n-#endif\n+#endif  // CONFIG_VP8\n #if CONFIG_VP9\n   vp9_rtcd();\n-#endif\n-#endif\n+#endif  // CONFIG_VP9\n+  vpx_dsp_rtcd();\n+  vpx_scale_rtcd();\n+#endif  // !CONFIG_SHARED\n \n   return RUN_ALL_TESTS();\n }\n""}<_**next**_>{""filename"": ""libvpx/test/test_vector_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/test_vector_test.cc"", ""patch"": ""@@ -12,21 +12,39 @@\n\n #include <cstdlib>\n #include <string>\n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n+#include \""../tools_common.h\""\n+#include \""./vpx_config.h\""\n #include \""test/codec_factory.h\""\n #include \""test/decode_test_driver.h\""\n #include \""test/ivf_video_source.h\""\n #include \""test/md5_helper.h\""\n #include \""test/test_vectors.h\""\n #include \""test/util.h\""\n+#if CONFIG_WEBM_IO\n #include \""test/webm_video_source.h\""\n+#endif\n #include \""vpx_mem/vpx_mem.h\""\n \n namespace {\n \n+enum DecodeMode {\n+  kSerialMode,\n+  kFrameParallelMode\n+};\n+\n+const int kDecodeMode = 0;\n+const int kThreads = 1;\n+const int kFileName = 2;\n+\n+typedef std::tr1::tuple<int, int, const char*> DecodeParam;\n+\n class TestVectorTest : public ::libvpx_test::DecoderTest,\n-    public ::libvpx_test::CodecTestWithParam<const char*> {\n+    public ::libvpx_test::CodecTestWithParam<DecodeParam> {\n  protected:\n-  TestVectorTest() : DecoderTest(GET_PARAM(0)), md5_file_(NULL) {}\n+  TestVectorTest()\n+      : DecoderTest(GET_PARAM(0)),\n+        md5_file_(NULL) {\n+  }\n \n   virtual ~TestVectorTest() {\n     if (md5_file_)\n@@ -68,14 +86,37 @@\n\n // checksums match the correct md5 data, then the test is passed. Otherwise,\n // the test failed.\n TEST_P(TestVectorTest, MD5Match) {\n-  const std::string filename = GET_PARAM(1);\n+  const DecodeParam input = GET_PARAM(1);\n+  const std::string filename = std::tr1::get<kFileName>(input);\n+  const int threads = std::tr1::get<kThreads>(input);\n+  const int mode = std::tr1::get<kDecodeMode>(input);\n   libvpx_test::CompressedVideoSource *video = NULL;\n+  vpx_codec_flags_t flags = 0;\n+  vpx_codec_dec_cfg_t cfg = {0};\n+  char str[256];\n+\n+  if (mode == kFrameParallelMode) {\n+    flags |= VPX_CODEC_USE_FRAME_THREADING;\n+  }\n+\n+  cfg.threads = threads;\n+\n+  snprintf(str, sizeof(str) / sizeof(str[0]) - 1,\n+           \""file: %s  mode: %s threads: %d\"",\n+           filename.c_str(), mode == 0 ? \""Serial\"" : \""Parallel\"", threads);\n+  SCOPED_TRACE(str);\n \n   // Open compressed video file.\n   if (filename.substr(filename.length() - 3, 3) == \""ivf\"") {\n     video = new libvpx_test::IVFVideoSource(filename);\n   } else if (filename.substr(filename.length() - 4, 4) == \""webm\"") {\n+#if CONFIG_WEBM_IO\n     video = new libvpx_test::WebMVideoSource(filename);\n+#else\n+    fprintf(stderr, \""WebM IO is disabled, skipping test vector %s\\n\"",\n+            filename.c_str());\n+    return;\n+#endif\n   }\n   video->Init();\n \n@@ -83,18 +124,50 @@\n\n   const std::string md5_filename = filename + \"".md5\"";\n   OpenMD5File(md5_filename);\n \n+  // Set decode config and flags.\n+  set_cfg(cfg);\n+  set_flags(flags);\n+\n   // Decode frame, and check the md5 matching.\n-  ASSERT_NO_FATAL_FAILURE(RunLoop(video));\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(video, cfg));\n   delete video;\n }\n \n-VP8_INSTANTIATE_TEST_CASE(TestVectorTest,\n-                          ::testing::ValuesIn(libvpx_test::kVP8TestVectors,\n-                                              libvpx_test::kVP8TestVectors +\n-                                              libvpx_test::kNumVP8TestVectors));\n-VP9_INSTANTIATE_TEST_CASE(TestVectorTest,\n-                          ::testing::ValuesIn(libvpx_test::kVP9TestVectors,\n-                                              libvpx_test::kVP9TestVectors +\n-                                              libvpx_test::kNumVP9TestVectors));\n+// Test VP8 decode in serial mode with single thread.\n+// NOTE: VP8 only support serial mode.\n+#if CONFIG_VP8_DECODER\n+VP8_INSTANTIATE_TEST_CASE(\n+    TestVectorTest,\n+    ::testing::Combine(\n+        ::testing::Values(0),  // Serial Mode.\n+        ::testing::Values(1),  // Single thread.\n+        ::testing::ValuesIn(libvpx_test::kVP8TestVectors,\n+                            libvpx_test::kVP8TestVectors +\n+                                libvpx_test::kNumVP8TestVectors)));\n+#endif  // CONFIG_VP8_DECODER\n \n+// Test VP9 decode in serial mode with single thread.\n+#if CONFIG_VP9_DECODER\n+VP9_INSTANTIATE_TEST_CASE(\n+    TestVectorTest,\n+    ::testing::Combine(\n+        ::testing::Values(0),  // Serial Mode.\n+        ::testing::Values(1),  // Single thread.\n+        ::testing::ValuesIn(libvpx_test::kVP9TestVectors,\n+                            libvpx_test::kVP9TestVectors +\n+                                libvpx_test::kNumVP9TestVectors)));\n+\n+// Test VP9 decode in frame parallel mode with different number of threads.\n+INSTANTIATE_TEST_CASE_P(\n+    VP9MultiThreadedFrameParallel, TestVectorTest,\n+    ::testing::Combine(\n+        ::testing::Values(\n+            static_cast<const libvpx_test::CodecFactory *>(&libvpx_test::kVP9)),\n+        ::testing::Combine(\n+            ::testing::Values(1),        // Frame Parallel mode.\n+            ::testing::Range(2, 9),      // With 2 ~ 8 threads.\n+            ::testing::ValuesIn(libvpx_test::kVP9TestVectors,\n+                                libvpx_test::kVP9TestVectors +\n+                                    libvpx_test::kNumVP9TestVectors))));\n+#endif\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/test_vectors.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/test_vectors.cc"", ""patch"": ""@@ -161,10 +161,14 @@\n\n   \""vp90-2-08-tile-4x1.webm\"", \""vp90-2-09-subpixel-00.ivf\"",\n   \""vp90-2-02-size-lf-1920x1080.webm\"", \""vp90-2-09-aq2.webm\"",\n   \""vp90-2-09-lf_deltas.webm\"", \""vp90-2-10-show-existing-frame.webm\"",\n+  \""vp90-2-10-show-existing-frame2.webm\"",\n   \""vp90-2-11-size-351x287.webm\"", \""vp90-2-11-size-351x288.webm\"",\n   \""vp90-2-11-size-352x287.webm\"", \""vp90-2-12-droppable_1.ivf\"",\n   \""vp90-2-12-droppable_2.ivf\"", \""vp90-2-12-droppable_3.ivf\"",\n-  \""vp90-2-13-largescaling.webm\"", \""vp91-2-04-yv444.webm\"",\n+#if !CONFIG_SIZE_LIMIT || \\\n+    (DECODE_WIDTH_LIMIT >= 20400 && DECODE_HEIGHT_LIMIT >= 120)\n+  \""vp90-2-13-largescaling.webm\"",\n+#endif\n   \""vp90-2-14-resize-fp-tiles-1-16.webm\"",\n   \""vp90-2-14-resize-fp-tiles-1-2-4-8-16.webm\"",\n   \""vp90-2-14-resize-fp-tiles-1-2.webm\"", \""vp90-2-14-resize-fp-tiles-1-4.webm\"",\n@@ -177,7 +181,20 @@\n\n   \""vp90-2-14-resize-fp-tiles-4-16.webm\"", \""vp90-2-14-resize-fp-tiles-4-1.webm\"",\n   \""vp90-2-14-resize-fp-tiles-4-2.webm\"", \""vp90-2-14-resize-fp-tiles-4-8.webm\"",\n   \""vp90-2-14-resize-fp-tiles-8-16.webm\"", \""vp90-2-14-resize-fp-tiles-8-1.webm\"",\n-  \""vp90-2-14-resize-fp-tiles-8-2.webm\"", \""vp90-2-14-resize-fp-tiles-8-4.webm\""\n+  \""vp90-2-14-resize-fp-tiles-8-2.webm\"", \""vp90-2-14-resize-fp-tiles-8-4.webm\"",\n+  \""vp90-2-15-segkey.webm\"", \""vp90-2-15-segkey_adpq.webm\"",\n+  \""vp90-2-16-intra-only.webm\"", \""vp90-2-17-show-existing-frame.webm\"",\n+  \""vp90-2-18-resize.ivf\"", \""vp90-2-19-skip.webm\"",\n+  \""vp90-2-19-skip-01.webm\"", \""vp90-2-19-skip-02.webm\"",\n+  \""vp91-2-04-yuv444.webm\"",\n+  \""vp91-2-04-yuv422.webm\"", \""vp91-2-04-yuv440.webm\"",\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  \""vp92-2-20-10bit-yuv420.webm\"", \""vp92-2-20-12bit-yuv420.webm\"",\n+  \""vp93-2-20-10bit-yuv422.webm\"", \""vp93-2-20-12bit-yuv422.webm\"",\n+  \""vp93-2-20-10bit-yuv440.webm\"", \""vp93-2-20-12bit-yuv440.webm\"",\n+  \""vp93-2-20-10bit-yuv444.webm\"", \""vp93-2-20-12bit-yuv444.webm\"",\n+#endif  // CONFIG_VP9_HIGHBITDEPTH`\n+  \""vp90-2-20-big_superframe-01.webm\"", \""vp90-2-20-big_superframe-02.webm\"",\n };\n const int kNumVP9TestVectors = NELEMENTS(kVP9TestVectors);\n #endif  // CONFIG_VP9_DECODER\n""}<_**next**_>{""filename"": ""libvpx/test/tile_independence_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/tile_independence_test.cc"", ""patch"": ""@@ -29,7 +29,7 @@\n\n         md5_inv_order_(),\n         n_tiles_(GET_PARAM(1)) {\n     init_flags_ = VPX_CODEC_USE_PSNR;\n-    vpx_codec_dec_cfg_t cfg;\n+    vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n     cfg.w = 704;\n     cfg.h = 144;\n     cfg.threads = 1;\n@@ -104,4 +104,5 @@\n\n \n VP9_INSTANTIATE_TEST_CASE(TileIndependenceTest, ::testing::Range(0, 2, 1));\n \n+VP10_INSTANTIATE_TEST_CASE(TileIndependenceTest, ::testing::Range(0, 2, 1));\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/tools_common.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/tools_common.sh"", ""patch"": ""@@ -9,7 +9,24 @@\n\n ##  be found in the AUTHORS file in the root of the source tree.\n ##\n ##  This file contains shell code shared by test scripts for libvpx tools.\n+\n+# Use $VPX_TEST_TOOLS_COMMON_SH as a pseudo include guard.\n+if [ -z \""${VPX_TEST_TOOLS_COMMON_SH}\"" ]; then\n+VPX_TEST_TOOLS_COMMON_SH=included\n+\n set -e\n+devnull='> /dev/null 2>&1'\n+VPX_TEST_PREFIX=\""\""\n+\n+elog() {\n+  echo \""$@\"" 1>&2\n+}\n+\n+vlog() {\n+  if [ \""${VPX_TEST_VERBOSE_OUTPUT}\"" = \""yes\"" ]; then\n+    echo \""$@\""\n+  fi\n+}\n \n # Sets $VPX_TOOL_TEST to the name specified by positional parameter one.\n test_begin() {\n@@ -89,22 +106,24 @@\n\n   fi\n }\n \n+# $1 is the name of an environment variable containing a directory name to\n+# test.\n+test_env_var_dir() {\n+  local dir=$(eval echo \""\\${$1}\"")\n+  if [ ! -d \""${dir}\"" ]; then\n+    elog \""'${dir}': No such directory\""\n+    elog \""The $1 environment variable must be set to a valid directory.\""\n+    return 1\n+  fi\n+}\n+\n # This script requires that the LIBVPX_BIN_PATH, LIBVPX_CONFIG_PATH, and\n # LIBVPX_TEST_DATA_PATH variables are in the environment: Confirm that\n # the variables are set and that they all evaluate to directory paths.\n verify_vpx_test_environment() {\n-  if [ ! -d \""${LIBVPX_BIN_PATH}\"" ]; then\n-    echo \""The LIBVPX_BIN_PATH environment variable must be set.\""\n-    return 1\n-  fi\n-  if [ ! -d \""${LIBVPX_CONFIG_PATH}\"" ]; then\n-    echo \""The LIBVPX_CONFIG_PATH environment variable must be set.\""\n-    return 1\n-  fi\n-  if [ ! -d \""${LIBVPX_TEST_DATA_PATH}\"" ]; then\n-    echo \""The LIBVPX_TEST_DATA_PATH environment variable must be set.\""\n-    return 1\n-  fi\n+  test_env_var_dir \""LIBVPX_BIN_PATH\"" \\\n+    && test_env_var_dir \""LIBVPX_CONFIG_PATH\"" \\\n+    && test_env_var_dir \""LIBVPX_TEST_DATA_PATH\""\n }\n \n # Greps vpx_config.h in LIBVPX_CONFIG_PATH for positional parameter one, which\n@@ -127,14 +146,30 @@\n\n   fi\n }\n \n+# Echoes path to $1 when it's executable and exists in ${LIBVPX_BIN_PATH}, or an\n+# empty string. Caller is responsible for testing the string once the function\n+# returns.\n+vpx_tool_path() {\n+  local readonly tool_name=\""$1\""\n+  local tool_path=\""${LIBVPX_BIN_PATH}/${tool_name}${VPX_TEST_EXE_SUFFIX}\""\n+  if [ ! -x \""${tool_path}\"" ]; then\n+    # Try one directory up: when running via examples.sh the tool could be in\n+    # the parent directory of $LIBVPX_BIN_PATH.\n+    tool_path=\""${LIBVPX_BIN_PATH}/../${tool_name}${VPX_TEST_EXE_SUFFIX}\""\n+  fi\n+\n+  if [ ! -x \""${tool_path}\"" ]; then\n+    tool_path=\""\""\n+  fi\n+  echo \""${tool_path}\""\n+}\n+\n # Echoes yes to stdout when the file named by positional parameter one exists\n # in LIBVPX_BIN_PATH, and is executable.\n vpx_tool_available() {\n-  tool_name=\""${1}\""\n-  if [ \""$(is_windows_target)\"" = \""yes\"" ]; then\n-    tool_name=\""${tool_name}.exe\""\n-  fi\n-  [ -x \""${LIBVPX_BIN_PATH}/${1}\"" ] && echo yes\n+  local tool_name=\""$1\""\n+  local tool=\""${LIBVPX_BIN_PATH}/${tool_name}${VPX_TEST_EXE_SUFFIX}\""\n+  [ -x \""${tool}\"" ] && echo yes\n }\n \n # Echoes yes to stdout when vpx_config_option_enabled() reports yes for\n@@ -167,107 +202,11 @@\n\n   [ \""$(vpx_config_option_enabled CONFIG_WEBM_IO)\"" = \""yes\"" ] && echo yes\n }\n \n-# Echoes yes to stdout when vpxdec exists according to vpx_tool_available().\n-vpxdec_available() {\n-  [ -n $(vpx_tool_available vpxdec) ] && echo yes\n-}\n-\n-# Wrapper function for running vpxdec in noblit mode. Requires that\n-# LIBVPX_BIN_PATH points to the directory containing vpxdec. Positional\n-# parameter one is used as the input file path. Positional parameter two, when\n-# present, is interpreted as a boolean flag that means the input should be sent\n-# to vpxdec via pipe from cat instead of directly.\n-vpxdec() {\n-  input=\""${1}\""\n-  pipe_input=${2}\n-\n-  if [ $# -gt 2 ]; then\n-    # shift away $1 and $2 so the remaining arguments can be passed to vpxdec\n-    # via $@.\n-    shift 2\n-  fi\n-\n-  decoder=\""${LIBVPX_BIN_PATH}/vpxdec\""\n-\n-  if [ \""$(is_windows_target)\"" = \""yes\"" ]; then\n-    decoder=\""${decoder}.exe\""\n-  fi\n-\n-  if [ -z \""${pipe_input}\"" ]; then\n-    \""${decoder}\"" \""$input\"" --summary --noblit \""$@\"" > /dev/null 2>&1\n-  else\n-    cat \""${input}\"" | \""${decoder}\"" - --summary --noblit \""$@\"" > /dev/null 2>&1\n-  fi\n-}\n-\n-# Echoes yes to stdout when vpxenc exists according to vpx_tool_available().\n-vpxenc_available() {\n-  [ -n $(vpx_tool_available vpxenc) ] && echo yes\n-}\n-\n-# Wrapper function for running vpxenc. Positional parameters are interpreted as\n-# follows:\n-#   1 - codec name\n-#   2 - input width\n-#   3 - input height\n-#   4 - number of frames to encode\n-#   5 - path to input file\n-#   6 - path to output file\n-#       Note: The output file path must end in .ivf to output an IVF file.\n-#   7 - extra flags\n-#       Note: Extra flags currently supports a special case: when set to \""-\""\n-#             input is piped to vpxenc via cat.\n-vpxenc() {\n-  encoder=\""${LIBVPX_BIN_PATH}/vpxenc\""\n-  codec=\""${1}\""\n-  width=${2}\n-  height=${3}\n-  frames=${4}\n-  input=${5}\n-  output=\""${VPX_TEST_OUTPUT_DIR}/${6}\""\n-  extra_flags=${7}\n-\n-  if [ \""$(is_windows_target)\"" = \""yes\"" ]; then\n-    encoder=\""${encoder}.exe\""\n-  fi\n-\n-  # Because --ivf must be within the command line to get IVF from vpxenc.\n-  if echo \""${output}\"" | egrep -q 'ivf$'; then\n-    use_ivf=--ivf\n-  else\n-    unset use_ivf\n-  fi\n-\n-  if [ \""${extra_flags}\"" = \""-\"" ]; then\n-    pipe_input=yes\n-    extra_flags=${8}\n-  else\n-    unset pipe_input\n-  fi\n-\n-  if [ -z \""${pipe_input}\"" ]; then\n-    \""${encoder}\"" --codec=${codec} --width=${width} --height=${height} \\\n-        --limit=${frames} ${use_ivf} ${extra_flags} --output=\""${output}\"" \\\n-        \""${input}\"" > /dev/null 2>&1\n-  else\n-    cat \""${input}\"" \\\n-        | \""${encoder}\"" --codec=${codec} --width=${width} --height=${height} \\\n-            --limit=${frames} ${use_ivf} ${extra_flags} --output=\""${output}\"" - \\\n-            > /dev/null 2>&1\n-  fi\n-\n-  if [ ! -e \""${output}\"" ]; then\n-    # Return non-zero exit status: output file doesn't exist, so something\n-    # definitely went wrong.\n-    return 1\n-  fi\n-}\n-\n-# Filters strings from positional parameter one using the filter specified by\n-# positional parameter two. Filter behavior depends on the presence of a third\n-# positional parameter. When parameter three is present, strings that match the\n-# filter are excluded. When omitted, strings matching the filter are included.\n-# The filtered string is echoed to stdout.\n+# Filters strings from $1 using the filter specified by $2. Filter behavior\n+# depends on the presence of $3. When $3 is present, strings that match the\n+# filter are excluded. When $3 is omitted, strings matching the filter are\n+# included.\n+# The filtered result is echoed to stdout.\n filter_strings() {\n   strings=${1}\n   filter=${2}\n@@ -298,8 +237,13 @@\n\n # functions and are run unconditionally. Functions in positional parameter two\n # are run according to the rules specified in vpx_test_usage().\n run_tests() {\n-  env_tests=\""verify_vpx_test_environment ${1}\""\n-  tests_to_filter=\""${2}\""\n+  local env_tests=\""verify_vpx_test_environment $1\""\n+  local tests_to_filter=\""$2\""\n+  local test_name=\""${VPX_TEST_NAME}\""\n+\n+  if [ -z \""${test_name}\"" ]; then\n+    test_name=\""$(basename \""${0%.*}\"")\""\n+  fi\n \n   if [ \""${VPX_TEST_RUN_DISABLED_TESTS}\"" != \""yes\"" ]; then\n     # Filter out DISABLED tests.\n@@ -311,20 +255,33 @@\n\n     tests_to_filter=$(filter_strings \""${tests_to_filter}\"" ${VPX_TEST_FILTER})\n   fi\n \n-  tests_to_run=\""${env_tests} ${tests_to_filter}\""\n+  # User requested test listing: Dump test names and return.\n+  if [ \""${VPX_TEST_LIST_TESTS}\"" = \""yes\"" ]; then\n+    for test_name in $tests_to_filter; do\n+      echo ${test_name}\n+    done\n+    return\n+  fi\n+\n+  # Don't bother with the environment tests if everything else was disabled.\n+  [ -z \""${tests_to_filter}\"" ] && return\n+\n+  # Combine environment and actual tests.\n+  local tests_to_run=\""${env_tests} ${tests_to_filter}\""\n \n   check_git_hashes\n \n   # Run tests.\n   for test in ${tests_to_run}; do\n     test_begin \""${test}\""\n+    vlog \""  RUN  ${test}\""\n     \""${test}\""\n-    [ \""${VPX_TEST_VERBOSE_OUTPUT}\"" = \""yes\"" ] && echo \""  PASS ${test}\""\n+    vlog \""  PASS ${test}\""\n     test_end \""${test}\""\n   done\n \n-  tested_config=\""$(test_configuration_target) @ $(current_hash)\""\n-  echo $(basename \""${0%.*}\""): Done, all tests pass for ${tested_config}.\n+  local tested_config=\""$(test_configuration_target) @ $(current_hash)\""\n+  echo \""${test_name}: Done, all tests pass for ${tested_config}.\""\n }\n \n vpx_test_usage() {\n@@ -336,6 +293,11 @@\n\n     --run-disabled-tests: Run disabled tests.\n     --help: Display this message and exit.\n     --test-data-path <path to libvpx test data directory>\n+    --show-program-output: Shows output from all programs being tested.\n+    --prefix: Allows for a user specified prefix to be inserted before all test\n+              programs. Grants the ability, for example, to run test programs\n+              within valgrind.\n+    --list-tests: List all test names and exit without actually running tests.\n     --verbose: Verbose output.\n \n     When the --bin-path option is not specified the script attempts to use\n@@ -385,9 +347,19 @@\n\n       LIBVPX_TEST_DATA_PATH=\""$2\""\n       shift\n       ;;\n+    --prefix)\n+      VPX_TEST_PREFIX=\""$2\""\n+      shift\n+      ;;\n     --verbose)\n       VPX_TEST_VERBOSE_OUTPUT=yes\n       ;;\n+    --show-program-output)\n+      devnull=\n+      ;;\n+    --list-tests)\n+      VPX_TEST_LIST_TESTS=yes\n+      ;;\n     *)\n       vpx_test_usage\n       exit 1\n@@ -411,8 +383,7 @@\n\n   VPX_TEST_TEMP_ROOT=/tmp\n fi\n \n-VPX_TEST_RAND=$(awk 'BEGIN { srand(); printf \""%d\\n\"",(rand() * 32768)}')\n-VPX_TEST_OUTPUT_DIR=\""${VPX_TEST_TEMP_ROOT}/vpx_test_${VPX_TEST_RAND}\""\n+VPX_TEST_OUTPUT_DIR=\""${VPX_TEST_TEMP_ROOT}/vpx_test_$$\""\n \n if ! mkdir -p \""${VPX_TEST_OUTPUT_DIR}\"" || \\\n    [ ! -d \""${VPX_TEST_OUTPUT_DIR}\"" ]; then\n@@ -421,17 +392,47 @@\n\n   exit 1\n fi\n \n+if [ \""$(is_windows_target)\"" = \""yes\"" ]; then\n+  VPX_TEST_EXE_SUFFIX=\"".exe\""\n+fi\n+\n+# Variables shared by tests.\n+VP8_IVF_FILE=\""${LIBVPX_TEST_DATA_PATH}/vp80-00-comprehensive-001.ivf\""\n+VP9_IVF_FILE=\""${LIBVPX_TEST_DATA_PATH}/vp90-2-09-subpixel-00.ivf\""\n+\n+VP9_WEBM_FILE=\""${LIBVPX_TEST_DATA_PATH}/vp90-2-00-quantizer-00.webm\""\n+VP9_FPM_WEBM_FILE=\""${LIBVPX_TEST_DATA_PATH}/vp90-2-07-frame_parallel-1.webm\""\n+VP9_LT_50_FRAMES_WEBM_FILE=\""${LIBVPX_TEST_DATA_PATH}/vp90-2-02-size-32x08.webm\""\n+\n+YUV_RAW_INPUT=\""${LIBVPX_TEST_DATA_PATH}/hantro_collage_w352h288.yuv\""\n+YUV_RAW_INPUT_WIDTH=352\n+YUV_RAW_INPUT_HEIGHT=288\n+\n+Y4M_NOSQ_PAR_INPUT=\""${LIBVPX_TEST_DATA_PATH}/park_joy_90p_8_420_a10-1.y4m\""\n+Y4M_720P_INPUT=\""${LIBVPX_TEST_DATA_PATH}/niklas_1280_720_30.y4m\""\n+\n+# Setup a trap function to clean up after tests complete.\n trap cleanup EXIT\n \n-if [ \""${VPX_TEST_VERBOSE_OUTPUT}\"" = \""yes\"" ]; then\n-cat << EOF\n-$(basename \""${0%.*}\"") test configuration:\n+vlog \""$(basename \""${0%.*}\"") test configuration:\n   LIBVPX_BIN_PATH=${LIBVPX_BIN_PATH}\n   LIBVPX_CONFIG_PATH=${LIBVPX_CONFIG_PATH}\n   LIBVPX_TEST_DATA_PATH=${LIBVPX_TEST_DATA_PATH}\n-  VPX_TEST_OUTPUT_DIR=${VPX_TEST_OUTPUT_DIR}\n-  VPX_TEST_VERBOSE_OUTPUT=${VPX_TEST_VERBOSE_OUTPUT}\n+  VP8_IVF_FILE=${VP8_IVF_FILE}\n+  VP9_IVF_FILE=${VP9_IVF_FILE}\n+  VP9_WEBM_FILE=${VP9_WEBM_FILE}\n+  VPX_TEST_EXE_SUFFIX=${VPX_TEST_EXE_SUFFIX}\n   VPX_TEST_FILTER=${VPX_TEST_FILTER}\n+  VPX_TEST_LIST_TESTS=${VPX_TEST_LIST_TESTS}\n+  VPX_TEST_OUTPUT_DIR=${VPX_TEST_OUTPUT_DIR}\n+  VPX_TEST_PREFIX=${VPX_TEST_PREFIX}\n   VPX_TEST_RUN_DISABLED_TESTS=${VPX_TEST_RUN_DISABLED_TESTS}\n-EOF\n-fi\n+  VPX_TEST_SHOW_PROGRAM_OUTPUT=${VPX_TEST_SHOW_PROGRAM_OUTPUT}\n+  VPX_TEST_TEMP_ROOT=${VPX_TEST_TEMP_ROOT}\n+  VPX_TEST_VERBOSE_OUTPUT=${VPX_TEST_VERBOSE_OUTPUT}\n+  YUV_RAW_INPUT=${YUV_RAW_INPUT}\n+  YUV_RAW_INPUT_WIDTH=${YUV_RAW_INPUT_WIDTH}\n+  YUV_RAW_INPUT_HEIGHT=${YUV_RAW_INPUT_HEIGHT}\n+  Y4M_NOSQ_PAR_INPUT=${Y4M_NOSQ_PAR_INPUT}\""\n+\n+fi  # End $VPX_TEST_TOOLS_COMMON_SH pseudo include guard.\n""}<_**next**_>{""filename"": ""libvpx/test/twopass_encoder.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/twopass_encoder.sh"", ""patch"": ""@@ -0,0 +1,62 @@\n\n+#!/bin/sh\n+##\n+##  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+##\n+##  Use of this source code is governed by a BSD-style license\n+##  that can be found in the LICENSE file in the root of the source\n+##  tree. An additional intellectual property rights grant can be found\n+##  in the file PATENTS.  All contributing project authors may\n+##  be found in the AUTHORS file in the root of the source tree.\n+##\n+##  This file tests the libvpx twopass_encoder example. To add new tests to this\n+##  file, do the following:\n+##    1. Write a shell function (this is your test).\n+##    2. Add the function to twopass_encoder_tests (on a new line).\n+##\n+. $(dirname $0)/tools_common.sh\n+\n+# Environment check: $YUV_RAW_INPUT is required.\n+twopass_encoder_verify_environment() {\n+  if [ ! -e \""${YUV_RAW_INPUT}\"" ]; then\n+    echo \""Libvpx test data must exist in LIBVPX_TEST_DATA_PATH.\""\n+    return 1\n+  fi\n+}\n+\n+# Runs twopass_encoder using the codec specified by $1.\n+twopass_encoder() {\n+  local encoder=\""${LIBVPX_BIN_PATH}/twopass_encoder${VPX_TEST_EXE_SUFFIX}\""\n+  local codec=\""$1\""\n+  local output_file=\""${VPX_TEST_OUTPUT_DIR}/twopass_encoder_${codec}.ivf\""\n+\n+  if [ ! -x \""${encoder}\"" ]; then\n+    elog \""${encoder} does not exist or is not executable.\""\n+    return 1\n+  fi\n+\n+  eval \""${VPX_TEST_PREFIX}\"" \""${encoder}\"" \""${codec}\"" \""${YUV_RAW_INPUT_WIDTH}\"" \\\n+      \""${YUV_RAW_INPUT_HEIGHT}\"" \""${YUV_RAW_INPUT}\"" \""${output_file}\"" \\\n+      ${devnull}\n+\n+  [ -e \""${output_file}\"" ] || return 1\n+}\n+\n+twopass_encoder_vp8() {\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+    twopass_encoder vp8 || return 1\n+  fi\n+}\n+\n+# TODO(tomfinegan): Add a frame limit param to twopass_encoder and enable this\n+# test. VP9 is just too slow right now: This test takes 31m16s+ on a fast\n+# machine.\n+DISABLED_twopass_encoder_vp9() {\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+    twopass_encoder vp9 || return 1\n+  fi\n+}\n+\n+twopass_encoder_tests=\""twopass_encoder_vp8\n+                       DISABLED_twopass_encoder_vp9\""\n+\n+run_tests twopass_encoder_verify_environment \""${twopass_encoder_tests}\""\n""}<_**next**_>{""filename"": ""libvpx/test/user_priv_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/user_priv_test.cc"", ""patch"": ""@@ -0,0 +1,100 @@\n\n+/*\n+ *  Copyright (c) 2013 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+#include \""./vpx_config.h\""\n+#include \""test/acm_random.h\""\n+#include \""test/codec_factory.h\""\n+#include \""test/decode_test_driver.h\""\n+#include \""test/ivf_video_source.h\""\n+#include \""test/md5_helper.h\""\n+#include \""test/util.h\""\n+#if CONFIG_WEBM_IO\n+#include \""test/webm_video_source.h\""\n+#endif\n+#include \""vpx_mem/vpx_mem.h\""\n+#include \""vpx/vp8.h\""\n+\n+namespace {\n+\n+using std::string;\n+using libvpx_test::ACMRandom;\n+\n+#if CONFIG_WEBM_IO\n+\n+void CheckUserPrivateData(void *user_priv, int *target) {\n+  // actual pointer value should be the same as expected.\n+  EXPECT_EQ(reinterpret_cast<void *>(target), user_priv) <<\n+      \""user_priv pointer value does not match.\"";\n+}\n+\n+// Decodes |filename|. Passes in user_priv data when calling DecodeFrame and\n+// compares the user_priv from return img with the original user_priv to see if\n+// they match. Both the pointer values and the values inside the addresses\n+// should match.\n+string DecodeFile(const string &filename) {\n+  ACMRandom rnd(ACMRandom::DeterministicSeed());\n+  libvpx_test::WebMVideoSource video(filename);\n+  video.Init();\n+\n+  vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n+  libvpx_test::VP9Decoder decoder(cfg, 0);\n+\n+  libvpx_test::MD5 md5;\n+  int frame_num = 0;\n+  for (video.Begin(); !::testing::Test::HasFailure() && video.cxdata();\n+       video.Next()) {\n+    void *user_priv = reinterpret_cast<void *>(&frame_num);\n+    const vpx_codec_err_t res =\n+        decoder.DecodeFrame(video.cxdata(), video.frame_size(),\n+                            (frame_num == 0) ? NULL : user_priv);\n+    if (res != VPX_CODEC_OK) {\n+      EXPECT_EQ(VPX_CODEC_OK, res) << decoder.DecodeError();\n+      break;\n+    }\n+    libvpx_test::DxDataIterator dec_iter = decoder.GetDxData();\n+    const vpx_image_t *img = NULL;\n+\n+    // Get decompressed data.\n+    while ((img = dec_iter.Next())) {\n+      if (frame_num == 0) {\n+        CheckUserPrivateData(img->user_priv, NULL);\n+      } else {\n+        CheckUserPrivateData(img->user_priv, &frame_num);\n+\n+        // Also test ctrl_get_reference api.\n+        struct vp9_ref_frame ref;\n+        // Randomly fetch a reference frame.\n+        ref.idx = rnd.Rand8() % 3;\n+        decoder.Control(VP9_GET_REFERENCE, &ref);\n+\n+        CheckUserPrivateData(ref.img.user_priv, NULL);\n+      }\n+      md5.Add(img);\n+    }\n+\n+    frame_num++;\n+  }\n+  return string(md5.Get());\n+}\n+\n+TEST(UserPrivTest, VideoDecode) {\n+  // no tiles or frame parallel; this exercises the decoding to test the\n+  // user_priv.\n+  EXPECT_STREQ(\""b35a1b707b28e82be025d960aba039bc\"",\n+               DecodeFile(\""vp90-2-03-size-226x226.webm\"").c_str());\n+}\n+\n+#endif  // CONFIG_WEBM_IO\n+\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/variance_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/variance_test.cc"", ""patch"": ""@@ -7,111 +7,271 @@\n\n  *  in the file PATENTS.  All contributing project authors may\n  *  be found in the AUTHORS file in the root of the source tree.\n  */\n-#include <stdlib.h>\n+\n+#include <cstdlib>\n #include <new>\n \n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n \n+#include \""./vpx_config.h\""\n+#include \""./vpx_dsp_rtcd.h\""\n+#include \""test/acm_random.h\""\n #include \""test/clear_system_state.h\""\n #include \""test/register_state_check.h\""\n-\n+#include \""vpx/vpx_codec.h\""\n #include \""vpx/vpx_integer.h\""\n-#include \""./vpx_config.h\""\n #include \""vpx_mem/vpx_mem.h\""\n-#if CONFIG_VP8_ENCODER\n-# include \""./vp8_rtcd.h\""\n-# include \""vp8/common/variance.h\""\n-#endif\n-#if CONFIG_VP9_ENCODER\n-# include \""./vp9_rtcd.h\""\n-# include \""vp9/encoder/vp9_variance.h\""\n-#endif\n-#include \""test/acm_random.h\""\n+#include \""vpx_ports/mem.h\""\n \n namespace {\n \n+typedef unsigned int (*VarianceMxNFunc)(const uint8_t *a, int a_stride,\n+                                        const uint8_t *b, int b_stride,\n+                                        unsigned int *sse);\n+typedef unsigned int (*SubpixVarMxNFunc)(const uint8_t *a, int a_stride,\n+                                         int xoffset, int yoffset,\n+                                         const uint8_t *b, int b_stride,\n+                                         unsigned int *sse);\n+typedef unsigned int (*SubpixAvgVarMxNFunc)(const uint8_t *a, int a_stride,\n+                                            int xoffset, int yoffset,\n+                                            const uint8_t *b, int b_stride,\n+                                            uint32_t *sse,\n+                                            const uint8_t *second_pred);\n+typedef unsigned int (*Get4x4SseFunc)(const uint8_t *a, int a_stride,\n+                                      const uint8_t *b, int b_stride);\n+typedef unsigned int (*SumOfSquaresFunction)(const int16_t *src);\n+\n+\n using ::std::tr1::get;\n using ::std::tr1::make_tuple;\n using ::std::tr1::tuple;\n using libvpx_test::ACMRandom;\n \n-static unsigned int variance_ref(const uint8_t *ref, const uint8_t *src,\n-                                 int l2w, int l2h, unsigned int *sse_ptr) {\n-  int se = 0;\n-  unsigned int sse = 0;\n-  const int w = 1 << l2w, h = 1 << l2h;\n-  for (int y = 0; y < h; y++) {\n-    for (int x = 0; x < w; x++) {\n-      int diff = ref[w * y + x] - src[w * y + x];\n-      se += diff;\n-      sse += diff * diff;\n-    }\n+// Truncate high bit depth results by downshifting (with rounding) by:\n+// 2 * (bit_depth - 8) for sse\n+// (bit_depth - 8) for se\n+static void RoundHighBitDepth(int bit_depth, int64_t *se, uint64_t *sse) {\n+  switch (bit_depth) {\n+    case VPX_BITS_12:\n+      *sse = (*sse + 128) >> 8;\n+      *se = (*se + 8) >> 4;\n+      break;\n+    case VPX_BITS_10:\n+      *sse = (*sse + 8) >> 4;\n+      *se = (*se + 2) >> 2;\n+      break;\n+    case VPX_BITS_8:\n+    default:\n+      break;\n   }\n-  *sse_ptr = sse;\n-  return sse - (((int64_t) se * se) >> (l2w + l2h));\n }\n \n-static unsigned int subpel_variance_ref(const uint8_t *ref, const uint8_t *src,\n-                                        int l2w, int l2h, int xoff, int yoff,\n-                                        unsigned int *sse_ptr) {\n-  int se = 0;\n-  unsigned int sse = 0;\n-  const int w = 1 << l2w, h = 1 << l2h;\n+static unsigned int mb_ss_ref(const int16_t *src) {\n+  unsigned int res = 0;\n+  for (int i = 0; i < 256; ++i) {\n+    res += src[i] * src[i];\n+  }\n+  return res;\n+}\n+\n+static uint32_t variance_ref(const uint8_t *src, const uint8_t *ref,\n+                             int l2w, int l2h, int src_stride_coeff,\n+                             int ref_stride_coeff, uint32_t *sse_ptr,\n+                             bool use_high_bit_depth_,\n+                             vpx_bit_depth_t bit_depth) {\n+  int64_t se = 0;\n+  uint64_t sse = 0;\n+  const int w = 1 << l2w;\n+  const int h = 1 << l2h;\n   for (int y = 0; y < h; y++) {\n     for (int x = 0; x < w; x++) {\n-      // bilinear interpolation at a 16th pel step\n-      const int a1 = ref[(w + 1) * (y + 0) + x + 0];\n-      const int a2 = ref[(w + 1) * (y + 0) + x + 1];\n-      const int b1 = ref[(w + 1) * (y + 1) + x + 0];\n-      const int b2 = ref[(w + 1) * (y + 1) + x + 1];\n-      const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);\n-      const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);\n-      const int r = a + (((b - a) * yoff + 8) >> 4);\n-      int diff = r - src[w * y + x];\n-      se += diff;\n-      sse += diff * diff;\n+      int diff;\n+      if (!use_high_bit_depth_) {\n+        diff = ref[w * y * ref_stride_coeff + x] -\n+               src[w * y * src_stride_coeff + x];\n+        se += diff;\n+        sse += diff * diff;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        diff = CONVERT_TO_SHORTPTR(ref)[w * y * ref_stride_coeff + x] -\n+               CONVERT_TO_SHORTPTR(src)[w * y * src_stride_coeff + x];\n+        se += diff;\n+        sse += diff * diff;\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+      }\n     }\n   }\n-  *sse_ptr = sse;\n-  return sse - (((int64_t) se * se) >> (l2w + l2h));\n+  RoundHighBitDepth(bit_depth, &se, &sse);\n+  *sse_ptr = static_cast<uint32_t>(sse);\n+  return static_cast<uint32_t>(sse -\n+                               ((static_cast<int64_t>(se) * se) >>\n+                                (l2w + l2h)));\n+}\n+\n+/* The subpel reference functions differ from the codec version in one aspect:\n+ * they calculate the bilinear factors directly instead of using a lookup table\n+ * and therefore upshift xoff and yoff by 1. Only every other calculated value\n+ * is used so the codec version shrinks the table to save space and maintain\n+ * compatibility with vp8.\n+ */\n+static uint32_t subpel_variance_ref(const uint8_t *ref, const uint8_t *src,\n+                                    int l2w, int l2h, int xoff, int yoff,\n+                                    uint32_t *sse_ptr,\n+                                    bool use_high_bit_depth_,\n+                                    vpx_bit_depth_t bit_depth) {\n+  int64_t se = 0;\n+  uint64_t sse = 0;\n+  const int w = 1 << l2w;\n+  const int h = 1 << l2h;\n+\n+  xoff <<= 1;\n+  yoff <<= 1;\n+\n+  for (int y = 0; y < h; y++) {\n+    for (int x = 0; x < w; x++) {\n+      // Bilinear interpolation at a 16th pel step.\n+      if (!use_high_bit_depth_) {\n+        const int a1 = ref[(w + 1) * (y + 0) + x + 0];\n+        const int a2 = ref[(w + 1) * (y + 0) + x + 1];\n+        const int b1 = ref[(w + 1) * (y + 1) + x + 0];\n+        const int b2 = ref[(w + 1) * (y + 1) + x + 1];\n+        const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);\n+        const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);\n+        const int r = a + (((b - a) * yoff + 8) >> 4);\n+        const int diff = r - src[w * y + x];\n+        se += diff;\n+        sse += diff * diff;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        uint16_t *ref16 = CONVERT_TO_SHORTPTR(ref);\n+        uint16_t *src16 = CONVERT_TO_SHORTPTR(src);\n+        const int a1 = ref16[(w + 1) * (y + 0) + x + 0];\n+        const int a2 = ref16[(w + 1) * (y + 0) + x + 1];\n+        const int b1 = ref16[(w + 1) * (y + 1) + x + 0];\n+        const int b2 = ref16[(w + 1) * (y + 1) + x + 1];\n+        const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);\n+        const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);\n+        const int r = a + (((b - a) * yoff + 8) >> 4);\n+        const int diff = r - src16[w * y + x];\n+        se += diff;\n+        sse += diff * diff;\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+      }\n+    }\n+  }\n+  RoundHighBitDepth(bit_depth, &se, &sse);\n+  *sse_ptr = static_cast<uint32_t>(sse);\n+  return static_cast<uint32_t>(sse -\n+                               ((static_cast<int64_t>(se) * se) >>\n+                                (l2w + l2h)));\n+}\n+\n+class SumOfSquaresTest : public ::testing::TestWithParam<SumOfSquaresFunction> {\n+ public:\n+  SumOfSquaresTest() : func_(GetParam()) {}\n+\n+  virtual ~SumOfSquaresTest() {\n+    libvpx_test::ClearSystemState();\n+  }\n+\n+ protected:\n+  void ConstTest();\n+  void RefTest();\n+\n+  SumOfSquaresFunction func_;\n+  ACMRandom rnd_;\n+};\n+\n+void SumOfSquaresTest::ConstTest() {\n+  int16_t mem[256];\n+  unsigned int res;\n+  for (int v = 0; v < 256; ++v) {\n+    for (int i = 0; i < 256; ++i) {\n+      mem[i] = v;\n+    }\n+    ASM_REGISTER_STATE_CHECK(res = func_(mem));\n+    EXPECT_EQ(256u * (v * v), res);\n+  }\n+}\n+\n+void SumOfSquaresTest::RefTest() {\n+  int16_t mem[256];\n+  for (int i = 0; i < 100; ++i) {\n+    for (int j = 0; j < 256; ++j) {\n+      mem[j] = rnd_.Rand8() - rnd_.Rand8();\n+    }\n+\n+    const unsigned int expected = mb_ss_ref(mem);\n+    unsigned int res;\n+    ASM_REGISTER_STATE_CHECK(res = func_(mem));\n+    EXPECT_EQ(expected, res);\n+  }\n }\n \n template<typename VarianceFunctionType>\n class VarianceTest\n-    : public ::testing::TestWithParam<tuple<int, int, VarianceFunctionType> > {\n+    : public ::testing::TestWithParam<tuple<int, int,\n+                                            VarianceFunctionType, int> > {\n  public:\n   virtual void SetUp() {\n-    const tuple<int, int, VarianceFunctionType>& params = this->GetParam();\n+    const tuple<int, int, VarianceFunctionType, int>& params = this->GetParam();\n     log2width_  = get<0>(params);\n     width_ = 1 << log2width_;\n     log2height_ = get<1>(params);\n     height_ = 1 << log2height_;\n     variance_ = get<2>(params);\n+    if (get<3>(params)) {\n+      bit_depth_ = static_cast<vpx_bit_depth_t>(get<3>(params));\n+      use_high_bit_depth_ = true;\n+    } else {\n+      bit_depth_ = VPX_BITS_8;\n+      use_high_bit_depth_ = false;\n+    }\n+    mask_ = (1 << bit_depth_) - 1;\n \n-    rnd(ACMRandom::DeterministicSeed());\n+    rnd_.Reset(ACMRandom::DeterministicSeed());\n     block_size_ = width_ * height_;\n-    src_ = new uint8_t[block_size_];\n-    ref_ = new uint8_t[block_size_];\n+    if (!use_high_bit_depth_) {\n+      src_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_ * 2));\n+      ref_ = new uint8_t[block_size_ * 2];\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    } else {\n+      src_ = CONVERT_TO_BYTEPTR(reinterpret_cast<uint16_t *>(\n+          vpx_memalign(16, block_size_ * 2 * sizeof(uint16_t))));\n+      ref_ = CONVERT_TO_BYTEPTR(new uint16_t[block_size_ * 2]);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+    }\n     ASSERT_TRUE(src_ != NULL);\n     ASSERT_TRUE(ref_ != NULL);\n   }\n \n   virtual void TearDown() {\n-    delete[] src_;\n-    delete[] ref_;\n+    if (!use_high_bit_depth_) {\n+      vpx_free(src_);\n+      delete[] ref_;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    } else {\n+      vpx_free(CONVERT_TO_SHORTPTR(src_));\n+      delete[] CONVERT_TO_SHORTPTR(ref_);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+    }\n     libvpx_test::ClearSystemState();\n   }\n \n  protected:\n   void ZeroTest();\n   void RefTest();\n+  void RefStrideTest();\n   void OneQuarterTest();\n \n-  ACMRandom rnd;\n-  uint8_t* src_;\n-  uint8_t* ref_;\n+  ACMRandom rnd_;\n+  uint8_t *src_;\n+  uint8_t *ref_;\n   int width_, log2width_;\n   int height_, log2height_;\n+  vpx_bit_depth_t bit_depth_;\n+  int mask_;\n+  bool use_high_bit_depth_;\n   int block_size_;\n   VarianceFunctionType variance_;\n };\n@@ -119,13 +279,28 @@\n\n template<typename VarianceFunctionType>\n void VarianceTest<VarianceFunctionType>::ZeroTest() {\n   for (int i = 0; i <= 255; ++i) {\n-    memset(src_, i, block_size_);\n+    if (!use_high_bit_depth_) {\n+      memset(src_, i, block_size_);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    } else {\n+      vpx_memset16(CONVERT_TO_SHORTPTR(src_), i << (bit_depth_ - 8),\n+                   block_size_);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+    }\n     for (int j = 0; j <= 255; ++j) {\n-      memset(ref_, j, block_size_);\n+      if (!use_high_bit_depth_) {\n+        memset(ref_, j, block_size_);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        vpx_memset16(CONVERT_TO_SHORTPTR(ref_), j  << (bit_depth_ - 8),\n+                     block_size_);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+      }\n       unsigned int sse;\n       unsigned int var;\n-      REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));\n-      EXPECT_EQ(0u, var) << \""src values: \"" << i << \""ref values: \"" << j;\n+      ASM_REGISTER_STATE_CHECK(\n+          var = variance_(src_, width_, ref_, width_, &sse));\n+      EXPECT_EQ(0u, var) << \""src values: \"" << i << \"" ref values: \"" << j;\n     }\n   }\n }\n@@ -134,14 +309,58 @@\n\n void VarianceTest<VarianceFunctionType>::RefTest() {\n   for (int i = 0; i < 10; ++i) {\n     for (int j = 0; j < block_size_; j++) {\n-      src_[j] = rnd.Rand8();\n-      ref_[j] = rnd.Rand8();\n+    if (!use_high_bit_depth_) {\n+      src_[j] = rnd_.Rand8();\n+      ref_[j] = rnd_.Rand8();\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    } else {\n+      CONVERT_TO_SHORTPTR(src_)[j] = rnd_.Rand16() && mask_;\n+      CONVERT_TO_SHORTPTR(ref_)[j] = rnd_.Rand16() && mask_;\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+    }\n     }\n     unsigned int sse1, sse2;\n     unsigned int var1;\n-    REGISTER_STATE_CHECK(var1 = variance_(src_, width_, ref_, width_, &sse1));\n+    const int stride_coeff = 1;\n+    ASM_REGISTER_STATE_CHECK(\n+        var1 = variance_(src_, width_, ref_, width_, &sse1));\n     const unsigned int var2 = variance_ref(src_, ref_, log2width_,\n-                                           log2height_, &sse2);\n+                                           log2height_, stride_coeff,\n+                                           stride_coeff, &sse2,\n+                                           use_high_bit_depth_, bit_depth_);\n+    EXPECT_EQ(sse1, sse2);\n+    EXPECT_EQ(var1, var2);\n+  }\n+}\n+\n+template<typename VarianceFunctionType>\n+void VarianceTest<VarianceFunctionType>::RefStrideTest() {\n+  for (int i = 0; i < 10; ++i) {\n+    int ref_stride_coeff = i % 2;\n+    int src_stride_coeff = (i >> 1) % 2;\n+    for (int j = 0; j < block_size_; j++) {\n+      int ref_ind = (j / width_) * ref_stride_coeff * width_ + j % width_;\n+      int src_ind = (j / width_) * src_stride_coeff * width_ + j % width_;\n+      if (!use_high_bit_depth_) {\n+        src_[src_ind] = rnd_.Rand8();\n+        ref_[ref_ind] = rnd_.Rand8();\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        CONVERT_TO_SHORTPTR(src_)[src_ind] = rnd_.Rand16() && mask_;\n+        CONVERT_TO_SHORTPTR(ref_)[ref_ind] = rnd_.Rand16() && mask_;\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+      }\n+    }\n+    unsigned int sse1, sse2;\n+    unsigned int var1;\n+\n+    ASM_REGISTER_STATE_CHECK(\n+        var1 = variance_(src_, width_ * src_stride_coeff,\n+                         ref_, width_ * ref_stride_coeff, &sse1));\n+    const unsigned int var2 = variance_ref(src_, ref_, log2width_,\n+                                           log2height_, src_stride_coeff,\n+                                           ref_stride_coeff, &sse2,\n+                                           use_high_bit_depth_, bit_depth_);\n     EXPECT_EQ(sse1, sse2);\n     EXPECT_EQ(var1, var2);\n   }\n@@ -149,561 +368,1673 @@\n\n \n template<typename VarianceFunctionType>\n void VarianceTest<VarianceFunctionType>::OneQuarterTest() {\n-  memset(src_, 255, block_size_);\n   const int half = block_size_ / 2;\n-  memset(ref_, 255, half);\n-  memset(ref_ + half, 0, half);\n+  if (!use_high_bit_depth_) {\n+    memset(src_, 255, block_size_);\n+    memset(ref_, 255, half);\n+    memset(ref_ + half, 0, half);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  } else {\n+    vpx_memset16(CONVERT_TO_SHORTPTR(src_), 255 << (bit_depth_ - 8),\n+                 block_size_);\n+    vpx_memset16(CONVERT_TO_SHORTPTR(ref_), 255 << (bit_depth_ - 8), half);\n+    vpx_memset16(CONVERT_TO_SHORTPTR(ref_) + half, 0, half);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+  }\n   unsigned int sse;\n   unsigned int var;\n-  REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));\n+  ASM_REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));\n   const unsigned int expected = block_size_ * 255 * 255 / 4;\n   EXPECT_EQ(expected, var);\n }\n \n-#if CONFIG_VP9_ENCODER\n-\n-unsigned int subpel_avg_variance_ref(const uint8_t *ref,\n-                                     const uint8_t *src,\n-                                     const uint8_t *second_pred,\n-                                     int l2w, int l2h,\n-                                     int xoff, int yoff,\n-                                     unsigned int *sse_ptr) {\n-  int se = 0;\n-  unsigned int sse = 0;\n-  const int w = 1 << l2w, h = 1 << l2h;\n-  for (int y = 0; y < h; y++) {\n-    for (int x = 0; x < w; x++) {\n-      // bilinear interpolation at a 16th pel step\n-      const int a1 = ref[(w + 1) * (y + 0) + x + 0];\n-      const int a2 = ref[(w + 1) * (y + 0) + x + 1];\n-      const int b1 = ref[(w + 1) * (y + 1) + x + 0];\n-      const int b2 = ref[(w + 1) * (y + 1) + x + 1];\n-      const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);\n-      const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);\n-      const int r = a + (((b - a) * yoff + 8) >> 4);\n-      int diff = ((r + second_pred[w * y + x] + 1) >> 1) - src[w * y + x];\n-      se += diff;\n-      sse += diff * diff;\n-    }\n-  }\n-  *sse_ptr = sse;\n-  return sse - (((int64_t) se * se) >> (l2w + l2h));\n-}\n-\n-template<typename SubpelVarianceFunctionType>\n-class SubpelVarianceTest\n-    : public ::testing::TestWithParam<tuple<int, int,\n-                                            SubpelVarianceFunctionType> > {\n+template<typename MseFunctionType>\n+class MseTest\n+    : public ::testing::TestWithParam<tuple<int, int, MseFunctionType> > {\n  public:\n   virtual void SetUp() {\n-    const tuple<int, int, SubpelVarianceFunctionType>& params =\n-        this->GetParam();\n+    const tuple<int, int, MseFunctionType>& params = this->GetParam();\n     log2width_  = get<0>(params);\n     width_ = 1 << log2width_;\n     log2height_ = get<1>(params);\n     height_ = 1 << log2height_;\n-    subpel_variance_ = get<2>(params);\n+    mse_ = get<2>(params);\n \n     rnd(ACMRandom::DeterministicSeed());\n     block_size_ = width_ * height_;\n     src_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));\n-    sec_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));\n-    ref_ = new uint8_t[block_size_ + width_ + height_ + 1];\n+    ref_ = new uint8_t[block_size_];\n     ASSERT_TRUE(src_ != NULL);\n-    ASSERT_TRUE(sec_ != NULL);\n     ASSERT_TRUE(ref_ != NULL);\n   }\n \n   virtual void TearDown() {\n     vpx_free(src_);\n     delete[] ref_;\n-    vpx_free(sec_);\n+    libvpx_test::ClearSystemState();\n+  }\n+\n+ protected:\n+  void RefTest_mse();\n+  void RefTest_sse();\n+  void MaxTest_mse();\n+  void MaxTest_sse();\n+\n+  ACMRandom rnd;\n+  uint8_t* src_;\n+  uint8_t* ref_;\n+  int width_, log2width_;\n+  int height_, log2height_;\n+  int block_size_;\n+  MseFunctionType mse_;\n+};\n+\n+template<typename MseFunctionType>\n+void MseTest<MseFunctionType>::RefTest_mse() {\n+  for (int i = 0; i < 10; ++i) {\n+    for (int j = 0; j < block_size_; j++) {\n+      src_[j] = rnd.Rand8();\n+      ref_[j] = rnd.Rand8();\n+    }\n+    unsigned int sse1, sse2;\n+    const int stride_coeff = 1;\n+    ASM_REGISTER_STATE_CHECK(mse_(src_, width_, ref_, width_, &sse1));\n+    variance_ref(src_, ref_, log2width_, log2height_, stride_coeff,\n+                 stride_coeff, &sse2, false, VPX_BITS_8);\n+    EXPECT_EQ(sse1, sse2);\n+  }\n+}\n+\n+template<typename MseFunctionType>\n+void MseTest<MseFunctionType>::RefTest_sse() {\n+  for (int i = 0; i < 10; ++i) {\n+    for (int j = 0; j < block_size_; j++) {\n+      src_[j] = rnd.Rand8();\n+      ref_[j] = rnd.Rand8();\n+    }\n+    unsigned int sse2;\n+    unsigned int var1;\n+    const int stride_coeff = 1;\n+    ASM_REGISTER_STATE_CHECK(var1 = mse_(src_, width_, ref_, width_));\n+    variance_ref(src_, ref_, log2width_, log2height_, stride_coeff,\n+                 stride_coeff, &sse2, false, VPX_BITS_8);\n+    EXPECT_EQ(var1, sse2);\n+  }\n+}\n+\n+template<typename MseFunctionType>\n+void MseTest<MseFunctionType>::MaxTest_mse() {\n+  memset(src_, 255, block_size_);\n+  memset(ref_, 0, block_size_);\n+  unsigned int sse;\n+  ASM_REGISTER_STATE_CHECK(mse_(src_, width_, ref_, width_, &sse));\n+  const unsigned int expected = block_size_ * 255 * 255;\n+  EXPECT_EQ(expected, sse);\n+}\n+\n+template<typename MseFunctionType>\n+void MseTest<MseFunctionType>::MaxTest_sse() {\n+  memset(src_, 255, block_size_);\n+  memset(ref_, 0, block_size_);\n+  unsigned int var;\n+  ASM_REGISTER_STATE_CHECK(var = mse_(src_, width_, ref_, width_));\n+  const unsigned int expected = block_size_ * 255 * 255;\n+  EXPECT_EQ(expected, var);\n+}\n+\n+static uint32_t subpel_avg_variance_ref(const uint8_t *ref,\n+                                        const uint8_t *src,\n+                                        const uint8_t *second_pred,\n+                                        int l2w, int l2h,\n+                                        int xoff, int yoff,\n+                                        uint32_t *sse_ptr,\n+                                        bool use_high_bit_depth,\n+                                        vpx_bit_depth_t bit_depth) {\n+  int64_t se = 0;\n+  uint64_t sse = 0;\n+  const int w = 1 << l2w;\n+  const int h = 1 << l2h;\n+\n+  xoff <<= 1;\n+  yoff <<= 1;\n+\n+  for (int y = 0; y < h; y++) {\n+    for (int x = 0; x < w; x++) {\n+      // bilinear interpolation at a 16th pel step\n+      if (!use_high_bit_depth) {\n+        const int a1 = ref[(w + 1) * (y + 0) + x + 0];\n+        const int a2 = ref[(w + 1) * (y + 0) + x + 1];\n+        const int b1 = ref[(w + 1) * (y + 1) + x + 0];\n+        const int b2 = ref[(w + 1) * (y + 1) + x + 1];\n+        const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);\n+        const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);\n+        const int r = a + (((b - a) * yoff + 8) >> 4);\n+        const int diff = ((r + second_pred[w * y + x] + 1) >> 1) - src[w * y + x];\n+        se += diff;\n+        sse += diff * diff;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        uint16_t *ref16 = CONVERT_TO_SHORTPTR(ref);\n+        uint16_t *src16 = CONVERT_TO_SHORTPTR(src);\n+        uint16_t *sec16   = CONVERT_TO_SHORTPTR(second_pred);\n+        const int a1 = ref16[(w + 1) * (y + 0) + x + 0];\n+        const int a2 = ref16[(w + 1) * (y + 0) + x + 1];\n+        const int b1 = ref16[(w + 1) * (y + 1) + x + 0];\n+        const int b2 = ref16[(w + 1) * (y + 1) + x + 1];\n+        const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);\n+        const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);\n+        const int r = a + (((b - a) * yoff + 8) >> 4);\n+        const int diff = ((r + sec16[w * y + x] + 1) >> 1) - src16[w * y + x];\n+        se += diff;\n+        sse += diff * diff;\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+      }\n+    }\n+  }\n+  RoundHighBitDepth(bit_depth, &se, &sse);\n+  *sse_ptr = static_cast<uint32_t>(sse);\n+  return static_cast<uint32_t>(sse -\n+                               ((static_cast<int64_t>(se) * se) >>\n+                                (l2w + l2h)));\n+}\n+\n+template<typename SubpelVarianceFunctionType>\n+class SubpelVarianceTest\n+    : public ::testing::TestWithParam<tuple<int, int,\n+                                            SubpelVarianceFunctionType, int> > {\n+ public:\n+  virtual void SetUp() {\n+    const tuple<int, int, SubpelVarianceFunctionType, int>& params =\n+        this->GetParam();\n+    log2width_  = get<0>(params);\n+    width_ = 1 << log2width_;\n+    log2height_ = get<1>(params);\n+    height_ = 1 << log2height_;\n+    subpel_variance_ = get<2>(params);\n+    if (get<3>(params)) {\n+      bit_depth_ = (vpx_bit_depth_t) get<3>(params);\n+      use_high_bit_depth_ = true;\n+    } else {\n+      bit_depth_ = VPX_BITS_8;\n+      use_high_bit_depth_ = false;\n+    }\n+    mask_ = (1 << bit_depth_)-1;\n+\n+    rnd_.Reset(ACMRandom::DeterministicSeed());\n+    block_size_ = width_ * height_;\n+    if (!use_high_bit_depth_) {\n+      src_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));\n+      sec_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));\n+      ref_ = new uint8_t[block_size_ + width_ + height_ + 1];\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    } else {\n+      src_ = CONVERT_TO_BYTEPTR(\n+          reinterpret_cast<uint16_t *>(\n+              vpx_memalign(16, block_size_*sizeof(uint16_t))));\n+      sec_ = CONVERT_TO_BYTEPTR(\n+          reinterpret_cast<uint16_t *>(\n+              vpx_memalign(16, block_size_*sizeof(uint16_t))));\n+      ref_ = CONVERT_TO_BYTEPTR(\n+          new uint16_t[block_size_ + width_ + height_ + 1]);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+    }\n+    ASSERT_TRUE(src_ != NULL);\n+    ASSERT_TRUE(sec_ != NULL);\n+    ASSERT_TRUE(ref_ != NULL);\n+  }\n+\n+  virtual void TearDown() {\n+    if (!use_high_bit_depth_) {\n+      vpx_free(src_);\n+      delete[] ref_;\n+      vpx_free(sec_);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    } else {\n+      vpx_free(CONVERT_TO_SHORTPTR(src_));\n+      delete[] CONVERT_TO_SHORTPTR(ref_);\n+      vpx_free(CONVERT_TO_SHORTPTR(sec_));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+    }\n     libvpx_test::ClearSystemState();\n   }\n \n  protected:\n   void RefTest();\n+  void ExtremeRefTest();\n \n-  ACMRandom rnd;\n+  ACMRandom rnd_;\n   uint8_t *src_;\n   uint8_t *ref_;\n   uint8_t *sec_;\n+  bool use_high_bit_depth_;\n+  vpx_bit_depth_t bit_depth_;\n   int width_, log2width_;\n   int height_, log2height_;\n-  int block_size_;\n+  int block_size_,  mask_;\n   SubpelVarianceFunctionType subpel_variance_;\n };\n \n template<typename SubpelVarianceFunctionType>\n void SubpelVarianceTest<SubpelVarianceFunctionType>::RefTest() {\n-  for (int x = 0; x < 16; ++x) {\n-    for (int y = 0; y < 16; ++y) {\n-      for (int j = 0; j < block_size_; j++) {\n-        src_[j] = rnd.Rand8();\n-      }\n-      for (int j = 0; j < block_size_ + width_ + height_ + 1; j++) {\n-        ref_[j] = rnd.Rand8();\n+  for (int x = 0; x < 8; ++x) {\n+    for (int y = 0; y < 8; ++y) {\n+      if (!use_high_bit_depth_) {\n+        for (int j = 0; j < block_size_; j++) {\n+          src_[j] = rnd_.Rand8();\n+        }\n+        for (int j = 0; j < block_size_ + width_ + height_ + 1; j++) {\n+          ref_[j] = rnd_.Rand8();\n+        }\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        for (int j = 0; j < block_size_; j++) {\n+          CONVERT_TO_SHORTPTR(src_)[j] = rnd_.Rand16() & mask_;\n+        }\n+        for (int j = 0; j < block_size_ + width_ + height_ + 1; j++) {\n+          CONVERT_TO_SHORTPTR(ref_)[j] = rnd_.Rand16() & mask_;\n+        }\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n       }\n       unsigned int sse1, sse2;\n       unsigned int var1;\n-      REGISTER_STATE_CHECK(var1 = subpel_variance_(ref_, width_ + 1, x, y,\n-                                                   src_, width_, &sse1));\n-      const unsigned int var2 = subpel_variance_ref(ref_, src_, log2width_,\n-                                                    log2height_, x, y, &sse2);\n+      ASM_REGISTER_STATE_CHECK(var1 = subpel_variance_(ref_, width_ + 1, x, y,\n+                                                       src_, width_, &sse1));\n+      const unsigned int var2 = subpel_variance_ref(ref_, src_,\n+                                                    log2width_, log2height_,\n+                                                    x, y, &sse2,\n+                                                    use_high_bit_depth_,\n+                                                    bit_depth_);\n       EXPECT_EQ(sse1, sse2) << \""at position \"" << x << \"", \"" << y;\n       EXPECT_EQ(var1, var2) << \""at position \"" << x << \"", \"" << y;\n     }\n   }\n }\n \n+template<typename SubpelVarianceFunctionType>\n+void SubpelVarianceTest<SubpelVarianceFunctionType>::ExtremeRefTest() {\n+  // Compare against reference.\n+  // Src: Set the first half of values to 0, the second half to the maximum.\n+  // Ref: Set the first half of values to the maximum, the second half to 0.\n+  for (int x = 0; x < 8; ++x) {\n+    for (int y = 0; y < 8; ++y) {\n+      const int half = block_size_ / 2;\n+      if (!use_high_bit_depth_) {\n+        memset(src_, 0, half);\n+        memset(src_ + half, 255, half);\n+        memset(ref_, 255, half);\n+        memset(ref_ + half, 0, half + width_ + height_ + 1);\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        vpx_memset16(CONVERT_TO_SHORTPTR(src_), mask_, half);\n+        vpx_memset16(CONVERT_TO_SHORTPTR(src_) + half, 0, half);\n+        vpx_memset16(CONVERT_TO_SHORTPTR(ref_), 0, half);\n+        vpx_memset16(CONVERT_TO_SHORTPTR(ref_) + half, mask_,\n+                     half + width_ + height_ + 1);\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+      }\n+      unsigned int sse1, sse2;\n+      unsigned int var1;\n+      ASM_REGISTER_STATE_CHECK(\n+          var1 = subpel_variance_(ref_, width_ + 1, x, y, src_, width_, &sse1));\n+      const unsigned int var2 =\n+          subpel_variance_ref(ref_, src_, log2width_, log2height_,\n+                              x, y, &sse2, use_high_bit_depth_, bit_depth_);\n+      EXPECT_EQ(sse1, sse2) << \""for xoffset \"" << x << \"" and yoffset \"" << y;\n+      EXPECT_EQ(var1, var2) << \""for xoffset \"" << x << \"" and yoffset \"" << y;\n+    }\n+  }\n+}\n+\n template<>\n-void SubpelVarianceTest<vp9_subp_avg_variance_fn_t>::RefTest() {\n-  for (int x = 0; x < 16; ++x) {\n-    for (int y = 0; y < 16; ++y) {\n-      for (int j = 0; j < block_size_; j++) {\n-        src_[j] = rnd.Rand8();\n-        sec_[j] = rnd.Rand8();\n-      }\n-      for (int j = 0; j < block_size_ + width_ + height_ + 1; j++) {\n-        ref_[j] = rnd.Rand8();\n+void SubpelVarianceTest<SubpixAvgVarMxNFunc>::RefTest() {\n+  for (int x = 0; x < 8; ++x) {\n+    for (int y = 0; y < 8; ++y) {\n+      if (!use_high_bit_depth_) {\n+        for (int j = 0; j < block_size_; j++) {\n+          src_[j] = rnd_.Rand8();\n+          sec_[j] = rnd_.Rand8();\n+        }\n+        for (int j = 0; j < block_size_ + width_ + height_ + 1; j++) {\n+          ref_[j] = rnd_.Rand8();\n+        }\n+#if CONFIG_VP9_HIGHBITDEPTH\n+      } else {\n+        for (int j = 0; j < block_size_; j++) {\n+          CONVERT_TO_SHORTPTR(src_)[j] = rnd_.Rand16() & mask_;\n+          CONVERT_TO_SHORTPTR(sec_)[j] = rnd_.Rand16() & mask_;\n+        }\n+        for (int j = 0; j < block_size_ + width_ + height_ + 1; j++) {\n+          CONVERT_TO_SHORTPTR(ref_)[j] = rnd_.Rand16() & mask_;\n+        }\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n       }\n       unsigned int sse1, sse2;\n       unsigned int var1;\n-      REGISTER_STATE_CHECK(var1 = subpel_variance_(ref_, width_ + 1, x, y,\n-                                                   src_, width_, &sse1, sec_));\n+      ASM_REGISTER_STATE_CHECK(\n+          var1 = subpel_variance_(ref_, width_ + 1, x, y,\n+                                  src_, width_, &sse1, sec_));\n       const unsigned int var2 = subpel_avg_variance_ref(ref_, src_, sec_,\n                                                         log2width_, log2height_,\n-                                                        x, y, &sse2);\n+                                                        x, y, &sse2,\n+                                                        use_high_bit_depth_,\n+                                                        bit_depth_);\n       EXPECT_EQ(sse1, sse2) << \""at position \"" << x << \"", \"" << y;\n       EXPECT_EQ(var1, var2) << \""at position \"" << x << \"", \"" << y;\n     }\n   }\n }\n \n-#endif  // CONFIG_VP9_ENCODER\n+typedef MseTest<Get4x4SseFunc> VpxSseTest;\n+typedef MseTest<VarianceMxNFunc> VpxMseTest;\n+typedef VarianceTest<VarianceMxNFunc> VpxVarianceTest;\n+typedef SubpelVarianceTest<SubpixVarMxNFunc> VpxSubpelVarianceTest;\n+typedef SubpelVarianceTest<SubpixAvgVarMxNFunc> VpxSubpelAvgVarianceTest;\n \n-// -----------------------------------------------------------------------------\n-// VP8 test cases.\n+TEST_P(VpxSseTest, Ref_sse) { RefTest_sse(); }\n+TEST_P(VpxSseTest, Max_sse) { MaxTest_sse(); }\n+TEST_P(VpxMseTest, Ref_mse) { RefTest_mse(); }\n+TEST_P(VpxMseTest, Max_mse) { MaxTest_mse(); }\n+TEST_P(VpxVarianceTest, Zero) { ZeroTest(); }\n+TEST_P(VpxVarianceTest, Ref) { RefTest(); }\n+TEST_P(VpxVarianceTest, RefStride) { RefStrideTest(); }\n+TEST_P(VpxVarianceTest, OneQuarter) { OneQuarterTest(); }\n+TEST_P(SumOfSquaresTest, Const) { ConstTest(); }\n+TEST_P(SumOfSquaresTest, Ref) { RefTest(); }\n+TEST_P(VpxSubpelVarianceTest, Ref) { RefTest(); }\n+TEST_P(VpxSubpelVarianceTest, ExtremeRef) { ExtremeRefTest(); }\n+TEST_P(VpxSubpelAvgVarianceTest, Ref) { RefTest(); }\n \n-namespace vp8 {\n+INSTANTIATE_TEST_CASE_P(C, SumOfSquaresTest,\n+                        ::testing::Values(vpx_get_mb_ss_c));\n \n-#if CONFIG_VP8_ENCODER\n-typedef VarianceTest<vp8_variance_fn_t> VP8VarianceTest;\n+const Get4x4SseFunc get4x4sse_cs_c = vpx_get4x4sse_cs_c;\n+INSTANTIATE_TEST_CASE_P(C, VpxSseTest,\n+                        ::testing::Values(make_tuple(2, 2, get4x4sse_cs_c)));\n \n-TEST_P(VP8VarianceTest, Zero) { ZeroTest(); }\n-TEST_P(VP8VarianceTest, Ref) { RefTest(); }\n-TEST_P(VP8VarianceTest, OneQuarter) { OneQuarterTest(); }\n+const VarianceMxNFunc mse16x16_c = vpx_mse16x16_c;\n+const VarianceMxNFunc mse16x8_c = vpx_mse16x8_c;\n+const VarianceMxNFunc mse8x16_c = vpx_mse8x16_c;\n+const VarianceMxNFunc mse8x8_c = vpx_mse8x8_c;\n+INSTANTIATE_TEST_CASE_P(C, VpxMseTest,\n+                        ::testing::Values(make_tuple(4, 4, mse16x16_c),\n+                                          make_tuple(4, 3, mse16x8_c),\n+                                          make_tuple(3, 4, mse8x16_c),\n+                                          make_tuple(3, 3, mse8x8_c)));\n \n-const vp8_variance_fn_t variance4x4_c = vp8_variance4x4_c;\n-const vp8_variance_fn_t variance8x8_c = vp8_variance8x8_c;\n-const vp8_variance_fn_t variance8x16_c = vp8_variance8x16_c;\n-const vp8_variance_fn_t variance16x8_c = vp8_variance16x8_c;\n-const vp8_variance_fn_t variance16x16_c = vp8_variance16x16_c;\n+const VarianceMxNFunc variance64x64_c = vpx_variance64x64_c;\n+const VarianceMxNFunc variance64x32_c = vpx_variance64x32_c;\n+const VarianceMxNFunc variance32x64_c = vpx_variance32x64_c;\n+const VarianceMxNFunc variance32x32_c = vpx_variance32x32_c;\n+const VarianceMxNFunc variance32x16_c = vpx_variance32x16_c;\n+const VarianceMxNFunc variance16x32_c = vpx_variance16x32_c;\n+const VarianceMxNFunc variance16x16_c = vpx_variance16x16_c;\n+const VarianceMxNFunc variance16x8_c = vpx_variance16x8_c;\n+const VarianceMxNFunc variance8x16_c = vpx_variance8x16_c;\n+const VarianceMxNFunc variance8x8_c = vpx_variance8x8_c;\n+const VarianceMxNFunc variance8x4_c = vpx_variance8x4_c;\n+const VarianceMxNFunc variance4x8_c = vpx_variance4x8_c;\n+const VarianceMxNFunc variance4x4_c = vpx_variance4x4_c;\n INSTANTIATE_TEST_CASE_P(\n-    C, VP8VarianceTest,\n-    ::testing::Values(make_tuple(2, 2, variance4x4_c),\n-                      make_tuple(3, 3, variance8x8_c),\n-                      make_tuple(3, 4, variance8x16_c),\n-                      make_tuple(4, 3, variance16x8_c),\n-                      make_tuple(4, 4, variance16x16_c)));\n+    C, VpxVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, variance64x64_c, 0),\n+                      make_tuple(6, 5, variance64x32_c, 0),\n+                      make_tuple(5, 6, variance32x64_c, 0),\n+                      make_tuple(5, 5, variance32x32_c, 0),\n+                      make_tuple(5, 4, variance32x16_c, 0),\n+                      make_tuple(4, 5, variance16x32_c, 0),\n+                      make_tuple(4, 4, variance16x16_c, 0),\n+                      make_tuple(4, 3, variance16x8_c, 0),\n+                      make_tuple(3, 4, variance8x16_c, 0),\n+                      make_tuple(3, 3, variance8x8_c, 0),\n+                      make_tuple(3, 2, variance8x4_c, 0),\n+                      make_tuple(2, 3, variance4x8_c, 0),\n+                      make_tuple(2, 2, variance4x4_c, 0)));\n \n-#if HAVE_NEON\n-const vp8_variance_fn_t variance8x8_neon = vp8_variance8x8_neon;\n-const vp8_variance_fn_t variance8x16_neon = vp8_variance8x16_neon;\n-const vp8_variance_fn_t variance16x8_neon = vp8_variance16x8_neon;\n-const vp8_variance_fn_t variance16x16_neon = vp8_variance16x16_neon;\n+const SubpixVarMxNFunc subpel_var64x64_c = vpx_sub_pixel_variance64x64_c;\n+const SubpixVarMxNFunc subpel_var64x32_c = vpx_sub_pixel_variance64x32_c;\n+const SubpixVarMxNFunc subpel_var32x64_c = vpx_sub_pixel_variance32x64_c;\n+const SubpixVarMxNFunc subpel_var32x32_c = vpx_sub_pixel_variance32x32_c;\n+const SubpixVarMxNFunc subpel_var32x16_c = vpx_sub_pixel_variance32x16_c;\n+const SubpixVarMxNFunc subpel_var16x32_c = vpx_sub_pixel_variance16x32_c;\n+const SubpixVarMxNFunc subpel_var16x16_c = vpx_sub_pixel_variance16x16_c;\n+const SubpixVarMxNFunc subpel_var16x8_c = vpx_sub_pixel_variance16x8_c;\n+const SubpixVarMxNFunc subpel_var8x16_c = vpx_sub_pixel_variance8x16_c;\n+const SubpixVarMxNFunc subpel_var8x8_c = vpx_sub_pixel_variance8x8_c;\n+const SubpixVarMxNFunc subpel_var8x4_c = vpx_sub_pixel_variance8x4_c;\n+const SubpixVarMxNFunc subpel_var4x8_c = vpx_sub_pixel_variance4x8_c;\n+const SubpixVarMxNFunc subpel_var4x4_c = vpx_sub_pixel_variance4x4_c;\n INSTANTIATE_TEST_CASE_P(\n-    NEON, VP8VarianceTest,\n-    ::testing::Values(make_tuple(3, 3, variance8x8_neon),\n-                      make_tuple(3, 4, variance8x16_neon),\n-                      make_tuple(4, 3, variance16x8_neon),\n-                      make_tuple(4, 4, variance16x16_neon)));\n-#endif\n+    C, VpxSubpelVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, subpel_var64x64_c, 0),\n+                      make_tuple(6, 5, subpel_var64x32_c, 0),\n+                      make_tuple(5, 6, subpel_var32x64_c, 0),\n+                      make_tuple(5, 5, subpel_var32x32_c, 0),\n+                      make_tuple(5, 4, subpel_var32x16_c, 0),\n+                      make_tuple(4, 5, subpel_var16x32_c, 0),\n+                      make_tuple(4, 4, subpel_var16x16_c, 0),\n+                      make_tuple(4, 3, subpel_var16x8_c, 0),\n+                      make_tuple(3, 4, subpel_var8x16_c, 0),\n+                      make_tuple(3, 3, subpel_var8x8_c, 0),\n+                      make_tuple(3, 2, subpel_var8x4_c, 0),\n+                      make_tuple(2, 3, subpel_var4x8_c, 0),\n+                      make_tuple(2, 2, subpel_var4x4_c, 0)));\n+\n+const SubpixAvgVarMxNFunc subpel_avg_var64x64_c =\n+    vpx_sub_pixel_avg_variance64x64_c;\n+const SubpixAvgVarMxNFunc subpel_avg_var64x32_c =\n+    vpx_sub_pixel_avg_variance64x32_c;\n+const SubpixAvgVarMxNFunc subpel_avg_var32x64_c =\n+    vpx_sub_pixel_avg_variance32x64_c;\n+const SubpixAvgVarMxNFunc subpel_avg_var32x32_c =\n+    vpx_sub_pixel_avg_variance32x32_c;\n+const SubpixAvgVarMxNFunc subpel_avg_var32x16_c =\n+    vpx_sub_pixel_avg_variance32x16_c;\n+const SubpixAvgVarMxNFunc subpel_avg_var16x32_c =\n+    vpx_sub_pixel_avg_variance16x32_c;\n+const SubpixAvgVarMxNFunc subpel_avg_var16x16_c =\n+    vpx_sub_pixel_avg_variance16x16_c;\n+const SubpixAvgVarMxNFunc subpel_avg_var16x8_c =\n+    vpx_sub_pixel_avg_variance16x8_c;\n+const SubpixAvgVarMxNFunc subpel_avg_var8x16_c =\n+    vpx_sub_pixel_avg_variance8x16_c;\n+const SubpixAvgVarMxNFunc subpel_avg_var8x8_c = vpx_sub_pixel_avg_variance8x8_c;\n+const SubpixAvgVarMxNFunc subpel_avg_var8x4_c = vpx_sub_pixel_avg_variance8x4_c;\n+const SubpixAvgVarMxNFunc subpel_avg_var4x8_c = vpx_sub_pixel_avg_variance4x8_c;\n+const SubpixAvgVarMxNFunc subpel_avg_var4x4_c = vpx_sub_pixel_avg_variance4x4_c;\n+INSTANTIATE_TEST_CASE_P(\n+    C, VpxSubpelAvgVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, subpel_avg_var64x64_c, 0),\n+                      make_tuple(6, 5, subpel_avg_var64x32_c, 0),\n+                      make_tuple(5, 6, subpel_avg_var32x64_c, 0),\n+                      make_tuple(5, 5, subpel_avg_var32x32_c, 0),\n+                      make_tuple(5, 4, subpel_avg_var32x16_c, 0),\n+                      make_tuple(4, 5, subpel_avg_var16x32_c, 0),\n+                      make_tuple(4, 4, subpel_avg_var16x16_c, 0),\n+                      make_tuple(4, 3, subpel_avg_var16x8_c, 0),\n+                      make_tuple(3, 4, subpel_avg_var8x16_c, 0),\n+                      make_tuple(3, 3, subpel_avg_var8x8_c, 0),\n+                      make_tuple(3, 2, subpel_avg_var8x4_c, 0),\n+                      make_tuple(2, 3, subpel_avg_var4x8_c, 0),\n+                      make_tuple(2, 2, subpel_avg_var4x4_c, 0)));\n+\n+#if CONFIG_VP9_HIGHBITDEPTH\n+typedef MseTest<VarianceMxNFunc> VpxHBDMseTest;\n+typedef VarianceTest<VarianceMxNFunc> VpxHBDVarianceTest;\n+typedef SubpelVarianceTest<SubpixVarMxNFunc> VpxHBDSubpelVarianceTest;\n+typedef SubpelVarianceTest<SubpixAvgVarMxNFunc>\n+    VpxHBDSubpelAvgVarianceTest;\n+\n+TEST_P(VpxHBDMseTest, Ref_mse) { RefTest_mse(); }\n+TEST_P(VpxHBDMseTest, Max_mse) { MaxTest_mse(); }\n+TEST_P(VpxHBDVarianceTest, Zero) { ZeroTest(); }\n+TEST_P(VpxHBDVarianceTest, Ref) { RefTest(); }\n+TEST_P(VpxHBDVarianceTest, RefStride) { RefStrideTest(); }\n+TEST_P(VpxHBDVarianceTest, OneQuarter) { OneQuarterTest(); }\n+TEST_P(VpxHBDSubpelVarianceTest, Ref) { RefTest(); }\n+TEST_P(VpxHBDSubpelVarianceTest, ExtremeRef) { ExtremeRefTest(); }\n+TEST_P(VpxHBDSubpelAvgVarianceTest, Ref) { RefTest(); }\n+\n+/* TODO(debargha): This test does not support the highbd version\n+const VarianceMxNFunc highbd_12_mse16x16_c = vpx_highbd_12_mse16x16_c;\n+const VarianceMxNFunc highbd_12_mse16x8_c = vpx_highbd_12_mse16x8_c;\n+const VarianceMxNFunc highbd_12_mse8x16_c = vpx_highbd_12_mse8x16_c;\n+const VarianceMxNFunc highbd_12_mse8x8_c = vpx_highbd_12_mse8x8_c;\n+\n+const VarianceMxNFunc highbd_10_mse16x16_c = vpx_highbd_10_mse16x16_c;\n+const VarianceMxNFunc highbd_10_mse16x8_c = vpx_highbd_10_mse16x8_c;\n+const VarianceMxNFunc highbd_10_mse8x16_c = vpx_highbd_10_mse8x16_c;\n+const VarianceMxNFunc highbd_10_mse8x8_c = vpx_highbd_10_mse8x8_c;\n+\n+const VarianceMxNFunc highbd_8_mse16x16_c = vpx_highbd_8_mse16x16_c;\n+const VarianceMxNFunc highbd_8_mse16x8_c = vpx_highbd_8_mse16x8_c;\n+const VarianceMxNFunc highbd_8_mse8x16_c = vpx_highbd_8_mse8x16_c;\n+const VarianceMxNFunc highbd_8_mse8x8_c = vpx_highbd_8_mse8x8_c;\n+INSTANTIATE_TEST_CASE_P(\n+    C, VpxHBDMseTest, ::testing::Values(make_tuple(4, 4, highbd_12_mse16x16_c),\n+                                        make_tuple(4, 4, highbd_12_mse16x8_c),\n+                                        make_tuple(4, 4, highbd_12_mse8x16_c),\n+                                        make_tuple(4, 4, highbd_12_mse8x8_c),\n+                                        make_tuple(4, 4, highbd_10_mse16x16_c),\n+                                        make_tuple(4, 4, highbd_10_mse16x8_c),\n+                                        make_tuple(4, 4, highbd_10_mse8x16_c),\n+                                        make_tuple(4, 4, highbd_10_mse8x8_c),\n+                                        make_tuple(4, 4, highbd_8_mse16x16_c),\n+                                        make_tuple(4, 4, highbd_8_mse16x8_c),\n+                                        make_tuple(4, 4, highbd_8_mse8x16_c),\n+                                        make_tuple(4, 4, highbd_8_mse8x8_c)));\n+*/\n+\n+const VarianceMxNFunc highbd_12_variance64x64_c = vpx_highbd_12_variance64x64_c;\n+const VarianceMxNFunc highbd_12_variance64x32_c = vpx_highbd_12_variance64x32_c;\n+const VarianceMxNFunc highbd_12_variance32x64_c = vpx_highbd_12_variance32x64_c;\n+const VarianceMxNFunc highbd_12_variance32x32_c = vpx_highbd_12_variance32x32_c;\n+const VarianceMxNFunc highbd_12_variance32x16_c = vpx_highbd_12_variance32x16_c;\n+const VarianceMxNFunc highbd_12_variance16x32_c = vpx_highbd_12_variance16x32_c;\n+const VarianceMxNFunc highbd_12_variance16x16_c = vpx_highbd_12_variance16x16_c;\n+const VarianceMxNFunc highbd_12_variance16x8_c = vpx_highbd_12_variance16x8_c;\n+const VarianceMxNFunc highbd_12_variance8x16_c = vpx_highbd_12_variance8x16_c;\n+const VarianceMxNFunc highbd_12_variance8x8_c = vpx_highbd_12_variance8x8_c;\n+const VarianceMxNFunc highbd_12_variance8x4_c = vpx_highbd_12_variance8x4_c;\n+const VarianceMxNFunc highbd_12_variance4x8_c = vpx_highbd_12_variance4x8_c;\n+const VarianceMxNFunc highbd_12_variance4x4_c = vpx_highbd_12_variance4x4_c;\n+const VarianceMxNFunc highbd_10_variance64x64_c = vpx_highbd_10_variance64x64_c;\n+const VarianceMxNFunc highbd_10_variance64x32_c = vpx_highbd_10_variance64x32_c;\n+const VarianceMxNFunc highbd_10_variance32x64_c = vpx_highbd_10_variance32x64_c;\n+const VarianceMxNFunc highbd_10_variance32x32_c = vpx_highbd_10_variance32x32_c;\n+const VarianceMxNFunc highbd_10_variance32x16_c = vpx_highbd_10_variance32x16_c;\n+const VarianceMxNFunc highbd_10_variance16x32_c = vpx_highbd_10_variance16x32_c;\n+const VarianceMxNFunc highbd_10_variance16x16_c = vpx_highbd_10_variance16x16_c;\n+const VarianceMxNFunc highbd_10_variance16x8_c = vpx_highbd_10_variance16x8_c;\n+const VarianceMxNFunc highbd_10_variance8x16_c = vpx_highbd_10_variance8x16_c;\n+const VarianceMxNFunc highbd_10_variance8x8_c = vpx_highbd_10_variance8x8_c;\n+const VarianceMxNFunc highbd_10_variance8x4_c = vpx_highbd_10_variance8x4_c;\n+const VarianceMxNFunc highbd_10_variance4x8_c = vpx_highbd_10_variance4x8_c;\n+const VarianceMxNFunc highbd_10_variance4x4_c = vpx_highbd_10_variance4x4_c;\n+const VarianceMxNFunc highbd_8_variance64x64_c = vpx_highbd_8_variance64x64_c;\n+const VarianceMxNFunc highbd_8_variance64x32_c = vpx_highbd_8_variance64x32_c;\n+const VarianceMxNFunc highbd_8_variance32x64_c = vpx_highbd_8_variance32x64_c;\n+const VarianceMxNFunc highbd_8_variance32x32_c = vpx_highbd_8_variance32x32_c;\n+const VarianceMxNFunc highbd_8_variance32x16_c = vpx_highbd_8_variance32x16_c;\n+const VarianceMxNFunc highbd_8_variance16x32_c = vpx_highbd_8_variance16x32_c;\n+const VarianceMxNFunc highbd_8_variance16x16_c = vpx_highbd_8_variance16x16_c;\n+const VarianceMxNFunc highbd_8_variance16x8_c = vpx_highbd_8_variance16x8_c;\n+const VarianceMxNFunc highbd_8_variance8x16_c = vpx_highbd_8_variance8x16_c;\n+const VarianceMxNFunc highbd_8_variance8x8_c = vpx_highbd_8_variance8x8_c;\n+const VarianceMxNFunc highbd_8_variance8x4_c = vpx_highbd_8_variance8x4_c;\n+const VarianceMxNFunc highbd_8_variance4x8_c = vpx_highbd_8_variance4x8_c;\n+const VarianceMxNFunc highbd_8_variance4x4_c = vpx_highbd_8_variance4x4_c;\n+INSTANTIATE_TEST_CASE_P(\n+    C, VpxHBDVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, highbd_12_variance64x64_c, 12),\n+                      make_tuple(6, 5, highbd_12_variance64x32_c, 12),\n+                      make_tuple(5, 6, highbd_12_variance32x64_c, 12),\n+                      make_tuple(5, 5, highbd_12_variance32x32_c, 12),\n+                      make_tuple(5, 4, highbd_12_variance32x16_c, 12),\n+                      make_tuple(4, 5, highbd_12_variance16x32_c, 12),\n+                      make_tuple(4, 4, highbd_12_variance16x16_c, 12),\n+                      make_tuple(4, 3, highbd_12_variance16x8_c, 12),\n+                      make_tuple(3, 4, highbd_12_variance8x16_c, 12),\n+                      make_tuple(3, 3, highbd_12_variance8x8_c, 12),\n+                      make_tuple(3, 2, highbd_12_variance8x4_c, 12),\n+                      make_tuple(2, 3, highbd_12_variance4x8_c, 12),\n+                      make_tuple(2, 2, highbd_12_variance4x4_c, 12),\n+                      make_tuple(6, 6, highbd_10_variance64x64_c, 10),\n+                      make_tuple(6, 5, highbd_10_variance64x32_c, 10),\n+                      make_tuple(5, 6, highbd_10_variance32x64_c, 10),\n+                      make_tuple(5, 5, highbd_10_variance32x32_c, 10),\n+                      make_tuple(5, 4, highbd_10_variance32x16_c, 10),\n+                      make_tuple(4, 5, highbd_10_variance16x32_c, 10),\n+                      make_tuple(4, 4, highbd_10_variance16x16_c, 10),\n+                      make_tuple(4, 3, highbd_10_variance16x8_c, 10),\n+                      make_tuple(3, 4, highbd_10_variance8x16_c, 10),\n+                      make_tuple(3, 3, highbd_10_variance8x8_c, 10),\n+                      make_tuple(3, 2, highbd_10_variance8x4_c, 10),\n+                      make_tuple(2, 3, highbd_10_variance4x8_c, 10),\n+                      make_tuple(2, 2, highbd_10_variance4x4_c, 10),\n+                      make_tuple(6, 6, highbd_8_variance64x64_c, 8),\n+                      make_tuple(6, 5, highbd_8_variance64x32_c, 8),\n+                      make_tuple(5, 6, highbd_8_variance32x64_c, 8),\n+                      make_tuple(5, 5, highbd_8_variance32x32_c, 8),\n+                      make_tuple(5, 4, highbd_8_variance32x16_c, 8),\n+                      make_tuple(4, 5, highbd_8_variance16x32_c, 8),\n+                      make_tuple(4, 4, highbd_8_variance16x16_c, 8),\n+                      make_tuple(4, 3, highbd_8_variance16x8_c, 8),\n+                      make_tuple(3, 4, highbd_8_variance8x16_c, 8),\n+                      make_tuple(3, 3, highbd_8_variance8x8_c, 8),\n+                      make_tuple(3, 2, highbd_8_variance8x4_c, 8),\n+                      make_tuple(2, 3, highbd_8_variance4x8_c, 8),\n+                      make_tuple(2, 2, highbd_8_variance4x4_c, 8)));\n+\n+const SubpixVarMxNFunc highbd_8_subpel_var64x64_c =\n+    vpx_highbd_8_sub_pixel_variance64x64_c;\n+const SubpixVarMxNFunc highbd_8_subpel_var64x32_c =\n+    vpx_highbd_8_sub_pixel_variance64x32_c;\n+const SubpixVarMxNFunc highbd_8_subpel_var32x64_c =\n+    vpx_highbd_8_sub_pixel_variance32x64_c;\n+const SubpixVarMxNFunc highbd_8_subpel_var32x32_c =\n+    vpx_highbd_8_sub_pixel_variance32x32_c;\n+const SubpixVarMxNFunc highbd_8_subpel_var32x16_c =\n+    vpx_highbd_8_sub_pixel_variance32x16_c;\n+const SubpixVarMxNFunc highbd_8_subpel_var16x32_c =\n+    vpx_highbd_8_sub_pixel_variance16x32_c;\n+const SubpixVarMxNFunc highbd_8_subpel_var16x16_c =\n+    vpx_highbd_8_sub_pixel_variance16x16_c;\n+const SubpixVarMxNFunc highbd_8_subpel_var16x8_c =\n+    vpx_highbd_8_sub_pixel_variance16x8_c;\n+const SubpixVarMxNFunc highbd_8_subpel_var8x16_c =\n+    vpx_highbd_8_sub_pixel_variance8x16_c;\n+const SubpixVarMxNFunc highbd_8_subpel_var8x8_c =\n+    vpx_highbd_8_sub_pixel_variance8x8_c;\n+const SubpixVarMxNFunc highbd_8_subpel_var8x4_c =\n+    vpx_highbd_8_sub_pixel_variance8x4_c;\n+const SubpixVarMxNFunc highbd_8_subpel_var4x8_c =\n+    vpx_highbd_8_sub_pixel_variance4x8_c;\n+const SubpixVarMxNFunc highbd_8_subpel_var4x4_c =\n+    vpx_highbd_8_sub_pixel_variance4x4_c;\n+const SubpixVarMxNFunc highbd_10_subpel_var64x64_c =\n+    vpx_highbd_10_sub_pixel_variance64x64_c;\n+const SubpixVarMxNFunc highbd_10_subpel_var64x32_c =\n+    vpx_highbd_10_sub_pixel_variance64x32_c;\n+const SubpixVarMxNFunc highbd_10_subpel_var32x64_c =\n+    vpx_highbd_10_sub_pixel_variance32x64_c;\n+const SubpixVarMxNFunc highbd_10_subpel_var32x32_c =\n+    vpx_highbd_10_sub_pixel_variance32x32_c;\n+const SubpixVarMxNFunc highbd_10_subpel_var32x16_c =\n+    vpx_highbd_10_sub_pixel_variance32x16_c;\n+const SubpixVarMxNFunc highbd_10_subpel_var16x32_c =\n+    vpx_highbd_10_sub_pixel_variance16x32_c;\n+const SubpixVarMxNFunc highbd_10_subpel_var16x16_c =\n+    vpx_highbd_10_sub_pixel_variance16x16_c;\n+const SubpixVarMxNFunc highbd_10_subpel_var16x8_c =\n+    vpx_highbd_10_sub_pixel_variance16x8_c;\n+const SubpixVarMxNFunc highbd_10_subpel_var8x16_c =\n+    vpx_highbd_10_sub_pixel_variance8x16_c;\n+const SubpixVarMxNFunc highbd_10_subpel_var8x8_c =\n+    vpx_highbd_10_sub_pixel_variance8x8_c;\n+const SubpixVarMxNFunc highbd_10_subpel_var8x4_c =\n+    vpx_highbd_10_sub_pixel_variance8x4_c;\n+const SubpixVarMxNFunc highbd_10_subpel_var4x8_c =\n+    vpx_highbd_10_sub_pixel_variance4x8_c;\n+const SubpixVarMxNFunc highbd_10_subpel_var4x4_c =\n+    vpx_highbd_10_sub_pixel_variance4x4_c;\n+const SubpixVarMxNFunc highbd_12_subpel_var64x64_c =\n+    vpx_highbd_12_sub_pixel_variance64x64_c;\n+const SubpixVarMxNFunc highbd_12_subpel_var64x32_c =\n+    vpx_highbd_12_sub_pixel_variance64x32_c;\n+const SubpixVarMxNFunc highbd_12_subpel_var32x64_c =\n+    vpx_highbd_12_sub_pixel_variance32x64_c;\n+const SubpixVarMxNFunc highbd_12_subpel_var32x32_c =\n+    vpx_highbd_12_sub_pixel_variance32x32_c;\n+const SubpixVarMxNFunc highbd_12_subpel_var32x16_c =\n+    vpx_highbd_12_sub_pixel_variance32x16_c;\n+const SubpixVarMxNFunc highbd_12_subpel_var16x32_c =\n+    vpx_highbd_12_sub_pixel_variance16x32_c;\n+const SubpixVarMxNFunc highbd_12_subpel_var16x16_c =\n+    vpx_highbd_12_sub_pixel_variance16x16_c;\n+const SubpixVarMxNFunc highbd_12_subpel_var16x8_c =\n+    vpx_highbd_12_sub_pixel_variance16x8_c;\n+const SubpixVarMxNFunc highbd_12_subpel_var8x16_c =\n+    vpx_highbd_12_sub_pixel_variance8x16_c;\n+const SubpixVarMxNFunc highbd_12_subpel_var8x8_c =\n+    vpx_highbd_12_sub_pixel_variance8x8_c;\n+const SubpixVarMxNFunc highbd_12_subpel_var8x4_c =\n+    vpx_highbd_12_sub_pixel_variance8x4_c;\n+const SubpixVarMxNFunc highbd_12_subpel_var4x8_c =\n+    vpx_highbd_12_sub_pixel_variance4x8_c;\n+const SubpixVarMxNFunc highbd_12_subpel_var4x4_c =\n+    vpx_highbd_12_sub_pixel_variance4x4_c;\n+INSTANTIATE_TEST_CASE_P(\n+    C, VpxHBDSubpelVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, highbd_8_subpel_var64x64_c, 8),\n+                      make_tuple(6, 5, highbd_8_subpel_var64x32_c, 8),\n+                      make_tuple(5, 6, highbd_8_subpel_var32x64_c, 8),\n+                      make_tuple(5, 5, highbd_8_subpel_var32x32_c, 8),\n+                      make_tuple(5, 4, highbd_8_subpel_var32x16_c, 8),\n+                      make_tuple(4, 5, highbd_8_subpel_var16x32_c, 8),\n+                      make_tuple(4, 4, highbd_8_subpel_var16x16_c, 8),\n+                      make_tuple(4, 3, highbd_8_subpel_var16x8_c, 8),\n+                      make_tuple(3, 4, highbd_8_subpel_var8x16_c, 8),\n+                      make_tuple(3, 3, highbd_8_subpel_var8x8_c, 8),\n+                      make_tuple(3, 2, highbd_8_subpel_var8x4_c, 8),\n+                      make_tuple(2, 3, highbd_8_subpel_var4x8_c, 8),\n+                      make_tuple(2, 2, highbd_8_subpel_var4x4_c, 8),\n+                      make_tuple(6, 6, highbd_10_subpel_var64x64_c, 10),\n+                      make_tuple(6, 5, highbd_10_subpel_var64x32_c, 10),\n+                      make_tuple(5, 6, highbd_10_subpel_var32x64_c, 10),\n+                      make_tuple(5, 5, highbd_10_subpel_var32x32_c, 10),\n+                      make_tuple(5, 4, highbd_10_subpel_var32x16_c, 10),\n+                      make_tuple(4, 5, highbd_10_subpel_var16x32_c, 10),\n+                      make_tuple(4, 4, highbd_10_subpel_var16x16_c, 10),\n+                      make_tuple(4, 3, highbd_10_subpel_var16x8_c, 10),\n+                      make_tuple(3, 4, highbd_10_subpel_var8x16_c, 10),\n+                      make_tuple(3, 3, highbd_10_subpel_var8x8_c, 10),\n+                      make_tuple(3, 2, highbd_10_subpel_var8x4_c, 10),\n+                      make_tuple(2, 3, highbd_10_subpel_var4x8_c, 10),\n+                      make_tuple(2, 2, highbd_10_subpel_var4x4_c, 10),\n+                      make_tuple(6, 6, highbd_12_subpel_var64x64_c, 12),\n+                      make_tuple(6, 5, highbd_12_subpel_var64x32_c, 12),\n+                      make_tuple(5, 6, highbd_12_subpel_var32x64_c, 12),\n+                      make_tuple(5, 5, highbd_12_subpel_var32x32_c, 12),\n+                      make_tuple(5, 4, highbd_12_subpel_var32x16_c, 12),\n+                      make_tuple(4, 5, highbd_12_subpel_var16x32_c, 12),\n+                      make_tuple(4, 4, highbd_12_subpel_var16x16_c, 12),\n+                      make_tuple(4, 3, highbd_12_subpel_var16x8_c, 12),\n+                      make_tuple(3, 4, highbd_12_subpel_var8x16_c, 12),\n+                      make_tuple(3, 3, highbd_12_subpel_var8x8_c, 12),\n+                      make_tuple(3, 2, highbd_12_subpel_var8x4_c, 12),\n+                      make_tuple(2, 3, highbd_12_subpel_var4x8_c, 12),\n+                      make_tuple(2, 2, highbd_12_subpel_var4x4_c, 12)));\n+\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_var64x64_c =\n+    vpx_highbd_8_sub_pixel_avg_variance64x64_c;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_var64x32_c =\n+    vpx_highbd_8_sub_pixel_avg_variance64x32_c;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_var32x64_c =\n+    vpx_highbd_8_sub_pixel_avg_variance32x64_c;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_var32x32_c =\n+    vpx_highbd_8_sub_pixel_avg_variance32x32_c;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_var32x16_c =\n+    vpx_highbd_8_sub_pixel_avg_variance32x16_c;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_var16x32_c =\n+    vpx_highbd_8_sub_pixel_avg_variance16x32_c;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_var16x16_c =\n+    vpx_highbd_8_sub_pixel_avg_variance16x16_c;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_var16x8_c =\n+    vpx_highbd_8_sub_pixel_avg_variance16x8_c;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_var8x16_c =\n+    vpx_highbd_8_sub_pixel_avg_variance8x16_c;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_var8x8_c =\n+    vpx_highbd_8_sub_pixel_avg_variance8x8_c;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_var8x4_c =\n+    vpx_highbd_8_sub_pixel_avg_variance8x4_c;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_var4x8_c =\n+    vpx_highbd_8_sub_pixel_avg_variance4x8_c;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_var4x4_c =\n+    vpx_highbd_8_sub_pixel_avg_variance4x4_c;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_var64x64_c =\n+    vpx_highbd_10_sub_pixel_avg_variance64x64_c;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_var64x32_c =\n+    vpx_highbd_10_sub_pixel_avg_variance64x32_c;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_var32x64_c =\n+    vpx_highbd_10_sub_pixel_avg_variance32x64_c;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_var32x32_c =\n+    vpx_highbd_10_sub_pixel_avg_variance32x32_c;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_var32x16_c =\n+    vpx_highbd_10_sub_pixel_avg_variance32x16_c;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_var16x32_c =\n+    vpx_highbd_10_sub_pixel_avg_variance16x32_c;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_var16x16_c =\n+    vpx_highbd_10_sub_pixel_avg_variance16x16_c;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_var16x8_c =\n+    vpx_highbd_10_sub_pixel_avg_variance16x8_c;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_var8x16_c =\n+    vpx_highbd_10_sub_pixel_avg_variance8x16_c;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_var8x8_c =\n+    vpx_highbd_10_sub_pixel_avg_variance8x8_c;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_var8x4_c =\n+    vpx_highbd_10_sub_pixel_avg_variance8x4_c;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_var4x8_c =\n+    vpx_highbd_10_sub_pixel_avg_variance4x8_c;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_var4x4_c =\n+    vpx_highbd_10_sub_pixel_avg_variance4x4_c;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_var64x64_c =\n+    vpx_highbd_12_sub_pixel_avg_variance64x64_c;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_var64x32_c =\n+    vpx_highbd_12_sub_pixel_avg_variance64x32_c;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_var32x64_c =\n+    vpx_highbd_12_sub_pixel_avg_variance32x64_c;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_var32x32_c =\n+    vpx_highbd_12_sub_pixel_avg_variance32x32_c;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_var32x16_c =\n+    vpx_highbd_12_sub_pixel_avg_variance32x16_c;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_var16x32_c =\n+    vpx_highbd_12_sub_pixel_avg_variance16x32_c;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_var16x16_c =\n+    vpx_highbd_12_sub_pixel_avg_variance16x16_c;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_var16x8_c =\n+    vpx_highbd_12_sub_pixel_avg_variance16x8_c;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_var8x16_c =\n+    vpx_highbd_12_sub_pixel_avg_variance8x16_c;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_var8x8_c =\n+    vpx_highbd_12_sub_pixel_avg_variance8x8_c;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_var8x4_c =\n+    vpx_highbd_12_sub_pixel_avg_variance8x4_c;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_var4x8_c =\n+    vpx_highbd_12_sub_pixel_avg_variance4x8_c;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_var4x4_c =\n+    vpx_highbd_12_sub_pixel_avg_variance4x4_c;\n+INSTANTIATE_TEST_CASE_P(\n+    C, VpxHBDSubpelAvgVarianceTest,\n+    ::testing::Values(\n+        make_tuple(6, 6, highbd_8_subpel_avg_var64x64_c, 8),\n+        make_tuple(6, 5, highbd_8_subpel_avg_var64x32_c, 8),\n+        make_tuple(5, 6, highbd_8_subpel_avg_var32x64_c, 8),\n+        make_tuple(5, 5, highbd_8_subpel_avg_var32x32_c, 8),\n+        make_tuple(5, 4, highbd_8_subpel_avg_var32x16_c, 8),\n+        make_tuple(4, 5, highbd_8_subpel_avg_var16x32_c, 8),\n+        make_tuple(4, 4, highbd_8_subpel_avg_var16x16_c, 8),\n+        make_tuple(4, 3, highbd_8_subpel_avg_var16x8_c, 8),\n+        make_tuple(3, 4, highbd_8_subpel_avg_var8x16_c, 8),\n+        make_tuple(3, 3, highbd_8_subpel_avg_var8x8_c, 8),\n+        make_tuple(3, 2, highbd_8_subpel_avg_var8x4_c, 8),\n+        make_tuple(2, 3, highbd_8_subpel_avg_var4x8_c, 8),\n+        make_tuple(2, 2, highbd_8_subpel_avg_var4x4_c, 8),\n+        make_tuple(6, 6, highbd_10_subpel_avg_var64x64_c, 10),\n+        make_tuple(6, 5, highbd_10_subpel_avg_var64x32_c, 10),\n+        make_tuple(5, 6, highbd_10_subpel_avg_var32x64_c, 10),\n+        make_tuple(5, 5, highbd_10_subpel_avg_var32x32_c, 10),\n+        make_tuple(5, 4, highbd_10_subpel_avg_var32x16_c, 10),\n+        make_tuple(4, 5, highbd_10_subpel_avg_var16x32_c, 10),\n+        make_tuple(4, 4, highbd_10_subpel_avg_var16x16_c, 10),\n+        make_tuple(4, 3, highbd_10_subpel_avg_var16x8_c, 10),\n+        make_tuple(3, 4, highbd_10_subpel_avg_var8x16_c, 10),\n+        make_tuple(3, 3, highbd_10_subpel_avg_var8x8_c, 10),\n+        make_tuple(3, 2, highbd_10_subpel_avg_var8x4_c, 10),\n+        make_tuple(2, 3, highbd_10_subpel_avg_var4x8_c, 10),\n+        make_tuple(2, 2, highbd_10_subpel_avg_var4x4_c, 10),\n+        make_tuple(6, 6, highbd_12_subpel_avg_var64x64_c, 12),\n+        make_tuple(6, 5, highbd_12_subpel_avg_var64x32_c, 12),\n+        make_tuple(5, 6, highbd_12_subpel_avg_var32x64_c, 12),\n+        make_tuple(5, 5, highbd_12_subpel_avg_var32x32_c, 12),\n+        make_tuple(5, 4, highbd_12_subpel_avg_var32x16_c, 12),\n+        make_tuple(4, 5, highbd_12_subpel_avg_var16x32_c, 12),\n+        make_tuple(4, 4, highbd_12_subpel_avg_var16x16_c, 12),\n+        make_tuple(4, 3, highbd_12_subpel_avg_var16x8_c, 12),\n+        make_tuple(3, 4, highbd_12_subpel_avg_var8x16_c, 12),\n+        make_tuple(3, 3, highbd_12_subpel_avg_var8x8_c, 12),\n+        make_tuple(3, 2, highbd_12_subpel_avg_var8x4_c, 12),\n+        make_tuple(2, 3, highbd_12_subpel_avg_var4x8_c, 12),\n+        make_tuple(2, 2, highbd_12_subpel_avg_var4x4_c, 12)));\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n \n #if HAVE_MMX\n-const vp8_variance_fn_t variance4x4_mmx = vp8_variance4x4_mmx;\n-const vp8_variance_fn_t variance8x8_mmx = vp8_variance8x8_mmx;\n-const vp8_variance_fn_t variance8x16_mmx = vp8_variance8x16_mmx;\n-const vp8_variance_fn_t variance16x8_mmx = vp8_variance16x8_mmx;\n-const vp8_variance_fn_t variance16x16_mmx = vp8_variance16x16_mmx;\n+const VarianceMxNFunc mse16x16_mmx = vpx_mse16x16_mmx;\n+INSTANTIATE_TEST_CASE_P(MMX, VpxMseTest,\n+                        ::testing::Values(make_tuple(4, 4, mse16x16_mmx)));\n+\n+INSTANTIATE_TEST_CASE_P(MMX, SumOfSquaresTest,\n+                        ::testing::Values(vpx_get_mb_ss_mmx));\n+\n+const VarianceMxNFunc variance16x16_mmx = vpx_variance16x16_mmx;\n+const VarianceMxNFunc variance16x8_mmx = vpx_variance16x8_mmx;\n+const VarianceMxNFunc variance8x16_mmx = vpx_variance8x16_mmx;\n+const VarianceMxNFunc variance8x8_mmx = vpx_variance8x8_mmx;\n+const VarianceMxNFunc variance4x4_mmx = vpx_variance4x4_mmx;\n INSTANTIATE_TEST_CASE_P(\n-    MMX, VP8VarianceTest,\n-    ::testing::Values(make_tuple(2, 2, variance4x4_mmx),\n-                      make_tuple(3, 3, variance8x8_mmx),\n-                      make_tuple(3, 4, variance8x16_mmx),\n-                      make_tuple(4, 3, variance16x8_mmx),\n-                      make_tuple(4, 4, variance16x16_mmx)));\n-#endif\n+    MMX, VpxVarianceTest,\n+    ::testing::Values(make_tuple(4, 4, variance16x16_mmx, 0),\n+                      make_tuple(4, 3, variance16x8_mmx, 0),\n+                      make_tuple(3, 4, variance8x16_mmx, 0),\n+                      make_tuple(3, 3, variance8x8_mmx, 0),\n+                      make_tuple(2, 2, variance4x4_mmx, 0)));\n+\n+const SubpixVarMxNFunc subpel_var16x16_mmx = vpx_sub_pixel_variance16x16_mmx;\n+const SubpixVarMxNFunc subpel_var16x8_mmx = vpx_sub_pixel_variance16x8_mmx;\n+const SubpixVarMxNFunc subpel_var8x16_mmx = vpx_sub_pixel_variance8x16_mmx;\n+const SubpixVarMxNFunc subpel_var8x8_mmx = vpx_sub_pixel_variance8x8_mmx;\n+const SubpixVarMxNFunc subpel_var4x4_mmx = vpx_sub_pixel_variance4x4_mmx;\n+INSTANTIATE_TEST_CASE_P(\n+    MMX, VpxSubpelVarianceTest,\n+    ::testing::Values(make_tuple(4, 4, subpel_var16x16_mmx, 0),\n+                      make_tuple(4, 3, subpel_var16x8_mmx, 0),\n+                      make_tuple(3, 4, subpel_var8x16_mmx, 0),\n+                      make_tuple(3, 3, subpel_var8x8_mmx, 0),\n+                      make_tuple(2, 2, subpel_var4x4_mmx, 0)));\n+#endif  // HAVE_MMX\n \n #if HAVE_SSE2\n-const vp8_variance_fn_t variance4x4_wmt = vp8_variance4x4_wmt;\n-const vp8_variance_fn_t variance8x8_wmt = vp8_variance8x8_wmt;\n-const vp8_variance_fn_t variance8x16_wmt = vp8_variance8x16_wmt;\n-const vp8_variance_fn_t variance16x8_wmt = vp8_variance16x8_wmt;\n-const vp8_variance_fn_t variance16x16_wmt = vp8_variance16x16_wmt;\n+INSTANTIATE_TEST_CASE_P(SSE2, SumOfSquaresTest,\n+                        ::testing::Values(vpx_get_mb_ss_sse2));\n+\n+const VarianceMxNFunc mse16x16_sse2 = vpx_mse16x16_sse2;\n+const VarianceMxNFunc mse16x8_sse2 = vpx_mse16x8_sse2;\n+const VarianceMxNFunc mse8x16_sse2 = vpx_mse8x16_sse2;\n+const VarianceMxNFunc mse8x8_sse2 = vpx_mse8x8_sse2;\n+INSTANTIATE_TEST_CASE_P(SSE2, VpxMseTest,\n+                        ::testing::Values(make_tuple(4, 4, mse16x16_sse2),\n+                                          make_tuple(4, 3, mse16x8_sse2),\n+                                          make_tuple(3, 4, mse8x16_sse2),\n+                                          make_tuple(3, 3, mse8x8_sse2)));\n+\n+const VarianceMxNFunc variance64x64_sse2 = vpx_variance64x64_sse2;\n+const VarianceMxNFunc variance64x32_sse2 = vpx_variance64x32_sse2;\n+const VarianceMxNFunc variance32x64_sse2 = vpx_variance32x64_sse2;\n+const VarianceMxNFunc variance32x32_sse2 = vpx_variance32x32_sse2;\n+const VarianceMxNFunc variance32x16_sse2 = vpx_variance32x16_sse2;\n+const VarianceMxNFunc variance16x32_sse2 = vpx_variance16x32_sse2;\n+const VarianceMxNFunc variance16x16_sse2 = vpx_variance16x16_sse2;\n+const VarianceMxNFunc variance16x8_sse2 = vpx_variance16x8_sse2;\n+const VarianceMxNFunc variance8x16_sse2 = vpx_variance8x16_sse2;\n+const VarianceMxNFunc variance8x8_sse2 = vpx_variance8x8_sse2;\n+const VarianceMxNFunc variance8x4_sse2 = vpx_variance8x4_sse2;\n+const VarianceMxNFunc variance4x8_sse2 = vpx_variance4x8_sse2;\n+const VarianceMxNFunc variance4x4_sse2 = vpx_variance4x4_sse2;\n INSTANTIATE_TEST_CASE_P(\n-    SSE2, VP8VarianceTest,\n-    ::testing::Values(make_tuple(2, 2, variance4x4_wmt),\n-                      make_tuple(3, 3, variance8x8_wmt),\n-                      make_tuple(3, 4, variance8x16_wmt),\n-                      make_tuple(4, 3, variance16x8_wmt),\n-                      make_tuple(4, 4, variance16x16_wmt)));\n-#endif\n-#endif  // CONFIG_VP8_ENCODER\n+    SSE2, VpxVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, variance64x64_sse2, 0),\n+                      make_tuple(6, 5, variance64x32_sse2, 0),\n+                      make_tuple(5, 6, variance32x64_sse2, 0),\n+                      make_tuple(5, 5, variance32x32_sse2, 0),\n+                      make_tuple(5, 4, variance32x16_sse2, 0),\n+                      make_tuple(4, 5, variance16x32_sse2, 0),\n+                      make_tuple(4, 4, variance16x16_sse2, 0),\n+                      make_tuple(4, 3, variance16x8_sse2, 0),\n+                      make_tuple(3, 4, variance8x16_sse2, 0),\n+                      make_tuple(3, 3, variance8x8_sse2, 0),\n+                      make_tuple(3, 2, variance8x4_sse2, 0),\n+                      make_tuple(2, 3, variance4x8_sse2, 0),\n+                      make_tuple(2, 2, variance4x4_sse2, 0)));\n \n-}  // namespace vp8\n-\n-// -----------------------------------------------------------------------------\n-// VP9 test cases.\n-\n-namespace vp9 {\n-\n-#if CONFIG_VP9_ENCODER\n-typedef VarianceTest<vp9_variance_fn_t> VP9VarianceTest;\n-typedef SubpelVarianceTest<vp9_subpixvariance_fn_t> VP9SubpelVarianceTest;\n-typedef SubpelVarianceTest<vp9_subp_avg_variance_fn_t> VP9SubpelAvgVarianceTest;\n-\n-TEST_P(VP9VarianceTest, Zero) { ZeroTest(); }\n-TEST_P(VP9VarianceTest, Ref) { RefTest(); }\n-TEST_P(VP9SubpelVarianceTest, Ref) { RefTest(); }\n-TEST_P(VP9SubpelAvgVarianceTest, Ref) { RefTest(); }\n-TEST_P(VP9VarianceTest, OneQuarter) { OneQuarterTest(); }\n-\n-const vp9_variance_fn_t variance4x4_c = vp9_variance4x4_c;\n-const vp9_variance_fn_t variance4x8_c = vp9_variance4x8_c;\n-const vp9_variance_fn_t variance8x4_c = vp9_variance8x4_c;\n-const vp9_variance_fn_t variance8x8_c = vp9_variance8x8_c;\n-const vp9_variance_fn_t variance8x16_c = vp9_variance8x16_c;\n-const vp9_variance_fn_t variance16x8_c = vp9_variance16x8_c;\n-const vp9_variance_fn_t variance16x16_c = vp9_variance16x16_c;\n-const vp9_variance_fn_t variance16x32_c = vp9_variance16x32_c;\n-const vp9_variance_fn_t variance32x16_c = vp9_variance32x16_c;\n-const vp9_variance_fn_t variance32x32_c = vp9_variance32x32_c;\n-const vp9_variance_fn_t variance32x64_c = vp9_variance32x64_c;\n-const vp9_variance_fn_t variance64x32_c = vp9_variance64x32_c;\n-const vp9_variance_fn_t variance64x64_c = vp9_variance64x64_c;\n-INSTANTIATE_TEST_CASE_P(\n-    C, VP9VarianceTest,\n-    ::testing::Values(make_tuple(2, 2, variance4x4_c),\n-                      make_tuple(2, 3, variance4x8_c),\n-                      make_tuple(3, 2, variance8x4_c),\n-                      make_tuple(3, 3, variance8x8_c),\n-                      make_tuple(3, 4, variance8x16_c),\n-                      make_tuple(4, 3, variance16x8_c),\n-                      make_tuple(4, 4, variance16x16_c),\n-                      make_tuple(4, 5, variance16x32_c),\n-                      make_tuple(5, 4, variance32x16_c),\n-                      make_tuple(5, 5, variance32x32_c),\n-                      make_tuple(5, 6, variance32x64_c),\n-                      make_tuple(6, 5, variance64x32_c),\n-                      make_tuple(6, 6, variance64x64_c)));\n-\n-const vp9_subpixvariance_fn_t subpel_variance4x4_c =\n-    vp9_sub_pixel_variance4x4_c;\n-const vp9_subpixvariance_fn_t subpel_variance4x8_c =\n-    vp9_sub_pixel_variance4x8_c;\n-const vp9_subpixvariance_fn_t subpel_variance8x4_c =\n-    vp9_sub_pixel_variance8x4_c;\n-const vp9_subpixvariance_fn_t subpel_variance8x8_c =\n-    vp9_sub_pixel_variance8x8_c;\n-const vp9_subpixvariance_fn_t subpel_variance8x16_c =\n-    vp9_sub_pixel_variance8x16_c;\n-const vp9_subpixvariance_fn_t subpel_variance16x8_c =\n-    vp9_sub_pixel_variance16x8_c;\n-const vp9_subpixvariance_fn_t subpel_variance16x16_c =\n-    vp9_sub_pixel_variance16x16_c;\n-const vp9_subpixvariance_fn_t subpel_variance16x32_c =\n-    vp9_sub_pixel_variance16x32_c;\n-const vp9_subpixvariance_fn_t subpel_variance32x16_c =\n-    vp9_sub_pixel_variance32x16_c;\n-const vp9_subpixvariance_fn_t subpel_variance32x32_c =\n-    vp9_sub_pixel_variance32x32_c;\n-const vp9_subpixvariance_fn_t subpel_variance32x64_c =\n-    vp9_sub_pixel_variance32x64_c;\n-const vp9_subpixvariance_fn_t subpel_variance64x32_c =\n-    vp9_sub_pixel_variance64x32_c;\n-const vp9_subpixvariance_fn_t subpel_variance64x64_c =\n-    vp9_sub_pixel_variance64x64_c;\n-INSTANTIATE_TEST_CASE_P(\n-    C, VP9SubpelVarianceTest,\n-    ::testing::Values(make_tuple(2, 2, subpel_variance4x4_c),\n-                      make_tuple(2, 3, subpel_variance4x8_c),\n-                      make_tuple(3, 2, subpel_variance8x4_c),\n-                      make_tuple(3, 3, subpel_variance8x8_c),\n-                      make_tuple(3, 4, subpel_variance8x16_c),\n-                      make_tuple(4, 3, subpel_variance16x8_c),\n-                      make_tuple(4, 4, subpel_variance16x16_c),\n-                      make_tuple(4, 5, subpel_variance16x32_c),\n-                      make_tuple(5, 4, subpel_variance32x16_c),\n-                      make_tuple(5, 5, subpel_variance32x32_c),\n-                      make_tuple(5, 6, subpel_variance32x64_c),\n-                      make_tuple(6, 5, subpel_variance64x32_c),\n-                      make_tuple(6, 6, subpel_variance64x64_c)));\n-\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance4x4_c =\n-    vp9_sub_pixel_avg_variance4x4_c;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance4x8_c =\n-    vp9_sub_pixel_avg_variance4x8_c;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance8x4_c =\n-    vp9_sub_pixel_avg_variance8x4_c;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance8x8_c =\n-    vp9_sub_pixel_avg_variance8x8_c;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance8x16_c =\n-    vp9_sub_pixel_avg_variance8x16_c;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance16x8_c =\n-    vp9_sub_pixel_avg_variance16x8_c;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance16x16_c =\n-    vp9_sub_pixel_avg_variance16x16_c;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance16x32_c =\n-    vp9_sub_pixel_avg_variance16x32_c;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance32x16_c =\n-    vp9_sub_pixel_avg_variance32x16_c;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance32x32_c =\n-    vp9_sub_pixel_avg_variance32x32_c;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance32x64_c =\n-    vp9_sub_pixel_avg_variance32x64_c;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance64x32_c =\n-    vp9_sub_pixel_avg_variance64x32_c;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance64x64_c =\n-    vp9_sub_pixel_avg_variance64x64_c;\n-INSTANTIATE_TEST_CASE_P(\n-    C, VP9SubpelAvgVarianceTest,\n-    ::testing::Values(make_tuple(2, 2, subpel_avg_variance4x4_c),\n-                      make_tuple(2, 3, subpel_avg_variance4x8_c),\n-                      make_tuple(3, 2, subpel_avg_variance8x4_c),\n-                      make_tuple(3, 3, subpel_avg_variance8x8_c),\n-                      make_tuple(3, 4, subpel_avg_variance8x16_c),\n-                      make_tuple(4, 3, subpel_avg_variance16x8_c),\n-                      make_tuple(4, 4, subpel_avg_variance16x16_c),\n-                      make_tuple(4, 5, subpel_avg_variance16x32_c),\n-                      make_tuple(5, 4, subpel_avg_variance32x16_c),\n-                      make_tuple(5, 5, subpel_avg_variance32x32_c),\n-                      make_tuple(5, 6, subpel_avg_variance32x64_c),\n-                      make_tuple(6, 5, subpel_avg_variance64x32_c),\n-                      make_tuple(6, 6, subpel_avg_variance64x64_c)));\n-\n-#if HAVE_MMX\n-const vp9_variance_fn_t variance4x4_mmx = vp9_variance4x4_mmx;\n-const vp9_variance_fn_t variance8x8_mmx = vp9_variance8x8_mmx;\n-const vp9_variance_fn_t variance8x16_mmx = vp9_variance8x16_mmx;\n-const vp9_variance_fn_t variance16x8_mmx = vp9_variance16x8_mmx;\n-const vp9_variance_fn_t variance16x16_mmx = vp9_variance16x16_mmx;\n-INSTANTIATE_TEST_CASE_P(\n-    MMX, VP9VarianceTest,\n-    ::testing::Values(make_tuple(2, 2, variance4x4_mmx),\n-                      make_tuple(3, 3, variance8x8_mmx),\n-                      make_tuple(3, 4, variance8x16_mmx),\n-                      make_tuple(4, 3, variance16x8_mmx),\n-                      make_tuple(4, 4, variance16x16_mmx)));\n-#endif\n-\n-#if HAVE_SSE2\n #if CONFIG_USE_X86INC\n-const vp9_variance_fn_t variance4x4_sse2 = vp9_variance4x4_sse2;\n-const vp9_variance_fn_t variance4x8_sse2 = vp9_variance4x8_sse2;\n-const vp9_variance_fn_t variance8x4_sse2 = vp9_variance8x4_sse2;\n-const vp9_variance_fn_t variance8x8_sse2 = vp9_variance8x8_sse2;\n-const vp9_variance_fn_t variance8x16_sse2 = vp9_variance8x16_sse2;\n-const vp9_variance_fn_t variance16x8_sse2 = vp9_variance16x8_sse2;\n-const vp9_variance_fn_t variance16x16_sse2 = vp9_variance16x16_sse2;\n-const vp9_variance_fn_t variance16x32_sse2 = vp9_variance16x32_sse2;\n-const vp9_variance_fn_t variance32x16_sse2 = vp9_variance32x16_sse2;\n-const vp9_variance_fn_t variance32x32_sse2 = vp9_variance32x32_sse2;\n-const vp9_variance_fn_t variance32x64_sse2 = vp9_variance32x64_sse2;\n-const vp9_variance_fn_t variance64x32_sse2 = vp9_variance64x32_sse2;\n-const vp9_variance_fn_t variance64x64_sse2 = vp9_variance64x64_sse2;\n+const SubpixVarMxNFunc subpel_variance64x64_sse2 =\n+    vpx_sub_pixel_variance64x64_sse2;\n+const SubpixVarMxNFunc subpel_variance64x32_sse2 =\n+    vpx_sub_pixel_variance64x32_sse2;\n+const SubpixVarMxNFunc subpel_variance32x64_sse2 =\n+    vpx_sub_pixel_variance32x64_sse2;\n+const SubpixVarMxNFunc subpel_variance32x32_sse2 =\n+    vpx_sub_pixel_variance32x32_sse2;\n+const SubpixVarMxNFunc subpel_variance32x16_sse2 =\n+    vpx_sub_pixel_variance32x16_sse2;\n+const SubpixVarMxNFunc subpel_variance16x32_sse2 =\n+    vpx_sub_pixel_variance16x32_sse2;\n+const SubpixVarMxNFunc subpel_variance16x16_sse2 =\n+    vpx_sub_pixel_variance16x16_sse2;\n+const SubpixVarMxNFunc subpel_variance16x8_sse2 =\n+    vpx_sub_pixel_variance16x8_sse2;\n+const SubpixVarMxNFunc subpel_variance8x16_sse2 =\n+    vpx_sub_pixel_variance8x16_sse2;\n+const SubpixVarMxNFunc subpel_variance8x8_sse2 = vpx_sub_pixel_variance8x8_sse2;\n+const SubpixVarMxNFunc subpel_variance8x4_sse2 = vpx_sub_pixel_variance8x4_sse2;\n+const SubpixVarMxNFunc subpel_variance4x8_sse = vpx_sub_pixel_variance4x8_sse;\n+const SubpixVarMxNFunc subpel_variance4x4_sse = vpx_sub_pixel_variance4x4_sse;\n INSTANTIATE_TEST_CASE_P(\n-    SSE2, VP9VarianceTest,\n-    ::testing::Values(make_tuple(2, 2, variance4x4_sse2),\n-                      make_tuple(2, 3, variance4x8_sse2),\n-                      make_tuple(3, 2, variance8x4_sse2),\n-                      make_tuple(3, 3, variance8x8_sse2),\n-                      make_tuple(3, 4, variance8x16_sse2),\n-                      make_tuple(4, 3, variance16x8_sse2),\n-                      make_tuple(4, 4, variance16x16_sse2),\n-                      make_tuple(4, 5, variance16x32_sse2),\n-                      make_tuple(5, 4, variance32x16_sse2),\n-                      make_tuple(5, 5, variance32x32_sse2),\n-                      make_tuple(5, 6, variance32x64_sse2),\n-                      make_tuple(6, 5, variance64x32_sse2),\n-                      make_tuple(6, 6, variance64x64_sse2)));\n+    SSE2, VpxSubpelVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, subpel_variance64x64_sse2, 0),\n+                      make_tuple(6, 5, subpel_variance64x32_sse2, 0),\n+                      make_tuple(5, 6, subpel_variance32x64_sse2, 0),\n+                      make_tuple(5, 5, subpel_variance32x32_sse2, 0),\n+                      make_tuple(5, 4, subpel_variance32x16_sse2, 0),\n+                      make_tuple(4, 5, subpel_variance16x32_sse2, 0),\n+                      make_tuple(4, 4, subpel_variance16x16_sse2, 0),\n+                      make_tuple(4, 3, subpel_variance16x8_sse2, 0),\n+                      make_tuple(3, 4, subpel_variance8x16_sse2, 0),\n+                      make_tuple(3, 3, subpel_variance8x8_sse2, 0),\n+                      make_tuple(3, 2, subpel_variance8x4_sse2, 0),\n+                      make_tuple(2, 3, subpel_variance4x8_sse, 0),\n+                      make_tuple(2, 2, subpel_variance4x4_sse, 0)));\n \n-const vp9_subpixvariance_fn_t subpel_variance4x4_sse =\n-    vp9_sub_pixel_variance4x4_sse;\n-const vp9_subpixvariance_fn_t subpel_variance4x8_sse =\n-    vp9_sub_pixel_variance4x8_sse;\n-const vp9_subpixvariance_fn_t subpel_variance8x4_sse2 =\n-    vp9_sub_pixel_variance8x4_sse2;\n-const vp9_subpixvariance_fn_t subpel_variance8x8_sse2 =\n-    vp9_sub_pixel_variance8x8_sse2;\n-const vp9_subpixvariance_fn_t subpel_variance8x16_sse2 =\n-    vp9_sub_pixel_variance8x16_sse2;\n-const vp9_subpixvariance_fn_t subpel_variance16x8_sse2 =\n-    vp9_sub_pixel_variance16x8_sse2;\n-const vp9_subpixvariance_fn_t subpel_variance16x16_sse2 =\n-    vp9_sub_pixel_variance16x16_sse2;\n-const vp9_subpixvariance_fn_t subpel_variance16x32_sse2 =\n-    vp9_sub_pixel_variance16x32_sse2;\n-const vp9_subpixvariance_fn_t subpel_variance32x16_sse2 =\n-    vp9_sub_pixel_variance32x16_sse2;\n-const vp9_subpixvariance_fn_t subpel_variance32x32_sse2 =\n-    vp9_sub_pixel_variance32x32_sse2;\n-const vp9_subpixvariance_fn_t subpel_variance32x64_sse2 =\n-    vp9_sub_pixel_variance32x64_sse2;\n-const vp9_subpixvariance_fn_t subpel_variance64x32_sse2 =\n-    vp9_sub_pixel_variance64x32_sse2;\n-const vp9_subpixvariance_fn_t subpel_variance64x64_sse2 =\n-    vp9_sub_pixel_variance64x64_sse2;\n+const SubpixAvgVarMxNFunc subpel_avg_variance64x64_sse2 =\n+    vpx_sub_pixel_avg_variance64x64_sse2;\n+const SubpixAvgVarMxNFunc subpel_avg_variance64x32_sse2 =\n+    vpx_sub_pixel_avg_variance64x32_sse2;\n+const SubpixAvgVarMxNFunc subpel_avg_variance32x64_sse2 =\n+    vpx_sub_pixel_avg_variance32x64_sse2;\n+const SubpixAvgVarMxNFunc subpel_avg_variance32x32_sse2 =\n+    vpx_sub_pixel_avg_variance32x32_sse2;\n+const SubpixAvgVarMxNFunc subpel_avg_variance32x16_sse2 =\n+    vpx_sub_pixel_avg_variance32x16_sse2;\n+const SubpixAvgVarMxNFunc subpel_avg_variance16x32_sse2 =\n+    vpx_sub_pixel_avg_variance16x32_sse2;\n+const SubpixAvgVarMxNFunc subpel_avg_variance16x16_sse2 =\n+    vpx_sub_pixel_avg_variance16x16_sse2;\n+const SubpixAvgVarMxNFunc subpel_avg_variance16x8_sse2 =\n+    vpx_sub_pixel_avg_variance16x8_sse2;\n+const SubpixAvgVarMxNFunc subpel_avg_variance8x16_sse2 =\n+    vpx_sub_pixel_avg_variance8x16_sse2;\n+const SubpixAvgVarMxNFunc subpel_avg_variance8x8_sse2 =\n+    vpx_sub_pixel_avg_variance8x8_sse2;\n+const SubpixAvgVarMxNFunc subpel_avg_variance8x4_sse2 =\n+    vpx_sub_pixel_avg_variance8x4_sse2;\n+const SubpixAvgVarMxNFunc subpel_avg_variance4x8_sse =\n+    vpx_sub_pixel_avg_variance4x8_sse;\n+const SubpixAvgVarMxNFunc subpel_avg_variance4x4_sse =\n+    vpx_sub_pixel_avg_variance4x4_sse;\n INSTANTIATE_TEST_CASE_P(\n-    SSE2, VP9SubpelVarianceTest,\n-    ::testing::Values(make_tuple(2, 2, subpel_variance4x4_sse),\n-                      make_tuple(2, 3, subpel_variance4x8_sse),\n-                      make_tuple(3, 2, subpel_variance8x4_sse2),\n-                      make_tuple(3, 3, subpel_variance8x8_sse2),\n-                      make_tuple(3, 4, subpel_variance8x16_sse2),\n-                      make_tuple(4, 3, subpel_variance16x8_sse2),\n-                      make_tuple(4, 4, subpel_variance16x16_sse2),\n-                      make_tuple(4, 5, subpel_variance16x32_sse2),\n-                      make_tuple(5, 4, subpel_variance32x16_sse2),\n-                      make_tuple(5, 5, subpel_variance32x32_sse2),\n-                      make_tuple(5, 6, subpel_variance32x64_sse2),\n-                      make_tuple(6, 5, subpel_variance64x32_sse2),\n-                      make_tuple(6, 6, subpel_variance64x64_sse2)));\n+    SSE2, VpxSubpelAvgVarianceTest,\n+    ::testing::Values(\n+                      make_tuple(6, 6, subpel_avg_variance64x64_sse2, 0),\n+                      make_tuple(6, 5, subpel_avg_variance64x32_sse2, 0),\n+                      make_tuple(5, 6, subpel_avg_variance32x64_sse2, 0),\n+                      make_tuple(5, 5, subpel_avg_variance32x32_sse2, 0),\n+                      make_tuple(5, 4, subpel_avg_variance32x16_sse2, 0),\n+                      make_tuple(4, 5, subpel_avg_variance16x32_sse2, 0),\n+                      make_tuple(4, 4, subpel_avg_variance16x16_sse2, 0),\n+                      make_tuple(4, 3, subpel_avg_variance16x8_sse2, 0),\n+                      make_tuple(3, 4, subpel_avg_variance8x16_sse2, 0),\n+                      make_tuple(3, 3, subpel_avg_variance8x8_sse2, 0),\n+                      make_tuple(3, 2, subpel_avg_variance8x4_sse2, 0),\n+                      make_tuple(2, 3, subpel_avg_variance4x8_sse, 0),\n+                      make_tuple(2, 2, subpel_avg_variance4x4_sse, 0)));\n+#endif  // CONFIG_USE_X86INC\n \n-const vp9_subp_avg_variance_fn_t subpel_avg_variance4x4_sse =\n-    vp9_sub_pixel_avg_variance4x4_sse;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance4x8_sse =\n-    vp9_sub_pixel_avg_variance4x8_sse;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance8x4_sse2 =\n-    vp9_sub_pixel_avg_variance8x4_sse2;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance8x8_sse2 =\n-    vp9_sub_pixel_avg_variance8x8_sse2;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance8x16_sse2 =\n-    vp9_sub_pixel_avg_variance8x16_sse2;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance16x8_sse2 =\n-    vp9_sub_pixel_avg_variance16x8_sse2;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance16x16_sse2 =\n-    vp9_sub_pixel_avg_variance16x16_sse2;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance16x32_sse2 =\n-    vp9_sub_pixel_avg_variance16x32_sse2;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance32x16_sse2 =\n-    vp9_sub_pixel_avg_variance32x16_sse2;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance32x32_sse2 =\n-    vp9_sub_pixel_avg_variance32x32_sse2;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance32x64_sse2 =\n-    vp9_sub_pixel_avg_variance32x64_sse2;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance64x32_sse2 =\n-    vp9_sub_pixel_avg_variance64x32_sse2;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance64x64_sse2 =\n-    vp9_sub_pixel_avg_variance64x64_sse2;\n+#if CONFIG_VP9_HIGHBITDEPTH\n+/* TODO(debargha): This test does not support the highbd version\n+const VarianceMxNFunc highbd_12_mse16x16_sse2 = vpx_highbd_12_mse16x16_sse2;\n+const VarianceMxNFunc highbd_12_mse16x8_sse2 = vpx_highbd_12_mse16x8_sse2;\n+const VarianceMxNFunc highbd_12_mse8x16_sse2 = vpx_highbd_12_mse8x16_sse2;\n+const VarianceMxNFunc highbd_12_mse8x8_sse2 = vpx_highbd_12_mse8x8_sse2;\n+\n+const VarianceMxNFunc highbd_10_mse16x16_sse2 = vpx_highbd_10_mse16x16_sse2;\n+const VarianceMxNFunc highbd_10_mse16x8_sse2 = vpx_highbd_10_mse16x8_sse2;\n+const VarianceMxNFunc highbd_10_mse8x16_sse2 = vpx_highbd_10_mse8x16_sse2;\n+const VarianceMxNFunc highbd_10_mse8x8_sse2 = vpx_highbd_10_mse8x8_sse2;\n+\n+const VarianceMxNFunc highbd_8_mse16x16_sse2 = vpx_highbd_8_mse16x16_sse2;\n+const VarianceMxNFunc highbd_8_mse16x8_sse2 = vpx_highbd_8_mse16x8_sse2;\n+const VarianceMxNFunc highbd_8_mse8x16_sse2 = vpx_highbd_8_mse8x16_sse2;\n+const VarianceMxNFunc highbd_8_mse8x8_sse2 = vpx_highbd_8_mse8x8_sse2;\n INSTANTIATE_TEST_CASE_P(\n-    SSE2, VP9SubpelAvgVarianceTest,\n-    ::testing::Values(make_tuple(2, 2, subpel_avg_variance4x4_sse),\n-                      make_tuple(2, 3, subpel_avg_variance4x8_sse),\n-                      make_tuple(3, 2, subpel_avg_variance8x4_sse2),\n-                      make_tuple(3, 3, subpel_avg_variance8x8_sse2),\n-                      make_tuple(3, 4, subpel_avg_variance8x16_sse2),\n-                      make_tuple(4, 3, subpel_avg_variance16x8_sse2),\n-                      make_tuple(4, 4, subpel_avg_variance16x16_sse2),\n-                      make_tuple(4, 5, subpel_avg_variance16x32_sse2),\n-                      make_tuple(5, 4, subpel_avg_variance32x16_sse2),\n-                      make_tuple(5, 5, subpel_avg_variance32x32_sse2),\n-                      make_tuple(5, 6, subpel_avg_variance32x64_sse2),\n-                      make_tuple(6, 5, subpel_avg_variance64x32_sse2),\n-                      make_tuple(6, 6, subpel_avg_variance64x64_sse2)));\n-#endif\n-#endif\n+    SSE2, VpxHBDMseTest, ::testing::Values(make_tuple(4, 4, highbd_12_mse16x16_sse2),\n+                                           make_tuple(4, 3, highbd_12_mse16x8_sse2),\n+                                           make_tuple(3, 4, highbd_12_mse8x16_sse2),\n+                                           make_tuple(3, 3, highbd_12_mse8x8_sse2),\n+                                           make_tuple(4, 4, highbd_10_mse16x16_sse2),\n+                                           make_tuple(4, 3, highbd_10_mse16x8_sse2),\n+                                           make_tuple(3, 4, highbd_10_mse8x16_sse2),\n+                                           make_tuple(3, 3, highbd_10_mse8x8_sse2),\n+                                           make_tuple(4, 4, highbd_8_mse16x16_sse2),\n+                                           make_tuple(4, 3, highbd_8_mse16x8_sse2),\n+                                           make_tuple(3, 4, highbd_8_mse8x16_sse2),\n+                                           make_tuple(3, 3, highbd_8_mse8x8_sse2)));\n+*/\n+\n+const VarianceMxNFunc highbd_12_variance64x64_sse2 =\n+    vpx_highbd_12_variance64x64_sse2;\n+const VarianceMxNFunc highbd_12_variance64x32_sse2 =\n+    vpx_highbd_12_variance64x32_sse2;\n+const VarianceMxNFunc highbd_12_variance32x64_sse2 =\n+    vpx_highbd_12_variance32x64_sse2;\n+const VarianceMxNFunc highbd_12_variance32x32_sse2 =\n+    vpx_highbd_12_variance32x32_sse2;\n+const VarianceMxNFunc highbd_12_variance32x16_sse2 =\n+    vpx_highbd_12_variance32x16_sse2;\n+const VarianceMxNFunc highbd_12_variance16x32_sse2 =\n+    vpx_highbd_12_variance16x32_sse2;\n+const VarianceMxNFunc highbd_12_variance16x16_sse2 =\n+    vpx_highbd_12_variance16x16_sse2;\n+const VarianceMxNFunc highbd_12_variance16x8_sse2 =\n+    vpx_highbd_12_variance16x8_sse2;\n+const VarianceMxNFunc highbd_12_variance8x16_sse2 =\n+    vpx_highbd_12_variance8x16_sse2;\n+const VarianceMxNFunc highbd_12_variance8x8_sse2 =\n+    vpx_highbd_12_variance8x8_sse2;\n+const VarianceMxNFunc highbd_10_variance64x64_sse2 =\n+    vpx_highbd_10_variance64x64_sse2;\n+const VarianceMxNFunc highbd_10_variance64x32_sse2 =\n+    vpx_highbd_10_variance64x32_sse2;\n+const VarianceMxNFunc highbd_10_variance32x64_sse2 =\n+    vpx_highbd_10_variance32x64_sse2;\n+const VarianceMxNFunc highbd_10_variance32x32_sse2 =\n+    vpx_highbd_10_variance32x32_sse2;\n+const VarianceMxNFunc highbd_10_variance32x16_sse2 =\n+    vpx_highbd_10_variance32x16_sse2;\n+const VarianceMxNFunc highbd_10_variance16x32_sse2 =\n+    vpx_highbd_10_variance16x32_sse2;\n+const VarianceMxNFunc highbd_10_variance16x16_sse2 =\n+    vpx_highbd_10_variance16x16_sse2;\n+const VarianceMxNFunc highbd_10_variance16x8_sse2 =\n+    vpx_highbd_10_variance16x8_sse2;\n+const VarianceMxNFunc highbd_10_variance8x16_sse2 =\n+    vpx_highbd_10_variance8x16_sse2;\n+const VarianceMxNFunc highbd_10_variance8x8_sse2 =\n+    vpx_highbd_10_variance8x8_sse2;\n+const VarianceMxNFunc highbd_8_variance64x64_sse2 =\n+    vpx_highbd_8_variance64x64_sse2;\n+const VarianceMxNFunc highbd_8_variance64x32_sse2 =\n+    vpx_highbd_8_variance64x32_sse2;\n+const VarianceMxNFunc highbd_8_variance32x64_sse2 =\n+    vpx_highbd_8_variance32x64_sse2;\n+const VarianceMxNFunc highbd_8_variance32x32_sse2 =\n+    vpx_highbd_8_variance32x32_sse2;\n+const VarianceMxNFunc highbd_8_variance32x16_sse2 =\n+    vpx_highbd_8_variance32x16_sse2;\n+const VarianceMxNFunc highbd_8_variance16x32_sse2 =\n+    vpx_highbd_8_variance16x32_sse2;\n+const VarianceMxNFunc highbd_8_variance16x16_sse2 =\n+    vpx_highbd_8_variance16x16_sse2;\n+const VarianceMxNFunc highbd_8_variance16x8_sse2 =\n+    vpx_highbd_8_variance16x8_sse2;\n+const VarianceMxNFunc highbd_8_variance8x16_sse2 =\n+    vpx_highbd_8_variance8x16_sse2;\n+const VarianceMxNFunc highbd_8_variance8x8_sse2 =\n+    vpx_highbd_8_variance8x8_sse2;\n+\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, VpxHBDVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, highbd_12_variance64x64_sse2, 12),\n+                      make_tuple(6, 5, highbd_12_variance64x32_sse2, 12),\n+                      make_tuple(5, 6, highbd_12_variance32x64_sse2, 12),\n+                      make_tuple(5, 5, highbd_12_variance32x32_sse2, 12),\n+                      make_tuple(5, 4, highbd_12_variance32x16_sse2, 12),\n+                      make_tuple(4, 5, highbd_12_variance16x32_sse2, 12),\n+                      make_tuple(4, 4, highbd_12_variance16x16_sse2, 12),\n+                      make_tuple(4, 3, highbd_12_variance16x8_sse2, 12),\n+                      make_tuple(3, 4, highbd_12_variance8x16_sse2, 12),\n+                      make_tuple(3, 3, highbd_12_variance8x8_sse2, 12),\n+                      make_tuple(6, 6, highbd_10_variance64x64_sse2, 10),\n+                      make_tuple(6, 5, highbd_10_variance64x32_sse2, 10),\n+                      make_tuple(5, 6, highbd_10_variance32x64_sse2, 10),\n+                      make_tuple(5, 5, highbd_10_variance32x32_sse2, 10),\n+                      make_tuple(5, 4, highbd_10_variance32x16_sse2, 10),\n+                      make_tuple(4, 5, highbd_10_variance16x32_sse2, 10),\n+                      make_tuple(4, 4, highbd_10_variance16x16_sse2, 10),\n+                      make_tuple(4, 3, highbd_10_variance16x8_sse2, 10),\n+                      make_tuple(3, 4, highbd_10_variance8x16_sse2, 10),\n+                      make_tuple(3, 3, highbd_10_variance8x8_sse2, 10),\n+                      make_tuple(6, 6, highbd_8_variance64x64_sse2, 8),\n+                      make_tuple(6, 5, highbd_8_variance64x32_sse2, 8),\n+                      make_tuple(5, 6, highbd_8_variance32x64_sse2, 8),\n+                      make_tuple(5, 5, highbd_8_variance32x32_sse2, 8),\n+                      make_tuple(5, 4, highbd_8_variance32x16_sse2, 8),\n+                      make_tuple(4, 5, highbd_8_variance16x32_sse2, 8),\n+                      make_tuple(4, 4, highbd_8_variance16x16_sse2, 8),\n+                      make_tuple(4, 3, highbd_8_variance16x8_sse2, 8),\n+                      make_tuple(3, 4, highbd_8_variance8x16_sse2, 8),\n+                      make_tuple(3, 3, highbd_8_variance8x8_sse2, 8)));\n+\n+#if CONFIG_USE_X86INC\n+const SubpixVarMxNFunc highbd_12_subpel_variance64x64_sse2 =\n+    vpx_highbd_12_sub_pixel_variance64x64_sse2;\n+const SubpixVarMxNFunc highbd_12_subpel_variance64x32_sse2 =\n+    vpx_highbd_12_sub_pixel_variance64x32_sse2;\n+const SubpixVarMxNFunc highbd_12_subpel_variance32x64_sse2 =\n+    vpx_highbd_12_sub_pixel_variance32x64_sse2;\n+const SubpixVarMxNFunc highbd_12_subpel_variance32x32_sse2 =\n+    vpx_highbd_12_sub_pixel_variance32x32_sse2;\n+const SubpixVarMxNFunc highbd_12_subpel_variance32x16_sse2 =\n+    vpx_highbd_12_sub_pixel_variance32x16_sse2;\n+const SubpixVarMxNFunc highbd_12_subpel_variance16x32_sse2 =\n+    vpx_highbd_12_sub_pixel_variance16x32_sse2;\n+const SubpixVarMxNFunc highbd_12_subpel_variance16x16_sse2 =\n+    vpx_highbd_12_sub_pixel_variance16x16_sse2;\n+const SubpixVarMxNFunc highbd_12_subpel_variance16x8_sse2 =\n+    vpx_highbd_12_sub_pixel_variance16x8_sse2;\n+const SubpixVarMxNFunc highbd_12_subpel_variance8x16_sse2 =\n+    vpx_highbd_12_sub_pixel_variance8x16_sse2;\n+const SubpixVarMxNFunc highbd_12_subpel_variance8x8_sse2 =\n+    vpx_highbd_12_sub_pixel_variance8x8_sse2;\n+const SubpixVarMxNFunc highbd_12_subpel_variance8x4_sse2 =\n+    vpx_highbd_12_sub_pixel_variance8x4_sse2;\n+const SubpixVarMxNFunc highbd_10_subpel_variance64x64_sse2 =\n+    vpx_highbd_10_sub_pixel_variance64x64_sse2;\n+const SubpixVarMxNFunc highbd_10_subpel_variance64x32_sse2 =\n+    vpx_highbd_10_sub_pixel_variance64x32_sse2;\n+const SubpixVarMxNFunc highbd_10_subpel_variance32x64_sse2 =\n+    vpx_highbd_10_sub_pixel_variance32x64_sse2;\n+const SubpixVarMxNFunc highbd_10_subpel_variance32x32_sse2 =\n+    vpx_highbd_10_sub_pixel_variance32x32_sse2;\n+const SubpixVarMxNFunc highbd_10_subpel_variance32x16_sse2 =\n+    vpx_highbd_10_sub_pixel_variance32x16_sse2;\n+const SubpixVarMxNFunc highbd_10_subpel_variance16x32_sse2 =\n+    vpx_highbd_10_sub_pixel_variance16x32_sse2;\n+const SubpixVarMxNFunc highbd_10_subpel_variance16x16_sse2 =\n+    vpx_highbd_10_sub_pixel_variance16x16_sse2;\n+const SubpixVarMxNFunc highbd_10_subpel_variance16x8_sse2 =\n+    vpx_highbd_10_sub_pixel_variance16x8_sse2;\n+const SubpixVarMxNFunc highbd_10_subpel_variance8x16_sse2 =\n+    vpx_highbd_10_sub_pixel_variance8x16_sse2;\n+const SubpixVarMxNFunc highbd_10_subpel_variance8x8_sse2 =\n+    vpx_highbd_10_sub_pixel_variance8x8_sse2;\n+const SubpixVarMxNFunc highbd_10_subpel_variance8x4_sse2 =\n+    vpx_highbd_10_sub_pixel_variance8x4_sse2;\n+const SubpixVarMxNFunc highbd_8_subpel_variance64x64_sse2 =\n+    vpx_highbd_8_sub_pixel_variance64x64_sse2;\n+const SubpixVarMxNFunc highbd_8_subpel_variance64x32_sse2 =\n+    vpx_highbd_8_sub_pixel_variance64x32_sse2;\n+const SubpixVarMxNFunc highbd_8_subpel_variance32x64_sse2 =\n+    vpx_highbd_8_sub_pixel_variance32x64_sse2;\n+const SubpixVarMxNFunc highbd_8_subpel_variance32x32_sse2 =\n+    vpx_highbd_8_sub_pixel_variance32x32_sse2;\n+const SubpixVarMxNFunc highbd_8_subpel_variance32x16_sse2 =\n+    vpx_highbd_8_sub_pixel_variance32x16_sse2;\n+const SubpixVarMxNFunc highbd_8_subpel_variance16x32_sse2 =\n+    vpx_highbd_8_sub_pixel_variance16x32_sse2;\n+const SubpixVarMxNFunc highbd_8_subpel_variance16x16_sse2 =\n+    vpx_highbd_8_sub_pixel_variance16x16_sse2;\n+const SubpixVarMxNFunc highbd_8_subpel_variance16x8_sse2 =\n+    vpx_highbd_8_sub_pixel_variance16x8_sse2;\n+const SubpixVarMxNFunc highbd_8_subpel_variance8x16_sse2 =\n+    vpx_highbd_8_sub_pixel_variance8x16_sse2;\n+const SubpixVarMxNFunc highbd_8_subpel_variance8x8_sse2 =\n+    vpx_highbd_8_sub_pixel_variance8x8_sse2;\n+const SubpixVarMxNFunc highbd_8_subpel_variance8x4_sse2 =\n+    vpx_highbd_8_sub_pixel_variance8x4_sse2;\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, VpxHBDSubpelVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, highbd_12_subpel_variance64x64_sse2, 12),\n+                      make_tuple(6, 5, highbd_12_subpel_variance64x32_sse2, 12),\n+                      make_tuple(5, 6, highbd_12_subpel_variance32x64_sse2, 12),\n+                      make_tuple(5, 5, highbd_12_subpel_variance32x32_sse2, 12),\n+                      make_tuple(5, 4, highbd_12_subpel_variance32x16_sse2, 12),\n+                      make_tuple(4, 5, highbd_12_subpel_variance16x32_sse2, 12),\n+                      make_tuple(4, 4, highbd_12_subpel_variance16x16_sse2, 12),\n+                      make_tuple(4, 3, highbd_12_subpel_variance16x8_sse2, 12),\n+                      make_tuple(3, 4, highbd_12_subpel_variance8x16_sse2, 12),\n+                      make_tuple(3, 3, highbd_12_subpel_variance8x8_sse2, 12),\n+                      make_tuple(3, 2, highbd_12_subpel_variance8x4_sse2, 12),\n+                      make_tuple(6, 6, highbd_10_subpel_variance64x64_sse2, 10),\n+                      make_tuple(6, 5, highbd_10_subpel_variance64x32_sse2, 10),\n+                      make_tuple(5, 6, highbd_10_subpel_variance32x64_sse2, 10),\n+                      make_tuple(5, 5, highbd_10_subpel_variance32x32_sse2, 10),\n+                      make_tuple(5, 4, highbd_10_subpel_variance32x16_sse2, 10),\n+                      make_tuple(4, 5, highbd_10_subpel_variance16x32_sse2, 10),\n+                      make_tuple(4, 4, highbd_10_subpel_variance16x16_sse2, 10),\n+                      make_tuple(4, 3, highbd_10_subpel_variance16x8_sse2, 10),\n+                      make_tuple(3, 4, highbd_10_subpel_variance8x16_sse2, 10),\n+                      make_tuple(3, 3, highbd_10_subpel_variance8x8_sse2, 10),\n+                      make_tuple(3, 2, highbd_10_subpel_variance8x4_sse2, 10),\n+                      make_tuple(6, 6, highbd_8_subpel_variance64x64_sse2, 8),\n+                      make_tuple(6, 5, highbd_8_subpel_variance64x32_sse2, 8),\n+                      make_tuple(5, 6, highbd_8_subpel_variance32x64_sse2, 8),\n+                      make_tuple(5, 5, highbd_8_subpel_variance32x32_sse2, 8),\n+                      make_tuple(5, 4, highbd_8_subpel_variance32x16_sse2, 8),\n+                      make_tuple(4, 5, highbd_8_subpel_variance16x32_sse2, 8),\n+                      make_tuple(4, 4, highbd_8_subpel_variance16x16_sse2, 8),\n+                      make_tuple(4, 3, highbd_8_subpel_variance16x8_sse2, 8),\n+                      make_tuple(3, 4, highbd_8_subpel_variance8x16_sse2, 8),\n+                      make_tuple(3, 3, highbd_8_subpel_variance8x8_sse2, 8),\n+                      make_tuple(3, 2, highbd_8_subpel_variance8x4_sse2, 8)));\n+\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_variance64x64_sse2 =\n+    vpx_highbd_12_sub_pixel_avg_variance64x64_sse2;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_variance64x32_sse2 =\n+    vpx_highbd_12_sub_pixel_avg_variance64x32_sse2;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_variance32x64_sse2 =\n+    vpx_highbd_12_sub_pixel_avg_variance32x64_sse2;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_variance32x32_sse2 =\n+    vpx_highbd_12_sub_pixel_avg_variance32x32_sse2;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_variance32x16_sse2 =\n+    vpx_highbd_12_sub_pixel_avg_variance32x16_sse2;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_variance16x32_sse2 =\n+    vpx_highbd_12_sub_pixel_avg_variance16x32_sse2;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_variance16x16_sse2 =\n+    vpx_highbd_12_sub_pixel_avg_variance16x16_sse2;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_variance16x8_sse2 =\n+    vpx_highbd_12_sub_pixel_avg_variance16x8_sse2;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_variance8x16_sse2 =\n+    vpx_highbd_12_sub_pixel_avg_variance8x16_sse2;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_variance8x8_sse2 =\n+    vpx_highbd_12_sub_pixel_avg_variance8x8_sse2;\n+const SubpixAvgVarMxNFunc highbd_12_subpel_avg_variance8x4_sse2 =\n+    vpx_highbd_12_sub_pixel_avg_variance8x4_sse2;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_variance64x64_sse2 =\n+    vpx_highbd_10_sub_pixel_avg_variance64x64_sse2;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_variance64x32_sse2 =\n+    vpx_highbd_10_sub_pixel_avg_variance64x32_sse2;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_variance32x64_sse2 =\n+    vpx_highbd_10_sub_pixel_avg_variance32x64_sse2;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_variance32x32_sse2 =\n+    vpx_highbd_10_sub_pixel_avg_variance32x32_sse2;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_variance32x16_sse2 =\n+    vpx_highbd_10_sub_pixel_avg_variance32x16_sse2;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_variance16x32_sse2 =\n+    vpx_highbd_10_sub_pixel_avg_variance16x32_sse2;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_variance16x16_sse2 =\n+    vpx_highbd_10_sub_pixel_avg_variance16x16_sse2;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_variance16x8_sse2 =\n+    vpx_highbd_10_sub_pixel_avg_variance16x8_sse2;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_variance8x16_sse2 =\n+    vpx_highbd_10_sub_pixel_avg_variance8x16_sse2;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_variance8x8_sse2 =\n+    vpx_highbd_10_sub_pixel_avg_variance8x8_sse2;\n+const SubpixAvgVarMxNFunc highbd_10_subpel_avg_variance8x4_sse2 =\n+    vpx_highbd_10_sub_pixel_avg_variance8x4_sse2;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_variance64x64_sse2 =\n+    vpx_highbd_8_sub_pixel_avg_variance64x64_sse2;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_variance64x32_sse2 =\n+    vpx_highbd_8_sub_pixel_avg_variance64x32_sse2;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_variance32x64_sse2 =\n+    vpx_highbd_8_sub_pixel_avg_variance32x64_sse2;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_variance32x32_sse2 =\n+    vpx_highbd_8_sub_pixel_avg_variance32x32_sse2;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_variance32x16_sse2 =\n+    vpx_highbd_8_sub_pixel_avg_variance32x16_sse2;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_variance16x32_sse2 =\n+    vpx_highbd_8_sub_pixel_avg_variance16x32_sse2;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_variance16x16_sse2 =\n+    vpx_highbd_8_sub_pixel_avg_variance16x16_sse2;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_variance16x8_sse2 =\n+    vpx_highbd_8_sub_pixel_avg_variance16x8_sse2;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_variance8x16_sse2 =\n+    vpx_highbd_8_sub_pixel_avg_variance8x16_sse2;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_variance8x8_sse2 =\n+    vpx_highbd_8_sub_pixel_avg_variance8x8_sse2;\n+const SubpixAvgVarMxNFunc highbd_8_subpel_avg_variance8x4_sse2 =\n+    vpx_highbd_8_sub_pixel_avg_variance8x4_sse2;\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, VpxHBDSubpelAvgVarianceTest,\n+    ::testing::Values(\n+        make_tuple(6, 6, highbd_12_subpel_avg_variance64x64_sse2, 12),\n+        make_tuple(6, 5, highbd_12_subpel_avg_variance64x32_sse2, 12),\n+        make_tuple(5, 6, highbd_12_subpel_avg_variance32x64_sse2, 12),\n+        make_tuple(5, 5, highbd_12_subpel_avg_variance32x32_sse2, 12),\n+        make_tuple(5, 4, highbd_12_subpel_avg_variance32x16_sse2, 12),\n+        make_tuple(4, 5, highbd_12_subpel_avg_variance16x32_sse2, 12),\n+        make_tuple(4, 4, highbd_12_subpel_avg_variance16x16_sse2, 12),\n+        make_tuple(4, 3, highbd_12_subpel_avg_variance16x8_sse2, 12),\n+        make_tuple(3, 4, highbd_12_subpel_avg_variance8x16_sse2, 12),\n+        make_tuple(3, 3, highbd_12_subpel_avg_variance8x8_sse2, 12),\n+        make_tuple(3, 2, highbd_12_subpel_avg_variance8x4_sse2, 12),\n+        make_tuple(6, 6, highbd_10_subpel_avg_variance64x64_sse2, 10),\n+        make_tuple(6, 5, highbd_10_subpel_avg_variance64x32_sse2, 10),\n+        make_tuple(5, 6, highbd_10_subpel_avg_variance32x64_sse2, 10),\n+        make_tuple(5, 5, highbd_10_subpel_avg_variance32x32_sse2, 10),\n+        make_tuple(5, 4, highbd_10_subpel_avg_variance32x16_sse2, 10),\n+        make_tuple(4, 5, highbd_10_subpel_avg_variance16x32_sse2, 10),\n+        make_tuple(4, 4, highbd_10_subpel_avg_variance16x16_sse2, 10),\n+        make_tuple(4, 3, highbd_10_subpel_avg_variance16x8_sse2, 10),\n+        make_tuple(3, 4, highbd_10_subpel_avg_variance8x16_sse2, 10),\n+        make_tuple(3, 3, highbd_10_subpel_avg_variance8x8_sse2, 10),\n+        make_tuple(3, 2, highbd_10_subpel_avg_variance8x4_sse2, 10),\n+        make_tuple(6, 6, highbd_8_subpel_avg_variance64x64_sse2, 8),\n+        make_tuple(6, 5, highbd_8_subpel_avg_variance64x32_sse2, 8),\n+        make_tuple(5, 6, highbd_8_subpel_avg_variance32x64_sse2, 8),\n+        make_tuple(5, 5, highbd_8_subpel_avg_variance32x32_sse2, 8),\n+        make_tuple(5, 4, highbd_8_subpel_avg_variance32x16_sse2, 8),\n+        make_tuple(4, 5, highbd_8_subpel_avg_variance16x32_sse2, 8),\n+        make_tuple(4, 4, highbd_8_subpel_avg_variance16x16_sse2, 8),\n+        make_tuple(4, 3, highbd_8_subpel_avg_variance16x8_sse2, 8),\n+        make_tuple(3, 4, highbd_8_subpel_avg_variance8x16_sse2, 8),\n+        make_tuple(3, 3, highbd_8_subpel_avg_variance8x8_sse2, 8),\n+        make_tuple(3, 2, highbd_8_subpel_avg_variance8x4_sse2, 8)));\n+#endif  // CONFIG_USE_X86INC\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+#endif  // HAVE_SSE2\n \n #if HAVE_SSSE3\n #if CONFIG_USE_X86INC\n-\n-const vp9_subpixvariance_fn_t subpel_variance4x4_ssse3 =\n-    vp9_sub_pixel_variance4x4_ssse3;\n-const vp9_subpixvariance_fn_t subpel_variance4x8_ssse3 =\n-    vp9_sub_pixel_variance4x8_ssse3;\n-const vp9_subpixvariance_fn_t subpel_variance8x4_ssse3 =\n-    vp9_sub_pixel_variance8x4_ssse3;\n-const vp9_subpixvariance_fn_t subpel_variance8x8_ssse3 =\n-    vp9_sub_pixel_variance8x8_ssse3;\n-const vp9_subpixvariance_fn_t subpel_variance8x16_ssse3 =\n-    vp9_sub_pixel_variance8x16_ssse3;\n-const vp9_subpixvariance_fn_t subpel_variance16x8_ssse3 =\n-    vp9_sub_pixel_variance16x8_ssse3;\n-const vp9_subpixvariance_fn_t subpel_variance16x16_ssse3 =\n-    vp9_sub_pixel_variance16x16_ssse3;\n-const vp9_subpixvariance_fn_t subpel_variance16x32_ssse3 =\n-    vp9_sub_pixel_variance16x32_ssse3;\n-const vp9_subpixvariance_fn_t subpel_variance32x16_ssse3 =\n-    vp9_sub_pixel_variance32x16_ssse3;\n-const vp9_subpixvariance_fn_t subpel_variance32x32_ssse3 =\n-    vp9_sub_pixel_variance32x32_ssse3;\n-const vp9_subpixvariance_fn_t subpel_variance32x64_ssse3 =\n-    vp9_sub_pixel_variance32x64_ssse3;\n-const vp9_subpixvariance_fn_t subpel_variance64x32_ssse3 =\n-    vp9_sub_pixel_variance64x32_ssse3;\n-const vp9_subpixvariance_fn_t subpel_variance64x64_ssse3 =\n-    vp9_sub_pixel_variance64x64_ssse3;\n+const SubpixVarMxNFunc subpel_variance64x64_ssse3 =\n+    vpx_sub_pixel_variance64x64_ssse3;\n+const SubpixVarMxNFunc subpel_variance64x32_ssse3 =\n+    vpx_sub_pixel_variance64x32_ssse3;\n+const SubpixVarMxNFunc subpel_variance32x64_ssse3 =\n+    vpx_sub_pixel_variance32x64_ssse3;\n+const SubpixVarMxNFunc subpel_variance32x32_ssse3 =\n+    vpx_sub_pixel_variance32x32_ssse3;\n+const SubpixVarMxNFunc subpel_variance32x16_ssse3 =\n+    vpx_sub_pixel_variance32x16_ssse3;\n+const SubpixVarMxNFunc subpel_variance16x32_ssse3 =\n+    vpx_sub_pixel_variance16x32_ssse3;\n+const SubpixVarMxNFunc subpel_variance16x16_ssse3 =\n+    vpx_sub_pixel_variance16x16_ssse3;\n+const SubpixVarMxNFunc subpel_variance16x8_ssse3 =\n+    vpx_sub_pixel_variance16x8_ssse3;\n+const SubpixVarMxNFunc subpel_variance8x16_ssse3 =\n+    vpx_sub_pixel_variance8x16_ssse3;\n+const SubpixVarMxNFunc subpel_variance8x8_ssse3 =\n+    vpx_sub_pixel_variance8x8_ssse3;\n+const SubpixVarMxNFunc subpel_variance8x4_ssse3 =\n+    vpx_sub_pixel_variance8x4_ssse3;\n+const SubpixVarMxNFunc subpel_variance4x8_ssse3 =\n+    vpx_sub_pixel_variance4x8_ssse3;\n+const SubpixVarMxNFunc subpel_variance4x4_ssse3 =\n+    vpx_sub_pixel_variance4x4_ssse3;\n INSTANTIATE_TEST_CASE_P(\n-    SSSE3, VP9SubpelVarianceTest,\n-    ::testing::Values(make_tuple(2, 2, subpel_variance4x4_ssse3),\n-                      make_tuple(2, 3, subpel_variance4x8_ssse3),\n-                      make_tuple(3, 2, subpel_variance8x4_ssse3),\n-                      make_tuple(3, 3, subpel_variance8x8_ssse3),\n-                      make_tuple(3, 4, subpel_variance8x16_ssse3),\n-                      make_tuple(4, 3, subpel_variance16x8_ssse3),\n-                      make_tuple(4, 4, subpel_variance16x16_ssse3),\n-                      make_tuple(4, 5, subpel_variance16x32_ssse3),\n-                      make_tuple(5, 4, subpel_variance32x16_ssse3),\n-                      make_tuple(5, 5, subpel_variance32x32_ssse3),\n-                      make_tuple(5, 6, subpel_variance32x64_ssse3),\n-                      make_tuple(6, 5, subpel_variance64x32_ssse3),\n-                      make_tuple(6, 6, subpel_variance64x64_ssse3)));\n+    SSSE3, VpxSubpelVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, subpel_variance64x64_ssse3, 0),\n+                      make_tuple(6, 5, subpel_variance64x32_ssse3, 0),\n+                      make_tuple(5, 6, subpel_variance32x64_ssse3, 0),\n+                      make_tuple(5, 5, subpel_variance32x32_ssse3, 0),\n+                      make_tuple(5, 4, subpel_variance32x16_ssse3, 0),\n+                      make_tuple(4, 5, subpel_variance16x32_ssse3, 0),\n+                      make_tuple(4, 4, subpel_variance16x16_ssse3, 0),\n+                      make_tuple(4, 3, subpel_variance16x8_ssse3, 0),\n+                      make_tuple(3, 4, subpel_variance8x16_ssse3, 0),\n+                      make_tuple(3, 3, subpel_variance8x8_ssse3, 0),\n+                      make_tuple(3, 2, subpel_variance8x4_ssse3, 0),\n+                      make_tuple(2, 3, subpel_variance4x8_ssse3, 0),\n+                      make_tuple(2, 2, subpel_variance4x4_ssse3, 0)));\n \n-const vp9_subp_avg_variance_fn_t subpel_avg_variance4x4_ssse3 =\n-    vp9_sub_pixel_avg_variance4x4_ssse3;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance4x8_ssse3 =\n-    vp9_sub_pixel_avg_variance4x8_ssse3;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance8x4_ssse3 =\n-    vp9_sub_pixel_avg_variance8x4_ssse3;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance8x8_ssse3 =\n-    vp9_sub_pixel_avg_variance8x8_ssse3;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance8x16_ssse3 =\n-    vp9_sub_pixel_avg_variance8x16_ssse3;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance16x8_ssse3 =\n-    vp9_sub_pixel_avg_variance16x8_ssse3;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance16x16_ssse3 =\n-    vp9_sub_pixel_avg_variance16x16_ssse3;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance16x32_ssse3 =\n-    vp9_sub_pixel_avg_variance16x32_ssse3;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance32x16_ssse3 =\n-    vp9_sub_pixel_avg_variance32x16_ssse3;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance32x32_ssse3 =\n-    vp9_sub_pixel_avg_variance32x32_ssse3;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance32x64_ssse3 =\n-    vp9_sub_pixel_avg_variance32x64_ssse3;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance64x32_ssse3 =\n-    vp9_sub_pixel_avg_variance64x32_ssse3;\n-const vp9_subp_avg_variance_fn_t subpel_avg_variance64x64_ssse3 =\n-    vp9_sub_pixel_avg_variance64x64_ssse3;\n+const SubpixAvgVarMxNFunc subpel_avg_variance64x64_ssse3 =\n+    vpx_sub_pixel_avg_variance64x64_ssse3;\n+const SubpixAvgVarMxNFunc subpel_avg_variance64x32_ssse3 =\n+    vpx_sub_pixel_avg_variance64x32_ssse3;\n+const SubpixAvgVarMxNFunc subpel_avg_variance32x64_ssse3 =\n+    vpx_sub_pixel_avg_variance32x64_ssse3;\n+const SubpixAvgVarMxNFunc subpel_avg_variance32x32_ssse3 =\n+    vpx_sub_pixel_avg_variance32x32_ssse3;\n+const SubpixAvgVarMxNFunc subpel_avg_variance32x16_ssse3 =\n+    vpx_sub_pixel_avg_variance32x16_ssse3;\n+const SubpixAvgVarMxNFunc subpel_avg_variance16x32_ssse3 =\n+    vpx_sub_pixel_avg_variance16x32_ssse3;\n+const SubpixAvgVarMxNFunc subpel_avg_variance16x16_ssse3 =\n+    vpx_sub_pixel_avg_variance16x16_ssse3;\n+const SubpixAvgVarMxNFunc subpel_avg_variance16x8_ssse3 =\n+    vpx_sub_pixel_avg_variance16x8_ssse3;\n+const SubpixAvgVarMxNFunc subpel_avg_variance8x16_ssse3 =\n+    vpx_sub_pixel_avg_variance8x16_ssse3;\n+const SubpixAvgVarMxNFunc subpel_avg_variance8x8_ssse3 =\n+    vpx_sub_pixel_avg_variance8x8_ssse3;\n+const SubpixAvgVarMxNFunc subpel_avg_variance8x4_ssse3 =\n+    vpx_sub_pixel_avg_variance8x4_ssse3;\n+const SubpixAvgVarMxNFunc subpel_avg_variance4x8_ssse3 =\n+    vpx_sub_pixel_avg_variance4x8_ssse3;\n+const SubpixAvgVarMxNFunc subpel_avg_variance4x4_ssse3 =\n+    vpx_sub_pixel_avg_variance4x4_ssse3;\n INSTANTIATE_TEST_CASE_P(\n-    SSSE3, VP9SubpelAvgVarianceTest,\n-    ::testing::Values(make_tuple(2, 2, subpel_avg_variance4x4_ssse3),\n-                      make_tuple(2, 3, subpel_avg_variance4x8_ssse3),\n-                      make_tuple(3, 2, subpel_avg_variance8x4_ssse3),\n-                      make_tuple(3, 3, subpel_avg_variance8x8_ssse3),\n-                      make_tuple(3, 4, subpel_avg_variance8x16_ssse3),\n-                      make_tuple(4, 3, subpel_avg_variance16x8_ssse3),\n-                      make_tuple(4, 4, subpel_avg_variance16x16_ssse3),\n-                      make_tuple(4, 5, subpel_avg_variance16x32_ssse3),\n-                      make_tuple(5, 4, subpel_avg_variance32x16_ssse3),\n-                      make_tuple(5, 5, subpel_avg_variance32x32_ssse3),\n-                      make_tuple(5, 6, subpel_avg_variance32x64_ssse3),\n-                      make_tuple(6, 5, subpel_avg_variance64x32_ssse3),\n-                      make_tuple(6, 6, subpel_avg_variance64x64_ssse3)));\n-#endif\n-#endif\n-#endif  // CONFIG_VP9_ENCODER\n+    SSSE3, VpxSubpelAvgVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, subpel_avg_variance64x64_ssse3, 0),\n+                      make_tuple(6, 5, subpel_avg_variance64x32_ssse3, 0),\n+                      make_tuple(5, 6, subpel_avg_variance32x64_ssse3, 0),\n+                      make_tuple(5, 5, subpel_avg_variance32x32_ssse3, 0),\n+                      make_tuple(5, 4, subpel_avg_variance32x16_ssse3, 0),\n+                      make_tuple(4, 5, subpel_avg_variance16x32_ssse3, 0),\n+                      make_tuple(4, 4, subpel_avg_variance16x16_ssse3, 0),\n+                      make_tuple(4, 3, subpel_avg_variance16x8_ssse3, 0),\n+                      make_tuple(3, 4, subpel_avg_variance8x16_ssse3, 0),\n+                      make_tuple(3, 3, subpel_avg_variance8x8_ssse3, 0),\n+                      make_tuple(3, 2, subpel_avg_variance8x4_ssse3, 0),\n+                      make_tuple(2, 3, subpel_avg_variance4x8_ssse3, 0),\n+                      make_tuple(2, 2, subpel_avg_variance4x4_ssse3, 0)));\n+#endif  // CONFIG_USE_X86INC\n+#endif  // HAVE_SSSE3\n \n-}  // namespace vp9\n+#if HAVE_AVX2\n+const VarianceMxNFunc mse16x16_avx2 = vpx_mse16x16_avx2;\n+INSTANTIATE_TEST_CASE_P(AVX2, VpxMseTest,\n+                        ::testing::Values(make_tuple(4, 4, mse16x16_avx2)));\n \n+const VarianceMxNFunc variance64x64_avx2 = vpx_variance64x64_avx2;\n+const VarianceMxNFunc variance64x32_avx2 = vpx_variance64x32_avx2;\n+const VarianceMxNFunc variance32x32_avx2 = vpx_variance32x32_avx2;\n+const VarianceMxNFunc variance32x16_avx2 = vpx_variance32x16_avx2;\n+const VarianceMxNFunc variance16x16_avx2 = vpx_variance16x16_avx2;\n+INSTANTIATE_TEST_CASE_P(\n+    AVX2, VpxVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, variance64x64_avx2, 0),\n+                      make_tuple(6, 5, variance64x32_avx2, 0),\n+                      make_tuple(5, 5, variance32x32_avx2, 0),\n+                      make_tuple(5, 4, variance32x16_avx2, 0),\n+                      make_tuple(4, 4, variance16x16_avx2, 0)));\n+\n+const SubpixVarMxNFunc subpel_variance64x64_avx2 =\n+    vpx_sub_pixel_variance64x64_avx2;\n+const SubpixVarMxNFunc subpel_variance32x32_avx2 =\n+    vpx_sub_pixel_variance32x32_avx2;\n+INSTANTIATE_TEST_CASE_P(\n+    AVX2, VpxSubpelVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, subpel_variance64x64_avx2, 0),\n+                      make_tuple(5, 5, subpel_variance32x32_avx2, 0)));\n+\n+const SubpixAvgVarMxNFunc subpel_avg_variance64x64_avx2 =\n+    vpx_sub_pixel_avg_variance64x64_avx2;\n+const SubpixAvgVarMxNFunc subpel_avg_variance32x32_avx2 =\n+    vpx_sub_pixel_avg_variance32x32_avx2;\n+INSTANTIATE_TEST_CASE_P(\n+    AVX2, VpxSubpelAvgVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, subpel_avg_variance64x64_avx2, 0),\n+                      make_tuple(5, 5, subpel_avg_variance32x32_avx2, 0)));\n+#endif  // HAVE_AVX2\n+\n+#if HAVE_MEDIA\n+const VarianceMxNFunc mse16x16_media = vpx_mse16x16_media;\n+INSTANTIATE_TEST_CASE_P(MEDIA, VpxMseTest,\n+                        ::testing::Values(make_tuple(4, 4, mse16x16_media)));\n+\n+const VarianceMxNFunc variance16x16_media = vpx_variance16x16_media;\n+const VarianceMxNFunc variance8x8_media = vpx_variance8x8_media;\n+INSTANTIATE_TEST_CASE_P(\n+    MEDIA, VpxVarianceTest,\n+    ::testing::Values(make_tuple(4, 4, variance16x16_media, 0),\n+                      make_tuple(3, 3, variance8x8_media, 0)));\n+\n+const SubpixVarMxNFunc subpel_variance16x16_media =\n+    vpx_sub_pixel_variance16x16_media;\n+const SubpixVarMxNFunc subpel_variance8x8_media =\n+    vpx_sub_pixel_variance8x8_media;\n+INSTANTIATE_TEST_CASE_P(\n+    MEDIA, VpxSubpelVarianceTest,\n+    ::testing::Values(make_tuple(4, 4, subpel_variance16x16_media, 0),\n+                      make_tuple(3, 3, subpel_variance8x8_media, 0)));\n+#endif  // HAVE_MEDIA\n+\n+#if HAVE_NEON\n+const Get4x4SseFunc get4x4sse_cs_neon = vpx_get4x4sse_cs_neon;\n+INSTANTIATE_TEST_CASE_P(NEON, VpxSseTest,\n+                        ::testing::Values(make_tuple(2, 2, get4x4sse_cs_neon)));\n+\n+const VarianceMxNFunc mse16x16_neon = vpx_mse16x16_neon;\n+INSTANTIATE_TEST_CASE_P(NEON, VpxMseTest,\n+                        ::testing::Values(make_tuple(4, 4, mse16x16_neon)));\n+\n+const VarianceMxNFunc variance64x64_neon = vpx_variance64x64_neon;\n+const VarianceMxNFunc variance64x32_neon = vpx_variance64x32_neon;\n+const VarianceMxNFunc variance32x64_neon = vpx_variance32x64_neon;\n+const VarianceMxNFunc variance32x32_neon = vpx_variance32x32_neon;\n+const VarianceMxNFunc variance16x16_neon = vpx_variance16x16_neon;\n+const VarianceMxNFunc variance16x8_neon = vpx_variance16x8_neon;\n+const VarianceMxNFunc variance8x16_neon = vpx_variance8x16_neon;\n+const VarianceMxNFunc variance8x8_neon = vpx_variance8x8_neon;\n+INSTANTIATE_TEST_CASE_P(\n+    NEON, VpxVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, variance64x64_neon, 0),\n+                      make_tuple(6, 5, variance64x32_neon, 0),\n+                      make_tuple(5, 6, variance32x64_neon, 0),\n+                      make_tuple(5, 5, variance32x32_neon, 0),\n+                      make_tuple(4, 4, variance16x16_neon, 0),\n+                      make_tuple(4, 3, variance16x8_neon, 0),\n+                      make_tuple(3, 4, variance8x16_neon, 0),\n+                      make_tuple(3, 3, variance8x8_neon, 0)));\n+\n+const SubpixVarMxNFunc subpel_variance64x64_neon =\n+    vpx_sub_pixel_variance64x64_neon;\n+const SubpixVarMxNFunc subpel_variance32x32_neon =\n+    vpx_sub_pixel_variance32x32_neon;\n+const SubpixVarMxNFunc subpel_variance16x16_neon =\n+    vpx_sub_pixel_variance16x16_neon;\n+const SubpixVarMxNFunc subpel_variance8x8_neon = vpx_sub_pixel_variance8x8_neon;\n+INSTANTIATE_TEST_CASE_P(\n+    NEON, VpxSubpelVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, subpel_variance64x64_neon, 0),\n+                      make_tuple(5, 5, subpel_variance32x32_neon, 0),\n+                      make_tuple(4, 4, subpel_variance16x16_neon, 0),\n+                      make_tuple(3, 3, subpel_variance8x8_neon, 0)));\n+#endif  // HAVE_NEON\n+\n+#if HAVE_MSA\n+INSTANTIATE_TEST_CASE_P(MSA, SumOfSquaresTest,\n+                        ::testing::Values(vpx_get_mb_ss_msa));\n+\n+const Get4x4SseFunc get4x4sse_cs_msa = vpx_get4x4sse_cs_msa;\n+INSTANTIATE_TEST_CASE_P(MSA, VpxSseTest,\n+                        ::testing::Values(make_tuple(2, 2, get4x4sse_cs_msa)));\n+\n+const VarianceMxNFunc mse16x16_msa = vpx_mse16x16_msa;\n+const VarianceMxNFunc mse16x8_msa = vpx_mse16x8_msa;\n+const VarianceMxNFunc mse8x16_msa = vpx_mse8x16_msa;\n+const VarianceMxNFunc mse8x8_msa = vpx_mse8x8_msa;\n+INSTANTIATE_TEST_CASE_P(MSA, VpxMseTest,\n+                        ::testing::Values(make_tuple(4, 4, mse16x16_msa),\n+                                          make_tuple(4, 3, mse16x8_msa),\n+                                          make_tuple(3, 4, mse8x16_msa),\n+                                          make_tuple(3, 3, mse8x8_msa)));\n+\n+const VarianceMxNFunc variance64x64_msa = vpx_variance64x64_msa;\n+const VarianceMxNFunc variance64x32_msa = vpx_variance64x32_msa;\n+const VarianceMxNFunc variance32x64_msa = vpx_variance32x64_msa;\n+const VarianceMxNFunc variance32x32_msa = vpx_variance32x32_msa;\n+const VarianceMxNFunc variance32x16_msa = vpx_variance32x16_msa;\n+const VarianceMxNFunc variance16x32_msa = vpx_variance16x32_msa;\n+const VarianceMxNFunc variance16x16_msa = vpx_variance16x16_msa;\n+const VarianceMxNFunc variance16x8_msa = vpx_variance16x8_msa;\n+const VarianceMxNFunc variance8x16_msa = vpx_variance8x16_msa;\n+const VarianceMxNFunc variance8x8_msa = vpx_variance8x8_msa;\n+const VarianceMxNFunc variance8x4_msa = vpx_variance8x4_msa;\n+const VarianceMxNFunc variance4x8_msa = vpx_variance4x8_msa;\n+const VarianceMxNFunc variance4x4_msa = vpx_variance4x4_msa;\n+INSTANTIATE_TEST_CASE_P(\n+    MSA, VpxVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, variance64x64_msa, 0),\n+                      make_tuple(6, 5, variance64x32_msa, 0),\n+                      make_tuple(5, 6, variance32x64_msa, 0),\n+                      make_tuple(5, 5, variance32x32_msa, 0),\n+                      make_tuple(5, 4, variance32x16_msa, 0),\n+                      make_tuple(4, 5, variance16x32_msa, 0),\n+                      make_tuple(4, 4, variance16x16_msa, 0),\n+                      make_tuple(4, 3, variance16x8_msa, 0),\n+                      make_tuple(3, 4, variance8x16_msa, 0),\n+                      make_tuple(3, 3, variance8x8_msa, 0),\n+                      make_tuple(3, 2, variance8x4_msa, 0),\n+                      make_tuple(2, 3, variance4x8_msa, 0),\n+                      make_tuple(2, 2, variance4x4_msa, 0)));\n+\n+const SubpixVarMxNFunc subpel_variance4x4_msa = vpx_sub_pixel_variance4x4_msa;\n+const SubpixVarMxNFunc subpel_variance4x8_msa = vpx_sub_pixel_variance4x8_msa;\n+const SubpixVarMxNFunc subpel_variance8x4_msa = vpx_sub_pixel_variance8x4_msa;\n+const SubpixVarMxNFunc subpel_variance8x8_msa = vpx_sub_pixel_variance8x8_msa;\n+const SubpixVarMxNFunc subpel_variance8x16_msa = vpx_sub_pixel_variance8x16_msa;\n+const SubpixVarMxNFunc subpel_variance16x8_msa = vpx_sub_pixel_variance16x8_msa;\n+const SubpixVarMxNFunc subpel_variance16x16_msa =\n+    vpx_sub_pixel_variance16x16_msa;\n+const SubpixVarMxNFunc subpel_variance16x32_msa =\n+    vpx_sub_pixel_variance16x32_msa;\n+const SubpixVarMxNFunc subpel_variance32x16_msa =\n+    vpx_sub_pixel_variance32x16_msa;\n+const SubpixVarMxNFunc subpel_variance32x32_msa =\n+    vpx_sub_pixel_variance32x32_msa;\n+const SubpixVarMxNFunc subpel_variance32x64_msa =\n+    vpx_sub_pixel_variance32x64_msa;\n+const SubpixVarMxNFunc subpel_variance64x32_msa =\n+    vpx_sub_pixel_variance64x32_msa;\n+const SubpixVarMxNFunc subpel_variance64x64_msa =\n+    vpx_sub_pixel_variance64x64_msa;\n+INSTANTIATE_TEST_CASE_P(\n+    MSA, VpxSubpelVarianceTest,\n+    ::testing::Values(make_tuple(2, 2, subpel_variance4x4_msa, 0),\n+                      make_tuple(2, 3, subpel_variance4x8_msa, 0),\n+                      make_tuple(3, 2, subpel_variance8x4_msa, 0),\n+                      make_tuple(3, 3, subpel_variance8x8_msa, 0),\n+                      make_tuple(3, 4, subpel_variance8x16_msa, 0),\n+                      make_tuple(4, 3, subpel_variance16x8_msa, 0),\n+                      make_tuple(4, 4, subpel_variance16x16_msa, 0),\n+                      make_tuple(4, 5, subpel_variance16x32_msa, 0),\n+                      make_tuple(5, 4, subpel_variance32x16_msa, 0),\n+                      make_tuple(5, 5, subpel_variance32x32_msa, 0),\n+                      make_tuple(5, 6, subpel_variance32x64_msa, 0),\n+                      make_tuple(6, 5, subpel_variance64x32_msa, 0),\n+                      make_tuple(6, 6, subpel_variance64x64_msa, 0)));\n+\n+const SubpixAvgVarMxNFunc subpel_avg_variance64x64_msa =\n+    vpx_sub_pixel_avg_variance64x64_msa;\n+const SubpixAvgVarMxNFunc subpel_avg_variance64x32_msa =\n+    vpx_sub_pixel_avg_variance64x32_msa;\n+const SubpixAvgVarMxNFunc subpel_avg_variance32x64_msa =\n+    vpx_sub_pixel_avg_variance32x64_msa;\n+const SubpixAvgVarMxNFunc subpel_avg_variance32x32_msa =\n+    vpx_sub_pixel_avg_variance32x32_msa;\n+const SubpixAvgVarMxNFunc subpel_avg_variance32x16_msa =\n+    vpx_sub_pixel_avg_variance32x16_msa;\n+const SubpixAvgVarMxNFunc subpel_avg_variance16x32_msa =\n+    vpx_sub_pixel_avg_variance16x32_msa;\n+const SubpixAvgVarMxNFunc subpel_avg_variance16x16_msa =\n+    vpx_sub_pixel_avg_variance16x16_msa;\n+const SubpixAvgVarMxNFunc subpel_avg_variance16x8_msa =\n+    vpx_sub_pixel_avg_variance16x8_msa;\n+const SubpixAvgVarMxNFunc subpel_avg_variance8x16_msa =\n+    vpx_sub_pixel_avg_variance8x16_msa;\n+const SubpixAvgVarMxNFunc subpel_avg_variance8x8_msa =\n+    vpx_sub_pixel_avg_variance8x8_msa;\n+const SubpixAvgVarMxNFunc subpel_avg_variance8x4_msa =\n+    vpx_sub_pixel_avg_variance8x4_msa;\n+const SubpixAvgVarMxNFunc subpel_avg_variance4x8_msa =\n+    vpx_sub_pixel_avg_variance4x8_msa;\n+const SubpixAvgVarMxNFunc subpel_avg_variance4x4_msa =\n+    vpx_sub_pixel_avg_variance4x4_msa;\n+INSTANTIATE_TEST_CASE_P(\n+    MSA, VpxSubpelAvgVarianceTest,\n+    ::testing::Values(make_tuple(6, 6, subpel_avg_variance64x64_msa, 0),\n+                      make_tuple(6, 5, subpel_avg_variance64x32_msa, 0),\n+                      make_tuple(5, 6, subpel_avg_variance32x64_msa, 0),\n+                      make_tuple(5, 5, subpel_avg_variance32x32_msa, 0),\n+                      make_tuple(5, 4, subpel_avg_variance32x16_msa, 0),\n+                      make_tuple(4, 5, subpel_avg_variance16x32_msa, 0),\n+                      make_tuple(4, 4, subpel_avg_variance16x16_msa, 0),\n+                      make_tuple(4, 3, subpel_avg_variance16x8_msa, 0),\n+                      make_tuple(3, 4, subpel_avg_variance8x16_msa, 0),\n+                      make_tuple(3, 3, subpel_avg_variance8x8_msa, 0),\n+                      make_tuple(3, 2, subpel_avg_variance8x4_msa, 0),\n+                      make_tuple(2, 3, subpel_avg_variance4x8_msa, 0),\n+                      make_tuple(2, 2, subpel_avg_variance4x4_msa, 0)));\n+#endif  // HAVE_MSA\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/video_source.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/video_source.h"", ""patch"": ""@@ -10,6 +10,9 @@\n\n #ifndef TEST_VIDEO_SOURCE_H_\n #define TEST_VIDEO_SOURCE_H_\n \n+#if defined(_WIN32)\n+#include <windows.h>\n+#endif\n #include <cstdio>\n #include <cstdlib>\n #include <string>\n@@ -50,6 +53,53 @@\n\n   return fopen(path_to_source.c_str(), \""rb\"");\n }\n \n+static FILE *GetTempOutFile(std::string *file_name) {\n+  file_name->clear();\n+#if defined(_WIN32)\n+  char fname[MAX_PATH];\n+  char tmppath[MAX_PATH];\n+  if (GetTempPathA(MAX_PATH, tmppath)) {\n+    // Assume for now that the filename generated is unique per process\n+    if (GetTempFileNameA(tmppath, \""lvx\"", 0, fname)) {\n+      file_name->assign(fname);\n+      return fopen(fname, \""wb+\"");\n+    }\n+  }\n+  return NULL;\n+#else\n+  return tmpfile();\n+#endif\n+}\n+\n+class TempOutFile {\n+ public:\n+  TempOutFile() {\n+    file_ = GetTempOutFile(&file_name_);\n+  }\n+  ~TempOutFile() {\n+    CloseFile();\n+    if (!file_name_.empty()) {\n+      EXPECT_EQ(0, remove(file_name_.c_str()));\n+    }\n+  }\n+  FILE *file() {\n+    return file_;\n+  }\n+  const std::string& file_name() {\n+    return file_name_;\n+  }\n+\n+ protected:\n+  void CloseFile() {\n+    if (file_) {\n+      fclose(file_);\n+      file_ = NULL;\n+    }\n+  }\n+  FILE *file_;\n+  std::string file_name_;\n+};\n+\n // Abstract base class for test video sources, which provide a stream of\n // vpx_image_t images with associated timestamps and duration.\n class VideoSource {\n@@ -84,8 +134,13 @@\n\n \n class DummyVideoSource : public VideoSource {\n  public:\n-  DummyVideoSource() : img_(NULL), limit_(100), width_(0), height_(0) {\n-    SetSize(80, 64);\n+  DummyVideoSource()\n+      : img_(NULL),\n+        limit_(100),\n+        width_(80),\n+        height_(64),\n+        format_(VPX_IMG_FMT_I420) {\n+    ReallocImage();\n   }\n \n   virtual ~DummyVideoSource() { vpx_img_free(img_); }\n@@ -118,18 +173,33 @@\n\n \n   virtual unsigned int limit() const { return limit_; }\n \n+  void set_limit(unsigned int limit) {\n+    limit_ = limit;\n+  }\n+\n   void SetSize(unsigned int width, unsigned int height) {\n     if (width != width_ || height != height_) {\n-      vpx_img_free(img_);\n-      raw_sz_ = ((width + 31)&~31) * height * 3 / 2;\n-      img_ = vpx_img_alloc(NULL, VPX_IMG_FMT_I420, width, height, 32);\n       width_ = width;\n       height_ = height;\n+      ReallocImage();\n+    }\n+  }\n+\n+  void SetImageFormat(vpx_img_fmt_t format) {\n+    if (format_ != format) {\n+      format_ = format;\n+      ReallocImage();\n     }\n   }\n \n  protected:\n-  virtual void FillFrame() { memset(img_->img_data, 0, raw_sz_); }\n+  virtual void FillFrame() { if (img_) memset(img_->img_data, 0, raw_sz_); }\n+\n+  void ReallocImage() {\n+    vpx_img_free(img_);\n+    img_ = vpx_img_alloc(NULL, format_, width_, height_, 32);\n+    raw_sz_ = ((img_->w + 31) & ~31) * img_->h * img_->bps / 8;\n+  }\n \n   vpx_image_t *img_;\n   size_t       raw_sz_;\n@@ -137,6 +207,7 @@\n\n   unsigned int frame_;\n   unsigned int width_;\n   unsigned int height_;\n+  vpx_img_fmt_t format_;\n };\n \n \n@@ -157,11 +228,13 @@\n\n   // 15 frames of noise, followed by 15 static frames. Reset to 0 rather\n   // than holding previous frames to encourage keyframes to be thrown.\n   virtual void FillFrame() {\n-    if (frame_ % 30 < 15)\n-      for (size_t i = 0; i < raw_sz_; ++i)\n-        img_->img_data[i] = rnd_.Rand8();\n-    else\n-      memset(img_->img_data, 0, raw_sz_);\n+    if (img_) {\n+      if (frame_ % 30 < 15)\n+        for (size_t i = 0; i < raw_sz_; ++i)\n+          img_->img_data[i] = rnd_.Rand8();\n+      else\n+        memset(img_->img_data, 0, raw_sz_);\n+    }\n   }\n \n   ACMRandom rnd_;\n""}<_**next**_>{""filename"": ""libvpx/test/vp8_boolcoder_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp8_boolcoder_test.cc"", ""patch"": ""@@ -16,12 +16,12 @@\n\n #include <string.h>\n #include <sys/types.h>\n \n-#include \""test/acm_random.h\""\n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n-#include \""vpx/vpx_integer.h\""\n \n-#include \""vp8/encoder/boolhuff.h\""\n+#include \""test/acm_random.h\""\n #include \""vp8/decoder/dboolhuff.h\""\n+#include \""vp8/encoder/boolhuff.h\""\n+#include \""vpx/vpx_integer.h\""\n \n namespace {\n const int num_tests = 10;\n@@ -94,14 +94,10 @@\n\n         vp8_stop_encode(&bw);\n \n         BOOL_DECODER br;\n-#if CONFIG_DECRYPT\n-        encrypt_buffer(bw_buffer, buffer_size);\n-        vp8dx_start_decode(&br, bw_buffer, buffer_size,\n+        encrypt_buffer(bw_buffer, kBufferSize);\n+        vp8dx_start_decode(&br, bw_buffer, kBufferSize,\n                            test_decrypt_cb,\n                            reinterpret_cast<void *>(bw_buffer));\n-#else\n-        vp8dx_start_decode(&br, bw_buffer, kBufferSize, NULL, NULL);\n-#endif\n         bit_rnd.Reset(random_seed);\n         for (int i = 0; i < kBitsToTest; ++i) {\n           if (bit_method == 2) {\n""}<_**next**_>{""filename"": ""libvpx/test/vp8_decrypt_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp8_decrypt_test.cc"", ""patch"": ""@@ -43,11 +43,11 @@\n\n \n namespace libvpx_test {\n \n-TEST(TestDecrypt, DecryptWorks) {\n+TEST(TestDecrypt, DecryptWorksVp8) {\n   libvpx_test::IVFVideoSource video(\""vp80-00-comprehensive-001.ivf\"");\n   video.Init();\n \n-  vpx_codec_dec_cfg_t dec_cfg = {0};\n+  vpx_codec_dec_cfg_t dec_cfg = vpx_codec_dec_cfg_t();\n   VP8Decoder decoder(dec_cfg, 0);\n \n   video.Begin();\n@@ -59,14 +59,12 @@\n\n   // decrypt frame\n   video.Next();\n \n-#if CONFIG_DECRYPT\n   std::vector<uint8_t> encrypted(video.frame_size());\n   encrypt_buffer(video.cxdata(), &encrypted[0], video.frame_size(), 0);\n-  vp8_decrypt_init di = { test_decrypt_cb, &encrypted[0] };\n-  decoder.Control(VP8D_SET_DECRYPTOR, &di);\n-#endif  // CONFIG_DECRYPT\n+  vpx_decrypt_init di = { test_decrypt_cb, &encrypted[0] };\n+  decoder.Control(VPXD_SET_DECRYPTOR, &di);\n \n-  res = decoder.DecodeFrame(video.cxdata(), video.frame_size());\n+  res = decoder.DecodeFrame(&encrypted[0], encrypted.size());\n   ASSERT_EQ(VPX_CODEC_OK, res) << decoder.DecodeError();\n }\n \n""}<_**next**_>{""filename"": ""libvpx/test/vp8_denoiser_sse2_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp8_denoiser_sse2_test.cc"", ""patch"": ""@@ -0,0 +1,116 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <math.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+#include \""test/acm_random.h\""\n+#include \""test/clear_system_state.h\""\n+#include \""test/register_state_check.h\""\n+#include \""test/util.h\""\n+\n+#include \""vp8/encoder/denoising.h\""\n+#include \""vp8/common/reconinter.h\""\n+#include \""vpx/vpx_integer.h\""\n+#include \""vpx_mem/vpx_mem.h\""\n+\n+using libvpx_test::ACMRandom;\n+\n+namespace {\n+\n+const int kNumPixels = 16 * 16;\n+class VP8DenoiserTest : public ::testing::TestWithParam<int> {\n+ public:\n+  virtual ~VP8DenoiserTest() {}\n+\n+  virtual void SetUp() {\n+    increase_denoising_ = GetParam();\n+  }\n+\n+  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n+\n+ protected:\n+  int increase_denoising_;\n+};\n+\n+TEST_P(VP8DenoiserTest, BitexactCheck) {\n+  ACMRandom rnd(ACMRandom::DeterministicSeed());\n+  const int count_test_block = 4000;\n+  const int stride = 16;\n+\n+  // Allocate the space for input and output,\n+  // where sig_block_c/_sse2 is the block to be denoised,\n+  // mc_avg_block is the denoised reference block,\n+  // avg_block_c is the denoised result from C code,\n+  // avg_block_sse2 is the denoised result from SSE2 code.\n+  DECLARE_ALIGNED(16, uint8_t, sig_block_c[kNumPixels]);\n+  // Since in VP8 denoiser, the source signal will be changed,\n+  // we need another copy of the source signal as the input of sse2 code.\n+  DECLARE_ALIGNED(16, uint8_t, sig_block_sse2[kNumPixels]);\n+  DECLARE_ALIGNED(16, uint8_t, mc_avg_block[kNumPixels]);\n+  DECLARE_ALIGNED(16, uint8_t, avg_block_c[kNumPixels]);\n+  DECLARE_ALIGNED(16, uint8_t, avg_block_sse2[kNumPixels]);\n+\n+  for (int i = 0; i < count_test_block; ++i) {\n+    // Generate random motion magnitude, 20% of which exceed the threshold.\n+    const int motion_magnitude_ran =\n+        rnd.Rand8() % static_cast<int>(MOTION_MAGNITUDE_THRESHOLD * 1.2);\n+\n+    // Initialize a test block with random number in range [0, 255].\n+    for (int j = 0; j < kNumPixels; ++j) {\n+      int temp = 0;\n+      sig_block_sse2[j] = sig_block_c[j] = rnd.Rand8();\n+      // The pixels in mc_avg_block are generated by adding a random\n+      // number in range [-19, 19] to corresponding pixels in sig_block.\n+      temp = sig_block_c[j] + (rnd.Rand8() % 2 == 0 ? -1 : 1) *\n+             (rnd.Rand8() % 20);\n+      // Clip.\n+      mc_avg_block[j] = (temp < 0) ? 0 : ((temp > 255) ? 255 : temp);\n+    }\n+\n+    // Test denosiser on Y component.\n+    ASM_REGISTER_STATE_CHECK(vp8_denoiser_filter_c(\n+        mc_avg_block, stride, avg_block_c, stride, sig_block_c, stride,\n+        motion_magnitude_ran, increase_denoising_));\n+\n+    ASM_REGISTER_STATE_CHECK(vp8_denoiser_filter_sse2(\n+        mc_avg_block, stride, avg_block_sse2, stride, sig_block_sse2, stride,\n+        motion_magnitude_ran, increase_denoising_));\n+\n+    // Check bitexactness.\n+    for (int h = 0; h < 16; ++h) {\n+      for (int w = 0; w < 16; ++w) {\n+        EXPECT_EQ(avg_block_c[h * stride + w], avg_block_sse2[h * stride + w]);\n+      }\n+    }\n+\n+    // Test denoiser on UV component.\n+    ASM_REGISTER_STATE_CHECK(vp8_denoiser_filter_uv_c(\n+        mc_avg_block, stride, avg_block_c, stride, sig_block_c, stride,\n+        motion_magnitude_ran, increase_denoising_));\n+\n+    ASM_REGISTER_STATE_CHECK(vp8_denoiser_filter_uv_sse2(\n+        mc_avg_block, stride, avg_block_sse2, stride, sig_block_sse2, stride,\n+        motion_magnitude_ran, increase_denoising_));\n+\n+    // Check bitexactness.\n+    for (int h = 0; h < 16; ++h) {\n+      for (int w = 0; w < 16; ++w) {\n+        EXPECT_EQ(avg_block_c[h * stride + w], avg_block_sse2[h * stride + w]);\n+      }\n+    }\n+  }\n+}\n+\n+// Test for all block size.\n+INSTANTIATE_TEST_CASE_P(SSE2, VP8DenoiserTest, ::testing::Values(0, 1));\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/vp8_fdct4x4_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp8_fdct4x4_test.cc"", ""patch"": ""@@ -15,10 +15,10 @@\n\n #include <string.h>\n #include <sys/types.h>\n \n-#include \""./vp8_rtcd.h\""\n-\n-#include \""test/acm_random.h\""\n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vp8_rtcd.h\""\n+#include \""test/acm_random.h\""\n #include \""vpx/vpx_integer.h\""\n \n namespace {\n""}<_**next**_>{""filename"": ""libvpx/test/vp8_fragments_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp8_fragments_test.cc"", ""patch"": ""@@ -0,0 +1,37 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+#include \""test/codec_factory.h\""\n+#include \""test/video_source.h\""\n+\n+namespace {\n+\n+class VP8FramgmentsTest\n+    : public ::libvpx_test::EncoderTest,\n+      public ::testing::Test {\n+ protected:\n+  VP8FramgmentsTest() : EncoderTest(&::libvpx_test::kVP8) {}\n+  virtual ~VP8FramgmentsTest() {}\n+\n+  virtual void SetUp() {\n+    const unsigned long init_flags =  // NOLINT(runtime/int)\n+        VPX_CODEC_USE_OUTPUT_PARTITION;\n+    InitializeConfig();\n+    SetMode(::libvpx_test::kRealTime);\n+    set_init_flags(init_flags);\n+  }\n+};\n+\n+TEST_F(VP8FramgmentsTest, TestFragmentsEncodeDecode) {\n+  ::libvpx_test::RandomVideoSource video;\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+}\n+\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/vp8_multi_resolution_encoder.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp8_multi_resolution_encoder.sh"", ""patch"": ""@@ -0,0 +1,75 @@\n\n+#!/bin/sh\n+##\n+##  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+##\n+##  Use of this source code is governed by a BSD-style license\n+##  that can be found in the LICENSE file in the root of the source\n+##  tree. An additional intellectual property rights grant can be found\n+##  in the file PATENTS.  All contributing project authors may\n+##  be found in the AUTHORS file in the root of the source tree.\n+##\n+##  This file tests the libvpx vp8_multi_resolution_encoder example. To add new\n+##  tests to this file, do the following:\n+##    1. Write a shell function (this is your test).\n+##    2. Add the function to vp8_mre_tests (on a new line).\n+##\n+. $(dirname $0)/tools_common.sh\n+\n+# Environment check: $YUV_RAW_INPUT is required.\n+vp8_multi_resolution_encoder_verify_environment() {\n+  if [ \""$(vpx_config_option_enabled CONFIG_MULTI_RES_ENCODING)\"" = \""yes\"" ]; then\n+    if [ ! -e \""${YUV_RAW_INPUT}\"" ]; then\n+      elog \""Libvpx test data must exist in LIBVPX_TEST_DATA_PATH.\""\n+      return 1\n+    fi\n+    local readonly app=\""vp8_multi_resolution_encoder\""\n+    if [ -z \""$(vpx_tool_path \""${app}\"")\"" ]; then\n+      elog \""${app} not found. It must exist in LIBVPX_BIN_PATH or its parent.\""\n+      return 1\n+    fi\n+  fi\n+}\n+\n+# Runs vp8_multi_resolution_encoder. Simply forwards all arguments to\n+# vp8_multi_resolution_encoder after building path to the executable.\n+vp8_mre() {\n+  local readonly encoder=\""$(vpx_tool_path vp8_multi_resolution_encoder)\""\n+  if [ ! -x \""${encoder}\"" ]; then\n+    elog \""${encoder} does not exist or is not executable.\""\n+    return 1\n+  fi\n+\n+  eval \""${VPX_TEST_PREFIX}\"" \""${encoder}\"" \""$@\"" ${devnull}\n+}\n+\n+vp8_multi_resolution_encoder_three_formats() {\n+  local readonly output_files=\""${VPX_TEST_OUTPUT_DIR}/vp8_mre_0.ivf\n+                               ${VPX_TEST_OUTPUT_DIR}/vp8_mre_1.ivf\n+                               ${VPX_TEST_OUTPUT_DIR}/vp8_mre_2.ivf\""\n+\n+  if [ \""$(vpx_config_option_enabled CONFIG_MULTI_RES_ENCODING)\"" = \""yes\"" ]; then\n+    if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+      # Param order:\n+      #  Input width\n+      #  Input height\n+      #  Input file path\n+      #  Output file names\n+      #  Output PSNR\n+      vp8_mre \""${YUV_RAW_INPUT_WIDTH}\"" \\\n+        \""${YUV_RAW_INPUT_HEIGHT}\"" \\\n+        \""${YUV_RAW_INPUT}\"" \\\n+        ${output_files} \\\n+        0\n+\n+      for output_file in ${output_files}; do\n+        if [ ! -e \""${output_file}\"" ]; then\n+          elog \""Missing output file: ${output_file}\""\n+          return 1\n+        fi\n+      done\n+    fi\n+  fi\n+}\n+\n+vp8_mre_tests=\""vp8_multi_resolution_encoder_three_formats\""\n+run_tests vp8_multi_resolution_encoder_verify_environment \""${vp8_mre_tests}\""\n""}<_**next**_>{""filename"": ""libvpx/test/vp8cx_set_ref.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp8cx_set_ref.sh"", ""patch"": ""@@ -0,0 +1,57 @@\n\n+#!/bin/sh\n+##\n+##  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+##\n+##  Use of this source code is governed by a BSD-style license\n+##  that can be found in the LICENSE file in the root of the source\n+##  tree. An additional intellectual property rights grant can be found\n+##  in the file PATENTS.  All contributing project authors may\n+##  be found in the AUTHORS file in the root of the source tree.\n+##\n+##  This file tests the libvpx vp8cx_set_ref example. To add new tests to this\n+##  file, do the following:\n+##    1. Write a shell function (this is your test).\n+##    2. Add the function to vp8cx_set_ref_tests (on a new line).\n+##\n+. $(dirname $0)/tools_common.sh\n+\n+# Environment check: $YUV_RAW_INPUT is required.\n+vp8cx_set_ref_verify_environment() {\n+  if [ ! -e \""${YUV_RAW_INPUT}\"" ]; then\n+    echo \""Libvpx test data must exist in LIBVPX_TEST_DATA_PATH.\""\n+    return 1\n+  fi\n+}\n+\n+# Runs vp8cx_set_ref and updates the reference frame before encoding frame 90.\n+# $1 is the codec name, which vp8cx_set_ref does not support at present: It's\n+# currently used only to name the output file.\n+# TODO(tomfinegan): Pass the codec param once the example is updated to support\n+# VP9.\n+vpx_set_ref() {\n+  local encoder=\""${LIBVPX_BIN_PATH}/vp8cx_set_ref${VPX_TEST_EXE_SUFFIX}\""\n+  local codec=\""$1\""\n+  local output_file=\""${VPX_TEST_OUTPUT_DIR}/vp8cx_set_ref_${codec}.ivf\""\n+  local ref_frame_num=90\n+\n+  if [ ! -x \""${encoder}\"" ]; then\n+    elog \""${encoder} does not exist or is not executable.\""\n+    return 1\n+  fi\n+\n+  eval \""${VPX_TEST_PREFIX}\"" \""${encoder}\"" \""${YUV_RAW_INPUT_WIDTH}\"" \\\n+      \""${YUV_RAW_INPUT_HEIGHT}\"" \""${YUV_RAW_INPUT}\"" \""${output_file}\"" \\\n+      \""${ref_frame_num}\"" ${devnull}\n+\n+  [ -e \""${output_file}\"" ] || return 1\n+}\n+\n+vp8cx_set_ref_vp8() {\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+    vpx_set_ref vp8 || return 1\n+  fi\n+}\n+\n+vp8cx_set_ref_tests=\""vp8cx_set_ref_vp8\""\n+\n+run_tests vp8cx_set_ref_verify_environment \""${vp8cx_set_ref_tests}\""\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_arf_freq_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_arf_freq_test.cc"", ""patch"": ""@@ -0,0 +1,238 @@\n\n+/*\n+ *  Copyright (c) 2015 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""test/codec_factory.h\""\n+#include \""test/encode_test_driver.h\""\n+#include \""test/util.h\""\n+#include \""test/y4m_video_source.h\""\n+#include \""test/yuv_video_source.h\""\n+#include \""vp9/encoder/vp9_ratectrl.h\""\n+\n+namespace {\n+\n+const unsigned int kFrames = 100;\n+const int kBitrate = 500;\n+\n+#define ARF_NOT_SEEN               1000001\n+#define ARF_SEEN_ONCE              1000000\n+\n+typedef struct {\n+  const char *filename;\n+  unsigned int width;\n+  unsigned int height;\n+  unsigned int framerate_num;\n+  unsigned int framerate_den;\n+  unsigned int input_bit_depth;\n+  vpx_img_fmt fmt;\n+  vpx_bit_depth_t bit_depth;\n+  unsigned int profile;\n+} TestVideoParam;\n+\n+typedef struct {\n+  libvpx_test::TestMode mode;\n+  int cpu_used;\n+} TestEncodeParam;\n+\n+const TestVideoParam kTestVectors[] = {\n+  // artificially increase framerate to trigger default check\n+  {\""hantro_collage_w352h288.yuv\"", 352, 288, 5000, 1,\n+    8, VPX_IMG_FMT_I420, VPX_BITS_8, 0},\n+  {\""hantro_collage_w352h288.yuv\"", 352, 288, 30, 1,\n+    8, VPX_IMG_FMT_I420, VPX_BITS_8, 0},\n+  {\""rush_hour_444.y4m\"", 352, 288, 30, 1,\n+    8, VPX_IMG_FMT_I444, VPX_BITS_8, 1},\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  // Add list of profile 2/3 test videos here ...\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+};\n+\n+const TestEncodeParam kEncodeVectors[] = {\n+  {::libvpx_test::kOnePassGood, 2},\n+  {::libvpx_test::kOnePassGood, 5},\n+  {::libvpx_test::kTwoPassGood, 1},\n+  {::libvpx_test::kTwoPassGood, 2},\n+  {::libvpx_test::kTwoPassGood, 5},\n+  {::libvpx_test::kRealTime, 5},\n+};\n+\n+const int kMinArfVectors[] = {\n+  // NOTE: 0 refers to the default built-in logic in:\n+  //       vp9_rc_get_default_min_gf_interval(...)\n+  0, 4, 8, 12, 15\n+};\n+\n+int is_extension_y4m(const char *filename) {\n+  const char *dot = strrchr(filename, '.');\n+  if (!dot || dot == filename)\n+    return 0;\n+  else\n+    return !strcmp(dot, \"".y4m\"");\n+}\n+\n+class ArfFreqTest\n+    : public ::libvpx_test::EncoderTest,\n+      public ::libvpx_test::CodecTestWith3Params<TestVideoParam, \\\n+                                                 TestEncodeParam, int> {\n+ protected:\n+  ArfFreqTest()\n+      : EncoderTest(GET_PARAM(0)),\n+        test_video_param_(GET_PARAM(1)),\n+        test_encode_param_(GET_PARAM(2)),\n+        min_arf_requested_(GET_PARAM(3)) {\n+  }\n+\n+  virtual ~ArfFreqTest() {}\n+\n+  virtual void SetUp() {\n+    InitializeConfig();\n+    SetMode(test_encode_param_.mode);\n+    if (test_encode_param_.mode != ::libvpx_test::kRealTime) {\n+      cfg_.g_lag_in_frames = 25;\n+      cfg_.rc_end_usage = VPX_VBR;\n+    } else {\n+      cfg_.g_lag_in_frames = 0;\n+      cfg_.rc_end_usage = VPX_CBR;\n+      cfg_.rc_buf_sz = 1000;\n+      cfg_.rc_buf_initial_sz = 500;\n+      cfg_.rc_buf_optimal_sz = 600;\n+    }\n+    dec_cfg_.threads = 4;\n+  }\n+\n+  virtual void BeginPassHook(unsigned int) {\n+    min_run_ = ARF_NOT_SEEN;\n+    run_of_visible_frames_ = 0;\n+  }\n+\n+  int GetNumFramesInPkt(const vpx_codec_cx_pkt_t *pkt) {\n+    const uint8_t *buffer = reinterpret_cast<uint8_t*>(pkt->data.frame.buf);\n+    const uint8_t marker = buffer[pkt->data.frame.sz - 1];\n+    const int mag = ((marker >> 3) & 3) + 1;\n+    int frames = (marker & 0x7) + 1;\n+    const unsigned int index_sz = 2 + mag  * frames;\n+    // Check for superframe or not.\n+    // Assume superframe has only one visible frame, the rest being\n+    // invisible. If superframe index is not found, then there is only\n+    // one frame.\n+    if (!((marker & 0xe0) == 0xc0 &&\n+          pkt->data.frame.sz >= index_sz &&\n+          buffer[pkt->data.frame.sz - index_sz] == marker)) {\n+      frames = 1;\n+    }\n+    return frames;\n+  }\n+\n+  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n+    if (pkt->kind != VPX_CODEC_CX_FRAME_PKT)\n+      return;\n+    const int frames = GetNumFramesInPkt(pkt);\n+    if (frames == 1) {\n+      run_of_visible_frames_++;\n+    } else if (frames == 2) {\n+      if (min_run_ == ARF_NOT_SEEN) {\n+        min_run_ = ARF_SEEN_ONCE;\n+      } else if (min_run_ == ARF_SEEN_ONCE ||\n+                 run_of_visible_frames_ < min_run_) {\n+        min_run_ = run_of_visible_frames_;\n+      }\n+      run_of_visible_frames_ = 1;\n+    } else {\n+      min_run_ = 0;\n+      run_of_visible_frames_ = 1;\n+    }\n+  }\n+\n+  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n+                                  ::libvpx_test::Encoder *encoder) {\n+    if (video->frame() == 0) {\n+      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING, 1);\n+      encoder->Control(VP9E_SET_TILE_COLUMNS, 4);\n+      encoder->Control(VP8E_SET_CPUUSED, test_encode_param_.cpu_used);\n+      encoder->Control(VP9E_SET_MIN_GF_INTERVAL, min_arf_requested_);\n+      if (test_encode_param_.mode != ::libvpx_test::kRealTime) {\n+        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n+        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n+        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n+        encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n+      }\n+    }\n+  }\n+\n+  int GetMinVisibleRun() const {\n+    return min_run_;\n+  }\n+\n+  int GetMinArfDistanceRequested() const {\n+    if (min_arf_requested_)\n+      return min_arf_requested_;\n+    else\n+      return vp9_rc_get_default_min_gf_interval(\n+          test_video_param_.width, test_video_param_.height,\n+          (double)test_video_param_.framerate_num /\n+          test_video_param_.framerate_den);\n+  }\n+\n+  TestVideoParam test_video_param_;\n+  TestEncodeParam test_encode_param_;\n+\n+ private:\n+  int min_arf_requested_;\n+  int min_run_;\n+  int run_of_visible_frames_;\n+};\n+\n+TEST_P(ArfFreqTest, MinArfFreqTest) {\n+  cfg_.rc_target_bitrate = kBitrate;\n+  cfg_.g_error_resilient = 0;\n+  cfg_.g_profile = test_video_param_.profile;\n+  cfg_.g_input_bit_depth = test_video_param_.input_bit_depth;\n+  cfg_.g_bit_depth = test_video_param_.bit_depth;\n+  init_flags_ = VPX_CODEC_USE_PSNR;\n+  if (cfg_.g_bit_depth > 8)\n+    init_flags_ |= VPX_CODEC_USE_HIGHBITDEPTH;\n+\n+  libvpx_test::VideoSource *video;\n+  if (is_extension_y4m(test_video_param_.filename)) {\n+    video = new libvpx_test::Y4mVideoSource(test_video_param_.filename,\n+                                            0, kFrames);\n+  } else {\n+    video = new libvpx_test::YUVVideoSource(test_video_param_.filename,\n+                                            test_video_param_.fmt,\n+                                            test_video_param_.width,\n+                                            test_video_param_.height,\n+                                            test_video_param_.framerate_num,\n+                                            test_video_param_.framerate_den,\n+                                            0, kFrames);\n+  }\n+\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(video));\n+  const int min_run = GetMinVisibleRun();\n+  const int min_arf_dist_requested = GetMinArfDistanceRequested();\n+  if (min_run != ARF_NOT_SEEN && min_run != ARF_SEEN_ONCE) {\n+    const int min_arf_dist = min_run + 1;\n+    EXPECT_GE(min_arf_dist, min_arf_dist_requested);\n+  }\n+  delete(video);\n+}\n+\n+VP9_INSTANTIATE_TEST_CASE(\n+    ArfFreqTest,\n+    ::testing::ValuesIn(kTestVectors),\n+    ::testing::ValuesIn(kEncodeVectors),\n+    ::testing::ValuesIn(kMinArfVectors));\n+\n+VP10_INSTANTIATE_TEST_CASE(\n+    ArfFreqTest,\n+    ::testing::ValuesIn(kTestVectors),\n+    ::testing::ValuesIn(kEncodeVectors),\n+    ::testing::ValuesIn(kMinArfVectors));\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_avg_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_avg_test.cc"", ""patch"": ""@@ -0,0 +1,314 @@\n\n+/*\n+ *  Copyright (c) 2012 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <limits.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vpx_config.h\""\n+#if CONFIG_VP9_ENCODER\n+#include \""./vp9_rtcd.h\""\n+#endif\n+\n+#include \""test/acm_random.h\""\n+#include \""test/clear_system_state.h\""\n+#include \""test/register_state_check.h\""\n+#include \""test/util.h\""\n+#include \""vpx_mem/vpx_mem.h\""\n+\n+using libvpx_test::ACMRandom;\n+\n+namespace {\n+class AverageTestBase : public ::testing::Test {\n+ public:\n+  AverageTestBase(int width, int height) : width_(width), height_(height) {}\n+\n+  static void SetUpTestCase() {\n+    source_data_ = reinterpret_cast<uint8_t*>(\n+        vpx_memalign(kDataAlignment, kDataBlockSize));\n+  }\n+\n+  static void TearDownTestCase() {\n+    vpx_free(source_data_);\n+    source_data_ = NULL;\n+  }\n+\n+  virtual void TearDown() {\n+    libvpx_test::ClearSystemState();\n+  }\n+\n+ protected:\n+  // Handle blocks up to 4 blocks 64x64 with stride up to 128\n+  static const int kDataAlignment = 16;\n+  static const int kDataBlockSize = 64 * 128;\n+\n+  virtual void SetUp() {\n+    source_stride_ = (width_ + 31) & ~31;\n+    rnd_.Reset(ACMRandom::DeterministicSeed());\n+  }\n+\n+  // Sum Pixels\n+  unsigned int ReferenceAverage8x8(const uint8_t* source, int pitch ) {\n+    unsigned int average = 0;\n+    for (int h = 0; h < 8; ++h)\n+      for (int w = 0; w < 8; ++w)\n+        average += source[h * source_stride_ + w];\n+    return ((average + 32) >> 6);\n+  }\n+\n+  unsigned int ReferenceAverage4x4(const uint8_t* source, int pitch ) {\n+    unsigned int average = 0;\n+    for (int h = 0; h < 4; ++h)\n+      for (int w = 0; w < 4; ++w)\n+        average += source[h * source_stride_ + w];\n+    return ((average + 8) >> 4);\n+  }\n+\n+  void FillConstant(uint8_t fill_constant) {\n+    for (int i = 0; i < width_ * height_; ++i) {\n+        source_data_[i] = fill_constant;\n+    }\n+  }\n+\n+  void FillRandom() {\n+    for (int i = 0; i < width_ * height_; ++i) {\n+        source_data_[i] = rnd_.Rand8();\n+    }\n+  }\n+\n+  int width_, height_;\n+  static uint8_t* source_data_;\n+  int source_stride_;\n+\n+  ACMRandom rnd_;\n+};\n+typedef unsigned int (*AverageFunction)(const uint8_t* s, int pitch);\n+\n+typedef std::tr1::tuple<int, int, int, int, AverageFunction> AvgFunc;\n+\n+class AverageTest\n+    : public AverageTestBase,\n+      public ::testing::WithParamInterface<AvgFunc>{\n+ public:\n+  AverageTest() : AverageTestBase(GET_PARAM(0), GET_PARAM(1)) {}\n+\n+ protected:\n+  void CheckAverages() {\n+    unsigned int expected = 0;\n+    if (GET_PARAM(3) == 8) {\n+      expected = ReferenceAverage8x8(source_data_+ GET_PARAM(2),\n+                                     source_stride_);\n+    } else  if (GET_PARAM(3) == 4) {\n+      expected = ReferenceAverage4x4(source_data_+ GET_PARAM(2),\n+                                     source_stride_);\n+    }\n+\n+    ASM_REGISTER_STATE_CHECK(GET_PARAM(4)(source_data_+ GET_PARAM(2),\n+                                          source_stride_));\n+    unsigned int actual = GET_PARAM(4)(source_data_+ GET_PARAM(2),\n+                                       source_stride_);\n+\n+    EXPECT_EQ(expected, actual);\n+  }\n+};\n+\n+typedef void (*IntProRowFunc)(int16_t hbuf[16], uint8_t const *ref,\n+                              const int ref_stride, const int height);\n+\n+typedef std::tr1::tuple<int, IntProRowFunc, IntProRowFunc> IntProRowParam;\n+\n+class IntProRowTest\n+    : public AverageTestBase,\n+      public ::testing::WithParamInterface<IntProRowParam> {\n+ public:\n+  IntProRowTest()\n+    : AverageTestBase(16, GET_PARAM(0)),\n+      hbuf_asm_(NULL),\n+      hbuf_c_(NULL) {\n+    asm_func_ = GET_PARAM(1);\n+    c_func_ = GET_PARAM(2);\n+  }\n+\n+ protected:\n+  virtual void SetUp() {\n+    hbuf_asm_ = reinterpret_cast<int16_t*>(\n+        vpx_memalign(kDataAlignment, sizeof(*hbuf_asm_) * 16));\n+    hbuf_c_ = reinterpret_cast<int16_t*>(\n+        vpx_memalign(kDataAlignment, sizeof(*hbuf_c_) * 16));\n+  }\n+\n+  virtual void TearDown() {\n+    vpx_free(hbuf_c_);\n+    hbuf_c_ = NULL;\n+    vpx_free(hbuf_asm_);\n+    hbuf_asm_ = NULL;\n+  }\n+\n+  void RunComparison() {\n+    ASM_REGISTER_STATE_CHECK(c_func_(hbuf_c_, source_data_, 0, height_));\n+    ASM_REGISTER_STATE_CHECK(asm_func_(hbuf_asm_, source_data_, 0, height_));\n+    EXPECT_EQ(0, memcmp(hbuf_c_, hbuf_asm_, sizeof(*hbuf_c_) * 16))\n+        << \""Output mismatch\"";\n+  }\n+\n+ private:\n+  IntProRowFunc asm_func_;\n+  IntProRowFunc c_func_;\n+  int16_t *hbuf_asm_;\n+  int16_t *hbuf_c_;\n+};\n+\n+typedef int16_t (*IntProColFunc)(uint8_t const *ref, const int width);\n+\n+typedef std::tr1::tuple<int, IntProColFunc, IntProColFunc> IntProColParam;\n+\n+class IntProColTest\n+    : public AverageTestBase,\n+      public ::testing::WithParamInterface<IntProColParam> {\n+ public:\n+  IntProColTest() : AverageTestBase(GET_PARAM(0), 1), sum_asm_(0), sum_c_(0) {\n+    asm_func_ = GET_PARAM(1);\n+    c_func_ = GET_PARAM(2);\n+  }\n+\n+ protected:\n+  void RunComparison() {\n+    ASM_REGISTER_STATE_CHECK(sum_c_ = c_func_(source_data_, width_));\n+    ASM_REGISTER_STATE_CHECK(sum_asm_ = asm_func_(source_data_, width_));\n+    EXPECT_EQ(sum_c_, sum_asm_) << \""Output mismatch\"";\n+  }\n+\n+ private:\n+  IntProColFunc asm_func_;\n+  IntProColFunc c_func_;\n+  int16_t sum_asm_;\n+  int16_t sum_c_;\n+};\n+\n+\n+uint8_t* AverageTestBase::source_data_ = NULL;\n+\n+TEST_P(AverageTest, MinValue) {\n+  FillConstant(0);\n+  CheckAverages();\n+}\n+\n+TEST_P(AverageTest, MaxValue) {\n+  FillConstant(255);\n+  CheckAverages();\n+}\n+\n+TEST_P(AverageTest, Random) {\n+  // The reference frame, but not the source frame, may be unaligned for\n+  // certain types of searches.\n+  for (int i = 0; i < 1000; i++) {\n+    FillRandom();\n+    CheckAverages();\n+  }\n+}\n+\n+TEST_P(IntProRowTest, MinValue) {\n+  FillConstant(0);\n+  RunComparison();\n+}\n+\n+TEST_P(IntProRowTest, MaxValue) {\n+  FillConstant(255);\n+  RunComparison();\n+}\n+\n+TEST_P(IntProRowTest, Random) {\n+  FillRandom();\n+  RunComparison();\n+}\n+\n+TEST_P(IntProColTest, MinValue) {\n+  FillConstant(0);\n+  RunComparison();\n+}\n+\n+TEST_P(IntProColTest, MaxValue) {\n+  FillConstant(255);\n+  RunComparison();\n+}\n+\n+TEST_P(IntProColTest, Random) {\n+  FillRandom();\n+  RunComparison();\n+}\n+\n+using std::tr1::make_tuple;\n+\n+INSTANTIATE_TEST_CASE_P(\n+    C, AverageTest,\n+    ::testing::Values(\n+        make_tuple(16, 16, 1, 8, &vp9_avg_8x8_c),\n+        make_tuple(16, 16, 1, 4, &vp9_avg_4x4_c)));\n+\n+#if HAVE_SSE2\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, AverageTest,\n+    ::testing::Values(\n+        make_tuple(16, 16, 0, 8, &vp9_avg_8x8_sse2),\n+        make_tuple(16, 16, 5, 8, &vp9_avg_8x8_sse2),\n+        make_tuple(32, 32, 15, 8, &vp9_avg_8x8_sse2),\n+        make_tuple(16, 16, 0, 4, &vp9_avg_4x4_sse2),\n+        make_tuple(16, 16, 5, 4, &vp9_avg_4x4_sse2),\n+        make_tuple(32, 32, 15, 4, &vp9_avg_4x4_sse2)));\n+\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, IntProRowTest, ::testing::Values(\n+        make_tuple(16, &vp9_int_pro_row_sse2, &vp9_int_pro_row_c),\n+        make_tuple(32, &vp9_int_pro_row_sse2, &vp9_int_pro_row_c),\n+        make_tuple(64, &vp9_int_pro_row_sse2, &vp9_int_pro_row_c)));\n+\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, IntProColTest, ::testing::Values(\n+        make_tuple(16, &vp9_int_pro_col_sse2, &vp9_int_pro_col_c),\n+        make_tuple(32, &vp9_int_pro_col_sse2, &vp9_int_pro_col_c),\n+        make_tuple(64, &vp9_int_pro_col_sse2, &vp9_int_pro_col_c)));\n+#endif\n+\n+#if HAVE_NEON\n+INSTANTIATE_TEST_CASE_P(\n+    NEON, AverageTest,\n+    ::testing::Values(\n+        make_tuple(16, 16, 0, 8, &vp9_avg_8x8_neon),\n+        make_tuple(16, 16, 5, 8, &vp9_avg_8x8_neon),\n+        make_tuple(32, 32, 15, 8, &vp9_avg_8x8_neon)));\n+\n+INSTANTIATE_TEST_CASE_P(\n+    NEON, IntProRowTest, ::testing::Values(\n+        make_tuple(16, &vp9_int_pro_row_neon, &vp9_int_pro_row_c),\n+        make_tuple(32, &vp9_int_pro_row_neon, &vp9_int_pro_row_c),\n+        make_tuple(64, &vp9_int_pro_row_neon, &vp9_int_pro_row_c)));\n+\n+INSTANTIATE_TEST_CASE_P(\n+    NEON, IntProColTest, ::testing::Values(\n+        make_tuple(16, &vp9_int_pro_col_neon, &vp9_int_pro_col_c),\n+        make_tuple(32, &vp9_int_pro_col_neon, &vp9_int_pro_col_c),\n+        make_tuple(64, &vp9_int_pro_col_neon, &vp9_int_pro_col_c)));\n+#endif\n+\n+#if HAVE_MSA\n+INSTANTIATE_TEST_CASE_P(\n+    MSA, AverageTest,\n+    ::testing::Values(\n+        make_tuple(16, 16, 0, 8, &vp9_avg_8x8_msa),\n+        make_tuple(16, 16, 5, 8, &vp9_avg_8x8_msa),\n+        make_tuple(32, 32, 15, 8, &vp9_avg_8x8_msa),\n+        make_tuple(16, 16, 0, 4, &vp9_avg_4x4_msa),\n+        make_tuple(16, 16, 5, 4, &vp9_avg_4x4_msa),\n+        make_tuple(32, 32, 15, 4, &vp9_avg_4x4_msa)));\n+#endif\n+\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_boolcoder_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_boolcoder_test.cc"", ""patch"": ""@@ -14,11 +14,10 @@\n\n \n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n \n-#include \""vp9/decoder/vp9_reader.h\""\n-#include \""vp9/encoder/vp9_writer.h\""\n-\n #include \""test/acm_random.h\""\n #include \""vpx/vpx_integer.h\""\n+#include \""vpx_dsp/bitreader.h\""\n+#include \""vpx_dsp/bitwriter.h\""\n \n using libvpx_test::ACMRandom;\n \n@@ -50,9 +49,9 @@\n\n         const int random_seed = 6432;\n         const int kBufferSize = 10000;\n         ACMRandom bit_rnd(random_seed);\n-        vp9_writer bw;\n+        vpx_writer bw;\n         uint8_t bw_buffer[kBufferSize];\n-        vp9_start_encode(&bw, bw_buffer);\n+        vpx_start_encode(&bw, bw_buffer);\n \n         int bit = (bit_method == 0) ? 0 : (bit_method == 1) ? 1 : 0;\n         for (int i = 0; i < kBitsToTest; ++i) {\n@@ -61,16 +60,16 @@\n\n           } else if (bit_method == 3) {\n             bit = bit_rnd(2);\n           }\n-          vp9_write(&bw, bit, static_cast<int>(probas[i]));\n+          vpx_write(&bw, bit, static_cast<int>(probas[i]));\n         }\n \n-        vp9_stop_encode(&bw);\n+        vpx_stop_encode(&bw);\n \n         // First bit should be zero\n         GTEST_ASSERT_EQ(bw_buffer[0] & 0x80, 0);\n \n-        vp9_reader br;\n-        vp9_reader_init(&br, bw_buffer, kBufferSize);\n+        vpx_reader br;\n+        vpx_reader_init(&br, bw_buffer, kBufferSize, NULL, NULL);\n         bit_rnd.Reset(random_seed);\n         for (int i = 0; i < kBitsToTest; ++i) {\n           if (bit_method == 2) {\n@@ -78,7 +77,7 @@\n\n           } else if (bit_method == 3) {\n             bit = bit_rnd(2);\n           }\n-          GTEST_ASSERT_EQ(vp9_read(&br, probas[i]), bit)\n+          GTEST_ASSERT_EQ(vpx_read(&br, probas[i]), bit)\n               << \""pos: \"" << i << \"" / \"" << kBitsToTest\n               << \"" bit_method: \"" << bit_method\n               << \"" method: \"" << method;\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_decrypt_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_decrypt_test.cc"", ""patch"": ""@@ -0,0 +1,71 @@\n\n+/*\n+ *  Copyright (c) 2013 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+#include \""test/codec_factory.h\""\n+#include \""test/ivf_video_source.h\""\n+\n+namespace {\n+// In a real use the 'decrypt_state' parameter will be a pointer to a struct\n+// with whatever internal state the decryptor uses. For testing we'll just\n+// xor with a constant key, and decrypt_state will point to the start of\n+// the original buffer.\n+const uint8_t test_key[16] = {\n+  0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78,\n+  0x89, 0x9a, 0xab, 0xbc, 0xcd, 0xde, 0xef, 0xf0\n+};\n+\n+void encrypt_buffer(const uint8_t *src, uint8_t *dst, size_t size,\n+                    ptrdiff_t offset) {\n+  for (size_t i = 0; i < size; ++i) {\n+    dst[i] = src[i] ^ test_key[(offset + i) & 15];\n+  }\n+}\n+\n+void test_decrypt_cb(void *decrypt_state, const uint8_t *input,\n+                     uint8_t *output, int count) {\n+  encrypt_buffer(input, output, count,\n+                 input - reinterpret_cast<uint8_t *>(decrypt_state));\n+}\n+\n+}  // namespace\n+\n+namespace libvpx_test {\n+\n+TEST(TestDecrypt, DecryptWorksVp9) {\n+  libvpx_test::IVFVideoSource video(\""vp90-2-05-resize.ivf\"");\n+  video.Init();\n+\n+  vpx_codec_dec_cfg_t dec_cfg = vpx_codec_dec_cfg_t();\n+  VP9Decoder decoder(dec_cfg, 0);\n+\n+  video.Begin();\n+\n+  // no decryption\n+  vpx_codec_err_t res = decoder.DecodeFrame(video.cxdata(), video.frame_size());\n+  ASSERT_EQ(VPX_CODEC_OK, res) << decoder.DecodeError();\n+\n+  // decrypt frame\n+  video.Next();\n+\n+  std::vector<uint8_t> encrypted(video.frame_size());\n+  encrypt_buffer(video.cxdata(), &encrypted[0], video.frame_size(), 0);\n+  vpx_decrypt_init di = { test_decrypt_cb, &encrypted[0] };\n+  decoder.Control(VPXD_SET_DECRYPTOR, &di);\n+\n+  res = decoder.DecodeFrame(&encrypted[0], encrypted.size());\n+  ASSERT_EQ(VPX_CODEC_OK, res) << decoder.DecodeError();\n+}\n+\n+}  // namespace libvpx_test\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_denoiser_sse2_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_denoiser_sse2_test.cc"", ""patch"": ""@@ -0,0 +1,101 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <math.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+#include \""test/acm_random.h\""\n+#include \""test/clear_system_state.h\""\n+#include \""test/register_state_check.h\""\n+#include \""test/util.h\""\n+\n+#include \""vpx_scale/yv12config.h\""\n+#include \""vpx/vpx_integer.h\""\n+#include \""vp9/common/vp9_reconinter.h\""\n+#include \""vp9/encoder/vp9_context_tree.h\""\n+#include \""vp9/encoder/vp9_denoiser.h\""\n+\n+using libvpx_test::ACMRandom;\n+\n+namespace {\n+\n+const int kNumPixels = 64 * 64;\n+class VP9DenoiserTest : public ::testing::TestWithParam<BLOCK_SIZE> {\n+ public:\n+  virtual ~VP9DenoiserTest() {}\n+\n+  virtual void SetUp() {\n+    bs_ = GetParam();\n+  }\n+\n+  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n+\n+ protected:\n+  BLOCK_SIZE bs_;\n+};\n+\n+TEST_P(VP9DenoiserTest, BitexactCheck) {\n+  ACMRandom rnd(ACMRandom::DeterministicSeed());\n+  const int count_test_block = 4000;\n+\n+  // Allocate the space for input and output,\n+  // where sig_block is the block to be denoised,\n+  // mc_avg_block is the denoised reference block,\n+  // avg_block_c is the denoised result from C code,\n+  // avg_block_sse2 is the denoised result from SSE2 code.\n+  DECLARE_ALIGNED(16, uint8_t, sig_block[kNumPixels]);\n+  DECLARE_ALIGNED(16, uint8_t, mc_avg_block[kNumPixels]);\n+  DECLARE_ALIGNED(16, uint8_t, avg_block_c[kNumPixels]);\n+  DECLARE_ALIGNED(16, uint8_t, avg_block_sse2[kNumPixels]);\n+\n+  for (int i = 0; i < count_test_block; ++i) {\n+    // Generate random motion magnitude, 20% of which exceed the threshold.\n+    const int motion_magnitude_random =\n+        rnd.Rand8() % static_cast<int>(MOTION_MAGNITUDE_THRESHOLD * 1.2);\n+\n+    // Initialize a test block with random number in range [0, 255].\n+    for (int j = 0; j < kNumPixels; ++j) {\n+      int temp = 0;\n+      sig_block[j] = rnd.Rand8();\n+      // The pixels in mc_avg_block are generated by adding a random\n+      // number in range [-19, 19] to corresponding pixels in sig_block.\n+      temp = sig_block[j] + ((rnd.Rand8() % 2 == 0) ? -1 : 1) *\n+             (rnd.Rand8() % 20);\n+      // Clip.\n+      mc_avg_block[j] = (temp < 0) ? 0 : ((temp > 255) ? 255 : temp);\n+    }\n+\n+    ASM_REGISTER_STATE_CHECK(vp9_denoiser_filter_c(\n+        sig_block, 64, mc_avg_block, 64, avg_block_c,\n+        64, 0, bs_, motion_magnitude_random));\n+\n+    ASM_REGISTER_STATE_CHECK(vp9_denoiser_filter_sse2(\n+        sig_block, 64, mc_avg_block, 64, avg_block_sse2,\n+        64, 0, bs_, motion_magnitude_random));\n+\n+    // Test bitexactness.\n+    for (int h = 0; h < (4 << b_height_log2_lookup[bs_]); ++h) {\n+      for (int w = 0; w < (4 << b_width_log2_lookup[bs_]); ++w) {\n+        EXPECT_EQ(avg_block_c[h * 64 + w], avg_block_sse2[h * 64 + w]);\n+      }\n+    }\n+  }\n+}\n+\n+// Test for all block size.\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, VP9DenoiserTest,\n+    ::testing::Values(BLOCK_4X4, BLOCK_4X8, BLOCK_8X4, BLOCK_8X8,\n+                      BLOCK_8X16, BLOCK_16X8, BLOCK_16X16, BLOCK_16X32,\n+                      BLOCK_32X16, BLOCK_32X32, BLOCK_32X64, BLOCK_64X32,\n+                      BLOCK_64X64));\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_encoder_parms_get_to_decoder.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_encoder_parms_get_to_decoder.cc"", ""patch"": ""@@ -0,0 +1,198 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""test/codec_factory.h\""\n+#include \""test/encode_test_driver.h\""\n+#include \""test/util.h\""\n+#include \""test/y4m_video_source.h\""\n+#include \""test/yuv_video_source.h\""\n+#include \""vp9/decoder/vp9_decoder.h\""\n+\n+typedef vpx_codec_stream_info_t vp9_stream_info_t;\n+struct vpx_codec_alg_priv {\n+  vpx_codec_priv_t        base;\n+  vpx_codec_dec_cfg_t     cfg;\n+  vp9_stream_info_t       si;\n+  struct VP9Decoder      *pbi;\n+  int                     postproc_cfg_set;\n+  vp8_postproc_cfg_t      postproc_cfg;\n+  vpx_decrypt_cb          decrypt_cb;\n+  void                   *decrypt_state;\n+  vpx_image_t             img;\n+  int                     img_avail;\n+  int                     flushed;\n+  int                     invert_tile_order;\n+  int                     frame_parallel_decode;\n+\n+  // External frame buffer info to save for VP9 common.\n+  void *ext_priv;  // Private data associated with the external frame buffers.\n+  vpx_get_frame_buffer_cb_fn_t get_ext_fb_cb;\n+  vpx_release_frame_buffer_cb_fn_t release_ext_fb_cb;\n+};\n+\n+static vpx_codec_alg_priv_t *get_alg_priv(vpx_codec_ctx_t *ctx) {\n+  return (vpx_codec_alg_priv_t *)ctx->priv;\n+}\n+\n+namespace {\n+\n+const unsigned int kFramerate = 50;\n+const int kCpuUsed = 2;\n+\n+struct EncodePerfTestVideo {\n+  const char *name;\n+  uint32_t width;\n+  uint32_t height;\n+  uint32_t bitrate;\n+  int frames;\n+};\n+\n+const EncodePerfTestVideo kVP9EncodePerfTestVectors[] = {\n+  {\""niklas_1280_720_30.y4m\"", 1280, 720, 600, 10},\n+};\n+\n+struct EncodeParameters {\n+  int32_t tile_rows;\n+  int32_t tile_cols;\n+  int32_t lossless;\n+  int32_t error_resilient;\n+  int32_t frame_parallel;\n+  vpx_color_space_t cs;\n+  // TODO(JBB): quantizers / bitrate\n+};\n+\n+const EncodeParameters kVP9EncodeParameterSet[] = {\n+    {0, 0, 0, 1, 0, VPX_CS_BT_601},\n+    {0, 0, 0, 0, 0, VPX_CS_BT_709},\n+    {0, 0, 1, 0, 0, VPX_CS_BT_2020},\n+    {0, 2, 0, 0, 1, VPX_CS_UNKNOWN},\n+    // TODO(JBB): Test profiles (requires more work).\n+};\n+\n+int is_extension_y4m(const char *filename) {\n+  const char *dot = strrchr(filename, '.');\n+  if (!dot || dot == filename)\n+    return 0;\n+  else\n+    return !strcmp(dot, \"".y4m\"");\n+}\n+\n+class VpxEncoderParmsGetToDecoder\n+    : public ::libvpx_test::EncoderTest,\n+      public ::libvpx_test::CodecTestWith2Params<EncodeParameters, \\\n+                                                 EncodePerfTestVideo> {\n+ protected:\n+  VpxEncoderParmsGetToDecoder()\n+      : EncoderTest(GET_PARAM(0)),\n+        encode_parms(GET_PARAM(1)) {\n+  }\n+\n+  virtual ~VpxEncoderParmsGetToDecoder() {}\n+\n+  virtual void SetUp() {\n+    InitializeConfig();\n+    SetMode(::libvpx_test::kTwoPassGood);\n+    cfg_.g_lag_in_frames = 25;\n+    cfg_.g_error_resilient = encode_parms.error_resilient;\n+    dec_cfg_.threads = 4;\n+    test_video_ = GET_PARAM(2);\n+    cfg_.rc_target_bitrate = test_video_.bitrate;\n+  }\n+\n+  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n+                                  ::libvpx_test::Encoder *encoder) {\n+    if (video->frame() == 1) {\n+      encoder->Control(VP9E_SET_COLOR_SPACE, encode_parms.cs);\n+      encoder->Control(VP9E_SET_LOSSLESS, encode_parms.lossless);\n+      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING,\n+                       encode_parms.frame_parallel);\n+      encoder->Control(VP9E_SET_TILE_ROWS, encode_parms.tile_rows);\n+      encoder->Control(VP9E_SET_TILE_COLUMNS, encode_parms.tile_cols);\n+      encoder->Control(VP8E_SET_CPUUSED, kCpuUsed);\n+      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n+      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n+      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n+      encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n+    }\n+  }\n+\n+  virtual bool HandleDecodeResult(const vpx_codec_err_t res_dec,\n+                                  const libvpx_test::VideoSource& video,\n+                                  libvpx_test::Decoder *decoder) {\n+    vpx_codec_ctx_t* vp9_decoder = decoder->GetDecoder();\n+    vpx_codec_alg_priv_t* priv =\n+        (vpx_codec_alg_priv_t*) get_alg_priv(vp9_decoder);\n+\n+    VP9Decoder* pbi = priv->pbi;\n+    VP9_COMMON* common = &pbi->common;\n+\n+    if (encode_parms.lossless) {\n+      EXPECT_EQ(common->base_qindex, 0);\n+      EXPECT_EQ(common->y_dc_delta_q, 0);\n+      EXPECT_EQ(common->uv_dc_delta_q, 0);\n+      EXPECT_EQ(common->uv_ac_delta_q, 0);\n+      EXPECT_EQ(common->tx_mode, ONLY_4X4);\n+    }\n+    EXPECT_EQ(common->error_resilient_mode, encode_parms.error_resilient);\n+    if (encode_parms.error_resilient) {\n+      EXPECT_EQ(common->frame_parallel_decoding_mode, 1);\n+      EXPECT_EQ(common->use_prev_frame_mvs, 0);\n+    } else {\n+      EXPECT_EQ(common->frame_parallel_decoding_mode,\n+                encode_parms.frame_parallel);\n+    }\n+    EXPECT_EQ(common->color_space, encode_parms.cs);\n+    EXPECT_EQ(common->log2_tile_cols, encode_parms.tile_cols);\n+    EXPECT_EQ(common->log2_tile_rows, encode_parms.tile_rows);\n+\n+    EXPECT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n+    return VPX_CODEC_OK == res_dec;\n+  }\n+\n+  EncodePerfTestVideo test_video_;\n+\n+ private:\n+  EncodeParameters encode_parms;\n+};\n+\n+// TODO(hkuang): This test conflicts with frame parallel decode. So disable it\n+// for now until fix.\n+TEST_P(VpxEncoderParmsGetToDecoder, DISABLED_BitstreamParms) {\n+  init_flags_ = VPX_CODEC_USE_PSNR;\n+\n+  libvpx_test::VideoSource *video;\n+  if (is_extension_y4m(test_video_.name)) {\n+    video = new libvpx_test::Y4mVideoSource(test_video_.name,\n+                                            0, test_video_.frames);\n+  } else {\n+    video = new libvpx_test::YUVVideoSource(test_video_.name,\n+                                            VPX_IMG_FMT_I420,\n+                                            test_video_.width,\n+                                            test_video_.height,\n+                                            kFramerate, 1, 0,\n+                                            test_video_.frames);\n+  }\n+\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(video));\n+  delete(video);\n+}\n+\n+VP9_INSTANTIATE_TEST_CASE(\n+    VpxEncoderParmsGetToDecoder,\n+    ::testing::ValuesIn(kVP9EncodeParameterSet),\n+    ::testing::ValuesIn(kVP9EncodePerfTestVectors));\n+\n+VP10_INSTANTIATE_TEST_CASE(\n+    VpxEncoderParmsGetToDecoder,\n+    ::testing::ValuesIn(kVP9EncodeParameterSet),\n+    ::testing::ValuesIn(kVP9EncodePerfTestVectors));\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_end_to_end_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_end_to_end_test.cc"", ""patch"": ""@@ -0,0 +1,195 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""test/codec_factory.h\""\n+#include \""test/encode_test_driver.h\""\n+#include \""test/util.h\""\n+#include \""test/y4m_video_source.h\""\n+#include \""test/yuv_video_source.h\""\n+\n+namespace {\n+\n+const unsigned int kWidth  = 160;\n+const unsigned int kHeight = 90;\n+const unsigned int kFramerate = 50;\n+const unsigned int kFrames = 10;\n+const int kBitrate = 500;\n+// List of psnr thresholds for speed settings 0-7 and 5 encoding modes\n+const double kPsnrThreshold[][5] = {\n+  { 36.0, 37.0, 37.0, 37.0, 37.0 },\n+  { 35.0, 36.0, 36.0, 36.0, 36.0 },\n+  { 34.0, 35.0, 35.0, 35.0, 35.0 },\n+  { 33.0, 34.0, 34.0, 34.0, 34.0 },\n+  { 32.0, 33.0, 33.0, 33.0, 33.0 },\n+  { 31.0, 32.0, 32.0, 32.0, 32.0 },\n+  { 30.0, 31.0, 31.0, 31.0, 31.0 },\n+  { 29.0, 30.0, 30.0, 30.0, 30.0 },\n+};\n+\n+typedef struct {\n+  const char *filename;\n+  unsigned int input_bit_depth;\n+  vpx_img_fmt fmt;\n+  vpx_bit_depth_t bit_depth;\n+  unsigned int profile;\n+} TestVideoParam;\n+\n+const TestVideoParam kTestVectors[] = {\n+  {\""park_joy_90p_8_420.y4m\"", 8, VPX_IMG_FMT_I420, VPX_BITS_8, 0},\n+  {\""park_joy_90p_8_422.y4m\"", 8, VPX_IMG_FMT_I422, VPX_BITS_8, 1},\n+  {\""park_joy_90p_8_444.y4m\"", 8, VPX_IMG_FMT_I444, VPX_BITS_8, 1},\n+  {\""park_joy_90p_8_440.yuv\"", 8, VPX_IMG_FMT_I440, VPX_BITS_8, 1},\n+#if CONFIG_VP9_HIGHBITDEPTH\n+  {\""park_joy_90p_10_420.y4m\"", 10, VPX_IMG_FMT_I42016, VPX_BITS_10, 2},\n+  {\""park_joy_90p_10_422.y4m\"", 10, VPX_IMG_FMT_I42216, VPX_BITS_10, 3},\n+  {\""park_joy_90p_10_444.y4m\"", 10, VPX_IMG_FMT_I44416, VPX_BITS_10, 3},\n+  {\""park_joy_90p_10_440.yuv\"", 10, VPX_IMG_FMT_I44016, VPX_BITS_10, 3},\n+  {\""park_joy_90p_12_420.y4m\"", 12, VPX_IMG_FMT_I42016, VPX_BITS_12, 2},\n+  {\""park_joy_90p_12_422.y4m\"", 12, VPX_IMG_FMT_I42216, VPX_BITS_12, 3},\n+  {\""park_joy_90p_12_444.y4m\"", 12, VPX_IMG_FMT_I44416, VPX_BITS_12, 3},\n+  {\""park_joy_90p_12_440.yuv\"", 12, VPX_IMG_FMT_I44016, VPX_BITS_12, 3},\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+};\n+\n+// Encoding modes tested\n+const libvpx_test::TestMode kEncodingModeVectors[] = {\n+  ::libvpx_test::kTwoPassGood,\n+  ::libvpx_test::kOnePassGood,\n+  ::libvpx_test::kRealTime,\n+};\n+\n+// Speed settings tested\n+const int kCpuUsedVectors[] = {1, 2, 3, 5, 6};\n+\n+int is_extension_y4m(const char *filename) {\n+  const char *dot = strrchr(filename, '.');\n+  if (!dot || dot == filename)\n+    return 0;\n+  else\n+    return !strcmp(dot, \"".y4m\"");\n+}\n+\n+class EndToEndTestLarge\n+    : public ::libvpx_test::EncoderTest,\n+      public ::libvpx_test::CodecTestWith3Params<libvpx_test::TestMode, \\\n+                                                 TestVideoParam, int> {\n+ protected:\n+  EndToEndTestLarge()\n+      : EncoderTest(GET_PARAM(0)),\n+        test_video_param_(GET_PARAM(2)),\n+        cpu_used_(GET_PARAM(3)),\n+        psnr_(0.0),\n+        nframes_(0),\n+        encoding_mode_(GET_PARAM(1)) {\n+  }\n+\n+  virtual ~EndToEndTestLarge() {}\n+\n+  virtual void SetUp() {\n+    InitializeConfig();\n+    SetMode(encoding_mode_);\n+    if (encoding_mode_ != ::libvpx_test::kRealTime) {\n+      cfg_.g_lag_in_frames = 5;\n+      cfg_.rc_end_usage = VPX_VBR;\n+    } else {\n+      cfg_.g_lag_in_frames = 0;\n+      cfg_.rc_end_usage = VPX_CBR;\n+      cfg_.rc_buf_sz = 1000;\n+      cfg_.rc_buf_initial_sz = 500;\n+      cfg_.rc_buf_optimal_sz = 600;\n+    }\n+    dec_cfg_.threads = 4;\n+  }\n+\n+  virtual void BeginPassHook(unsigned int) {\n+    psnr_ = 0.0;\n+    nframes_ = 0;\n+  }\n+\n+  virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n+    psnr_ += pkt->data.psnr.psnr[0];\n+    nframes_++;\n+  }\n+\n+  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n+                                  ::libvpx_test::Encoder *encoder) {\n+    if (video->frame() == 1) {\n+      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING, 1);\n+      encoder->Control(VP9E_SET_TILE_COLUMNS, 4);\n+      encoder->Control(VP8E_SET_CPUUSED, cpu_used_);\n+      if (encoding_mode_ != ::libvpx_test::kRealTime) {\n+        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n+        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n+        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n+        encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n+      }\n+    }\n+  }\n+\n+  double GetAveragePsnr() const {\n+    if (nframes_)\n+      return psnr_ / nframes_;\n+    return 0.0;\n+  }\n+\n+  double GetPsnrThreshold() {\n+    return kPsnrThreshold[cpu_used_][encoding_mode_];\n+  }\n+\n+  TestVideoParam test_video_param_;\n+  int cpu_used_;\n+\n+ private:\n+  double psnr_;\n+  unsigned int nframes_;\n+  libvpx_test::TestMode encoding_mode_;\n+};\n+\n+TEST_P(EndToEndTestLarge, EndtoEndPSNRTest) {\n+  cfg_.rc_target_bitrate = kBitrate;\n+  cfg_.g_error_resilient = 0;\n+  cfg_.g_profile = test_video_param_.profile;\n+  cfg_.g_input_bit_depth = test_video_param_.input_bit_depth;\n+  cfg_.g_bit_depth = test_video_param_.bit_depth;\n+  init_flags_ = VPX_CODEC_USE_PSNR;\n+  if (cfg_.g_bit_depth > 8)\n+    init_flags_ |= VPX_CODEC_USE_HIGHBITDEPTH;\n+\n+  libvpx_test::VideoSource *video;\n+  if (is_extension_y4m(test_video_param_.filename)) {\n+    video = new libvpx_test::Y4mVideoSource(test_video_param_.filename,\n+                                            0, kFrames);\n+  } else {\n+    video = new libvpx_test::YUVVideoSource(test_video_param_.filename,\n+                                            test_video_param_.fmt,\n+                                            kWidth, kHeight,\n+                                            kFramerate, 1, 0, kFrames);\n+  }\n+\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(video));\n+  const double psnr = GetAveragePsnr();\n+  EXPECT_GT(psnr, GetPsnrThreshold());\n+  delete(video);\n+}\n+\n+VP9_INSTANTIATE_TEST_CASE(\n+    EndToEndTestLarge,\n+    ::testing::ValuesIn(kEncodingModeVectors),\n+    ::testing::ValuesIn(kTestVectors),\n+    ::testing::ValuesIn(kCpuUsedVectors));\n+\n+VP10_INSTANTIATE_TEST_CASE(\n+    EndToEndTestLarge,\n+    ::testing::ValuesIn(kEncodingModeVectors),\n+    ::testing::ValuesIn(kTestVectors),\n+    ::testing::ValuesIn(kCpuUsedVectors));\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_error_block_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_error_block_test.cc"", ""patch"": ""@@ -0,0 +1,151 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <cmath>\n+#include <cstdlib>\n+#include <string>\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vpx_config.h\""\n+#include \""./vp9_rtcd.h\""\n+#include \""test/acm_random.h\""\n+#include \""test/clear_system_state.h\""\n+#include \""test/register_state_check.h\""\n+#include \""test/util.h\""\n+#include \""vp9/common/vp9_entropy.h\""\n+#include \""vpx/vpx_codec.h\""\n+#include \""vpx/vpx_integer.h\""\n+\n+using libvpx_test::ACMRandom;\n+\n+namespace {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+const int kNumIterations = 1000;\n+\n+typedef int64_t (*ErrorBlockFunc)(const tran_low_t *coeff,\n+                                  const tran_low_t *dqcoeff,\n+                                  intptr_t block_size,\n+                                  int64_t *ssz, int bps);\n+\n+typedef std::tr1::tuple<ErrorBlockFunc, ErrorBlockFunc, vpx_bit_depth_t>\n+                        ErrorBlockParam;\n+\n+class ErrorBlockTest\n+  : public ::testing::TestWithParam<ErrorBlockParam> {\n+ public:\n+  virtual ~ErrorBlockTest() {}\n+  virtual void SetUp() {\n+    error_block_op_     = GET_PARAM(0);\n+    ref_error_block_op_ = GET_PARAM(1);\n+    bit_depth_  = GET_PARAM(2);\n+  }\n+\n+  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n+\n+ protected:\n+  vpx_bit_depth_t bit_depth_;\n+  ErrorBlockFunc error_block_op_;\n+  ErrorBlockFunc ref_error_block_op_;\n+};\n+\n+TEST_P(ErrorBlockTest, OperationCheck) {\n+  ACMRandom rnd(ACMRandom::DeterministicSeed());\n+  DECLARE_ALIGNED(16, tran_low_t, coeff[4096]);\n+  DECLARE_ALIGNED(16, tran_low_t, dqcoeff[4096]);\n+  int err_count_total = 0;\n+  int first_failure = -1;\n+  intptr_t block_size;\n+  int64_t ssz;\n+  int64_t ret;\n+  int64_t ref_ssz;\n+  int64_t ref_ret;\n+  for (int i = 0; i < kNumIterations; ++i) {\n+    int err_count = 0;\n+    block_size = 16 << (i % 9);  // All block sizes from 4x4, 8x4 ..64x64\n+    for (int j = 0; j < block_size; j++) {\n+      coeff[j]   = rnd(2 << 20) - (1 << 20);\n+      dqcoeff[j] = rnd(2 << 20) - (1 << 20);\n+    }\n+    ref_ret = ref_error_block_op_(coeff, dqcoeff, block_size, &ref_ssz,\n+                                  bit_depth_);\n+    ASM_REGISTER_STATE_CHECK(ret = error_block_op_(coeff, dqcoeff, block_size,\n+                                                   &ssz, bit_depth_));\n+    err_count += (ref_ret != ret) | (ref_ssz != ssz);\n+    if (err_count && !err_count_total) {\n+      first_failure = i;\n+    }\n+    err_count_total += err_count;\n+  }\n+  EXPECT_EQ(0, err_count_total)\n+      << \""Error: Error Block Test, C output doesn't match SSE2 output. \""\n+      << \""First failed at test case \"" << first_failure;\n+}\n+\n+TEST_P(ErrorBlockTest, ExtremeValues) {\n+  ACMRandom rnd(ACMRandom::DeterministicSeed());\n+  DECLARE_ALIGNED(16, tran_low_t, coeff[4096]);\n+  DECLARE_ALIGNED(16, tran_low_t, dqcoeff[4096]);\n+  int err_count_total = 0;\n+  int first_failure = -1;\n+  intptr_t block_size;\n+  int64_t ssz;\n+  int64_t ret;\n+  int64_t ref_ssz;\n+  int64_t ref_ret;\n+  int max_val = ((1 << 20) - 1);\n+  for (int i = 0; i < kNumIterations; ++i) {\n+    int err_count = 0;\n+    int k = (i / 9) % 5;\n+\n+    // Change the maximum coeff value, to test different bit boundaries\n+    if ( k == 4 && (i % 9) == 0 ) {\n+      max_val >>= 1;\n+    }\n+    block_size = 16 << (i % 9);  // All block sizes from 4x4, 8x4 ..64x64\n+    for (int j = 0; j < block_size; j++) {\n+      if (k < 4) {  // Test at maximum values\n+        coeff[j]   = k % 2 ? max_val : -max_val;\n+        dqcoeff[j] = (k >> 1) % 2 ? max_val : -max_val;\n+      } else {\n+        coeff[j]   = rnd(2 << 14) - (1 << 14);\n+        dqcoeff[j] = rnd(2 << 14) - (1 << 14);\n+      }\n+    }\n+    ref_ret = ref_error_block_op_(coeff, dqcoeff, block_size, &ref_ssz,\n+                                  bit_depth_);\n+    ASM_REGISTER_STATE_CHECK(ret = error_block_op_(coeff, dqcoeff, block_size,\n+                                                   &ssz, bit_depth_));\n+    err_count += (ref_ret != ret) | (ref_ssz != ssz);\n+    if (err_count && !err_count_total) {\n+      first_failure = i;\n+    }\n+    err_count_total += err_count;\n+  }\n+  EXPECT_EQ(0, err_count_total)\n+      << \""Error: Error Block Test, C output doesn't match SSE2 output. \""\n+      << \""First failed at test case \"" << first_failure;\n+}\n+\n+using std::tr1::make_tuple;\n+\n+#if HAVE_SSE2\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, ErrorBlockTest,\n+    ::testing::Values(\n+        make_tuple(&vp9_highbd_block_error_sse2,\n+                   &vp9_highbd_block_error_c, VPX_BITS_10),\n+        make_tuple(&vp9_highbd_block_error_sse2,\n+                   &vp9_highbd_block_error_c, VPX_BITS_12),\n+        make_tuple(&vp9_highbd_block_error_sse2,\n+                   &vp9_highbd_block_error_c, VPX_BITS_8)));\n+#endif  // HAVE_SSE2\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_ethread_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_ethread_test.cc"", ""patch"": ""@@ -0,0 +1,142 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <string>\n+#include <vector>\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+#include \""test/codec_factory.h\""\n+#include \""test/encode_test_driver.h\""\n+#include \""test/md5_helper.h\""\n+#include \""test/util.h\""\n+#include \""test/y4m_video_source.h\""\n+\n+namespace {\n+class VPxEncoderThreadTest\n+    : public ::libvpx_test::EncoderTest,\n+      public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, int> {\n+ protected:\n+  VPxEncoderThreadTest()\n+      : EncoderTest(GET_PARAM(0)),\n+        encoder_initialized_(false),\n+        tiles_(2),\n+        encoding_mode_(GET_PARAM(1)),\n+        set_cpu_used_(GET_PARAM(2)) {\n+    init_flags_ = VPX_CODEC_USE_PSNR;\n+    vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n+    cfg.w = 1280;\n+    cfg.h = 720;\n+    decoder_ = codec_->CreateDecoder(cfg, 0);\n+\n+    md5_.clear();\n+  }\n+  virtual ~VPxEncoderThreadTest() {\n+    delete decoder_;\n+  }\n+\n+  virtual void SetUp() {\n+    InitializeConfig();\n+    SetMode(encoding_mode_);\n+\n+    if (encoding_mode_ != ::libvpx_test::kRealTime) {\n+      cfg_.g_lag_in_frames = 3;\n+      cfg_.rc_end_usage = VPX_VBR;\n+      cfg_.rc_2pass_vbr_minsection_pct = 5;\n+      cfg_.rc_2pass_vbr_minsection_pct = 2000;\n+    } else {\n+      cfg_.g_lag_in_frames = 0;\n+      cfg_.rc_end_usage = VPX_CBR;\n+      cfg_.g_error_resilient = 1;\n+    }\n+    cfg_.rc_max_quantizer = 56;\n+    cfg_.rc_min_quantizer = 0;\n+  }\n+\n+  virtual void BeginPassHook(unsigned int /*pass*/) {\n+    encoder_initialized_ = false;\n+  }\n+\n+  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n+                                  ::libvpx_test::Encoder *encoder) {\n+    if (!encoder_initialized_) {\n+      // Encode 4 column tiles.\n+      encoder->Control(VP9E_SET_TILE_COLUMNS, tiles_);\n+      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n+      if (encoding_mode_ != ::libvpx_test::kRealTime) {\n+        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n+        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n+        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n+        encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n+      } else {\n+        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 0);\n+        encoder->Control(VP9E_SET_AQ_MODE, 3);\n+      }\n+      encoder_initialized_ = true;\n+    }\n+  }\n+\n+  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n+    const vpx_codec_err_t res = decoder_->DecodeFrame(\n+        reinterpret_cast<uint8_t*>(pkt->data.frame.buf), pkt->data.frame.sz);\n+    if (res != VPX_CODEC_OK) {\n+      abort_ = true;\n+      ASSERT_EQ(VPX_CODEC_OK, res);\n+    }\n+    const vpx_image_t *img = decoder_->GetDxData().Next();\n+\n+    if (img) {\n+      ::libvpx_test::MD5 md5_res;\n+      md5_res.Add(img);\n+      md5_.push_back(md5_res.Get());\n+    }\n+  }\n+\n+  bool encoder_initialized_;\n+  int tiles_;\n+  ::libvpx_test::TestMode encoding_mode_;\n+  int set_cpu_used_;\n+  ::libvpx_test::Decoder *decoder_;\n+  std::vector<std::string> md5_;\n+};\n+\n+TEST_P(VPxEncoderThreadTest, EncoderResultTest) {\n+  std::vector<std::string> single_thr_md5, multi_thr_md5;\n+\n+  ::libvpx_test::Y4mVideoSource video(\""niklas_1280_720_30.y4m\"", 15, 20);\n+\n+  cfg_.rc_target_bitrate = 1000;\n+\n+  // Encode using single thread.\n+  cfg_.g_threads = 1;\n+  init_flags_ = VPX_CODEC_USE_PSNR;\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+  single_thr_md5 = md5_;\n+  md5_.clear();\n+\n+  // Encode using multiple threads.\n+  cfg_.g_threads = 4;\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+  multi_thr_md5 = md5_;\n+  md5_.clear();\n+\n+  // Compare to check if two vectors are equal.\n+  ASSERT_EQ(single_thr_md5, multi_thr_md5);\n+}\n+\n+VP9_INSTANTIATE_TEST_CASE(\n+    VPxEncoderThreadTest,\n+    ::testing::Values(::libvpx_test::kTwoPassGood, ::libvpx_test::kOnePassGood,\n+                      ::libvpx_test::kRealTime),\n+    ::testing::Range(1, 9));\n+\n+VP10_INSTANTIATE_TEST_CASE(\n+    VPxEncoderThreadTest,\n+    ::testing::Values(::libvpx_test::kTwoPassGood, ::libvpx_test::kOnePassGood),\n+    ::testing::Range(1, 3));\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_frame_parallel_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_frame_parallel_test.cc"", ""patch"": ""@@ -0,0 +1,220 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+#include \""./vpx_config.h\""\n+#include \""test/codec_factory.h\""\n+#include \""test/decode_test_driver.h\""\n+#include \""test/ivf_video_source.h\""\n+#include \""test/md5_helper.h\""\n+#include \""test/util.h\""\n+#if CONFIG_WEBM_IO\n+#include \""test/webm_video_source.h\""\n+#endif\n+#include \""vpx_mem/vpx_mem.h\""\n+\n+namespace {\n+\n+using std::string;\n+\n+#if CONFIG_WEBM_IO\n+\n+struct PauseFileList {\n+  const char *name;\n+  // md5 sum for decoded frames which does not include skipped frames.\n+  const char *expected_md5;\n+  const int pause_frame_num;\n+};\n+\n+// Decodes |filename| with |num_threads|. Pause at the specified frame_num,\n+// seek to next key frame and then continue decoding until the end. Return\n+// the md5 of the decoded frames which does not include skipped frames.\n+string DecodeFileWithPause(const string &filename, int num_threads,\n+                           int pause_num) {\n+  libvpx_test::WebMVideoSource video(filename);\n+  video.Init();\n+  int in_frames = 0;\n+  int out_frames = 0;\n+\n+  vpx_codec_dec_cfg_t cfg = {0};\n+  cfg.threads = num_threads;\n+  vpx_codec_flags_t flags = 0;\n+  flags |= VPX_CODEC_USE_FRAME_THREADING;\n+  libvpx_test::VP9Decoder decoder(cfg, flags, 0);\n+\n+  libvpx_test::MD5 md5;\n+  video.Begin();\n+\n+  do {\n+    ++in_frames;\n+    const vpx_codec_err_t res =\n+        decoder.DecodeFrame(video.cxdata(), video.frame_size());\n+    if (res != VPX_CODEC_OK) {\n+      EXPECT_EQ(VPX_CODEC_OK, res) << decoder.DecodeError();\n+      break;\n+    }\n+\n+    // Pause at specified frame number.\n+    if (in_frames == pause_num) {\n+      // Flush the decoder and then seek to next key frame.\n+      decoder.DecodeFrame(NULL, 0);\n+      video.SeekToNextKeyFrame();\n+    } else {\n+      video.Next();\n+    }\n+\n+    // Flush the decoder at the end of the video.\n+    if (!video.cxdata())\n+      decoder.DecodeFrame(NULL, 0);\n+\n+    libvpx_test::DxDataIterator dec_iter = decoder.GetDxData();\n+    const vpx_image_t *img;\n+\n+    // Get decompressed data\n+    while ((img = dec_iter.Next())) {\n+      ++out_frames;\n+      md5.Add(img);\n+    }\n+  } while (video.cxdata() != NULL);\n+\n+  EXPECT_EQ(in_frames, out_frames) <<\n+      \""Input frame count does not match output frame count\"";\n+\n+  return string(md5.Get());\n+}\n+\n+void DecodeFilesWithPause(const PauseFileList files[]) {\n+  for (const PauseFileList *iter = files; iter->name != NULL; ++iter) {\n+    SCOPED_TRACE(iter->name);\n+    for (int t = 2; t <= 8; ++t) {\n+      EXPECT_EQ(iter->expected_md5,\n+                DecodeFileWithPause(iter->name, t, iter->pause_frame_num))\n+          << \""threads = \"" << t;\n+    }\n+  }\n+}\n+\n+TEST(VP9MultiThreadedFrameParallel, PauseSeekResume) {\n+  // vp90-2-07-frame_parallel-1.webm is a 40 frame video file with\n+  // one key frame for every ten frames.\n+  static const PauseFileList files[] = {\n+    { \""vp90-2-07-frame_parallel-1.webm\"",\n+      \""6ea7c3875d67252e7caf2bc6e75b36b1\"", 6 },\n+    { \""vp90-2-07-frame_parallel-1.webm\"",\n+      \""4bb634160c7356a8d7d4299b6dc83a45\"", 12 },\n+    { \""vp90-2-07-frame_parallel-1.webm\"",\n+      \""89772591e6ef461f9fa754f916c78ed8\"", 26 },\n+    { NULL, NULL, 0 },\n+  };\n+  DecodeFilesWithPause(files);\n+}\n+\n+struct FileList {\n+  const char *name;\n+  // md5 sum for decoded frames which does not include corrupted frames.\n+  const char *expected_md5;\n+  // Expected number of decoded frames which does not include corrupted frames.\n+  const int expected_frame_count;\n+};\n+\n+// Decodes |filename| with |num_threads|. Return the md5 of the decoded\n+// frames which does not include corrupted frames.\n+string DecodeFile(const string &filename, int num_threads,\n+                  int expected_frame_count) {\n+  libvpx_test::WebMVideoSource video(filename);\n+  video.Init();\n+\n+  vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n+  cfg.threads = num_threads;\n+  const vpx_codec_flags_t flags = VPX_CODEC_USE_FRAME_THREADING;\n+  libvpx_test::VP9Decoder decoder(cfg, flags, 0);\n+\n+  libvpx_test::MD5 md5;\n+  video.Begin();\n+\n+  int out_frames = 0;\n+  do {\n+    const vpx_codec_err_t res =\n+        decoder.DecodeFrame(video.cxdata(), video.frame_size());\n+    // TODO(hkuang): frame parallel mode should return an error on corruption.\n+    if (res != VPX_CODEC_OK) {\n+      EXPECT_EQ(VPX_CODEC_OK, res) << decoder.DecodeError();\n+      break;\n+    }\n+\n+    video.Next();\n+\n+    // Flush the decoder at the end of the video.\n+    if (!video.cxdata())\n+      decoder.DecodeFrame(NULL, 0);\n+\n+    libvpx_test::DxDataIterator dec_iter = decoder.GetDxData();\n+    const vpx_image_t *img;\n+\n+    // Get decompressed data\n+    while ((img = dec_iter.Next())) {\n+      ++out_frames;\n+      md5.Add(img);\n+    }\n+  } while (video.cxdata() != NULL);\n+\n+  EXPECT_EQ(expected_frame_count, out_frames) <<\n+      \""Input frame count does not match expected output frame count\"";\n+\n+  return string(md5.Get());\n+}\n+\n+void DecodeFiles(const FileList files[]) {\n+  for (const FileList *iter = files; iter->name != NULL; ++iter) {\n+    SCOPED_TRACE(iter->name);\n+    for (int t = 2; t <= 8; ++t) {\n+      EXPECT_EQ(iter->expected_md5,\n+                DecodeFile(iter->name, t, iter->expected_frame_count))\n+          << \""threads = \"" << t;\n+    }\n+  }\n+}\n+\n+TEST(VP9MultiThreadedFrameParallel, InvalidFileTest) {\n+  static const FileList files[] = {\n+    // invalid-vp90-2-07-frame_parallel-1.webm is a 40 frame video file with\n+    // one key frame for every ten frames. The 11th frame has corrupted data.\n+    { \""invalid-vp90-2-07-frame_parallel-1.webm\"",\n+      \""0549d0f45f60deaef8eb708e6c0eb6cb\"", 30 },\n+    // invalid-vp90-2-07-frame_parallel-2.webm is a 40 frame video file with\n+    // one key frame for every ten frames. The 1st and 31st frames have\n+    // corrupted data.\n+    { \""invalid-vp90-2-07-frame_parallel-2.webm\"",\n+      \""6a1f3cf6f9e7a364212fadb9580d525e\"", 20 },\n+    // invalid-vp90-2-07-frame_parallel-3.webm is a 40 frame video file with\n+    // one key frame for every ten frames. The 5th and 13th frames have\n+    // corrupted data.\n+    { \""invalid-vp90-2-07-frame_parallel-3.webm\"",\n+      \""8256544308de926b0681e04685b98677\"", 27 },\n+    { NULL, NULL, 0 },\n+  };\n+  DecodeFiles(files);\n+}\n+\n+TEST(VP9MultiThreadedFrameParallel, ValidFileTest) {\n+  static const FileList files[] = {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+    { \""vp92-2-20-10bit-yuv420.webm\"",\n+      \""a16b99df180c584e8db2ffeda987d293\"", 10 },\n+#endif\n+    { NULL, NULL, 0 },\n+  };\n+  DecodeFiles(files);\n+}\n+#endif  // CONFIG_WEBM_IO\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_intrapred_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_intrapred_test.cc"", ""patch"": ""@@ -0,0 +1,301 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <string>\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vpx_config.h\""\n+#include \""./vpx_dsp_rtcd.h\""\n+#include \""test/acm_random.h\""\n+#include \""test/clear_system_state.h\""\n+#include \""test/register_state_check.h\""\n+#include \""test/util.h\""\n+#include \""vp9/common/vp9_blockd.h\""\n+#include \""vp9/common/vp9_pred_common.h\""\n+#include \""vpx_mem/vpx_mem.h\""\n+\n+namespace {\n+\n+using libvpx_test::ACMRandom;\n+\n+const int count_test_block = 100000;\n+\n+// Base class for VP9 intra prediction tests.\n+class VP9IntraPredBase {\n+ public:\n+  virtual ~VP9IntraPredBase() { libvpx_test::ClearSystemState(); }\n+\n+ protected:\n+  virtual void Predict(PREDICTION_MODE mode) = 0;\n+\n+  void CheckPrediction(int test_case_number, int *error_count) const {\n+    // For each pixel ensure that the calculated value is the same as reference.\n+    for (int y = 0; y < block_size_; y++) {\n+      for (int x = 0; x < block_size_; x++) {\n+        *error_count += ref_dst_[x + y * stride_] != dst_[x + y * stride_];\n+        if (*error_count == 1) {\n+          ASSERT_EQ(ref_dst_[x + y * stride_], dst_[x + y * stride_])\n+              << \"" Failed on Test Case Number \""<< test_case_number;\n+        }\n+      }\n+    }\n+  }\n+\n+  void RunTest(uint16_t* left_col, uint16_t* above_data,\n+               uint16_t* dst, uint16_t* ref_dst) {\n+    ACMRandom rnd(ACMRandom::DeterministicSeed());\n+    left_col_ = left_col;\n+    dst_ = dst;\n+    ref_dst_ = ref_dst;\n+    above_row_ = above_data + 16;\n+    int error_count = 0;\n+    for (int i = 0; i < count_test_block; ++i) {\n+      // Fill edges with random data, try first with saturated values.\n+      for (int x = -1; x <= block_size_*2; x++) {\n+        if (i == 0) {\n+          above_row_[x] = mask_;\n+        } else {\n+          above_row_[x] = rnd.Rand16() & mask_;\n+        }\n+      }\n+      for (int y = 0; y < block_size_; y++) {\n+        if (i == 0) {\n+          left_col_[y] = mask_;\n+        } else {\n+          left_col_[y] = rnd.Rand16() & mask_;\n+        }\n+      }\n+      Predict(DC_PRED);\n+      CheckPrediction(i, &error_count);\n+    }\n+    ASSERT_EQ(0, error_count);\n+  }\n+\n+  int block_size_;\n+  uint16_t *above_row_;\n+  uint16_t *left_col_;\n+  uint16_t *dst_;\n+  uint16_t *ref_dst_;\n+  ptrdiff_t stride_;\n+  int mask_;\n+};\n+\n+typedef void (*intra_pred_fn_t)(\n+      uint16_t *dst, ptrdiff_t stride, const uint16_t *above,\n+      const uint16_t *left, int bps);\n+typedef std::tr1::tuple<intra_pred_fn_t,\n+                        intra_pred_fn_t, int, int> intra_pred_params_t;\n+class VP9IntraPredTest\n+    : public VP9IntraPredBase,\n+      public ::testing::TestWithParam<intra_pred_params_t> {\n+\n+  virtual void SetUp() {\n+    pred_fn_    = GET_PARAM(0);\n+    ref_fn_     = GET_PARAM(1);\n+    block_size_ = GET_PARAM(2);\n+    bit_depth_  = GET_PARAM(3);\n+    stride_     = block_size_ * 3;\n+    mask_       = (1 << bit_depth_) - 1;\n+  }\n+\n+  virtual void Predict(PREDICTION_MODE mode) {\n+    const uint16_t *const_above_row = above_row_;\n+    const uint16_t *const_left_col = left_col_;\n+    ref_fn_(ref_dst_, stride_, const_above_row, const_left_col, bit_depth_);\n+    ASM_REGISTER_STATE_CHECK(pred_fn_(dst_, stride_, const_above_row,\n+                                      const_left_col, bit_depth_));\n+  }\n+  intra_pred_fn_t pred_fn_;\n+  intra_pred_fn_t ref_fn_;\n+  int bit_depth_;\n+};\n+\n+TEST_P(VP9IntraPredTest, IntraPredTests) {\n+  // max block size is 32\n+  DECLARE_ALIGNED(16, uint16_t, left_col[2*32]);\n+  DECLARE_ALIGNED(16, uint16_t, above_data[2*32+32]);\n+  DECLARE_ALIGNED(16, uint16_t, dst[3 * 32 * 32]);\n+  DECLARE_ALIGNED(16, uint16_t, ref_dst[3 * 32 * 32]);\n+  RunTest(left_col, above_data, dst, ref_dst);\n+}\n+\n+using std::tr1::make_tuple;\n+\n+#if HAVE_SSE2\n+#if CONFIG_VP9_HIGHBITDEPTH\n+#if CONFIG_USE_X86INC\n+#if ARCH_X86_64\n+INSTANTIATE_TEST_CASE_P(SSE2_TO_C_8, VP9IntraPredTest,\n+                        ::testing::Values(\n+                            make_tuple(&vpx_highbd_dc_predictor_32x32_sse2,\n+                                       &vpx_highbd_dc_predictor_32x32_c, 32, 8),\n+                            make_tuple(&vpx_highbd_tm_predictor_16x16_sse2,\n+                                       &vpx_highbd_tm_predictor_16x16_c, 16, 8),\n+                            make_tuple(&vpx_highbd_tm_predictor_32x32_sse2,\n+                                       &vpx_highbd_tm_predictor_32x32_c, 32, 8),\n+                            make_tuple(&vpx_highbd_dc_predictor_4x4_sse,\n+                                       &vpx_highbd_dc_predictor_4x4_c, 4, 8),\n+                            make_tuple(&vpx_highbd_dc_predictor_8x8_sse2,\n+                                       &vpx_highbd_dc_predictor_8x8_c, 8, 8),\n+                            make_tuple(&vpx_highbd_dc_predictor_16x16_sse2,\n+                                       &vpx_highbd_dc_predictor_16x16_c, 16, 8),\n+                            make_tuple(&vpx_highbd_v_predictor_4x4_sse,\n+                                       &vpx_highbd_v_predictor_4x4_c, 4, 8),\n+                            make_tuple(&vpx_highbd_v_predictor_8x8_sse2,\n+                                       &vpx_highbd_v_predictor_8x8_c, 8, 8),\n+                            make_tuple(&vpx_highbd_v_predictor_16x16_sse2,\n+                                       &vpx_highbd_v_predictor_16x16_c, 16, 8),\n+                            make_tuple(&vpx_highbd_v_predictor_32x32_sse2,\n+                                       &vpx_highbd_v_predictor_32x32_c, 32, 8),\n+                            make_tuple(&vpx_highbd_tm_predictor_4x4_sse,\n+                                       &vpx_highbd_tm_predictor_4x4_c, 4, 8),\n+                            make_tuple(&vpx_highbd_tm_predictor_8x8_sse2,\n+                                       &vpx_highbd_tm_predictor_8x8_c, 8, 8)));\n+#else\n+INSTANTIATE_TEST_CASE_P(SSE2_TO_C_8, VP9IntraPredTest,\n+                        ::testing::Values(\n+                            make_tuple(&vpx_highbd_dc_predictor_4x4_sse,\n+                                       &vpx_highbd_dc_predictor_4x4_c, 4, 8),\n+                            make_tuple(&vpx_highbd_dc_predictor_8x8_sse2,\n+                                       &vpx_highbd_dc_predictor_8x8_c, 8, 8),\n+                            make_tuple(&vpx_highbd_dc_predictor_16x16_sse2,\n+                                       &vpx_highbd_dc_predictor_16x16_c, 16, 8),\n+                            make_tuple(&vpx_highbd_v_predictor_4x4_sse,\n+                                       &vpx_highbd_v_predictor_4x4_c, 4, 8),\n+                            make_tuple(&vpx_highbd_v_predictor_8x8_sse2,\n+                                       &vpx_highbd_v_predictor_8x8_c, 8, 8),\n+                            make_tuple(&vpx_highbd_v_predictor_16x16_sse2,\n+                                       &vpx_highbd_v_predictor_16x16_c, 16, 8),\n+                            make_tuple(&vpx_highbd_v_predictor_32x32_sse2,\n+                                       &vpx_highbd_v_predictor_32x32_c, 32, 8),\n+                            make_tuple(&vpx_highbd_tm_predictor_4x4_sse,\n+                                       &vpx_highbd_tm_predictor_4x4_c, 4, 8),\n+                            make_tuple(&vpx_highbd_tm_predictor_8x8_sse2,\n+                                       &vpx_highbd_tm_predictor_8x8_c, 8, 8)));\n+#endif  // !ARCH_X86_64\n+\n+#if ARCH_X86_64\n+INSTANTIATE_TEST_CASE_P(SSE2_TO_C_10, VP9IntraPredTest,\n+                        ::testing::Values(\n+                            make_tuple(&vpx_highbd_dc_predictor_32x32_sse2,\n+                                       &vpx_highbd_dc_predictor_32x32_c, 32,\n+                                       10),\n+                            make_tuple(&vpx_highbd_tm_predictor_16x16_sse2,\n+                                       &vpx_highbd_tm_predictor_16x16_c, 16,\n+                                       10),\n+                            make_tuple(&vpx_highbd_tm_predictor_32x32_sse2,\n+                                       &vpx_highbd_tm_predictor_32x32_c, 32,\n+                                       10),\n+                            make_tuple(&vpx_highbd_dc_predictor_4x4_sse,\n+                                       &vpx_highbd_dc_predictor_4x4_c, 4, 10),\n+                            make_tuple(&vpx_highbd_dc_predictor_8x8_sse2,\n+                                       &vpx_highbd_dc_predictor_8x8_c, 8, 10),\n+                            make_tuple(&vpx_highbd_dc_predictor_16x16_sse2,\n+                                       &vpx_highbd_dc_predictor_16x16_c, 16,\n+                                       10),\n+                            make_tuple(&vpx_highbd_v_predictor_4x4_sse,\n+                                       &vpx_highbd_v_predictor_4x4_c, 4, 10),\n+                            make_tuple(&vpx_highbd_v_predictor_8x8_sse2,\n+                                       &vpx_highbd_v_predictor_8x8_c, 8, 10),\n+                            make_tuple(&vpx_highbd_v_predictor_16x16_sse2,\n+                                       &vpx_highbd_v_predictor_16x16_c, 16,\n+                                       10),\n+                            make_tuple(&vpx_highbd_v_predictor_32x32_sse2,\n+                                       &vpx_highbd_v_predictor_32x32_c, 32,\n+                                       10),\n+                            make_tuple(&vpx_highbd_tm_predictor_4x4_sse,\n+                                       &vpx_highbd_tm_predictor_4x4_c, 4, 10),\n+                            make_tuple(&vpx_highbd_tm_predictor_8x8_sse2,\n+                                       &vpx_highbd_tm_predictor_8x8_c, 8, 10)));\n+#else\n+INSTANTIATE_TEST_CASE_P(SSE2_TO_C_10, VP9IntraPredTest,\n+                        ::testing::Values(\n+                            make_tuple(&vpx_highbd_dc_predictor_4x4_sse,\n+                                       &vpx_highbd_dc_predictor_4x4_c, 4, 10),\n+                            make_tuple(&vpx_highbd_dc_predictor_8x8_sse2,\n+                                       &vpx_highbd_dc_predictor_8x8_c, 8, 10),\n+                            make_tuple(&vpx_highbd_dc_predictor_16x16_sse2,\n+                                       &vpx_highbd_dc_predictor_16x16_c, 16,\n+                                       10),\n+                            make_tuple(&vpx_highbd_v_predictor_4x4_sse,\n+                                       &vpx_highbd_v_predictor_4x4_c, 4, 10),\n+                            make_tuple(&vpx_highbd_v_predictor_8x8_sse2,\n+                                       &vpx_highbd_v_predictor_8x8_c, 8, 10),\n+                            make_tuple(&vpx_highbd_v_predictor_16x16_sse2,\n+                                       &vpx_highbd_v_predictor_16x16_c, 16, 10),\n+                            make_tuple(&vpx_highbd_v_predictor_32x32_sse2,\n+                                       &vpx_highbd_v_predictor_32x32_c, 32, 10),\n+                            make_tuple(&vpx_highbd_tm_predictor_4x4_sse,\n+                                       &vpx_highbd_tm_predictor_4x4_c, 4, 10),\n+                            make_tuple(&vpx_highbd_tm_predictor_8x8_sse2,\n+                                       &vpx_highbd_tm_predictor_8x8_c, 8, 10)));\n+#endif  // !ARCH_X86_64\n+\n+#if ARCH_X86_64\n+INSTANTIATE_TEST_CASE_P(SSE2_TO_C_12, VP9IntraPredTest,\n+                        ::testing::Values(\n+                            make_tuple(&vpx_highbd_dc_predictor_32x32_sse2,\n+                                       &vpx_highbd_dc_predictor_32x32_c, 32,\n+                                       12),\n+                            make_tuple(&vpx_highbd_tm_predictor_16x16_sse2,\n+                                       &vpx_highbd_tm_predictor_16x16_c, 16,\n+                                       12),\n+                            make_tuple(&vpx_highbd_tm_predictor_32x32_sse2,\n+                                       &vpx_highbd_tm_predictor_32x32_c, 32,\n+                                       12),\n+                            make_tuple(&vpx_highbd_dc_predictor_4x4_sse,\n+                                       &vpx_highbd_dc_predictor_4x4_c, 4, 12),\n+                            make_tuple(&vpx_highbd_dc_predictor_8x8_sse2,\n+                                       &vpx_highbd_dc_predictor_8x8_c, 8, 12),\n+                            make_tuple(&vpx_highbd_dc_predictor_16x16_sse2,\n+                                       &vpx_highbd_dc_predictor_16x16_c, 16,\n+                                       12),\n+                            make_tuple(&vpx_highbd_v_predictor_4x4_sse,\n+                                       &vpx_highbd_v_predictor_4x4_c, 4, 12),\n+                            make_tuple(&vpx_highbd_v_predictor_8x8_sse2,\n+                                       &vpx_highbd_v_predictor_8x8_c, 8, 12),\n+                            make_tuple(&vpx_highbd_v_predictor_16x16_sse2,\n+                                       &vpx_highbd_v_predictor_16x16_c, 16,\n+                                       12),\n+                            make_tuple(&vpx_highbd_v_predictor_32x32_sse2,\n+                                       &vpx_highbd_v_predictor_32x32_c, 32,\n+                                       12),\n+                            make_tuple(&vpx_highbd_tm_predictor_4x4_sse,\n+                                       &vpx_highbd_tm_predictor_4x4_c, 4, 12),\n+                            make_tuple(&vpx_highbd_tm_predictor_8x8_sse2,\n+                                       &vpx_highbd_tm_predictor_8x8_c, 8, 12)));\n+#else\n+INSTANTIATE_TEST_CASE_P(SSE2_TO_C_12, VP9IntraPredTest,\n+                        ::testing::Values(\n+                            make_tuple(&vpx_highbd_dc_predictor_4x4_sse,\n+                                       &vpx_highbd_dc_predictor_4x4_c, 4, 12),\n+                            make_tuple(&vpx_highbd_dc_predictor_8x8_sse2,\n+                                       &vpx_highbd_dc_predictor_8x8_c, 8, 12),\n+                            make_tuple(&vpx_highbd_dc_predictor_16x16_sse2,\n+                                       &vpx_highbd_dc_predictor_16x16_c, 16,\n+                                       12),\n+                            make_tuple(&vpx_highbd_v_predictor_4x4_sse,\n+                                       &vpx_highbd_v_predictor_4x4_c, 4, 12),\n+                            make_tuple(&vpx_highbd_v_predictor_8x8_sse2,\n+                                       &vpx_highbd_v_predictor_8x8_c, 8, 12),\n+                            make_tuple(&vpx_highbd_v_predictor_16x16_sse2,\n+                                       &vpx_highbd_v_predictor_16x16_c, 16, 12),\n+                            make_tuple(&vpx_highbd_v_predictor_32x32_sse2,\n+                                       &vpx_highbd_v_predictor_32x32_c, 32, 12),\n+                            make_tuple(&vpx_highbd_tm_predictor_4x4_sse,\n+                                       &vpx_highbd_tm_predictor_4x4_c, 4, 12),\n+                            make_tuple(&vpx_highbd_tm_predictor_8x8_sse2,\n+                                       &vpx_highbd_tm_predictor_8x8_c, 8, 12)));\n+#endif  // !ARCH_X86_64\n+#endif  // CONFIG_USE_X86INC\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+#endif  // HAVE_SSE2\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_lossless_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_lossless_test.cc"", ""patch"": ""@@ -7,8 +7,10 @@\n\n  *  in the file PATENTS.  All contributing project authors may\n  *  be found in the AUTHORS file in the root of the source tree.\n  */\n-#include \""./vpx_config.h\""\n+\n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vpx_config.h\""\n #include \""test/codec_factory.h\""\n #include \""test/encode_test_driver.h\""\n #include \""test/i420_video_source.h\""\n@@ -19,23 +21,34 @@\n\n \n const int kMaxPsnr = 100;\n \n-class LosslessTestLarge : public ::libvpx_test::EncoderTest,\n+class LosslessTest : public ::libvpx_test::EncoderTest,\n     public ::libvpx_test::CodecTestWithParam<libvpx_test::TestMode> {\n  protected:\n-  LosslessTestLarge()\n+  LosslessTest()\n       : EncoderTest(GET_PARAM(0)),\n         psnr_(kMaxPsnr),\n         nframes_(0),\n         encoding_mode_(GET_PARAM(1)) {\n   }\n \n-  virtual ~LosslessTestLarge() {}\n+  virtual ~LosslessTest() {}\n \n   virtual void SetUp() {\n     InitializeConfig();\n     SetMode(encoding_mode_);\n   }\n \n+  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n+                                  ::libvpx_test::Encoder *encoder) {\n+    if (video->frame() == 1) {\n+      // Only call Control if quantizer > 0 to verify that using quantizer\n+      // alone will activate lossless\n+      if (cfg_.rc_max_quantizer > 0 || cfg_.rc_min_quantizer > 0) {\n+        encoder->Control(VP9E_SET_LOSSLESS, 1);\n+      }\n+    }\n+  }\n+\n   virtual void BeginPassHook(unsigned int /*pass*/) {\n     psnr_ = kMaxPsnr;\n     nframes_ = 0;\n@@ -56,7 +69,7 @@\n\n   libvpx_test::TestMode encoding_mode_;\n };\n \n-TEST_P(LosslessTestLarge, TestLossLessEncoding) {\n+TEST_P(LosslessTest, TestLossLessEncoding) {\n   const vpx_rational timebase = { 33333333, 1000000000 };\n   cfg_.g_timebase = timebase;\n   cfg_.rc_target_bitrate = 2000;\n@@ -74,7 +87,7 @@\n\n   EXPECT_GE(psnr_lossless, kMaxPsnr);\n }\n \n-TEST_P(LosslessTestLarge, TestLossLessEncoding444) {\n+TEST_P(LosslessTest, TestLossLessEncoding444) {\n   libvpx_test::Y4mVideoSource video(\""rush_hour_444.y4m\"", 0, 10);\n \n   cfg_.g_profile = 1;\n@@ -91,5 +104,31 @@\n\n   EXPECT_GE(psnr_lossless, kMaxPsnr);\n }\n \n-VP9_INSTANTIATE_TEST_CASE(LosslessTestLarge, ALL_TEST_MODES);\n+TEST_P(LosslessTest, TestLossLessEncodingCtrl) {\n+  const vpx_rational timebase = { 33333333, 1000000000 };\n+  cfg_.g_timebase = timebase;\n+  cfg_.rc_target_bitrate = 2000;\n+  cfg_.g_lag_in_frames = 25;\n+  // Intentionally set Q > 0, to make sure control can be used to activate\n+  // lossless\n+  cfg_.rc_min_quantizer = 10;\n+  cfg_.rc_max_quantizer = 20;\n+\n+  init_flags_ = VPX_CODEC_USE_PSNR;\n+\n+  libvpx_test::I420VideoSource video(\""hantro_collage_w352h288.yuv\"", 352, 288,\n+                                     timebase.den, timebase.num, 0, 10);\n+  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n+  const double psnr_lossless = GetMinPsnr();\n+  EXPECT_GE(psnr_lossless, kMaxPsnr);\n+}\n+\n+VP9_INSTANTIATE_TEST_CASE(LosslessTest,\n+                          ::testing::Values(::libvpx_test::kRealTime,\n+                                            ::libvpx_test::kOnePassGood,\n+                                            ::libvpx_test::kTwoPassGood));\n+\n+VP10_INSTANTIATE_TEST_CASE(LosslessTest,\n+                           ::testing::Values(::libvpx_test::kOnePassGood,\n+                                             ::libvpx_test::kTwoPassGood));\n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_quantize_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_quantize_test.cc"", ""patch"": ""@@ -0,0 +1,351 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <math.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vpx_config.h\""\n+#include \""./vpx_dsp_rtcd.h\""\n+#include \""test/acm_random.h\""\n+#include \""test/clear_system_state.h\""\n+#include \""test/register_state_check.h\""\n+#include \""test/util.h\""\n+#include \""vp9/common/vp9_entropy.h\""\n+#include \""vp9/common/vp9_scan.h\""\n+#include \""vpx/vpx_codec.h\""\n+#include \""vpx/vpx_integer.h\""\n+\n+using libvpx_test::ACMRandom;\n+\n+namespace {\n+#if CONFIG_VP9_HIGHBITDEPTH\n+const int number_of_iterations = 100;\n+\n+typedef void (*QuantizeFunc)(const tran_low_t *coeff, intptr_t count,\n+                             int skip_block, const int16_t *zbin,\n+                             const int16_t *round, const int16_t *quant,\n+                             const int16_t *quant_shift,\n+                             tran_low_t *qcoeff, tran_low_t *dqcoeff,\n+                             const int16_t *dequant,\n+                             uint16_t *eob, const int16_t *scan,\n+                             const int16_t *iscan);\n+typedef std::tr1::tuple<QuantizeFunc, QuantizeFunc, vpx_bit_depth_t>\n+    QuantizeParam;\n+\n+class VP9QuantizeTest : public ::testing::TestWithParam<QuantizeParam> {\n+ public:\n+  virtual ~VP9QuantizeTest() {}\n+  virtual void SetUp() {\n+    quantize_op_   = GET_PARAM(0);\n+    ref_quantize_op_ = GET_PARAM(1);\n+    bit_depth_  = GET_PARAM(2);\n+    mask_ = (1 << bit_depth_) - 1;\n+  }\n+\n+  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n+\n+ protected:\n+  vpx_bit_depth_t bit_depth_;\n+  int mask_;\n+  QuantizeFunc quantize_op_;\n+  QuantizeFunc ref_quantize_op_;\n+};\n+\n+class VP9Quantize32Test : public ::testing::TestWithParam<QuantizeParam> {\n+ public:\n+  virtual ~VP9Quantize32Test() {}\n+  virtual void SetUp() {\n+    quantize_op_   = GET_PARAM(0);\n+    ref_quantize_op_ = GET_PARAM(1);\n+    bit_depth_  = GET_PARAM(2);\n+    mask_ = (1 << bit_depth_) - 1;\n+  }\n+\n+  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n+\n+ protected:\n+  vpx_bit_depth_t bit_depth_;\n+  int mask_;\n+  QuantizeFunc quantize_op_;\n+  QuantizeFunc ref_quantize_op_;\n+};\n+\n+TEST_P(VP9QuantizeTest, OperationCheck) {\n+  ACMRandom rnd(ACMRandom::DeterministicSeed());\n+  DECLARE_ALIGNED(16, tran_low_t, coeff_ptr[256]);\n+  DECLARE_ALIGNED(16, int16_t, zbin_ptr[2]);\n+  DECLARE_ALIGNED(16, int16_t, round_ptr[2]);\n+  DECLARE_ALIGNED(16, int16_t, quant_ptr[2]);\n+  DECLARE_ALIGNED(16, int16_t, quant_shift_ptr[2]);\n+  DECLARE_ALIGNED(16, tran_low_t, qcoeff_ptr[256]);\n+  DECLARE_ALIGNED(16, tran_low_t, dqcoeff_ptr[256]);\n+  DECLARE_ALIGNED(16, tran_low_t, ref_qcoeff_ptr[256]);\n+  DECLARE_ALIGNED(16, tran_low_t, ref_dqcoeff_ptr[256]);\n+  DECLARE_ALIGNED(16, int16_t, dequant_ptr[2]);\n+  DECLARE_ALIGNED(16, uint16_t, eob_ptr[1]);\n+  DECLARE_ALIGNED(16, uint16_t, ref_eob_ptr[1]);\n+  int err_count_total = 0;\n+  int first_failure = -1;\n+  for (int i = 0; i < number_of_iterations; ++i) {\n+    const int skip_block = i == 0;\n+    const TX_SIZE sz = (TX_SIZE)(i % 3);  // TX_4X4, TX_8X8 TX_16X16\n+    const TX_TYPE tx_type = (TX_TYPE)((i >> 2) % 3);\n+    const scan_order *scan_order = &vp9_scan_orders[sz][tx_type];\n+    const int count = (4 << sz) * (4 << sz);  // 16, 64, 256\n+    int err_count = 0;\n+    *eob_ptr = rnd.Rand16();\n+    *ref_eob_ptr = *eob_ptr;\n+    for (int j = 0; j < count; j++) {\n+      coeff_ptr[j] = rnd.Rand16()&mask_;\n+    }\n+    for (int j = 0; j < 2; j++) {\n+      zbin_ptr[j] = rnd.Rand16()&mask_;\n+      round_ptr[j] = rnd.Rand16();\n+      quant_ptr[j] = rnd.Rand16();\n+      quant_shift_ptr[j] = rnd.Rand16();\n+      dequant_ptr[j] = rnd.Rand16();\n+    }\n+    ref_quantize_op_(coeff_ptr, count, skip_block, zbin_ptr, round_ptr,\n+                     quant_ptr, quant_shift_ptr, ref_qcoeff_ptr,\n+                     ref_dqcoeff_ptr, dequant_ptr,\n+                     ref_eob_ptr, scan_order->scan, scan_order->iscan);\n+    ASM_REGISTER_STATE_CHECK(quantize_op_(coeff_ptr, count, skip_block,\n+                                          zbin_ptr, round_ptr, quant_ptr,\n+                                          quant_shift_ptr, qcoeff_ptr,\n+                                          dqcoeff_ptr, dequant_ptr, eob_ptr,\n+                                          scan_order->scan, scan_order->iscan));\n+    for (int j = 0; j < sz; ++j) {\n+      err_count += (ref_qcoeff_ptr[j]  != qcoeff_ptr[j]) |\n+          (ref_dqcoeff_ptr[j] != dqcoeff_ptr[j]);\n+    }\n+    err_count += (*ref_eob_ptr != *eob_ptr);\n+    if (err_count && !err_count_total) {\n+      first_failure = i;\n+    }\n+    err_count_total += err_count;\n+  }\n+  EXPECT_EQ(0, err_count_total)\n+      << \""Error: Quantization Test, C output doesn't match SSE2 output. \""\n+      << \""First failed at test case \"" << first_failure;\n+}\n+\n+TEST_P(VP9Quantize32Test, OperationCheck) {\n+  ACMRandom rnd(ACMRandom::DeterministicSeed());\n+  DECLARE_ALIGNED(16, tran_low_t, coeff_ptr[1024]);\n+  DECLARE_ALIGNED(16, int16_t, zbin_ptr[2]);\n+  DECLARE_ALIGNED(16, int16_t, round_ptr[2]);\n+  DECLARE_ALIGNED(16, int16_t, quant_ptr[2]);\n+  DECLARE_ALIGNED(16, int16_t, quant_shift_ptr[2]);\n+  DECLARE_ALIGNED(16, tran_low_t, qcoeff_ptr[1024]);\n+  DECLARE_ALIGNED(16, tran_low_t, dqcoeff_ptr[1024]);\n+  DECLARE_ALIGNED(16, tran_low_t, ref_qcoeff_ptr[1024]);\n+  DECLARE_ALIGNED(16, tran_low_t, ref_dqcoeff_ptr[1024]);\n+  DECLARE_ALIGNED(16, int16_t, dequant_ptr[2]);\n+  DECLARE_ALIGNED(16, uint16_t, eob_ptr[1]);\n+  DECLARE_ALIGNED(16, uint16_t, ref_eob_ptr[1]);\n+  int err_count_total = 0;\n+  int first_failure = -1;\n+  for (int i = 0; i < number_of_iterations; ++i) {\n+    const int skip_block = i == 0;\n+    const TX_SIZE sz = TX_32X32;\n+    const TX_TYPE tx_type = (TX_TYPE)(i % 4);\n+    const scan_order *scan_order = &vp9_scan_orders[sz][tx_type];\n+    const int count = (4 << sz) * (4 << sz);  // 1024\n+    int err_count = 0;\n+    *eob_ptr = rnd.Rand16();\n+    *ref_eob_ptr = *eob_ptr;\n+    for (int j = 0; j < count; j++) {\n+      coeff_ptr[j] = rnd.Rand16()&mask_;\n+    }\n+    for (int j = 0; j < 2; j++) {\n+      zbin_ptr[j] = rnd.Rand16()&mask_;\n+      round_ptr[j] = rnd.Rand16();\n+      quant_ptr[j] = rnd.Rand16();\n+      quant_shift_ptr[j] = rnd.Rand16();\n+      dequant_ptr[j] = rnd.Rand16();\n+    }\n+    ref_quantize_op_(coeff_ptr, count, skip_block, zbin_ptr, round_ptr,\n+                     quant_ptr, quant_shift_ptr, ref_qcoeff_ptr,\n+                     ref_dqcoeff_ptr, dequant_ptr,\n+                     ref_eob_ptr, scan_order->scan, scan_order->iscan);\n+    ASM_REGISTER_STATE_CHECK(quantize_op_(coeff_ptr, count, skip_block,\n+                                          zbin_ptr, round_ptr, quant_ptr,\n+                                          quant_shift_ptr, qcoeff_ptr,\n+                                          dqcoeff_ptr, dequant_ptr, eob_ptr,\n+                                          scan_order->scan, scan_order->iscan));\n+    for (int j = 0; j < sz; ++j) {\n+      err_count += (ref_qcoeff_ptr[j]  != qcoeff_ptr[j]) |\n+          (ref_dqcoeff_ptr[j] != dqcoeff_ptr[j]);\n+    }\n+    err_count += (*ref_eob_ptr != *eob_ptr);\n+    if (err_count && !err_count_total) {\n+      first_failure = i;\n+    }\n+    err_count_total += err_count;\n+  }\n+  EXPECT_EQ(0, err_count_total)\n+      << \""Error: Quantization Test, C output doesn't match SSE2 output. \""\n+      << \""First failed at test case \"" << first_failure;\n+}\n+\n+TEST_P(VP9QuantizeTest, EOBCheck) {\n+  ACMRandom rnd(ACMRandom::DeterministicSeed());\n+  DECLARE_ALIGNED(16, tran_low_t, coeff_ptr[256]);\n+  DECLARE_ALIGNED(16, int16_t, zbin_ptr[2]);\n+  DECLARE_ALIGNED(16, int16_t, round_ptr[2]);\n+  DECLARE_ALIGNED(16, int16_t, quant_ptr[2]);\n+  DECLARE_ALIGNED(16, int16_t, quant_shift_ptr[2]);\n+  DECLARE_ALIGNED(16, tran_low_t, qcoeff_ptr[256]);\n+  DECLARE_ALIGNED(16, tran_low_t, dqcoeff_ptr[256]);\n+  DECLARE_ALIGNED(16, tran_low_t, ref_qcoeff_ptr[256]);\n+  DECLARE_ALIGNED(16, tran_low_t, ref_dqcoeff_ptr[256]);\n+  DECLARE_ALIGNED(16, int16_t, dequant_ptr[2]);\n+  DECLARE_ALIGNED(16, uint16_t, eob_ptr[1]);\n+  DECLARE_ALIGNED(16, uint16_t, ref_eob_ptr[1]);\n+  int err_count_total = 0;\n+  int first_failure = -1;\n+  for (int i = 0; i < number_of_iterations; ++i) {\n+    int skip_block = i == 0;\n+    TX_SIZE sz = (TX_SIZE)(i % 3);  // TX_4X4, TX_8X8 TX_16X16\n+    TX_TYPE tx_type = (TX_TYPE)((i >> 2) % 3);\n+    const scan_order *scan_order = &vp9_scan_orders[sz][tx_type];\n+    int count = (4 << sz) * (4 << sz);  // 16, 64, 256\n+    int err_count = 0;\n+    *eob_ptr = rnd.Rand16();\n+    *ref_eob_ptr = *eob_ptr;\n+    // Two random entries\n+    for (int j = 0; j < count; j++) {\n+      coeff_ptr[j] = 0;\n+    }\n+    coeff_ptr[rnd(count)] = rnd.Rand16()&mask_;\n+    coeff_ptr[rnd(count)] = rnd.Rand16()&mask_;\n+    for (int j = 0; j < 2; j++) {\n+      zbin_ptr[j] = rnd.Rand16()&mask_;\n+      round_ptr[j] = rnd.Rand16();\n+      quant_ptr[j] = rnd.Rand16();\n+      quant_shift_ptr[j] = rnd.Rand16();\n+      dequant_ptr[j] = rnd.Rand16();\n+    }\n+\n+    ref_quantize_op_(coeff_ptr, count, skip_block, zbin_ptr, round_ptr,\n+                     quant_ptr, quant_shift_ptr, ref_qcoeff_ptr,\n+                     ref_dqcoeff_ptr, dequant_ptr,\n+                     ref_eob_ptr, scan_order->scan, scan_order->iscan);\n+    ASM_REGISTER_STATE_CHECK(quantize_op_(coeff_ptr, count, skip_block,\n+                                          zbin_ptr, round_ptr, quant_ptr,\n+                                          quant_shift_ptr, qcoeff_ptr,\n+                                          dqcoeff_ptr, dequant_ptr, eob_ptr,\n+                                          scan_order->scan, scan_order->iscan));\n+\n+    for (int j = 0; j < sz; ++j) {\n+      err_count += (ref_qcoeff_ptr[j]  != qcoeff_ptr[j]) |\n+          (ref_dqcoeff_ptr[j] != dqcoeff_ptr[j]);\n+    }\n+    err_count += (*ref_eob_ptr != *eob_ptr);\n+    if (err_count && !err_count_total) {\n+      first_failure = i;\n+    }\n+    err_count_total += err_count;\n+  }\n+  EXPECT_EQ(0, err_count_total)\n+      << \""Error: Quantization Test, C output doesn't match SSE2 output. \""\n+      << \""First failed at test case \"" << first_failure;\n+}\n+\n+TEST_P(VP9Quantize32Test, EOBCheck) {\n+  ACMRandom rnd(ACMRandom::DeterministicSeed());\n+  DECLARE_ALIGNED(16, tran_low_t, coeff_ptr[1024]);\n+  DECLARE_ALIGNED(16, int16_t, zbin_ptr[2]);\n+  DECLARE_ALIGNED(16, int16_t, round_ptr[2]);\n+  DECLARE_ALIGNED(16, int16_t, quant_ptr[2]);\n+  DECLARE_ALIGNED(16, int16_t, quant_shift_ptr[2]);\n+  DECLARE_ALIGNED(16, tran_low_t, qcoeff_ptr[1024]);\n+  DECLARE_ALIGNED(16, tran_low_t, dqcoeff_ptr[1024]);\n+  DECLARE_ALIGNED(16, tran_low_t, ref_qcoeff_ptr[1024]);\n+  DECLARE_ALIGNED(16, tran_low_t, ref_dqcoeff_ptr[1024]);\n+  DECLARE_ALIGNED(16, int16_t, dequant_ptr[2]);\n+  DECLARE_ALIGNED(16, uint16_t, eob_ptr[1]);\n+  DECLARE_ALIGNED(16, uint16_t, ref_eob_ptr[1]);\n+  int err_count_total = 0;\n+  int first_failure = -1;\n+  for (int i = 0; i < number_of_iterations; ++i) {\n+    int skip_block = i == 0;\n+    TX_SIZE sz = TX_32X32;\n+    TX_TYPE tx_type = (TX_TYPE)(i % 4);\n+    const scan_order *scan_order = &vp9_scan_orders[sz][tx_type];\n+    int count = (4 << sz) * (4 << sz);  // 1024\n+    int err_count = 0;\n+    *eob_ptr = rnd.Rand16();\n+    *ref_eob_ptr = *eob_ptr;\n+    for (int j = 0; j < count; j++) {\n+      coeff_ptr[j] = 0;\n+    }\n+    // Two random entries\n+    coeff_ptr[rnd(count)] = rnd.Rand16()&mask_;\n+    coeff_ptr[rnd(count)] = rnd.Rand16()&mask_;\n+    for (int j = 0; j < 2; j++) {\n+      zbin_ptr[j] = rnd.Rand16()&mask_;\n+      round_ptr[j] = rnd.Rand16();\n+      quant_ptr[j] = rnd.Rand16();\n+      quant_shift_ptr[j] = rnd.Rand16();\n+      dequant_ptr[j] = rnd.Rand16();\n+    }\n+\n+    ref_quantize_op_(coeff_ptr, count, skip_block, zbin_ptr, round_ptr,\n+                     quant_ptr, quant_shift_ptr, ref_qcoeff_ptr,\n+                     ref_dqcoeff_ptr, dequant_ptr,\n+                     ref_eob_ptr, scan_order->scan, scan_order->iscan);\n+    ASM_REGISTER_STATE_CHECK(quantize_op_(coeff_ptr, count, skip_block,\n+                                          zbin_ptr, round_ptr, quant_ptr,\n+                                          quant_shift_ptr, qcoeff_ptr,\n+                                          dqcoeff_ptr, dequant_ptr, eob_ptr,\n+                                          scan_order->scan, scan_order->iscan));\n+\n+    for (int j = 0; j < sz; ++j) {\n+      err_count += (ref_qcoeff_ptr[j]  != qcoeff_ptr[j]) |\n+          (ref_dqcoeff_ptr[j] != dqcoeff_ptr[j]);\n+    }\n+    err_count += (*ref_eob_ptr != *eob_ptr);\n+    if (err_count && !err_count_total) {\n+      first_failure = i;\n+    }\n+    err_count_total += err_count;\n+  }\n+  EXPECT_EQ(0, err_count_total)\n+      << \""Error: Quantization Test, C output doesn't match SSE2 output. \""\n+      << \""First failed at test case \"" << first_failure;\n+}\n+using std::tr1::make_tuple;\n+\n+#if HAVE_SSE2\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, VP9QuantizeTest,\n+    ::testing::Values(\n+        make_tuple(&vpx_highbd_quantize_b_sse2,\n+                   &vpx_highbd_quantize_b_c, VPX_BITS_8),\n+        make_tuple(&vpx_highbd_quantize_b_sse2,\n+                   &vpx_highbd_quantize_b_c, VPX_BITS_10),\n+        make_tuple(&vpx_highbd_quantize_b_sse2,\n+                   &vpx_highbd_quantize_b_c, VPX_BITS_12)));\n+INSTANTIATE_TEST_CASE_P(\n+    SSE2, VP9Quantize32Test,\n+    ::testing::Values(\n+        make_tuple(&vpx_highbd_quantize_b_32x32_sse2,\n+                   &vpx_highbd_quantize_b_32x32_c, VPX_BITS_8),\n+        make_tuple(&vpx_highbd_quantize_b_32x32_sse2,\n+                   &vpx_highbd_quantize_b_32x32_c, VPX_BITS_10),\n+        make_tuple(&vpx_highbd_quantize_b_32x32_sse2,\n+                   &vpx_highbd_quantize_b_32x32_c, VPX_BITS_12)));\n+#endif  // HAVE_SSE2\n+#endif  // CONFIG_VP9_HIGHBITDEPTH\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_skip_loopfilter_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_skip_loopfilter_test.cc"", ""patch"": ""@@ -0,0 +1,180 @@\n\n+/*\n+ *  Copyright (c) 2015 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <string>\n+\n+#include \""test/codec_factory.h\""\n+#include \""test/decode_test_driver.h\""\n+#include \""test/md5_helper.h\""\n+#include \""test/util.h\""\n+#include \""test/webm_video_source.h\""\n+\n+namespace {\n+\n+const char kVp9TestFile[] = \""vp90-2-08-tile_1x8_frame_parallel.webm\"";\n+const char kVp9Md5File[] = \""vp90-2-08-tile_1x8_frame_parallel.webm.md5\"";\n+\n+// Class for testing shutting off the loop filter.\n+class SkipLoopFilterTest {\n+ public:\n+  SkipLoopFilterTest()\n+      : video_(NULL),\n+        decoder_(NULL),\n+        md5_file_(NULL) {}\n+\n+  ~SkipLoopFilterTest() {\n+    if (md5_file_ != NULL)\n+      fclose(md5_file_);\n+    delete decoder_;\n+    delete video_;\n+  }\n+\n+  // If |threads| > 0 then set the decoder with that number of threads.\n+  void Init(int num_threads) {\n+    expected_md5_[0] = '\\0';\n+    junk_[0] = '\\0';\n+    video_ = new libvpx_test::WebMVideoSource(kVp9TestFile);\n+    ASSERT_TRUE(video_ != NULL);\n+    video_->Init();\n+    video_->Begin();\n+\n+    vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n+    if (num_threads > 0)\n+      cfg.threads = num_threads;\n+    decoder_ = new libvpx_test::VP9Decoder(cfg, 0);\n+    ASSERT_TRUE(decoder_ != NULL);\n+\n+    OpenMd5File(kVp9Md5File);\n+  }\n+\n+  // Set the VP9 skipLoopFilter control value.\n+  void SetSkipLoopFilter(int value, vpx_codec_err_t expected_value) {\n+    decoder_->Control(VP9_SET_SKIP_LOOP_FILTER, value, expected_value);\n+  }\n+\n+  vpx_codec_err_t DecodeOneFrame() {\n+    const vpx_codec_err_t res =\n+        decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());\n+    if (res == VPX_CODEC_OK) {\n+      ReadMd5();\n+      video_->Next();\n+    }\n+    return res;\n+  }\n+\n+  vpx_codec_err_t DecodeRemainingFrames() {\n+    for (; video_->cxdata() != NULL; video_->Next()) {\n+      const vpx_codec_err_t res =\n+          decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());\n+      if (res != VPX_CODEC_OK)\n+        return res;\n+      ReadMd5();\n+    }\n+    return VPX_CODEC_OK;\n+  }\n+\n+  // Checks if MD5 matches or doesn't.\n+  void CheckMd5(bool matches) {\n+    libvpx_test::DxDataIterator dec_iter = decoder_->GetDxData();\n+    const vpx_image_t *img = dec_iter.Next();\n+    CheckMd5Vpx(*img, matches);\n+  }\n+\n+ private:\n+  // TODO(fgalligan): Move the MD5 testing code into another class.\n+  void OpenMd5File(const std::string &md5_file_name) {\n+    md5_file_ = libvpx_test::OpenTestDataFile(md5_file_name);\n+    ASSERT_TRUE(md5_file_ != NULL) << \""MD5 file open failed. Filename: \""\n+        << md5_file_name;\n+  }\n+\n+  // Reads the next line of the MD5 file.\n+  void ReadMd5() {\n+    ASSERT_TRUE(md5_file_ != NULL);\n+    const int res = fscanf(md5_file_, \""%s  %s\"", expected_md5_, junk_);\n+    ASSERT_NE(EOF, res) << \""Read md5 data failed\"";\n+    expected_md5_[32] = '\\0';\n+  }\n+\n+  // Checks if the last read MD5 matches |img| or doesn't.\n+  void CheckMd5Vpx(const vpx_image_t &img, bool matches) {\n+    ::libvpx_test::MD5 md5_res;\n+    md5_res.Add(&img);\n+    const char *const actual_md5 = md5_res.Get();\n+\n+    // Check MD5.\n+    if (matches)\n+      ASSERT_STREQ(expected_md5_, actual_md5) << \""MD5 checksums don't match\"";\n+    else\n+      ASSERT_STRNE(expected_md5_, actual_md5) << \""MD5 checksums match\"";\n+  }\n+\n+  libvpx_test::WebMVideoSource *video_;\n+  libvpx_test::VP9Decoder *decoder_;\n+  FILE *md5_file_;\n+  char expected_md5_[33];\n+  char junk_[128];\n+};\n+\n+TEST(SkipLoopFilterTest, ShutOffLoopFilter) {\n+  const int non_zero_value = 1;\n+  const int num_threads = 0;\n+  SkipLoopFilterTest skip_loop_filter;\n+  skip_loop_filter.Init(num_threads);\n+  skip_loop_filter.SetSkipLoopFilter(non_zero_value, VPX_CODEC_OK);\n+  ASSERT_EQ(VPX_CODEC_OK, skip_loop_filter.DecodeRemainingFrames());\n+  skip_loop_filter.CheckMd5(false);\n+}\n+\n+TEST(SkipLoopFilterTest, ShutOffLoopFilterSingleThread) {\n+  const int non_zero_value = 1;\n+  const int num_threads = 1;\n+  SkipLoopFilterTest skip_loop_filter;\n+  skip_loop_filter.Init(num_threads);\n+  skip_loop_filter.SetSkipLoopFilter(non_zero_value, VPX_CODEC_OK);\n+  ASSERT_EQ(VPX_CODEC_OK, skip_loop_filter.DecodeRemainingFrames());\n+  skip_loop_filter.CheckMd5(false);\n+}\n+\n+TEST(SkipLoopFilterTest, ShutOffLoopFilter8Threads) {\n+  const int non_zero_value = 1;\n+  const int num_threads = 8;\n+  SkipLoopFilterTest skip_loop_filter;\n+  skip_loop_filter.Init(num_threads);\n+  skip_loop_filter.SetSkipLoopFilter(non_zero_value, VPX_CODEC_OK);\n+  ASSERT_EQ(VPX_CODEC_OK, skip_loop_filter.DecodeRemainingFrames());\n+  skip_loop_filter.CheckMd5(false);\n+}\n+\n+TEST(SkipLoopFilterTest, WithLoopFilter) {\n+  const int non_zero_value = 1;\n+  const int num_threads = 0;\n+  SkipLoopFilterTest skip_loop_filter;\n+  skip_loop_filter.Init(num_threads);\n+  skip_loop_filter.SetSkipLoopFilter(non_zero_value, VPX_CODEC_OK);\n+  skip_loop_filter.SetSkipLoopFilter(0, VPX_CODEC_OK);\n+  ASSERT_EQ(VPX_CODEC_OK, skip_loop_filter.DecodeRemainingFrames());\n+  skip_loop_filter.CheckMd5(true);\n+}\n+\n+TEST(SkipLoopFilterTest, ToggleLoopFilter) {\n+  const int num_threads = 0;\n+  SkipLoopFilterTest skip_loop_filter;\n+  skip_loop_filter.Init(num_threads);\n+\n+  for (int i = 0; i < 10; ++i) {\n+    skip_loop_filter.SetSkipLoopFilter(i % 2, VPX_CODEC_OK);\n+    ASSERT_EQ(VPX_CODEC_OK, skip_loop_filter.DecodeOneFrame());\n+  }\n+  ASSERT_EQ(VPX_CODEC_OK, skip_loop_filter.DecodeRemainingFrames());\n+  skip_loop_filter.CheckMd5(false);\n+}\n+\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_spatial_svc_encoder.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_spatial_svc_encoder.sh"", ""patch"": ""@@ -0,0 +1,72 @@\n\n+#!/bin/sh\n+##\n+##  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+##\n+##  Use of this source code is governed by a BSD-style license\n+##  that can be found in the LICENSE file in the root of the source\n+##  tree. An additional intellectual property rights grant can be found\n+##  in the file PATENTS.  All contributing project authors may\n+##  be found in the AUTHORS file in the root of the source tree.\n+##\n+##  This file tests the libvpx vp9_spatial_svc_encoder example. To add new\n+##  tests to to this file, do the following:\n+##    1. Write a shell function (this is your test).\n+##    2. Add the function to vp9_spatial_svc_tests (on a new line).\n+##\n+. $(dirname $0)/tools_common.sh\n+\n+# Environment check: $YUV_RAW_INPUT is required.\n+vp9_spatial_svc_encoder_verify_environment() {\n+  if [ ! -e \""${YUV_RAW_INPUT}\"" ]; then\n+    echo \""Libvpx test data must exist in LIBVPX_TEST_DATA_PATH.\""\n+    return 1\n+  fi\n+}\n+\n+# Runs vp9_spatial_svc_encoder. $1 is the test name.\n+vp9_spatial_svc_encoder() {\n+  local readonly \\\n+    encoder=\""${LIBVPX_BIN_PATH}/vp9_spatial_svc_encoder${VPX_TEST_EXE_SUFFIX}\""\n+  local readonly test_name=\""$1\""\n+  local readonly \\\n+    output_file=\""${VPX_TEST_OUTPUT_DIR}/vp9_ssvc_encoder${test_name}.ivf\""\n+  local readonly frames_to_encode=10\n+  local readonly max_kf=9999\n+\n+  shift\n+\n+  if [ ! -x \""${encoder}\"" ]; then\n+    elog \""${encoder} does not exist or is not executable.\""\n+    return 1\n+  fi\n+\n+  eval \""${VPX_TEST_PREFIX}\"" \""${encoder}\"" -w \""${YUV_RAW_INPUT_WIDTH}\"" \\\n+    -h \""${YUV_RAW_INPUT_HEIGHT}\"" -k \""${max_kf}\"" -f \""${frames_to_encode}\"" \\\n+    \""$@\"" \""${YUV_RAW_INPUT}\"" \""${output_file}\"" ${devnull}\n+\n+  [ -e \""${output_file}\"" ] || return 1\n+}\n+\n+# Each test is run with layer count 1-$vp9_ssvc_test_layers.\n+vp9_ssvc_test_layers=5\n+\n+vp9_spatial_svc() {\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+    local readonly test_name=\""vp9_spatial_svc\""\n+    for layers in $(seq 1 ${vp9_ssvc_test_layers}); do\n+      vp9_spatial_svc_encoder \""${test_name}\"" -l ${layers}\n+    done\n+  fi\n+}\n+\n+readonly vp9_spatial_svc_tests=\""DISABLED_vp9_spatial_svc_mode_i\n+                                DISABLED_vp9_spatial_svc_mode_altip\n+                                DISABLED_vp9_spatial_svc_mode_ip\n+                                DISABLED_vp9_spatial_svc_mode_gf\n+                                vp9_spatial_svc\""\n+\n+if [ \""$(vpx_config_option_enabled CONFIG_SPATIAL_SVC)\"" = \""yes\"" ]; then\n+  run_tests \\\n+    vp9_spatial_svc_encoder_verify_environment \\\n+    \""${vp9_spatial_svc_tests}\""\n+fi\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_subtract_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_subtract_test.cc"", ""patch"": ""@@ -9,22 +9,24 @@\n\n  */\n \n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vp9_rtcd.h\""\n+#include \""./vpx_config.h\""\n+#include \""./vpx_dsp_rtcd.h\""\n #include \""test/acm_random.h\""\n #include \""test/clear_system_state.h\""\n #include \""test/register_state_check.h\""\n-#include \""./vpx_config.h\""\n-#include \""./vp9_rtcd.h\""\n #include \""vp9/common/vp9_blockd.h\""\n #include \""vpx_mem/vpx_mem.h\""\n \n-typedef void (*subtract_fn_t)(int rows, int cols,\n-                              int16_t *diff_ptr, ptrdiff_t diff_stride,\n-                              const uint8_t *src_ptr, ptrdiff_t src_stride,\n-                              const uint8_t *pred_ptr, ptrdiff_t pred_stride);\n+typedef void (*SubtractFunc)(int rows, int cols,\n+                             int16_t *diff_ptr, ptrdiff_t diff_stride,\n+                             const uint8_t *src_ptr, ptrdiff_t src_stride,\n+                             const uint8_t *pred_ptr, ptrdiff_t pred_stride);\n \n namespace vp9 {\n \n-class VP9SubtractBlockTest : public ::testing::TestWithParam<subtract_fn_t> {\n+class VP9SubtractBlockTest : public ::testing::TestWithParam<SubtractFunc> {\n  public:\n   virtual void TearDown() {\n     libvpx_test::ClearSystemState();\n@@ -89,10 +91,19 @@\n\n }\n \n INSTANTIATE_TEST_CASE_P(C, VP9SubtractBlockTest,\n-                        ::testing::Values(vp9_subtract_block_c));\n+                        ::testing::Values(vpx_subtract_block_c));\n \n #if HAVE_SSE2 && CONFIG_USE_X86INC\n INSTANTIATE_TEST_CASE_P(SSE2, VP9SubtractBlockTest,\n-                        ::testing::Values(vp9_subtract_block_sse2));\n+                        ::testing::Values(vpx_subtract_block_sse2));\n #endif\n+#if HAVE_NEON\n+INSTANTIATE_TEST_CASE_P(NEON, VP9SubtractBlockTest,\n+                        ::testing::Values(vpx_subtract_block_neon));\n+#endif\n+#if HAVE_MSA\n+INSTANTIATE_TEST_CASE_P(MSA, VP9SubtractBlockTest,\n+                        ::testing::Values(vpx_subtract_block_msa));\n+#endif\n+\n }  // namespace vp9\n""}<_**next**_>{""filename"": ""libvpx/test/vp9_thread_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vp9_thread_test.cc"", ""patch"": ""@@ -11,28 +11,40 @@\n\n #include <string>\n \n #include \""third_party/googletest/src/include/gtest/gtest.h\""\n+#include \""./vpx_config.h\""\n #include \""test/codec_factory.h\""\n #include \""test/decode_test_driver.h\""\n #include \""test/md5_helper.h\""\n+#if CONFIG_WEBM_IO\n #include \""test/webm_video_source.h\""\n-#include \""vp9/decoder/vp9_thread.h\""\n+#endif\n+#include \""vpx_util/vpx_thread.h\""\n \n namespace {\n \n using std::string;\n \n-class VP9WorkerThreadTest : public ::testing::TestWithParam<bool> {\n+class VPxWorkerThreadTest : public ::testing::TestWithParam<bool> {\n  protected:\n-  virtual ~VP9WorkerThreadTest() {}\n+  virtual ~VPxWorkerThreadTest() {}\n   virtual void SetUp() {\n-    vp9_worker_init(&worker_);\n+    vpx_get_worker_interface()->init(&worker_);\n   }\n \n   virtual void TearDown() {\n-    vp9_worker_end(&worker_);\n+    vpx_get_worker_interface()->end(&worker_);\n   }\n \n-  VP9Worker worker_;\n+  void Run(VPxWorker* worker) {\n+    const bool synchronous = GetParam();\n+    if (synchronous) {\n+      vpx_get_worker_interface()->execute(worker);\n+    } else {\n+      vpx_get_worker_interface()->launch(worker);\n+    }\n+  }\n+\n+  VPxWorker worker_;\n };\n \n int ThreadHook(void* data, void* return_value) {\n@@ -41,11 +53,12 @@\n\n   return *reinterpret_cast<int*>(return_value);\n }\n \n-TEST_P(VP9WorkerThreadTest, HookSuccess) {\n-  EXPECT_NE(vp9_worker_sync(&worker_), 0);  // should be a no-op.\n+TEST_P(VPxWorkerThreadTest, HookSuccess) {\n+  // should be a no-op.\n+  EXPECT_NE(vpx_get_worker_interface()->sync(&worker_), 0);\n \n   for (int i = 0; i < 2; ++i) {\n-    EXPECT_NE(vp9_worker_reset(&worker_), 0);\n+    EXPECT_NE(vpx_get_worker_interface()->reset(&worker_), 0);\n \n     int hook_data = 0;\n     int return_value = 1;  // return successfully from the hook\n@@ -53,22 +66,18 @@\n\n     worker_.data1 = &hook_data;\n     worker_.data2 = &return_value;\n \n-    const bool synchronous = GetParam();\n-    if (synchronous) {\n-      vp9_worker_execute(&worker_);\n-    } else {\n-      vp9_worker_launch(&worker_);\n-    }\n-    EXPECT_NE(vp9_worker_sync(&worker_), 0);\n+    Run(&worker_);\n+    EXPECT_NE(vpx_get_worker_interface()->sync(&worker_), 0);\n     EXPECT_FALSE(worker_.had_error);\n     EXPECT_EQ(5, hook_data);\n \n-    EXPECT_NE(vp9_worker_sync(&worker_), 0);  // should be a no-op.\n+    // should be a no-op.\n+    EXPECT_NE(vpx_get_worker_interface()->sync(&worker_), 0);\n   }\n }\n \n-TEST_P(VP9WorkerThreadTest, HookFailure) {\n-  EXPECT_NE(vp9_worker_reset(&worker_), 0);\n+TEST_P(VPxWorkerThreadTest, HookFailure) {\n+  EXPECT_NE(vpx_get_worker_interface()->reset(&worker_), 0);\n \n   int hook_data = 0;\n   int return_value = 0;  // return failure from the hook\n@@ -76,33 +85,85 @@\n\n   worker_.data1 = &hook_data;\n   worker_.data2 = &return_value;\n \n-  const bool synchronous = GetParam();\n-  if (synchronous) {\n-    vp9_worker_execute(&worker_);\n-  } else {\n-    vp9_worker_launch(&worker_);\n-  }\n-  EXPECT_FALSE(vp9_worker_sync(&worker_));\n+  Run(&worker_);\n+  EXPECT_FALSE(vpx_get_worker_interface()->sync(&worker_));\n   EXPECT_EQ(1, worker_.had_error);\n \n   // Ensure _reset() clears the error and _launch() can be called again.\n   return_value = 1;\n-  EXPECT_NE(vp9_worker_reset(&worker_), 0);\n+  EXPECT_NE(vpx_get_worker_interface()->reset(&worker_), 0);\n   EXPECT_FALSE(worker_.had_error);\n-  vp9_worker_launch(&worker_);\n-  EXPECT_NE(vp9_worker_sync(&worker_), 0);\n+  vpx_get_worker_interface()->launch(&worker_);\n+  EXPECT_NE(vpx_get_worker_interface()->sync(&worker_), 0);\n   EXPECT_FALSE(worker_.had_error);\n }\n \n+TEST_P(VPxWorkerThreadTest, EndWithoutSync) {\n+  // Create a large number of threads to increase the chances of detecting a\n+  // race. Doing more work in the hook is no guarantee as any race would occur\n+  // post hook execution in the main thread loop driver.\n+  static const int kNumWorkers = 64;\n+  VPxWorker workers[kNumWorkers];\n+  int hook_data[kNumWorkers];\n+  int return_value[kNumWorkers];\n+\n+  for (int n = 0; n < kNumWorkers; ++n) {\n+    vpx_get_worker_interface()->init(&workers[n]);\n+    return_value[n] = 1;  // return successfully from the hook\n+    workers[n].hook = ThreadHook;\n+    workers[n].data1 = &hook_data[n];\n+    workers[n].data2 = &return_value[n];\n+  }\n+\n+  for (int i = 0; i < 2; ++i) {\n+    for (int n = 0; n < kNumWorkers; ++n) {\n+      EXPECT_NE(vpx_get_worker_interface()->reset(&workers[n]), 0);\n+      hook_data[n] = 0;\n+    }\n+\n+    for (int n = 0; n < kNumWorkers; ++n) {\n+      Run(&workers[n]);\n+    }\n+\n+    for (int n = kNumWorkers - 1; n >= 0; --n) {\n+      vpx_get_worker_interface()->end(&workers[n]);\n+    }\n+  }\n+}\n+\n+TEST(VPxWorkerThreadTest, TestInterfaceAPI) {\n+  EXPECT_EQ(0, vpx_set_worker_interface(NULL));\n+  EXPECT_TRUE(vpx_get_worker_interface() != NULL);\n+  for (int i = 0; i < 6; ++i) {\n+    VPxWorkerInterface winterface = *vpx_get_worker_interface();\n+    switch (i) {\n+      default:\n+      case 0: winterface.init = NULL; break;\n+      case 1: winterface.reset = NULL; break;\n+      case 2: winterface.sync = NULL; break;\n+      case 3: winterface.launch = NULL; break;\n+      case 4: winterface.execute = NULL; break;\n+      case 5: winterface.end = NULL; break;\n+    }\n+    EXPECT_EQ(0, vpx_set_worker_interface(&winterface));\n+  }\n+}\n+\n // -----------------------------------------------------------------------------\n // Multi-threaded decode tests\n \n+#if CONFIG_WEBM_IO\n+struct FileList {\n+  const char *name;\n+  const char *expected_md5;\n+};\n+\n // Decodes |filename| with |num_threads|. Returns the md5 of the decoded frames.\n string DecodeFile(const string& filename, int num_threads) {\n   libvpx_test::WebMVideoSource video(filename);\n   video.Init();\n \n-  vpx_codec_dec_cfg_t cfg = {0};\n+  vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n   cfg.threads = num_threads;\n   libvpx_test::VP9Decoder decoder(cfg, 0);\n \n@@ -126,39 +187,77 @@\n\n   return string(md5.Get());\n }\n \n-TEST(VP9DecodeMTTest, MTDecode) {\n-  // no tiles or frame parallel; this exercises loop filter threading.\n-  EXPECT_STREQ(\""b35a1b707b28e82be025d960aba039bc\"",\n-               DecodeFile(\""vp90-2-03-size-226x226.webm\"", 2).c_str());\n+void DecodeFiles(const FileList files[]) {\n+  for (const FileList *iter = files; iter->name != NULL; ++iter) {\n+    SCOPED_TRACE(iter->name);\n+    for (int t = 2; t <= 8; ++t) {\n+      EXPECT_EQ(iter->expected_md5, DecodeFile(iter->name, t))\n+          << \""threads = \"" << t;\n+    }\n+  }\n }\n \n-TEST(VP9DecodeMTTest, MTDecode2) {\n-  static const struct {\n-    const char *name;\n-    const char *expected_md5;\n-  } files[] = {\n+// Trivial serialized thread worker interface implementation.\n+// Note any worker that requires synchronization between other workers will\n+// hang.\n+namespace impl {\n+\n+void Init(VPxWorker *const worker) { memset(worker, 0, sizeof(*worker)); }\n+int Reset(VPxWorker *const /*worker*/) { return 1; }\n+int Sync(VPxWorker *const worker) { return !worker->had_error; }\n+\n+void Execute(VPxWorker *const worker) {\n+  worker->had_error |= !worker->hook(worker->data1, worker->data2);\n+}\n+\n+void Launch(VPxWorker *const worker) { Execute(worker); }\n+void End(VPxWorker *const /*worker*/) {}\n+\n+}  // namespace impl\n+\n+TEST(VPxWorkerThreadTest, TestSerialInterface) {\n+  static const VPxWorkerInterface serial_interface = {\n+    impl::Init, impl::Reset, impl::Sync, impl::Launch, impl::Execute, impl::End\n+  };\n+  // TODO(jzern): Avoid using a file that will use the row-based thread\n+  // loopfilter, with the simple serialized implementation it will hang. This is\n+  // due to its expectation that rows will be run in parallel as they wait on\n+  // progress in the row above before proceeding.\n+  static const char expected_md5[] = \""b35a1b707b28e82be025d960aba039bc\"";\n+  static const char filename[] = \""vp90-2-03-size-226x226.webm\"";\n+  VPxWorkerInterface default_interface = *vpx_get_worker_interface();\n+\n+  EXPECT_NE(vpx_set_worker_interface(&serial_interface), 0);\n+  EXPECT_EQ(expected_md5, DecodeFile(filename, 2));\n+\n+  // Reset the interface.\n+  EXPECT_NE(vpx_set_worker_interface(&default_interface), 0);\n+  EXPECT_EQ(expected_md5, DecodeFile(filename, 2));\n+}\n+\n+TEST(VP9DecodeMultiThreadedTest, Decode) {\n+  // no tiles or frame parallel; this exercises loop filter threading.\n+  EXPECT_EQ(\""b35a1b707b28e82be025d960aba039bc\"",\n+            DecodeFile(\""vp90-2-03-size-226x226.webm\"", 2));\n+}\n+\n+TEST(VP9DecodeMultiThreadedTest, Decode2) {\n+  static const FileList files[] = {\n     { \""vp90-2-08-tile_1x2_frame_parallel.webm\"",\n       \""68ede6abd66bae0a2edf2eb9232241b6\"" },\n     { \""vp90-2-08-tile_1x4_frame_parallel.webm\"",\n       \""368ebc6ebf3a5e478d85b2c3149b2848\"" },\n     { \""vp90-2-08-tile_1x8_frame_parallel.webm\"",\n       \""17e439da2388aff3a0f69cb22579c6c1\"" },\n+    { NULL, NULL }\n   };\n \n-  for (int i = 0; i < static_cast<int>(sizeof(files) / sizeof(files[0])); ++i) {\n-    for (int t = 2; t <= 8; ++t) {\n-      EXPECT_STREQ(files[i].expected_md5, DecodeFile(files[i].name, t).c_str())\n-          << \""threads = \"" << t;\n-    }\n-  }\n+  DecodeFiles(files);\n }\n \n // Test tile quantity changes within one file.\n-TEST(VP9DecodeMTTest, MTDecode3) {\n-  static const struct {\n-    const char *name;\n-    const char *expected_md5;\n-  } files[] = {\n+TEST(VP9DecodeMultiThreadedTest, Decode3) {\n+  static const FileList files[] = {\n     { \""vp90-2-14-resize-fp-tiles-1-16.webm\"",\n       \""0cd5e632c326297e975f38949c31ea94\"" },\n     { \""vp90-2-14-resize-fp-tiles-1-2-4-8-16.webm\"",\n@@ -203,16 +302,13 @@\n\n       \""ae96f21f21b6370cc0125621b441fc52\"" },\n     { \""vp90-2-14-resize-fp-tiles-8-4.webm\"",\n       \""3eb4f24f10640d42218f7fd7b9fd30d4\"" },\n+    { NULL, NULL }\n   };\n \n-  for (int i = 0; i < static_cast<int>(sizeof(files) / sizeof(files[0])); ++i) {\n-    for (int t = 2; t <= 8; ++t) {\n-      EXPECT_STREQ(files[i].expected_md5, DecodeFile(files[i].name, t).c_str())\n-          << \""threads = \"" << t;\n-    }\n-  }\n+  DecodeFiles(files);\n }\n+#endif  // CONFIG_WEBM_IO\n \n-INSTANTIATE_TEST_CASE_P(Synchronous, VP9WorkerThreadTest, ::testing::Bool());\n+INSTANTIATE_TEST_CASE_P(Synchronous, VPxWorkerThreadTest, ::testing::Bool());\n \n }  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/vpx_scale_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vpx_scale_test.cc"", ""patch"": ""@@ -0,0 +1,255 @@\n\n+/*\n+ *  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vpx_config.h\""\n+#include \""./vpx_scale_rtcd.h\""\n+#include \""test/clear_system_state.h\""\n+#include \""test/register_state_check.h\""\n+#include \""vpx_mem/vpx_mem.h\""\n+#include \""vpx_scale/yv12config.h\""\n+\n+namespace {\n+\n+typedef void (*ExtendFrameBorderFunc)(YV12_BUFFER_CONFIG *ybf);\n+typedef void (*CopyFrameFunc)(const YV12_BUFFER_CONFIG *src_ybf,\n+                              YV12_BUFFER_CONFIG *dst_ybf);\n+\n+class VpxScaleBase {\n+ public:\n+  virtual ~VpxScaleBase() {\n+    libvpx_test::ClearSystemState();\n+  }\n+\n+  void ResetImage(int width, int height) {\n+    width_ = width;\n+    height_ = height;\n+    memset(&img_, 0, sizeof(img_));\n+    ASSERT_EQ(0, vp8_yv12_alloc_frame_buffer(&img_, width_, height_,\n+                                             VP8BORDERINPIXELS));\n+    memset(img_.buffer_alloc, kBufFiller, img_.frame_size);\n+    FillPlane(img_.y_buffer, img_.y_crop_width, img_.y_crop_height,\n+              img_.y_stride);\n+    FillPlane(img_.u_buffer, img_.uv_crop_width, img_.uv_crop_height,\n+              img_.uv_stride);\n+    FillPlane(img_.v_buffer, img_.uv_crop_width, img_.uv_crop_height,\n+              img_.uv_stride);\n+\n+    memset(&ref_img_, 0, sizeof(ref_img_));\n+    ASSERT_EQ(0, vp8_yv12_alloc_frame_buffer(&ref_img_, width_, height_,\n+                                             VP8BORDERINPIXELS));\n+    memset(ref_img_.buffer_alloc, kBufFiller, ref_img_.frame_size);\n+\n+    memset(&cpy_img_, 0, sizeof(cpy_img_));\n+    ASSERT_EQ(0, vp8_yv12_alloc_frame_buffer(&cpy_img_, width_, height_,\n+                                             VP8BORDERINPIXELS));\n+    memset(cpy_img_.buffer_alloc, kBufFiller, cpy_img_.frame_size);\n+    ReferenceCopyFrame();\n+  }\n+\n+  void DeallocImage() {\n+    vp8_yv12_de_alloc_frame_buffer(&img_);\n+    vp8_yv12_de_alloc_frame_buffer(&ref_img_);\n+    vp8_yv12_de_alloc_frame_buffer(&cpy_img_);\n+  }\n+\n+ protected:\n+  static const int kBufFiller = 123;\n+  static const int kBufMax = kBufFiller - 1;\n+\n+  static void FillPlane(uint8_t *buf, int width, int height, int stride) {\n+    for (int y = 0; y < height; ++y) {\n+      for (int x = 0; x < width; ++x) {\n+        buf[x + (y * stride)] = (x + (width * y)) % kBufMax;\n+      }\n+    }\n+  }\n+\n+  static void ExtendPlane(uint8_t *buf, int crop_width, int crop_height,\n+                          int width, int height, int stride, int padding) {\n+    // Copy the outermost visible pixel to a distance of at least 'padding.'\n+    // The buffers are allocated such that there may be excess space outside the\n+    // padding. As long as the minimum amount of padding is achieved it is not\n+    // necessary to fill this space as well.\n+    uint8_t *left = buf - padding;\n+    uint8_t *right = buf + crop_width;\n+    const int right_extend = padding + (width - crop_width);\n+    const int bottom_extend = padding + (height - crop_height);\n+\n+    // Fill the border pixels from the nearest image pixel.\n+    for (int y = 0; y < crop_height; ++y) {\n+      memset(left, left[padding], padding);\n+      memset(right, right[-1], right_extend);\n+      left += stride;\n+      right += stride;\n+    }\n+\n+    left = buf - padding;\n+    uint8_t *top = left - (stride * padding);\n+    // The buffer does not always extend as far as the stride.\n+    // Equivalent to padding + width + padding.\n+    const int extend_width = padding + crop_width + right_extend;\n+\n+    // The first row was already extended to the left and right. Copy it up.\n+    for (int y = 0; y < padding; ++y) {\n+      memcpy(top, left, extend_width);\n+      top += stride;\n+    }\n+\n+    uint8_t *bottom = left + (crop_height * stride);\n+    for (int y = 0; y <  bottom_extend; ++y) {\n+      memcpy(bottom, left + (crop_height - 1) * stride, extend_width);\n+      bottom += stride;\n+    }\n+  }\n+\n+  void ReferenceExtendBorder() {\n+    ExtendPlane(ref_img_.y_buffer,\n+                ref_img_.y_crop_width, ref_img_.y_crop_height,\n+                ref_img_.y_width, ref_img_.y_height,\n+                ref_img_.y_stride,\n+                ref_img_.border);\n+    ExtendPlane(ref_img_.u_buffer,\n+                ref_img_.uv_crop_width, ref_img_.uv_crop_height,\n+                ref_img_.uv_width, ref_img_.uv_height,\n+                ref_img_.uv_stride,\n+                ref_img_.border / 2);\n+    ExtendPlane(ref_img_.v_buffer,\n+                ref_img_.uv_crop_width, ref_img_.uv_crop_height,\n+                ref_img_.uv_width, ref_img_.uv_height,\n+                ref_img_.uv_stride,\n+                ref_img_.border / 2);\n+  }\n+\n+  void ReferenceCopyFrame() {\n+    // Copy img_ to ref_img_ and extend frame borders. This will be used for\n+    // verifying extend_fn_ as well as copy_frame_fn_.\n+    EXPECT_EQ(ref_img_.frame_size, img_.frame_size);\n+    for (int y = 0; y < img_.y_crop_height; ++y) {\n+      for (int x = 0; x < img_.y_crop_width; ++x) {\n+        ref_img_.y_buffer[x + y * ref_img_.y_stride] =\n+            img_.y_buffer[x + y * img_.y_stride];\n+      }\n+    }\n+\n+    for (int y = 0; y < img_.uv_crop_height; ++y) {\n+      for (int x = 0; x < img_.uv_crop_width; ++x) {\n+        ref_img_.u_buffer[x + y * ref_img_.uv_stride] =\n+            img_.u_buffer[x + y * img_.uv_stride];\n+        ref_img_.v_buffer[x + y * ref_img_.uv_stride] =\n+            img_.v_buffer[x + y * img_.uv_stride];\n+      }\n+    }\n+\n+    ReferenceExtendBorder();\n+  }\n+\n+  void CompareImages(const YV12_BUFFER_CONFIG actual) {\n+    EXPECT_EQ(ref_img_.frame_size, actual.frame_size);\n+    EXPECT_EQ(0, memcmp(ref_img_.buffer_alloc, actual.buffer_alloc,\n+                        ref_img_.frame_size));\n+  }\n+\n+  YV12_BUFFER_CONFIG img_;\n+  YV12_BUFFER_CONFIG ref_img_;\n+  YV12_BUFFER_CONFIG cpy_img_;\n+  int width_;\n+  int height_;\n+};\n+\n+class ExtendBorderTest\n+    : public VpxScaleBase,\n+      public ::testing::TestWithParam<ExtendFrameBorderFunc> {\n+ public:\n+  virtual ~ExtendBorderTest() {}\n+\n+ protected:\n+  virtual void SetUp() {\n+    extend_fn_ = GetParam();\n+  }\n+\n+  void ExtendBorder() {\n+    ASM_REGISTER_STATE_CHECK(extend_fn_(&img_));\n+  }\n+\n+  void RunTest() {\n+#if ARCH_ARM\n+    // Some arm devices OOM when trying to allocate the largest buffers.\n+    static const int kNumSizesToTest = 6;\n+#else\n+    static const int kNumSizesToTest = 7;\n+#endif\n+    static const int kSizesToTest[] = {1, 15, 33, 145, 512, 1025, 16383};\n+    for (int h = 0; h < kNumSizesToTest; ++h) {\n+      for (int w = 0; w < kNumSizesToTest; ++w) {\n+        ResetImage(kSizesToTest[w], kSizesToTest[h]);\n+        ExtendBorder();\n+        ReferenceExtendBorder();\n+        CompareImages(img_);\n+        DeallocImage();\n+      }\n+    }\n+  }\n+\n+  ExtendFrameBorderFunc extend_fn_;\n+};\n+\n+TEST_P(ExtendBorderTest, ExtendBorder) {\n+  ASSERT_NO_FATAL_FAILURE(RunTest());\n+}\n+\n+INSTANTIATE_TEST_CASE_P(C, ExtendBorderTest,\n+                        ::testing::Values(vp8_yv12_extend_frame_borders_c));\n+\n+class CopyFrameTest\n+    : public VpxScaleBase,\n+      public ::testing::TestWithParam<CopyFrameFunc> {\n+ public:\n+  virtual ~CopyFrameTest() {}\n+\n+ protected:\n+  virtual void SetUp() {\n+    copy_frame_fn_ = GetParam();\n+  }\n+\n+  void CopyFrame() {\n+    ASM_REGISTER_STATE_CHECK(copy_frame_fn_(&img_, &cpy_img_));\n+  }\n+\n+  void RunTest() {\n+#if ARCH_ARM\n+    // Some arm devices OOM when trying to allocate the largest buffers.\n+    static const int kNumSizesToTest = 6;\n+#else\n+    static const int kNumSizesToTest = 7;\n+#endif\n+    static const int kSizesToTest[] = {1, 15, 33, 145, 512, 1025, 16383};\n+    for (int h = 0; h < kNumSizesToTest; ++h) {\n+      for (int w = 0; w < kNumSizesToTest; ++w) {\n+        ResetImage(kSizesToTest[w], kSizesToTest[h]);\n+        ReferenceCopyFrame();\n+        CopyFrame();\n+        CompareImages(cpy_img_);\n+        DeallocImage();\n+      }\n+    }\n+  }\n+\n+  CopyFrameFunc copy_frame_fn_;\n+};\n+\n+TEST_P(CopyFrameTest, CopyFrame) {\n+  ASSERT_NO_FATAL_FAILURE(RunTest());\n+}\n+\n+INSTANTIATE_TEST_CASE_P(C, CopyFrameTest,\n+                        ::testing::Values(vp8_yv12_copy_frame_c));\n+}  // namespace\n""}<_**next**_>{""filename"": ""libvpx/test/vpx_temporal_svc_encoder.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vpx_temporal_svc_encoder.sh"", ""patch"": ""@@ -0,0 +1,290 @@\n\n+#!/bin/sh\n+##\n+##  Copyright (c) 2014 The WebM project authors. All Rights Reserved.\n+##\n+##  Use of this source code is governed by a BSD-style license\n+##  that can be found in the LICENSE file in the root of the source\n+##  tree. An additional intellectual property rights grant can be found\n+##  in the file PATENTS.  All contributing project authors may\n+##  be found in the AUTHORS file in the root of the source tree.\n+##\n+##  This file tests the libvpx vpx_temporal_svc_encoder example. To add new\n+##  tests to this file, do the following:\n+##    1. Write a shell function (this is your test).\n+##    2. Add the function to vpx_tsvc_encoder_tests (on a new line).\n+##\n+. $(dirname $0)/tools_common.sh\n+\n+# Environment check: $YUV_RAW_INPUT is required.\n+vpx_tsvc_encoder_verify_environment() {\n+  if [ ! -e \""${YUV_RAW_INPUT}\"" ]; then\n+    echo \""Libvpx test data must exist in LIBVPX_TEST_DATA_PATH.\""\n+    return 1\n+  fi\n+  if [ \""$(vpx_config_option_enabled CONFIG_TEMPORAL_DENOISING)\"" != \""yes\"" ]; then\n+    elog \""Warning: Temporal denoising is disabled! Spatial denoising will be \"" \\\n+      \""used instead, which is probably not what you want for this test.\""\n+  fi\n+}\n+\n+# Runs vpx_temporal_svc_encoder using the codec specified by $1 and output file\n+# name by $2. Additional positional parameters are passed directly to\n+# vpx_temporal_svc_encoder.\n+vpx_tsvc_encoder() {\n+  local encoder=\""${LIBVPX_BIN_PATH}/vpx_temporal_svc_encoder\""\n+  encoder=\""${encoder}${VPX_TEST_EXE_SUFFIX}\""\n+  local codec=\""$1\""\n+  local output_file_base=\""$2\""\n+  local output_file=\""${VPX_TEST_OUTPUT_DIR}/${output_file_base}\""\n+  local timebase_num=\""1\""\n+  local timebase_den=\""1000\""\n+  local speed=\""6\""\n+  local frame_drop_thresh=\""30\""\n+\n+  shift 2\n+\n+  if [ ! -x \""${encoder}\"" ]; then\n+    elog \""${encoder} does not exist or is not executable.\""\n+    return 1\n+  fi\n+\n+  eval \""${VPX_TEST_PREFIX}\"" \""${encoder}\"" \""${YUV_RAW_INPUT}\"" \""${output_file}\"" \\\n+      \""${codec}\"" \""${YUV_RAW_INPUT_WIDTH}\"" \""${YUV_RAW_INPUT_HEIGHT}\"" \\\n+      \""${timebase_num}\"" \""${timebase_den}\"" \""${speed}\"" \""${frame_drop_thresh}\"" \\\n+      \""$@\"" \\\n+      ${devnull}\n+}\n+\n+# Confirms that all expected output files exist given the output file name\n+# passed to vpx_temporal_svc_encoder.\n+# The file name passed to vpx_temporal_svc_encoder is joined with the stream\n+# number and the extension .ivf to produce per stream output files.  Here $1 is\n+# file name, and $2 is expected number of files.\n+files_exist() {\n+  local file_name=\""${VPX_TEST_OUTPUT_DIR}/$1\""\n+  local num_files=\""$(($2 - 1))\""\n+  for stream_num in $(seq 0 ${num_files}); do\n+    [ -e \""${file_name}_${stream_num}.ivf\"" ] || return 1\n+  done\n+}\n+\n+# Run vpx_temporal_svc_encoder in all supported modes for vp8 and vp9.\n+\n+vpx_tsvc_encoder_vp8_mode_0() {\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp8 \""${FUNCNAME}\"" 0 200 || return 1\n+    # Mode 0 produces 1 stream\n+    files_exist \""${FUNCNAME}\"" 1 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp8_mode_1() {\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp8 \""${FUNCNAME}\"" 1 200 400 || return 1\n+    # Mode 1 produces 2 streams\n+    files_exist \""${FUNCNAME}\"" 2 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp8_mode_2() {\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp8 \""${FUNCNAME}\"" 2 200 400 || return 1\n+    # Mode 2 produces 2 streams\n+    files_exist \""${FUNCNAME}\"" 2 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp8_mode_3() {\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp8 \""${FUNCNAME}\"" 3 200 400 600 || return 1\n+    # Mode 3 produces 3 streams\n+    files_exist \""${FUNCNAME}\"" 3 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp8_mode_4() {\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp8 \""${FUNCNAME}\"" 4 200 400 600 || return 1\n+    # Mode 4 produces 3 streams\n+    files_exist \""${FUNCNAME}\"" 3 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp8_mode_5() {\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp8 \""${FUNCNAME}\"" 5 200 400 600 || return 1\n+    # Mode 5 produces 3 streams\n+    files_exist \""${FUNCNAME}\"" 3 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp8_mode_6() {\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp8 \""${FUNCNAME}\"" 6 200 400 600 || return 1\n+    # Mode 6 produces 3 streams\n+    files_exist \""${FUNCNAME}\"" 3 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp8_mode_7() {\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp8 \""${FUNCNAME}\"" 7 200 400 600 800 1000 || return 1\n+    # Mode 7 produces 5 streams\n+    files_exist \""${FUNCNAME}\"" 5 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp8_mode_8() {\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp8 \""${FUNCNAME}\"" 8 200 400 || return 1\n+    # Mode 8 produces 2 streams\n+    files_exist \""${FUNCNAME}\"" 2 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp8_mode_9() {\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp8 \""${FUNCNAME}\"" 9 200 400 600 || return 1\n+    # Mode 9 produces 3 streams\n+    files_exist \""${FUNCNAME}\"" 3 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp8_mode_10() {\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp8 \""${FUNCNAME}\"" 10 200 400 600 || return 1\n+    # Mode 10 produces 3 streams\n+    files_exist \""${FUNCNAME}\"" 3 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp8_mode_11() {\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp8 \""${FUNCNAME}\"" 11 200 400 600 || return 1\n+    # Mode 11 produces 3 streams\n+    files_exist \""${FUNCNAME}\"" 3 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp9_mode_0() {\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp9 \""${FUNCNAME}\"" 0 200 || return 1\n+    # Mode 0 produces 1 stream\n+    files_exist \""${FUNCNAME}\"" 1 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp9_mode_1() {\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp9 \""${FUNCNAME}\"" 1 200 400 || return 1\n+    # Mode 1 produces 2 streams\n+    files_exist \""${FUNCNAME}\"" 2 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp9_mode_2() {\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp9 \""${FUNCNAME}\"" 2 200 400 || return 1\n+    # Mode 2 produces 2 streams\n+    files_exist \""${FUNCNAME}\"" 2 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp9_mode_3() {\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp9 \""${FUNCNAME}\"" 3 200 400 600 || return 1\n+    # Mode 3 produces 3 streams\n+    files_exist \""${FUNCNAME}\"" 3 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp9_mode_4() {\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp9 \""${FUNCNAME}\"" 4 200 400 600 || return 1\n+    # Mode 4 produces 3 streams\n+    files_exist \""${FUNCNAME}\"" 3 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp9_mode_5() {\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp9 \""${FUNCNAME}\"" 5 200 400 600 || return 1\n+    # Mode 5 produces 3 streams\n+    files_exist \""${FUNCNAME}\"" 3 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp9_mode_6() {\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp9 \""${FUNCNAME}\"" 6 200 400 600 || return 1\n+    # Mode 6 produces 3 streams\n+    files_exist \""${FUNCNAME}\"" 3 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp9_mode_7() {\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp9 \""${FUNCNAME}\"" 7 200 400 600 800 1000 || return 1\n+    # Mode 7 produces 5 streams\n+    files_exist \""${FUNCNAME}\"" 5 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp9_mode_8() {\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp9 \""${FUNCNAME}\"" 8 200 400 || return 1\n+    # Mode 8 produces 2 streams\n+    files_exist \""${FUNCNAME}\"" 2 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp9_mode_9() {\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp9 \""${FUNCNAME}\"" 9 200 400 600 || return 1\n+    # Mode 9 produces 3 streams\n+    files_exist \""${FUNCNAME}\"" 3 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp9_mode_10() {\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp9 \""${FUNCNAME}\"" 10 200 400 600 || return 1\n+    # Mode 10 produces 3 streams\n+    files_exist \""${FUNCNAME}\"" 3 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_vp9_mode_11() {\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+    vpx_tsvc_encoder vp9 \""${FUNCNAME}\"" 11 200 400 600 || return 1\n+    # Mode 11 produces 3 streams\n+    files_exist \""${FUNCNAME}\"" 3 || return 1\n+  fi\n+}\n+\n+vpx_tsvc_encoder_tests=\""vpx_tsvc_encoder_vp8_mode_0\n+                        vpx_tsvc_encoder_vp8_mode_1\n+                        vpx_tsvc_encoder_vp8_mode_2\n+                        vpx_tsvc_encoder_vp8_mode_3\n+                        vpx_tsvc_encoder_vp8_mode_4\n+                        vpx_tsvc_encoder_vp8_mode_5\n+                        vpx_tsvc_encoder_vp8_mode_6\n+                        vpx_tsvc_encoder_vp8_mode_7\n+                        vpx_tsvc_encoder_vp8_mode_8\n+                        vpx_tsvc_encoder_vp8_mode_9\n+                        vpx_tsvc_encoder_vp8_mode_10\n+                        vpx_tsvc_encoder_vp8_mode_11\n+                        vpx_tsvc_encoder_vp9_mode_0\n+                        vpx_tsvc_encoder_vp9_mode_1\n+                        vpx_tsvc_encoder_vp9_mode_2\n+                        vpx_tsvc_encoder_vp9_mode_3\n+                        vpx_tsvc_encoder_vp9_mode_4\n+                        vpx_tsvc_encoder_vp9_mode_5\n+                        vpx_tsvc_encoder_vp9_mode_6\n+                        vpx_tsvc_encoder_vp9_mode_7\n+                        vpx_tsvc_encoder_vp9_mode_8\n+                        vpx_tsvc_encoder_vp9_mode_9\n+                        vpx_tsvc_encoder_vp9_mode_10\n+                        vpx_tsvc_encoder_vp9_mode_11\""\n+\n+run_tests vpx_tsvc_encoder_verify_environment \""${vpx_tsvc_encoder_tests}\""\n""}<_**next**_>{""filename"": ""libvpx/test/vpxdec.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vpxdec.sh"", ""patch"": ""@@ -14,52 +14,103 @@\n\n ##\n . $(dirname $0)/tools_common.sh\n \n-VP8_IVF_FILE=\""${LIBVPX_TEST_DATA_PATH}/vp80-00-comprehensive-001.ivf\""\n-VP9_WEBM_FILE=\""${LIBVPX_TEST_DATA_PATH}/vp90-2-00-quantizer-00.webm\""\n-\n # Environment check: Make sure input is available.\n vpxdec_verify_environment() {\n-  if [ ! -e \""${VP8_IVF_FILE}\"" ] || [ ! -e \""${VP9_WEBM_FILE}\"" ]; then\n-    echo \""Libvpx test data must exist in LIBVPX_TEST_DATA_PATH.\""\n+  if [ ! -e \""${VP8_IVF_FILE}\"" ] || [ ! -e \""${VP9_WEBM_FILE}\"" ] || \\\n+    [ ! -e \""${VP9_FPM_WEBM_FILE}\"" ] || \\\n+    [ ! -e \""${VP9_LT_50_FRAMES_WEBM_FILE}\"" ] ; then\n+    elog \""Libvpx test data must exist in LIBVPX_TEST_DATA_PATH.\""\n+    return 1\n+  fi\n+  if [ -z \""$(vpx_tool_path vpxdec)\"" ]; then\n+    elog \""vpxdec not found. It must exist in LIBVPX_BIN_PATH or its parent.\""\n     return 1\n   fi\n }\n \n+# Wrapper function for running vpxdec with pipe input. Requires that\n+# LIBVPX_BIN_PATH points to the directory containing vpxdec. $1 is used as the\n+# input file path and shifted away. All remaining parameters are passed through\n+# to vpxdec.\n+vpxdec_pipe() {\n+  local readonly decoder=\""$(vpx_tool_path vpxdec)\""\n+  local readonly input=\""$1\""\n+  shift\n+  cat \""${input}\"" | eval \""${VPX_TEST_PREFIX}\"" \""${decoder}\"" - \""$@\"" ${devnull}\n+}\n+\n+# Wrapper function for running vpxdec. Requires that LIBVPX_BIN_PATH points to\n+# the directory containing vpxdec. $1 one is used as the input file path and\n+# shifted away. All remaining parameters are passed through to vpxdec.\n+vpxdec() {\n+  local readonly decoder=\""$(vpx_tool_path vpxdec)\""\n+  local readonly input=\""$1\""\n+  shift\n+  eval \""${VPX_TEST_PREFIX}\"" \""${decoder}\"" \""$input\"" \""$@\"" ${devnull}\n+}\n+\n vpxdec_can_decode_vp8() {\n-  if [ \""$(vpxdec_available)\"" = \""yes\"" ] && \\\n-     [ \""$(vp8_decode_available)\"" = \""yes\"" ]; then\n+  if [ \""$(vp8_decode_available)\"" = \""yes\"" ]; then\n     echo yes\n   fi\n }\n \n vpxdec_can_decode_vp9() {\n-  if [ \""$(vpxdec_available)\"" = \""yes\"" ] && \\\n-     [ \""$(vp9_decode_available)\"" = \""yes\"" ]; then\n+  if [ \""$(vp9_decode_available)\"" = \""yes\"" ]; then\n     echo yes\n   fi\n }\n \n vpxdec_vp8_ivf() {\n   if [ \""$(vpxdec_can_decode_vp8)\"" = \""yes\"" ]; then\n-    vpxdec \""${VP8_IVF_FILE}\""\n+    vpxdec \""${VP8_IVF_FILE}\"" --summary --noblit\n   fi\n }\n \n vpxdec_vp8_ivf_pipe_input() {\n   if [ \""$(vpxdec_can_decode_vp8)\"" = \""yes\"" ]; then\n-    vpxdec \""${VP8_IVF_FILE}\"" -\n+    vpxdec_pipe \""${VP8_IVF_FILE}\"" --summary --noblit\n   fi\n }\n \n vpxdec_vp9_webm() {\n   if [ \""$(vpxdec_can_decode_vp9)\"" = \""yes\"" ] && \\\n      [ \""$(webm_io_available)\"" = \""yes\"" ]; then\n-    vpxdec \""${VP9_WEBM_FILE}\""\n+    vpxdec \""${VP9_WEBM_FILE}\"" --summary --noblit\n+  fi\n+}\n+\n+vpxdec_vp9_webm_frame_parallel() {\n+  if [ \""$(vpxdec_can_decode_vp9)\"" = \""yes\"" ] && \\\n+     [ \""$(webm_io_available)\"" = \""yes\"" ]; then\n+    for threads in 2 3 4 5 6 7 8; do\n+      vpxdec \""${VP9_FPM_WEBM_FILE}\"" --summary --noblit --threads=$threads \\\n+        --frame-parallel\n+    done\n+  fi\n+}\n+\n+vpxdec_vp9_webm_less_than_50_frames() {\n+  # ensure that reaching eof in webm_guess_framerate doesn't result in invalid\n+  # frames in actual webm_read_frame calls.\n+  if [ \""$(vpxdec_can_decode_vp9)\"" = \""yes\"" ] && \\\n+     [ \""$(webm_io_available)\"" = \""yes\"" ]; then\n+    local readonly decoder=\""$(vpx_tool_path vpxdec)\""\n+    local readonly expected=10\n+    local readonly num_frames=$(${VPX_TEST_PREFIX} \""${decoder}\"" \\\n+      \""${VP9_LT_50_FRAMES_WEBM_FILE}\"" --summary --noblit 2>&1 \\\n+      | awk '/^[0-9]+ decoded frames/ { print $1 }')\n+    if [ \""$num_frames\"" -ne \""$expected\"" ]; then\n+      elog \""Output frames ($num_frames) != expected ($expected)\""\n+      return 1\n+    fi\n   fi\n }\n \n vpxdec_tests=\""vpxdec_vp8_ivf\n               vpxdec_vp8_ivf_pipe_input\n-              vpxdec_vp9_webm\""\n+              vpxdec_vp9_webm\n+              vpxdec_vp9_webm_frame_parallel\n+              vpxdec_vp9_webm_less_than_50_frames\""\n \n run_tests vpxdec_verify_environment \""${vpxdec_tests}\""\n""}<_**next**_>{""filename"": ""libvpx/test/vpxenc.sh"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/vpxenc.sh"", ""patch"": ""@@ -15,82 +15,415 @@\n\n ##\n . $(dirname $0)/tools_common.sh\n \n-YUV_RAW_INPUT=\""${LIBVPX_TEST_DATA_PATH}/hantro_collage_w352h288.yuv\""\n-YUV_RAW_INPUT_WIDTH=352\n-YUV_RAW_INPUT_HEIGHT=288\n-TEST_FRAMES=10\n+readonly TEST_FRAMES=10\n \n # Environment check: Make sure input is available.\n vpxenc_verify_environment() {\n   if [ ! -e \""${YUV_RAW_INPUT}\"" ]; then\n-    echo \""The file ${YUV_RAW_INPUT##*/} must exist in LIBVPX_TEST_DATA_PATH.\""\n+    elog \""The file ${YUV_RAW_INPUT##*/} must exist in LIBVPX_TEST_DATA_PATH.\""\n+    return 1\n+  fi\n+  if [ \""$(vpxenc_can_encode_vp9)\"" = \""yes\"" ]; then\n+    if [ ! -e \""${Y4M_NOSQ_PAR_INPUT}\"" ]; then\n+      elog \""The file ${Y4M_NOSQ_PAR_INPUT##*/} must exist in\""\n+      elog \""LIBVPX_TEST_DATA_PATH.\""\n+      return 1\n+    fi\n+  fi\n+  if [ -z \""$(vpx_tool_path vpxenc)\"" ]; then\n+    elog \""vpxenc not found. It must exist in LIBVPX_BIN_PATH or its parent.\""\n     return 1\n   fi\n }\n \n vpxenc_can_encode_vp8() {\n-  if [ \""$(vpxenc_available)\"" = \""yes\"" ] && \\\n-     [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n+  if [ \""$(vp8_encode_available)\"" = \""yes\"" ]; then\n     echo yes\n   fi\n }\n \n vpxenc_can_encode_vp9() {\n-  if [ \""$(vpxenc_available)\"" = \""yes\"" ] && \\\n-     [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n+  if [ \""$(vp9_encode_available)\"" = \""yes\"" ]; then\n     echo yes\n   fi\n }\n \n-vpxenc_vp8_ivf() {\n-  if [ \""$(vpxenc_can_encode_vp8)\"" = \""yes\"" ]; then\n-    vpxenc vp8 ${YUV_RAW_INPUT_WIDTH} ${YUV_RAW_INPUT_HEIGHT} ${TEST_FRAMES} \\\n-        \""${YUV_RAW_INPUT}\"" vp8.ivf\n-  fi\n+# Echo vpxenc command line parameters allowing use of\n+# hantro_collage_w352h288.yuv as input.\n+yuv_input_hantro_collage() {\n+  echo \""\""${YUV_RAW_INPUT}\""\n+       --width=\""${YUV_RAW_INPUT_WIDTH}\""\n+       --height=\""${YUV_RAW_INPUT_HEIGHT}\""\""\n }\n \n-vpxenc_vp8_ivf_pipe_input() {\n+y4m_input_non_square_par() {\n+  echo \""\""${Y4M_NOSQ_PAR_INPUT}\""\""\n+}\n+\n+y4m_input_720p() {\n+  echo \""\""${Y4M_720P_INPUT}\""\""\n+}\n+\n+# Echo default vpxenc real time encoding params. $1 is the codec, which defaults\n+# to vp8 if unspecified.\n+vpxenc_rt_params() {\n+  local readonly codec=\""${1:-vp8}\""\n+  echo \""--codec=${codec}\n+    --buf-initial-sz=500\n+    --buf-optimal-sz=600\n+    --buf-sz=1000\n+    --cpu-used=-6\n+    --end-usage=cbr\n+    --error-resilient=1\n+    --kf-max-dist=90000\n+    --lag-in-frames=0\n+    --max-intra-rate=300\n+    --max-q=56\n+    --min-q=2\n+    --noise-sensitivity=0\n+    --overshoot-pct=50\n+    --passes=1\n+    --profile=0\n+    --resize-allowed=0\n+    --rt\n+    --static-thresh=0\n+    --undershoot-pct=50\""\n+}\n+\n+# Wrapper function for running vpxenc with pipe input. Requires that\n+# LIBVPX_BIN_PATH points to the directory containing vpxenc. $1 is used as the\n+# input file path and shifted away. All remaining parameters are passed through\n+# to vpxenc.\n+vpxenc_pipe() {\n+  local readonly encoder=\""$(vpx_tool_path vpxenc)\""\n+  local readonly input=\""$1\""\n+  shift\n+  cat \""${input}\"" | eval \""${VPX_TEST_PREFIX}\"" \""${encoder}\"" - \\\n+    --test-decode=fatal \\\n+    \""$@\"" ${devnull}\n+}\n+\n+# Wrapper function for running vpxenc. Requires that LIBVPX_BIN_PATH points to\n+# the directory containing vpxenc. $1 one is used as the input file path and\n+# shifted away. All remaining parameters are passed through to vpxenc.\n+vpxenc() {\n+  local readonly encoder=\""$(vpx_tool_path vpxenc)\""\n+  local readonly input=\""$1\""\n+  shift\n+  eval \""${VPX_TEST_PREFIX}\"" \""${encoder}\"" \""${input}\"" \\\n+    --test-decode=fatal \\\n+    \""$@\"" ${devnull}\n+}\n+\n+vpxenc_vp8_ivf() {\n   if [ \""$(vpxenc_can_encode_vp8)\"" = \""yes\"" ]; then\n-    vpxenc vp8 ${YUV_RAW_INPUT_WIDTH} ${YUV_RAW_INPUT_HEIGHT} ${TEST_FRAMES} \\\n-        \""${YUV_RAW_INPUT}\"" vp8.ivf -\n+    local readonly output=\""${VPX_TEST_OUTPUT_DIR}/vp8.ivf\""\n+    vpxenc $(yuv_input_hantro_collage) \\\n+      --codec=vp8 \\\n+      --limit=\""${TEST_FRAMES}\"" \\\n+      --ivf \\\n+      --output=\""${output}\""\n+\n+    if [ ! -e \""${output}\"" ]; then\n+      elog \""Output file does not exist.\""\n+      return 1\n+    fi\n   fi\n }\n \n vpxenc_vp8_webm() {\n-  if [ \""$(vpxenc_can_encode_vp8)\"" = \""yes\"" ] &&\n-     [ \""$(webm_io_available)\"" = \""yes\"" ] ; then\n-    vpxenc vp8 ${YUV_RAW_INPUT_WIDTH} ${YUV_RAW_INPUT_HEIGHT} ${TEST_FRAMES} \\\n-        \""${YUV_RAW_INPUT}\"" vp8.webm\n+  if [ \""$(vpxenc_can_encode_vp8)\"" = \""yes\"" ] && \\\n+     [ \""$(webm_io_available)\"" = \""yes\"" ]; then\n+    local readonly output=\""${VPX_TEST_OUTPUT_DIR}/vp8.webm\""\n+    vpxenc $(yuv_input_hantro_collage) \\\n+      --codec=vp8 \\\n+      --limit=\""${TEST_FRAMES}\"" \\\n+      --output=\""${output}\""\n+\n+    if [ ! -e \""${output}\"" ]; then\n+      elog \""Output file does not exist.\""\n+      return 1\n+    fi\n+  fi\n+}\n+\n+vpxenc_vp8_webm_rt() {\n+  if [ \""$(vpxenc_can_encode_vp8)\"" = \""yes\"" ] && \\\n+     [ \""$(webm_io_available)\"" = \""yes\"" ]; then\n+    local readonly output=\""${VPX_TEST_OUTPUT_DIR}/vp8_rt.webm\""\n+    vpxenc $(yuv_input_hantro_collage) \\\n+      $(vpxenc_rt_params vp8) \\\n+      --output=\""${output}\""\n+    if [ ! -e \""${output}\"" ]; then\n+      elog \""Output file does not exist.\""\n+      return 1\n+    fi\n+  fi\n+}\n+\n+vpxenc_vp8_webm_2pass() {\n+  if [ \""$(vpxenc_can_encode_vp8)\"" = \""yes\"" ] && \\\n+     [ \""$(webm_io_available)\"" = \""yes\"" ]; then\n+    local readonly output=\""${VPX_TEST_OUTPUT_DIR}/vp8.webm\""\n+    vpxenc $(yuv_input_hantro_collage) \\\n+      --codec=vp8 \\\n+      --limit=\""${TEST_FRAMES}\"" \\\n+      --output=\""${output}\"" \\\n+      --passes=2\n+\n+    if [ ! -e \""${output}\"" ]; then\n+      elog \""Output file does not exist.\""\n+      return 1\n+    fi\n+  fi\n+}\n+\n+vpxenc_vp8_webm_lag10_frames20() {\n+  if [ \""$(vpxenc_can_encode_vp8)\"" = \""yes\"" ] && \\\n+     [ \""$(webm_io_available)\"" = \""yes\"" ]; then\n+    local readonly lag_total_frames=20\n+    local readonly lag_frames=10\n+    local readonly output=\""${VPX_TEST_OUTPUT_DIR}/vp8_lag10_frames20.webm\""\n+    vpxenc $(yuv_input_hantro_collage) \\\n+      --codec=vp8 \\\n+      --limit=\""${lag_total_frames}\"" \\\n+      --lag-in-frames=\""${lag_frames}\"" \\\n+      --output=\""${output}\"" \\\n+      --auto-alt-ref=1 \\\n+      --passes=2\n+\n+    if [ ! -e \""${output}\"" ]; then\n+      elog \""Output file does not exist.\""\n+      return 1\n+    fi\n+  fi\n+}\n+\n+vpxenc_vp8_ivf_piped_input() {\n+  if [ \""$(vpxenc_can_encode_vp8)\"" = \""yes\"" ]; then\n+    local readonly output=\""${VPX_TEST_OUTPUT_DIR}/vp8_piped_input.ivf\""\n+    vpxenc_pipe $(yuv_input_hantro_collage) \\\n+      --codec=vp8 \\\n+      --limit=\""${TEST_FRAMES}\"" \\\n+      --ivf \\\n+      --output=\""${output}\""\n+\n+    if [ ! -e \""${output}\"" ]; then\n+      elog \""Output file does not exist.\""\n+      return 1\n+    fi\n   fi\n }\n \n vpxenc_vp9_ivf() {\n   if [ \""$(vpxenc_can_encode_vp9)\"" = \""yes\"" ]; then\n-    vpxenc vp9 ${YUV_RAW_INPUT_WIDTH} ${YUV_RAW_INPUT_HEIGHT} ${TEST_FRAMES} \\\n-        \""${YUV_RAW_INPUT}\"" vp9.ivf\n+    local readonly output=\""${VPX_TEST_OUTPUT_DIR}/vp9.ivf\""\n+    vpxenc $(yuv_input_hantro_collage) \\\n+      --codec=vp9 \\\n+      --limit=\""${TEST_FRAMES}\"" \\\n+      --ivf \\\n+      --output=\""${output}\""\n+\n+    if [ ! -e \""${output}\"" ]; then\n+      elog \""Output file does not exist.\""\n+      return 1\n+    fi\n   fi\n }\n \n vpxenc_vp9_webm() {\n-  if [ \""$(vpxenc_can_encode_vp9)\"" = \""yes\"" ] &&\n-     [ \""$(webm_io_available)\"" = \""yes\"" ] ; then\n-    vpxenc vp9 ${YUV_RAW_INPUT_WIDTH} ${YUV_RAW_INPUT_HEIGHT} ${TEST_FRAMES} \\\n-        \""${YUV_RAW_INPUT}\"" vp9.webm\n+  if [ \""$(vpxenc_can_encode_vp9)\"" = \""yes\"" ] && \\\n+     [ \""$(webm_io_available)\"" = \""yes\"" ]; then\n+    local readonly output=\""${VPX_TEST_OUTPUT_DIR}/vp9.webm\""\n+    vpxenc $(yuv_input_hantro_collage) \\\n+      --codec=vp9 \\\n+      --limit=\""${TEST_FRAMES}\"" \\\n+      --output=\""${output}\""\n+\n+    if [ ! -e \""${output}\"" ]; then\n+      elog \""Output file does not exist.\""\n+      return 1\n+    fi\n   fi\n }\n \n-DISABLED_vpxenc_vp9_ivf_lossless() {\n+vpxenc_vp9_webm_rt() {\n+  if [ \""$(vpxenc_can_encode_vp9)\"" = \""yes\"" ] && \\\n+     [ \""$(webm_io_available)\"" = \""yes\"" ]; then\n+    local readonly output=\""${VPX_TEST_OUTPUT_DIR}/vp9_rt.webm\""\n+    vpxenc $(yuv_input_hantro_collage) \\\n+      $(vpxenc_rt_params vp9) \\\n+      --output=\""${output}\""\n+\n+    if [ ! -e \""${output}\"" ]; then\n+      elog \""Output file does not exist.\""\n+      return 1\n+    fi\n+  fi\n+}\n+\n+vpxenc_vp9_webm_rt_multithread_tiled() {\n+  if [ \""$(vpxenc_can_encode_vp9)\"" = \""yes\"" ] && \\\n+     [ \""$(webm_io_available)\"" = \""yes\"" ]; then\n+    local readonly output=\""${VPX_TEST_OUTPUT_DIR}/vp9_rt_multithread_tiled.webm\""\n+    local readonly tilethread_min=2\n+    local readonly tilethread_max=4\n+    local readonly num_threads=\""$(seq ${tilethread_min} ${tilethread_max})\""\n+    local readonly num_tile_cols=\""$(seq ${tilethread_min} ${tilethread_max})\""\n+\n+    for threads in ${num_threads}; do\n+      for tile_cols in ${num_tile_cols}; do\n+        vpxenc $(y4m_input_720p) \\\n+          $(vpxenc_rt_params vp9) \\\n+          --threads=${threads} \\\n+          --tile-columns=${tile_cols} \\\n+          --output=\""${output}\""\n+      done\n+    done\n+\n+    if [ ! -e \""${output}\"" ]; then\n+      elog \""Output file does not exist.\""\n+      return 1\n+    fi\n+\n+    rm \""${output}\""\n+  fi\n+}\n+\n+vpxenc_vp9_webm_rt_multithread_tiled_frameparallel() {\n+  if [ \""$(vpxenc_can_encode_vp9)\"" = \""yes\"" ] && \\\n+     [ \""$(webm_io_available)\"" = \""yes\"" ]; then\n+    local readonly output=\""${VPX_TEST_OUTPUT_DIR}/vp9_rt_mt_t_fp.webm\""\n+    local readonly tilethread_min=2\n+    local readonly tilethread_max=4\n+    local readonly num_threads=\""$(seq ${tilethread_min} ${tilethread_max})\""\n+    local readonly num_tile_cols=\""$(seq ${tilethread_min} ${tilethread_max})\""\n+\n+    for threads in ${num_threads}; do\n+      for tile_cols in ${num_tile_cols}; do\n+        vpxenc $(y4m_input_720p) \\\n+          $(vpxenc_rt_params vp9) \\\n+          --threads=${threads} \\\n+          --tile-columns=${tile_cols} \\\n+          --frame-parallel=1 \\\n+          --output=\""${output}\""\n+      done\n+    done\n+\n+    if [ ! -e \""${output}\"" ]; then\n+      elog \""Output file does not exist.\""\n+      return 1\n+    fi\n+\n+    rm \""${output}\""\n+  fi\n+}\n+\n+vpxenc_vp9_webm_2pass() {\n+  if [ \""$(vpxenc_can_encode_vp9)\"" = \""yes\"" ] && \\\n+     [ \""$(webm_io_available)\"" = \""yes\"" ]; then\n+    local readonly output=\""${VPX_TEST_OUTPUT_DIR}/vp9.webm\""\n+    vpxenc $(yuv_input_hantro_collage) \\\n+      --codec=vp9 \\\n+      --limit=\""${TEST_FRAMES}\"" \\\n+      --output=\""${output}\"" \\\n+      --passes=2\n+\n+    if [ ! -e \""${output}\"" ]; then\n+      elog \""Output file does not exist.\""\n+      return 1\n+    fi\n+  fi\n+}\n+\n+vpxenc_vp9_ivf_lossless() {\n   if [ \""$(vpxenc_can_encode_vp9)\"" = \""yes\"" ]; then\n-    vpxenc vp9 ${YUV_RAW_INPUT_WIDTH} ${YUV_RAW_INPUT_HEIGHT} ${TEST_FRAMES} \\\n-        \""${YUV_RAW_INPUT}\"" vp9_lossless.ivf --lossless\n+    local readonly output=\""${VPX_TEST_OUTPUT_DIR}/vp9_lossless.ivf\""\n+    vpxenc $(yuv_input_hantro_collage) \\\n+      --codec=vp9 \\\n+      --limit=\""${TEST_FRAMES}\"" \\\n+      --ivf \\\n+      --output=\""${output}\"" \\\n+      --lossless=1\n+\n+    if [ ! -e \""${output}\"" ]; then\n+      elog \""Output file does not exist.\""\n+      return 1\n+    fi\n+  fi\n+}\n+\n+vpxenc_vp9_ivf_minq0_maxq0() {\n+  if [ \""$(vpxenc_can_encode_vp9)\"" = \""yes\"" ]; then\n+    local readonly output=\""${VPX_TEST_OUTPUT_DIR}/vp9_lossless_minq0_maxq0.ivf\""\n+    vpxenc $(yuv_input_hantro_collage) \\\n+      --codec=vp9 \\\n+      --limit=\""${TEST_FRAMES}\"" \\\n+      --ivf \\\n+      --output=\""${output}\"" \\\n+      --min-q=0 \\\n+      --max-q=0\n+\n+    if [ ! -e \""${output}\"" ]; then\n+      elog \""Output file does not exist.\""\n+      return 1\n+    fi\n+  fi\n+}\n+\n+vpxenc_vp9_webm_lag10_frames20() {\n+  if [ \""$(vpxenc_can_encode_vp9)\"" = \""yes\"" ] && \\\n+     [ \""$(webm_io_available)\"" = \""yes\"" ]; then\n+    local readonly lag_total_frames=20\n+    local readonly lag_frames=10\n+    local readonly output=\""${VPX_TEST_OUTPUT_DIR}/vp9_lag10_frames20.webm\""\n+    vpxenc $(yuv_input_hantro_collage) \\\n+      --codec=vp9 \\\n+      --limit=\""${lag_total_frames}\"" \\\n+      --lag-in-frames=\""${lag_frames}\"" \\\n+      --output=\""${output}\"" \\\n+      --passes=2 \\\n+      --auto-alt-ref=1\n+\n+    if [ ! -e \""${output}\"" ]; then\n+      elog \""Output file does not exist.\""\n+      return 1\n+    fi\n+  fi\n+}\n+\n+# TODO(fgalligan): Test that DisplayWidth is different than video width.\n+vpxenc_vp9_webm_non_square_par() {\n+  if [ \""$(vpxenc_can_encode_vp9)\"" = \""yes\"" ] && \\\n+     [ \""$(webm_io_available)\"" = \""yes\"" ]; then\n+    local readonly output=\""${VPX_TEST_OUTPUT_DIR}/vp9_non_square_par.webm\""\n+    vpxenc $(y4m_input_non_square_par) \\\n+      --codec=vp9 \\\n+      --limit=\""${TEST_FRAMES}\"" \\\n+      --output=\""${output}\""\n+\n+    if [ ! -e \""${output}\"" ]; then\n+      elog \""Output file does not exist.\""\n+      return 1\n+    fi\n   fi\n }\n \n vpxenc_tests=\""vpxenc_vp8_ivf\n               vpxenc_vp8_webm\n-              vpxenc_vp8_ivf_pipe_input\n+              vpxenc_vp8_webm_rt\n+              vpxenc_vp8_webm_2pass\n+              vpxenc_vp8_webm_lag10_frames20\n+              vpxenc_vp8_ivf_piped_input\n               vpxenc_vp9_ivf\n               vpxenc_vp9_webm\n-              DISABLED_vpxenc_vp9_ivf_lossless\""\n+              vpxenc_vp9_webm_rt\n+              vpxenc_vp9_webm_rt_multithread_tiled\n+              vpxenc_vp9_webm_rt_multithread_tiled_frameparallel\n+              vpxenc_vp9_webm_2pass\n+              vpxenc_vp9_ivf_lossless\n+              vpxenc_vp9_ivf_minq0_maxq0\n+              vpxenc_vp9_webm_lag10_frames20\n+              vpxenc_vp9_webm_non_square_par\""\n \n run_tests vpxenc_verify_environment \""${vpxenc_tests}\""\n""}<_**next**_>{""filename"": ""libvpx/test/webm_video_source.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/webm_video_source.h"", ""patch"": ""@@ -14,73 +14,20 @@\n\n #include <cstdlib>\n #include <new>\n #include <string>\n-#include \""third_party/nestegg/include/nestegg/nestegg.h\""\n+#include \""../tools_common.h\""\n+#include \""../webmdec.h\""\n #include \""test/video_source.h\""\n \n namespace libvpx_test {\n \n-static int\n-nestegg_read_cb(void *buffer, size_t length, void *userdata) {\n-  FILE *f = reinterpret_cast<FILE *>(userdata);\n-\n-  if (fread(buffer, 1, length, f) < length) {\n-    if (ferror(f))\n-      return -1;\n-    if (feof(f))\n-      return 0;\n-  }\n-  return 1;\n-}\n-\n-\n-static int\n-nestegg_seek_cb(int64_t offset, int whence, void *userdata) {\n-  FILE *f = reinterpret_cast<FILE *>(userdata);\n-  switch (whence) {\n-    case NESTEGG_SEEK_SET:\n-      whence = SEEK_SET;\n-      break;\n-    case NESTEGG_SEEK_CUR:\n-      whence = SEEK_CUR;\n-      break;\n-    case NESTEGG_SEEK_END:\n-      whence = SEEK_END;\n-      break;\n-  };\n-  return fseek(f, (long)offset, whence) ? -1 : 0;\n-}\n-\n-\n-static int64_t\n-nestegg_tell_cb(void *userdata) {\n-  FILE *f = reinterpret_cast<FILE *>(userdata);\n-  return ftell(f);\n-}\n-\n-\n-static void\n-nestegg_log_cb(nestegg *context, unsigned int severity, char const *format,\n-               ...) {\n-  va_list ap;\n-\n-  va_start(ap, format);\n-  vfprintf(stderr, format, ap);\n-  fprintf(stderr, \""\\n\"");\n-  va_end(ap);\n-}\n-\n // This class extends VideoSource to allow parsing of WebM files,\n // so that we can do actual file decodes.\n class WebMVideoSource : public CompressedVideoSource {\n  public:\n   explicit WebMVideoSource(const std::string &file_name)\n       : file_name_(file_name),\n-        input_file_(NULL),\n-        nestegg_ctx_(NULL),\n-        pkt_(NULL),\n-        video_track_(0),\n-        chunk_(0),\n-        chunks_(0),\n+        vpx_ctx_(new VpxInputContext()),\n+        webm_ctx_(new WebmInputContext()),\n         buf_(NULL),\n         buf_sz_(0),\n         frame_(0),\n@@ -88,42 +35,22 @@\n\n   }\n \n   virtual ~WebMVideoSource() {\n-    if (input_file_)\n-      fclose(input_file_);\n-    if (nestegg_ctx_ != NULL) {\n-      if (pkt_ != NULL) {\n-        nestegg_free_packet(pkt_);\n-      }\n-      nestegg_destroy(nestegg_ctx_);\n-    }\n+    if (vpx_ctx_->file != NULL)\n+      fclose(vpx_ctx_->file);\n+    webm_free(webm_ctx_);\n+    delete vpx_ctx_;\n+    delete webm_ctx_;\n   }\n \n   virtual void Init() {\n   }\n \n   virtual void Begin() {\n-    input_file_ = OpenTestDataFile(file_name_);\n-    ASSERT_TRUE(input_file_ != NULL) << \""Input file open failed. Filename: \""\n+    vpx_ctx_->file = OpenTestDataFile(file_name_);\n+    ASSERT_TRUE(vpx_ctx_->file != NULL) << \""Input file open failed. Filename: \""\n         << file_name_;\n \n-    nestegg_io io = {nestegg_read_cb, nestegg_seek_cb, nestegg_tell_cb,\n-                     input_file_};\n-    ASSERT_FALSE(nestegg_init(&nestegg_ctx_, io, NULL, -1))\n-        << \""nestegg_init failed\"";\n-\n-    unsigned int n;\n-    ASSERT_FALSE(nestegg_track_count(nestegg_ctx_, &n))\n-        << \""failed to get track count\"";\n-\n-    for (unsigned int i = 0; i < n; i++) {\n-      int track_type = nestegg_track_type(nestegg_ctx_, i);\n-      ASSERT_GE(track_type, 0) << \""failed to get track type\"";\n-\n-      if (track_type == NESTEGG_TRACK_VIDEO) {\n-        video_track_ = i;\n-        break;\n-      }\n-    }\n+    ASSERT_EQ(file_is_webm(webm_ctx_, vpx_ctx_), 1) << \""file is not WebM\"";\n \n     FillFrame();\n   }\n@@ -134,36 +61,24 @@\n\n   }\n \n   void FillFrame() {\n-    ASSERT_TRUE(input_file_ != NULL);\n-    if (chunk_ >= chunks_) {\n-      unsigned int track;\n-\n-      do {\n-        /* End of this packet, get another. */\n-        if (pkt_ != NULL) {\n-          nestegg_free_packet(pkt_);\n-          pkt_ = NULL;\n-        }\n-\n-        int again = nestegg_read_packet(nestegg_ctx_, &pkt_);\n-        ASSERT_GE(again, 0) << \""nestegg_read_packet failed\"";\n-        if (!again) {\n-          end_of_file_ = true;\n-          return;\n-        }\n-\n-        ASSERT_FALSE(nestegg_packet_track(pkt_, &track))\n-            << \""nestegg_packet_track failed\"";\n-      } while (track != video_track_);\n-\n-      ASSERT_FALSE(nestegg_packet_count(pkt_, &chunks_))\n-          << \""nestegg_packet_count failed\"";\n-      chunk_ = 0;\n+    ASSERT_TRUE(vpx_ctx_->file != NULL);\n+    const int status = webm_read_frame(webm_ctx_, &buf_, &buf_sz_, &buf_sz_);\n+    ASSERT_GE(status, 0) << \""webm_read_frame failed\"";\n+    if (status == 1) {\n+      end_of_file_ = true;\n     }\n+  }\n \n-    ASSERT_FALSE(nestegg_packet_data(pkt_, chunk_, &buf_, &buf_sz_))\n-        << \""nestegg_packet_data failed\"";\n-    chunk_++;\n+  void SeekToNextKeyFrame() {\n+    ASSERT_TRUE(vpx_ctx_->file != NULL);\n+    do {\n+      const int status = webm_read_frame(webm_ctx_, &buf_, &buf_sz_, &buf_sz_);\n+      ASSERT_GE(status, 0) << \""webm_read_frame failed\"";\n+      ++frame_;\n+      if (status == 1) {\n+        end_of_file_ = true;\n+      }\n+    } while (!webm_ctx_->is_key_frame && !end_of_file_);\n   }\n \n   virtual const uint8_t *cxdata() const {\n@@ -174,12 +89,8 @@\n\n \n  protected:\n   std::string file_name_;\n-  FILE *input_file_;\n-  nestegg *nestegg_ctx_;\n-  nestegg_packet *pkt_;\n-  unsigned int video_track_;\n-  unsigned int chunk_;\n-  unsigned int chunks_;\n+  VpxInputContext *vpx_ctx_;\n+  WebmInputContext *webm_ctx_;\n   uint8_t *buf_;\n   size_t buf_sz_;\n   unsigned int frame_;\n""}<_**next**_>{""filename"": ""libvpx/test/y4m_test.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426/libvpx/test/y4m_test.cc"", ""patch"": ""@@ -0,0 +1,195 @@\n\n+/*\n+ *  Copyright (c) 2012 The WebM project authors. All Rights Reserved.\n+ *\n+ *  Use of this source code is governed by a BSD-style license\n+ *  that can be found in the LICENSE file in the root of the source\n+ *  tree. An additional intellectual property rights grant can be found\n+ *  in the file PATENTS.  All contributing project authors may\n+ *  be found in the AUTHORS file in the root of the source tree.\n+ */\n+\n+#include <string>\n+\n+#include \""third_party/googletest/src/include/gtest/gtest.h\""\n+\n+#include \""./vpx_config.h\""\n+#include \""./y4menc.h\""\n+#include \""test/md5_helper.h\""\n+#include \""test/util.h\""\n+#include \""test/y4m_video_source.h\""\n+\n+namespace {\n+\n+using std::string;\n+\n+static const unsigned int kWidth  = 160;\n+static const unsigned int kHeight = 90;\n+static const unsigned int kFrames = 10;\n+\n+struct Y4mTestParam {\n+  const char *filename;\n+  unsigned int bit_depth;\n+  vpx_img_fmt format;\n+  const char *md5raw;\n+};\n+\n+const Y4mTestParam kY4mTestVectors[] = {\n+  {\""park_joy_90p_8_420.y4m\"", 8, VPX_IMG_FMT_I420,\n+    \""e5406275b9fc6bb3436c31d4a05c1cab\""},\n+  {\""park_joy_90p_8_422.y4m\"", 8, VPX_IMG_FMT_I422,\n+    \""284a47a47133b12884ec3a14e959a0b6\""},\n+  {\""park_joy_90p_8_444.y4m\"", 8, VPX_IMG_FMT_I444,\n+    \""90517ff33843d85de712fd4fe60dbed0\""},\n+  {\""park_joy_90p_10_420.y4m\"", 10, VPX_IMG_FMT_I42016,\n+    \""63f21f9f717d8b8631bd2288ee87137b\""},\n+  {\""park_joy_90p_10_422.y4m\"", 10, VPX_IMG_FMT_I42216,\n+    \""48ab51fb540aed07f7ff5af130c9b605\""},\n+  {\""park_joy_90p_10_444.y4m\"", 10, VPX_IMG_FMT_I44416,\n+    \""067bfd75aa85ff9bae91fa3e0edd1e3e\""},\n+  {\""park_joy_90p_12_420.y4m\"", 12, VPX_IMG_FMT_I42016,\n+    \""9e6d8f6508c6e55625f6b697bc461cef\""},\n+  {\""park_joy_90p_12_422.y4m\"", 12, VPX_IMG_FMT_I42216,\n+    \""b239c6b301c0b835485be349ca83a7e3\""},\n+  {\""park_joy_90p_12_444.y4m\"", 12, VPX_IMG_FMT_I44416,\n+    \""5a6481a550821dab6d0192f5c63845e9\""},\n+};\n+\n+static void write_image_file(const vpx_image_t *img, FILE *file) {\n+  int plane, y;\n+  for (plane = 0; plane < 3; ++plane) {\n+    const unsigned char *buf = img->planes[plane];\n+    const int stride = img->stride[plane];\n+    const int bytes_per_sample = (img->fmt & VPX_IMG_FMT_HIGHBITDEPTH) ? 2 : 1;\n+    const int h = (plane ? (img->d_h + img->y_chroma_shift) >>\n+                   img->y_chroma_shift : img->d_h);\n+    const int w = (plane ? (img->d_w + img->x_chroma_shift) >>\n+                   img->x_chroma_shift : img->d_w);\n+    for (y = 0; y < h; ++y) {\n+      fwrite(buf, bytes_per_sample, w, file);\n+      buf += stride;\n+    }\n+  }\n+}\n+\n+class Y4mVideoSourceTest\n+    : public ::testing::TestWithParam<Y4mTestParam>,\n+      public ::libvpx_test::Y4mVideoSource {\n+ protected:\n+  Y4mVideoSourceTest() : Y4mVideoSource(\""\"", 0, 0) {}\n+\n+  virtual ~Y4mVideoSourceTest() {\n+    CloseSource();\n+  }\n+\n+  virtual void Init(const std::string &file_name, int limit) {\n+    file_name_ = file_name;\n+    start_ = 0;\n+    limit_ = limit;\n+    frame_ = 0;\n+    Begin();\n+  }\n+\n+  // Checks y4m header information\n+  void HeaderChecks(unsigned int bit_depth, vpx_img_fmt_t fmt) {\n+    ASSERT_TRUE(input_file_ != NULL);\n+    ASSERT_EQ(y4m_.pic_w, (int)kWidth);\n+    ASSERT_EQ(y4m_.pic_h, (int)kHeight);\n+    ASSERT_EQ(img()->d_w, kWidth);\n+    ASSERT_EQ(img()->d_h, kHeight);\n+    ASSERT_EQ(y4m_.bit_depth, bit_depth);\n+    ASSERT_EQ(y4m_.vpx_fmt, fmt);\n+    if (fmt == VPX_IMG_FMT_I420 || fmt == VPX_IMG_FMT_I4201