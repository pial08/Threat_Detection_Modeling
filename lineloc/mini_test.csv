,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,flaw_line,flaw_line_index,func_after,func_before,index,lang,lines_after,lines_before,parentID,patch,processed_func,project,project_after,project_before,target,vul_func_with_fix
11,None,Remote,Not required,Partial,CVE-2016-5149,https://www.cvedetails.com/cve/CVE-2016-5149/,CWE-94,Medium,Partial,Partial,,2016-09-11,6.8,"The extensions subsystem in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux relies on an IFRAME source URL to identify an associated extension, which allows remote attackers to conduct extension-bindings injection attacks by leveraging script access to a resource that initially has the about:blank URL.",2018-10-30,,4.0,https://github.com/chromium/chromium/commit/53262b5285efbbfdbbcc17fbf5200890f1ee295c,53262b5285efbbfdbbcc17fbf5200890f1ee295c,"Migrate ServiceProcessControl tests off of QuitCurrent*Deprecated().

Bug: 844016
Change-Id: I9403b850456c8ee06cd2539f7cec9599302e81a0
Reviewed-on: https://chromium-review.googlesource.com/1126576
Commit-Queue: Wez <wez@chromium.org>
Reviewed-by: Avi Drissman <avi@chromium.org>
Cr-Commit-Position: refs/heads/master@{#573131}",3.0,chrome/browser/service_process/service_process_control_browsertest.cc,"{""sha"": ""0a04df0fa30f33bb4c1a9e7fa461ecce6c6aad83"", ""filename"": ""chrome/browser/service_process/service_process_control_browsertest.cc"", ""status"": ""modified"", ""additions"": 107, ""deletions"": 87, ""changes"": 194, ""blob_url"": ""https://github.com/chromium/chromium/blob/53262b5285efbbfdbbcc17fbf5200890f1ee295c/chrome/browser/service_process/service_process_control_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/53262b5285efbbfdbbcc17fbf5200890f1ee295c/chrome/browser/service_process/service_process_control_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/service_process/service_process_control_browsertest.cc?ref=53262b5285efbbfdbbcc17fbf5200890f1ee295c"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""chrome/browser/service_process/service_process_control.h\""\n \n+#include \""base/barrier_closure.h\""\n #include \""base/bind.h\""\n #include \""base/bind_helpers.h\""\n #include \""base/command_line.h\""\n@@ -37,36 +38,29 @@ class ServiceProcessControlBrowserTest\n   }\n   ~ServiceProcessControlBrowserTest() override {}\n \n-  void HistogramsCallback() {\n+  void HistogramsCallback(base::RepeatingClosure on_done) {\n     MockHistogramsCallback();\n-    QuitMessageLoop();\n+    on_done.Run();\n   }\n \n   MOCK_METHOD0(MockHistogramsCallback, void());\n \n  protected:\n-  void LaunchServiceProcessControl(bool wait) {\n+  void LaunchServiceProcessControl(base::RepeatingClosure on_launched) {\n     // Launch the process asynchronously.\n     ServiceProcessControl::GetInstance()->Launch(\n-        base::Bind(&ServiceProcessControlBrowserTest::ProcessControlLaunched,\n-                   base::Unretained(this)),\n-        base::Bind(\n+        base::BindOnce(\n+            &ServiceProcessControlBrowserTest::ProcessControlLaunched,\n+            base::Unretained(this), on_launched),\n+        base::BindOnce(\n             &ServiceProcessControlBrowserTest::ProcessControlLaunchFailed,\n-            base::Unretained(this)));\n-\n-    // Then run the message loop to keep things running.\n-    if (wait)\n-      content::RunMessageLoop();\n-  }\n-\n-  static void QuitMessageLoop() {\n-    base::RunLoop::QuitCurrentWhenIdleDeprecated();\n+            base::Unretained(this), on_launched));\n   }\n \n-  static void CloudPrintInfoCallback(bool enabled,\n-                                     const std::string& email,\n-                                     const std::string& proxy_id) {\n-    QuitMessageLoop();\n+  void LaunchServiceProcessControlAndWait() {\n+    base::RunLoop run_loop;\n+    LaunchServiceProcessControl(run_loop.QuitClosure());\n+    run_loop.Run();\n   }\n \n   void Disconnect() {\n@@ -101,7 +95,7 @@ class ServiceProcessControlBrowserTest\n     InProcessBrowserTest::TearDown();\n   }\n \n-  void ProcessControlLaunched() {\n+  void ProcessControlLaunched(base::OnceClosure on_done) {\n     base::ScopedAllowBlockingForTesting allow_blocking;\n     base::ProcessId service_pid;\n     EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));\n@@ -114,18 +108,12 @@ class ServiceProcessControlBrowserTest\n     service_process_ = base::Process::Open(service_pid);\n #endif\n     EXPECT_TRUE(service_process_.IsValid());\n-    // Quit the current message. Post a QuitTask instead of just calling Quit()\n-    // because this can get invoked in the context of a Launch() call and we\n-    // may not be in Run() yet.\n-    base::ThreadTaskRunnerHandle::Get()->PostTask(\n-        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());\n+    std::move(on_done).Run();\n   }\n \n-  void ProcessControlLaunchFailed() {\n+  void ProcessControlLaunchFailed(base::OnceClosure on_done) {\n     ADD_FAILURE();\n-    // Quit the current message.\n-    base::ThreadTaskRunnerHandle::Get()->PostTask(\n-        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());\n+    std::move(on_done).Run();\n   }\n \n  private:\n@@ -152,39 +140,45 @@ class RealServiceProcessControlBrowserTest\n // TODO(vitalybuka): Fix crbug.com/340563\n IN_PROC_BROWSER_TEST_F(RealServiceProcessControlBrowserTest,\n                        DISABLED_LaunchAndIPC) {\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n \n   // Make sure we are connected to the service process.\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n   cloud_print::mojom::CloudPrintPtr cloud_print_proxy;\n   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(\n       &cloud_print_proxy);\n+  base::RunLoop run_loop;\n   cloud_print_proxy->GetCloudPrintProxyInfo(\n-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));\n-  content::RunMessageLoop();\n+      base::BindOnce([](base::OnceClosure done, bool, const std::string&,\n+                        const std::string&) { std::move(done).Run(); },\n+                     run_loop.QuitClosure()));\n+  run_loop.Run();\n \n   // And then shutdown the service process.\n   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());\n }\n \n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndIPC) {\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n \n   // Make sure we are connected to the service process.\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n   cloud_print::mojom::CloudPrintPtr cloud_print_proxy;\n   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(\n       &cloud_print_proxy);\n+  base::RunLoop run_loop;\n   cloud_print_proxy->GetCloudPrintProxyInfo(\n-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));\n-  content::RunMessageLoop();\n+      base::BindOnce([](base::OnceClosure done, bool, const std::string&,\n+                        const std::string&) { std::move(done).Run(); },\n+                     run_loop.QuitClosure()));\n+  run_loop.Run();\n \n   // And then shutdown the service process.\n   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());\n }\n \n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndReconnect) {\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n \n   // Make sure we are connected to the service process.\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n@@ -197,21 +191,34 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndReconnect) {\n \n   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(\n       &cloud_print_proxy);\n-  cloud_print_proxy->GetCloudPrintProxyInfo(\n-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));\n-  content::RunMessageLoop();\n-  Disconnect();\n+  {\n+    base::RunLoop run_loop;\n+    cloud_print_proxy->GetCloudPrintProxyInfo(\n+        base::BindOnce([](base::OnceClosure done, bool, const std::string&,\n+                          const std::string&) { std::move(done).Run(); },\n+                       run_loop.QuitClosure()));\n+    run_loop.Run();\n+    Disconnect();\n+  }\n \n-  LaunchServiceProcessControl(false);\n+  {\n+    base::RunLoop run_loop;\n+    LaunchServiceProcessControl(run_loop.QuitClosure());\n \n-  ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n-  content::RunMessageLoop();\n+    ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n+    run_loop.Run();\n+  }\n \n   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(\n       &cloud_print_proxy);\n-  cloud_print_proxy->GetCloudPrintProxyInfo(\n-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));\n-  content::RunMessageLoop();\n+  {\n+    base::RunLoop run_loop;\n+    cloud_print_proxy->GetCloudPrintProxyInfo(\n+        base::BindOnce([](base::OnceClosure done, bool, const std::string&,\n+                          const std::string&) { std::move(done).Run(); },\n+                       run_loop.QuitClosure()));\n+    run_loop.Run();\n+  }\n \n   // And then shutdown the service process.\n   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());\n@@ -227,32 +234,35 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndReconnect) {\n #endif\n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_LaunchTwice) {\n   // Launch the service process the first time.\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n \n   // Make sure we are connected to the service process.\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n   cloud_print::mojom::CloudPrintPtr cloud_print_proxy;\n   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(\n       &cloud_print_proxy);\n-  cloud_print_proxy->GetCloudPrintProxyInfo(\n-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));\n-  content::RunMessageLoop();\n+  {\n+    base::RunLoop run_loop;\n+    cloud_print_proxy->GetCloudPrintProxyInfo(\n+        base::BindOnce([](base::OnceClosure done, bool, const std::string&,\n+                          const std::string&) { std::move(done).Run(); },\n+                       run_loop.QuitClosure()));\n+    run_loop.Run();\n+  }\n \n   // Launch the service process again.\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(\n       &cloud_print_proxy);\n-  cloud_print_proxy->GetCloudPrintProxyInfo(\n-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));\n-  content::RunMessageLoop();\n-}\n-\n-static void DecrementUntilZero(int* count) {\n-  (*count)--;\n-  if (!(*count))\n-    base::ThreadTaskRunnerHandle::Get()->PostTask(\n-        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());\n+  {\n+    base::RunLoop run_loop;\n+    cloud_print_proxy->GetCloudPrintProxyInfo(\n+        base::BindOnce([](base::OnceClosure done, bool, const std::string&,\n+                          const std::string&) { std::move(done).Run(); },\n+                       run_loop.QuitClosure()));\n+    run_loop.Run();\n+  }\n }\n \n // Flaky on Mac. http://crbug.com/517420\n@@ -266,15 +276,23 @@ static void DecrementUntilZero(int* count) {\n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,\n                        MAYBE_MultipleLaunchTasks) {\n   ServiceProcessControl* process = ServiceProcessControl::GetInstance();\n-  int launch_count = 5;\n-  for (int i = 0; i < launch_count; i++) {\n+  constexpr int kExpectedLaunchCount = 5;\n+  int success_count = 0;\n+  base::RunLoop run_loop;\n+  base::RepeatingClosure on_launch_attempted =\n+      base::BarrierClosure(kExpectedLaunchCount, run_loop.QuitClosure());\n+  for (int i = 0; i < kExpectedLaunchCount; i++) {\n     // Launch the process asynchronously.\n-    process->Launch(base::Bind(&DecrementUntilZero, &launch_count),\n-                    base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());\n+    process->Launch(base::BindOnce(\n+                        [](int* success_count, base::OnceClosure task) {\n+                          (*success_count)++;\n+                          std::move(task).Run();\n+                        },\n+                        &success_count, on_launch_attempted),\n+                    on_launch_attempted);\n   }\n-  // Then run the message loop to keep things running.\n-  content::RunMessageLoop();\n-  EXPECT_EQ(0, launch_count);\n+  run_loop.Run();\n+  EXPECT_EQ(kExpectedLaunchCount, success_count);\n }\n \n // Flaky on Mac. http://crbug.com/517420\n@@ -286,15 +304,15 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,\n // Make sure using the same task for success and failure tasks works.\n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_SameLaunchTask) {\n   ServiceProcessControl* process = ServiceProcessControl::GetInstance();\n-  int launch_count = 5;\n-  for (int i = 0; i < launch_count; i++) {\n+  constexpr int kExpectedLaunchCount = 5;\n+  base::RunLoop run_loop;\n+  base::RepeatingClosure task =\n+      base::BarrierClosure(kExpectedLaunchCount, run_loop.QuitClosure());\n+  for (int i = 0; i < kExpectedLaunchCount; i++) {\n     // Launch the process asynchronously.\n-    base::Closure task = base::Bind(&DecrementUntilZero, &launch_count);\n     process->Launch(task, task);\n   }\n-  // Then run the message loop to keep things running.\n-  content::RunMessageLoop();\n-  EXPECT_EQ(0, launch_count);\n+  run_loop.Run();\n }\n \n // Tests whether disconnecting from the service IPC causes the service process\n@@ -308,7 +326,7 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_SameLaunchTask) {\n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,\n                        MAYBE_DieOnDisconnect) {\n   // Launch the service process.\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n   // Make sure we are connected to the service process.\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n   Disconnect();\n@@ -322,7 +340,7 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,\n #endif\n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_ForceShutdown) {\n   // Launch the service process.\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n   // Make sure we are connected to the service process.\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n   base::ProcessId service_pid;\n@@ -343,7 +361,7 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_CheckPid) {\n   base::ScopedAllowBlockingForTesting allow_blocking;\n   EXPECT_FALSE(GetServiceProcessData(NULL, &service_pid));\n   // Launch the service process.\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n   EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));\n   EXPECT_NE(static_cast<base::ProcessId>(0), service_pid);\n   // Disconnect from service process.\n@@ -354,8 +372,8 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, HistogramsNoService) {\n   ASSERT_FALSE(ServiceProcessControl::GetInstance()->IsConnected());\n   EXPECT_CALL(*this, MockHistogramsCallback()).Times(0);\n   EXPECT_FALSE(ServiceProcessControl::GetInstance()->GetHistograms(\n-      base::Bind(&ServiceProcessControlBrowserTest::HistogramsCallback,\n-                 base::Unretained(this)),\n+      base::BindRepeating(&ServiceProcessControlBrowserTest::HistogramsCallback,\n+                          base::Unretained(this), base::DoNothing()),\n       base::TimeDelta()));\n }\n \n@@ -369,29 +387,31 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, HistogramsNoService) {\n #endif\n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,\n                        MAYBE_HistogramsTimeout) {\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n   // Callback should not be called during GetHistograms call.\n   EXPECT_CALL(*this, MockHistogramsCallback()).Times(0);\n+  base::RunLoop run_loop;\n   EXPECT_TRUE(ServiceProcessControl::GetInstance()->GetHistograms(\n-      base::Bind(&ServiceProcessControlBrowserTest::HistogramsCallback,\n-                 base::Unretained(this)),\n+      base::BindRepeating(&ServiceProcessControlBrowserTest::HistogramsCallback,\n+                          base::Unretained(this), run_loop.QuitClosure()),\n       base::TimeDelta::FromMilliseconds(100)));\n   EXPECT_CALL(*this, MockHistogramsCallback()).Times(1);\n   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());\n-  content::RunMessageLoop();\n+  run_loop.Run();\n }\n \n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_Histograms) {\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n   // Callback should not be called during GetHistograms call.\n   EXPECT_CALL(*this, MockHistogramsCallback()).Times(0);\n   // Wait for real callback by providing large timeout value.\n+  base::RunLoop run_loop;\n   EXPECT_TRUE(ServiceProcessControl::GetInstance()->GetHistograms(\n-      base::Bind(&ServiceProcessControlBrowserTest::HistogramsCallback,\n-                base::Unretained(this)),\n+      base::BindRepeating(&ServiceProcessControlBrowserTest::HistogramsCallback,\n+                          base::Unretained(this), run_loop.QuitClosure()),\n       base::TimeDelta::FromHours(1)));\n   EXPECT_CALL(*this, MockHistogramsCallback()).Times(1);\n-  content::RunMessageLoop();\n+  run_loop.Run();\n }""}","                                     const std::string& email,/~/                                     const std::string& proxy_id) {/~/    QuitMessageLoop();","1,2,3","  static void CloudPrintInfoCallback(bool enabled,
  void LaunchServiceProcessControlAndWait() {
    base::RunLoop run_loop;
    LaunchServiceProcessControl(run_loop.QuitClosure());
    run_loop.Run();
   }
","  static void CloudPrintInfoCallback(bool enabled,
                                     const std::string& email,
                                     const std::string& proxy_id) {
    QuitMessageLoop();
   }
",185961.0,C,"  void LaunchServiceProcessControlAndWait() {
    base::RunLoop run_loop;
    LaunchServiceProcessControl(run_loop.QuitClosure());
    run_loop.Run();
","                                     const std::string& email,
                                     const std::string& proxy_id) {
    QuitMessageLoop();
",,"@@ -4,6 +4,7 @@
 
 #include ""chrome/browser/service_process/service_process_control.h""
 
+#include ""base/barrier_closure.h""
 #include ""base/bind.h""
 #include ""base/bind_helpers.h""
 #include ""base/command_line.h""
@@ -37,36 +38,29 @@ class ServiceProcessControlBrowserTest
   }
   ~ServiceProcessControlBrowserTest() override {}
 
-  void HistogramsCallback() {
+  void HistogramsCallback(base::RepeatingClosure on_done) {
     MockHistogramsCallback();
-    QuitMessageLoop();
+    on_done.Run();
   }
 
   MOCK_METHOD0(MockHistogramsCallback, void());
 
  protected:
-  void LaunchServiceProcessControl(bool wait) {
+  void LaunchServiceProcessControl(base::RepeatingClosure on_launched) {
     // Launch the process asynchronously.
     ServiceProcessControl::GetInstance()->Launch(
-        base::Bind(&ServiceProcessControlBrowserTest::ProcessControlLaunched,
-                   base::Unretained(this)),
-        base::Bind(
+        base::BindOnce(
+            &ServiceProcessControlBrowserTest::ProcessControlLaunched,
+            base::Unretained(this), on_launched),
+        base::BindOnce(
             &ServiceProcessControlBrowserTest::ProcessControlLaunchFailed,
-            base::Unretained(this)));
-
-    // Then run the message loop to keep things running.
-    if (wait)
-      content::RunMessageLoop();
-  }
-
-  static void QuitMessageLoop() {
-    base::RunLoop::QuitCurrentWhenIdleDeprecated();
+            base::Unretained(this), on_launched));
   }
 
-  static void CloudPrintInfoCallback(bool enabled,
-                                     const std::string& email,
-                                     const std::string& proxy_id) {
-    QuitMessageLoop();
+  void LaunchServiceProcessControlAndWait() {
+    base::RunLoop run_loop;
+    LaunchServiceProcessControl(run_loop.QuitClosure());
+    run_loop.Run();
   }
 
   void Disconnect() {
@@ -101,7 +95,7 @@ class ServiceProcessControlBrowserTest
     InProcessBrowserTest::TearDown();
   }
 
-  void ProcessControlLaunched() {
+  void ProcessControlLaunched(base::OnceClosure on_done) {
     base::ScopedAllowBlockingForTesting allow_blocking;
     base::ProcessId service_pid;
     EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));
@@ -114,18 +108,12 @@ class ServiceProcessControlBrowserTest
     service_process_ = base::Process::Open(service_pid);
 #endif
     EXPECT_TRUE(service_process_.IsValid());
-    // Quit the current message. Post a QuitTask instead of just calling Quit()
-    // because this can get invoked in the context of a Launch() call and we
-    // may not be in Run() yet.
-    base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());
+    std::move(on_done).Run();
   }
 
-  void ProcessControlLaunchFailed() {
+  void ProcessControlLaunchFailed(base::OnceClosure on_done) {
     ADD_FAILURE();
-    // Quit the current message.
-    base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());
+    std::move(on_done).Run();
   }
 
  private:
@@ -152,39 +140,45 @@ class RealServiceProcessControlBrowserTest
 // TODO(vitalybuka): Fix crbug.com/340563
 IN_PROC_BROWSER_TEST_F(RealServiceProcessControlBrowserTest,
                        DISABLED_LaunchAndIPC) {
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
 
   // Make sure we are connected to the service process.
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   cloud_print::mojom::CloudPrintPtr cloud_print_proxy;
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
+  base::RunLoop run_loop;
   cloud_print_proxy->GetCloudPrintProxyInfo(
-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));
-  content::RunMessageLoop();
+      base::BindOnce([](base::OnceClosure done, bool, const std::string&,
+                        const std::string&) { std::move(done).Run(); },
+                     run_loop.QuitClosure()));
+  run_loop.Run();
 
   // And then shutdown the service process.
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());
 }
 
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndIPC) {
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
 
   // Make sure we are connected to the service process.
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   cloud_print::mojom::CloudPrintPtr cloud_print_proxy;
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
+  base::RunLoop run_loop;
   cloud_print_proxy->GetCloudPrintProxyInfo(
-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));
-  content::RunMessageLoop();
+      base::BindOnce([](base::OnceClosure done, bool, const std::string&,
+                        const std::string&) { std::move(done).Run(); },
+                     run_loop.QuitClosure()));
+  run_loop.Run();
 
   // And then shutdown the service process.
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());
 }
 
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndReconnect) {
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
 
   // Make sure we are connected to the service process.
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
@@ -197,21 +191,34 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndReconnect) {
 
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
-  cloud_print_proxy->GetCloudPrintProxyInfo(
-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));
-  content::RunMessageLoop();
-  Disconnect();
+  {
+    base::RunLoop run_loop;
+    cloud_print_proxy->GetCloudPrintProxyInfo(
+        base::BindOnce([](base::OnceClosure done, bool, const std::string&,
+                          const std::string&) { std::move(done).Run(); },
+                       run_loop.QuitClosure()));
+    run_loop.Run();
+    Disconnect();
+  }
 
-  LaunchServiceProcessControl(false);
+  {
+    base::RunLoop run_loop;
+    LaunchServiceProcessControl(run_loop.QuitClosure());
 
-  ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
-  content::RunMessageLoop();
+    ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
+    run_loop.Run();
+  }
 
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
-  cloud_print_proxy->GetCloudPrintProxyInfo(
-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));
-  content::RunMessageLoop();
+  {
+    base::RunLoop run_loop;
+    cloud_print_proxy->GetCloudPrintProxyInfo(
+        base::BindOnce([](base::OnceClosure done, bool, const std::string&,
+                          const std::string&) { std::move(done).Run(); },
+                       run_loop.QuitClosure()));
+    run_loop.Run();
+  }
 
   // And then shutdown the service process.
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());
@@ -227,32 +234,35 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndReconnect) {
 #endif
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_LaunchTwice) {
   // Launch the service process the first time.
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
 
   // Make sure we are connected to the service process.
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   cloud_print::mojom::CloudPrintPtr cloud_print_proxy;
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
-  cloud_print_proxy->GetCloudPrintProxyInfo(
-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));
-  content::RunMessageLoop();
+  {
+    base::RunLoop run_loop;
+    cloud_print_proxy->GetCloudPrintProxyInfo(
+        base::BindOnce([](base::OnceClosure done, bool, const std::string&,
+                          const std::string&) { std::move(done).Run(); },
+                       run_loop.QuitClosure()));
+    run_loop.Run();
+  }
 
   // Launch the service process again.
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
-  cloud_print_proxy->GetCloudPrintProxyInfo(
-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));
-  content::RunMessageLoop();
-}
-
-static void DecrementUntilZero(int* count) {
-  (*count)--;
-  if (!(*count))
-    base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());
+  {
+    base::RunLoop run_loop;
+    cloud_print_proxy->GetCloudPrintProxyInfo(
+        base::BindOnce([](base::OnceClosure done, bool, const std::string&,
+                          const std::string&) { std::move(done).Run(); },
+                       run_loop.QuitClosure()));
+    run_loop.Run();
+  }
 }
 
 // Flaky on Mac. http://crbug.com/517420
@@ -266,15 +276,23 @@ static void DecrementUntilZero(int* count) {
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,
                        MAYBE_MultipleLaunchTasks) {
   ServiceProcessControl* process = ServiceProcessControl::GetInstance();
-  int launch_count = 5;
-  for (int i = 0; i < launch_count; i++) {
+  constexpr int kExpectedLaunchCount = 5;
+  int success_count = 0;
+  base::RunLoop run_loop;
+  base::RepeatingClosure on_launch_attempted =
+      base::BarrierClosure(kExpectedLaunchCount, run_loop.QuitClosure());
+  for (int i = 0; i < kExpectedLaunchCount; i++) {
     // Launch the process asynchronously.
-    process->Launch(base::Bind(&DecrementUntilZero, &launch_count),
-                    base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());
+    process->Launch(base::BindOnce(
+                        [](int* success_count, base::OnceClosure task) {
+                          (*success_count)++;
+                          std::move(task).Run();
+                        },
+                        &success_count, on_launch_attempted),
+                    on_launch_attempted);
   }
-  // Then run the message loop to keep things running.
-  content::RunMessageLoop();
-  EXPECT_EQ(0, launch_count);
+  run_loop.Run();
+  EXPECT_EQ(kExpectedLaunchCount, success_count);
 }
 
 // Flaky on Mac. http://crbug.com/517420
@@ -286,15 +304,15 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,
 // Make sure using the same task for success and failure tasks works.
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_SameLaunchTask) {
   ServiceProcessControl* process = ServiceProcessControl::GetInstance();
-  int launch_count = 5;
-  for (int i = 0; i < launch_count; i++) {
+  constexpr int kExpectedLaunchCount = 5;
+  base::RunLoop run_loop;
+  base::RepeatingClosure task =
+      base::BarrierClosure(kExpectedLaunchCount, run_loop.QuitClosure());
+  for (int i = 0; i < kExpectedLaunchCount; i++) {
     // Launch the process asynchronously.
-    base::Closure task = base::Bind(&DecrementUntilZero, &launch_count);
     process->Launch(task, task);
   }
-  // Then run the message loop to keep things running.
-  content::RunMessageLoop();
-  EXPECT_EQ(0, launch_count);
+  run_loop.Run();
 }
 
 // Tests whether disconnecting from the service IPC causes the service process
@@ -308,7 +326,7 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_SameLaunchTask) {
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,
                        MAYBE_DieOnDisconnect) {
   // Launch the service process.
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
   // Make sure we are connected to the service process.
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   Disconnect();
@@ -322,7 +340,7 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,
 #endif
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_ForceShutdown) {
   // Launch the service process.
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
   // Make sure we are connected to the service process.
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   base::ProcessId service_pid;
@@ -343,7 +361,7 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_CheckPid) {
   base::ScopedAllowBlockingForTesting allow_blocking;
   EXPECT_FALSE(GetServiceProcessData(NULL, &service_pid));
   // Launch the service process.
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
   EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));
   EXPECT_NE(static_cast<base::ProcessId>(0), service_pid);
   // Disconnect from service process.
@@ -354,8 +372,8 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, HistogramsNoService) {
   ASSERT_FALSE(ServiceProcessControl::GetInstance()->IsConnected());
   EXPECT_CALL(*this, MockHistogramsCallback()).Times(0);
   EXPECT_FALSE(ServiceProcessControl::GetInstance()->GetHistograms(
-      base::Bind(&ServiceProcessControlBrowserTest::HistogramsCallback,
-                 base::Unretained(this)),
+      base::BindRepeating(&ServiceProcessControlBrowserTest::HistogramsCallback,
+                          base::Unretained(this), base::DoNothing()),
       base::TimeDelta()));
 }
 
@@ -369,29 +387,31 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, HistogramsNoService) {
 #endif
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,
                        MAYBE_HistogramsTimeout) {
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   // Callback should not be called during GetHistograms call.
   EXPECT_CALL(*this, MockHistogramsCallback()).Times(0);
+  base::RunLoop run_loop;
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->GetHistograms(
-      base::Bind(&ServiceProcessControlBrowserTest::HistogramsCallback,
-                 base::Unretained(this)),
+      base::BindRepeating(&ServiceProcessControlBrowserTest::HistogramsCallback,
+                          base::Unretained(this), run_loop.QuitClosure()),
       base::TimeDelta::FromMilliseconds(100)));
   EXPECT_CALL(*this, MockHistogramsCallback()).Times(1);
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());
-  content::RunMessageLoop();
+  run_loop.Run();
 }
 
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_Histograms) {
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   // Callback should not be called during GetHistograms call.
   EXPECT_CALL(*this, MockHistogramsCallback()).Times(0);
   // Wait for real callback by providing large timeout value.
+  base::RunLoop run_loop;
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->GetHistograms(
-      base::Bind(&ServiceProcessControlBrowserTest::HistogramsCallback,
-                base::Unretained(this)),
+      base::BindRepeating(&ServiceProcessControlBrowserTest::HistogramsCallback,
+                          base::Unretained(this), run_loop.QuitClosure()),
       base::TimeDelta::FromHours(1)));
   EXPECT_CALL(*this, MockHistogramsCallback()).Times(1);
-  content::RunMessageLoop();
+  run_loop.Run();
 }","static void CloudPrintInfoCallback(bool enabled,
                                     const std::string& email,
                                     const std::string& proxy_id) {
    QuitMessageLoop();
}
",Chrome,53262b5285efbbfdbbcc17fbf5200890f1ee295c,56016bcf9add262d12ea2badcee26e972f8beab5,1.0,"  static void CloudPrintInfoCallback(bool enabled,
//flaw_line_below:
                                     const std::string& email,
//flaw_line_below:
                                     const std::string& proxy_id) {
//flaw_line_below:
    QuitMessageLoop();
//fix_flaw_line_below:
//  void LaunchServiceProcessControlAndWait() {
//fix_flaw_line_below:
//    base::RunLoop run_loop;
//fix_flaw_line_below:
//    LaunchServiceProcessControl(run_loop.QuitClosure());
//fix_flaw_line_below:
//    run_loop.Run();
   }
"
99,,,,,,,,,,,,,,,2010-11,,2.0,https://github.com/chromium/chromium/commit/a44b00c88bc5ea35b5b150217c5fd6e4ce168e58,a44b00c88bc5ea35b5b150217c5fd6e4ce168e58,"Apply behaviour change fix from upstream for previous XPath change.

BUG=58731
TEST=NONE

Review URL: http://codereview.chromium.org/4027006

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@63572 0039d316-1c4b-4281-b951-d872f2087c98",3.0,third_party/libxml/src/xpath.c,"{""sha"": ""832678a8b6360e45389c42744108c046cf695be1"", ""filename"": ""third_party/libxml/README.chromium"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/a44b00c88bc5ea35b5b150217c5fd6e4ce168e58/third_party/libxml/README.chromium"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a44b00c88bc5ea35b5b150217c5fd6e4ce168e58/third_party/libxml/README.chromium"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libxml/README.chromium?ref=a44b00c88bc5ea35b5b150217c5fd6e4ce168e58"", ""patch"": ""@@ -10,6 +10,7 @@ Current version: 2.7.7.\n \n Modifications:\n - Import XPath fix http://git.gnome.org/browse/libxml2/commit/?id=91d19754d46acd4a639a8b9e31f50f31c78f8c9c\n+- Import follow-on for above commit: http://git.gnome.org/browse/libxml2/commit/?id=ea90b894146030c214a7df6d8375310174f134b9\n \n To import a new snapshot of libxml:\n ""}<_**next**_>{""sha"": ""5d3474ef4d949d0d6ceb1c646e2ef312cdcc9ed3"", ""filename"": ""third_party/libxml/src/xpath.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 16, ""changes"": 33, ""blob_url"": ""https://github.com/chromium/chromium/blob/a44b00c88bc5ea35b5b150217c5fd6e4ce168e58/third_party/libxml/src/xpath.c"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a44b00c88bc5ea35b5b150217c5fd6e4ce168e58/third_party/libxml/src/xpath.c"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libxml/src/xpath.c?ref=a44b00c88bc5ea35b5b150217c5fd6e4ce168e58"", ""patch"": ""@@ -8106,17 +8106,17 @@ xmlXPathNextPrecedingSibling(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {\n xmlNodePtr\n xmlXPathNextFollowing(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {\n     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n-    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n-\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n-\treturn(NULL);\n-    if (cur != NULL) {\n-        if ((cur->type == XML_ATTRIBUTE_NODE) ||\n-            (cur->type == XML_NAMESPACE_DECL))\n+    if ((cur != NULL) && (cur->type  != XML_ATTRIBUTE_NODE) &&\n+        (cur->type != XML_NAMESPACE_DECL) && (cur->children != NULL))\n+        return(cur->children);\n+\n+    if (cur == NULL) {\n+        cur = ctxt->context->node;\n+        if (cur->type == XML_NAMESPACE_DECL)\n             return(NULL);\n-        if (cur->children != NULL)\n-            return cur->children ;\n+        if (cur->type == XML_ATTRIBUTE_NODE)\n+            cur = cur->parent;\n     }\n-    if (cur == NULL) cur = ctxt->context->node;\n     if (cur == NULL) return(NULL) ; /* ERROR */\n     if (cur->next != NULL) return(cur->next) ;\n     do {\n@@ -8170,11 +8170,13 @@ xmlNodePtr\n xmlXPathNextPreceding(xmlXPathParserContextPtr ctxt, xmlNodePtr cur)\n {\n     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n-    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n-\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n-\treturn(NULL);\n-    if (cur == NULL)\n+    if (cur == NULL) {\n         cur = ctxt->context->node;\n+        if (cur->type == XML_NAMESPACE_DECL)\n+            return(NULL);\n+        if (cur->type == XML_ATTRIBUTE_NODE)\n+            return(cur->parent);\n+    }\n     if (cur == NULL)\n \treturn (NULL);\n     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n@@ -8214,13 +8216,12 @@ xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,\n                               xmlNodePtr cur)\n {\n     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n-    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n-\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n-\treturn(NULL);\n     if (cur == NULL) {\n         cur = ctxt->context->node;\n         if (cur == NULL)\n             return (NULL);\n+        if (cur->type == XML_NAMESPACE_DECL)\n+            return (NULL);\n         ctxt->ancestor = cur->parent;\n     }\n     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))""}",    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||/~/	(ctxt->context->node->type == XML_NAMESPACE_DECL))/~/	return(NULL);,"4,5,6","xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
                               xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
     if (cur == NULL) {
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
        if (cur->type == XML_NAMESPACE_DECL)
            return (NULL);
         ctxt->ancestor = cur->parent;
     }
     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
	cur = cur->prev;
    while (cur->prev == NULL) {
        cur = cur->parent;
        if (cur == NULL)
            return (NULL);
        if (cur == ctxt->context->doc->children)
            return (NULL);
        if (cur != ctxt->ancestor)
            return (cur);
        ctxt->ancestor = cur->parent;
    }
    cur = cur->prev;
    while (cur->last != NULL)
        cur = cur->last;
    return (cur);
}
","xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
                               xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
	(ctxt->context->node->type == XML_NAMESPACE_DECL))
	return(NULL);
     if (cur == NULL) {
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
         ctxt->ancestor = cur->parent;
     }
     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
	cur = cur->prev;
    while (cur->prev == NULL) {
        cur = cur->parent;
        if (cur == NULL)
            return (NULL);
        if (cur == ctxt->context->doc->children)
            return (NULL);
        if (cur != ctxt->ancestor)
            return (cur);
        ctxt->ancestor = cur->parent;
    }
    cur = cur->prev;
    while (cur->last != NULL)
        cur = cur->last;
    return (cur);
}
",183429.0,C,"        if (cur->type == XML_NAMESPACE_DECL)
            return (NULL);
","    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
	(ctxt->context->node->type == XML_NAMESPACE_DECL))
	return(NULL);
",,"@@ -8106,17 +8106,17 @@ xmlXPathNextPrecedingSibling(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 xmlNodePtr
 xmlXPathNextFollowing(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
-    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
-	(ctxt->context->node->type == XML_NAMESPACE_DECL))
-	return(NULL);
-    if (cur != NULL) {
-        if ((cur->type == XML_ATTRIBUTE_NODE) ||
-            (cur->type == XML_NAMESPACE_DECL))
+    if ((cur != NULL) && (cur->type  != XML_ATTRIBUTE_NODE) &&
+        (cur->type != XML_NAMESPACE_DECL) && (cur->children != NULL))
+        return(cur->children);
+
+    if (cur == NULL) {
+        cur = ctxt->context->node;
+        if (cur->type == XML_NAMESPACE_DECL)
             return(NULL);
-        if (cur->children != NULL)
-            return cur->children ;
+        if (cur->type == XML_ATTRIBUTE_NODE)
+            cur = cur->parent;
     }
-    if (cur == NULL) cur = ctxt->context->node;
     if (cur == NULL) return(NULL) ; /* ERROR */
     if (cur->next != NULL) return(cur->next) ;
     do {
@@ -8170,11 +8170,13 @@ xmlNodePtr
 xmlXPathNextPreceding(xmlXPathParserContextPtr ctxt, xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
-    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
-	(ctxt->context->node->type == XML_NAMESPACE_DECL))
-	return(NULL);
-    if (cur == NULL)
+    if (cur == NULL) {
         cur = ctxt->context->node;
+        if (cur->type == XML_NAMESPACE_DECL)
+            return(NULL);
+        if (cur->type == XML_ATTRIBUTE_NODE)
+            return(cur->parent);
+    }
     if (cur == NULL)
 	return (NULL);
     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
@@ -8214,13 +8216,12 @@ xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
                               xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
-    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
-	(ctxt->context->node->type == XML_NAMESPACE_DECL))
-	return(NULL);
     if (cur == NULL) {
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
+        if (cur->type == XML_NAMESPACE_DECL)
+            return (NULL);
         ctxt->ancestor = cur->parent;
     }
     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))","xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
xmlNodePtr cur)
{
if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
	(ctxt->context->node->type == XML_NAMESPACE_DECL))
	return(NULL);
if (cur == NULL) {
cur = ctxt->context->node;
if (cur == NULL)
return (NULL);
ctxt->ancestor = cur->parent;
}
if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
cur = cur->prev;
while (cur->prev == NULL) {
cur = cur->parent;
if (cur == NULL)
return (NULL);
if (cur == ctxt->context->doc->children)
return (NULL);
if (cur != ctxt->ancestor)
return (cur);
ctxt->ancestor = cur->parent;
}
cur = cur->prev;
while (cur->last != NULL)
cur = cur->last;
return (cur);
}
",Chrome,a44b00c88bc5ea35b5b150217c5fd6e4ce168e58,eef2c2ed6ea089b49c0f6468154d5a4d524abaeb,1.0,"xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
                               xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
//flaw_line_below:
    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
//flaw_line_below:
	(ctxt->context->node->type == XML_NAMESPACE_DECL))
//flaw_line_below:
	return(NULL);
     if (cur == NULL) {
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
//fix_flaw_line_below:
//        if (cur->type == XML_NAMESPACE_DECL)
//fix_flaw_line_below:
//            return (NULL);
         ctxt->ancestor = cur->parent;
     }
     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
	cur = cur->prev;
    while (cur->prev == NULL) {
        cur = cur->parent;
        if (cur == NULL)
            return (NULL);
        if (cur == ctxt->context->doc->children)
            return (NULL);
        if (cur != ctxt->ancestor)
            return (cur);
        ctxt->ancestor = cur->parent;
    }
    cur = cur->prev;
    while (cur->last != NULL)
        cur = cur->last;
    return (cur);
}
"
103,None,Remote,Not required,None,CVE-2014-2020,https://www.cvedetails.com/cve/CVE-2014-2020/,CWE-189,Low,Partial,None,,2014-02-18,5.0,"ext/gd/gd.c in PHP 5.5.x before 5.5.9 does not check data types, which might allow remote attackers to obtain sensitive information by using a (1) string or (2) array data type in place of a numeric data type, as demonstrated by an imagecrop function call with a string for the x dimension value, a different vulnerability than CVE-2013-7226.",2014-03-08,+Info ,9.0,https://github.com/php/php-src/commit/2938329ce19cb8c4197dec146c3ec887c6f61d01,2938329ce19cb8c4197dec146c3ec887c6f61d01,"Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop())

And also fixed the bug: arguments are altered after some calls",3.0,ext/gd/gd.c,"{""sha"": ""86eeb7cea9fef34108eb023e82e5b38875db57e6"", ""filename"": ""NEWS"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/php/php-src/blob/2938329ce19cb8c4197dec146c3ec887c6f61d01/NEWS"", ""raw_url"": ""https://github.com/php/php-src/raw/2938329ce19cb8c4197dec146c3ec887c6f61d01/NEWS"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/NEWS?ref=2938329ce19cb8c4197dec146c3ec887c6f61d01"", ""patch"": ""@@ -29,6 +29,7 @@ PHP                                                                        NEWS\n   . Fixed bug #66229 (128.0.0.0/16 isn't reserved any longer). (Adam)\n \n - GD:\n+  . Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop()). (Laruence)\n   . Fixed bug #64405 (Use freetype-config for determining freetype2 dir(s)).\n     (Adam)\n     ""}<_**next**_>{""sha"": ""49970c168838a7c0882687d56e69089cac2857d9"", ""filename"": ""ext/gd/gd.c"", ""status"": ""modified"", ""additions"": 147, ""deletions"": 34, ""changes"": 181, ""blob_url"": ""https://github.com/php/php-src/blob/2938329ce19cb8c4197dec146c3ec887c6f61d01/ext/gd/gd.c"", ""raw_url"": ""https://github.com/php/php-src/raw/2938329ce19cb8c4197dec146c3ec887c6f61d01/ext/gd/gd.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/gd.c?ref=2938329ce19cb8c4197dec146c3ec887c6f61d01"", ""patch"": ""@@ -1538,9 +1538,15 @@ PHP_FUNCTION(imagesetstyle)\n \t\t\tbreak;\n \t\t}\n \n-\t\tconvert_to_long_ex(item);\n-\n-\t\tstylearr[index++] = Z_LVAL_PP(item);\n+\t\tif (Z_TYPE_PP(item) != IS_LONG) {\n+\t\t\tzval lval;\n+\t\t\tlval = **item;\n+\t\t\tzval_copy_ctor(&lval);\n+\t\t\tconvert_to_long(&lval);\n+\t\t\tstylearr[index++] = Z_LVAL(lval);\n+\t\t} else {\n+\t\t\tstylearr[index++] = Z_LVAL_PP(item);\n+\t\t}\n \t}\n \n \tgdImageSetStyle(im, stylearr, index);\n@@ -3346,14 +3352,26 @@ static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)\n \n \tfor (i = 0; i < npoints; i++) {\n \t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n-\t\t\tSEPARATE_ZVAL((var));\n-\t\t\tconvert_to_long(*var);\n-\t\t\tpoints[i].x = Z_LVAL_PP(var);\n+\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **var;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\tpoints[i].x = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\tpoints[i].x = Z_LVAL_PP(var);\n+\t\t\t}\n \t\t}\n \t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n-\t\t\tSEPARATE_ZVAL(var);\n-\t\t\tconvert_to_long(*var);\n-\t\t\tpoints[i].y = Z_LVAL_PP(var);\n+\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **var;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\tpoints[i].y = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\tpoints[i].y = Z_LVAL_PP(var);\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -4859,9 +4877,15 @@ PHP_FUNCTION(imageconvolution)\n \n \t\t\tfor (j=0; j<3; j++) {\n \t\t\t\tif (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {\n-\t\t\t\t\tSEPARATE_ZVAL(var2);\n-\t\t\t\t\tconvert_to_double(*var2);\n-\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL_PP(var2);\n+\t\t\t\t\tif (Z_TYPE_PP(var2) != IS_DOUBLE) {\n+\t\t\t\t\t\tzval dval;\n+\t\t\t\t\t\tdval = **var;\n+\t\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL(dval);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL_PP(var2);\n+\t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""You must have a 3x3 matrix\"");\n \t\t\t\t\tRETURN_FALSE;\n@@ -4954,28 +4978,60 @@ PHP_FUNCTION(imagecrop)\n \tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \""Image\"", le_gd);\n \n \tif (zend_hash_find(HASH_OF(z_rect), \""x\"", sizeof(\""x\""), (void **)&tmp) != FAILURE) {\n-\t\trect.x = Z_LVAL_PP(tmp);\n+\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\tzval lval;\n+\t\t\tlval = **tmp;\n+\t\t\tzval_copy_ctor(&lval);\n+\t\t\tconvert_to_long(&lval);\n+\t\t\trect.x = Z_LVAL(lval);\n+\t\t} else {\n+\t\t\trect.x = Z_LVAL_PP(tmp);\n+\t\t}\n \t} else {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Missing x position\"");\n \t\tRETURN_FALSE;\n \t}\n \n \tif (zend_hash_find(HASH_OF(z_rect), \""y\"", sizeof(\""x\""), (void **)&tmp) != FAILURE) {\n-\t\trect.y = Z_LVAL_PP(tmp);\n+\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\tzval lval;\n+\t\t\tlval = **tmp;\n+\t\t\tzval_copy_ctor(&lval);\n+\t\t\tconvert_to_long(&lval);\n+\t\t\trect.y = Z_LVAL(lval);\n+\t\t} else {\n+\t\t\trect.y = Z_LVAL_PP(tmp);\n+\t\t}\n \t} else {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Missing y position\"");\n \t\tRETURN_FALSE;\n \t}\n \n \tif (zend_hash_find(HASH_OF(z_rect), \""width\"", sizeof(\""width\""), (void **)&tmp) != FAILURE) {\n-\t\trect.width = Z_LVAL_PP(tmp);\n+\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\tzval lval;\n+\t\t\tlval = **tmp;\n+\t\t\tzval_copy_ctor(&lval);\n+\t\t\tconvert_to_long(&lval);\n+\t\t\trect.width = Z_LVAL(lval);\n+\t\t} else {\n+\t\t\trect.width = Z_LVAL_PP(tmp);\n+\t\t}\n \t} else {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Missing width\"");\n \t\tRETURN_FALSE;\n \t}\n \n \tif (zend_hash_find(HASH_OF(z_rect), \""height\"", sizeof(\""height\""), (void **)&tmp) != FAILURE) {\n-\t\trect.height = Z_LVAL_PP(tmp);\n+\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\tzval lval;\n+\t\t\tlval = **tmp;\n+\t\t\tzval_copy_ctor(&lval);\n+\t\t\tconvert_to_long(&lval);\n+\t\t\trect.height = Z_LVAL(lval);\n+\t\t} else {\n+\t\t\trect.height = Z_LVAL_PP(tmp);\n+\t\t}\n \t} else {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Missing height\"");\n \t\tRETURN_FALSE;\n@@ -5124,8 +5180,13 @@ PHP_FUNCTION(imageaffine)\n \t\t\t\t\taffine[i] = Z_DVAL_PP(zval_affine_elem);\n \t\t\t\t\tbreak;\n \t\t\t\tcase IS_STRING:\n-\t\t\t\t\tconvert_to_double_ex(zval_affine_elem);\n-\t\t\t\t\taffine[i] = Z_DVAL_PP(zval_affine_elem);\n+\t\t\t\t\t{\n+\t\t\t\t\t\tzval dval;\n+\t\t\t\t\t\tdval = **zval_affine_elem;\n+\t\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\t\taffine[i] = Z_DVAL(dval);\n+\t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Invalid type for element %i\"", i);\n@@ -5136,32 +5197,60 @@ PHP_FUNCTION(imageaffine)\n \n \tif (z_rect != NULL) {\n \t\tif (zend_hash_find(HASH_OF(z_rect), \""x\"", sizeof(\""x\""), (void **)&tmp) != FAILURE) {\n-\t\t\tconvert_to_long_ex(tmp);\n-\t\t\trect.x = Z_LVAL_PP(tmp);\n+\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **tmp;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\trect.x = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\trect.x = Z_LVAL_PP(tmp);\n+\t\t\t}\n \t\t} else {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Missing x position\"");\n \t\t\tRETURN_FALSE;\n \t\t}\n \n \t\tif (zend_hash_find(HASH_OF(z_rect), \""y\"", sizeof(\""x\""), (void **)&tmp) != FAILURE) {\n-\t\t\tconvert_to_long_ex(tmp);\n-\t\t\trect.y = Z_LVAL_PP(tmp);\n+\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **tmp;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\trect.y = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\trect.y = Z_LVAL_PP(tmp);\n+\t\t\t}\n \t\t} else {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Missing y position\"");\n \t\t\tRETURN_FALSE;\n \t\t}\n \n \t\tif (zend_hash_find(HASH_OF(z_rect), \""width\"", sizeof(\""width\""), (void **)&tmp) != FAILURE) {\n-\t\t\tconvert_to_long_ex(tmp);\n-\t\t\trect.width = Z_LVAL_PP(tmp);\n+\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **tmp;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\trect.width = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\trect.width = Z_LVAL_PP(tmp);\n+\t\t\t}\n \t\t} else {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Missing width\"");\n \t\t\tRETURN_FALSE;\n \t\t}\n \n \t\tif (zend_hash_find(HASH_OF(z_rect), \""height\"", sizeof(\""height\""), (void **)&tmp) != FAILURE) {\n-\t\t\tconvert_to_long_ex(tmp);\n-\t\t\trect.height = Z_LVAL_PP(tmp);\n+\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **tmp;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\trect.height = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\trect.height = Z_LVAL_PP(tmp);\n+\t\t\t}\n \t\t} else {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Missing height\"");\n \t\t\tRETURN_FALSE;\n@@ -5211,16 +5300,30 @@ PHP_FUNCTION(imageaffinematrixget)\n \t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Array expected as options\"");\n \t\t\t}\n \t\t\tif (zend_hash_find(HASH_OF(options), \""x\"", sizeof(\""x\""), (void **)&tmp) != FAILURE) {\n-\t\t\t\tconvert_to_double_ex(tmp);\n-\t\t\t\tx = Z_DVAL_PP(tmp);\n+\t\t\t\tif (Z_TYPE_PP(tmp) != IS_DOUBLE) {\n+\t\t\t\t\tzval dval;\n+\t\t\t\t\tdval = **tmp;\n+\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\tx = Z_DVAL(dval);\n+\t\t\t\t} else {\n+\t\t\t\t\tx = Z_DVAL_PP(tmp);\n+\t\t\t\t}\n \t\t\t} else {\n \t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Missing x position\"");\n \t\t\t\tRETURN_FALSE;\n \t\t\t}\n \n \t\t\tif (zend_hash_find(HASH_OF(options), \""y\"", sizeof(\""y\""), (void **)&tmp) != FAILURE) {\n-\t\t\t\tconvert_to_double_ex(tmp);\n-\t\t\t\ty = Z_DVAL_PP(tmp);\n+\t\t\t\tif (Z_TYPE_PP(tmp) != IS_DOUBLE) {\n+\t\t\t\t\tzval dval;\n+\t\t\t\t\tdval = **tmp;\n+\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\ty = Z_DVAL(dval);\n+\t\t\t\t} else {\n+\t\t\t\t\ty = Z_DVAL_PP(tmp);\n+\t\t\t\t}\n \t\t\t} else {\n \t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Missing y position\"");\n \t\t\t\tRETURN_FALSE;\n@@ -5300,8 +5403,13 @@ PHP_FUNCTION(imageaffinematrixconcat)\n \t\t\t\t\tm1[i] = Z_DVAL_PP(tmp);\n \t\t\t\t\tbreak;\n \t\t\t\tcase IS_STRING:\n-\t\t\t\t\tconvert_to_double_ex(tmp);\n-\t\t\t\t\tm1[i] = Z_DVAL_PP(tmp);\n+\t\t\t\t\t{\n+\t\t\t\t\t\tzval dval;\n+\t\t\t\t\t\tdval = **tmp;\n+\t\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\t\tm1[i] = Z_DVAL(dval);\n+\t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Invalid type for element %i\"", i);\n@@ -5317,8 +5425,13 @@ PHP_FUNCTION(imageaffinematrixconcat)\n \t\t\t\t\tm2[i] = Z_DVAL_PP(tmp);\n \t\t\t\t\tbreak;\n \t\t\t\tcase IS_STRING:\n-\t\t\t\t\tconvert_to_double_ex(tmp);\n-\t\t\t\t\tm2[i] = Z_DVAL_PP(tmp);\n+\t\t\t\t\t{\n+\t\t\t\t\t\tzval dval;\n+\t\t\t\t\t\tdval = **tmp;\n+\t\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\t\tm2[i] = Z_DVAL(dval);\n+\t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Invalid type for element %i\"", i);""}<_**next**_>{""sha"": ""f881494716402338847ab4ff23619f4f633fc384"", ""filename"": ""ext/gd/tests/bug66356.phpt"", ""status"": ""added"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/php/php-src/blob/2938329ce19cb8c4197dec146c3ec887c6f61d01/ext/gd/tests/bug66356.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/2938329ce19cb8c4197dec146c3ec887c6f61d01/ext/gd/tests/bug66356.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/tests/bug66356.phpt?ref=2938329ce19cb8c4197dec146c3ec887c6f61d01"", ""patch"": ""@@ -0,0 +1,22 @@\n+--TEST--\n+Bug #66356 (Heap Overflow Vulnerability in imagecrop())\n+--SKIPIF--\n+<?php\n+\tif(!extension_loaded('gd')){ die('skip gd extension not available'); }\n+?>\n+--FILE--\n+<?php\n+$img = imagecreatetruecolor(10, 10);\n+$img = imagecrop($img, array(\""x\"" => \""a\"", \""y\"" => 0, \""width\"" => 10, \""height\"" => 10));\n+$arr = array(\""x\"" => \""a\"", \""y\"" => \""12b\"", \""width\"" => 10, \""height\"" => 10);\n+$img = imagecrop($img, $arr);\n+print_r($arr);\n+?>\n+--EXPECTF--\n+Array\n+(\n+    [x] => a\n+    [y] => 12b\n+    [width] => 10\n+    [height] => 10\n+)""}<_**next**_>{""sha"": ""d9ea4aab3cd61f5dbff50d8113875e70834728b3"", ""filename"": ""main/php_version.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/php/php-src/blob/2938329ce19cb8c4197dec146c3ec887c6f61d01/main/php_version.h"", ""raw_url"": ""https://github.com/php/php-src/raw/2938329ce19cb8c4197dec146c3ec887c6f61d01/main/php_version.h"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/main/php_version.h?ref=2938329ce19cb8c4197dec146c3ec887c6f61d01"", ""patch"": ""@@ -2,7 +2,7 @@\n /* edit configure.in to change version number */\n #define PHP_MAJOR_VERSION 5\n #define PHP_MINOR_VERSION 5\n-#define PHP_RELEASE_VERSION 8\n+#define PHP_RELEASE_VERSION 5\n #define PHP_EXTRA_VERSION \""-dev\""\n-#define PHP_VERSION \""5.5.8-dev\""\n-#define PHP_VERSION_ID 50508\n+#define PHP_VERSION \""5.5.5-dev\""\n+#define PHP_VERSION_ID 50505""}",					SEPARATE_ZVAL(var2);/~/					convert_to_double(*var2);/~/					matrix[i][j] = (float)Z_DVAL_PP(var2);,"30,31,32","PHP_FUNCTION(imageconvolution)
{
	zval *SIM, *hash_matrix;
	zval **var = NULL, **var2 = NULL;
	gdImagePtr im_src = NULL;
	double div, offset;
	int nelem, i, j, res;
	float matrix[3][3] = {{0,0,0}, {0,0,0}, {0,0,0}};

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""radd"", &SIM, &hash_matrix, &div, &offset) == FAILURE) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, ""Image"", le_gd);

	nelem = zend_hash_num_elements(Z_ARRVAL_P(hash_matrix));
	if (nelem != 3) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have 3x3 array"");
		RETURN_FALSE;
	}

	for (i=0; i<3; i++) {
		if (zend_hash_index_find(Z_ARRVAL_P(hash_matrix), (i), (void **) &var) == SUCCESS && Z_TYPE_PP(var) == IS_ARRAY) {
			if (Z_TYPE_PP(var) != IS_ARRAY || zend_hash_num_elements(Z_ARRVAL_PP(var)) != 3 ) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have 3x3 array"");
				RETURN_FALSE;
			}
 
 			for (j=0; j<3; j++) {
 				if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {
					if (Z_TYPE_PP(var2) != IS_DOUBLE) {
						zval dval;
						dval = **var;
						zval_copy_ctor(&dval);
						convert_to_double(&dval);
						matrix[i][j] = (float)Z_DVAL(dval);
					} else {
						matrix[i][j] = (float)Z_DVAL_PP(var2);
					}
 				} else {
 					php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have a 3x3 matrix"");
 					RETURN_FALSE;
				}
			}
		}
	}
	res = gdImageConvolution(im_src, matrix, (float)div, (float)offset);

	if (res) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}
}
","PHP_FUNCTION(imageconvolution)
{
	zval *SIM, *hash_matrix;
	zval **var = NULL, **var2 = NULL;
	gdImagePtr im_src = NULL;
	double div, offset;
	int nelem, i, j, res;
	float matrix[3][3] = {{0,0,0}, {0,0,0}, {0,0,0}};

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""radd"", &SIM, &hash_matrix, &div, &offset) == FAILURE) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, ""Image"", le_gd);

	nelem = zend_hash_num_elements(Z_ARRVAL_P(hash_matrix));
	if (nelem != 3) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have 3x3 array"");
		RETURN_FALSE;
	}

	for (i=0; i<3; i++) {
		if (zend_hash_index_find(Z_ARRVAL_P(hash_matrix), (i), (void **) &var) == SUCCESS && Z_TYPE_PP(var) == IS_ARRAY) {
			if (Z_TYPE_PP(var) != IS_ARRAY || zend_hash_num_elements(Z_ARRVAL_PP(var)) != 3 ) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have 3x3 array"");
				RETURN_FALSE;
			}
 
 			for (j=0; j<3; j++) {
 				if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {
					SEPARATE_ZVAL(var2);
					convert_to_double(*var2);
					matrix[i][j] = (float)Z_DVAL_PP(var2);
 				} else {
 					php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have a 3x3 matrix"");
 					RETURN_FALSE;
				}
			}
		}
	}
	res = gdImageConvolution(im_src, matrix, (float)div, (float)offset);

	if (res) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}
}
",179598.0,C,"					if (Z_TYPE_PP(var2) != IS_DOUBLE) {
						zval dval;
						dval = **var;
						zval_copy_ctor(&dval);
						convert_to_double(&dval);
						matrix[i][j] = (float)Z_DVAL(dval);
					} else {
						matrix[i][j] = (float)Z_DVAL_PP(var2);
					}
","					SEPARATE_ZVAL(var2);
					convert_to_double(*var2);
					matrix[i][j] = (float)Z_DVAL_PP(var2);
",,"@@ -1538,9 +1538,15 @@ PHP_FUNCTION(imagesetstyle)
 			break;
 		}
 
-		convert_to_long_ex(item);
-
-		stylearr[index++] = Z_LVAL_PP(item);
+		if (Z_TYPE_PP(item) != IS_LONG) {
+			zval lval;
+			lval = **item;
+			zval_copy_ctor(&lval);
+			convert_to_long(&lval);
+			stylearr[index++] = Z_LVAL(lval);
+		} else {
+			stylearr[index++] = Z_LVAL_PP(item);
+		}
 	}
 
 	gdImageSetStyle(im, stylearr, index);
@@ -3346,14 +3352,26 @@ static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)
 
 	for (i = 0; i < npoints; i++) {
 		if (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {
-			SEPARATE_ZVAL((var));
-			convert_to_long(*var);
-			points[i].x = Z_LVAL_PP(var);
+			if (Z_TYPE_PP(var) != IS_LONG) {
+				zval lval;
+				lval = **var;
+				zval_copy_ctor(&lval);
+				convert_to_long(&lval);
+				points[i].x = Z_LVAL(lval);
+			} else {
+				points[i].x = Z_LVAL_PP(var);
+			}
 		}
 		if (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {
-			SEPARATE_ZVAL(var);
-			convert_to_long(*var);
-			points[i].y = Z_LVAL_PP(var);
+			if (Z_TYPE_PP(var) != IS_LONG) {
+				zval lval;
+				lval = **var;
+				zval_copy_ctor(&lval);
+				convert_to_long(&lval);
+				points[i].y = Z_LVAL(lval);
+			} else {
+				points[i].y = Z_LVAL_PP(var);
+			}
 		}
 	}
 
@@ -4859,9 +4877,15 @@ PHP_FUNCTION(imageconvolution)
 
 			for (j=0; j<3; j++) {
 				if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {
-					SEPARATE_ZVAL(var2);
-					convert_to_double(*var2);
-					matrix[i][j] = (float)Z_DVAL_PP(var2);
+					if (Z_TYPE_PP(var2) != IS_DOUBLE) {
+						zval dval;
+						dval = **var;
+						zval_copy_ctor(&dval);
+						convert_to_double(&dval);
+						matrix[i][j] = (float)Z_DVAL(dval);
+					} else {
+						matrix[i][j] = (float)Z_DVAL_PP(var2);
+					}
 				} else {
 					php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have a 3x3 matrix"");
 					RETURN_FALSE;
@@ -4954,28 +4978,60 @@ PHP_FUNCTION(imagecrop)
 	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);
 
 	if (zend_hash_find(HASH_OF(z_rect), ""x"", sizeof(""x""), (void **)&tmp) != FAILURE) {
-		rect.x = Z_LVAL_PP(tmp);
+		if (Z_TYPE_PP(tmp) != IS_LONG) {
+			zval lval;
+			lval = **tmp;
+			zval_copy_ctor(&lval);
+			convert_to_long(&lval);
+			rect.x = Z_LVAL(lval);
+		} else {
+			rect.x = Z_LVAL_PP(tmp);
+		}
 	} else {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing x position"");
 		RETURN_FALSE;
 	}
 
 	if (zend_hash_find(HASH_OF(z_rect), ""y"", sizeof(""x""), (void **)&tmp) != FAILURE) {
-		rect.y = Z_LVAL_PP(tmp);
+		if (Z_TYPE_PP(tmp) != IS_LONG) {
+			zval lval;
+			lval = **tmp;
+			zval_copy_ctor(&lval);
+			convert_to_long(&lval);
+			rect.y = Z_LVAL(lval);
+		} else {
+			rect.y = Z_LVAL_PP(tmp);
+		}
 	} else {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing y position"");
 		RETURN_FALSE;
 	}
 
 	if (zend_hash_find(HASH_OF(z_rect), ""width"", sizeof(""width""), (void **)&tmp) != FAILURE) {
-		rect.width = Z_LVAL_PP(tmp);
+		if (Z_TYPE_PP(tmp) != IS_LONG) {
+			zval lval;
+			lval = **tmp;
+			zval_copy_ctor(&lval);
+			convert_to_long(&lval);
+			rect.width = Z_LVAL(lval);
+		} else {
+			rect.width = Z_LVAL_PP(tmp);
+		}
 	} else {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing width"");
 		RETURN_FALSE;
 	}
 
 	if (zend_hash_find(HASH_OF(z_rect), ""height"", sizeof(""height""), (void **)&tmp) != FAILURE) {
-		rect.height = Z_LVAL_PP(tmp);
+		if (Z_TYPE_PP(tmp) != IS_LONG) {
+			zval lval;
+			lval = **tmp;
+			zval_copy_ctor(&lval);
+			convert_to_long(&lval);
+			rect.height = Z_LVAL(lval);
+		} else {
+			rect.height = Z_LVAL_PP(tmp);
+		}
 	} else {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing height"");
 		RETURN_FALSE;
@@ -5124,8 +5180,13 @@ PHP_FUNCTION(imageaffine)
 					affine[i] = Z_DVAL_PP(zval_affine_elem);
 					break;
 				case IS_STRING:
-					convert_to_double_ex(zval_affine_elem);
-					affine[i] = Z_DVAL_PP(zval_affine_elem);
+					{
+						zval dval;
+						dval = **zval_affine_elem;
+						zval_copy_ctor(&dval);
+						convert_to_double(&dval);
+						affine[i] = Z_DVAL(dval);
+					}
 					break;
 				default:
 					php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid type for element %i"", i);
@@ -5136,32 +5197,60 @@ PHP_FUNCTION(imageaffine)
 
 	if (z_rect != NULL) {
 		if (zend_hash_find(HASH_OF(z_rect), ""x"", sizeof(""x""), (void **)&tmp) != FAILURE) {
-			convert_to_long_ex(tmp);
-			rect.x = Z_LVAL_PP(tmp);
+			if (Z_TYPE_PP(tmp) != IS_LONG) {
+				zval lval;
+				lval = **tmp;
+				zval_copy_ctor(&lval);
+				convert_to_long(&lval);
+				rect.x = Z_LVAL(lval);
+			} else {
+				rect.x = Z_LVAL_PP(tmp);
+			}
 		} else {
 			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing x position"");
 			RETURN_FALSE;
 		}
 
 		if (zend_hash_find(HASH_OF(z_rect), ""y"", sizeof(""x""), (void **)&tmp) != FAILURE) {
-			convert_to_long_ex(tmp);
-			rect.y = Z_LVAL_PP(tmp);
+			if (Z_TYPE_PP(tmp) != IS_LONG) {
+				zval lval;
+				lval = **tmp;
+				zval_copy_ctor(&lval);
+				convert_to_long(&lval);
+				rect.y = Z_LVAL(lval);
+			} else {
+				rect.y = Z_LVAL_PP(tmp);
+			}
 		} else {
 			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing y position"");
 			RETURN_FALSE;
 		}
 
 		if (zend_hash_find(HASH_OF(z_rect), ""width"", sizeof(""width""), (void **)&tmp) != FAILURE) {
-			convert_to_long_ex(tmp);
-			rect.width = Z_LVAL_PP(tmp);
+			if (Z_TYPE_PP(tmp) != IS_LONG) {
+				zval lval;
+				lval = **tmp;
+				zval_copy_ctor(&lval);
+				convert_to_long(&lval);
+				rect.width = Z_LVAL(lval);
+			} else {
+				rect.width = Z_LVAL_PP(tmp);
+			}
 		} else {
 			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing width"");
 			RETURN_FALSE;
 		}
 
 		if (zend_hash_find(HASH_OF(z_rect), ""height"", sizeof(""height""), (void **)&tmp) != FAILURE) {
-			convert_to_long_ex(tmp);
-			rect.height = Z_LVAL_PP(tmp);
+			if (Z_TYPE_PP(tmp) != IS_LONG) {
+				zval lval;
+				lval = **tmp;
+				zval_copy_ctor(&lval);
+				convert_to_long(&lval);
+				rect.height = Z_LVAL(lval);
+			} else {
+				rect.height = Z_LVAL_PP(tmp);
+			}
 		} else {
 			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing height"");
 			RETURN_FALSE;
@@ -5211,16 +5300,30 @@ PHP_FUNCTION(imageaffinematrixget)
 				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Array expected as options"");
 			}
 			if (zend_hash_find(HASH_OF(options), ""x"", sizeof(""x""), (void **)&tmp) != FAILURE) {
-				convert_to_double_ex(tmp);
-				x = Z_DVAL_PP(tmp);
+				if (Z_TYPE_PP(tmp) != IS_DOUBLE) {
+					zval dval;
+					dval = **tmp;
+					zval_copy_ctor(&dval);
+					convert_to_double(&dval);
+					x = Z_DVAL(dval);
+				} else {
+					x = Z_DVAL_PP(tmp);
+				}
 			} else {
 				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing x position"");
 				RETURN_FALSE;
 			}
 
 			if (zend_hash_find(HASH_OF(options), ""y"", sizeof(""y""), (void **)&tmp) != FAILURE) {
-				convert_to_double_ex(tmp);
-				y = Z_DVAL_PP(tmp);
+				if (Z_TYPE_PP(tmp) != IS_DOUBLE) {
+					zval dval;
+					dval = **tmp;
+					zval_copy_ctor(&dval);
+					convert_to_double(&dval);
+					y = Z_DVAL(dval);
+				} else {
+					y = Z_DVAL_PP(tmp);
+				}
 			} else {
 				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing y position"");
 				RETURN_FALSE;
@@ -5300,8 +5403,13 @@ PHP_FUNCTION(imageaffinematrixconcat)
 					m1[i] = Z_DVAL_PP(tmp);
 					break;
 				case IS_STRING:
-					convert_to_double_ex(tmp);
-					m1[i] = Z_DVAL_PP(tmp);
+					{
+						zval dval;
+						dval = **tmp;
+						zval_copy_ctor(&dval);
+						convert_to_double(&dval);
+						m1[i] = Z_DVAL(dval);
+					}
 					break;
 				default:
 					php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid type for element %i"", i);
@@ -5317,8 +5425,13 @@ PHP_FUNCTION(imageaffinematrixconcat)
 					m2[i] = Z_DVAL_PP(tmp);
 					break;
 				case IS_STRING:
-					convert_to_double_ex(tmp);
-					m2[i] = Z_DVAL_PP(tmp);
+					{
+						zval dval;
+						dval = **tmp;
+						zval_copy_ctor(&dval);
+						convert_to_double(&dval);
+						m2[i] = Z_DVAL(dval);
+					}
 					break;
 				default:
 					php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid type for element %i"", i);","PHP_FUNCTION(imageconvolution)
{
zval *SIM, *hash_matrix;
zval **var = NULL, **var2 = NULL;
gdImagePtr im_src = NULL;
double div, offset;
int nelem, i, j, res;
float matrix[3][3] = {{0,0,0}, {0,0,0}, {0,0,0}};

if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""radd"", &SIM, &hash_matrix, &div, &offset) == FAILURE) {
RETURN_FALSE;
}

ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, ""Image"", le_gd);

nelem = zend_hash_num_elements(Z_ARRVAL_P(hash_matrix));
if (nelem != 3) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have 3x3 array"");
RETURN_FALSE;
}

for (i=0; i<3; i++) {
if (zend_hash_index_find(Z_ARRVAL_P(hash_matrix), (i), (void **) &var) == SUCCESS && Z_TYPE_PP(var) == IS_ARRAY) {
if (Z_TYPE_PP(var) != IS_ARRAY || zend_hash_num_elements(Z_ARRVAL_PP(var)) != 3 ) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have 3x3 array"");
RETURN_FALSE;
}

for (j=0; j<3; j++) {
if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {
					SEPARATE_ZVAL(var2);
					convert_to_double(*var2);
					matrix[i][j] = (float)Z_DVAL_PP(var2);
} else {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have a 3x3 matrix"");
RETURN_FALSE;
}
}
}
}
res = gdImageConvolution(im_src, matrix, (float)div, (float)offset);

if (res) {
RETURN_TRUE;
} else {
RETURN_FALSE;
}
}
",php-src,2938329ce19cb8c4197dec146c3ec887c6f61d01,6414fe283e3931d87416a155f4cfbaaf5ffca1ad,1.0,"PHP_FUNCTION(imageconvolution)
{
	zval *SIM, *hash_matrix;
	zval **var = NULL, **var2 = NULL;
	gdImagePtr im_src = NULL;
	double div, offset;
	int nelem, i, j, res;
	float matrix[3][3] = {{0,0,0}, {0,0,0}, {0,0,0}};

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""radd"", &SIM, &hash_matrix, &div, &offset) == FAILURE) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, ""Image"", le_gd);

	nelem = zend_hash_num_elements(Z_ARRVAL_P(hash_matrix));
	if (nelem != 3) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have 3x3 array"");
		RETURN_FALSE;
	}

	for (i=0; i<3; i++) {
		if (zend_hash_index_find(Z_ARRVAL_P(hash_matrix), (i), (void **) &var) == SUCCESS && Z_TYPE_PP(var) == IS_ARRAY) {
			if (Z_TYPE_PP(var) != IS_ARRAY || zend_hash_num_elements(Z_ARRVAL_PP(var)) != 3 ) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have 3x3 array"");
				RETURN_FALSE;
			}
 
 			for (j=0; j<3; j++) {
 				if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {
//flaw_line_below:
					SEPARATE_ZVAL(var2);
//flaw_line_below:
					convert_to_double(*var2);
//flaw_line_below:
					matrix[i][j] = (float)Z_DVAL_PP(var2);
//fix_flaw_line_below:
//					if (Z_TYPE_PP(var2) != IS_DOUBLE) {
//fix_flaw_line_below:
//						zval dval;
//fix_flaw_line_below:
//						dval = **var;
//fix_flaw_line_below:
//						zval_copy_ctor(&dval);
//fix_flaw_line_below:
//						convert_to_double(&dval);
//fix_flaw_line_below:
//						matrix[i][j] = (float)Z_DVAL(dval);
//fix_flaw_line_below:
//					} else {
//fix_flaw_line_below:
//						matrix[i][j] = (float)Z_DVAL_PP(var2);
//fix_flaw_line_below:
//					}
 				} else {
 					php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have a 3x3 matrix"");
 					RETURN_FALSE;
				}
			}
		}
	}
	res = gdImageConvolution(im_src, matrix, (float)div, (float)offset);

	if (res) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}
}
"
108,None,Remote,Not required,Partial,CVE-2011-2839,https://www.cvedetails.com/cve/CVE-2011-2839/,CWE-20,Low,Partial,Partial,,2011-08-29,7.5,"The PDF implementation in Google Chrome before 13.0.782.215 on Linux does not properly use the memset library function, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.",2017-09-18,DoS ,8.0,https://github.com/chromium/chromium/commit/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7,c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7,"Extend TTS extension API to support richer events returned from the engine
to the client. Previously we just had a completed event; this adds start,
word boundary, sentence boundary, and marker boundary. In addition,
interrupted and canceled, which were previously errors, now become events.
Mac and Windows implementations extended to support as many of these events
as possible.

BUG=67713
BUG=70198
BUG=75106
BUG=83404

TEST=Updates all TTS API tests to be event-based, and adds new tests.
Review URL: http://codereview.chromium.org/6792014

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@91665 0039d316-1c4b-4281-b951-d872f2087c98",16.0,chrome/browser/extensions/extension_tts_api.cc,"{""sha"": ""0269c5819c896b125cace58768cccca4edeafbdb"", ""filename"": ""base/mac/cocoa_protocols.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/base/mac/cocoa_protocols.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/base/mac/cocoa_protocols.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/mac/cocoa_protocols.h?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,4 +1,4 @@\n-// Copyright (c) 2009 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n@@ -34,6 +34,7 @@ DEFINE_EMPTY_PROTOCOL(NSMenuDelegate)\n DEFINE_EMPTY_PROTOCOL(NSOpenSavePanelDelegate)\n DEFINE_EMPTY_PROTOCOL(NSOutlineViewDataSource)\n DEFINE_EMPTY_PROTOCOL(NSOutlineViewDelegate)\n+DEFINE_EMPTY_PROTOCOL(NSSpeechSynthesizerDelegate)\n DEFINE_EMPTY_PROTOCOL(NSTableViewDataSource)\n DEFINE_EMPTY_PROTOCOL(NSTableViewDelegate)\n DEFINE_EMPTY_PROTOCOL(NSTextFieldDelegate)""}<_**next**_>{""sha"": ""5baa99963ef0a538013524eb9d25a4de589ceb51"", ""filename"": ""chrome/browser/chromeos/cros/cros_mock.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 2, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/chromeos/cros/cros_mock.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/chromeos/cros/cros_mock.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chromeos/cros/cros_mock.cc?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -287,15 +287,21 @@ void CrosMock::SetSpeechSynthesisLibraryExpectations() {\n   EXPECT_CALL(*mock_speech_synthesis_library_, StopSpeaking())\n       .WillOnce(Return(true))\n       .RetiresOnSaturation();\n+  EXPECT_CALL(*mock_speech_synthesis_library_, SetSpeakProperties(_))\n+      .WillOnce(Return(true))\n+      .RetiresOnSaturation();\n   EXPECT_CALL(*mock_speech_synthesis_library_, Speak(_))\n       .WillOnce(Return(true))\n       .RetiresOnSaturation();\n   EXPECT_CALL(*mock_speech_synthesis_library_, IsSpeaking())\n-      .Times(AnyNumber())\n-      .WillRepeatedly(Return(true));\n+      .WillOnce(Return(true))\n+      .RetiresOnSaturation();\n   EXPECT_CALL(*mock_speech_synthesis_library_, StopSpeaking())\n       .WillOnce(Return(true))\n       .RetiresOnSaturation();\n+  EXPECT_CALL(*mock_speech_synthesis_library_, SetSpeakProperties(_))\n+      .WillOnce(Return(true))\n+      .RetiresOnSaturation();\n   EXPECT_CALL(*mock_speech_synthesis_library_, Speak(_))\n       .WillOnce(Return(true))\n       .RetiresOnSaturation();""}<_**next**_>{""sha"": ""15fa40e2c6c159ccdb9ba0184c890024e1e1df8b"", ""filename"": ""chrome/browser/extensions/extension_function_dispatcher.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_function_dispatcher.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_function_dispatcher.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_function_dispatcher.cc?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -40,6 +40,7 @@\n #include \""chrome/browser/extensions/extension_tabs_module.h\""\n #include \""chrome/browser/extensions/extension_test_api.h\""\n #include \""chrome/browser/extensions/extension_tts_api.h\""\n+#include \""chrome/browser/extensions/extension_tts_engine_api.h\""\n #include \""chrome/browser/extensions/extension_web_socket_proxy_private_api.h\""\n #include \""chrome/browser/extensions/extension_web_ui.h\""\n #include \""chrome/browser/extensions/extension_webrequest_api.h\""\n@@ -249,10 +250,11 @@ void FactoryRegistry::ResetFunctions() {\n   RegisterFunction<SetAccessibilityEnabledFunction>();\n \n   // Text-to-speech.\n+  RegisterFunction<ExtensionTtsEngineSendTtsEventFunction>();\n+  RegisterFunction<ExtensionTtsGetVoicesFunction>();\n+  RegisterFunction<ExtensionTtsIsSpeakingFunction>();\n   RegisterFunction<ExtensionTtsSpeakFunction>();\n   RegisterFunction<ExtensionTtsStopSpeakingFunction>();\n-  RegisterFunction<ExtensionTtsIsSpeakingFunction>();\n-  RegisterFunction<ExtensionTtsSpeakCompletedFunction>();\n \n   // Context Menus.\n   RegisterFunction<CreateContextMenuFunction>();""}<_**next**_>{""sha"": ""916665adfddbbafa80461f146304fb0669dcce46"", ""filename"": ""chrome/browser/extensions/extension_tts_api.cc"", ""status"": ""modified"", ""additions"": 121, ""deletions"": 335, ""changes"": 456, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_api.cc?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -2,366 +2,159 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n+#include \""chrome/browser/extensions/extension_tts_api.h\""\n+\n #include <string>\n-#include <vector>\n \n-#include \""base/float_util.h\""\n-#include \""base/json/json_writer.h\""\n-#include \""base/message_loop.h\""\n #include \""base/values.h\""\n-#include \""chrome/browser/extensions/extension_event_router.h\""\n-#include \""chrome/browser/extensions/extension_service.h\""\n-#include \""chrome/browser/extensions/extension_tts_api.h\""\n+#include \""chrome/browser/extensions/extension_tts_api_constants.h\""\n+#include \""chrome/browser/extensions/extension_tts_api_controller.h\""\n #include \""chrome/browser/profiles/profile.h\""\n+#include \""ui/base/l10n/l10n_util.h\""\n \n-namespace util = extension_tts_api_util;\n-\n-namespace {\n-const char kSpeechInterruptedError[] = \""Utterance interrupted.\"";\n-const char kSpeechRemovedFromQueueError[] = \""Utterance removed from queue.\"";\n-const int kSpeechCheckDelayIntervalMs = 100;\n-};\n-\n-namespace events {\n-const char kOnSpeak[] = \""experimental.tts.onSpeak\"";\n-const char kOnStop[] = \""experimental.tts.onStop\"";\n-};  // namespace events\n-\n-//\n-// ExtensionTtsPlatformImpl\n-//\n+namespace constants = extension_tts_api_constants;\n \n-std::string ExtensionTtsPlatformImpl::error() {\n-  return error_;\n-}\n-\n-void ExtensionTtsPlatformImpl::clear_error() {\n-  error_ = std::string();\n-}\n-\n-void ExtensionTtsPlatformImpl::set_error(const std::string& error) {\n-  error_ = error;\n-}\n-\n-//\n-// Utterance\n-//\n-\n-// static\n-int Utterance::next_utterance_id_ = 0;\n-\n-Utterance::Utterance(Profile* profile,\n-                     const std::string& text,\n-                     DictionaryValue* options,\n-                     Task* completion_task)\n-    : profile_(profile),\n-      id_(next_utterance_id_++),\n-      text_(text),\n-      rate_(-1.0),\n-      pitch_(-1.0),\n-      volume_(-1.0),\n-      can_enqueue_(false),\n-      completion_task_(completion_task) {\n-  if (!options) {\n-    // Use all default options.\n-    options_.reset(new DictionaryValue());\n-    return;\n+bool ExtensionTtsSpeakFunction::RunImpl() {\n+  std::string text;\n+  EXTENSION_FUNCTION_VALIDATE(args_->GetString(0, &text));\n+  if (text.size() > 32768) {\n+    error_ = constants::kErrorUtteranceTooLong;\n+    return false;\n   }\n \n-  options_.reset(options->DeepCopy());\n-\n-  if (options->HasKey(util::kVoiceNameKey))\n-    options->GetString(util::kVoiceNameKey, &voice_name_);\n-\n-  if (options->HasKey(util::kLocaleKey))\n-    options->GetString(util::kLocaleKey, &locale_);\n-\n-  if (options->HasKey(util::kGenderKey))\n-    options->GetString(util::kGenderKey, &gender_);\n-\n-  if (options->GetDouble(util::kRateKey, &rate_)) {\n-    if (!base::IsFinite(rate_) || rate_ < 0.0 || rate_ > 1.0)\n-      rate_ = -1.0;\n+  scoped_ptr<DictionaryValue> options;\n+  if (args_->GetSize() >= 2) {\n+    DictionaryValue* temp_options = NULL;\n+    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &temp_options));\n+    options.reset(temp_options->DeepCopy());\n   }\n \n-  if (options->GetDouble(util::kPitchKey, &pitch_)) {\n-    if (!base::IsFinite(pitch_) || pitch_ < 0.0 || pitch_ > 1.0)\n-      pitch_ = -1.0;\n+  std::string voice_name;\n+  if (options->HasKey(constants::kVoiceNameKey)) {\n+    EXTENSION_FUNCTION_VALIDATE(\n+        options->GetString(constants::kVoiceNameKey, &voice_name));\n   }\n \n-  if (options->GetDouble(util::kVolumeKey, &volume_)) {\n-    if (!base::IsFinite(volume_) || volume_ < 0.0 || volume_ > 1.0)\n-      volume_ = -1.0;\n+  std::string lang;\n+  if (options->HasKey(constants::kLangKey))\n+    EXTENSION_FUNCTION_VALIDATE(options->GetString(constants::kLangKey, &lang));\n+  if (!lang.empty() && !l10n_util::IsValidLocaleSyntax(lang)) {\n+    error_ = constants::kErrorInvalidLang;\n+    return false;\n   }\n \n-  if (options->HasKey(util::kEnqueueKey))\n-    options->GetBoolean(util::kEnqueueKey, &can_enqueue_);\n-}\n-\n-Utterance::~Utterance() {\n-  DCHECK_EQ(completion_task_, static_cast<Task *>(NULL));\n-}\n-\n-void Utterance::FinishAndDestroy() {\n-  completion_task_->Run();\n-  completion_task_ = NULL;\n-  delete this;\n-}\n-\n-//\n-// ExtensionTtsController\n-//\n-\n-// static\n-ExtensionTtsController* ExtensionTtsController::GetInstance() {\n-  return Singleton<ExtensionTtsController>::get();\n-}\n-\n-ExtensionTtsController::ExtensionTtsController()\n-    : ALLOW_THIS_IN_INITIALIZER_LIST(method_factory_(this)),\n-      current_utterance_(NULL),\n-      platform_impl_(NULL) {\n-}\n-\n-ExtensionTtsController::~ExtensionTtsController() {\n-  FinishCurrentUtterance();\n-  ClearUtteranceQueue();\n-}\n-\n-void ExtensionTtsController::SpeakOrEnqueue(Utterance* utterance) {\n-  if (IsSpeaking() && utterance->can_enqueue()) {\n-    utterance_queue_.push(utterance);\n-  } else {\n-    Stop();\n-    SpeakNow(utterance);\n+  std::string gender;\n+  if (options->HasKey(constants::kGenderKey))\n+    EXTENSION_FUNCTION_VALIDATE(\n+        options->GetString(constants::kGenderKey, &gender));\n+  if (!gender.empty() &&\n+      gender != constants::kGenderFemale &&\n+      gender != constants::kGenderMale) {\n+    error_ = constants::kErrorInvalidGender;\n+    return false;\n   }\n-}\n-\n-std::string ExtensionTtsController::GetMatchingExtensionId(\n-    Utterance* utterance) {\n-  ExtensionService* service = utterance->profile()->GetExtensionService();\n-  DCHECK(service);\n-  ExtensionEventRouter* event_router =\n-      utterance->profile()->GetExtensionEventRouter();\n-  DCHECK(event_router);\n \n-  const ExtensionList* extensions = service->extensions();\n-  ExtensionList::const_iterator iter;\n-  for (iter = extensions->begin(); iter != extensions->end(); ++iter) {\n-    const Extension* extension = *iter;\n-\n-    if (!event_router->ExtensionHasEventListener(\n-            extension->id(), events::kOnSpeak) ||\n-        !event_router->ExtensionHasEventListener(\n-            extension->id(), events::kOnStop)) {\n-      continue;\n+  double rate = 1.0;\n+  if (options->HasKey(constants::kRateKey)) {\n+    EXTENSION_FUNCTION_VALIDATE(\n+        options->GetDouble(constants::kRateKey, &rate));\n+    if (rate < 0.1 || rate > 10.0) {\n+      error_ = constants::kErrorInvalidRate;\n+      return false;\n     }\n-\n-    const std::vector<Extension::TtsVoice>& tts_voices =\n-        extension->tts_voices();\n-    for (size_t i = 0; i < tts_voices.size(); ++i) {\n-      const Extension::TtsVoice& voice = tts_voices[i];\n-      if (!voice.voice_name.empty() &&\n-          !utterance->voice_name().empty() &&\n-          voice.voice_name != utterance->voice_name()) {\n-        continue;\n-      }\n-      if (!voice.locale.empty() &&\n-          !utterance->locale().empty() &&\n-          voice.locale != utterance->locale()) {\n-        continue;\n-      }\n-      if (!voice.gender.empty() &&\n-          !utterance->gender().empty() &&\n-          voice.gender != utterance->gender()) {\n-        continue;\n-      }\n-\n-      return extension->id();\n-    }\n-  }\n-\n-  return std::string();\n-}\n-\n-void ExtensionTtsController::SpeakNow(Utterance* utterance) {\n-  std::string extension_id = GetMatchingExtensionId(utterance);\n-  if (!extension_id.empty()) {\n-    current_utterance_ = utterance;\n-    utterance->set_extension_id(extension_id);\n-\n-    ListValue args;\n-    args.Set(0, Value::CreateStringValue(utterance->text()));\n-\n-    // Pass through all options to the speech engine, except for\n-    // \""enqueue\"", which the speech engine doesn't need to handle.\n-    DictionaryValue* options = static_cast<DictionaryValue*>(\n-        utterance->options()->DeepCopy());\n-    if (options->HasKey(util::kEnqueueKey))\n-      options->Remove(util::kEnqueueKey, NULL);\n-\n-    args.Set(1, options);\n-    args.Set(2, Value::CreateIntegerValue(utterance->id()));\n-    std::string json_args;\n-    base::JSONWriter::Write(&args, false, &json_args);\n-\n-    utterance->profile()->GetExtensionEventRouter()->DispatchEventToExtension(\n-        extension_id,\n-        events::kOnSpeak,\n-        json_args,\n-        utterance->profile(),\n-        GURL());\n-\n-    return;\n   }\n \n-  GetPlatformImpl()->clear_error();\n-  bool success = GetPlatformImpl()->Speak(\n-      utterance->text(),\n-      utterance->locale(),\n-      utterance->gender(),\n-      utterance->rate(),\n-      utterance->pitch(),\n-      utterance->volume());\n-  if (!success) {\n-    utterance->set_error(GetPlatformImpl()->error());\n-    utterance->FinishAndDestroy();\n-    return;\n+  double pitch = 1.0;\n+  if (options->HasKey(constants::kPitchKey)) {\n+    EXTENSION_FUNCTION_VALIDATE(\n+        options->GetDouble(constants::kPitchKey, &pitch));\n+    if (pitch < 0.0 || pitch > 2.0) {\n+      error_ = constants::kErrorInvalidPitch;\n+      return false;\n+    }\n   }\n-  current_utterance_ = utterance;\n-\n-  // Check to see if it's still speaking; finish the utterance if not and\n-  // start polling if so. Checking immediately helps to avoid flaky unit\n-  // tests by forcing them to set expectations for IsSpeaking.\n-  CheckSpeechStatus();\n-}\n \n-void ExtensionTtsController::Stop() {\n-  if (current_utterance_ && !current_utterance_->extension_id().empty()) {\n-    current_utterance_->profile()->GetExtensionEventRouter()->\n-        DispatchEventToExtension(\n-            current_utterance_->extension_id(),\n-            events::kOnStop,\n-            \""[]\"",\n-            current_utterance_->profile(),\n-            GURL());\n-  } else {\n-    GetPlatformImpl()->clear_error();\n-    GetPlatformImpl()->StopSpeaking();\n+  double volume = 1.0;\n+  if (options->HasKey(constants::kVolumeKey)) {\n+    EXTENSION_FUNCTION_VALIDATE(\n+        options->GetDouble(constants::kVolumeKey, &volume));\n+    if (volume < 0.0 || volume > 1.0) {\n+      error_ = constants::kErrorInvalidVolume;\n+      return false;\n+    }\n   }\n \n-  if (current_utterance_)\n-    current_utterance_->set_error(kSpeechInterruptedError);\n-  FinishCurrentUtterance();\n-  ClearUtteranceQueue();\n-}\n-\n-void ExtensionTtsController::OnSpeechFinished(\n-    int request_id, const std::string& error_message) {\n-  // We may sometimes receive completion callbacks \""late\"", after we've\n-  // already finished the utterance (for example because another utterance\n-  // interrupted or we got a call to Stop). It's also possible that a buggy\n-  // extension has called this more than once. In either case it's safe to\n-  // just ignore this call.\n-  if (!current_utterance_ || request_id != current_utterance_->id())\n-    return;\n-\n-  current_utterance_->set_error(error_message);\n-  FinishCurrentUtterance();\n-  SpeakNextUtterance();\n-}\n-\n-bool ExtensionTtsController::IsSpeaking() const {\n-  return current_utterance_ != NULL;\n-}\n-\n-void ExtensionTtsController::FinishCurrentUtterance() {\n-  if (current_utterance_) {\n-    current_utterance_->FinishAndDestroy();\n-    current_utterance_ = NULL;\n+  bool can_enqueue = false;\n+  if (options->HasKey(constants::kEnqueueKey)) {\n+    EXTENSION_FUNCTION_VALIDATE(\n+        options->GetBoolean(constants::kEnqueueKey, &can_enqueue));\n   }\n-}\n \n-void ExtensionTtsController::SpeakNextUtterance() {\n-  // Start speaking the next utterance in the queue.  Keep trying in case\n-  // one fails but there are still more in the queue to try.\n-  while (!utterance_queue_.empty() && !current_utterance_) {\n-    Utterance* utterance = utterance_queue_.front();\n-    utterance_queue_.pop();\n-    SpeakNow(utterance);\n-  }\n-}\n-\n-void ExtensionTtsController::ClearUtteranceQueue() {\n-  while (!utterance_queue_.empty()) {\n-    Utterance* utterance = utterance_queue_.front();\n-    utterance_queue_.pop();\n-    utterance->set_error(kSpeechRemovedFromQueueError);\n-    utterance->FinishAndDestroy();\n+  std::set<std::string> required_event_types;\n+  if (options->HasKey(constants::kRequiredEventTypesKey)) {\n+    ListValue* list;\n+    EXTENSION_FUNCTION_VALIDATE(\n+        options->GetList(constants::kRequiredEventTypesKey, &list));\n+    for (size_t i = 0; i < list->GetSize(); i++) {\n+      std::string event_type;\n+      if (!list->GetString(i, &event_type))\n+        required_event_types.insert(event_type);\n+    }\n   }\n-}\n-\n-void ExtensionTtsController::CheckSpeechStatus() {\n-  if (!current_utterance_)\n-    return;\n \n-  if (!current_utterance_->extension_id().empty())\n-    return;\n-\n-  if (GetPlatformImpl()->IsSpeaking() == false) {\n-    FinishCurrentUtterance();\n-    SpeakNextUtterance();\n+  std::set<std::string> desired_event_types;\n+  if (options->HasKey(constants::kDesiredEventTypesKey)) {\n+    ListValue* list;\n+    EXTENSION_FUNCTION_VALIDATE(\n+        options->GetList(constants::kDesiredEventTypesKey, &list));\n+    for (size_t i = 0; i < list->GetSize(); i++) {\n+      std::string event_type;\n+      if (!list->GetString(i, &event_type))\n+        desired_event_types.insert(event_type);\n+    }\n   }\n \n-  // If we're still speaking something (either the prevoius utterance or\n-  // a new utterance), keep calling this method after another delay.\n-  // TODO(dmazzoni): get rid of this as soon as all platform implementations\n-  // provide completion callbacks rather than only supporting polling.\n-  if (current_utterance_ && current_utterance_->extension_id().empty()) {\n-    MessageLoop::current()->PostDelayedTask(\n-        FROM_HERE, method_factory_.NewRunnableMethod(\n-            &ExtensionTtsController::CheckSpeechStatus),\n-        kSpeechCheckDelayIntervalMs);\n+  std::string voice_extension_id;\n+  if (options->HasKey(constants::kExtensionIdKey)) {\n+    EXTENSION_FUNCTION_VALIDATE(\n+        options->GetString(constants::kExtensionIdKey, &voice_extension_id));\n   }\n-}\n-\n-void ExtensionTtsController::SetPlatformImpl(\n-    ExtensionTtsPlatformImpl* platform_impl) {\n-  platform_impl_ = platform_impl;\n-}\n \n-ExtensionTtsPlatformImpl* ExtensionTtsController::GetPlatformImpl() {\n-  if (!platform_impl_)\n-    platform_impl_ = ExtensionTtsPlatformImpl::GetInstance();\n-  return platform_impl_;\n-}\n-\n-//\n-// Extension API functions\n-//\n-\n-bool ExtensionTtsSpeakFunction::RunImpl() {\n-  std::string text;\n-  EXTENSION_FUNCTION_VALIDATE(args_->GetString(0, &text));\n-  DictionaryValue* options = NULL;\n-  if (args_->GetSize() >= 2)\n-    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));\n-  Task* completion_task = NewRunnableMethod(\n-      this, &ExtensionTtsSpeakFunction::SpeechFinished);\n-  utterance_ = new Utterance(profile(), text, options, completion_task);\n-\n-  AddRef();  // Balanced in SpeechFinished().\n-  ExtensionTtsController::GetInstance()->SpeakOrEnqueue(utterance_);\n+  int src_id = -1;\n+  EXTENSION_FUNCTION_VALIDATE(\n+      options->GetInteger(constants::kSrcIdKey, &src_id));\n+\n+  // If we got this far, the arguments were all in the valid format, so\n+  // send the success response to the callback now - this ensures that\n+  // the callback response always arrives before events, which makes\n+  // the behavior more predictable and easier to write unit tests for too.\n+  SendResponse(true);\n+\n+  UtteranceContinuousParameters continuous_params;\n+  continuous_params.rate = rate;\n+  continuous_params.pitch = pitch;\n+  continuous_params.volume = volume;\n+\n+  Utterance* utterance = new Utterance(profile());\n+  utterance->set_text(text);\n+  utterance->set_voice_name(voice_name);\n+  utterance->set_src_extension_id(extension_id());\n+  utterance->set_src_id(src_id);\n+  utterance->set_src_url(source_url());\n+  utterance->set_lang(lang);\n+  utterance->set_gender(gender);\n+  utterance->set_continuous_parameters(continuous_params);\n+  utterance->set_can_enqueue(can_enqueue);\n+  utterance->set_required_event_types(required_event_types);\n+  utterance->set_desired_event_types(desired_event_types);\n+  utterance->set_extension_id(voice_extension_id);\n+  utterance->set_options(options.get());\n+\n+  ExtensionTtsController* controller = ExtensionTtsController::GetInstance();\n+  controller->SpeakOrEnqueue(utterance);\n   return true;\n }\n \n-void ExtensionTtsSpeakFunction::SpeechFinished() {\n-  error_ = utterance_->error();\n-  bool success = error_.empty();\n-  SendResponse(success);\n-  Release();  // Balanced in RunImpl().\n-}\n-\n bool ExtensionTtsStopSpeakingFunction::RunImpl() {\n   ExtensionTtsController::GetInstance()->Stop();\n   return true;\n@@ -373,14 +166,7 @@ bool ExtensionTtsIsSpeakingFunction::RunImpl() {\n   return true;\n }\n \n-bool ExtensionTtsSpeakCompletedFunction::RunImpl() {\n-  int request_id;\n-  std::string error_message;\n-  EXTENSION_FUNCTION_VALIDATE(args_->GetInteger(0, &request_id));\n-  if (args_->GetSize() >= 2)\n-    EXTENSION_FUNCTION_VALIDATE(args_->GetString(1, &error_message));\n-  ExtensionTtsController::GetInstance()->OnSpeechFinished(\n-      request_id, error_message);\n-\n+bool ExtensionTtsGetVoicesFunction::RunImpl() {\n+  result_.reset(ExtensionTtsController::GetInstance()->GetVoices(profile()));\n   return true;\n }""}<_**next**_>{""sha"": ""28329a291f1d847578e4a8ee387037a229cf38b2"", ""filename"": ""chrome/browser/extensions/extension_tts_api.h"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 204, ""changes"": 214, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_api.h?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -5,232 +5,38 @@\n #ifndef CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_API_H_\n #define CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_API_H_\n \n-#include <queue>\n #include <string>\n \n-#include \""base/memory/singleton.h\""\n-#include \""base/task.h\""\n #include \""chrome/browser/extensions/extension_function.h\""\n-#include \""chrome/browser/extensions/extension_tts_api_util.h\""\n+#include \""chrome/browser/extensions/extension_tts_api_controller.h\""\n \n-// Abstract class that defines the native platform TTS interface.\n-class ExtensionTtsPlatformImpl {\n- public:\n-  static ExtensionTtsPlatformImpl* GetInstance();\n-\n-  // Speak the given utterance with the given parameters if possible,\n-  // and return true on success. Utterance will always be nonempty.\n-  // If the user does not specify the other values, then locale and gender\n-  // will be empty strings, and rate, pitch, and volume will be -1.0.\n-  //\n-  // The ExtensionTtsController will only try to speak one utterance at\n-  // a time. If it wants to interrupt speech, it will always call Stop\n-  // before speaking again, otherwise it will wait until IsSpeaking\n-  // returns false before calling Speak again.\n-  virtual bool Speak(\n-      const std::string& utterance,\n-      const std::string& locale,\n-      const std::string& gender,\n-      double rate,\n-      double pitch,\n-      double volume) = 0;\n-\n-  // Stop speaking immediately and return true on success.\n-  virtual bool StopSpeaking() = 0;\n-\n-  // Return true if the synthesis engine is currently speaking.\n-  virtual bool IsSpeaking() = 0;\n-\n-  virtual std::string error();\n-  virtual void clear_error();\n-  virtual void set_error(const std::string& error);\n-\n- protected:\n-  ExtensionTtsPlatformImpl() {}\n-  virtual ~ExtensionTtsPlatformImpl() {}\n-\n-  std::string error_;\n-\n-  DISALLOW_COPY_AND_ASSIGN(ExtensionTtsPlatformImpl);\n-};\n-\n-// One speech utterance.\n-class Utterance {\n- public:\n-  // Construct an utterance given a profile, the text to speak,\n-  // the options passed to tts.speak, and a completion task to call\n-  // when the utterance is done speaking.\n-  Utterance(Profile* profile,\n-            const std::string& text,\n-            DictionaryValue* options,\n-            Task* completion_task);\n-  ~Utterance();\n-\n-  // Calls the completion task and then destroys itself.\n-  void FinishAndDestroy();\n-\n-  void set_error(const std::string& error) { error_ = error; }\n-  void set_extension_id(const std::string& extension_id) {\n-    extension_id_ = extension_id;\n-  }\n-\n-  // Accessors\n-  Profile* profile() { return profile_; }\n-  const std::string& extension_id() { return extension_id_; }\n-  int id() { return id_; }\n-  const std::string& text() { return text_; }\n-  const Value* options() { return options_.get(); }\n-  const std::string& voice_name() { return voice_name_; }\n-  const std::string& locale() { return locale_; }\n-  const std::string& gender() { return gender_; }\n-  double rate() { return rate_; }\n-  double pitch() { return pitch_; }\n-  double volume() { return volume_; }\n-  bool can_enqueue() { return can_enqueue_; }\n-  const std::string& error() { return error_; }\n-\n- private:\n-  // The profile that initiated this utterance.\n-  Profile* profile_;\n-\n-  // The extension ID of the extension providing TTS for this utterance, or\n-  // empty if native TTS is being used.\n-  std::string extension_id_;\n-\n-  // The unique ID of this utterance, used to associate callback functions\n-  // with utterances.\n-  int id_;\n-\n-  // The id of the next utterance, so we can associate requests with\n-  // responses.\n-  static int next_utterance_id_;\n-\n-  // The text to speak.\n-  std::string text_;\n-\n-  // The full options arg passed to tts.speak, which may include fields\n-  // other than the ones we explicitly parse, below.\n-  scoped_ptr<Value> options_;\n-\n-  // The parsed options.\n-  std::string voice_name_;\n-  std::string locale_;\n-  std::string gender_;\n-  double rate_;\n-  double pitch_;\n-  double volume_;\n-  bool can_enqueue_;\n-\n-  // The error string to pass to the completion task. Will be empty if\n-  // no error occurred.\n-  std::string error_;\n-\n-  // The method to call when this utterance has completed speaking.\n-  Task* completion_task_;\n-};\n-\n-// Singleton class that manages text-to-speech.\n-class ExtensionTtsController {\n- public:\n-  // Get the single instance of this class.\n-  static ExtensionTtsController* GetInstance();\n-\n-  // Returns true if we're currently speaking an utterance.\n-  bool IsSpeaking() const;\n-\n-  // Speak the given utterance. If the utterance's can_enqueue flag is true\n-  // and another utterance is in progress, adds it to the end of the queue.\n-  // Otherwise, interrupts any current utterance and speaks this one\n-  // immediately.\n-  void SpeakOrEnqueue(Utterance* utterance);\n-\n-  // Stop all utterances and flush the queue.\n-  void Stop();\n-\n-  // Called when an extension finishes speaking an utterance.\n-  void OnSpeechFinished(int request_id, const std::string& error_message);\n-\n-  // For unit testing.\n-  void SetPlatformImpl(ExtensionTtsPlatformImpl* platform_impl);\n-\n- private:\n-  ExtensionTtsController();\n-  virtual ~ExtensionTtsController();\n-\n-  // Get the platform TTS implementation (or injected mock).\n-  ExtensionTtsPlatformImpl* GetPlatformImpl();\n-\n-  // Start speaking the given utterance. Will either take ownership of\n-  // |utterance| or delete it if there's an error.\n-  void SpeakNow(Utterance* utterance);\n-\n-  // Called periodically when speech is ongoing. Checks to see if the\n-  // underlying platform speech system has finished the current utterance,\n-  // and if so finishes it and pops the next utterance off the queue.\n-  void CheckSpeechStatus();\n-\n-  // Clear the utterance queue.\n-  void ClearUtteranceQueue();\n-\n-  // Finalize and delete the current utterance.\n-  void FinishCurrentUtterance();\n-\n-  // Start speaking the next utterance in the queue.\n-  void SpeakNextUtterance();\n-\n-  // Return the id string of the first extension with tts_voices in its\n-  // manifest that matches the speech parameters of this utterance,\n-  // or the empty string if none is found.\n-  std::string GetMatchingExtensionId(Utterance* utterance);\n-\n-  ScopedRunnableMethodFactory<ExtensionTtsController> method_factory_;\n-  friend struct DefaultSingletonTraits<ExtensionTtsController>;\n-\n-  // The current utterance being spoken.\n-  Utterance* current_utterance_;\n-\n-  // A queue of utterances to speak after the current one finishes.\n-  std::queue<Utterance*> utterance_queue_;\n-\n-  // A pointer to the platform implementation of text-to-speech, for\n-  // dependency injection.\n-  ExtensionTtsPlatformImpl* platform_impl_;\n-\n-  DISALLOW_COPY_AND_ASSIGN(ExtensionTtsController);\n-};\n-\n-//\n-// Extension API function definitions\n-//\n-\n-class ExtensionTtsSpeakFunction : public AsyncExtensionFunction {\n+class ExtensionTtsSpeakFunction\n+    : public AsyncExtensionFunction {\n  private:\n   virtual ~ExtensionTtsSpeakFunction() {}\n-  virtual bool RunImpl();\n-  void SpeechFinished();\n-  Utterance* utterance_;\n+  virtual bool RunImpl() OVERRIDE;\n   DECLARE_EXTENSION_FUNCTION_NAME(\""experimental.tts.speak\"")\n };\n \n class ExtensionTtsStopSpeakingFunction : public SyncExtensionFunction {\n  private:\n   virtual ~ExtensionTtsStopSpeakingFunction() {}\n-  virtual bool RunImpl();\n+  virtual bool RunImpl() OVERRIDE;\n   DECLARE_EXTENSION_FUNCTION_NAME(\""experimental.tts.stop\"")\n };\n \n class ExtensionTtsIsSpeakingFunction : public SyncExtensionFunction {\n  private:\n   virtual ~ExtensionTtsIsSpeakingFunction() {}\n-  virtual bool RunImpl();\n+  virtual bool RunImpl() OVERRIDE;\n   DECLARE_EXTENSION_FUNCTION_NAME(\""experimental.tts.isSpeaking\"")\n };\n \n-class ExtensionTtsSpeakCompletedFunction : public SyncExtensionFunction {\n+class ExtensionTtsGetVoicesFunction : public SyncExtensionFunction {\n  private:\n-  virtual ~ExtensionTtsSpeakCompletedFunction() {}\n-  virtual bool RunImpl();\n-  DECLARE_EXTENSION_FUNCTION_NAME(\""experimental.tts.speakCompleted\"")\n+  virtual ~ExtensionTtsGetVoicesFunction() {}\n+  virtual bool RunImpl() OVERRIDE;\n+  DECLARE_EXTENSION_FUNCTION_NAME(\""experimental.tts.getVoices\"")\n };\n \n #endif  // CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_API_H_""}<_**next**_>{""sha"": ""9e27333acec5afe6a0399d825b79eb91f2231d41"", ""filename"": ""chrome/browser/extensions/extension_tts_api_chromeos.cc"", ""status"": ""modified"", ""additions"": 76, ""deletions"": 38, ""changes"": 114, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_chromeos.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_chromeos.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_api_chromeos.cc?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -2,46 +2,56 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-#include \""chrome/browser/extensions/extension_tts_api.h\""\n-\n #include \""base/memory/singleton.h\""\n+#include \""base/message_loop.h\""\n #include \""base/string_number_conversions.h\""\n+#include \""base/task.h\""\n #include \""chrome/browser/chromeos/cros/cros_library.h\""\n #include \""chrome/browser/chromeos/cros/speech_synthesis_library.h\""\n-\n-namespace util = extension_tts_api_util;\n+#include \""chrome/browser/extensions/extension_tts_api_controller.h\""\n+#include \""chrome/browser/extensions/extension_tts_api_platform.h\""\n \n using base::DoubleToString;\n \n namespace {\n const char kCrosLibraryNotLoadedError[] = \""Cros shared library not loaded.\"";\n+const int kSpeechCheckDelayIntervalMs = 100;\n };\n \n class ExtensionTtsPlatformImplChromeOs : public ExtensionTtsPlatformImpl {\n  public:\n+  virtual bool PlatformImplAvailable() {\n+    return true;\n+  }\n+\n   virtual bool Speak(\n+      int utterance_id,\n       const std::string& utterance,\n-      const std::string& locale,\n-      const std::string& gender,\n-      double rate,\n-      double pitch,\n-      double volume);\n+      const std::string& lang,\n+      const UtteranceContinuousParameters& params);\n \n   virtual bool StopSpeaking();\n \n-  virtual bool IsSpeaking();\n+  virtual bool SendsEvent(TtsEventType event_type);\n \n   // Get the single instance of this class.\n   static ExtensionTtsPlatformImplChromeOs* GetInstance();\n \n  private:\n-  ExtensionTtsPlatformImplChromeOs() {}\n+  ExtensionTtsPlatformImplChromeOs()\n+      : ALLOW_THIS_IN_INITIALIZER_LIST(method_factory_(this)) {}\n   virtual ~ExtensionTtsPlatformImplChromeOs() {}\n \n+  void PollUntilSpeechFinishes(int utterance_id);\n+\n   void AppendSpeakOption(std::string key,\n                          std::string value,\n                          std::string* options);\n \n+  int utterance_id_;\n+  int utterance_length_;\n+  ScopedRunnableMethodFactory<ExtensionTtsPlatformImplChromeOs> method_factory_;\n+\n   friend struct DefaultSingletonTraits<ExtensionTtsPlatformImplChromeOs>;\n \n   DISALLOW_COPY_AND_ASSIGN(ExtensionTtsPlatformImplChromeOs);\n@@ -53,54 +63,48 @@ ExtensionTtsPlatformImpl* ExtensionTtsPlatformImpl::GetInstance() {\n }\n \n bool ExtensionTtsPlatformImplChromeOs::Speak(\n+    int utterance_id,\n     const std::string& utterance,\n-    const std::string& locale,\n-    const std::string& gender,\n-    double rate,\n-    double pitch,\n-    double volume) {\n+    const std::string& lang,\n+    const UtteranceContinuousParameters& params) {\n   chromeos::CrosLibrary* cros_library = chromeos::CrosLibrary::Get();\n   if (!cros_library->EnsureLoaded()) {\n     set_error(kCrosLibraryNotLoadedError);\n     return false;\n   }\n \n+  utterance_id_ = utterance_id;\n+  utterance_length_ = utterance.size();\n+\n   std::string options;\n \n-  if (!locale.empty()) {\n+  if (!lang.empty()) {\n     AppendSpeakOption(\n         chromeos::SpeechSynthesisLibrary::kSpeechPropertyLocale,\n-        locale,\n+        lang,\n         &options);\n   }\n \n-  if (!gender.empty()) {\n-    AppendSpeakOption(\n-        chromeos::SpeechSynthesisLibrary::kSpeechPropertyGender,\n-        gender,\n-        &options);\n-  }\n-\n-  if (rate >= 0.0) {\n+  if (params.rate >= 0.0) {\n     AppendSpeakOption(\n         chromeos::SpeechSynthesisLibrary::kSpeechPropertyRate,\n-        DoubleToString(rate * 5),\n+        DoubleToString(1.5 + params.rate * 2.5),\n         &options);\n   }\n \n-  if (pitch >= 0.0) {\n+  if (params.pitch >= 0.0) {\n     // The TTS service allows a range of 0 to 2 for speech pitch.\n     AppendSpeakOption(\n         chromeos::SpeechSynthesisLibrary::kSpeechPropertyPitch,\n-        DoubleToString(pitch * 2),\n+        DoubleToString(params.pitch),\n         &options);\n   }\n \n-  if (volume >= 0.0) {\n+  if (params.volume >= 0.0) {\n     // The TTS service allows a range of 0 to 5 for speech volume.\n     AppendSpeakOption(\n         chromeos::SpeechSynthesisLibrary::kSpeechPropertyVolume,\n-        DoubleToString(volume * 5),\n+        DoubleToString(params.volume * 5),\n         &options);\n   }\n \n@@ -109,7 +113,16 @@ bool ExtensionTtsPlatformImplChromeOs::Speak(\n         options.c_str());\n   }\n \n-  return cros_library->GetSpeechSynthesisLibrary()->Speak(utterance.c_str());\n+  bool result =\n+      cros_library->GetSpeechSynthesisLibrary()->Speak(utterance.c_str());\n+\n+  if (result) {\n+    ExtensionTtsController* controller = ExtensionTtsController::GetInstance();\n+    controller->OnTtsEvent(utterance_id_, TTS_EVENT_START, 0, std::string());\n+    PollUntilSpeechFinishes(utterance_id_);\n+  }\n+\n+  return result;\n }\n \n bool ExtensionTtsPlatformImplChromeOs::StopSpeaking() {\n@@ -122,14 +135,39 @@ bool ExtensionTtsPlatformImplChromeOs::StopSpeaking() {\n   return false;\n }\n \n-bool ExtensionTtsPlatformImplChromeOs::IsSpeaking() {\n-  if (chromeos::CrosLibrary::Get()->EnsureLoaded()) {\n-    return chromeos::CrosLibrary::Get()->GetSpeechSynthesisLibrary()->\n-        IsSpeaking();\n+bool ExtensionTtsPlatformImplChromeOs::SendsEvent(TtsEventType event_type) {\n+  return (event_type == TTS_EVENT_START ||\n+          event_type == TTS_EVENT_END ||\n+          event_type == TTS_EVENT_ERROR);\n+}\n+\n+void ExtensionTtsPlatformImplChromeOs::PollUntilSpeechFinishes(\n+    int utterance_id) {\n+  if (utterance_id != utterance_id_) {\n+    // This utterance must have been interrupted or cancelled.\n+    return;\n   }\n \n-  set_error(kCrosLibraryNotLoadedError);\n-  return false;\n+  chromeos::CrosLibrary* cros_library = chromeos::CrosLibrary::Get();\n+  ExtensionTtsController* controller = ExtensionTtsController::GetInstance();\n+\n+  if (!cros_library->EnsureLoaded()) {\n+    controller->OnTtsEvent(\n+        utterance_id_, TTS_EVENT_ERROR, 0, kCrosLibraryNotLoadedError);\n+    return;\n+  }\n+\n+  if (!cros_library->GetSpeechSynthesisLibrary()->IsSpeaking()) {\n+    controller->OnTtsEvent(\n+        utterance_id_, TTS_EVENT_END, utterance_length_, std::string());\n+    return;\n+  }\n+\n+  MessageLoop::current()->PostDelayedTask(\n+      FROM_HERE, method_factory_.NewRunnableMethod(\n+          &ExtensionTtsPlatformImplChromeOs::PollUntilSpeechFinishes,\n+          utterance_id),\n+      kSpeechCheckDelayIntervalMs);\n }\n \n void ExtensionTtsPlatformImplChromeOs::AppendSpeakOption(""}<_**next**_>{""sha"": ""dc0ec9551118227c4d8104b5b130cc7fdcb42cf2"", ""filename"": ""chrome/browser/extensions/extension_tts_api_constants.cc"", ""status"": ""added"", ""additions"": 49, ""deletions"": 0, ""changes"": 49, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_constants.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_constants.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_api_constants.cc?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,49 @@\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""chrome/browser/extensions/extension_tts_api_constants.h\""\n+\n+namespace extension_tts_api_constants {\n+\n+const char kVoiceNameKey[] = \""voiceName\"";\n+const char kLangKey[] = \""lang\"";\n+const char kGenderKey[] = \""gender\"";\n+const char kRateKey[] = \""rate\"";\n+const char kPitchKey[] = \""pitch\"";\n+const char kVolumeKey[] = \""volume\"";\n+const char kEnqueueKey[] = \""enqueue\"";\n+const char kEventTypeKey[] = \""type\"";\n+const char kEventTypesKey[] = \""eventTypes\"";\n+const char kCharIndexKey[] = \""charIndex\"";\n+const char kErrorMessageKey[] = \""errorMessage\"";\n+const char kRequiredEventTypesKey[] = \""requiredEventTypes\"";\n+const char kDesiredEventTypesKey[] = \""desiredEventTypes\"";\n+const char kExtensionIdKey[] = \""extensionId\"";\n+const char kSrcIdKey[] = \""srcId\"";\n+const char kIsFinalEventKey[] = \""isFinalEvent\"";\n+\n+const char kGenderFemale[] = \""female\"";\n+const char kGenderMale[] = \""male\"";\n+\n+const char kEventTypeStart[] = \""start\"";\n+const char kEventTypeEnd[] = \""end\"";\n+const char kEventTypeWord[] = \""word\"";\n+const char kEventTypeSentence[] = \""sentence\"";\n+const char kEventTypeMarker[] = \""marker\"";\n+const char kEventTypeInterrupted[] = \""interrupted\"";\n+const char kEventTypeCancelled[] = \""cancelled\"";\n+const char kEventTypeError[] = \""error\"";\n+\n+const char kNativeVoiceName[] = \""native\"";\n+\n+const char kErrorUndeclaredEventType[] =\n+    \""Cannot send an event type that is not declared in the extension manifest.\"";\n+const char kErrorUtteranceTooLong[] = \""Utterance length is too long.\"";\n+const char kErrorInvalidLang[] = \""Invalid lang.\"";\n+const char kErrorInvalidGender[] = \""Invalid gender.\"";\n+const char kErrorInvalidRate[] = \""Invalid rate.\"";\n+const char kErrorInvalidPitch[] = \""Invalid pitch.\"";\n+const char kErrorInvalidVolume[] = \""Invalid volume.\"";\n+\n+}  // namespace extension_tts_api_constants.""}<_**next**_>{""sha"": ""6a66777516b932e88c690eb8af1bfcf714338438"", ""filename"": ""chrome/browser/extensions/extension_tts_api_constants.h"", ""status"": ""added"", ""additions"": 54, ""deletions"": 0, ""changes"": 54, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_constants.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_constants.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_api_constants.h?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,54 @@\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_API_CONSTANTS_H_\n+#define CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_API_CONSTANTS_H_\n+\n+#include <string>\n+\n+#include \""base/values.h\""\n+\n+namespace extension_tts_api_constants {\n+\n+extern const char kVoiceNameKey[];\n+extern const char kLangKey[];\n+extern const char kGenderKey[];\n+extern const char kRateKey[];\n+extern const char kPitchKey[];\n+extern const char kVolumeKey[];\n+extern const char kEnqueueKey[];\n+extern const char kEventTypeKey[];\n+extern const char kEventTypesKey[];\n+extern const char kCharIndexKey[];\n+extern const char kErrorMessageKey[];\n+extern const char kRequiredEventTypesKey[];\n+extern const char kDesiredEventTypesKey[];\n+extern const char kExtensionIdKey[];\n+extern const char kSrcIdKey[];\n+extern const char kIsFinalEventKey[];\n+\n+extern const char kGenderFemale[];\n+extern const char kGenderMale[];\n+\n+extern const char kEventTypeStart[];\n+extern const char kEventTypeEnd[];\n+extern const char kEventTypeWord[];\n+extern const char kEventTypeSentence[];\n+extern const char kEventTypeMarker[];\n+extern const char kEventTypeInterrupted[];\n+extern const char kEventTypeCancelled[];\n+extern const char kEventTypeError[];\n+\n+extern const char kNativeVoiceName[];\n+\n+extern const char kErrorUndeclaredEventType[];\n+extern const char kErrorUtteranceTooLong[];\n+extern const char kErrorInvalidLang[];\n+extern const char kErrorInvalidGender[];\n+extern const char kErrorInvalidRate[];\n+extern const char kErrorInvalidPitch[];\n+extern const char kErrorInvalidVolume[];\n+\n+}  // namespace extension_tts_api_constants.\n+#endif  // CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_API_CONSTANTS_H_""}<_**next**_>{""sha"": ""1d0b3fc18e4561e79965ad37d70448601e6b0475"", ""filename"": ""chrome/browser/extensions/extension_tts_api_controller.cc"", ""status"": ""added"", ""additions"": 312, ""deletions"": 0, ""changes"": 312, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_api_controller.cc?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,312 @@\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""chrome/browser/extensions/extension_tts_api_controller.h\""\n+\n+#include <string>\n+#include <vector>\n+\n+#include \""base/float_util.h\""\n+#include \""base/json/json_writer.h\""\n+#include \""base/values.h\""\n+#include \""chrome/browser/extensions/extension_event_router.h\""\n+#include \""chrome/browser/extensions/extension_tts_api.h\""\n+#include \""chrome/browser/extensions/extension_tts_api_constants.h\""\n+#include \""chrome/browser/extensions/extension_tts_api_platform.h\""\n+#include \""chrome/browser/extensions/extension_tts_engine_api.h\""\n+#include \""chrome/browser/profiles/profile.h\""\n+#include \""chrome/common/extensions/extension.h\""\n+\n+namespace constants = extension_tts_api_constants;\n+\n+namespace events {\n+const char kOnEvent[] = \""experimental.ttsEngine.onEvent\"";\n+};  // namespace events\n+\n+std::string TtsEventTypeToString(TtsEventType event_type) {\n+  switch (event_type) {\n+    case TTS_EVENT_START:\n+      return constants::kEventTypeStart;\n+    case TTS_EVENT_END:\n+      return constants::kEventTypeEnd;\n+    case TTS_EVENT_WORD:\n+      return constants::kEventTypeWord;\n+    case TTS_EVENT_SENTENCE:\n+      return constants::kEventTypeSentence;\n+    case TTS_EVENT_MARKER:\n+      return constants::kEventTypeMarker;\n+    case TTS_EVENT_INTERRUPTED:\n+      return constants::kEventTypeInterrupted;\n+    case TTS_EVENT_CANCELLED:\n+      return constants::kEventTypeCancelled;\n+    case TTS_EVENT_ERROR:\n+      return constants::kEventTypeError;\n+    default:\n+      NOTREACHED();\n+      return std::string();\n+  }\n+}\n+\n+\n+//\n+// UtteranceContinuousParameters\n+//\n+\n+\n+UtteranceContinuousParameters::UtteranceContinuousParameters()\n+    : rate(-1),\n+      pitch(-1),\n+      volume(-1) {}\n+\n+\n+//\n+// Utterance\n+//\n+\n+// static\n+int Utterance::next_utterance_id_ = 0;\n+\n+Utterance::Utterance(Profile* profile)\n+    : profile_(profile),\n+      id_(next_utterance_id_++),\n+      can_enqueue_(false),\n+      char_index_(0),\n+      finished_(false) {\n+  options_.reset(new DictionaryValue());\n+}\n+\n+Utterance::~Utterance() {\n+  DCHECK(finished_);\n+}\n+\n+void Utterance::OnTtsEvent(TtsEventType event_type,\n+                           int char_index,\n+                           const std::string& error_message) {\n+  std::string event_type_string = TtsEventTypeToString(event_type);\n+  if (char_index >= 0)\n+    char_index_ = char_index;\n+  if (event_type == TTS_EVENT_END ||\n+      event_type == TTS_EVENT_INTERRUPTED ||\n+      event_type == TTS_EVENT_CANCELLED ||\n+      event_type == TTS_EVENT_ERROR) {\n+    finished_ = true;\n+  }\n+  if (desired_event_types_.size() > 0 &&\n+      desired_event_types_.find(event_type_string) ==\n+      desired_event_types_.end()) {\n+    return;\n+  }\n+\n+  ListValue args;\n+  DictionaryValue* event = new DictionaryValue();\n+  event->SetInteger(constants::kCharIndexKey, char_index);\n+  event->SetString(constants::kEventTypeKey, event_type_string);\n+  if (event_type == TTS_EVENT_ERROR) {\n+    event->SetString(constants::kErrorMessageKey, error_message);\n+  }\n+  event->SetInteger(constants::kSrcIdKey, src_id_);\n+  event->SetBoolean(constants::kIsFinalEventKey, finished_);\n+  args.Set(0, event);\n+  std::string json_args;\n+  base::JSONWriter::Write(&args, false, &json_args);\n+\n+  profile_->GetExtensionEventRouter()->DispatchEventToExtension(\n+      src_extension_id_,\n+      events::kOnEvent,\n+      json_args,\n+      profile_,\n+      src_url_);\n+}\n+\n+void Utterance::Finish() {\n+  finished_ = true;\n+}\n+\n+void Utterance::set_options(const Value* options) {\n+  options_.reset(options->DeepCopy());\n+}\n+\n+//\n+// ExtensionTtsController\n+//\n+\n+// static\n+ExtensionTtsController* ExtensionTtsController::GetInstance() {\n+  return Singleton<ExtensionTtsController>::get();\n+}\n+\n+ExtensionTtsController::ExtensionTtsController()\n+    : current_utterance_(NULL),\n+      platform_impl_(NULL) {\n+}\n+\n+ExtensionTtsController::~ExtensionTtsController() {\n+  FinishCurrentUtterance();\n+  ClearUtteranceQueue();\n+}\n+\n+void ExtensionTtsController::SpeakOrEnqueue(Utterance* utterance) {\n+  if (IsSpeaking() && utterance->can_enqueue()) {\n+    utterance_queue_.push(utterance);\n+  } else {\n+    Stop();\n+    SpeakNow(utterance);\n+  }\n+}\n+\n+void ExtensionTtsController::SpeakNow(Utterance* utterance) {\n+  const Extension* extension;\n+  size_t voice_index;\n+  if (GetMatchingExtensionVoice(utterance, &extension, &voice_index)) {\n+    current_utterance_ = utterance;\n+    utterance->set_extension_id(extension->id());\n+\n+    ExtensionTtsEngineSpeak(utterance, extension, voice_index);\n+\n+    const std::set<std::string> event_types =\n+        extension->tts_voices()[voice_index].event_types;\n+    bool sends_end_event =\n+        (event_types.find(constants::kEventTypeEnd) != event_types.end());\n+    if (!sends_end_event) {\n+      utterance->Finish();\n+      delete utterance;\n+      current_utterance_ = NULL;\n+      SpeakNextUtterance();\n+    }\n+    return;\n+  }\n+\n+  GetPlatformImpl()->clear_error();\n+  bool success = GetPlatformImpl()->Speak(\n+      utterance->id(),\n+      utterance->text(),\n+      utterance->lang(),\n+      utterance->continuous_parameters());\n+  if (!success) {\n+    utterance->OnTtsEvent(TTS_EVENT_ERROR, -1, GetPlatformImpl()->error());\n+    delete utterance;\n+    return;\n+  }\n+  current_utterance_ = utterance;\n+}\n+\n+void ExtensionTtsController::Stop() {\n+  if (current_utterance_ && !current_utterance_->extension_id().empty()) {\n+    ExtensionTtsEngineStop(current_utterance_);\n+  } else {\n+    GetPlatformImpl()->clear_error();\n+    GetPlatformImpl()->StopSpeaking();\n+  }\n+\n+  if (current_utterance_)\n+    current_utterance_->OnTtsEvent(TTS_EVENT_INTERRUPTED, -1, std::string());\n+  FinishCurrentUtterance();\n+  ClearUtteranceQueue();\n+}\n+\n+void ExtensionTtsController::OnTtsEvent(int utterance_id,\n+                                        TtsEventType event_type,\n+                                        int char_index,\n+                                        const std::string& error_message) {\n+  // We may sometimes receive completion callbacks \""late\"", after we've\n+  // already finished the utterance (for example because another utterance\n+  // interrupted or we got a call to Stop). This is normal and we can\n+  // safely just ignore these events.\n+  if (!current_utterance_ || utterance_id != current_utterance_->id())\n+    return;\n+\n+  current_utterance_->OnTtsEvent(event_type, char_index, error_message);\n+  if (current_utterance_->finished()) {\n+    FinishCurrentUtterance();\n+    SpeakNextUtterance();\n+  }\n+}\n+\n+ListValue* ExtensionTtsController::GetVoices(Profile* profile) {\n+  ListValue* result_voices = new ListValue();\n+  if (platform_impl_ && platform_impl_->PlatformImplAvailable()) {\n+    DictionaryValue* result_voice = new DictionaryValue();\n+    result_voice->SetString(\n+        constants::kVoiceNameKey, constants::kNativeVoiceName);\n+    if (!platform_impl_->gender().empty())\n+      result_voice->SetString(constants::kGenderKey, platform_impl_->gender());\n+    ListValue* event_types = new ListValue();\n+\n+    // All platforms must send end events, and cancelled and interrupted\n+    // events are generated from the controller.\n+    DCHECK(platform_impl_->SendsEvent(TTS_EVENT_END));\n+    event_types->Append(Value::CreateStringValue(constants::kEventTypeEnd));\n+    event_types->Append(Value::CreateStringValue(\n+        constants::kEventTypeCancelled));\n+    event_types->Append(Value::CreateStringValue(\n+        constants::kEventTypeInterrupted));\n+\n+    if (platform_impl_->SendsEvent(TTS_EVENT_START))\n+      event_types->Append(Value::CreateStringValue(constants::kEventTypeStart));\n+    if (platform_impl_->SendsEvent(TTS_EVENT_WORD))\n+      event_types->Append(Value::CreateStringValue(constants::kEventTypeWord));\n+    if (platform_impl_->SendsEvent(TTS_EVENT_SENTENCE))\n+      event_types->Append(Value::CreateStringValue(\n+          constants::kEventTypeSentence));\n+    if (platform_impl_->SendsEvent(TTS_EVENT_MARKER))\n+      event_types->Append(Value::CreateStringValue(\n+          constants::kEventTypeMarker));\n+    if (platform_impl_->SendsEvent(TTS_EVENT_ERROR))\n+      event_types->Append(Value::CreateStringValue(\n+          constants::kEventTypeError));\n+    result_voice->Set(constants::kEventTypesKey, event_types);\n+    result_voices->Append(result_voice);\n+  }\n+\n+  GetExtensionVoices(profile, result_voices);\n+\n+  return result_voices;\n+}\n+\n+bool ExtensionTtsController::IsSpeaking() const {\n+  return current_utterance_ != NULL;\n+}\n+\n+void ExtensionTtsController::FinishCurrentUtterance() {\n+  if (current_utterance_) {\n+    if (!current_utterance_->finished())\n+      current_utterance_->OnTtsEvent(TTS_EVENT_INTERRUPTED, -1, std::string());\n+    delete current_utterance_;\n+    current_utterance_ = NULL;\n+  }\n+}\n+\n+void ExtensionTtsController::SpeakNextUtterance() {\n+  // Start speaking the next utterance in the queue.  Keep trying in case\n+  // one fails but there are still more in the queue to try.\n+  while (!utterance_queue_.empty() && !current_utterance_) {\n+    Utterance* utterance = utterance_queue_.front();\n+    utterance_queue_.pop();\n+    SpeakNow(utterance);\n+  }\n+}\n+\n+void ExtensionTtsController::ClearUtteranceQueue() {\n+  while (!utterance_queue_.empty()) {\n+    Utterance* utterance = utterance_queue_.front();\n+    utterance_queue_.pop();\n+    utterance->OnTtsEvent(TTS_EVENT_CANCELLED, -1, std::string());\n+    delete utterance;\n+  }\n+}\n+\n+void ExtensionTtsController::SetPlatformImpl(\n+    ExtensionTtsPlatformImpl* platform_impl) {\n+  platform_impl_ = platform_impl;\n+}\n+\n+int ExtensionTtsController::QueueSize() {\n+  return static_cast<int>(utterance_queue_.size());\n+}\n+\n+ExtensionTtsPlatformImpl* ExtensionTtsController::GetPlatformImpl() {\n+  if (!platform_impl_)\n+    platform_impl_ = ExtensionTtsPlatformImpl::GetInstance();\n+  return platform_impl_;\n+}""}<_**next**_>{""sha"": ""8ffe065e708dda46164934a0845a369e22e2066d"", ""filename"": ""chrome/browser/extensions/extension_tts_api_controller.h"", ""status"": ""added"", ""additions"": 256, ""deletions"": 0, ""changes"": 256, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_controller.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_controller.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_api_controller.h?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,256 @@\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_API_CONTROLLER_H_\n+#define CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_API_CONTROLLER_H_\n+\n+#include <queue>\n+#include <set>\n+#include <string>\n+\n+#include \""base/memory/singleton.h\""\n+#include \""base/scoped_ptr.h\""\n+#include \""googleurl/src/gurl.h\""\n+\n+class DictionaryValue;\n+class Extension;\n+class ExtensionTtsPlatformImpl;\n+class ListValue;\n+class Profile;\n+class Value;\n+\n+\n+// Events sent back from the TTS engine indicating the progress.\n+enum TtsEventType {\n+  TTS_EVENT_START,\n+  TTS_EVENT_END,\n+  TTS_EVENT_WORD,\n+  TTS_EVENT_SENTENCE,\n+  TTS_EVENT_MARKER,\n+  TTS_EVENT_INTERRUPTED,\n+  TTS_EVENT_CANCELLED,\n+  TTS_EVENT_ERROR\n+};\n+\n+\n+// The continuous parameters that apply to a given utterance.\n+struct UtteranceContinuousParameters {\n+  UtteranceContinuousParameters();\n+\n+  double rate;\n+  double pitch;\n+  double volume;\n+};\n+\n+\n+// One speech utterance.\n+class Utterance {\n+ public:\n+  // Construct an utterance given a profile and a completion task to call\n+  // when the utterance is done speaking. Before speaking this utterance,\n+  // its other parameters like text, rate, pitch, etc. should all be set.\n+  explicit Utterance(Profile* profile);\n+  ~Utterance();\n+\n+  // Sends an event to the delegate. If the event type is TTS_EVENT_END\n+  // or TTS_EVENT_ERROR, deletes the utterance. If |char_index| is -1,\n+  // uses the last good value.\n+  void OnTtsEvent(TtsEventType event_type,\n+                  int char_index,\n+                  const std::string& error_message);\n+\n+  // Finish an utterance without sending an event to the delegate.\n+  void Finish();\n+\n+  // Getters and setters for the text to speak and other speech options.\n+  void set_text(const std::string& text) { text_ = text; }\n+  const std::string& text() const { return text_; }\n+\n+  void set_options(const Value* options);\n+  const Value* options() const { return options_.get(); }\n+\n+  void set_src_extension_id(const std::string& src_extension_id) {\n+    src_extension_id_ = src_extension_id;\n+  }\n+  const std::string& src_extension_id() { return src_extension_id_; }\n+\n+  void set_src_id(int src_id) { src_id_ = src_id; }\n+  int src_id() { return src_id_; }\n+\n+  void set_src_url(const GURL& src_url) { src_url_ = src_url; }\n+  const GURL& src_url() { return src_url_; }\n+\n+  void set_voice_name(const std::string& voice_name) {\n+    voice_name_ = voice_name;\n+  }\n+  const std::string& voice_name() const { return voice_name_; }\n+\n+  void set_lang(const std::string& lang) {\n+    lang_ = lang;\n+  }\n+  const std::string& lang() const { return lang_; }\n+\n+  void set_gender(const std::string& gender) {\n+    gender_ = gender;\n+  }\n+  const std::string& gender() const { return gender_; }\n+\n+  void set_continuous_parameters(const UtteranceContinuousParameters& params) {\n+    continuous_parameters_ = params;\n+  }\n+  const UtteranceContinuousParameters& continuous_parameters() {\n+    return continuous_parameters_;\n+  }\n+\n+  void set_can_enqueue(bool can_enqueue) { can_enqueue_ = can_enqueue; }\n+  bool can_enqueue() const { return can_enqueue_; }\n+\n+  void set_required_event_types(const std::set<std::string>& types) {\n+    required_event_types_ = types;\n+  }\n+  const std::set<std::string>& required_event_types() const {\n+    return required_event_types_;\n+  }\n+\n+  void set_desired_event_types(const std::set<std::string>& types) {\n+    desired_event_types_ = types;\n+  }\n+  const std::set<std::string>& desired_event_types() const {\n+    return desired_event_types_;\n+  }\n+\n+  const std::string& extension_id() const { return extension_id_; }\n+  void set_extension_id(const std::string& extension_id) {\n+    extension_id_ = extension_id;\n+  }\n+\n+  // Getters and setters for internal state.\n+  Profile* profile() const { return profile_; }\n+  int id() const { return id_; }\n+  bool finished() const { return finished_; }\n+\n+ private:\n+  // The profile that initiated this utterance.\n+  Profile* profile_;\n+\n+  // The extension ID of the extension providing TTS for this utterance, or\n+  // empty if native TTS is being used.\n+  std::string extension_id_;\n+\n+  // The unique ID of this utterance, used to associate callback functions\n+  // with utterances.\n+  int id_;\n+\n+  // The id of the next utterance, so we can associate requests with\n+  // responses.\n+  static int next_utterance_id_;\n+\n+  // The text to speak.\n+  std::string text_;\n+\n+  // The full options arg passed to tts.speak, which may include fields\n+  // other than the ones we explicitly parse, below.\n+  scoped_ptr<Value> options_;\n+\n+  // The extension ID of the extension that called speak() and should\n+  // receive events.\n+  std::string src_extension_id_;\n+\n+  // The source extension's ID of this utterance, so that it can associate\n+  // events with the appropriate callback.\n+  int src_id_;\n+\n+  // The URL of the page where the source extension called speak.\n+  GURL src_url_;\n+\n+  // The parsed options.\n+  std::string voice_name_;\n+  std::string lang_;\n+  std::string gender_;\n+  UtteranceContinuousParameters continuous_parameters_;\n+  bool can_enqueue_;\n+  std::set<std::string> required_event_types_;\n+  std::set<std::string> desired_event_types_;\n+\n+  // The index of the current char being spoken.\n+  int char_index_;\n+\n+  // True if this utterance received an event indicating it's done.\n+  bool finished_;\n+};\n+\n+\n+// Singleton class that manages text-to-speech for the TTS and TTS engine\n+// extension APIs, maintaining a queue of pending utterances and keeping\n+// track of all state.\n+class ExtensionTtsController {\n+ public:\n+  // Get the single instance of this class.\n+  static ExtensionTtsController* GetInstance();\n+\n+  // Returns true if we're currently speaking an utterance.\n+  bool IsSpeaking() const;\n+\n+  // Speak the given utterance. If the utterance's can_enqueue flag is true\n+  // and another utterance is in progress, adds it to the end of the queue.\n+  // Otherwise, interrupts any current utterance and speaks this one\n+  // immediately.\n+  void SpeakOrEnqueue(Utterance* utterance);\n+\n+  // Stop all utterances and flush the queue.\n+  void Stop();\n+\n+  // Handle events received from the speech engine. Events are forwarded to\n+  // the callback function, and in addition, completion and error events\n+  // trigger finishing the current utterance and starting the next one, if\n+  // any.\n+  void OnTtsEvent(int utterance_id,\n+                  TtsEventType event_type,\n+                  int char_index,\n+                  const std::string& error_message);\n+\n+  // Return a list of all available voices, including the native voice,\n+  // if supported, and all voices registered by extensions.\n+  ListValue* GetVoices(Profile* profile);\n+\n+  // For unit testing.\n+  void SetPlatformImpl(ExtensionTtsPlatformImpl* platform_impl);\n+  int QueueSize();\n+\n+ private:\n+  ExtensionTtsController();\n+  virtual ~ExtensionTtsController();\n+\n+  // Get the platform TTS implementation (or injected mock).\n+  ExtensionTtsPlatformImpl* GetPlatformImpl();\n+\n+  // Start speaking the given utterance. Will either take ownership of\n+  // |utterance| or delete it if there's an error. Returns true on success.\n+  void SpeakNow(Utterance* utterance);\n+\n+  // Clear the utterance queue.\n+  void ClearUtteranceQueue();\n+\n+  // Finalize and delete the current utterance.\n+  void FinishCurrentUtterance();\n+\n+  // Start speaking the next utterance in the queue.\n+  void SpeakNextUtterance();\n+\n+  friend struct DefaultSingletonTraits<ExtensionTtsController>;\n+\n+  // The current utterance being spoken.\n+  Utterance* current_utterance_;\n+\n+  // A queue of utterances to speak after the current one finishes.\n+  std::queue<Utterance*> utterance_queue_;\n+\n+  // A pointer to the platform implementation of text-to-speech, for\n+  // dependency injection.\n+  ExtensionTtsPlatformImpl* platform_impl_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(ExtensionTtsController);\n+};\n+\n+#endif  // CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_API_CONTROLLER_H_""}<_**next**_>{""sha"": ""07e6c61a9e0f65b5712768cebef3c5d60b173a2d"", ""filename"": ""chrome/browser/extensions/extension_tts_api_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 9, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_api_linux.cc?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -2,11 +2,8 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-#include \""chrome/browser/extensions/extension_tts_api.h\""\n-\n #include \""base/memory/singleton.h\""\n-\n-namespace util = extension_tts_api_util;\n+#include \""chrome/browser/extensions/extension_tts_api_platform.h\""\n \n namespace {\n const char kNotSupportedError[] =\n@@ -15,13 +12,15 @@ const char kNotSupportedError[] =\n \n class ExtensionTtsPlatformImplLinux : public ExtensionTtsPlatformImpl {\n  public:\n+  virtual bool PlatformImplAvailable() {\n+    return false;\n+  }\n+\n   virtual bool Speak(\n+      int utterance_id,\n       const std::string& utterance,\n-      const std::string& language,\n-      const std::string& gender,\n-      double rate,\n-      double pitch,\n-      double volume) {\n+      const std::string& lang,\n+      const UtteranceContinuousParameters& params) {\n     error_ = kNotSupportedError;\n     return false;\n   }\n@@ -36,6 +35,10 @@ class ExtensionTtsPlatformImplLinux : public ExtensionTtsPlatformImpl {\n     return false;\n   }\n \n+  virtual bool SendsEvent(TtsEventType event_type) {\n+    return false;\n+  }\n+\n   // Get the single instance of this class.\n   static ExtensionTtsPlatformImplLinux* GetInstance() {\n     return Singleton<ExtensionTtsPlatformImplLinux>::get();""}<_**next**_>{""sha"": ""1a774983aebf437ea251eca716ee9250e1cda99b"", ""filename"": ""chrome/browser/extensions/extension_tts_api_mac.mm"", ""status"": ""modified"", ""additions"": 118, ""deletions"": 26, ""changes"": 144, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_mac.mm"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_mac.mm"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_api_mac.mm?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -2,40 +2,67 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-#include \""extension_tts_api.h\""\n-\n #include <string>\n \n+#include \""base/mac/cocoa_protocols.h\""\n+#include \""base/memory/scoped_nsobject.h\""\n #include \""base/memory/singleton.h\""\n+#include \""base/sys_string_conversions.h\""\n #include \""base/values.h\""\n #include \""chrome/browser/extensions/extension_function.h\""\n+#include \""chrome/browser/extensions/extension_tts_api_constants.h\""\n+#include \""chrome/browser/extensions/extension_tts_api_controller.h\""\n+#include \""chrome/browser/extensions/extension_tts_api_platform.h\""\n \n #import <Cocoa/Cocoa.h>\n \n-namespace util = extension_tts_api_util;\n+class ExtensionTtsPlatformImplMac;\n+\n+@interface ChromeTtsDelegate : NSObject <NSSpeechSynthesizerDelegate> {\n+ @private\n+  ExtensionTtsPlatformImplMac* ttsImplMac_;  // weak.\n+}\n+\n+- (id)initWithPlatformImplMac:(ExtensionTtsPlatformImplMac*)ttsImplMac;\n+\n+@end\n \n class ExtensionTtsPlatformImplMac : public ExtensionTtsPlatformImpl {\n  public:\n+  virtual bool PlatformImplAvailable() {\n+    return true;\n+  }\n+\n   virtual bool Speak(\n+      int utterance_id,\n       const std::string& utterance,\n-      const std::string& language,\n-      const std::string& gender,\n-      double rate,\n-      double pitch,\n-      double volume);\n+      const std::string& lang,\n+      const UtteranceContinuousParameters& params);\n \n   virtual bool StopSpeaking();\n \n   virtual bool IsSpeaking();\n \n+  virtual bool SendsEvent(TtsEventType event_type);\n+\n+  // Called by ChromeTtsDelegate when we get a callback from the\n+  // native speech engine.\n+  void OnSpeechEvent(TtsEventType event_type,\n+                     int char_index,\n+                     const std::string& error_message);\n+\n   // Get the single instance of this class.\n   static ExtensionTtsPlatformImplMac* GetInstance();\n \n  private:\n   ExtensionTtsPlatformImplMac();\n-  virtual ~ExtensionTtsPlatformImplMac() {}\n+  virtual ~ExtensionTtsPlatformImplMac();\n \n-  NSSpeechSynthesizer* speech_synthesizer_;\n+  scoped_nsobject<NSSpeechSynthesizer> speech_synthesizer_;\n+  scoped_nsobject<ChromeTtsDelegate> delegate_;\n+  int utterance_id_;\n+  std::string utterance_;\n+  bool sent_start_event_;\n \n   friend struct DefaultSingletonTraits<ExtensionTtsPlatformImplMac>;\n \n@@ -48,32 +75,35 @@ virtual bool Speak(\n }\n \n bool ExtensionTtsPlatformImplMac::Speak(\n+    int utterance_id,\n     const std::string& utterance,\n-    const std::string& language,\n-    const std::string& gender,\n-    double rate,\n-    double pitch,\n-    double volume) {\n-  // NSSpeechSynthesizer equivalents for kGenderKey and kLanguageNameKey do\n-  // not exist and thus are not supported.\n-\n-  if (rate >= 0.0) {\n-    // The TTS api defines rate via words per minute.\n+    const std::string& lang,\n+    const UtteranceContinuousParameters& params) {\n+  utterance_id_ = utterance_id;\n+  sent_start_event_ = false;\n+\n+  // TODO: convert SSML to SAPI xml. http://crbug.com/88072\n+  utterance_ = utterance;\n+\n+  // TODO: support languages other than the default: crbug.com/88059\n+\n+  if (params.rate >= 0.0) {\n+    // The TTS api defines rate via words per minute. Let 200 be the default.\n     [speech_synthesizer_\n-        setObject:[NSNumber numberWithInt:rate * 400]\n+        setObject:[NSNumber numberWithInt:params.rate * 200]\n         forProperty:NSSpeechRateProperty error:nil];\n   }\n \n-  if (pitch >= 0.0) {\n+  if (params.pitch >= 0.0) {\n     // The TTS api allows an approximate range of 30 to 65 for speech pitch.\n     [speech_synthesizer_\n-        setObject: [NSNumber numberWithInt:(pitch * 35 + 30)]\n+        setObject: [NSNumber numberWithInt:(params.pitch * 17 + 30)]\n         forProperty:NSSpeechPitchBaseProperty error:nil];\n   }\n \n-  if (volume >= 0.0) {\n+  if (params.volume >= 0.0) {\n     [speech_synthesizer_\n-        setObject: [NSNumber numberWithFloat:volume]\n+        setObject: [NSNumber numberWithFloat:params.volume]\n         forProperty:NSSpeechVolumeProperty error:nil];\n   }\n \n@@ -90,11 +120,73 @@ virtual bool Speak(\n   return [speech_synthesizer_ isSpeaking];\n }\n \n+bool ExtensionTtsPlatformImplMac::SendsEvent(TtsEventType event_type) {\n+  return (event_type == TTS_EVENT_START ||\n+          event_type == TTS_EVENT_END ||\n+          event_type == TTS_EVENT_WORD ||\n+          event_type == TTS_EVENT_ERROR);\n+}\n+\n+void ExtensionTtsPlatformImplMac::OnSpeechEvent(\n+    TtsEventType event_type,\n+    int char_index,\n+    const std::string& error_message) {\n+  if (event_type == TTS_EVENT_END)\n+    char_index = utterance_.size();\n+  ExtensionTtsController* controller = ExtensionTtsController::GetInstance();\n+  if (event_type == TTS_EVENT_WORD && !sent_start_event_) {\n+    controller->OnTtsEvent(\n+        utterance_id_, TTS_EVENT_START, 0, \""\"");\n+    sent_start_event_ = true;\n+  }\n+  controller->OnTtsEvent(\n+      utterance_id_, event_type, char_index, error_message);\n+}\n+\n ExtensionTtsPlatformImplMac::ExtensionTtsPlatformImplMac() {\n-  speech_synthesizer_ = [[NSSpeechSynthesizer alloc] init];\n+  utterance_id_ = -1;\n+  sent_start_event_ = true;\n+  speech_synthesizer_.reset([[NSSpeechSynthesizer alloc] init]);\n+\n+  delegate_.reset([[ChromeTtsDelegate alloc] initWithPlatformImplMac:this]);\n+  [speech_synthesizer_ setDelegate:delegate_];\n+}\n+\n+ExtensionTtsPlatformImplMac::~ExtensionTtsPlatformImplMac() {\n+  [speech_synthesizer_ setDelegate:nil];\n }\n \n // static\n ExtensionTtsPlatformImplMac* ExtensionTtsPlatformImplMac::GetInstance() {\n   return Singleton<ExtensionTtsPlatformImplMac>::get();\n }\n+\n+@implementation ChromeTtsDelegate\n+\n+- (id)initWithPlatformImplMac:(ExtensionTtsPlatformImplMac*)ttsImplMac {\n+  if ((self = [super init])) {\n+    ttsImplMac_ = ttsImplMac;\n+  }\n+  return self;\n+}\n+\n+- (void)speechSynthesizer:(NSSpeechSynthesizer*)sender\n+        didFinishSpeaking:(BOOL)finished_speaking {\n+  ttsImplMac_->OnSpeechEvent(TTS_EVENT_END, 0, \""\"");\n+}\n+\n+- (void)speechSynthesizer:(NSSpeechSynthesizer*)sender\n+            willSpeakWord:(NSRange)character_range\n+                 ofString:(NSString*)string {\n+  ttsImplMac_->OnSpeechEvent(TTS_EVENT_WORD, character_range.location, \""\"");\n+}\n+\n+- (void)speechSynthesizer:(NSSpeechSynthesizer*)sender\n+ didEncounterErrorAtIndex:(NSUInteger)character_index\n+                 ofString:(NSString*)string\n+                  message:(NSString*)message {\n+  std::string message_utf8 = base::SysNSStringToUTF8(message);\n+  ttsImplMac_->OnSpeechEvent(TTS_EVENT_ERROR, character_index, message_utf8);\n+}\n+\n+@end""}<_**next**_>{""sha"": ""03578e35f4bc383bcaa945cfce68d0bdd68f4f3a"", ""filename"": ""chrome/browser/extensions/extension_tts_api_platform.cc"", ""status"": ""added"", ""additions"": 19, ""deletions"": 0, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_platform.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_platform.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_api_platform.cc?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,19 @@\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""chrome/browser/extensions/extension_tts_api_platform.h\""\n+\n+#include <string>\n+\n+std::string ExtensionTtsPlatformImpl::error() {\n+  return error_;\n+}\n+\n+void ExtensionTtsPlatformImpl::clear_error() {\n+  error_ = std::string();\n+}\n+\n+void ExtensionTtsPlatformImpl::set_error(const std::string& error) {\n+  error_ = error;\n+}""}<_**next**_>{""sha"": ""f26422f58dc2003ac7eb7bbc3adc0a7a6af0c171"", ""filename"": ""chrome/browser/extensions/extension_tts_api_platform.h"", ""status"": ""added"", ""additions"": 59, ""deletions"": 0, ""changes"": 59, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_platform.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_platform.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_api_platform.h?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,59 @@\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_API_PLATFORM_H_\n+#define CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_API_PLATFORM_H_\n+\n+#include <string>\n+\n+#include \""chrome/browser/extensions/extension_tts_api_controller.h\""\n+\n+// Abstract class that defines the native platform TTS interface,\n+// subclassed by specific implementations on Win, Mac, etc.\n+class ExtensionTtsPlatformImpl {\n+ public:\n+  static ExtensionTtsPlatformImpl* GetInstance();\n+\n+  // Returns true if this platform implementation is supported and available.\n+  virtual bool PlatformImplAvailable() = 0;\n+\n+  // Speak the given utterance with the given parameters if possible,\n+  // and return true on success. Utterance will always be nonempty.\n+  // If rate, pitch, or volume are -1.0, they will be ignored.\n+  //\n+  // The ExtensionTtsController will only try to speak one utterance at\n+  // a time. If it wants to interrupt speech, it will always call Stop\n+  // before speaking again.\n+  virtual bool Speak(\n+      int utterance_id,\n+      const std::string& utterance,\n+      const std::string& lang,\n+      const UtteranceContinuousParameters& params) = 0;\n+\n+  // Stop speaking immediately and return true on success.\n+  virtual bool StopSpeaking() = 0;\n+\n+  // Return true if this platform implementation will fire the given event.\n+  // All platform implementations must fire the TTS_EVENT_END event at a\n+  // minimum.\n+  virtual bool SendsEvent(TtsEventType event_type) = 0;\n+\n+  // Return the gender of the voice, should be either \""male\"" or \""female\""\n+  // if known, otherwise the empty string.\n+  virtual std::string gender() { return std::string(); }\n+\n+  virtual std::string error();\n+  virtual void clear_error();\n+  virtual void set_error(const std::string& error);\n+\n+ protected:\n+  ExtensionTtsPlatformImpl() {}\n+  virtual ~ExtensionTtsPlatformImpl() {}\n+\n+  std::string error_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(ExtensionTtsPlatformImpl);\n+};\n+\n+#endif  // CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_API_PLATFORM_H_""}<_**next**_>{""sha"": ""8884966ec1a27a1b1a2045e0dbfab70a28a77bd4"", ""filename"": ""chrome/browser/extensions/extension_tts_api_util.cc"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 17, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/3768ee10e91e95f4ff90bbe8177ffa407725d955/chrome/browser/extensions/extension_tts_api_util.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3768ee10e91e95f4ff90bbe8177ffa407725d955/chrome/browser/extensions/extension_tts_api_util.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_api_util.cc?ref=3768ee10e91e95f4ff90bbe8177ffa407725d955"", ""patch"": ""@@ -1,17 +0,0 @@\n-// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-\n-#include \""chrome/browser/extensions/extension_tts_api_util.h\""\n-\n-namespace extension_tts_api_util {\n-\n-const char kVoiceNameKey[] = \""voiceName\"";\n-const char kLocaleKey[] = \""locale\"";\n-const char kGenderKey[] = \""gender\"";\n-const char kRateKey[] = \""rate\"";\n-const char kPitchKey[] = \""pitch\"";\n-const char kVolumeKey[] = \""volume\"";\n-const char kEnqueueKey[] = \""enqueue\"";\n-\n-}  // namespace extension_tts_api_util.""}<_**next**_>{""sha"": ""4ca782c0b9d502bca2ec3a1e9ced4cbe9cecc5d9"", ""filename"": ""chrome/browser/extensions/extension_tts_api_util.h"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 23, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/3768ee10e91e95f4ff90bbe8177ffa407725d955/chrome/browser/extensions/extension_tts_api_util.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3768ee10e91e95f4ff90bbe8177ffa407725d955/chrome/browser/extensions/extension_tts_api_util.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_api_util.h?ref=3768ee10e91e95f4ff90bbe8177ffa407725d955"", ""patch"": ""@@ -1,23 +0,0 @@\n-// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-\n-#ifndef CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_API_UTIL_H_\n-#define CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_API_UTIL_H_\n-\n-#include <string>\n-\n-#include \""base/values.h\""\n-\n-namespace extension_tts_api_util {\n-\n-extern const char kVoiceNameKey[];\n-extern const char kLocaleKey[];\n-extern const char kGenderKey[];\n-extern const char kRateKey[];\n-extern const char kPitchKey[];\n-extern const char kVolumeKey[];\n-extern const char kEnqueueKey[];\n-\n-}  // namespace extension_tts_api_util.\n-#endif  // CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_API_UTIL_H_""}<_**next**_>{""sha"": ""7fe146f7fdc5eb2382bb6c717a4ae3848e3a99f5"", ""filename"": ""chrome/browser/extensions/extension_tts_api_win.cc"", ""status"": ""modified"", ""additions"": 118, ""deletions"": 31, ""changes"": 149, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_api_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_api_win.cc?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -2,44 +2,56 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-#include \""chrome/browser/extensions/extension_tts_api.h\""\n-\n-#include <atlbase.h>\n-#include <atlcom.h>\n+#include <math.h>\n #include <sapi.h>\n \n #include \""base/memory/singleton.h\""\n #include \""base/string_number_conversions.h\""\n #include \""base/utf_string_conversions.h\""\n #include \""base/values.h\""\n #include \""base/win/scoped_comptr.h\""\n-\n-namespace util = extension_tts_api_util;\n+#include \""chrome/browser/extensions/extension_tts_api_controller.h\""\n+#include \""chrome/browser/extensions/extension_tts_api_platform.h\""\n \n class ExtensionTtsPlatformImplWin : public ExtensionTtsPlatformImpl {\n  public:\n+  virtual bool PlatformImplAvailable() {\n+    return true;\n+  }\n+\n   virtual bool Speak(\n+      int utterance_id,\n       const std::string& utterance,\n-      const std::string& language,\n-      const std::string& gender,\n-      double rate,\n-      double pitch,\n-      double volume);\n+      const std::string& lang,\n+      const UtteranceContinuousParameters& params);\n \n   virtual bool StopSpeaking();\n \n   virtual bool IsSpeaking();\n \n+  virtual bool SendsEvent(TtsEventType event_type);\n+\n   // Get the single instance of this class.\n   static ExtensionTtsPlatformImplWin* GetInstance();\n \n+  static void __stdcall SpeechEventCallback(WPARAM w_param, LPARAM l_param);\n+\n  private:\n   ExtensionTtsPlatformImplWin();\n   virtual ~ExtensionTtsPlatformImplWin() {}\n \n+  void OnSpeechEvent();\n+\n   base::win::ScopedComPtr<ISpVoice> speech_synthesizer_;\n   bool paused_;\n \n+  // These apply to the current utterance only.\n+  std::wstring utterance_;\n+  int utterance_id_;\n+  int prefix_len_;\n+  ULONG stream_number_;\n+  int char_position_;\n+\n   friend struct DefaultSingletonTraits<ExtensionTtsPlatformImplWin>;\n \n   DISALLOW_COPY_AND_ASSIGN(ExtensionTtsPlatformImplWin);\n@@ -51,48 +63,61 @@ ExtensionTtsPlatformImpl* ExtensionTtsPlatformImpl::GetInstance() {\n }\n \n bool ExtensionTtsPlatformImplWin::Speak(\n+    int utterance_id,\n     const std::string& src_utterance,\n-    const std::string& language,\n-    const std::string& gender,\n-    double rate,\n-    double pitch,\n-    double volume) {\n-  std::wstring utterance = UTF8ToUTF16(src_utterance);\n+    const std::string& lang,\n+    const UtteranceContinuousParameters& params) {\n+  std::wstring prefix;\n+  std::wstring suffix;\n \n   if (!speech_synthesizer_)\n     return false;\n \n-  // Speech API equivalents for kGenderKey and kLanguageNameKey do not\n-  // exist and thus are not supported.\n+  // TODO(dmazzoni): support languages other than the default: crbug.com/88059\n \n-  if (rate >= 0.0) {\n-    // The TTS api allows a range of -10 to 10 for speech rate.\n-    speech_synthesizer_->SetRate(static_cast<int32>(rate * 20 - 10));\n+  if (params.rate >= 0.0) {\n+    // Map our multiplicative range of 0.1x to 10.0x onto Microsoft's\n+    // linear range of -10 to 10:\n+    //   0.1 -> -10\n+    //   1.0 -> 0\n+    //  10.0 -> 10\n+    speech_synthesizer_->SetRate(static_cast<int32>(10 * log10(params.rate)));\n   }\n \n-  if (pitch >= 0.0) {\n+  if (params.pitch >= 0.0) {\n     // The TTS api allows a range of -10 to 10 for speech pitch.\n     // TODO(dtseng): cleanup if we ever use any other properties that\n     // require xml.\n     std::wstring pitch_value =\n-        base::IntToString16(static_cast<int>(pitch * 20 - 10));\n-    utterance = L\""<pitch absmiddle=\\\""\"" + pitch_value + L\""\\\"">\"" +\n-        utterance + L\""</pitch>\"";\n+        base::IntToString16(static_cast<int>(params.pitch * 10 - 10));\n+    prefix = L\""<pitch absmiddle=\\\""\"" + pitch_value + L\""\\\"">\"";\n+    suffix = L\""</pitch>\"";\n   }\n \n-  if (volume >= 0.0) {\n+  if (params.volume >= 0.0) {\n     // The TTS api allows a range of 0 to 100 for speech volume.\n-    speech_synthesizer_->SetVolume(static_cast<uint16>(volume * 100));\n+    speech_synthesizer_->SetVolume(static_cast<uint16>(params.volume * 100));\n   }\n \n   if (paused_) {\n     speech_synthesizer_->Resume();\n     paused_ = false;\n   }\n-  speech_synthesizer_->Speak(\n-      utterance.c_str(), SPF_ASYNC | SPF_PURGEBEFORESPEAK, NULL);\n \n-  return true;\n+  // TODO(dmazzoni): convert SSML to SAPI xml. http://crbug.com/88072\n+\n+  utterance_ = UTF8ToWide(src_utterance);\n+  utterance_id_ = utterance_id;\n+  char_position_ = 0;\n+  std::wstring merged_utterance = prefix + utterance_ + suffix;\n+  prefix_len_ = prefix.size();\n+\n+\n+  HRESULT result = speech_synthesizer_->Speak(\n+      merged_utterance.c_str(),\n+      SPF_ASYNC | SPF_PURGEBEFORESPEAK,\n+      &stream_number_);\n+  return (result == S_OK);\n }\n \n bool ExtensionTtsPlatformImplWin::StopSpeaking() {\n@@ -117,6 +142,51 @@ bool ExtensionTtsPlatformImplWin::IsSpeaking() {\n   return false;\n }\n \n+bool ExtensionTtsPlatformImplWin::SendsEvent(TtsEventType event_type) {\n+  return (event_type == TTS_EVENT_START ||\n+          event_type == TTS_EVENT_END ||\n+          event_type == TTS_EVENT_MARKER ||\n+          event_type == TTS_EVENT_WORD ||\n+          event_type == TTS_EVENT_SENTENCE);\n+}\n+\n+void ExtensionTtsPlatformImplWin::OnSpeechEvent() {\n+  ExtensionTtsController* controller = ExtensionTtsController::GetInstance();\n+  SPEVENT event;\n+  while (S_OK == speech_synthesizer_->GetEvents(1, &event, NULL)) {\n+    if (event.ulStreamNum != stream_number_)\n+      continue;\n+\n+    switch (event.eEventId) {\n+    case SPEI_START_INPUT_STREAM:\n+      controller->OnTtsEvent(\n+          utterance_id_, TTS_EVENT_START, 0, std::string());\n+      break;\n+    case SPEI_END_INPUT_STREAM:\n+      char_position_ = utterance_.size();\n+      controller->OnTtsEvent(\n+          utterance_id_, TTS_EVENT_END, char_position_, std::string());\n+      break;\n+    case SPEI_TTS_BOOKMARK:\n+      controller->OnTtsEvent(\n+          utterance_id_, TTS_EVENT_MARKER, char_position_, std::string());\n+      break;\n+    case SPEI_WORD_BOUNDARY:\n+      char_position_ = static_cast<ULONG>(event.lParam) - prefix_len_;\n+      controller->OnTtsEvent(\n+          utterance_id_, TTS_EVENT_WORD, char_position_,\n+          std::string());\n+      break;\n+    case SPEI_SENTENCE_BOUNDARY:\n+      char_position_ = static_cast<ULONG>(event.lParam) - prefix_len_;\n+      controller->OnTtsEvent(\n+          utterance_id_, TTS_EVENT_SENTENCE, char_position_,\n+          std::string());\n+      break;\n+    }\n+  }\n+}\n+\n ExtensionTtsPlatformImplWin::ExtensionTtsPlatformImplWin()\n   : speech_synthesizer_(NULL),\n     paused_(false) {\n@@ -126,9 +196,26 @@ ExtensionTtsPlatformImplWin::ExtensionTtsPlatformImplWin()\n       CLSCTX_SERVER,\n       IID_ISpVoice,\n       reinterpret_cast<void**>(&speech_synthesizer_));\n+  if (speech_synthesizer_) {\n+    ULONGLONG event_mask =\n+        SPFEI(SPEI_START_INPUT_STREAM) |\n+        SPFEI(SPEI_TTS_BOOKMARK) |\n+        SPFEI(SPEI_WORD_BOUNDARY) |\n+        SPFEI(SPEI_SENTENCE_BOUNDARY) |\n+        SPFEI(SPEI_END_INPUT_STREAM);\n+    speech_synthesizer_->SetInterest(event_mask, event_mask);\n+    speech_synthesizer_->SetNotifyCallbackFunction(\n+        ExtensionTtsPlatformImplWin::SpeechEventCallback, 0, 0);\n+  }\n }\n \n // static\n ExtensionTtsPlatformImplWin* ExtensionTtsPlatformImplWin::GetInstance() {\n   return Singleton<ExtensionTtsPlatformImplWin>::get();\n }\n+\n+// static\n+void ExtensionTtsPlatformImplWin::SpeechEventCallback(\n+    WPARAM w_param, LPARAM l_param) {\n+  GetInstance()->OnSpeechEvent();\n+}""}<_**next**_>{""sha"": ""e1e385fd026ad567f6e75a647f0214325fca9f5d"", ""filename"": ""chrome/browser/extensions/extension_tts_apitest.cc"", ""status"": ""modified"", ""additions"": 167, ""deletions"": 96, ""changes"": 263, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_apitest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_apitest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_apitest.cc?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,9 +1,13 @@\n-// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n+\n #include \""base/command_line.h\""\n+#include \""base/task.h\""\n #include \""chrome/browser/extensions/extension_apitest.h\""\n #include \""chrome/browser/extensions/extension_tts_api.h\""\n+#include \""chrome/browser/extensions/extension_tts_api_controller.h\""\n+#include \""chrome/browser/extensions/extension_tts_api_platform.h\""\n #include \""chrome/common/chrome_switches.h\""\n #include \""testing/gmock/include/gmock/gmock.h\""\n #include \""testing/gtest/include/gtest/gtest.h\""\n@@ -27,19 +31,90 @@ using ::testing::_;\n \n class MockExtensionTtsPlatformImpl : public ExtensionTtsPlatformImpl {\n  public:\n-  MOCK_METHOD6(Speak,\n-               bool(const std::string& utterance,\n-                    const std::string& locale,\n-                    const std::string& gender,\n-                    double rate,\n-                    double pitch,\n-                    double volume));\n+  MockExtensionTtsPlatformImpl()\n+      : ALLOW_THIS_IN_INITIALIZER_LIST(method_factory_(this)) {}\n+\n+  virtual bool PlatformImplAvailable() {\n+    return true;\n+  }\n+\n+  virtual bool SendsEvent(TtsEventType event_type) {\n+    return (event_type == TTS_EVENT_END ||\n+            event_type == TTS_EVENT_WORD);\n+  }\n+\n+\n+  MOCK_METHOD4(Speak,\n+               bool(int utterance_id,\n+                    const std::string& utterance,\n+                    const std::string& lang,\n+                    const UtteranceContinuousParameters& params));\n   MOCK_METHOD0(StopSpeaking, bool(void));\n-  MOCK_METHOD0(IsSpeaking, bool(void));\n \n   void SetErrorToEpicFail() {\n     set_error(\""epic fail\"");\n   }\n+\n+  void SendEndEvent(int utterance_id,\n+                    const std::string& utterance,\n+                    const std::string& lang,\n+                    const UtteranceContinuousParameters& params) {\n+    MessageLoop::current()->PostDelayedTask(\n+        FROM_HERE, method_factory_.NewRunnableMethod(\n+            &MockExtensionTtsPlatformImpl::SendEvent,\n+            false, utterance_id, TTS_EVENT_END, utterance.size(),\n+            std::string()),\n+        0);\n+  }\n+\n+  void SendEndEventWhenQueueNotEmpty(\n+      int utterance_id,\n+      const std::string& utterance,\n+      const std::string& lang,\n+      const UtteranceContinuousParameters& params) {\n+    MessageLoop::current()->PostDelayedTask(\n+        FROM_HERE, method_factory_.NewRunnableMethod(\n+            &MockExtensionTtsPlatformImpl::SendEvent,\n+            true, utterance_id, TTS_EVENT_END, utterance.size(), std::string()),\n+        0);\n+  }\n+\n+  void SendWordEvents(int utterance_id,\n+                      const std::string& utterance,\n+                      const std::string& lang,\n+                      const UtteranceContinuousParameters& params) {\n+    for (int i = 0; i < static_cast<int>(utterance.size()); i++) {\n+      if (i == 0 || utterance[i - 1] == ' ') {\n+        MessageLoop::current()->PostDelayedTask(\n+            FROM_HERE, method_factory_.NewRunnableMethod(\n+                &MockExtensionTtsPlatformImpl::SendEvent,\n+                false, utterance_id, TTS_EVENT_WORD, i,\n+                std::string()),\n+            0);\n+      }\n+    }\n+  }\n+\n+  void SendEvent(bool wait_for_non_empty_queue,\n+                 int utterance_id,\n+                 TtsEventType event_type,\n+                 int char_index,\n+                 const std::string& message) {\n+    ExtensionTtsController* controller = ExtensionTtsController::GetInstance();\n+    if (wait_for_non_empty_queue && controller->QueueSize() == 0) {\n+      MessageLoop::current()->PostDelayedTask(\n+          FROM_HERE, method_factory_.NewRunnableMethod(\n+              &MockExtensionTtsPlatformImpl::SendEvent,\n+              true, utterance_id, event_type, char_index, message),\n+          100);\n+      return;\n+    }\n+\n+    controller->OnTtsEvent(utterance_id, event_type, char_index, message);\n+  }\n+\n+ private:\n+  ScopedRunnableMethodFactory<MockExtensionTtsPlatformImpl> method_factory_;\n };\n \n class TtsApiTest : public ExtensionApiTest {\n@@ -63,49 +138,29 @@ IN_PROC_BROWSER_TEST_F(TtsApiTest, PlatformSpeakFinishesImmediately) {\n   InSequence s;\n   EXPECT_CALL(mock_platform_impl_, StopSpeaking())\n       .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, Speak(_, _, _, _, _, _))\n-      .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, IsSpeaking())\n-      .WillOnce(Return(false));\n-  ASSERT_TRUE(RunExtensionTest(\""tts/speak_once\"")) << message_;\n-}\n-\n-IN_PROC_BROWSER_TEST_F(TtsApiTest, PlatformSpeakKeepsSpeakingTwice) {\n-  InSequence s;\n-  EXPECT_CALL(mock_platform_impl_, StopSpeaking())\n-      .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, Speak(_, _, _, _, _, _))\n-      .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, IsSpeaking())\n-      .WillOnce(Return(true))\n-      .WillOnce(Return(true))\n-      .WillOnce(Return(false));\n+  EXPECT_CALL(mock_platform_impl_, Speak(_, _, _, _))\n+      .WillOnce(DoAll(\n+          Invoke(&mock_platform_impl_,\n+                 &MockExtensionTtsPlatformImpl::SendEndEvent),\n+          Return(true)));\n   ASSERT_TRUE(RunExtensionTest(\""tts/speak_once\"")) << message_;\n }\n \n IN_PROC_BROWSER_TEST_F(TtsApiTest, PlatformSpeakInterrupt) {\n-  // One utterances starts speaking, and then a second interrupts.\n+  // One utterance starts speaking, and then a second interrupts.\n   InSequence s;\n   EXPECT_CALL(mock_platform_impl_, StopSpeaking())\n       .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, Speak(\""text 1\"", _, _, _, _, _))\n+  EXPECT_CALL(mock_platform_impl_, Speak(_, \""text 1\"", _, _))\n       .WillOnce(Return(true));\n-\n-  // Ensure that the first utterance keeps going until it's interrupted.\n-  EXPECT_CALL(mock_platform_impl_, IsSpeaking())\n-      .Times(AnyNumber())\n-      .WillRepeatedly(Return(true));\n-\n-  // Expect the second utterance and allow it to continue for two calls to\n-  // IsSpeaking and then finish successfully.\n+  // Expect the second utterance and allow it to finish.\n   EXPECT_CALL(mock_platform_impl_, StopSpeaking())\n       .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, Speak(\""text 2\"", _, _, _, _, _))\n-      .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, IsSpeaking())\n-      .WillOnce(Return(true))\n-      .WillOnce(Return(true))\n-      .WillOnce(Return(false));\n+  EXPECT_CALL(mock_platform_impl_, Speak(_, \""text 2\"", _, _))\n+      .WillOnce(DoAll(\n+          Invoke(&mock_platform_impl_,\n+                 &MockExtensionTtsPlatformImpl::SendEndEvent),\n+          Return(true)));\n   ASSERT_TRUE(RunExtensionTest(\""tts/interrupt\"")) << message_;\n }\n \n@@ -115,94 +170,110 @@ IN_PROC_BROWSER_TEST_F(TtsApiTest, PlatformSpeakQueueInterrupt) {\n   InSequence s;\n   EXPECT_CALL(mock_platform_impl_, StopSpeaking())\n       .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, Speak(\""text 1\"", _, _, _, _, _))\n+  EXPECT_CALL(mock_platform_impl_, Speak(_, \""text 1\"", _, _))\n       .WillOnce(Return(true));\n-\n-  // Ensure that the first utterance keeps going until it's interrupted.\n-  EXPECT_CALL(mock_platform_impl_, IsSpeaking())\n-      .Times(AnyNumber())\n-      .WillRepeatedly(Return(true));\n-\n-  // Expect the third utterance and allow it to continue for two calls to\n-  // IsSpeaking and then finish successfully.\n+  // Don't expect the second utterance, because it's queued up and the\n+  // first never finishes.\n+  // Expect the third utterance and allow it to finish successfully.\n   EXPECT_CALL(mock_platform_impl_, StopSpeaking())\n       .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, Speak(\""text 3\"", _, _, _, _, _))\n-      .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, IsSpeaking())\n-      .WillOnce(Return(true))\n-      .WillOnce(Return(true))\n-      .WillOnce(Return(false));\n+  EXPECT_CALL(mock_platform_impl_, Speak(_, \""text 3\"", _, _))\n+      .WillOnce(DoAll(\n+          Invoke(&mock_platform_impl_,\n+                 &MockExtensionTtsPlatformImpl::SendEndEvent),\n+          Return(true)));\n   ASSERT_TRUE(RunExtensionTest(\""tts/queue_interrupt\"")) << message_;\n }\n \n IN_PROC_BROWSER_TEST_F(TtsApiTest, PlatformSpeakEnqueue) {\n   InSequence s;\n   EXPECT_CALL(mock_platform_impl_, StopSpeaking())\n       .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, Speak(\""text 1\"", _, _, _, _, _))\n-      .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, IsSpeaking())\n-      .WillOnce(Return(true))\n-      .WillOnce(Return(true))\n-      .WillOnce(Return(false));\n-  EXPECT_CALL(mock_platform_impl_, Speak(\""text 2\"", _, _, _, _, _))\n-      .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, IsSpeaking())\n-      .WillOnce(Return(true))\n-      .WillOnce(Return(true))\n-      .WillOnce(Return(false));\n+  EXPECT_CALL(mock_platform_impl_, Speak(_, \""text 1\"", _, _))\n+      .WillOnce(DoAll(\n+          Invoke(&mock_platform_impl_,\n+                 &MockExtensionTtsPlatformImpl::SendEndEventWhenQueueNotEmpty),\n+          Return(true)));\n+  EXPECT_CALL(mock_platform_impl_, Speak(_, \""text 2\"", _, _))\n+      .WillOnce(DoAll(\n+          Invoke(&mock_platform_impl_,\n+                 &MockExtensionTtsPlatformImpl::SendEndEvent),\n+          Return(true)));\n   ASSERT_TRUE(RunExtensionTest(\""tts/enqueue\"")) << message_;\n }\n \n IN_PROC_BROWSER_TEST_F(TtsApiTest, PlatformSpeakError) {\n   InSequence s;\n   EXPECT_CALL(mock_platform_impl_, StopSpeaking())\n       .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, Speak(_, _, _, _, _, _))\n-      .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, IsSpeaking())\n-      .WillOnce(Return(false));\n-  EXPECT_CALL(mock_platform_impl_, StopSpeaking())\n-      .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, Speak(_, _, _, _, _, _))\n+  EXPECT_CALL(mock_platform_impl_, Speak(_, \""first try\"", _, _))\n       .WillOnce(DoAll(\n           InvokeWithoutArgs(\n               CreateFunctor(&mock_platform_impl_,\n                             &MockExtensionTtsPlatformImpl::SetErrorToEpicFail)),\n           Return(false)));\n   EXPECT_CALL(mock_platform_impl_, StopSpeaking())\n       .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, Speak(_, _, _, _, _, _))\n-      .WillOnce(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, IsSpeaking())\n-      .WillOnce(Return(false));\n+  EXPECT_CALL(mock_platform_impl_, Speak(_, \""second try\"", _, _))\n+      .WillOnce(DoAll(\n+          Invoke(&mock_platform_impl_,\n+                 &MockExtensionTtsPlatformImpl::SendEndEvent),\n+          Return(true)));\n   ASSERT_TRUE(RunExtensionTest(\""tts/speak_error\"")) << message_;\n }\n \n-#if defined(OS_WIN)\n-// Flakily fails on Windows: http://crbug.com/70198\n-#define MAYBE_Provide FLAKY_Provide\n-#else\n-#define MAYBE_Provide Provide\n-#endif\n-IN_PROC_BROWSER_TEST_F(TtsApiTest, MAYBE_Provide) {\n+IN_PROC_BROWSER_TEST_F(TtsApiTest, PlatformWordCallbacks) {\n+  InSequence s;\n+  EXPECT_CALL(mock_platform_impl_, StopSpeaking())\n+      .WillOnce(Return(true));\n+  EXPECT_CALL(mock_platform_impl_, Speak(_, \""one two three\"", _, _))\n+      .WillOnce(DoAll(\n+          Invoke(&mock_platform_impl_,\n+                 &MockExtensionTtsPlatformImpl::SendWordEvents),\n+          Invoke(&mock_platform_impl_,\n+                 &MockExtensionTtsPlatformImpl::SendEndEvent),\n+          Return(true)));\n+  ASSERT_TRUE(RunExtensionTest(\""tts/word_callbacks\"")) << message_;\n+}\n+\n+IN_PROC_BROWSER_TEST_F(TtsApiTest, RegisterEngine) {\n   EXPECT_CALL(mock_platform_impl_, StopSpeaking())\n       .WillRepeatedly(Return(true));\n-  EXPECT_CALL(mock_platform_impl_, IsSpeaking())\n-      .WillRepeatedly(Return(false));\n \n   {\n     InSequence s;\n-    EXPECT_CALL(mock_platform_impl_, Speak(\""native speech\"", _, _, _, _, _))\n-        .WillOnce(Return(true));\n-    EXPECT_CALL(mock_platform_impl_, Speak(\""native speech 2\"", _, _, _, _, _))\n-        .WillOnce(Return(true));\n-    EXPECT_CALL(mock_platform_impl_, Speak(\""native speech 3\"", _, _, _, _, _))\n-        .WillOnce(Return(true));\n+    EXPECT_CALL(mock_platform_impl_, Speak(_, \""native speech\"", _, _))\n+      .WillOnce(DoAll(\n+          Invoke(&mock_platform_impl_,\n+                 &MockExtensionTtsPlatformImpl::SendEndEvent),\n+          Return(true)));\n+    EXPECT_CALL(mock_platform_impl_, Speak(_, \""native speech 2\"", _, _))\n+      .WillOnce(DoAll(\n+          Invoke(&mock_platform_impl_,\n+                 &MockExtensionTtsPlatformImpl::SendEndEvent),\n+          Return(true)));\n+    EXPECT_CALL(mock_platform_impl_, Speak(_, \""native speech 3\"", _, _))\n+      .WillOnce(DoAll(\n+          Invoke(&mock_platform_impl_,\n+                 &MockExtensionTtsPlatformImpl::SendEndEvent),\n+          Return(true)));\n   }\n \n-  ASSERT_TRUE(RunExtensionTest(\""tts/provide\"")) << message_;\n+  ASSERT_TRUE(RunExtensionTest(\""tts_engine/register_engine\"")) << message_;\n+}\n+\n+IN_PROC_BROWSER_TEST_F(TtsApiTest, EngineError) {\n+  EXPECT_CALL(mock_platform_impl_, StopSpeaking())\n+      .WillRepeatedly(Return(true));\n+\n+  ASSERT_TRUE(RunExtensionTest(\""tts_engine/engine_error\"")) << message_;\n+}\n+\n+IN_PROC_BROWSER_TEST_F(TtsApiTest, EngineWordCallbacks) {\n+  EXPECT_CALL(mock_platform_impl_, StopSpeaking())\n+      .WillRepeatedly(Return(true));\n+\n+  ASSERT_TRUE(RunExtensionTest(\""tts_engine/engine_word_callbacks\"")) << message_;\n }\n \n #if defined(OS_CHROMEOS)""}<_**next**_>{""sha"": ""d69420fe9c02b13a5df6a61a42519c7129ab0950"", ""filename"": ""chrome/browser/extensions/extension_tts_engine_api.cc"", ""status"": ""added"", ""additions"": 260, ""deletions"": 0, ""changes"": 260, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_engine_api.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_engine_api.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_engine_api.cc?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,260 @@\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""chrome/browser/extensions/extension_tts_engine_api.h\""\n+\n+#include <string>\n+\n+#include \""base/json/json_writer.h\""\n+#include \""base/values.h\""\n+#include \""chrome/browser/extensions/extension_event_router.h\""\n+#include \""chrome/browser/extensions/extension_service.h\""\n+#include \""chrome/browser/extensions/extension_tts_api_constants.h\""\n+#include \""chrome/browser/extensions/extension_tts_api_controller.h\""\n+#include \""chrome/common/extensions/extension.h\""\n+\n+namespace constants = extension_tts_api_constants;\n+\n+namespace events {\n+const char kOnSpeak[] = \""experimental.ttsEngine.onSpeak\"";\n+const char kOnStop[] = \""experimental.ttsEngine.onStop\"";\n+};  // namespace events\n+\n+void GetExtensionVoices(Profile* profile, ListValue* result_voices) {\n+  ExtensionService* service = profile->GetExtensionService();\n+  DCHECK(service);\n+  ExtensionEventRouter* event_router = profile->GetExtensionEventRouter();\n+  DCHECK(event_router);\n+\n+  const ExtensionList* extensions = service->extensions();\n+  ExtensionList::const_iterator iter;\n+  for (iter = extensions->begin(); iter != extensions->end(); ++iter) {\n+    const Extension* extension = *iter;\n+\n+    if (!event_router->ExtensionHasEventListener(\n+            extension->id(), events::kOnSpeak) ||\n+        !event_router->ExtensionHasEventListener(\n+            extension->id(), events::kOnStop)) {\n+      continue;\n+    }\n+\n+    const std::vector<Extension::TtsVoice>& tts_voices =\n+        extension->tts_voices();\n+    for (size_t i = 0; i < tts_voices.size(); ++i) {\n+      const Extension::TtsVoice& voice = tts_voices[i];\n+      DictionaryValue* result_voice = new DictionaryValue();\n+      if (!voice.voice_name.empty())\n+        result_voice->SetString(constants::kVoiceNameKey, voice.voice_name);\n+      if (!voice.lang.empty())\n+        result_voice->SetString(constants::kLangKey, voice.lang);\n+      if (!voice.gender.empty())\n+        result_voice->SetString(constants::kGenderKey, voice.gender);\n+      result_voice->SetString(constants::kExtensionIdKey, extension->id());\n+\n+      ListValue* event_types = new ListValue();\n+      for (std::set<std::string>::const_iterator iter =\n+               voice.event_types.begin();\n+           iter != voice.event_types.end();\n+           ++iter) {\n+        event_types->Append(Value::CreateStringValue(*iter));\n+      }\n+      // If the extension sends end events, the controller will handle\n+      // queueing and send interrupted and cancelled events.\n+      if (voice.event_types.find(constants::kEventTypeEnd) !=\n+          voice.event_types.end()) {\n+        event_types->Append(\n+            Value::CreateStringValue(constants::kEventTypeCancelled));\n+        event_types->Append(Value::CreateStringValue(\n+            constants::kEventTypeInterrupted));\n+      }\n+\n+      result_voice->Set(constants::kEventTypesKey, event_types);\n+      result_voices->Append(result_voice);\n+    }\n+  }\n+}\n+\n+bool GetMatchingExtensionVoice(\n+    Utterance* utterance,\n+    const Extension** matching_extension,\n+    size_t* voice_index) {\n+  ExtensionService* service = utterance->profile()->GetExtensionService();\n+  DCHECK(service);\n+  ExtensionEventRouter* event_router =\n+      utterance->profile()->GetExtensionEventRouter();\n+  DCHECK(event_router);\n+\n+  *matching_extension = NULL;\n+  *voice_index = -1;\n+  const ExtensionList* extensions = service->extensions();\n+  ExtensionList::const_iterator iter;\n+  for (iter = extensions->begin(); iter != extensions->end(); ++iter) {\n+    const Extension* extension = *iter;\n+\n+    if (!event_router->ExtensionHasEventListener(\n+            extension->id(), events::kOnSpeak) ||\n+        !event_router->ExtensionHasEventListener(\n+            extension->id(), events::kOnStop)) {\n+      continue;\n+    }\n+\n+    if (!utterance->extension_id().empty() &&\n+        utterance->extension_id() != extension->id()) {\n+      continue;\n+    }\n+\n+    const std::vector<Extension::TtsVoice>& tts_voices =\n+        extension->tts_voices();\n+    for (size_t i = 0; i < tts_voices.size(); ++i) {\n+      const Extension::TtsVoice& voice = tts_voices[i];\n+      if (!voice.voice_name.empty() &&\n+          !utterance->voice_name().empty() &&\n+          voice.voice_name != utterance->voice_name()) {\n+        continue;\n+      }\n+      if (!voice.lang.empty() &&\n+          !utterance->lang().empty() &&\n+          voice.lang != utterance->lang()) {\n+        continue;\n+      }\n+      if (!voice.gender.empty() &&\n+          !utterance->gender().empty() &&\n+          voice.gender != utterance->gender()) {\n+        continue;\n+      }\n+      if (utterance->required_event_types().size() > 0) {\n+        bool has_all_required_event_types = true;\n+        for (std::set<std::string>::const_iterator iter =\n+                 utterance->required_event_types().begin();\n+             iter != utterance->required_event_types().end();\n+             ++iter) {\n+          if (voice.event_types.find(*iter) == voice.event_types.end()) {\n+            has_all_required_event_types = false;\n+            break;\n+          }\n+        }\n+        if (!has_all_required_event_types)\n+          continue;\n+      }\n+\n+      *matching_extension = extension;\n+      *voice_index = i;\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+void ExtensionTtsEngineSpeak(Utterance* utterance,\n+                             const Extension* extension,\n+                             size_t voice_index) {\n+  // See if the engine supports the \""end\"" event; if so, we can keep the\n+  // utterance around and track it. If not, we're finished with this\n+  // utterance now.\n+  const std::set<std::string> event_types =\n+      extension->tts_voices()[voice_index].event_types;\n+  bool sends_end_event =\n+      (event_types.find(constants::kEventTypeEnd) != event_types.end());\n+\n+  ListValue args;\n+  args.Set(0, Value::CreateStringValue(utterance->text()));\n+\n+  // Pass through most options to the speech engine, but remove some\n+  // that are handled internally.\n+  DictionaryValue* options = static_cast<DictionaryValue*>(\n+      utterance->options()->DeepCopy());\n+  if (options->HasKey(constants::kRequiredEventTypesKey))\n+    options->Remove(constants::kRequiredEventTypesKey, NULL);\n+  if (options->HasKey(constants::kDesiredEventTypesKey))\n+    options->Remove(constants::kDesiredEventTypesKey, NULL);\n+  if (sends_end_event && options->HasKey(constants::kEnqueueKey))\n+    options->Remove(constants::kEnqueueKey, NULL);\n+  if (options->HasKey(constants::kSrcIdKey))\n+    options->Remove(constants::kSrcIdKey, NULL);\n+  if (options->HasKey(constants::kIsFinalEventKey))\n+    options->Remove(constants::kIsFinalEventKey, NULL);\n+\n+  args.Set(1, options);\n+  args.Set(2, Value::CreateIntegerValue(utterance->id()));\n+  std::string json_args;\n+  base::JSONWriter::Write(&args, false, &json_args);\n+\n+  utterance->profile()->GetExtensionEventRouter()->DispatchEventToExtension(\n+      extension->id(),\n+      events::kOnSpeak,\n+      json_args,\n+      utterance->profile(),\n+      GURL());\n+}\n+\n+void ExtensionTtsEngineStop(Utterance* utterance) {\n+  utterance->profile()->GetExtensionEventRouter()->DispatchEventToExtension(\n+      utterance->extension_id(),\n+      events::kOnStop,\n+      \""[]\"",\n+      utterance->profile(),\n+      GURL());\n+}\n+\n+bool ExtensionTtsEngineSendTtsEventFunction::RunImpl() {\n+  int utterance_id;\n+  std::string error_message;\n+  EXTENSION_FUNCTION_VALIDATE(args_->GetInteger(0, &utterance_id));\n+\n+  DictionaryValue* event;\n+  EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &event));\n+\n+  std::string event_type;\n+  EXTENSION_FUNCTION_VALIDATE(\n+      event->GetString(constants::kEventTypeKey, &event_type));\n+\n+  int char_index = 0;\n+  if (event->HasKey(constants::kCharIndexKey)) {\n+    EXTENSION_FUNCTION_VALIDATE(\n+        event->GetInteger(constants::kCharIndexKey, &char_index));\n+  }\n+\n+  // Make sure the extension has included this event type in its manifest.\n+  bool event_type_allowed = false;\n+  const Extension* extension = GetExtension();\n+  for (size_t i = 0; i < extension->tts_voices().size(); i++) {\n+    const Extension::TtsVoice& voice = extension->tts_voices()[i];\n+    if (voice.event_types.find(event_type) != voice.event_types.end()) {\n+      event_type_allowed = true;\n+      break;\n+    }\n+  }\n+  if (!event_type_allowed) {\n+    error_ = constants::kErrorUndeclaredEventType;\n+    return false;\n+  }\n+\n+  ExtensionTtsController* controller = ExtensionTtsController::GetInstance();\n+  if (event_type == constants::kEventTypeStart) {\n+    controller->OnTtsEvent(\n+        utterance_id, TTS_EVENT_START, char_index, std::string());\n+  } else if (event_type == constants::kEventTypeEnd) {\n+    controller->OnTtsEvent(\n+        utterance_id, TTS_EVENT_END, char_index, std::string());\n+  } else if (event_type == constants::kEventTypeWord) {\n+    controller->OnTtsEvent(\n+        utterance_id, TTS_EVENT_WORD, char_index, std::string());\n+  } else if (event_type == constants::kEventTypeSentence) {\n+    controller->OnTtsEvent(\n+        utterance_id, TTS_EVENT_SENTENCE, char_index, std::string());\n+  } else if (event_type == constants::kEventTypeMarker) {\n+    controller->OnTtsEvent(\n+        utterance_id, TTS_EVENT_MARKER, char_index, std::string());\n+  } else if (event_type == constants::kEventTypeError) {\n+    std::string error_message;\n+    event->GetString(constants::kErrorMessageKey, &error_message);\n+    controller->OnTtsEvent(\n+        utterance_id, TTS_EVENT_ERROR, char_index, error_message);\n+  } else {\n+    EXTENSION_FUNCTION_VALIDATE(false);\n+  }\n+\n+  return true;\n+}""}<_**next**_>{""sha"": ""7c1493717b85428edb7e80b7091c68f5bbf2ee37"", ""filename"": ""chrome/browser/extensions/extension_tts_engine_api.h"", ""status"": ""added"", ""additions"": 45, ""deletions"": 0, ""changes"": 45, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_engine_api.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extension_tts_engine_api.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_tts_engine_api.h?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,45 @@\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_ENGINE_API_H_\n+#define CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_ENGINE_API_H_\n+\n+#include \""base/memory/singleton.h\""\n+#include \""chrome/browser/extensions/extension_function.h\""\n+\n+class Extension;\n+class Utterance;\n+\n+// Return a list of all available voices registered by extensions.\n+void GetExtensionVoices(Profile* profile, ListValue* result_voices);\n+\n+// Find the first extension with a tts_voices in its\n+// manifest that matches the speech parameters of this utterance.\n+// If found, store a pointer to the extension in |matching_extension| and\n+// the index of the voice within the extension in |voice_index| and\n+// return true.\n+bool GetMatchingExtensionVoice(Utterance* utterance,\n+                               const Extension** matching_extension,\n+                               size_t* voice_index);\n+\n+// Speak the given utterance by sending an event to the given TTS engine\n+// extension voice.\n+void ExtensionTtsEngineSpeak(Utterance* utterance,\n+                             const Extension* extension,\n+                             size_t voice_index);\n+\n+// Stop speaking the given utterance by sending an event to the extension\n+// associated with this utterance.\n+void ExtensionTtsEngineStop(Utterance* utterance);\n+\n+// Hidden/internal extension function used to allow TTS engine extensions\n+// to send events back to the client that's calling tts.speak().\n+class ExtensionTtsEngineSendTtsEventFunction : public SyncExtensionFunction {\n+ private:\n+  virtual ~ExtensionTtsEngineSendTtsEventFunction() {}\n+  virtual bool RunImpl() OVERRIDE;\n+  DECLARE_EXTENSION_FUNCTION_NAME(\""experimental.ttsEngine.sendTtsEvent\"")\n+};\n+\n+#endif  // CHROME_BROWSER_EXTENSIONS_EXTENSION_TTS_ENGINE_API_H_""}<_**next**_>{""sha"": ""feb7da2627f589b04bd1676fe232861d71c7b103"", ""filename"": ""chrome/browser/extensions/extensions_quota_service_unittest.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extensions_quota_service_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/browser/extensions/extensions_quota_service_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extensions_quota_service_unittest.cc?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,4 +1,4 @@\n-// Copyright (c) 2009 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n@@ -59,6 +59,7 @@ class MockFunction : public ExtensionFunction {\n   virtual void Destruct() const { delete this; }\n   virtual bool RunImpl() { return true; }\n   virtual void SendResponse(bool) { }\n+  virtual void SendNonFinalResponse() { }\n   virtual void HandleBadMessage() { }\n };\n ""}<_**next**_>{""sha"": ""dfe8fb47bbb66b4a3650276ba4612a1b2c01527d"", ""filename"": ""chrome/chrome_browser.gypi"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 2, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/chrome_browser.gypi"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/chrome_browser.gypi"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/chrome_browser.gypi?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1038,11 +1038,17 @@\n         'browser/extensions/extension_tts_api.cc',\n         'browser/extensions/extension_tts_api.h',\n         'browser/extensions/extension_tts_api_chromeos.cc',\n+        'browser/extensions/extension_tts_api_constants.cc',\n+        'browser/extensions/extension_tts_api_constants.h',\n+        'browser/extensions/extension_tts_api_controller.cc',\n+        'browser/extensions/extension_tts_api_controller.h',\n         'browser/extensions/extension_tts_api_linux.cc',\n         'browser/extensions/extension_tts_api_mac.mm',\n-        'browser/extensions/extension_tts_api_util.cc',\n-        'browser/extensions/extension_tts_api_util.h',\n+        'browser/extensions/extension_tts_api_platform.cc',\n+        'browser/extensions/extension_tts_api_platform.h',\n         'browser/extensions/extension_tts_api_win.cc',\n+        'browser/extensions/extension_tts_engine_api.cc',\n+        'browser/extensions/extension_tts_engine_api.h',\n         'browser/extensions/extension_uninstall_dialog.cc',\n         'browser/extensions/extension_uninstall_dialog.h',\n         'browser/extensions/extension_updater.cc',""}<_**next**_>{""sha"": ""6458211d1014ce1ff081bc1d15e3855a3da8283e"", ""filename"": ""chrome/common/extensions/api/extension_api.json"", ""status"": ""modified"", ""additions"": 165, ""deletions"": 29, ""changes"": 194, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/api/extension_api.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/api/extension_api.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/api/extension_api.json?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -508,6 +508,76 @@\n   },\n   {\n     \""namespace\"": \""experimental.tts\"",\n+    \""types\"": [\n+      {\n+        \""id\"": \""TtsEvent\"",\n+        \""type\"": \""object\"",\n+        \""description\"": \""An event from the TTS engine to communicate the status of an utterance.\"",\n+        \""properties\"": {\n+          \""type\"": {\n+            \""type\"": \""string\"",\n+            \""enum\"": [\""start\"", \""end\"", \""word\"", \""sentence\"", \""marker\"", \""interrupted\"", \""cancelled\"", \""error\""],\n+            \""description\"": \""The message can be 'start' when this utterance is begun to be spoken, 'word' when a word boundary is reached, 'sentence' when a sentence boundary is reached, 'marker' when an SSML mark element is reached, 'end' when the end of the utterance is reached, 'interrupted' when the utterance is stopped or interrupted before reaching the end, 'cancelled' when it's removed from the queue before ever being synthesized, and 'error' when any other error occurs. Clients will always receive 'end', 'cancelled', 'interrupted', or 'error', and other events will depend on the engine.\""\n+          },\n+          \""charIndex\"": {\n+            \""type\"": \""number\"",\n+            \""optional\"": true,\n+            \""description\"": \""The index of the current character in the utterance.\""\n+          },\n+          \""errorMessage\"": {\n+            \""type\"": \""string\"",\n+            \""description\"": \""The error message, if the message is 'error'.\"",\n+            \""optional\"": true\n+          },\n+          \""srcId\"": {\n+            \""type\"": \""number\"",\n+            \""description\"": \""An ID unique to the calling function's context so that events can get routed back to the correct tts.speak call.\"",\n+            \""nodoc\"": true,\n+            \""optional\"": true\n+          },\n+          \""isFinalEvent\"": {\n+            \""type\"": \""boolean\"",\n+            \""description\"": \""True if this is the final event that will be sent to this handler.\"",\n+            \""nodoc\"": true,\n+            \""optional\"": true\n+          }\n+        }\n+      },\n+      {\n+        \""id\"": \""TtsVoice\"",\n+        \""type\"": \""object\"",\n+        \""description\"": \""A description of a voice available for speech synthesis.\"",\n+        \""properties\"": {\n+          \""voiceName\"": {\n+            \""type\"": \""string\"",\n+            \""optional\"": true,\n+            \""description\"": \""The name of the voice.\""\n+          },\n+          \""lang\"": {\n+            \""type\"": \""string\"",\n+            \""optional\"": true,\n+            \""description\"": \""The language that this voice supports, in the form &lt;language&gt;-&lt;region&gt;. Examples: 'en', 'en-US', 'en-GB', 'zh-CN', etc.\""\n+          },\n+          \""gender\"": {\n+            \""type\"": \""string\"",\n+            \""optional\"": true,\n+            \""description\"": \""This voice's gender.\"",\n+            \""enum\"": [\""male\"", \""female\""]\n+          },\n+          \""extensionId\"": {\n+            \""type\"": \""string\"",\n+            \""optional\"": true,\n+            \""description\"": \""The ID of the extension providing this voice.\""\n+          },\n+          \""eventTypes\"": {\n+            \""type\"": \""array\"",\n+            \""items\"": {\""type\"": \""string\""},\n+            \""optional\"": true,\n+            \""description\"": \""All of the callback event types that this voice is capable of sending.\""\n+          }\n+        }\n+      }\n+    ],\n     \""functions\"": [\n       {\n         \""name\"": \""speak\"",\n@@ -517,7 +587,7 @@\n           {\n             \""type\"": \""string\"",\n             \""name\"": \""utterance\"",\n-            \""description\"": \""The text to speak. May include SSML markup.\""\n+            \""description\"": \""The text to speak, either plaintext or a complete well-formed SSML document. Speech engines that do not support SSML will strip away the tags and speak the text. The maximum length of the text is 32,768 characters.\""\n           },\n           {\n             \""type\"": \""object\"",\n@@ -535,10 +605,15 @@\n                 \""optional\"": true,\n                 \""description\"": \""The name of the voice to use for synthesis. If empty, uses any available voice.\""\n               },\n-\t      \""locale\"": {\n+\t      \""extensionId\"": {\n+                \""type\"": \""string\"",\n+                \""optional\"": true,\n+                \""description\"": \""The specific extension ID of the speech engine to use, if known.\""\n+              },\n+\t      \""lang\"": {\n                 \""type\"": \""string\"",\n                 \""optional\"": true,\n-                \""description\"": \""The language and optional region code that specify the language and dialect to be used for synthesis, in the form &lt;language&gt;-&lt;region&gt;. Examples: 'en', 'en-US', 'en-GB', 'zh-CN', etc.\""\n+                \""description\"": \""The language to be used for synthesis, in the form &lt;language&gt;-&lt;region&gt;. Examples: 'en', 'en-US', 'en-GB', 'zh-CN', etc.\""\n               },\n               \""gender\"": {\n                 \""type\"": \""string\"",\n@@ -549,31 +624,55 @@\n               \""rate\"": {\n                 \""type\"": \""number\"",\n                 \""optional\"": true,\n-                \""minimum\"": 0,\n-                \""maximum\"": 1,\n-                \""description\"": \""Speaking speed between 0 and 1 inclusive, with 0 being slowest and 1 being fastest, with a default of 0.5.\""\n+                \""minimum\"": 0.1,\n+                \""maximum\"": 10,\n+                \""description\"": \""Speaking rate relative to the default rate for this voice. 1.0 is the default rate, normally around 180 to 220 words per minute, 2.0 would be twice as fast, and 0.5 would be half as fast. Values below 0.1 or above 10.0 are strictly disallowed, but many voices will constrain the minimum and maximum rates further - i.e. a particular voice may not actually speak faster than 3 times normal even if you specify a value larger than 3.0.\""\n               },\n               \""pitch\"": {\n                 \""type\"": \""number\"",\n                 \""optional\"": true,\n                 \""minimum\"": 0,\n-                \""maximum\"": 1,\n-                \""description\"": \""Speaking pitch between 0 and 1 inclusive, with 0 being lowest and 1 being highest, with a default of 0.5.\""\n+                \""maximum\"": 2,\n+                \""description\"": \""Speaking pitch between 0 and 2 inclusive, with 0 being lowest and 1 being highest, with 1.0 being the default pitch of this particular voice.\""\n               },\n               \""volume\"": {\n                 \""type\"": \""number\"",\n                 \""optional\"": true,\n                 \""minimum\"": 0,\n                 \""maximum\"": 1,\n                 \""description\"": \""Speaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being highest, with a default of 1.0.\""\n+              },\n+              \""requiredEventTypes\"": {\n+                \""type\"": \""array\"",\n+                \""items\"": {\""type\"": \""string\""},\n+                \""optional\"": true,\n+                \""description\"": \""The TTS event types the voice must support. If missing, this criteria will not be used to filter voices.\""\n+              },\n+              \""desiredEventTypes\"": {\n+                \""type\"": \""array\"",\n+                \""items\"": {\""type\"": \""string\""},\n+                \""optional\"": true,\n+                \""description\"": \""The TTS event types that should be sent. If missing, all event types will be sent.\""\n+              },\n+              \""onevent\"": {\n+                \""type\"": \""function\"",\n+                \""optional\"": true,\n+                \""description\"": \""This function is called with events that occur in the process of speaking the utterance.\"",\n+                \""parameters\"": [\n+                  {\n+                    \""name\"": \""event\"",\n+                    \""$ref\"": \""TtsEvent\"",\n+                    \""description\"": \""The update event from the text-to-speech engine indicating the status of this utterance.\""\n+                  }\n+                ]\n               }\n             }\n           },\n           {\n             \""type\"": \""function\"",\n             \""name\"": \""callback\"",\n             \""optional\"": true,\n-            \""description\"": \""This function is called when speaking is finished.\"",\n+            \""description\"": \""Called right away, before speech finishes. Check chrome.extension.lastError to make sure there were no errors. Use options.onevent to get more detailed feedback.\"",\n             \""parameters\"": []\n           }\n         ]\n@@ -604,19 +703,44 @@\n         ]\n       },\n       {\n-        \""name\"": \""speakCompleted\"",\n+        \""name\"": \""getVoices\"",\n+        \""type\"": \""function\"",\n+        \""description\"": \""Get an array of all available voices.\"",\n+        \""parameters\"": [\n+          {\n+            \""type\"": \""function\"",\n+            \""name\"": \""callback\"",\n+            \""optional\"": true,\n+            \""parameters\"": [\n+              {\n+                \""type\"": \""array\"",\n+                \""name\"": \""voices\"",\n+                \""items\"": { \""$ref\"": \""TtsVoice\"" },\n+                \""description\"": \""Array of $ref:TtsVoice objects representing the available voices for speech synthesis.\""\n+              }\n+            ]\n+          }\n+        ]\n+      }\n+    ]\n+  },\n+  {\n+    \""namespace\"": \""experimental.ttsEngine\"",\n+    \""functions\"": [\n+      {\n+        \""name\"": \""sendTtsEvent\"",\n         \""nodoc\"": true,\n         \""type\"": \""function\"",\n-        \""description\"": \""A callback passed to the onSpeak event.\"",\n+        \""description\"": \""Route a TTS event from a speech engine to a client.\"",\n         \""parameters\"": [\n           {\n             \""type\"": \""integer\"",\n             \""name\"": \""requestId\""\n           },\n           {\n-            \""type\"": \""string\"",\n-\t    \""optional\"": \""true\"",\n-            \""name\"": \""errorMessage\""\n+            \""name\"": \""event\"",\n+            \""$ref\"": \""TtsEvent\"",\n+            \""description\"": \""The update event from the text-to-speech engine indicating the status of this utterance.\""\n           }\n         ]\n       }\n@@ -630,7 +754,7 @@\n           {\n             \""type\"": \""string\"",\n             \""name\"": \""utterance\"",\n-            \""description\"": \""The text to speak. This may include SSML, so if your engine does not support SSML, you should strip out all XML markup and synthesize only the underlying text content.\""\n+            \""description\"": \""The text to speak. This may include SSML, so if your engine does not support SSML, you should strip out all XML markup and synthesize only the underlying text content. This is guaranteed to be no more than 32,768 characters. If this engine does not support speaking that many characters at a time, the utterance should be split into smaller chunks and queued internally without returning an error.\""\n           },\n           {\n             \""type\"": \""object\"",\n@@ -642,10 +766,10 @@\n                 \""optional\"": true,\n                 \""description\"": \""The name of the voice to use for synthesis.\""\n               },\n-\t      \""locale\"": {\n+\t      \""lang\"": {\n                 \""type\"": \""string\"",\n                 \""optional\"": true,\n-                \""description\"": \""The language and region code that specify the language and dialect to be used for synthesis, in the form <language>-<region>, e.g. en-US, en-GB, fr-CA, zh-CN, etc.\""\n+                \""description\"": \""The language to be used for synthesis, in the form <language>-<region>, e.g. en-US, en-GB, fr-CA, zh-CN, etc.\""\n               },\n               \""gender\"": {\n                 \""type\"": \""string\"",\n@@ -656,36 +780,35 @@\n               \""rate\"": {\n                 \""type\"": \""number\"",\n                 \""optional\"": true,\n-                \""minimum\"": 0,\n-                \""maximum\"": 1,\n-                \""description\"": \""Speaking speed between 0 and 1 inclusive, with 0 being slowest and 1 being fastest.\""\n+                \""minimum\"": 0.1,\n+                \""maximum\"": 10.0,\n+                \""description\"": \""Speaking rate relative to the default rate for this voice. 1.0 is the default rate, normally around 180 to 220 words per minute, 2.0 would be twice as fast, and 0.5 would be half as fast.  This value is guaranteed to be between 0.1 and 10.0, inclusive. When a voice does not support this full range of rates, the actual rate should be clipped to the range that is supported without returning an error.\""\n               },\n               \""pitch\"": {\n                 \""type\"": \""number\"",\n                 \""optional\"": true,\n                 \""minimum\"": 0,\n-                \""maximum\"": 1,\n-                \""description\"": \""Speaking pitch between 0 and 1 inclusive, with 0 being lowest and 1 being highest.\""\n+                \""maximum\"": 2,\n+                \""description\"": \""Speaking pitch between 0 and 2 inclusive, with 0 being lowest and 1 being highest, with 1.0 being the default pitch of this particular voice.\""\n               },\n               \""volume\"": {\n                 \""type\"": \""number\"",\n                 \""optional\"": true,\n                 \""minimum\"": 0,\n                 \""maximum\"": 1,\n-                \""description\"": \""Speaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being highest.\""\n+                \""description\"": \""Speaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being highest, with a default of 1.0.\""\n               }\n             }\n \t  },\n           {\n+            \""name\"": \""sendTtsEvent\"",\n             \""type\"": \""function\"",\n-            \""name\"": \""callback\"",\n-            \""description\"": \""You must call this function when speaking is finished.\"",\n+            \""description\"": \""Call this function with events that occur in the process of speaking the utterance.\"",\n             \""parameters\"": [\n               {\n-                \""type\"": \""string\"",\n-                \""name\"": \""error\"",\n-\t\t\""optional\"": true,\n-                \""description\"": \""Error message, which will be returned to the caller in chrome.extension.lastError.\""\n+                \""name\"": \""event\"",\n+                \""$ref\"": \""TtsEvent\"",\n+                \""description\"": \""The event from the text-to-speech engine indicating the status of this utterance.\""\n               }\n             ]\n           }\n@@ -695,6 +818,19 @@\n         \""name\"": \""onStop\"",\n         \""type\"": \""function\"",\n         \""description\"": \""Fired when a call is made to tts.stop and this extension may be in the middle of speaking. If an extension receives a call to onStop and speech is already stopped, it should do nothing (not raise an error).\""\n+      },\n+      {\n+        \""name\"": \""onEvent\"",\n+        \""type\"": \""function\"",\n+        \""nodoc\"": true,\n+        \""parameters\"": [\n+          {\n+            \""name\"": \""event\"",\n+            \""$ref\"": \""TtsEvent\"",\n+            \""description\"": \""The event from the text-to-speech engine indicating the status of this utterance.\""\n+          }\n+        ],\n+        \""description\"": \""Used to pass events back to the function calling speak().\""\n       }\n     ]\n   },""}<_**next**_>{""sha"": ""cd536c5523c0d0da78834909937b07e34db477ca"", ""filename"": ""chrome/common/extensions/docs/experimental.html"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/docs/experimental.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/docs/experimental.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/docs/experimental.html?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -331,6 +331,7 @@ <h2>Contents</h2>\n   <a href=\""experimental.processes.html\"">experimental.processes</a></li><li>\n   <a href=\""experimental.sidebar.html\"">experimental.sidebar</a></li><li>\n   <a href=\""experimental.tts.html\"">experimental.tts</a></li><li>\n+  <a href=\""experimental.ttsEngine.html\"">experimental.ttsEngine</a></li><li>\n   <a href=\""experimental.webNavigation.html\"">experimental.webNavigation</a></li><li>\n   <a href=\""experimental.webRequest.html\"">experimental.webRequest</a></li>\n </ul>""}<_**next**_>{""sha"": ""e3fb2b0c78a34f9637a07652334519e611463190"", ""filename"": ""chrome/common/extensions/docs/experimental.tts.html"", ""status"": ""modified"", ""additions"": 965, ""deletions"": 370, ""changes"": 1335, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/docs/experimental.tts.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/docs/experimental.tts.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/docs/experimental.tts.html?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -271,6 +271,13 @@ <h2>Contents</h2>\n                   <a>h3Name</a>\n                 </li>\n               </ol>\n+            </li><li>\n+              <a href=\""#events\"">Listening to events</a>\n+              <ol>\n+                <li style=\""display: none; \"">\n+                  <a>h3Name</a>\n+                </li>\n+              </ol>\n             </li><li>\n               <a href=\""#ssml\"">SSML markup</a>\n               <ol>\n@@ -279,7 +286,7 @@ <h2>Contents</h2>\n                 </li>\n               </ol>\n             </li><li>\n-              <a href=\""#provider\"">Implementing a speech provider</a>\n+              <a href=\""#choosing_voice\"">Choosing a voice</a>\n               <ol>\n                 <li style=\""display: none; \"">\n                   <a>h3Name</a>\n@@ -301,31 +308,31 @@ <h2>Contents</h2>\n                     <a href=\""#global-methods\"">Methods</a>\n                     <ol>\n                       <li>\n+                        <a href=\""#method-getVoices\"">getVoices</a>\n+                      </li><li>\n                         <a href=\""#method-isSpeaking\"">isSpeaking</a>\n                       </li><li>\n                         <a href=\""#method-speak\"">speak</a>\n-                      </li><li style=\""display: none; \"">\n-                        <a href=\""#method-anchor\"">methodName</a>\n                       </li><li>\n                         <a href=\""#method-stop\"">stop</a>\n                       </li>\n                     </ol>\n                   </li>\n-                  <li>\n-                    <a href=\""#global-events\"">Events</a>\n+                  <li style=\""display: none; \"">\n+                    <a>Events</a>\n                     <ol>\n                       <li>\n-                        <a href=\""#event-onSpeak\"">onSpeak</a>\n-                      </li><li>\n-                        <a href=\""#event-onStop\"">onStop</a>\n+                        <a href=\""#event-anchor\"">eventName</a>\n                       </li>\n                     </ol>\n                   </li>\n-                  <li style=\""display: none; \"">\n+                  <li>\n                     <a href=\""#types\"">Types</a>\n                     <ol>\n                       <li>\n-                        <a href=\""#id-anchor\"">id</a>\n+                        <a href=\""#type-TtsEvent\"">TtsEvent</a>\n+                      </li><li>\n+                        <a href=\""#type-TtsVoice\"">TtsVoice</a>\n                       </li>\n                     </ol>\n                   </li>\n@@ -343,8 +350,10 @@ <h2>Contents</h2>\n         <!-- STATIC CONTENT PLACEHOLDER -->\n         <div id=\""static\""><p id=\""classSummary\"">\n Use the <code>chrome.experimental.tts</code> module to play synthesized\n-text-to-speech (TTS) from your extension or packaged app, or to register\n-as a speech provider for other extensions and packaged apps that want to speak.\n+text-to-speech (TTS) from your extension or packaged app.\n+See also the related\n+<a href=\""experimental.ttsEngine.html\"">experimental.ttsEngine</a>\n+module which allows an extension to implement a speech engine.\n </p>\n \n <p class=\""note\""><b>Give us feedback:</b> If you have suggestions,\n@@ -362,7 +371,7 @@ <h2 id=\""overview\"">Overview</h2>\n 5), Mac OS X, and Chrome OS, using speech synthesis capabilities\n provided by the operating system. On all platforms, the user can\n install extensions that register themselves as alternative speech\n-synthesis providers.</p>\n+engines.</p>\n \n <h2 id=\""generating_speech\"">Generating speech</h2>\n \n@@ -371,122 +380,163 @@ <h2 id=\""generating_speech\"">Generating speech</h2>\n \n <pre>chrome.experimental.tts.speak('Hello, world.');</pre>\n \n+<p>To stop speaking immediately, just call <code>stop()</code>:\n+\n+</p><pre>chrome.experimental.tts.stop();</pre>\n+\n <p>You can provide options that control various properties of the speech,\n such as its rate, pitch, and more. For example:</p>\n \n-<pre>chrome.experimental.tts.speak('Hello, world.', {'rate': 0.8});</pre>\n+<pre>chrome.experimental.tts.speak('Hello, world.', {'rate': 2.0});</pre>\n \n-<p>It's also a good idea to specify the locale so that a synthesizer\n+<p>It's also a good idea to specify the language so that a synthesizer\n supporting that language (and regional dialect, if applicable) is chosen.</p>\n \n <pre>chrome.experimental.tts.speak(\n-    'Hello, world.',\n-    {\n-      'locale': 'en-US',\n-      'rate': 0.8\n-    });</pre>\n-\n-<p>Not all speech engines will support all options.</p>\n+    'Hello, world.', {'lang': 'en-US', 'rate': 2.0});</pre>\n \n-<p>You can also pass a callback function that will be called when the\n-speech has finished. For example, suppose we have an image on our page\n-displaying a picture of a face with a closed mouth. We could open the mouth\n-while speaking, and close it when done.</p>\n+<p>By default, each call to <code>speak()</code> will interrupt any\n+ongoing speech and speak immediately. To determine if a call would be\n+interrupting anything, you can call <code>isSpeaking()</code>, or\n+you can use the <code>enqueue</code> option to cause this utterance to\n+be added to a queue of utterances that will be spoken when the current\n+utterance has finished.\n \n-<pre>faceImage.src = 'open_mouth.png';\n+</p><pre>chrome.experimental.tts.speak(\n+    'Speak this first.');\n chrome.experimental.tts.speak(\n-    'Hello, world.', null, function() {\n-      faceImage.src = 'closed_mouth.png';\n-    });\n+    'Speak this next, when the first sentence is done.', {'enqueue': true});\n </pre>\n \n-<p>To stop speaking immediately, just call <code>stop()</code>. Call\n-<code>isSpeaking()</code> to find out if a TTS engine is currently speaking.</p>\n+<p>A complete description of all options can be found in the\n+<a href=\""#method-speak\"">speak() method documentation</a> below.\n+Not all speech engines will support all options.</p>\n+\n+<p>To catch errors and make sure you're calling <code>speak()</code>\n+correctly, pass a callback function that takes no arguments. Inside\n+the callback, check\n+<a href=\""extension.html#property-lastError\"">chrome.extension.lastError</a>\n+to see if there were any errors.</p>\n+\n+<pre>chrome.experimental.tts.speak(\n+    utterance,\n+    options,\n+    function() {\n+      if (chrome.extension.lastError) {\n+        console.log('Error: ' + chrome.extension.lastError.message);\n+      }\n+    });</pre>\n+\n+<p>The callback returns right away, before the speech engine has started\n+generating speech. The purpose of the callback is to alert you to syntax\n+errors in your use of the TTS API, not all possible errors that might occur\n+in the process of synthesizing and outputting speech. To catch these errors\n+too, you need to use an event listener, described below.\n \n-<p>You can check to see if an error occurred by checking\n-<code>chrome.extension.lastError</code> inside the callback function.</p>\n+</p><h2 id=\""events\"">Listening to events</h2>\n \n-<h2 id=\""ssml\"">SSML markup</h2>\n+<p>To get more real-time information about the status of synthesized speech,\n+pass an event listener in the options to <code>speak()</code>, like this:</p>\n+\n+<pre>chrome.experimental.tts.speak(\n+    utterance,\n+    {\n+      'onevent': function(event) {\n+        console.log('Event ' + event.type ' at position ' + event.charIndex);\n+        if (event.type == 'error') {\n+          console.log('Error: ' + event.errorMessage);\n+        }\n+      }\n+    },\n+    callback);</pre>\n+\n+<p>Each event includes an event type, the character index of the current\n+speech relative to the utterance, and for error events, an optional\n+error message. The event types are:</p>\n+\n+<ul>\n+  <li><code>'start'</code>: the engine has started speaking the utterance.\n+  </li><li><code>'word'</code>: a word boundary was reached. Use\n+          <code>event.charIndex</code> to determine the current speech\n+          position.\n+  </li><li><code>'sentence'</code>: a sentence boundary was reached. Use\n+          <code>event.charIndex</code> to determine the current speech\n+          position.\n+  </li><li><code>'marker'</code>: an SSML marker was reached. Use\n+          <code>event.charIndex</code> to determine the current speech\n+          position.\n+  </li><li><code>'end'</code>: the engine has finished speaking the utterance.\n+  </li><li><code>'interrupted'</code>: this utterance was interrupted by another\n+          call to <code>speak()</code> or <code>stop()</code> and did not\n+          finish.\n+  </li><li><code>'cancelled'</code>: this utterance was queued, but then\n+          cancelled by another call to <code>speak()</code> or\n+          <code>stop()</code> and never began to speak at all.\n+  </li><li><code>'error'</code>: An engine-specific error occurred and\n+          this utterance cannot be spoken.\n+          Check <code>event.errorMessage</code> for details.\n+</li></ul>\n+\n+<p>Four of the event types, <code>'end'</code>, <code>'interrupted'</code>,\n+<code>'cancelled'</code>, and <code>'error'</code>, are <i>final</i>. After\n+one of those events is received, this utterance will no longer speak and\n+no new events from this utterance will be received.</p>\n+\n+<p>Some TTS engines may not support all event types, and some may not even\n+support any events at all. To require that the speech engine used sends\n+the events you're interested in, you can pass a list of event types in\n+the <code>requiredEventTypes</code> member of the options object, or use\n+<code>getVoices</code> to choose a voice that has the events you need.\n+Both are documented below.\n+\n+</p><h2 id=\""ssml\"">SSML markup</h2>\n \n <p>Utterances used in this API may include markup using the\n <a href=\""http://www.w3.org/TR/speech-synthesis\"">Speech Synthesis Markup\n-Language (SSML)</a>. For example:\n+Language (SSML)</a>. If you use SSML, the first argument to\n+<code>speak()</code> should be a complete SSML document with an XML\n+header and a top-level <code>&lt;speak&gt;</code> tag, not a document\n+fragment.\n \n-</p><pre>chrome.experimental.tts.speak('The &lt;emphasis&gt;second&lt;/emphasis&gt; word of this sentence was emphasized.');</pre>\n+For example:\n+\n+</p><pre>chrome.experimental.tts.speak(\n+    '&lt;?xml version=\""1.0\""?&gt;' +\n+    '&lt;speak&gt;' +\n+    '  The &lt;emphasis&gt;second&lt;/emphasis&gt; ' +\n+    '  word of this sentence was emphasized.' +\n+    '&lt;/speak&gt;');</pre>\n \n <p>Not all speech engines will support all SSML tags, and some may not support\n-SSML at all, but all engines are expected to ignore any SSML they don't\n+SSML at all, but all engines are required to ignore any SSML they don't\n support and still speak the underlying text.</p>\n \n-<h2 id=\""provider\"">Implementing a speech provider</h2>\n-\n-<p>An extension can register itself as a speech provider. By doing so, it\n-can intercept some or all calls to functions such as\n-<code>speak()</code> and <code>stop()</code> and provide an alternate\n-implementation. Extensions are free to use any available web technology\n-to provide speech, including streaming audio from a server, HTML5 audio,\n-Native Client, or Flash. An extension could even do something different\n-with the utterances, like display closed captions in a pop-up window or\n-send them as log messages to a remote server.</p>\n-\n-<p>To provide TTS, an extension must first declare all voices it provides\n-in the extension manifest, like this:</p>\n-\n-<pre>{\n-  \""name\"": \""My TTS Provider\"",\n-  \""version\"": \""1.0\"",\n-  <b>\""permissions\"": [\""experimental\""]\n-  \""tts\"": {\n-    \""voices\"": [\n-      {\n-        \""voiceName\"": \""Alice\"",\n-        \""locale\"": \""en-US\"",\n-        \""gender\"": \""female\""\n-      },\n-      {\n-        \""voiceName\"": \""Pat\"",\n-        \""locale\"": \""en-US\""\n+<h2 id=\""choosing_voice\"">Choosing a voice</h2>\n+\n+<p>By default, Chrome will choose the most appropriate voice for each\n+utterance you want to speak, based on the language and gender. On most\n+Windows, Mac OS X, and Chrome OS systems, speech synthesis provided by\n+the operating system should be able to speak any text in at least one\n+language. Some users may have a variety of voices available, though,\n+from their operating system and from speech engines implemented by other\n+Chrome extensions. In those cases, you can implement custom code to choose\n+the appropriate voice, or present the user with a list of choices.</p>\n+\n+<p>To get a list of all voices, call <code>getVoices()</code> and pass it\n+a function that receives an array of <code>TtsVoice</code> objects as its\n+argument:</p>\n+\n+<pre>chrome.experimental.tts.getVoices(\n+    function(voices) {\n+      for (var i = 0; i &lt; voices.length; i++) {\n+        console.log('Voice ' + i + ':');\n+        console.log('  name: ' + voices[i].voiceName);\n+        console.log('  lang: ' + voices[i].lang);\n+        console.log('  gender: ' + voices[i].gender);\n+        console.log('  extension id: ' + voices[i].extensionId);\n+        console.log('  event types: ' + voices[i].eventTypes);\n       }\n-    ]\n-  },</b>\n-  \""background_page\"": \""background.html\"",\n-}</pre>\n-\n-<p>An extension can specify any number of voices. The three\n-parameters\u2014<code>voiceName</code>, <code>locale</code>,\n-and <code>gender</code>\u2014are all optional. If they are all unspecified,\n-the extension will handle all speech from all clients. If any of them\n-are specified, they can be used to filter speech requests. For\n-example, if a voice only supports French, it should set the locale to\n-'fr' (or something more specific like 'fr-FR') so that only utterances\n-in that locale are routed to that extension.</p>\n-\n-<p>To handle speech calls, the extension should register listeners\n-for <code>onSpeak</code> and <code>onStop</code>, like this:</p>\n-\n-<pre>var speakListener = function(utterance, options, callback) {\n-  ...\n-  callback();\n-};\n-var stopListener = function() {\n-  ...\n-};\n-chrome.experimental.tts.onSpeak.addListener(speakListener);\n-chrome.experimental.tts.onStop.addListener(stopListener);</pre>\n-\n-<p class=\""warning\""><b>Important:</b> Don't forget to call the callback\n-function from your speak listener!</p>\n-\n-<p>If an extension does not register listeners for both\n-<code>onSpeak</code> and <code>onStop</code>, it will not intercept any\n-speech calls, regardless of what is in the manifest.\n-\n-</p><p>The decision of whether or not to send a given speech request to an\n-extension is based solely on whether the extension supports the given voice\n-parameters in its manifest and has registered listeners\n-for <code>onSpeak</code> and <code>onStop</code>. In other words,\n-there's no way for an extension to receive a speech request and\n-dynamically decide whether to handle it or not.</p>\n+    });</pre>\n </div>\n \n         <!-- API PAGE -->\n@@ -519,6 +569,213 @@ <h3>Methods</h3>\n \n             <!-- iterates over all functions -->\n             <div class=\""apiItem\"">\n+              <a name=\""method-getVoices\""></a> <!-- method-anchor -->\n+              <h4>getVoices</h4>\n+\n+              <div class=\""summary\""><span style=\""display: none; \"">void</span>\n+                  <!-- Note: intentionally longer 80 columns -->\n+                  <span>chrome.experimental.tts.getVoices</span>(<span class=\""optional\""><span style=\""display: none; \"">, </span><span>function</span>\n+                      <var><span>callback</span></var></span>)</div>\n+\n+              <div class=\""description\"">\n+                <p class=\""todo\"" style=\""display: none; \"">Undocumented.</p>\n+                <p>Get an array of all available voices.</p>\n+\n+                <!-- PARAMETERS -->\n+                <h4>Parameters</h4>\n+                <dl>\n+                  <div>\n+                    <div>\n+          <dt>\n+            <var>callback</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span style=\""display: none; \"">\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>function</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"">\n+            Undocumented.\n+          </dd>\n+          <dd style=\""display: none; \"">\n+            Description of this parameter from the json schema.\n+          </dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd style=\""display: none; \"">\n+            <dl>\n+              <div>\n+                <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n+                  </div>\n+                </dl>\n+\n+                <!-- RETURNS -->\n+                <h4 style=\""display: none; \"">Returns</h4>\n+                <dl>\n+                  <div style=\""display: none; \"">\n+                    <div>\n+                    </div>\n+                  </div>\n+                </dl>\n+\n+                <!-- CALLBACK -->\n+                <div>\n+                  <div>\n+                  <h4>Callback function</h4>\n+                  <p style=\""display: none; \"">\n+                    The callback <em>parameter</em> should specify a function\n+                    that looks like this:\n+                  </p>\n+                  <p>\n+                    If you specify the <em>callback</em> parameter, it should\n+                    specify a function that looks like this:\n+                  </p>\n+\n+                  <!-- Note: intentionally longer 80 columns -->\n+                  <pre>function(<span>array of TtsVoice voices</span>) <span class=\""subdued\"">{...}</span>;</pre>\n+                  <dl>\n+                    <div>\n+                      <div>\n+          <dt>\n+            <var>voices</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"" style=\""display: none; \"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span>\n+                          array of <span><span>\n+                      <span>\n+                        <a href=\""experimental.tts.html#type-TtsVoice\"">TtsVoice</a>\n+                      </span>\n+                      <span style=\""display: none; \"">\n+                        <span>\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>paramType</span>\n+                        <span></span>\n+                      </span>\n+                    </span></span>\n+                        </span>\n+                        <span style=\""display: none; \"">paramType</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>Array of <a href=\""experimental.tts.html#type-TtsVoice\"">TtsVoice</a> objects representing the available voices for speech synthesis.</dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd style=\""display: none; \"">\n+            <dl>\n+              <div>\n+                <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n+                    </div>\n+                  </dl>\n+                  </div>\n+                </div>\n+\n+                <!-- MIN_VERSION -->\n+                <p style=\""display: none; \"">\n+                  This function was added in version <b><span></span></b>.\n+                  If you require this function, the manifest key\n+                  <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+                  can ensure that your extension won't be run in an earlier browser version.\n+                </p>\n+              </div> <!-- /description -->\n+\n+            </div><div class=\""apiItem\"">\n               <a name=\""method-isSpeaking\""></a> <!-- method-anchor -->\n               <h4>isSpeaking</h4>\n \n@@ -763,7 +1020,7 @@ <h4>Parameters</h4>\n           <dd class=\""todo\"" style=\""display: none; \"">\n             Undocumented.\n           </dd>\n-          <dd>The text to speak. May include SSML markup.</dd>\n+          <dd>The text to speak, either plaintext or a complete well-formed SSML document. Speech engines that do not support SSML will strip away the tags and speak the text. The maximum length of the text is 32,768 characters.</dd>\n           <dd style=\""display: none; \"">\n             This parameter was added in version\n             <b><span></span></b>.\n@@ -984,7 +1241,7 @@ <h4>Parameters</h4>\n               </div><div>\n                 <div>\n           <dt>\n-            <var>locale</var>\n+            <var>extensionId</var>\n               <em>\n \n                 <!-- TYPE -->\n@@ -1012,7 +1269,7 @@ <h4>Parameters</h4>\n           <dd class=\""todo\"" style=\""display: none; \"">\n             Undocumented.\n           </dd>\n-          <dd>The language and optional region code that specify the language and dialect to be used for synthesis, in the form &lt;language&gt;-&lt;region&gt;. Examples: 'en', 'en-US', 'en-GB', 'zh-CN', etc.</dd>\n+          <dd>The specific extension ID of the speech engine to use, if known.</dd>\n           <dd style=\""display: none; \"">\n             This parameter was added in version\n             <b><span></span></b>.\n@@ -1052,14 +1309,14 @@ <h4>Parameters</h4>\n               </div><div>\n                 <div>\n           <dt>\n-            <var>gender</var>\n+            <var>lang</var>\n               <em>\n \n                 <!-- TYPE -->\n                 <div style=\""display:inline\"">\n                   (\n                     <span class=\""optional\"">optional</span>\n-                    <span class=\""enum\"">enumerated</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n                     <span id=\""typeTemplate\"">\n                       <span style=\""display: none; \"">\n                         <a> Type</a>\n@@ -1069,7 +1326,7 @@ <h4>Parameters</h4>\n                           array of <span><span></span></span>\n                         </span>\n                         <span>string</span>\n-                        <span>[\""male\"", \""female\""]</span>\n+                        <span style=\""display: none; \""></span>\n                       </span>\n                     </span>\n                   )\n@@ -1080,7 +1337,7 @@ <h4>Parameters</h4>\n           <dd class=\""todo\"" style=\""display: none; \"">\n             Undocumented.\n           </dd>\n-          <dd>Gender of voice for synthesized speech.</dd>\n+          <dd>The language to be used for synthesis, in the form &lt;language&gt;-&lt;region&gt;. Examples: 'en', 'en-US', 'en-GB', 'zh-CN', etc.</dd>\n           <dd style=\""display: none; \"">\n             This parameter was added in version\n             <b><span></span></b>.\n@@ -1120,14 +1377,14 @@ <h4>Parameters</h4>\n               </div><div>\n                 <div>\n           <dt>\n-            <var>rate</var>\n+            <var>gender</var>\n               <em>\n \n                 <!-- TYPE -->\n                 <div style=\""display:inline\"">\n                   (\n                     <span class=\""optional\"">optional</span>\n-                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span class=\""enum\"">enumerated</span>\n                     <span id=\""typeTemplate\"">\n                       <span style=\""display: none; \"">\n                         <a> Type</a>\n@@ -1136,8 +1393,8 @@ <h4>Parameters</h4>\n                         <span style=\""display: none; \"">\n                           array of <span><span></span></span>\n                         </span>\n-                        <span>number</span>\n-                        <span style=\""display: none; \""></span>\n+                        <span>string</span>\n+                        <span>[\""male\"", \""female\""]</span>\n                       </span>\n                     </span>\n                   )\n@@ -1148,7 +1405,7 @@ <h4>Parameters</h4>\n           <dd class=\""todo\"" style=\""display: none; \"">\n             Undocumented.\n           </dd>\n-          <dd>Speaking speed between 0 and 1 inclusive, with 0 being slowest and 1 being fastest, with a default of 0.5.</dd>\n+          <dd>Gender of voice for synthesized speech.</dd>\n           <dd style=\""display: none; \"">\n             This parameter was added in version\n             <b><span></span></b>.\n@@ -1188,7 +1445,7 @@ <h4>Parameters</h4>\n               </div><div>\n                 <div>\n           <dt>\n-            <var>pitch</var>\n+            <var>rate</var>\n               <em>\n \n                 <!-- TYPE -->\n@@ -1216,7 +1473,7 @@ <h4>Parameters</h4>\n           <dd class=\""todo\"" style=\""display: none; \"">\n             Undocumented.\n           </dd>\n-          <dd>Speaking pitch between 0 and 1 inclusive, with 0 being lowest and 1 being highest, with a default of 0.5.</dd>\n+          <dd>Speaking rate relative to the default rate for this voice. 1.0 is the default rate, normally around 180 to 220 words per minute, 2.0 would be twice as fast, and 0.5 would be half as fast. Values below 0.1 or above 10.0 are strictly disallowed, but many voices will constrain the minimum and maximum rates further - i.e. a particular voice may not actually speak faster than 3 times normal even if you specify a value larger than 3.0.</dd>\n           <dd style=\""display: none; \"">\n             This parameter was added in version\n             <b><span></span></b>.\n@@ -1256,7 +1513,7 @@ <h4>Parameters</h4>\n               </div><div>\n                 <div>\n           <dt>\n-            <var>volume</var>\n+            <var>pitch</var>\n               <em>\n \n                 <!-- TYPE -->\n@@ -1284,7 +1541,7 @@ <h4>Parameters</h4>\n           <dd class=\""todo\"" style=\""display: none; \"">\n             Undocumented.\n           </dd>\n-          <dd>Speaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being highest, with a default of 1.0.</dd>\n+          <dd>Speaking pitch between 0 and 2 inclusive, with 0 being lowest and 1 being highest, with 1.0 being the default pitch of this particular voice.</dd>\n           <dd style=\""display: none; \"">\n             This parameter was added in version\n             <b><span></span></b>.\n@@ -1321,12 +1578,60 @@ <h4>Parameters</h4>\n           </dd>\n \n         </div>\n-              </div>\n-            </dl>\n-          </dd>\n+              </div><div>\n+                <div>\n+          <dt>\n+            <var>volume</var>\n+              <em>\n \n-          <!-- OBJECT METHODS -->\n-          <dd style=\""display: none; \"">\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span style=\""display: none; \"">\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>number</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>Speaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being highest, with a default of 1.0.</dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd style=\""display: none; \"">\n+            <dl>\n+              <div>\n+                <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n             <div></div>\n           </dd>\n \n@@ -1341,10 +1646,10 @@ <h4>Parameters</h4>\n           </dd>\n \n         </div>\n-                  </div><div>\n-                    <div>\n+              </div><div>\n+                <div>\n           <dt>\n-            <var>callback</var>\n+            <var>requiredEventTypes</var>\n               <em>\n \n                 <!-- TYPE -->\n@@ -1356,11 +1661,22 @@ <h4>Parameters</h4>\n                       <span style=\""display: none; \"">\n                         <a> Type</a>\n                       </span>\n+                      <span>\n+                        <span>\n+                          array of <span><span>\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n                       <span>\n                         <span style=\""display: none; \"">\n                           array of <span><span></span></span>\n                         </span>\n-                        <span>function</span>\n+                        <span>string</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span></span>\n+                        </span>\n+                        <span style=\""display: none; \"">paramType</span>\n                         <span style=\""display: none; \""></span>\n                       </span>\n                     </span>\n@@ -1372,7 +1688,7 @@ <h4>Parameters</h4>\n           <dd class=\""todo\"" style=\""display: none; \"">\n             Undocumented.\n           </dd>\n-          <dd>This function is called when speaking is finished.</dd>\n+          <dd>The TTS event types the voice must support. If missing, this criteria will not be used to filter voices.</dd>\n           <dd style=\""display: none; \"">\n             This parameter was added in version\n             <b><span></span></b>.\n@@ -1409,79 +1725,321 @@ <h4>Parameters</h4>\n           </dd>\n \n         </div>\n-                  </div>\n-                </dl>\n+              </div><div>\n+                <div>\n+          <dt>\n+            <var>desiredEventTypes</var>\n+              <em>\n \n-                <!-- RETURNS -->\n-                <h4 style=\""display: none; \"">Returns</h4>\n-                <dl>\n-                  <div style=\""display: none; \"">\n-                    <div>\n-                    </div>\n-                  </div>\n-                </dl>\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span>\n+                          array of <span><span>\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span style=\""display: none; \"">\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>string</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span></span>\n+                        </span>\n+                        <span style=\""display: none; \"">paramType</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n \n-                <!-- CALLBACK -->\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>The TTS event types that should be sent. If missing, all event types will be sent.</dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd style=\""display: none; \"">\n+            <dl>\n+              <div>\n                 <div>\n-                  <div>\n-                  <h4>Callback function</h4>\n-                  <p style=\""display: none; \"">\n-                    The callback <em>parameter</em> should specify a function\n-                    that looks like this:\n-                  </p>\n-                  <p>\n-                    If you specify the <em>callback</em> parameter, it should\n-                    specify a function that looks like this:\n-                  </p>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n \n-                  <!-- Note: intentionally longer 80 columns -->\n-                  <pre>function(<span></span>) <span class=\""subdued\"">{...}</span>;</pre>\n-                  <dl>\n-                    <div style=\""display: none; \"">\n-                      <div>\n-                      </div>\n-                    </div>\n-                  </dl>\n-                  </div>\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n+              </div><div>\n+                <div>\n+          <dt>\n+            <var>onevent</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span style=\""display: none; \"">\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>function</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span>\n+                  )\n                 </div>\n \n-                <!-- MIN_VERSION -->\n-                <p style=\""display: none; \"">\n-                  This function was added in version <b><span></span></b>.\n-                  If you require this function, the manifest key\n-                  <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n-                  can ensure that your extension won't be run in an earlier browser version.\n-                </p>\n-              </div> <!-- /description -->\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>This function is called with events that occur in the process of speaking the utterance.</dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n \n-            </div><div class=\""apiItem\"" style=\""display: none; \"">\n-              <a></a> <!-- method-anchor -->\n-              <h4>method name</h4>\n+          <!-- OBJECT PROPERTIES -->\n+          <dd style=\""display: none; \"">\n+            <dl>\n+              <div>\n+                <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n \n-              <div class=\""summary\""><span>void</span>\n-                  <!-- Note: intentionally longer 80 columns -->\n-                  <span>chrome.module.methodName</span>(<span><span>, </span><span></span>\n-                      <var><span></span></var></span>)</div>\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n \n-              <div class=\""description\"">\n-                <p class=\""todo\"">Undocumented.</p>\n-                <p>\n-                  A description from the json schema def of the function goes here.\n-                </p>\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n \n-                <!-- PARAMETERS -->\n-                <h4>Parameters</h4>\n-                <dl>\n-                  <div>\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd>\n+            <div>\n+          <h5>Parameters</h5>\n+          <dl>\n+            <div>\n+              <div>\n+          <dt>\n+            <var>event</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"" style=\""display: none; \"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span>\n+                        <a href=\""experimental.tts.html#type-TtsEvent\"">TtsEvent</a>\n+                      </span>\n+                      <span style=\""display: none; \"">\n+                        <span>\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>paramType</span>\n+                        <span></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>The update event from the text-to-speech engine indicating the status of this utterance.</dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd style=\""display: none; \"">\n+            <dl>\n+              <div>\n+                <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n+            </div>\n+          </dl>\n+        </div>\n+          </dd>\n+\n+        </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n+                  </div><div>\n                     <div>\n-                    </div>\n+          <dt>\n+            <var>callback</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span style=\""display: none; \"">\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>function</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>Called right away, before speech finishes. Check chrome.extension.lastError to make sure there were no errors. Use options.onevent to get more detailed feedback.</dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd style=\""display: none; \"">\n+            <dl>\n+              <div>\n+                <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n                   </div>\n                 </dl>\n \n                 <!-- RETURNS -->\n-                <h4>Returns</h4>\n+                <h4 style=\""display: none; \"">Returns</h4>\n                 <dl>\n-                  <div>\n+                  <div style=\""display: none; \"">\n                     <div>\n                     </div>\n                   </div>\n@@ -1491,7 +2049,7 @@ <h4>Returns</h4>\n                 <div>\n                   <div>\n                   <h4>Callback function</h4>\n-                  <p>\n+                  <p style=\""display: none; \"">\n                     The callback <em>parameter</em> should specify a function\n                     that looks like this:\n                   </p>\n@@ -1501,9 +2059,9 @@ <h4>Callback function</h4>\n                   </p>\n \n                   <!-- Note: intentionally longer 80 columns -->\n-                  <pre>function(<span>Type param1, Type param2</span>) <span class=\""subdued\"">{...}</span>;</pre>\n+                  <pre>function(<span></span>) <span class=\""subdued\"">{...}</span>;</pre>\n                   <dl>\n-                    <div>\n+                    <div style=\""display: none; \"">\n                       <div>\n                       </div>\n                     </div>\n@@ -1512,7 +2070,7 @@ <h4>Callback function</h4>\n                 </div>\n \n                 <!-- MIN_VERSION -->\n-                <p>\n+                <p style=\""display: none; \"">\n                   This function was added in version <b><span></span></b>.\n                   If you require this function, the manifest key\n                   <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n@@ -1589,38 +2147,126 @@ <h4>Callback function</h4>\n           </div>  <!-- /apiGroup -->\n \n           <!-- EVENTS -->\n-          <div id=\""eventsTemplate\"" class=\""apiGroup\"">\n-            <a name=\""global-events\""></a>\n+          <div id=\""eventsTemplate\"" class=\""apiGroup\"" style=\""display: none; \"">\n+            <a></a>\n             <h3>Events</h3>\n             <!-- iterates over all events -->\n             <div class=\""apiItem\"">\n-              <a name=\""event-onSpeak\""></a>\n-              <h4>onSpeak</h4>\n+              <a></a>\n+              <h4>event name</h4>\n \n               <div class=\""summary\"">\n                 <!-- Note: intentionally longer 80 columns -->\n-                <span class=\""subdued\"">chrome.experimental.tts.</span><span>onSpeak</span><span class=\""subdued\"">.addListener</span>(function(<span>string utterance, object options, function callback</span>) <span class=\""subdued\"">{...}</span><span></span>));\n+                <span class=\""subdued\"">chrome.bookmarks</span><span>onEvent</span><span class=\""subdued\"">.addListener</span>(function(<span>Type param1, Type param2</span>) <span class=\""subdued\"">{...}</span><span>, Type opt_param1, Type opt_param2</span>));\n               </div>\n \n               <div class=\""description\"">\n-                <p class=\""todo\"" style=\""display: none; \"">Undocumented.</p>\n-                <p>Called when the user makes a call to tts.speak and the options matches one of the tts_voices from this extension's manifest.</p>\n+                <p class=\""todo\"">Undocumented.</p>\n+                <p>\n+                  A description from the json schema def of the event goes here.\n+                </p>\n+\n+                <!-- LISTENER PARAMETERS -->\n+                <div>\n+                  <h4>Listener parameters</h4>\n+                  <dl>\n+                    <div>\n+                      <div>\n+                      </div>\n+                    </div>\n+                  </dl>\n+                </div>\n+\n+                <!-- EXTRA PARAMETERS -->\n+                <div>\n+                  <h4>Extra parameters to addListener</h4>\n+                  <dl>\n+                    <div>\n+                      <div>\n+                      </div>\n+                    </div>\n+                  </dl>\n+                </div>\n+\n+                <!-- LISTENER RETURN VALUE -->\n+                <h4>Listener returns</h4>\n+                <dl>\n+                  <div>\n+                    <div>\n+                    </div>\n+                  </div>\n+                </dl>\n+\n+              </div> <!-- /description -->\n+            </div> <!-- /apiItem -->\n+\n+          </div> <!-- /apiGroup -->\n+\n+          <!-- TYPES -->\n+          <div class=\""apiGroup\"">\n+            <a name=\""types\""></a>\n+            <h3 id=\""types\"">Types</h3>\n+\n+            <!-- iterates over all types -->\n+            <div class=\""apiItem\"">\n+              <a name=\""type-TtsEvent\""></a>\n+              <h4>TtsEvent</h4>\n+\n+              <div>\n+          <dt>\n+            <var style=\""display: none; \"">paramName</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"" style=\""display: none; \"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span style=\""display: none; \"">\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>object</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>An event from the TTS engine to communicate the status of an utterance.</dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n \n-                <!-- LISTENER PARAMETERS -->\n+          <!-- OBJECT PROPERTIES -->\n+          <dd>\n+            <dl>\n+              <div>\n                 <div>\n-                  <h4>Listener parameters</h4>\n-                  <dl>\n-                    <div>\n-                      <div>\n           <dt>\n-            <var>utterance</var>\n+            <var>type</var>\n               <em>\n \n                 <!-- TYPE -->\n                 <div style=\""display:inline\"">\n                   (\n                     <span class=\""optional\"" style=\""display: none; \"">optional</span>\n-                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span class=\""enum\"">enumerated</span>\n                     <span id=\""typeTemplate\"">\n                       <span style=\""display: none; \"">\n                         <a> Type</a>\n@@ -1630,7 +2276,7 @@ <h4>Listener parameters</h4>\n                           array of <span><span></span></span>\n                         </span>\n                         <span>string</span>\n-                        <span style=\""display: none; \""></span>\n+                        <span>[\""start\"", \""end\"", \""word\"", \""sentence\"", \""marker\"", \""interrupted\"", \""cancelled\"", \""error\""]</span>\n                       </span>\n                     </span>\n                   )\n@@ -1641,7 +2287,7 @@ <h4>Listener parameters</h4>\n           <dd class=\""todo\"" style=\""display: none; \"">\n             Undocumented.\n           </dd>\n-          <dd>The text to speak. This may include SSML, so if your engine does not support SSML, you should strip out all XML markup and synthesize only the underlying text content.</dd>\n+          <dd>The message can be 'start' when this utterance is begun to be spoken, 'word' when a word boundary is reached, 'sentence' when a sentence boundary is reached, 'marker' when an SSML mark element is reached, 'end' when the end of the utterance is reached, 'interrupted' when the utterance is stopped or interrupted before reaching the end, 'cancelled' when it's removed from the queue before ever being synthesized, and 'error' when any other error occurs. Clients will always receive 'end', 'cancelled', 'interrupted', or 'error', and other events will depend on the engine.</dd>\n           <dd style=\""display: none; \"">\n             This parameter was added in version\n             <b><span></span></b>.\n@@ -1678,16 +2324,16 @@ <h4>Listener parameters</h4>\n           </dd>\n \n         </div>\n-                    </div><div>\n-                      <div>\n+              </div><div>\n+                <div>\n           <dt>\n-            <var>options</var>\n+            <var>charIndex</var>\n               <em>\n \n                 <!-- TYPE -->\n                 <div style=\""display:inline\"">\n                   (\n-                    <span class=\""optional\"" style=\""display: none; \"">optional</span>\n+                    <span class=\""optional\"">optional</span>\n                     <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n                     <span id=\""typeTemplate\"">\n                       <span style=\""display: none; \"">\n@@ -1697,7 +2343,7 @@ <h4>Listener parameters</h4>\n                         <span style=\""display: none; \"">\n                           array of <span><span></span></span>\n                         </span>\n-                        <span>object</span>\n+                        <span>number</span>\n                         <span style=\""display: none; \""></span>\n                       </span>\n                     </span>\n@@ -1709,7 +2355,7 @@ <h4>Listener parameters</h4>\n           <dd class=\""todo\"" style=\""display: none; \"">\n             Undocumented.\n           </dd>\n-          <dd>The speak options.</dd>\n+          <dd>The index of the current character in the utterance.</dd>\n           <dd style=\""display: none; \"">\n             This parameter was added in version\n             <b><span></span></b>.\n@@ -1721,12 +2367,35 @@ <h4>Listener parameters</h4>\n           </dd>\n \n           <!-- OBJECT PROPERTIES -->\n-          <dd>\n+          <dd style=\""display: none; \"">\n             <dl>\n               <div>\n                 <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n+              </div><div>\n+                <div>\n           <dt>\n-            <var>voiceName</var>\n+            <var>errorMessage</var>\n               <em>\n \n                 <!-- TYPE -->\n@@ -1754,7 +2423,7 @@ <h4>Listener parameters</h4>\n           <dd class=\""todo\"" style=\""display: none; \"">\n             Undocumented.\n           </dd>\n-          <dd>The name of the voice to use for synthesis.</dd>\n+          <dd>The error message, if the message is 'error'.</dd>\n           <dd style=\""display: none; \"">\n             This parameter was added in version\n             <b><span></span></b>.\n@@ -1791,16 +2460,40 @@ <h4>Listener parameters</h4>\n           </dd>\n \n         </div>\n-              </div><div>\n-                <div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n+\n+            </div><div class=\""apiItem\"">\n+              <a name=\""type-TtsVoice\""></a>\n+              <h4>TtsVoice</h4>\n+\n+              <div>\n           <dt>\n-            <var>locale</var>\n+            <var style=\""display: none; \"">paramName</var>\n               <em>\n \n                 <!-- TYPE -->\n                 <div style=\""display:inline\"">\n                   (\n-                    <span class=\""optional\"">optional</span>\n+                    <span class=\""optional\"" style=\""display: none; \"">optional</span>\n                     <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n                     <span id=\""typeTemplate\"">\n                       <span style=\""display: none; \"">\n@@ -1810,7 +2503,7 @@ <h4>Listener parameters</h4>\n                         <span style=\""display: none; \"">\n                           array of <span><span></span></span>\n                         </span>\n-                        <span>string</span>\n+                        <span>object</span>\n                         <span style=\""display: none; \""></span>\n                       </span>\n                     </span>\n@@ -1822,7 +2515,7 @@ <h4>Listener parameters</h4>\n           <dd class=\""todo\"" style=\""display: none; \"">\n             Undocumented.\n           </dd>\n-          <dd>The language and region code that specify the language and dialect to be used for synthesis, in the form <language>-<region>, e.g. en-US, en-GB, fr-CA, zh-CN, etc.</region></language></dd>\n+          <dd>A description of a voice available for speech synthesis.</dd>\n           <dd style=\""display: none; \"">\n             This parameter was added in version\n             <b><span></span></b>.\n@@ -1834,42 +2527,19 @@ <h4>Listener parameters</h4>\n           </dd>\n \n           <!-- OBJECT PROPERTIES -->\n-          <dd style=\""display: none; \"">\n+          <dd>\n             <dl>\n               <div>\n                 <div>\n-                </div>\n-              </div>\n-            </dl>\n-          </dd>\n-\n-          <!-- OBJECT METHODS -->\n-          <dd style=\""display: none; \"">\n-            <div></div>\n-          </dd>\n-\n-          <!-- OBJECT EVENT FIELDS -->\n-          <dd style=\""display: none; \"">\n-            <div></div>\n-          </dd>\n-\n-          <!-- FUNCTION PARAMETERS -->\n-          <dd style=\""display: none; \"">\n-            <div></div>\n-          </dd>\n-\n-        </div>\n-              </div><div>\n-                <div>\n           <dt>\n-            <var>gender</var>\n+            <var>voiceName</var>\n               <em>\n \n                 <!-- TYPE -->\n                 <div style=\""display:inline\"">\n                   (\n                     <span class=\""optional\"">optional</span>\n-                    <span class=\""enum\"">enumerated</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n                     <span id=\""typeTemplate\"">\n                       <span style=\""display: none; \"">\n                         <a> Type</a>\n@@ -1879,7 +2549,7 @@ <h4>Listener parameters</h4>\n                           array of <span><span></span></span>\n                         </span>\n                         <span>string</span>\n-                        <span>[\""male\"", \""female\""]</span>\n+                        <span style=\""display: none; \""></span>\n                       </span>\n                     </span>\n                   )\n@@ -1890,7 +2560,7 @@ <h4>Listener parameters</h4>\n           <dd class=\""todo\"" style=\""display: none; \"">\n             Undocumented.\n           </dd>\n-          <dd>Gender of voice for synthesized speech.</dd>\n+          <dd>The name of the voice.</dd>\n           <dd style=\""display: none; \"">\n             This parameter was added in version\n             <b><span></span></b>.\n@@ -1930,7 +2600,7 @@ <h4>Listener parameters</h4>\n               </div><div>\n                 <div>\n           <dt>\n-            <var>rate</var>\n+            <var>lang</var>\n               <em>\n \n                 <!-- TYPE -->\n@@ -1946,7 +2616,7 @@ <h4>Listener parameters</h4>\n                         <span style=\""display: none; \"">\n                           array of <span><span></span></span>\n                         </span>\n-                        <span>number</span>\n+                        <span>string</span>\n                         <span style=\""display: none; \""></span>\n                       </span>\n                     </span>\n@@ -1958,7 +2628,7 @@ <h4>Listener parameters</h4>\n           <dd class=\""todo\"" style=\""display: none; \"">\n             Undocumented.\n           </dd>\n-          <dd>Speaking speed between 0 and 1 inclusive, with 0 being slowest and 1 being fastest.</dd>\n+          <dd>The language that this voice supports, in the form &lt;language&gt;-&lt;region&gt;. Examples: 'en', 'en-US', 'en-GB', 'zh-CN', etc.</dd>\n           <dd style=\""display: none; \"">\n             This parameter was added in version\n             <b><span></span></b>.\n@@ -1998,14 +2668,14 @@ <h4>Listener parameters</h4>\n               </div><div>\n                 <div>\n           <dt>\n-            <var>pitch</var>\n+            <var>gender</var>\n               <em>\n \n                 <!-- TYPE -->\n                 <div style=\""display:inline\"">\n                   (\n                     <span class=\""optional\"">optional</span>\n-                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span class=\""enum\"">enumerated</span>\n                     <span id=\""typeTemplate\"">\n                       <span style=\""display: none; \"">\n                         <a> Type</a>\n@@ -2014,8 +2684,8 @@ <h4>Listener parameters</h4>\n                         <span style=\""display: none; \"">\n                           array of <span><span></span></span>\n                         </span>\n-                        <span>number</span>\n-                        <span style=\""display: none; \""></span>\n+                        <span>string</span>\n+                        <span>[\""male\"", \""female\""]</span>\n                       </span>\n                     </span>\n                   )\n@@ -2026,7 +2696,7 @@ <h4>Listener parameters</h4>\n           <dd class=\""todo\"" style=\""display: none; \"">\n             Undocumented.\n           </dd>\n-          <dd>Speaking pitch between 0 and 1 inclusive, with 0 being lowest and 1 being highest.</dd>\n+          <dd>This voice's gender.</dd>\n           <dd style=\""display: none; \"">\n             This parameter was added in version\n             <b><span></span></b>.\n@@ -2066,7 +2736,7 @@ <h4>Listener parameters</h4>\n               </div><div>\n                 <div>\n           <dt>\n-            <var>volume</var>\n+            <var>extensionId</var>\n               <em>\n \n                 <!-- TYPE -->\n@@ -2082,7 +2752,7 @@ <h4>Listener parameters</h4>\n                         <span style=\""display: none; \"">\n                           array of <span><span></span></span>\n                         </span>\n-                        <span>number</span>\n+                        <span>string</span>\n                         <span style=\""display: none; \""></span>\n                       </span>\n                     </span>\n@@ -2094,7 +2764,7 @@ <h4>Listener parameters</h4>\n           <dd class=\""todo\"" style=\""display: none; \"">\n             Undocumented.\n           </dd>\n-          <dd>Speaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being highest.</dd>\n+          <dd>The ID of the extension providing this voice.</dd>\n           <dd style=\""display: none; \"">\n             This parameter was added in version\n             <b><span></span></b>.\n@@ -2131,46 +2801,37 @@ <h4>Listener parameters</h4>\n           </dd>\n \n         </div>\n-              </div>\n-            </dl>\n-          </dd>\n-\n-          <!-- OBJECT METHODS -->\n-          <dd style=\""display: none; \"">\n-            <div></div>\n-          </dd>\n-\n-          <!-- OBJECT EVENT FIELDS -->\n-          <dd style=\""display: none; \"">\n-            <div></div>\n-          </dd>\n-\n-          <!-- FUNCTION PARAMETERS -->\n-          <dd style=\""display: none; \"">\n-            <div></div>\n-          </dd>\n-\n-        </div>\n-                    </div><div>\n-                      <div>\n+              </div><div>\n+                <div>\n           <dt>\n-            <var>callback</var>\n+            <var>eventTypes</var>\n               <em>\n \n                 <!-- TYPE -->\n                 <div style=\""display:inline\"">\n                   (\n-                    <span class=\""optional\"" style=\""display: none; \"">optional</span>\n+                    <span class=\""optional\"">optional</span>\n                     <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n                     <span id=\""typeTemplate\"">\n                       <span style=\""display: none; \"">\n                         <a> Type</a>\n                       </span>\n+                      <span>\n+                        <span>\n+                          array of <span><span>\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n                       <span>\n                         <span style=\""display: none; \"">\n                           array of <span><span></span></span>\n                         </span>\n-                        <span>function</span>\n+                        <span>string</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span></span>\n+                        </span>\n+                        <span style=\""display: none; \"">paramType</span>\n                         <span style=\""display: none; \""></span>\n                       </span>\n                     </span>\n@@ -2182,7 +2843,7 @@ <h4>Listener parameters</h4>\n           <dd class=\""todo\"" style=\""display: none; \"">\n             Undocumented.\n           </dd>\n-          <dd>You must call this function when speaking is finished.</dd>\n+          <dd>All of the callback event types that this voice is capable of sending.</dd>\n           <dd style=\""display: none; \"">\n             This parameter was added in version\n             <b><span></span></b>.\n@@ -2219,92 +2880,26 @@ <h4>Listener parameters</h4>\n           </dd>\n \n         </div>\n-                    </div>\n-                  </dl>\n-                </div>\n-\n-                <!-- EXTRA PARAMETERS -->\n-                <div style=\""display: none; \"">\n-                  <h4>Extra parameters to addListener</h4>\n-                  <dl>\n-                    <div>\n-                      <div>\n-                      </div>\n-                    </div>\n-                  </dl>\n-                </div>\n-\n-                <!-- LISTENER RETURN VALUE -->\n-                <h4 style=\""display: none; \"">Listener returns</h4>\n-                <dl>\n-                  <div style=\""display: none; \"">\n-                    <div>\n-                    </div>\n-                  </div>\n-                </dl>\n-\n-              </div> <!-- /description -->\n-            </div><div class=\""apiItem\"">\n-              <a name=\""event-onStop\""></a>\n-              <h4>onStop</h4>\n-\n-              <div class=\""summary\"">\n-                <!-- Note: intentionally longer 80 columns -->\n-                <span class=\""subdued\"">chrome.experimental.tts.</span><span>onStop</span><span class=\""subdued\"">.addListener</span>(function(<span></span>) <span class=\""subdued\"">{...}</span><span></span>));\n               </div>\n+            </dl>\n+          </dd>\n \n-              <div class=\""description\"">\n-                <p class=\""todo\"" style=\""display: none; \"">Undocumented.</p>\n-                <p>Fired when a call is made to tts.stop and this extension may be in the middle of speaking. If an extension receives a call to onStop and speech is already stopped, it should do nothing (not raise an error).</p>\n-\n-                <!-- LISTENER PARAMETERS -->\n-                <div style=\""display: none; \"">\n-                  <h4>Listener parameters</h4>\n-                  <dl>\n-                    <div>\n-                      <div>\n-                      </div>\n-                    </div>\n-                  </dl>\n-                </div>\n-\n-                <!-- EXTRA PARAMETERS -->\n-                <div style=\""display: none; \"">\n-                  <h4>Extra parameters to addListener</h4>\n-                  <dl>\n-                    <div>\n-                      <div>\n-                      </div>\n-                    </div>\n-                  </dl>\n-                </div>\n-\n-                <!-- LISTENER RETURN VALUE -->\n-                <h4 style=\""display: none; \"">Listener returns</h4>\n-                <dl>\n-                  <div style=\""display: none; \"">\n-                    <div>\n-                    </div>\n-                  </div>\n-                </dl>\n-\n-              </div> <!-- /description -->\n-            </div> <!-- /apiItem -->\n-\n-          </div> <!-- /apiGroup -->\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n \n-          <!-- TYPES -->\n-          <div class=\""apiGroup\"" style=\""display: none; \"">\n-            <a name=\""types\""></a>\n-            <h3 id=\""types\"">Types</h3>\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n \n-            <!-- iterates over all types -->\n-            <div class=\""apiItem\"">\n-              <a></a>\n-              <h4>type name</h4>\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n \n-              <div>\n-              </div>\n+        </div>\n \n             </div> <!-- /apiItem -->\n ""}<_**next**_>{""sha"": ""d92354f8d09598e52150217e7a9a1f1f1140dcef"", ""filename"": ""chrome/common/extensions/docs/experimental.ttsEngine.html"", ""status"": ""added"", ""additions"": 1468, ""deletions"": 0, ""changes"": 1468, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/docs/experimental.ttsEngine.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/docs/experimental.ttsEngine.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/docs/experimental.ttsEngine.html?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,1468 @@\n+<!DOCTYPE html><!-- This page is a placeholder for generated extensions api doc. Note:\n+    1) The <head> information in this page is significant, should be uniform\n+       across api docs and should be edited only with knowledge of the\n+       templating mechanism.\n+    3) All <body>.innerHTML is genereated as an rendering step. If viewed in a\n+       browser, it will be re-generated from the template, json schema and\n+       authored overview content.\n+    4) The <body>.innerHTML is also generated by an offline step so that this\n+       page may easily be indexed by search engines.\n+--><html xmlns=\""http://www.w3.org/1999/xhtml\""><head>\n+    <meta http-equiv=\""Content-Type\"" content=\""text/html; charset=UTF-8\"">\n+    <link href=\""css/ApiRefStyles.css\"" rel=\""stylesheet\"" type=\""text/css\"">\n+    <link href=\""css/print.css\"" rel=\""stylesheet\"" type=\""text/css\"" media=\""print\"">\n+    <script type=\""text/javascript\"" src=\""../../../third_party/jstemplate/jstemplate_compiled.js\"">\n+    </script>\n+    <script type=\""text/javascript\"" src=\""js/api_page_generator.js\""></script>\n+    <script type=\""text/javascript\"" src=\""js/bootstrap.js\""></script>\n+    <script type=\""text/javascript\"" src=\""js/sidebar.js\""></script>\n+  <title>chrome.experimental.ttsEngine - Google Chrome Extensions - Google Code</title></head>\n+  <body>  <div id=\""gc-container\"" class=\""labs\"">\n+      <div id=\""devModeWarning\"">\n+        You are viewing extension docs in chrome via the 'file:' scheme: are you expecting to see local changes when you refresh? You'll need run chrome with --allow-file-access-from-files.\n+      </div>\n+      <!-- SUBTEMPLATES: DO NOT MOVE FROM THIS LOCATION -->\n+      <!-- In particular, sub-templates that recurse, must be used by allowing\n+           jstemplate to make a copy of the template in this section which\n+           are not operated on by way of the jsskip=\""true\"" -->\n+      <div style=\""display:none\"">\n+\n+        <!-- VALUE -->\n+        <div id=\""valueTemplate\"">\n+          <dt>\n+            <var>paramName</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"">optional</span>\n+                    <span class=\""enum\"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span>\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span>\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>paramType</span>\n+                        <span></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"">\n+            Undocumented.\n+          </dd>\n+          <dd>\n+            Description of this parameter from the json schema.\n+          </dd>\n+          <dd>\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd>\n+            <dl>\n+              <div>\n+                <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd>\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd>\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd>\n+            <div></div>\n+          </dd>\n+\n+        </div> <!-- /VALUE -->\n+\n+        <div id=\""functionParametersTemplate\"">\n+          <h5>Parameters</h5>\n+          <dl>\n+            <div>\n+              <div>\n+              </div>\n+            </div>\n+          </dl>\n+        </div>\n+      </div> <!-- /SUBTEMPLATES -->\n+\n+  <a id=\""top\""></a>\n+    <div id=\""skipto\"">\n+      <a href=\""#gc-pagecontent\"">Skip to page content</a>\n+      <a href=\""#gc-toc\"">Skip to main navigation</a>\n+    </div>\n+    <!-- API HEADER -->\n+    <table id=\""header\"" width=\""100%\"" cellspacing=\""0\"" border=\""0\"">\n+      <tbody><tr>\n+        <td valign=\""middle\""><a href=\""http://code.google.com/\""><img src=\""images/code_labs_logo.gif\"" height=\""43\"" width=\""161\"" alt=\""Google Code Labs\"" style=\""border:0; margin:0;\""></a></td>\n+        <td valign=\""middle\"" width=\""100%\"" style=\""padding-left:0.6em;\"">\n+          <form action=\""http://www.google.com/cse\"" id=\""cse\"" style=\""margin-top:0.5em\"">\n+            <div id=\""gsc-search-box\"">\n+              <input type=\""hidden\"" name=\""cx\"" value=\""002967670403910741006:61_cvzfqtno\"">\n+              <input type=\""hidden\"" name=\""ie\"" value=\""UTF-8\"">\n+              <input type=\""text\"" name=\""q\"" value=\""\"" size=\""55\"">\n+              <input class=\""gsc-search-button\"" type=\""submit\"" name=\""sa\"" value=\""Search\"">\n+              <br>\n+              <span class=\""greytext\"">e.g. \""page action\"" or \""tabs\""</span>\n+            </div>\n+          </form>\n+\n+          <script type=\""text/javascript\"" src=\""http://www.google.com/jsapi\""></script>\n+          <script type=\""text/javascript\"">google.load(\""elements\"", \""1\"", {packages: \""transliteration\""});</script>\n+          <script type=\""text/javascript\"" src=\""http://www.google.com/coop/cse/t13n?form=cse&amp;t13n_langs=en\""></script>\n+          <script type=\""text/javascript\"" src=\""http://www.google.com/coop/cse/brand?form=cse&amp;lang=en\""></script>\n+        </td>\n+      </tr>\n+    </tbody></table>\n+\n+    <div id=\""codesiteContent\"" class=\""\"">\n+\n+      <a id=\""gc-topnav-anchor\""></a>\n+      <div id=\""gc-topnav\"">\n+        <h1>Google Chrome Extensions (<a href=\""http://code.google.com/labs/\"">Labs</a>)</h1>\n+        <ul id=\""home\"" class=\""gc-topnav-tabs\"">\n+          <li id=\""home_link\"">\n+            <a href=\""index.html\"" title=\""Google Chrome Extensions home page\"">Home</a>\n+          </li>\n+          <li id=\""docs_link\"">\n+            <a href=\""docs.html\"" title=\""Official Google Chrome Extensions documentation\"">Docs</a>\n+          </li>\n+          <li id=\""faq_link\"">\n+            <a href=\""faq.html\"" title=\""Answers to frequently asked questions about Google Chrome Extensions\"">FAQ</a>\n+          </li>\n+          <li id=\""samples_link\"">\n+            <a href=\""samples.html\"" title=\""Sample extensions (with source code)\"">Samples</a>\n+          </li>\n+          <li id=\""group_link\"">\n+            <a href=\""http://groups.google.com/a/chromium.org/group/chromium-extensions\"" title=\""Google Chrome Extensions developer forum\"">Group</a>\n+          </li>\n+        </ul>\n+      </div> <!-- end gc-topnav -->\n+\n+    <div class=\""g-section g-tpl-170\"">\n+      <!-- SIDENAV -->\n+      <div class=\""g-unit g-first\"" id=\""gc-toc\"">\n+        <ul>\n+          <li><a href=\""getstarted.html\"">Getting Started</a></li>\n+          <li><a href=\""overview.html\"">Overview</a></li>\n+          <li><a href=\""whats_new.html\"">What's New?</a></li>\n+          <li><h2><a href=\""devguide.html\"">Developer's Guide</a></h2>\n+            <ul>\n+              <li>Browser UI\n+                <ul>\n+                  <li><a href=\""browserAction.html\"">Browser Actions</a></li>\n+                  <li><a href=\""contextMenus.html\"">Context Menus</a></li>\n+                  <li><a href=\""notifications.html\"">Desktop Notifications</a></li>\n+                  <li><a href=\""omnibox.html\"">Omnibox</a></li>\n+                  <li><a href=\""options.html\"">Options Pages</a></li>\n+                  <li><a href=\""override.html\"">Override Pages</a></li>\n+                  <li><a href=\""pageAction.html\"">Page Actions</a></li>\n+                </ul>\n+              </li>\n+              <li>Browser Interaction\n+                <ul>\n+                  <li><a href=\""bookmarks.html\"">Bookmarks</a></li>\n+                  <li><a href=\""cookies.html\"">Cookies</a></li>\n+                  <li><a href=\""events.html\"">Events</a></li>\n+                  <li><a href=\""history.html\"">History</a></li>\n+                  <li><a href=\""management.html\"">Management</a></li>\n+                  <li><a href=\""tabs.html\"">Tabs</a></li>\n+                  <li><a href=\""windows.html\"">Windows</a></li>\n+                </ul>\n+              </li>\n+              <li>Implementation\n+                <ul>\n+                  <li><a href=\""a11y.html\"">Accessibility</a></li>\n+                  <li><a href=\""background_pages.html\"">Background Pages</a></li>\n+                  <li><a href=\""content_scripts.html\"">Content Scripts</a></li>\n+                  <li><a href=\""xhr.html\"">Cross-Origin XHR</a></li>\n+                  <li><a href=\""idle.html\"">Idle</a></li>\n+                  <li><a href=\""i18n.html\"">Internationalization</a></li>\n+                  <li><a href=\""messaging.html\"">Message Passing</a></li>\n+                  <li><a href=\""npapi.html\"">NPAPI Plugins</a></li>\n+                </ul>\n+              </li>\n+              <li>Finishing\n+                <ul>\n+                  <li><a href=\""hosting.html\"">Hosting</a></li>\n+                  <li><a href=\""external_extensions.html\"">Other Deployment Options</a></li>\n+                </ul>\n+              </li>\n+            </ul>\n+          </li>\n+          <li><h2><a href=\""apps.html\"">Packaged Apps</a></h2></li>\n+          <li><h2><a href=\""tutorials.html\"">Tutorials</a></h2>\n+            <ul>\n+              <li><a href=\""tut_debugging.html\"">Debugging</a></li>\n+              <li><a href=\""tut_analytics.html\"">Google Analytics</a></li>\n+              <li><a href=\""tut_oauth.html\"">OAuth</a></li>\n+            </ul>\n+          </li>\n+          <li><h2>Reference</h2>\n+            <ul>\n+              <li>Formats\n+                <ul>\n+                  <li><a href=\""manifest.html\"">Manifest Files</a></li>\n+                  <li><a href=\""match_patterns.html\"">Match Patterns</a></li>\n+                </ul>\n+              </li>\n+              <li><a href=\""permission_warnings.html\"">Permission Warnings</a></li>\n+              <li><a href=\""api_index.html\"">chrome.* APIs</a></li>\n+              <li><a href=\""api_other.html\"">Other APIs</a></li>\n+            </ul>\n+          </li>\n+          <li><h2><a href=\""samples.html\"">Samples</a></h2></li>\n+          <div class=\""line\""> </div>\n+          <li><h2>More</h2>\n+            <ul>\n+              <li><a href=\""http://code.google.com/chrome/webstore/docs/index.html\"">Chrome Web Store</a></li>\n+              <li><a href=\""http://code.google.com/chrome/apps/docs/developers_guide.html\"">Hosted Apps</a></li>\n+              <li><a href=\""themes.html\"">Themes</a></li>\n+            </ul>\n+          </li>\n+        </ul>\n+      </div>\n+      <script>\n+        initToggles();\n+      </script>\n+\n+    <div class=\""g-unit\"" id=\""gc-pagecontent\"">\n+      <div id=\""pageTitle\"">\n+        <h1 class=\""page_title\"">chrome.experimental.ttsEngine</h1>\n+      </div>\n+        <!-- TABLE OF CONTENTS -->\n+        <div id=\""toc\"">\n+          <h2>Contents</h2>\n+          <ol>\n+            <li>\n+              <a href=\""#overview\"">Overview</a>\n+              <ol>\n+                <li style=\""display: none; \"">\n+                  <a>h3Name</a>\n+                </li>\n+              </ol>\n+            </li><li>\n+              <a href=\""#manifest\"">Manifest</a>\n+              <ol>\n+                <li style=\""display: none; \"">\n+                  <a>h3Name</a>\n+                </li>\n+              </ol>\n+            </li><li>\n+              <a href=\""#handling_speech_events\"">Handling Speech Events</a>\n+              <ol>\n+                <li style=\""display: none; \"">\n+                  <a>h3Name</a>\n+                </li>\n+              </ol>\n+            </li>\n+              <li>\n+                <a href=\""#apiReference\"">API reference: chrome.experimental.ttsEngine</a>\n+                <ol>\n+                  <li style=\""display: none; \"">\n+                    <a href=\""#properties\"">Properties</a>\n+                    <ol>\n+                      <li>\n+                        <a href=\""#property-anchor\"">propertyName</a>\n+                      </li>\n+                    </ol>\n+                  </li>\n+                  <li>\n+                    <a href=\""#global-methods\"">Methods</a>\n+                    <ol>\n+                      <li style=\""display: none; \"">\n+                        <a href=\""#method-anchor\"">methodName</a>\n+                      </li>\n+                    </ol>\n+                  </li>\n+                  <li>\n+                    <a href=\""#global-events\"">Events</a>\n+                    <ol>\n+                      <li style=\""display: none; \"">\n+                        <a href=\""#event-anchor\"">eventName</a>\n+                      </li><li>\n+                        <a href=\""#event-onSpeak\"">onSpeak</a>\n+                      </li><li>\n+                        <a href=\""#event-onStop\"">onStop</a>\n+                      </li>\n+                    </ol>\n+                  </li>\n+                  <li style=\""display: none; \"">\n+                    <a href=\""#types\"">Types</a>\n+                    <ol>\n+                      <li>\n+                        <a href=\""#id-anchor\"">id</a>\n+                      </li>\n+                    </ol>\n+                  </li>\n+                </ol>\n+              </li>\n+          </ol>\n+        </div>\n+        <!-- /TABLE OF CONTENTS -->\n+\n+        <!-- Standard content lead-in for experimental API pages -->\n+        <p id=\""classSummary\"">\n+          For information on how to use experimental APIs, see the <a href=\""experimental.html\"">chrome.experimental.* APIs</a> page.\n+        </p>\n+\n+        <!-- STATIC CONTENT PLACEHOLDER -->\n+        <div id=\""static\""><p id=\""classSummary\"">\n+Use the <code>chrome.experimental.ttsEngine</code> module to\n+implement a text-to-speech (TTS) engine using an extension. If your\n+extension registers using this API, it will receive events containing\n+the intended utterance and other parameters when any extension or packaged\n+app uses the\n+<a href=\""experimental.tts.html\"">experimental.tts</a>\n+module to generate speech. Your extension can then use any available\n+web technology to synthesize and output the speech, and send events back\n+to the calling function to report the status.\n+</p>\n+\n+<p class=\""note\""><b>Give us feedback:</b> If you have suggestions,\n+especially changes that should be made before stabilizing the first\n+version of this API, please send your ideas to the\n+<a href=\""http://groups.google.com/a/chromium.org/group/chromium-extensions\"">chromium-extensions</a>\n+group.</p>\n+\n+<h2 id=\""overview\"">Overview</h2>\n+\n+<p>To enable this experimental API, visit\n+<b>chrome://flags</b> and enable <b>Experimental Extension APIs</b>.\n+\n+</p><p>An extension can register itself as a speech engine. By doing so, it\n+can intercept some or all calls to functions such as\n+<a href=\""experimental.tts.html#method-speak\""><code>speak()</code></a> and\n+<a href=\""experimental.tts.html#method-stop\""><code>stop()</code></a>\n+and provide an alternate implementation.\n+Extensions are free to use any available web technology\n+to provide speech, including streaming audio from a server, HTML5 audio,\n+Native Client, or Flash. An extension could even do something different\n+with the utterances, like display closed captions in a pop-up window or\n+send them as log messages to a remote server.</p>\n+\n+<h2 id=\""manifest\"">Manifest</h2>\n+\n+<p>To implement a TTS engine, an extension must first declare all voices\n+it provides in the extension manifest, like this:</p>\n+\n+<pre>{\n+  \""name\"": \""My TTS Engine\"",\n+  \""version\"": \""1.0\"",\n+  <b>\""permissions\"": [\""experimental\""],\n+  \""tts_engine\"": {\n+    \""voices\"": [\n+      {\n+        \""voice_name\"": \""Alice\"",\n+        \""lang\"": \""en-US\"",\n+        \""gender\"": \""female\"",\n+        \""event_types\"": [\""start\"", \""marker\"", \""end\""]\n+      },\n+      {\n+        \""voice_name\"": \""Pat\"",\n+        \""lang\"": \""en-US\"",\n+        \""event_types\"": [\""end\""]\n+      }\n+    ]\n+  },</b>\n+  \""background_page\"": \""background.html\"",\n+}</pre>\n+\n+<p>An extension can specify any number of voices.</p>\n+\n+<p>The <code>voice_name</code> parameter is required. The name should be\n+descriptive enough that it identifies the name of the voice and the\n+engine used. In the unlikely event that two extensions register voices\n+with the same name, a client can manually specify the extension id it\n+wants to do the synthesis.</p>\n+\n+<p>The <code>gender</code> parameter is optional. If your voice corresponds\n+to a male or female voice, you can use this parameter to help clients\n+choose the most appropriate voice for their application.</p>\n+\n+<p>The <code>lang</code> parameter is optional, but highly recommended.\n+Almost always, a voice can synthesize speech in just a single language.\n+When an engine supports more than one language, it can easily register a\n+separate voice for each language. Under rare circumstances where a single\n+voice can handle more than one language, it's easiest to just list two\n+separate voices and handle them using the same logic internally. However,\n+if you want to create a voice that will handle utterances in any language,\n+leave out the <code>lang</code> parameter from your extension's manifest.</p>\n+\n+<p>Finally, the <code>event_types</code> parameter is required if the engine can\n+send events to update the client on the progress of speech synthesis.\n+At a minimum, supporting the <code>'end'</code> event type to indicate\n+when speech is finished is highly recommend, otherwise it's impossible\n+for Chrome to schedule queued utterances.</p>\n+\n+<p class=\""note\"">If your TTS engine does not support the <code>'end'</code>\n+event type, Chrome will pass the <code>enqueue</code> option to\n+onSpeak, so that your engine can implement its own queuing. However, this is\n+discouraged because it means that users cannot queue utterances that get\n+sent to different speech engines.</p>\n+\n+<p>The possible event types you can send correspond to the event types that\n+the <code>speak()</code> method receives:</p>\n+\n+<ul>\n+  <li><code>'start'</code>: the engine has started speaking the utterance.\n+  </li><li><code>'word'</code>: a word boundary was reached. Use\n+          <code>event.charIndex</code> to determine the current speech\n+          position.\n+  </li><li><code>'sentence'</code>: a sentence boundary was reached. Use\n+          <code>event.charIndex</code> to determine the current speech\n+          position.\n+  </li><li><code>'marker'</code>: an SSML marker was reached. Use\n+          <code>event.charIndex</code> to determine the current speech\n+          position.\n+  </li><li><code>'end'</code>: the engine has finished speaking the utterance.\n+  </li><li><code>'error'</code>: An engine-specific error occurred and\n+          this utterance cannot be spoken.\n+          Pass more information in <code>event.errorMessage</code>.\n+</li></ul>\n+\n+<p>The <code>'interrupted'</code> and <code>'cancelled'</code> events are\n+not sent by the speech engine; they are generated automatically by Chrome.</p>\n+\n+<p>The information about your extensions's voices from your manifest\n+will be returned to any client that calls <code>getVoices</code>, assuming\n+you've also registered speech event listeners as described below.</p>\n+\n+<h2 id=\""handling_speech_events\"">Handling Speech Events</h2>\n+\n+<p>To generate speech at the request of clients, your extension must\n+register listeners for both <code>onSpeak</code> and <code>onStop</code>,\n+like this:</p>\n+\n+<pre>var speakListener = function(utterance, options, sendTtsEvent) {\n+  sendTtsEvent({'event_type': 'start', 'charIndex': 0})\n+\n+  // (start speaking)\n+\n+  sendTtsEvent({'event_type': 'end', 'charIndex': utterance.length})\n+};\n+\n+var stopListener = function() {\n+  // (stop all speech)\n+};\n+\n+chrome.experimental.ttsEngine.onSpeak.addListener(speakListener);\n+chrome.experimental.ttsEngine.onStop.addListener(stopListener);</pre>\n+\n+<p class=\""warning\"">If an extension does not register listeners for both\n+<code>onSpeak</code> and <code>onStop</code>, it will not intercept any\n+speech calls, regardless of what is in the manifest.</p>\n+\n+<p>The decision of whether or not to send a given speech request to an\n+extension is based solely on whether the extension supports the given voice\n+parameters in its manifest and has registered listeners\n+for <code>onSpeak</code> and <code>onStop</code>. In other words,\n+there's no way for an extension to receive a speech request and\n+dynamically decide whether to handle it or not.</p>\n+</div>\n+\n+        <!-- API PAGE -->\n+        <div class=\""apiPage\"">\n+        <a name=\""apiReference\""></a>\n+        <h2>API reference: chrome.experimental.ttsEngine</h2>\n+\n+          <!-- PROPERTIES -->\n+          <div class=\""apiGroup\"" style=\""display: none; \"">\n+            <a name=\""properties\""></a>\n+            <h3 id=\""properties\"">Properties</h3>\n+\n+            <div>\n+              <a></a>\n+              <h4>getLastError</h4>\n+              <div class=\""summary\"">\n+                <!-- Note: intentionally longer 80 columns -->\n+                <span>chrome.extension</span><span>lastError</span>\n+              </div>\n+              <div>\n+              </div>\n+            </div>\n+\n+          </div> <!-- /apiGroup -->\n+\n+          <!-- METHODS -->\n+          <div id=\""methodsTemplate\"" class=\""apiGroup\"">\n+            <a name=\""global-methods\""></a>\n+            <h3>Methods</h3>\n+\n+            <!-- iterates over all functions -->\n+            <div class=\""apiItem\"" style=\""display: none; \"">\n+              <a></a> <!-- method-anchor -->\n+              <h4>method name</h4>\n+\n+              <div class=\""summary\""><span>void</span>\n+                  <!-- Note: intentionally longer 80 columns -->\n+                  <span>chrome.module.methodName</span>(<span><span>, </span><span></span>\n+                      <var><span></span></var></span>)</div>\n+\n+              <div class=\""description\"">\n+                <p class=\""todo\"">Undocumented.</p>\n+                <p>\n+                  A description from the json schema def of the function goes here.\n+                </p>\n+\n+                <!-- PARAMETERS -->\n+                <h4>Parameters</h4>\n+                <dl>\n+                  <div>\n+                    <div>\n+                    </div>\n+                  </div>\n+                </dl>\n+\n+                <!-- RETURNS -->\n+                <h4>Returns</h4>\n+                <dl>\n+                  <div>\n+                    <div>\n+                    </div>\n+                  </div>\n+                </dl>\n+\n+                <!-- CALLBACK -->\n+                <div>\n+                  <div>\n+                  <h4>Callback function</h4>\n+                  <p>\n+                    The callback <em>parameter</em> should specify a function\n+                    that looks like this:\n+                  </p>\n+                  <p>\n+                    If you specify the <em>callback</em> parameter, it should\n+                    specify a function that looks like this:\n+                  </p>\n+\n+                  <!-- Note: intentionally longer 80 columns -->\n+                  <pre>function(<span>Type param1, Type param2</span>) <span class=\""subdued\"">{...}</span>;</pre>\n+                  <dl>\n+                    <div>\n+                      <div>\n+                      </div>\n+                    </div>\n+                  </dl>\n+                  </div>\n+                </div>\n+\n+                <!-- MIN_VERSION -->\n+                <p>\n+                  This function was added in version <b><span></span></b>.\n+                  If you require this function, the manifest key\n+                  <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+                  can ensure that your extension won't be run in an earlier browser version.\n+                </p>\n+              </div> <!-- /description -->\n+\n+            </div>  <!-- /apiItem -->\n+\n+          </div>  <!-- /apiGroup -->\n+\n+          <!-- EVENTS -->\n+          <div id=\""eventsTemplate\"" class=\""apiGroup\"">\n+            <a name=\""global-events\""></a>\n+            <h3>Events</h3>\n+            <!-- iterates over all events -->\n+            <div class=\""apiItem\"" style=\""display: none; \"">\n+              <a></a>\n+              <h4>event name</h4>\n+\n+              <div class=\""summary\"">\n+                <!-- Note: intentionally longer 80 columns -->\n+                <span class=\""subdued\"">chrome.bookmarks</span><span>onEvent</span><span class=\""subdued\"">.addListener</span>(function(<span>Type param1, Type param2</span>) <span class=\""subdued\"">{...}</span><span>, Type opt_param1, Type opt_param2</span>));\n+              </div>\n+\n+              <div class=\""description\"">\n+                <p class=\""todo\"">Undocumented.</p>\n+                <p>\n+                  A description from the json schema def of the event goes here.\n+                </p>\n+\n+                <!-- LISTENER PARAMETERS -->\n+                <div>\n+                  <h4>Listener parameters</h4>\n+                  <dl>\n+                    <div>\n+                      <div>\n+                      </div>\n+                    </div>\n+                  </dl>\n+                </div>\n+\n+                <!-- EXTRA PARAMETERS -->\n+                <div>\n+                  <h4>Extra parameters to addListener</h4>\n+                  <dl>\n+                    <div>\n+                      <div>\n+                      </div>\n+                    </div>\n+                  </dl>\n+                </div>\n+\n+                <!-- LISTENER RETURN VALUE -->\n+                <h4>Listener returns</h4>\n+                <dl>\n+                  <div>\n+                    <div>\n+                    </div>\n+                  </div>\n+                </dl>\n+\n+              </div> <!-- /description -->\n+            </div><div class=\""apiItem\"">\n+              <a name=\""event-onSpeak\""></a>\n+              <h4>onSpeak</h4>\n+\n+              <div class=\""summary\"">\n+                <!-- Note: intentionally longer 80 columns -->\n+                <span class=\""subdued\"">chrome.experimental.ttsEngine.</span><span>onSpeak</span><span class=\""subdued\"">.addListener</span>(function(<span>string utterance, object options, function sendTtsEvent</span>) <span class=\""subdued\"">{...}</span><span></span>));\n+              </div>\n+\n+              <div class=\""description\"">\n+                <p class=\""todo\"" style=\""display: none; \"">Undocumented.</p>\n+                <p>Called when the user makes a call to tts.speak and the options matches one of the tts_voices from this extension's manifest.</p>\n+\n+                <!-- LISTENER PARAMETERS -->\n+                <div>\n+                  <h4>Listener parameters</h4>\n+                  <dl>\n+                    <div>\n+                      <div>\n+          <dt>\n+            <var>utterance</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"" style=\""display: none; \"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span style=\""display: none; \"">\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>string</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>The text to speak. This may include SSML, so if your engine does not support SSML, you should strip out all XML markup and synthesize only the underlying text content. This is guaranteed to be no more than 32,768 characters. If this engine does not support speaking that many characters at a time, the utterance should be split into smaller chunks and queued internally without returning an error.</dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd style=\""display: none; \"">\n+            <dl>\n+              <div>\n+                <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n+                    </div><div>\n+                      <div>\n+          <dt>\n+            <var>options</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"" style=\""display: none; \"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span style=\""display: none; \"">\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>object</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>The speak options.</dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd>\n+            <dl>\n+              <div>\n+                <div>\n+          <dt>\n+            <var>voiceName</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span style=\""display: none; \"">\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>string</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>The name of the voice to use for synthesis.</dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd style=\""display: none; \"">\n+            <dl>\n+              <div>\n+                <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n+              </div><div>\n+                <div>\n+          <dt>\n+            <var>lang</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span style=\""display: none; \"">\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>string</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>The language to be used for synthesis, in the form <language>-<region>, e.g. en-US, en-GB, fr-CA, zh-CN, etc.</region></language></dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd style=\""display: none; \"">\n+            <dl>\n+              <div>\n+                <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n+              </div><div>\n+                <div>\n+          <dt>\n+            <var>gender</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"">optional</span>\n+                    <span class=\""enum\"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span style=\""display: none; \"">\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>string</span>\n+                        <span>[\""male\"", \""female\""]</span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>Gender of voice for synthesized speech.</dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd style=\""display: none; \"">\n+            <dl>\n+              <div>\n+                <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n+              </div><div>\n+                <div>\n+          <dt>\n+            <var>rate</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span style=\""display: none; \"">\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>number</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>Speaking rate relative to the default rate for this voice. 1.0 is the default rate, normally around 180 to 220 words per minute, 2.0 would be twice as fast, and 0.5 would be half as fast.  This value is guaranteed to be between 0.1 and 10.0, inclusive. When a voice does not support this full range of rates, the actual rate should be clipped to the range that is supported without returning an error.</dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd style=\""display: none; \"">\n+            <dl>\n+              <div>\n+                <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n+              </div><div>\n+                <div>\n+          <dt>\n+            <var>pitch</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span style=\""display: none; \"">\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>number</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>Speaking pitch between 0 and 2 inclusive, with 0 being lowest and 1 being highest, with 1.0 being the default pitch of this particular voice.</dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd style=\""display: none; \"">\n+            <dl>\n+              <div>\n+                <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n+              </div><div>\n+                <div>\n+          <dt>\n+            <var>volume</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span style=\""display: none; \"">\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>number</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>Speaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being highest, with a default of 1.0.</dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd style=\""display: none; \"">\n+            <dl>\n+              <div>\n+                <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n+                    </div><div>\n+                      <div>\n+          <dt>\n+            <var>sendTtsEvent</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"" style=\""display: none; \"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span style=\""display: none; \"">\n+                        <a> Type</a>\n+                      </span>\n+                      <span>\n+                        <span style=\""display: none; \"">\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>function</span>\n+                        <span style=\""display: none; \""></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>Call this function with events that occur in the process of speaking the utterance.</dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd style=\""display: none; \"">\n+            <dl>\n+              <div>\n+                <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd>\n+            <div>\n+          <h5>Parameters</h5>\n+          <dl>\n+            <div>\n+              <div>\n+          <dt>\n+            <var>event</var>\n+              <em>\n+\n+                <!-- TYPE -->\n+                <div style=\""display:inline\"">\n+                  (\n+                    <span class=\""optional\"" style=\""display: none; \"">optional</span>\n+                    <span class=\""enum\"" style=\""display: none; \"">enumerated</span>\n+                    <span id=\""typeTemplate\"">\n+                      <span>\n+                        <a href=\""experimental.tts.html#type-TtsEvent\"">TtsEvent</a>\n+                      </span>\n+                      <span style=\""display: none; \"">\n+                        <span>\n+                          array of <span><span></span></span>\n+                        </span>\n+                        <span>paramType</span>\n+                        <span></span>\n+                      </span>\n+                    </span>\n+                  )\n+                </div>\n+\n+              </em>\n+          </dt>\n+          <dd class=\""todo\"" style=\""display: none; \"">\n+            Undocumented.\n+          </dd>\n+          <dd>The event from the text-to-speech engine indicating the status of this utterance.</dd>\n+          <dd style=\""display: none; \"">\n+            This parameter was added in version\n+            <b><span></span></b>.\n+            You must omit this parameter in earlier versions,\n+            and you may omit it in any version.  If you require this\n+            parameter, the manifest key\n+            <a href=\""manifest.html#minimum_chrome_version\"">minimum_chrome_version</a>\n+            can ensure that your extension won't be run in an earlier browser version.\n+          </dd>\n+\n+          <!-- OBJECT PROPERTIES -->\n+          <dd style=\""display: none; \"">\n+            <dl>\n+              <div>\n+                <div>\n+                </div>\n+              </div>\n+            </dl>\n+          </dd>\n+\n+          <!-- OBJECT METHODS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- OBJECT EVENT FIELDS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+          <!-- FUNCTION PARAMETERS -->\n+          <dd style=\""display: none; \"">\n+            <div></div>\n+          </dd>\n+\n+        </div>\n+            </div>\n+          </dl>\n+        </div>\n+          </dd>\n+\n+        </div>\n+                    </div>\n+                  </dl>\n+                </div>\n+\n+                <!-- EXTRA PARAMETERS -->\n+                <div style=\""display: none; \"">\n+                  <h4>Extra parameters to addListener</h4>\n+                  <dl>\n+                    <div>\n+                      <div>\n+                      </div>\n+                    </div>\n+                  </dl>\n+                </div>\n+\n+                <!-- LISTENER RETURN VALUE -->\n+                <h4 style=\""display: none; \"">Listener returns</h4>\n+                <dl>\n+                  <div style=\""display: none; \"">\n+                    <div>\n+                    </div>\n+                  </div>\n+                </dl>\n+\n+              </div> <!-- /description -->\n+            </div><div class=\""apiItem\"">\n+              <a name=\""event-onStop\""></a>\n+              <h4>onStop</h4>\n+\n+              <div class=\""summary\"">\n+                <!-- Note: intentionally longer 80 columns -->\n+                <span class=\""subdued\"">chrome.experimental.ttsEngine.</span><span>onStop</span><span class=\""subdued\"">.addListener</span>(function(<span></span>) <span class=\""subdued\"">{...}</span><span></span>));\n+              </div>\n+\n+              <div class=\""description\"">\n+                <p class=\""todo\"" style=\""display: none; \"">Undocumented.</p>\n+                <p>Fired when a call is made to tts.stop and this extension may be in the middle of speaking. If an extension receives a call to onStop and speech is already stopped, it should do nothing (not raise an error).</p>\n+\n+                <!-- LISTENER PARAMETERS -->\n+                <div style=\""display: none; \"">\n+                  <h4>Listener parameters</h4>\n+                  <dl>\n+                    <div>\n+                      <div>\n+                      </div>\n+                    </div>\n+                  </dl>\n+                </div>\n+\n+                <!-- EXTRA PARAMETERS -->\n+                <div style=\""display: none; \"">\n+                  <h4>Extra parameters to addListener</h4>\n+                  <dl>\n+                    <div>\n+                      <div>\n+                      </div>\n+                    </div>\n+                  </dl>\n+                </div>\n+\n+                <!-- LISTENER RETURN VALUE -->\n+                <h4 style=\""display: none; \"">Listener returns</h4>\n+                <dl>\n+                  <div style=\""display: none; \"">\n+                    <div>\n+                    </div>\n+                  </div>\n+                </dl>\n+\n+              </div> <!-- /description -->\n+            </div> <!-- /apiItem -->\n+\n+          </div> <!-- /apiGroup -->\n+\n+          <!-- TYPES -->\n+          <div class=\""apiGroup\"" style=\""display: none; \"">\n+            <a name=\""types\""></a>\n+            <h3 id=\""types\"">Types</h3>\n+\n+            <!-- iterates over all types -->\n+            <div class=\""apiItem\"">\n+              <a></a>\n+              <h4>type name</h4>\n+\n+              <div>\n+              </div>\n+\n+            </div> <!-- /apiItem -->\n+\n+          </div> <!-- /apiGroup -->\n+\n+        </div> <!-- /apiPage -->\n+      </div> <!-- /gc-pagecontent -->\n+    </div> <!-- /g-section -->\n+  </div> <!-- /codesiteContent -->\n+    <div id=\""gc-footer\"" --=\""\"">\n+      <div class=\""text\"">\n+  <p>\n+  Except as otherwise <a href=\""http://code.google.com/policies.html#restrictions\"">noted</a>,\n+  the content of this page is licensed under the <a rel=\""license\"" href=\""http://creativecommons.org/licenses/by/3.0/\"">Creative Commons\n+  Attribution 3.0 License</a>, and code samples are licensed under the\n+  <a rel=\""license\"" href=\""http://code.google.com/google_bsd_license.html\"">BSD License</a>.\n+  </p>\n+  <p>\n+  \u00a92011 Google\n+  </p>\n+\n+<!-- begin analytics -->\n+<script src=\""http://www.google-analytics.com/urchin.js\"" type=\""text/javascript\""></script>\n+<script src=\""http://www.google-analytics.com/ga.js\"" type=\""text/javascript\""></script>\n+\n+<script type=\""text/javascript\"">\n+  // chrome doc tracking\n+  try {\n+    var engdocs = _gat._getTracker(\""YT-10763712-2\"");\n+    engdocs._trackPageview();\n+  } catch(err) {}\n+\n+  // code.google.com site-wide tracking\n+  try {\n+    _uacct=\""UA-18071-1\"";\n+    _uanchor=1;\n+    _uff=0;\n+    urchinTracker();\n+  }\n+  catch(e) {/* urchinTracker not available. */}\n+</script>\n+<!-- end analytics -->\n+      </div>\n+    </div> <!-- /gc-footer -->\n+  </div> <!-- /gc-container -->\n+</body></html>""}<_**next**_>{""sha"": ""31cc9876331c89ffba4498f5f2a7f2aa2fd4c961"", ""filename"": ""chrome/common/extensions/docs/static/experimental.tts.html"", ""status"": ""modified"", ""additions"": 138, ""deletions"": 95, ""changes"": 233, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/docs/static/experimental.tts.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/docs/static/experimental.tts.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/docs/static/experimental.tts.html?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,7 +1,9 @@\n <p id=\""classSummary\"">\n Use the <code>chrome.experimental.tts</code> module to play synthesized\n-text-to-speech (TTS) from your extension or packaged app, or to register\n-as a speech provider for other extensions and packaged apps that want to speak.\n+text-to-speech (TTS) from your extension or packaged app.\n+See also the related\n+<a href=\""experimental.ttsEngine.html\"">experimental.ttsEngine</a>\n+module which allows an extension to implement a speech engine.\n </p>\n \n <p class=\""note\""><b>Give us feedback:</b> If you have suggestions,\n@@ -19,7 +21,7 @@ <h2 id=\""overview\"">Overview</h2>\n 5), Mac OS X, and Chrome OS, using speech synthesis capabilities\n provided by the operating system. On all platforms, the user can\n install extensions that register themselves as alternative speech\n-synthesis providers.</p>\n+engines.</p>\n \n <h2 id=\""generating_speech\"">Generating speech</h2>\n \n@@ -28,119 +30,160 @@ <h2 id=\""generating_speech\"">Generating speech</h2>\n \n <pre>chrome.experimental.tts.speak('Hello, world.');</pre>\n \n+<p>To stop speaking immediately, just call <code>stop()</code>:\n+\n+<pre>chrome.experimental.tts.stop();</pre>\n+\n <p>You can provide options that control various properties of the speech,\n such as its rate, pitch, and more. For example:</p>\n \n-<pre>chrome.experimental.tts.speak('Hello, world.', {'rate': 0.8});</pre>\n+<pre>chrome.experimental.tts.speak('Hello, world.', {'rate': 2.0});</pre>\n \n-<p>It's also a good idea to specify the locale so that a synthesizer\n+<p>It's also a good idea to specify the language so that a synthesizer\n supporting that language (and regional dialect, if applicable) is chosen.</p>\n \n <pre>chrome.experimental.tts.speak(\n-    'Hello, world.',\n-    {\n-      'locale': 'en-US',\n-      'rate': 0.8\n-    });</pre>\n-\n-<p>Not all speech engines will support all options.</p>\n+    'Hello, world.', {'lang': 'en-US', 'rate': 2.0});</pre>\n \n-<p>You can also pass a callback function that will be called when the\n-speech has finished. For example, suppose we have an image on our page\n-displaying a picture of a face with a closed mouth. We could open the mouth\n-while speaking, and close it when done.</p>\n+<p>By default, each call to <code>speak()</code> will interrupt any\n+ongoing speech and speak immediately. To determine if a call would be\n+interrupting anything, you can call <code>isSpeaking()</code>, or\n+you can use the <code>enqueue</code> option to cause this utterance to\n+be added to a queue of utterances that will be spoken when the current\n+utterance has finished.\n \n-<pre>faceImage.src = 'open_mouth.png';\n+<pre>chrome.experimental.tts.speak(\n+    'Speak this first.');\n chrome.experimental.tts.speak(\n-    'Hello, world.', null, function() {\n-      faceImage.src = 'closed_mouth.png';\n-    });\n+    'Speak this next, when the first sentence is done.', {'enqueue': true});\n </pre>\n \n-<p>To stop speaking immediately, just call <code>stop()</code>. Call\n-<code>isSpeaking()</code> to find out if a TTS engine is currently speaking.</p>\n+<p>A complete description of all options can be found in the\n+<a href=\""#method-speak\"">speak() method documentation</a> below.\n+Not all speech engines will support all options.</p>\n+\n+<p>To catch errors and make sure you're calling <code>speak()</code>\n+correctly, pass a callback function that takes no arguments. Inside\n+the callback, check\n+<a href=\""extension.html#property-lastError\"">chrome.extension.lastError</a>\n+to see if there were any errors.</p>\n+\n+<pre>chrome.experimental.tts.speak(\n+    utterance,\n+    options,\n+    function() {\n+      if (chrome.extension.lastError) {\n+        console.log('Error: ' + chrome.extension.lastError.message);\n+      }\n+    });</pre>\n+\n+<p>The callback returns right away, before the speech engine has started\n+generating speech. The purpose of the callback is to alert you to syntax\n+errors in your use of the TTS API, not all possible errors that might occur\n+in the process of synthesizing and outputting speech. To catch these errors\n+too, you need to use an event listener, described below.\n+\n+<h2 id=\""events\"">Listening to events</h2>\n \n-<p>You can check to see if an error occurred by checking\n-<code>chrome.extension.lastError</code> inside the callback function.</p>\n+<p>To get more real-time information about the status of synthesized speech,\n+pass an event listener in the options to <code>speak()</code>, like this:</p>\n+\n+<pre>chrome.experimental.tts.speak(\n+    utterance,\n+    {\n+      'onevent': function(event) {\n+        console.log('Event ' + event.type ' at position ' + event.charIndex);\n+        if (event.type == 'error') {\n+          console.log('Error: ' + event.errorMessage);\n+        }\n+      }\n+    },\n+    callback);</pre>\n+\n+<p>Each event includes an event type, the character index of the current\n+speech relative to the utterance, and for error events, an optional\n+error message. The event types are:</p>\n+\n+<ul>\n+  <li><code>'start'</code>: the engine has started speaking the utterance.\n+  <li><code>'word'</code>: a word boundary was reached. Use\n+          <code>event.charIndex</code> to determine the current speech\n+          position.\n+  <li><code>'sentence'</code>: a sentence boundary was reached. Use\n+          <code>event.charIndex</code> to determine the current speech\n+          position.\n+  <li><code>'marker'</code>: an SSML marker was reached. Use\n+          <code>event.charIndex</code> to determine the current speech\n+          position.\n+  <li><code>'end'</code>: the engine has finished speaking the utterance.\n+  <li><code>'interrupted'</code>: this utterance was interrupted by another\n+          call to <code>speak()</code> or <code>stop()</code> and did not\n+          finish.\n+  <li><code>'cancelled'</code>: this utterance was queued, but then\n+          cancelled by another call to <code>speak()</code> or\n+          <code>stop()</code> and never began to speak at all.\n+  <li><code>'error'</code>: An engine-specific error occurred and\n+          this utterance cannot be spoken.\n+          Check <code>event.errorMessage</code> for details.\n+</ul>\n+\n+<p>Four of the event types, <code>'end'</code>, <code>'interrupted'</code>,\n+<code>'cancelled'</code>, and <code>'error'</code>, are <i>final</i>. After\n+one of those events is received, this utterance will no longer speak and\n+no new events from this utterance will be received.</p>\n+\n+<p>Some TTS engines may not support all event types, and some may not even\n+support any events at all. To require that the speech engine used sends\n+the events you're interested in, you can pass a list of event types in\n+the <code>requiredEventTypes</code> member of the options object, or use\n+<code>getVoices</code> to choose a voice that has the events you need.\n+Both are documented below.\n \n <h2 id=\""ssml\"">SSML markup</h2>\n \n <p>Utterances used in this API may include markup using the\n <a href=\""http://www.w3.org/TR/speech-synthesis\"">Speech Synthesis Markup\n-Language (SSML)</a>. For example:\n+Language (SSML)</a>. If you use SSML, the first argument to\n+<code>speak()</code> should be a complete SSML document with an XML\n+header and a top-level <code>&lt;speak&gt;</code> tag, not a document\n+fragment.\n \n-<pre>chrome.experimental.tts.speak('The &lt;emphasis&gt;second&lt;/emphasis&gt; word of this sentence was emphasized.');</pre>\n+For example:\n+\n+<pre>chrome.experimental.tts.speak(\n+    '&lt;?xml version=\""1.0\""?&gt;' +\n+    '&lt;speak&gt;' +\n+    '  The &lt;emphasis&gt;second&lt;/emphasis&gt; ' +\n+    '  word of this sentence was emphasized.' +\n+    '&lt;/speak&gt;');</pre>\n \n <p>Not all speech engines will support all SSML tags, and some may not support\n-SSML at all, but all engines are expected to ignore any SSML they don't\n+SSML at all, but all engines are required to ignore any SSML they don't\n support and still speak the underlying text.</p>\n \n-<h2 id=\""provider\"">Implementing a speech provider</h2>\n-\n-<p>An extension can register itself as a speech provider. By doing so, it\n-can intercept some or all calls to functions such as\n-<code>speak()</code> and <code>stop()</code> and provide an alternate\n-implementation. Extensions are free to use any available web technology\n-to provide speech, including streaming audio from a server, HTML5 audio,\n-Native Client, or Flash. An extension could even do something different\n-with the utterances, like display closed captions in a pop-up window or\n-send them as log messages to a remote server.</p>\n-\n-<p>To provide TTS, an extension must first declare all voices it provides\n-in the extension manifest, like this:</p>\n-\n-<pre>{\n-  \""name\"": \""My TTS Provider\"",\n-  \""version\"": \""1.0\"",\n-  <b>\""permissions\"": [\""experimental\""]\n-  \""tts\"": {\n-    \""voices\"": [\n-      {\n-        \""voiceName\"": \""Alice\"",\n-        \""locale\"": \""en-US\"",\n-        \""gender\"": \""female\""\n-      },\n-      {\n-        \""voiceName\"": \""Pat\"",\n-        \""locale\"": \""en-US\""\n+<h2 id=\""choosing_voice\"">Choosing a voice</h2>\n+\n+<p>By default, Chrome will choose the most appropriate voice for each\n+utterance you want to speak, based on the language and gender. On most\n+Windows, Mac OS X, and Chrome OS systems, speech synthesis provided by\n+the operating system should be able to speak any text in at least one\n+language. Some users may have a variety of voices available, though,\n+from their operating system and from speech engines implemented by other\n+Chrome extensions. In those cases, you can implement custom code to choose\n+the appropriate voice, or present the user with a list of choices.</p>\n+\n+<p>To get a list of all voices, call <code>getVoices()</code> and pass it\n+a function that receives an array of <code>TtsVoice</code> objects as its\n+argument:</p>\n+\n+<pre>chrome.experimental.tts.getVoices(\n+    function(voices) {\n+      for (var i = 0; i < voices.length; i++) {\n+        console.log('Voice ' + i + ':');\n+        console.log('  name: ' + voices[i].voiceName);\n+        console.log('  lang: ' + voices[i].lang);\n+        console.log('  gender: ' + voices[i].gender);\n+        console.log('  extension id: ' + voices[i].extensionId);\n+        console.log('  event types: ' + voices[i].eventTypes);\n       }\n-    ]\n-  },</b>\n-  \""background_page\"": \""background.html\"",\n-}</pre>\n-\n-<p>An extension can specify any number of voices. The three\n-parameters&mdash;<code>voiceName</code>, <code>locale</code>,\n-and <code>gender</code>&mdash;are all optional. If they are all unspecified,\n-the extension will handle all speech from all clients. If any of them\n-are specified, they can be used to filter speech requests. For\n-example, if a voice only supports French, it should set the locale to\n-'fr' (or something more specific like 'fr-FR') so that only utterances\n-in that locale are routed to that extension.</p>\n-\n-<p>To handle speech calls, the extension should register listeners\n-for <code>onSpeak</code> and <code>onStop</code>, like this:</p>\n-\n-<pre>var speakListener = function(utterance, options, callback) {\n-  ...\n-  callback();\n-};\n-var stopListener = function() {\n-  ...\n-};\n-chrome.experimental.tts.onSpeak.addListener(speakListener);\n-chrome.experimental.tts.onStop.addListener(stopListener);</pre>\n-\n-<p class=\""warning\""><b>Important:</b> Don't forget to call the callback\n-function from your speak listener!</p>\n-\n-<p>If an extension does not register listeners for both\n-<code>onSpeak</code> and <code>onStop</code>, it will not intercept any\n-speech calls, regardless of what is in the manifest.\n-\n-<p>The decision of whether or not to send a given speech request to an\n-extension is based solely on whether the extension supports the given voice\n-parameters in its manifest and has registered listeners\n-for <code>onSpeak</code> and <code>onStop</code>. In other words,\n-there's no way for an extension to receive a speech request and\n-dynamically decide whether to handle it or not.</p>\n+    });</pre>""}<_**next**_>{""sha"": ""d7c3387f4f64b96eabf4274125d4d4de429a9f50"", ""filename"": ""chrome/common/extensions/docs/static/experimental.ttsEngine.html"", ""status"": ""added"", ""additions"": 152, ""deletions"": 0, ""changes"": 152, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/docs/static/experimental.ttsEngine.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/docs/static/experimental.ttsEngine.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/docs/static/experimental.ttsEngine.html?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,152 @@\n+<p id=\""classSummary\"">\n+Use the <code>chrome.experimental.ttsEngine</code> module to\n+implement a text-to-speech (TTS) engine using an extension. If your\n+extension registers using this API, it will receive events containing\n+the intended utterance and other parameters when any extension or packaged\n+app uses the\n+<a href=\""experimental.tts.html\"">experimental.tts</a>\n+module to generate speech. Your extension can then use any available\n+web technology to synthesize and output the speech, and send events back\n+to the calling function to report the status.\n+</p>\n+\n+<p class=\""note\""><b>Give us feedback:</b> If you have suggestions,\n+especially changes that should be made before stabilizing the first\n+version of this API, please send your ideas to the\n+<a href=\""http://groups.google.com/a/chromium.org/group/chromium-extensions\"">chromium-extensions</a>\n+group.</p>\n+\n+<h2 id=\""overview\"">Overview</h2>\n+\n+<p>To enable this experimental API, visit\n+<b>chrome://flags</b> and enable <b>Experimental Extension APIs</b>.\n+\n+<p>An extension can register itself as a speech engine. By doing so, it\n+can intercept some or all calls to functions such as\n+<a href=\""experimental.tts.html#method-speak\""><code>speak()</code></a> and\n+<a href=\""experimental.tts.html#method-stop\""><code>stop()</code></a>\n+and provide an alternate implementation.\n+Extensions are free to use any available web technology\n+to provide speech, including streaming audio from a server, HTML5 audio,\n+Native Client, or Flash. An extension could even do something different\n+with the utterances, like display closed captions in a pop-up window or\n+send them as log messages to a remote server.</p>\n+\n+<h2 id=\""manifest\"">Manifest</h2>\n+\n+<p>To implement a TTS engine, an extension must first declare all voices\n+it provides in the extension manifest, like this:</p>\n+\n+<pre>{\n+  \""name\"": \""My TTS Engine\"",\n+  \""version\"": \""1.0\"",\n+  <b>\""permissions\"": [\""experimental\""],\n+  \""tts_engine\"": {\n+    \""voices\"": [\n+      {\n+        \""voice_name\"": \""Alice\"",\n+        \""lang\"": \""en-US\"",\n+        \""gender\"": \""female\"",\n+        \""event_types\"": [\""start\"", \""marker\"", \""end\""]\n+      },\n+      {\n+        \""voice_name\"": \""Pat\"",\n+        \""lang\"": \""en-US\"",\n+        \""event_types\"": [\""end\""]\n+      }\n+    ]\n+  },</b>\n+  \""background_page\"": \""background.html\"",\n+}</pre>\n+\n+<p>An extension can specify any number of voices.</p>\n+\n+<p>The <code>voice_name</code> parameter is required. The name should be\n+descriptive enough that it identifies the name of the voice and the\n+engine used. In the unlikely event that two extensions register voices\n+with the same name, a client can manually specify the extension id it\n+wants to do the synthesis.</p>\n+\n+<p>The <code>gender</code> parameter is optional. If your voice corresponds\n+to a male or female voice, you can use this parameter to help clients\n+choose the most appropriate voice for their application.</p>\n+\n+<p>The <code>lang</code> parameter is optional, but highly recommended.\n+Almost always, a voice can synthesize speech in just a single language.\n+When an engine supports more than one language, it can easily register a\n+separate voice for each language. Under rare circumstances where a single\n+voice can handle more than one language, it's easiest to just list two\n+separate voices and handle them using the same logic internally. However,\n+if you want to create a voice that will handle utterances in any language,\n+leave out the <code>lang</code> parameter from your extension's manifest.</p>\n+\n+<p>Finally, the <code>event_types</code> parameter is required if the engine can\n+send events to update the client on the progress of speech synthesis.\n+At a minimum, supporting the <code>'end'</code> event type to indicate\n+when speech is finished is highly recommend, otherwise it's impossible\n+for Chrome to schedule queued utterances.</p>\n+\n+<p class=\""note\"">If your TTS engine does not support the <code>'end'</code>\n+event type, Chrome will pass the <code>enqueue</code> option to\n+onSpeak, so that your engine can implement its own queuing. However, this is\n+discouraged because it means that users cannot queue utterances that get\n+sent to different speech engines.</p>\n+\n+<p>The possible event types you can send correspond to the event types that\n+the <code>speak()</code> method receives:</p>\n+\n+<ul>\n+  <li><code>'start'</code>: the engine has started speaking the utterance.\n+  <li><code>'word'</code>: a word boundary was reached. Use\n+          <code>event.charIndex</code> to determine the current speech\n+          position.\n+  <li><code>'sentence'</code>: a sentence boundary was reached. Use\n+          <code>event.charIndex</code> to determine the current speech\n+          position.\n+  <li><code>'marker'</code>: an SSML marker was reached. Use\n+          <code>event.charIndex</code> to determine the current speech\n+          position.\n+  <li><code>'end'</code>: the engine has finished speaking the utterance.\n+  <li><code>'error'</code>: An engine-specific error occurred and\n+          this utterance cannot be spoken.\n+          Pass more information in <code>event.errorMessage</code>.\n+</ul>\n+\n+<p>The <code>'interrupted'</code> and <code>'cancelled'</code> events are\n+not sent by the speech engine; they are generated automatically by Chrome.</p>\n+\n+<p>The information about your extensions's voices from your manifest\n+will be returned to any client that calls <code>getVoices</code>, assuming\n+you've also registered speech event listeners as described below.</p>\n+\n+<h2 id=\""handling_speech_events\"">Handling Speech Events</h2>\n+\n+<p>To generate speech at the request of clients, your extension must\n+register listeners for both <code>onSpeak</code> and <code>onStop</code>,\n+like this:</p>\n+\n+<pre>var speakListener = function(utterance, options, sendTtsEvent) {\n+  sendTtsEvent({'event_type': 'start', 'charIndex': 0})\n+\n+  // (start speaking)\n+\n+  sendTtsEvent({'event_type': 'end', 'charIndex': utterance.length})\n+};\n+\n+var stopListener = function() {\n+  // (stop all speech)\n+};\n+\n+chrome.experimental.ttsEngine.onSpeak.addListener(speakListener);\n+chrome.experimental.ttsEngine.onStop.addListener(stopListener);</pre>\n+\n+<p class=\""warning\"">If an extension does not register listeners for both\n+<code>onSpeak</code> and <code>onStop</code>, it will not intercept any\n+speech calls, regardless of what is in the manifest.</p>\n+\n+<p>The decision of whether or not to send a given speech request to an\n+extension is based solely on whether the extension supports the given voice\n+parameters in its manifest and has registered listeners\n+for <code>onSpeak</code> and <code>onStop</code>. In other words,\n+there's no way for an extension to receive a speech request and\n+dynamically decide whether to handle it or not.</p>""}<_**next**_>{""sha"": ""d3fd98faac7c7b1378bc8f517de01aff3aeb6dd6"", ""filename"": ""chrome/common/extensions/extension.cc"", ""status"": ""modified"", ""additions"": 36, ""deletions"": 6, ""changes"": 42, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/extension.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/extension.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/extension.cc?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -2245,9 +2245,9 @@ bool Extension::InitFromValue(const DictionaryValue& source, int flags,\n   }\n \n   // Initialize text-to-speech voices (optional).\n-  if (source.HasKey(keys::kTts)) {\n+  if (source.HasKey(keys::kTtsEngine)) {\n     DictionaryValue* tts_dict = NULL;\n-    if (!source.GetDictionary(keys::kTts, &tts_dict)) {\n+    if (!source.GetDictionary(keys::kTtsEngine, &tts_dict)) {\n       *error = errors::kInvalidTts;\n       return false;\n     }\n@@ -2274,11 +2274,11 @@ bool Extension::InitFromValue(const DictionaryValue& source, int flags,\n             return false;\n           }\n         }\n-        if (one_tts_voice->HasKey(keys::kTtsVoicesLocale)) {\n+        if (one_tts_voice->HasKey(keys::kTtsVoicesLang)) {\n           if (!one_tts_voice->GetString(\n-                  keys::kTtsVoicesLocale, &voice_data.locale) ||\n-              !l10n_util::IsValidLocaleSyntax(voice_data.locale)) {\n-            *error = errors::kInvalidTtsVoicesLocale;\n+                  keys::kTtsVoicesLang, &voice_data.lang) ||\n+              !l10n_util::IsValidLocaleSyntax(voice_data.lang)) {\n+            *error = errors::kInvalidTtsVoicesLang;\n             return false;\n           }\n         }\n@@ -2291,6 +2291,36 @@ bool Extension::InitFromValue(const DictionaryValue& source, int flags,\n             return false;\n           }\n         }\n+        if (one_tts_voice->HasKey(keys::kTtsVoicesEventTypes)) {\n+          ListValue* event_types_list;\n+          if (!one_tts_voice->GetList(\n+                  keys::kTtsVoicesEventTypes, &event_types_list)) {\n+            *error = errors::kInvalidTtsVoicesEventTypes;\n+            return false;\n+          }\n+          for (size_t i = 0; i < event_types_list->GetSize(); i++) {\n+            std::string event_type;\n+            if (!event_types_list->GetString(i, &event_type)) {\n+              *error = errors::kInvalidTtsVoicesEventTypes;\n+              return false;\n+            }\n+            if (event_type != keys::kTtsVoicesEventTypeEnd &&\n+                event_type != keys::kTtsVoicesEventTypeError &&\n+                event_type != keys::kTtsVoicesEventTypeMarker &&\n+                event_type != keys::kTtsVoicesEventTypeSentence &&\n+                event_type != keys::kTtsVoicesEventTypeStart &&\n+                event_type != keys::kTtsVoicesEventTypeWord) {\n+              *error = errors::kInvalidTtsVoicesEventTypes;\n+              return false;\n+            }\n+            if (voice_data.event_types.find(event_type) !=\n+                voice_data.event_types.end()) {\n+              *error = errors::kInvalidTtsVoicesEventTypes;\n+              return false;\n+            }\n+            voice_data.event_types.insert(event_type);\n+          }\n+        }\n \n         tts_voices_.push_back(voice_data);\n       }""}<_**next**_>{""sha"": ""505bac64e3d8fc4264fe109e49c61842718a782e"", ""filename"": ""chrome/common/extensions/extension.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/extension.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/extension.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/extension.h?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -139,8 +139,9 @@ class Extension : public base::RefCountedThreadSafe<Extension> {\n \n   struct TtsVoice {\n     std::string voice_name;\n-    std::string locale;\n+    std::string lang;\n     std::string gender;\n+    std::set<std::string> event_types;\n   };\n \n   enum InitFromValueFlags {""}<_**next**_>{""sha"": ""0218761c44bf0f75340204409d2f058d1d974684"", ""filename"": ""chrome/common/extensions/extension_constants.cc"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 9, ""changes"": 27, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/extension_constants.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/extension_constants.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/extension_constants.cc?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -81,13 +81,20 @@ const char* kThemeImages = \""images\"";\n const char* kThemeTints = \""tints\"";\n const char* kToolstripPath = \""path\"";\n const char* kToolstrips = \""toolstrips\"";\n-const char* kTts = \""tts\"";\n+const char* kTtsEngine = \""tts_engine\"";\n const char* kTtsGenderFemale = \""female\"";\n const char* kTtsGenderMale = \""male\"";\n const char* kTtsVoices = \""voices\"";\n+const char* kTtsVoicesEventTypeEnd = \""end\"";\n+const char* kTtsVoicesEventTypeError = \""error\"";\n+const char* kTtsVoicesEventTypeMarker = \""marker\"";\n+const char* kTtsVoicesEventTypeSentence = \""sentence\"";\n+const char* kTtsVoicesEventTypeStart = \""start\"";\n+const char* kTtsVoicesEventTypeWord = \""word\"";\n+const char* kTtsVoicesEventTypes = \""event_types\"";\n const char* kTtsVoicesGender = \""gender\"";\n-const char* kTtsVoicesLocale = \""locale\"";\n-const char* kTtsVoicesVoiceName = \""voiceName\"";\n+const char* kTtsVoicesLang = \""lang\"";\n+const char* kTtsVoicesVoiceName = \""voice_name\"";\n const char* kType = \""type\"";\n const char* kUpdateURL = \""update_url\"";\n const char* kVersion = \""version\"";\n@@ -326,15 +333,17 @@ const char* kInvalidToolstrip =\n const char* kInvalidToolstrips =\n     \""Invalid value for 'toolstrips'.\"";\n const char* kInvalidTts =\n-    \""Invalid value for 'tts'.\"";\n+    \""Invalid value for 'tts_engine'.\"";\n const char* kInvalidTtsVoices =\n-    \""Invalid value for 'tts.voices'.\"";\n+    \""Invalid value for 'tts_engine.voices'.\"";\n+const char* kInvalidTtsVoicesEventTypes =\n+    \""Invalid value for 'tts_engine.voices[*].event_types'.\"";\n const char* kInvalidTtsVoicesGender =\n-    \""Invalid value for 'tts.voices[*].gender'.\"";\n-const char* kInvalidTtsVoicesLocale =\n-    \""Invalid value for 'tts.voices[*].locale'.\"";\n+    \""Invalid value for 'tts_engine.voices[*].gender'.\"";\n+const char* kInvalidTtsVoicesLang =\n+    \""Invalid value for 'tts_engine.voices[*].lang'.\"";\n const char* kInvalidTtsVoicesVoiceName =\n-    \""Invalid value for 'tts.voices[*].voiceName'.\"";\n+    \""Invalid value for 'tts_engine.voices[*].voice_name'.\"";\n const char* kInvalidUpdateURL =\n     \""Invalid value for update url: '[*]'.\"";\n const char* kInvalidURLPatternError =""}<_**next**_>{""sha"": ""b9fd2734361b18b909a9d45d7f1faf003b6f135f"", ""filename"": ""chrome/common/extensions/extension_constants.h"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 3, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/extension_constants.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/extension_constants.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/extension_constants.h?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -86,12 +86,19 @@ namespace extension_manifest_keys {\n   extern const char* kThemeTints;\n   extern const char* kToolstripPath;\n   extern const char* kToolstrips;\n-  extern const char* kTts;\n+  extern const char* kTtsEngine;\n   extern const char* kTtsGenderFemale;\n   extern const char* kTtsGenderMale;\n   extern const char* kTtsVoices;\n+  extern const char* kTtsVoicesEventTypeEnd;\n+  extern const char* kTtsVoicesEventTypeError;\n+  extern const char* kTtsVoicesEventTypeMarker;\n+  extern const char* kTtsVoicesEventTypeSentence;\n+  extern const char* kTtsVoicesEventTypeStart;\n+  extern const char* kTtsVoicesEventTypeWord;\n+  extern const char* kTtsVoicesEventTypes;\n   extern const char* kTtsVoicesGender;\n-  extern const char* kTtsVoicesLocale;\n+  extern const char* kTtsVoicesLang;\n   extern const char* kTtsVoicesVoiceName;\n   extern const char* kType;\n   extern const char* kUpdateURL;\n@@ -222,8 +229,9 @@ namespace extension_manifest_errors {\n   extern const char* kInvalidToolstrips;\n   extern const char* kInvalidTts;\n   extern const char* kInvalidTtsVoices;\n+  extern const char* kInvalidTtsVoicesEventTypes;\n   extern const char* kInvalidTtsVoicesGender;\n-  extern const char* kInvalidTtsVoicesLocale;\n+  extern const char* kInvalidTtsVoicesLang;\n   extern const char* kInvalidTtsVoicesVoiceName;\n   extern const char* kInvalidUpdateURL;\n   extern const char* kInvalidURLPatternError;""}<_**next**_>{""sha"": ""1184d529ba4d1831313988214b9477b966ff4ec5"", ""filename"": ""chrome/common/extensions/extension_manifests_unittest.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 12, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/extension_manifests_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/common/extensions/extension_manifests_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/extension_manifests_unittest.cc?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -706,29 +706,34 @@ TEST_F(ExtensionManifestTest, DefaultLocale) {\n   EXPECT_EQ(\""de-AT\"", extension->default_locale());\n }\n \n-TEST_F(ExtensionManifestTest, TtsProvider) {\n-  LoadAndExpectError(\""tts_provider_invalid_1.json\"",\n+TEST_F(ExtensionManifestTest, TtsEngine) {\n+  LoadAndExpectError(\""tts_engine_invalid_1.json\"",\n                      extension_manifest_errors::kInvalidTts);\n-  LoadAndExpectError(\""tts_provider_invalid_2.json\"",\n+  LoadAndExpectError(\""tts_engine_invalid_2.json\"",\n                      extension_manifest_errors::kInvalidTtsVoices);\n-  LoadAndExpectError(\""tts_provider_invalid_3.json\"",\n+  LoadAndExpectError(\""tts_engine_invalid_3.json\"",\n                      extension_manifest_errors::kInvalidTtsVoices);\n-  LoadAndExpectError(\""tts_provider_invalid_4.json\"",\n+  LoadAndExpectError(\""tts_engine_invalid_4.json\"",\n                      extension_manifest_errors::kInvalidTtsVoicesVoiceName);\n-  LoadAndExpectError(\""tts_provider_invalid_5.json\"",\n-                     extension_manifest_errors::kInvalidTtsVoicesLocale);\n-  LoadAndExpectError(\""tts_provider_invalid_6.json\"",\n-                     extension_manifest_errors::kInvalidTtsVoicesLocale);\n-  LoadAndExpectError(\""tts_provider_invalid_7.json\"",\n+  LoadAndExpectError(\""tts_engine_invalid_5.json\"",\n+                     extension_manifest_errors::kInvalidTtsVoicesLang);\n+  LoadAndExpectError(\""tts_engine_invalid_6.json\"",\n+                     extension_manifest_errors::kInvalidTtsVoicesLang);\n+  LoadAndExpectError(\""tts_engine_invalid_7.json\"",\n                      extension_manifest_errors::kInvalidTtsVoicesGender);\n+  LoadAndExpectError(\""tts_engine_invalid_8.json\"",\n+                     extension_manifest_errors::kInvalidTtsVoicesEventTypes);\n+  LoadAndExpectError(\""tts_engine_invalid_9.json\"",\n+                     extension_manifest_errors::kInvalidTtsVoicesEventTypes);\n \n   scoped_refptr<Extension> extension(\n-      LoadAndExpectSuccess(\""tts_provider_valid.json\""));\n+      LoadAndExpectSuccess(\""tts_engine_valid.json\""));\n \n   ASSERT_EQ(1u, extension->tts_voices().size());\n   EXPECT_EQ(\""name\"", extension->tts_voices()[0].voice_name);\n-  EXPECT_EQ(\""en-US\"", extension->tts_voices()[0].locale);\n+  EXPECT_EQ(\""en-US\"", extension->tts_voices()[0].lang);\n   EXPECT_EQ(\""female\"", extension->tts_voices()[0].gender);\n+  EXPECT_EQ(3U, extension->tts_voices()[0].event_types.size());\n }\n \n TEST_F(ExtensionManifestTest, ForbidPortsInPermissions) {""}<_**next**_>{""sha"": ""b518c9bd0a2b7309d2bb8ce82ebc98d144d031c2"", ""filename"": ""chrome/renderer/extensions/extension_process_bindings.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/renderer/extensions/extension_process_bindings.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/renderer/extensions/extension_process_bindings.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/extensions/extension_process_bindings.cc?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -162,6 +162,8 @@ class ExtensionImpl : public ExtensionBase {\n       return v8::FunctionTemplate::New(OpenChannelToTab);\n     } else if (name->Equals(v8::String::New(\""GetNextContextMenuId\""))) {\n       return v8::FunctionTemplate::New(GetNextContextMenuId);\n+    } else if (name->Equals(v8::String::New(\""GetNextTtsEventId\""))) {\n+      return v8::FunctionTemplate::New(GetNextTtsEventId);\n     } else if (name->Equals(v8::String::New(\""GetCurrentPageActions\""))) {\n       return v8::FunctionTemplate::New(GetCurrentPageActions,\n                                        v8::External::New(this));\n@@ -375,6 +377,13 @@ class ExtensionImpl : public ExtensionBase {\n     return v8::Integer::New(next_context_menu_id++);\n   }\n \n+  static v8::Handle<v8::Value> GetNextTtsEventId(const v8::Arguments& args) {\n+    // Note: this works because the TTS API only works in the\n+    // extension process, not content scripts.\n+    static int next_tts_event_id = 1;\n+    return v8::Integer::New(next_tts_event_id++);\n+  }\n+\n   static v8::Handle<v8::Value> GetCurrentPageActions(\n       const v8::Arguments& args) {\n     ExtensionImpl* v8_extension = GetFromArguments<ExtensionImpl>(args);""}<_**next**_>{""sha"": ""64814c9a0e8fb700d4711d80e3dd16341d0c8d17"", ""filename"": ""chrome/renderer/resources/extension_process_bindings.js"", ""status"": ""modified"", ""additions"": 43, ""deletions"": 9, ""changes"": 52, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/renderer/resources/extension_process_bindings.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/renderer/resources/extension_process_bindings.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/resources/extension_process_bindings.js?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -14,6 +14,7 @@ var chrome = chrome || {};\n   native function GetChromeHidden();\n   native function GetNextRequestId();\n   native function GetNextContextMenuId();\n+  native function GetNextTtsEventId();\n   native function OpenChannelToTab();\n   native function GetRenderViewId();\n   native function SetIconCommon();\n@@ -529,16 +530,35 @@ var chrome = chrome || {};\n   }\n \n   function setupTtsEvents() {\n-    chrome.experimental.tts.onSpeak.dispatch =\n+    chromeHidden.tts = {};\n+    chromeHidden.tts.handlers = {};\n+    chrome.experimental.ttsEngine.onSpeak.dispatch =\n         function(text, options, requestId) {\n-      var callback = function(errorMessage) {\n-        if (errorMessage)\n-          chrome.experimental.tts.speakCompleted(requestId, errorMessage);\n-        else\n-          chrome.experimental.tts.speakCompleted(requestId);\n-      };\n-      chrome.Event.prototype.dispatch.apply(this, [text, options, callback]);\n-    };\n+          var sendTtsEvent = function(event) {\n+            chrome.experimental.ttsEngine.sendTtsEvent(requestId, event);\n+          };\n+          chrome.Event.prototype.dispatch.apply(\n+              this, [text, options, sendTtsEvent]);\n+        };\n+    try {\n+      chrome.experimental.ttsEngine.onEvent.addListener(\n+          function(event) {\n+            var eventHandler = chromeHidden.tts.handlers[event.srcId];\n+            if (eventHandler) {\n+              eventHandler({\n+                             type: event.type,\n+                             charIndex: event.charIndex,\n+                             errorMessage: event.errorMessage\n+                           });\n+              if (event.isFinalEvent) {\n+                delete chromeHidden.tts.handlers[event.srcId];\n+              }\n+            }\n+          });\n+      } catch (e) {\n+        // This extension doesn't have permission to access TTS, so we\n+        // can safely ignore this.\n+      }\n   }\n \n   // Get the platform from navigator.appVersion.\n@@ -988,6 +1008,17 @@ var chrome = chrome || {};\n       return [requestId, suggestions];\n     };\n \n+    apiFunctions[\""experimental.tts.speak\""].handleRequest = function() {\n+      var args = arguments;\n+      if (args.length > 1 && args[1].onevent) {\n+        var id = GetNextTtsEventId();\n+        args[1].srcId = id;\n+        chromeHidden.tts.handlers[id] = args[1].onevent;\n+      }\n+      sendRequest(this.name, args, this.definition.parameters);\n+      return id;\n+    };\n+\n     if (chrome.test) {\n       chrome.test.getApiDefinitions = GetExtensionAPIDefinition;\n     }\n@@ -1007,4 +1038,7 @@ var chrome = chrome || {};\n \n   if (!chrome.experimental.tts)\n     chrome.experimental.tts = {};\n+\n+  if (!chrome.experimental.ttsEngine)\n+    chrome.experimental.ttsEngine = {};\n })();""}<_**next**_>{""sha"": ""777f4fafe17fa0c99c7a6f20b5f1471fa96cb9fa"", ""filename"": ""chrome/renderer/resources/renderer_extension_bindings.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/renderer/resources/renderer_extension_bindings.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/renderer/resources/renderer_extension_bindings.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/resources/renderer_extension_bindings.js?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -314,6 +314,7 @@ var chrome = chrome || {};\n       \""experimental.rlz\"",\n       \""experimental.sidebar\"",\n       \""experimental.tts\"",\n+      \""experimental.ttsEngine\"",\n       \""experimental.webNavigation\"",\n       \""experimental.webRequest\"",\n       \""fileBrowserHandler\"",""}<_**next**_>{""sha"": ""6859f214263a6507530acb1595c1fc847be11785"", ""filename"": ""chrome/test/data/extensions/api_test/tts/chromeos/test.js"", ""status"": ""modified"", ""additions"": 27, ""deletions"": 15, ""changes"": 42, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/chromeos/test.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/chromeos/test.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts/chromeos/test.js?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,4 +1,4 @@\n-// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n@@ -8,21 +8,33 @@\n chrome.test.runTests([\n   function testChromeOsSpeech() {\n     var callbacks = 0;\n-    chrome.experimental.tts.speak('text 1', {}, function() {\n-        chrome.test.assertEq('Utterance interrupted.',\n-                             chrome.extension.lastError.message);\n-        callbacks++;\n-      });\n-    chrome.experimental.tts.speak('text 2', {}, function() {\n-        chrome.test.assertNoLastError();\n-        callbacks++;\n-        if (callbacks == 2) {\n+    chrome.experimental.tts.speak(\n+        'text 1',\n+        {\n+         'onevent': function(event) {\n+           callbacks++;\n+           chrome.test.assertEq('interrupted', event.type);\n+         }\n+        },\n+        function() {\n           chrome.test.assertNoLastError();\n-          chrome.test.succeed();\n-        } else {\n-          chrome.test.fail();\n-        }\n-      });\n+        });\n+    chrome.experimental.tts.speak(\n+        'text 2',\n+        {\n+         'onevent': function(event) {\n+           chrome.test.assertEq('end', event.type);\n+           callbacks++;\n+           if (callbacks == 2) {\n+             chrome.test.succeed();\n+           } else {\n+             chrome.test.fail();\n+           }\n+         }\n+        },\n+        function() {\n+          chrome.test.assertNoLastError();\n+        });\n   }\n \n ]);""}<_**next**_>{""sha"": ""e006ee910781437e0470b0a6e61558005625261a"", ""filename"": ""chrome/test/data/extensions/api_test/tts/enqueue/test.js"", ""status"": ""modified"", ""additions"": 33, ""deletions"": 15, ""changes"": 48, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/enqueue/test.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/enqueue/test.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts/enqueue/test.js?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,25 +1,43 @@\n-// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n // TTS api test for Chrome on ChromeOS.\n // browser_tests.exe --gtest_filter=\""TtsApiTest.*\""\n \n chrome.test.runTests([\n-  function testAllSpeakCallbackFunctionsAreCalled() {\n+  function testEnqueue() {\n     var callbacks = 0;\n-    chrome.experimental.tts.speak('text 1', {'enqueue': true}, function() {\n-        chrome.test.assertNoLastError();\n-        callbacks++;\n-      });\n-    chrome.experimental.tts.speak('text 2', {'enqueue': true}, function() {\n-        chrome.test.assertNoLastError();\n-        callbacks++;\n-        if (callbacks == 2) {\n-          chrome.test.succeed();\n-        } else {\n-          chrome.test.fail();\n-        }\n-      });\n+    chrome.experimental.tts.speak(\n+        'text 1',\n+        {\n+         'enqueue': true,\n+         'onevent': function(event) {\n+           chrome.test.assertEq('end', event.type);\n+           callbacks++;\n+         }\n+        },\n+        function() {\n+          chrome.test.assertNoLastError();\n+          callbacks++;\n+        });\n+    chrome.experimental.tts.speak(\n+        'text 2',\n+        {\n+         'enqueue': true,\n+         'onevent': function(event) {\n+           chrome.test.assertEq('end', event.type);\n+           callbacks++;\n+           if (callbacks == 4) {\n+             chrome.test.succeed();\n+           } else {\n+             chrome.test.fail();\n+           }\n+         }\n+        },\n+        function() {\n+          chrome.test.assertNoLastError();\n+          callbacks++;\n+        });\n   }\n ]);""}<_**next**_>{""sha"": ""65e000cd333990383174aad5c24a502403f37656"", ""filename"": ""chrome/test/data/extensions/api_test/tts/interrupt/test.js"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 16, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/interrupt/test.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/interrupt/test.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts/interrupt/test.js?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,26 +1,41 @@\n-// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n // TTS api test for Chrome on ChromeOS.\n // browser_tests.exe --gtest_filter=\""TtsApiTest.*\""\n \n chrome.test.runTests([\n-  function testAllSpeakCallbackFunctionsAreCalled() {\n+  function testInterrupt() {\n     var callbacks = 0;\n-    chrome.experimental.tts.speak('text 1', {'enqueue': false}, function() {\n-        chrome.test.assertEq('Utterance interrupted.',\n-                             chrome.extension.lastError.message);\n-        callbacks++;\n-      });\n-    chrome.experimental.tts.speak('text 2', {'enqueue': false}, function() {\n-        chrome.test.assertNoLastError();\n-        callbacks++;\n-        if (callbacks == 2) {\n-          chrome.test.succeed();\n-        } else {\n-          chrome.test.fail();\n-        }\n-      });\n+    chrome.experimental.tts.speak(\n+        'text 1',\n+        {\n+         'enqueue': false,\n+         'onevent': function(event) {\n+            chrome.test.assertEq('interrupted', event.type);\n+            callbacks++;\n+         }\n+        },\n+        function() {\n+          chrome.test.assertNoLastError();\n+          callbacks++;\n+        });\n+    chrome.experimental.tts.speak(\n+        'text 2',\n+        {\n+         'enqueue': false,\n+         'onevent': function(event) {\n+           chrome.test.assertEq('end', event.type);\n+           callbacks++;\n+           if (callbacks == 4) {\n+             chrome.test.succeed();\n+           }\n+         }\n+        },\n+        function() {\n+          chrome.test.assertNoLastError();\n+          callbacks++;\n+        });\n   }\n ]);""}<_**next**_>{""sha"": ""bc5e16a8be1606b844b62bd49d54e5bdd7268eec"", ""filename"": ""chrome/test/data/extensions/api_test/tts/provide/test.js"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 113, ""changes"": 113, ""blob_url"": ""https://github.com/chromium/chromium/blob/3768ee10e91e95f4ff90bbe8177ffa407725d955/chrome/test/data/extensions/api_test/tts/provide/test.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3768ee10e91e95f4ff90bbe8177ffa407725d955/chrome/test/data/extensions/api_test/tts/provide/test.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts/provide/test.js?ref=3768ee10e91e95f4ff90bbe8177ffa407725d955"", ""patch"": ""@@ -1,113 +0,0 @@\n-// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-\n-// TTS api test for Chrome on ChromeOS.\n-// browser_tests.exe --gtest_filter=\""TtsApiTest.*\""\n-\n-if (!chrome.tts) {\n-  chrome.tts = chrome.experimental.tts;\n-}\n-\n-chrome.test.runTests([\n-  function testNoListeners() {\n-    // This call should go to native speech because we haven't registered\n-    // any listeners.\n-    chrome.tts.speak('native speech', {}, function() {\n-        chrome.test.assertNoLastError();\n-        chrome.test.succeed();\n-      });\n-  },\n-  function testTtsProvider() {\n-    // Register listeners for speech functions, enabling this extension\n-    // to be a TTS provider.\n-    var speakListener = function(utterance, options, callback) {\n-        chrome.test.assertNoLastError();\n-        chrome.test.assertEq('extension speech', utterance);\n-        callback();\n-      };\n-    var stopListener = function() {};\n-    chrome.tts.onSpeak.addListener(speakListener);\n-    chrome.tts.onStop.addListener(stopListener);\n-\n-    // This call should go to our own speech provider.\n-    chrome.tts.speak('extension speech', {}, function() {\n-        chrome.test.assertNoLastError();\n-        chrome.tts.onSpeak.removeListener(speakListener);\n-        chrome.tts.onStop.removeListener(stopListener);\n-        chrome.test.succeed();\n-      });\n-  },\n-  function testVoiceMatching() {\n-    // Count the number of times our callback functions have been called.\n-    var callbacks = 0;\n-    // Count the number of times our TTS provider has been called.\n-    var speakListenerCalls = 0;\n-\n-    // Register listeners for speech functions.\n-    var speakListener = function(utterance, options, callback) {\n-        speakListenerCalls++;\n-        callback();\n-      };\n-    var stopListener = function() {};\n-    chrome.tts.onSpeak.addListener(speakListener);\n-    chrome.tts.onStop.addListener(stopListener);\n-\n-    // These don't match the voices in the manifest, so they should\n-    // go to native speech. The gmock assertions in TtsApiTest::Provide\n-    // enforce that the native TTS handlers are called.\n-    chrome.tts.speak('native speech 2',\n-                     {'voiceName': 'George', 'enqueue': true}, function() {\n-        chrome.test.assertNoLastError();\n-        callbacks++;\n-      });\n-    chrome.tts.speak('native speech 3',\n-                     {'locale': 'fr-FR', 'enqueue': true},\n-                     function() {\n-        chrome.test.assertNoLastError();\n-        callbacks++;\n-      });\n-\n-    // These do match the voices in the manifest, so they should go to our\n-    // own TTS provider.\n-    chrome.tts.speak('extension speech 2',\n-                     {'voiceName': 'Alice', 'enqueue': true},\n-                     function() {\n-        chrome.test.assertNoLastError();\n-        callbacks++;\n-        chrome.test.succeed();\n-      });\n-    chrome.tts.speak('extension speech 3',\n-                     {'voiceName': 'Pat', 'gender': 'male', 'enqueue': true},\n-                     function() {\n-        chrome.test.assertNoLastError();\n-        callbacks++;\n-        chrome.tts.onSpeak.removeListener(speakListener);\n-        chrome.tts.onStop.removeListener(stopListener);\n-        if (callbacks == 4 && speakListenerCalls == 2) {\n-          chrome.test.succeed();\n-        }\n-      });\n-  },\n-  function testTtsProviderError() {\n-    // Register listeners for speech functions, but have speak return an\n-    // error when it's used.\n-    var speakListener = function(utterance, options, callback) {\n-        chrome.test.assertEq('extension speech 4', utterance);\n-        callback('extension tts error');\n-      };\n-    var stopListener = function() {};\n-    chrome.tts.onSpeak.addListener(speakListener);\n-    chrome.tts.onStop.addListener(stopListener);\n-\n-    // This should go to our own TTS provider, and we can check that we\n-    // get the error message.\n-    chrome.tts.speak('extension speech 4', {}, function() {\n-        chrome.test.assertEq('extension tts error',\n-                             chrome.extension.lastError.message);\n-        chrome.tts.onSpeak.removeListener(speakListener);\n-        chrome.tts.onStop.removeListener(stopListener);\n-        chrome.test.succeed();\n-      });\n-  }\n-]);""}<_**next**_>{""sha"": ""c21f9f798bb177b17fe3df912b20dc6f53539965"", ""filename"": ""chrome/test/data/extensions/api_test/tts/queue_interrupt/test.js"", ""status"": ""modified"", ""additions"": 45, ""deletions"": 21, ""changes"": 66, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/queue_interrupt/test.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/queue_interrupt/test.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts/queue_interrupt/test.js?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,35 +1,59 @@\n-// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n // TTS api test for Chrome on ChromeOS.\n // browser_tests.exe --gtest_filter=\""TtsApiTest.*\""\n \n chrome.test.runTests([\n-  function testAllSpeakCallbackFunctionsAreCalled() {\n+  function testQueueInterrupt() {\n     // In this test, two utterances are queued, and then a third\n     // interrupts. The first gets interrupted, the second never gets spoken\n     // at all. The test expectations in extension_tts_apitest.cc ensure that\n     // the first call to tts.speak keeps going until it's interrupted.\n     var callbacks = 0;\n-    chrome.experimental.tts.speak('text 1', {'enqueue': true}, function() {\n-        chrome.test.assertEq('Utterance interrupted.',\n-                             chrome.extension.lastError.message);\n-        callbacks++;\n-      });\n-    chrome.experimental.tts.speak('text 2', {'enqueue': true}, function() {\n-        chrome.test.assertEq('Utterance removed from queue.',\n-                             chrome.extension.lastError.message);\n-        callbacks++;\n-      });\n-    chrome.experimental.tts.speak('text 3', {'enqueue': false}, function() {\n-        chrome.test.assertNoLastError();\n-        callbacks++;\n-        if (callbacks == 3) {\n-          chrome.test.succeed();\n-        } else {\n-          chrome.test.fail();\n-        }\n-      });\n+    chrome.experimental.tts.speak(\n+        'text 1',\n+        {\n+         'enqueue': true,\n+         'onevent': function(event) {\n+           chrome.test.assertEq('interrupted', event.type);\n+           callbacks++;\n+         }\n+        },\n+        function() {\n+          chrome.test.assertNoLastError();\n+          callbacks++;\n+        });\n+    chrome.experimental.tts.speak(\n+        'text 2',\n+        {\n+         'enqueue': true,\n+         'onevent': function(event) {\n+           chrome.test.assertEq('cancelled', event.type);\n+           callbacks++;\n+         }\n+        }, function() {\n+          chrome.test.assertNoLastError();\n+          callbacks++;\n+        });\n+    chrome.experimental.tts.speak(\n+        'text 3',\n+        {\n+         'enqueue': false,\n+         'onevent': function(event) {\n+           chrome.test.assertEq('end', event.type);\n+           callbacks++;\n+           if (callbacks == 6) {\n+             chrome.test.succeed();\n+           } else {\n+             chrome.test.fail();\n+           }\n+         }\n+        },\n+        function() {\n+          chrome.test.assertNoLastError();\n+          callbacks++;\n+        });\n   }\n ]);""}<_**next**_>{""sha"": ""f592d9751980f25db60b8bb9dddbb081a8210d20"", ""filename"": ""chrome/test/data/extensions/api_test/tts/speak_error/test.js"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 19, ""changes"": 51, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/speak_error/test.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/speak_error/test.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts/speak_error/test.js?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,29 +1,42 @@\n-// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n // TTS api test for Chrome on ChromeOS.\n // browser_tests.exe --gtest_filter=\""TtsApiTest.*\""\n \n chrome.test.runTests([\n-  function testSpeakCallbackFunctionIsCalled() {\n+  function testSpeakError() {\n     var callbacks = 0;\n-    chrome.experimental.tts.speak('first try', {'enqueue': true}, function() {\n-        chrome.test.assertNoLastError();\n-        callbacks++;\n-      });\n-    chrome.experimental.tts.speak('second try', {'enqueue': true}, function() {\n-        chrome.test.assertEq('epic fail', chrome.extension.lastError.message);\n-        callbacks++;\n-      });\n-    chrome.experimental.tts.speak('third try', {'enqueue': true}, function() {\n-        chrome.test.assertNoLastError();\n-        callbacks++;\n-        if (callbacks == 3) {\n-          chrome.test.succeed();\n-        } else {\n-          chrome.test.fail();\n-        }\n-      });\n+    chrome.experimental.tts.speak(\n+        'first try',\n+        {\n+         'enqueue': true,\n+         'onevent': function(event) {\n+            chrome.test.assertEq('error', event.type);\n+            chrome.test.assertEq('epic fail', event.errorMessage);\n+            callbacks++;\n+         }\n+        },\n+        function() {\n+          chrome.test.assertNoLastError();\n+        });\n+    chrome.experimental.tts.speak(\n+        'second try',\n+        {\n+         'enqueue': true,\n+         'onevent': function(event) {\n+            chrome.test.assertEq('end', event.type);\n+            callbacks++;\n+            if (callbacks == 2) {\n+              chrome.test.succeed();\n+            } else {\n+              chrome.test.fail();\n+            }\n+         }\n+        },\n+        function() {\n+          chrome.test.assertNoLastError();\n+        });\n   }\n ]);""}<_**next**_>{""sha"": ""588f99811f1cbdec1dc2336d44965b4f173b401e"", ""filename"": ""chrome/test/data/extensions/api_test/tts/speak_once/test.js"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 7, ""changes"": 20, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/speak_once/test.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/speak_once/test.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts/speak_once/test.js?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,15 +1,21 @@\n-// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-// TTS api test for Chrome on ChromeOS.\n // browser_tests.exe --gtest_filter=\""TtsApiTest.*\""\n \n chrome.test.runTests([\n-  function testSpeakCallbackFunctionIsCalled() {\n-    chrome.experimental.tts.speak('hello world', {}, function() {\n-        chrome.test.assertNoLastError();\n-        chrome.test.succeed();\n-      });\n+  function testSpeakOnce() {\n+    function eventListener(event) {\n+      chrome.test.assertEq('end', event.type);\n+      chrome.test.assertEq(11, event.charIndex);\n+      chrome.test.succeed();\n+    }\n+    chrome.experimental.tts.speak(\n+        'hello world',\n+        {'onevent': eventListener},\n+        function() {\n+          chrome.test.assertNoLastError();\n+        });\n   }\n ]);""}<_**next**_>{""sha"": ""a43bc3d479fff0525435dc34dca103487fa93240"", ""filename"": ""chrome/test/data/extensions/api_test/tts/word_callbacks/manifest.json"", ""status"": ""added"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/word_callbacks/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/word_callbacks/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts/word_callbacks/manifest.json?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,7 @@\n+{\n+  \""name\"": \""chrome.experimental.tts\"",\n+  \""version\"": \""0.1\"",\n+  \""description\"": \""browser test for chrome.experimental.tts API\"",\n+  \""background_page\"": \""test.html\"",\n+  \""permissions\"": [\""experimental\""]\n+}""}<_**next**_>{""sha"": ""46f4d74c30692c8ab193b54683da02bd212ef91f"", ""filename"": ""chrome/test/data/extensions/api_test/tts/word_callbacks/test.html"", ""status"": ""renamed"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/word_callbacks/test.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/word_callbacks/test.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts/word_callbacks/test.html?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""previous_filename"": ""chrome/test/data/extensions/api_test/tts/provide/test.html""}<_**next**_>{""sha"": ""232a552245466825dcae251b37bfb6aba17aedd3"", ""filename"": ""chrome/test/data/extensions/api_test/tts/word_callbacks/test.js"", ""status"": ""added"", ""additions"": 40, ""deletions"": 0, ""changes"": 40, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/word_callbacks/test.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts/word_callbacks/test.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts/word_callbacks/test.js?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,40 @@\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+// TTS api test for Chrome on ChromeOS.\n+// browser_tests.exe --gtest_filter=\""TtsApiTest.*\""\n+\n+chrome.test.runTests([\n+  function testWordCallbacks() {\n+    var callbacks = 0;\n+    chrome.experimental.tts.speak(\n+        'one two three',\n+        {\n+         'onevent': function(event) {\n+           callbacks++;\n+           switch(callbacks) {\n+           case 1:\n+             chrome.test.assertEq('word', event.type);\n+             chrome.test.assertEq(0, event.charIndex);\n+             break;\n+           case 2:\n+             chrome.test.assertEq('word', event.type);\n+             chrome.test.assertEq(4, event.charIndex);\n+             break;\n+           case 3:\n+             chrome.test.assertEq('word', event.type);\n+             chrome.test.assertEq(8, event.charIndex);\n+             break;\n+           case 4:\n+             chrome.test.assertEq('end', event.type);\n+             chrome.test.assertEq(13, event.charIndex);\n+             chrome.test.succeed();\n+             break;\n+           default:\n+             chrome.test.fail();\n+           }\n+         }\n+        });\n+  }\n+]);""}<_**next**_>{""sha"": ""39ac6163d496fcfd6fb71e7953045bb39f4ed6f5"", ""filename"": ""chrome/test/data/extensions/api_test/tts_engine/engine_error/manifest.json"", ""status"": ""renamed"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/engine_error/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/engine_error/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts_engine/engine_error/manifest.json?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -3,16 +3,12 @@\n   \""version\"": \""0.1\"",\n   \""description\"": \""browser test for chrome.experimental.tts API\"",\n   \""background_page\"": \""test.html\"",\n-  \""tts\"": {\n+  \""tts_engine\"": {\n     \""voices\"": [\n       {\n-        \""voiceName\"": \""Alice\"",\n-        \""locale\"": \""en-US\"",\n-        \""gender\"": \""female\""\n-      },\n-      {\n-        \""voiceName\"": \""Pat\"",\n-        \""locale\"": \""en-US\""\n+        \""voice_name\"": \""Zach\"",\n+        \""lang\"": \""en-US\"",\n+        \""event_types\"": [ \""end\"", \""error\"" ]\n       }\n     ]\n   },"", ""previous_filename"": ""chrome/test/data/extensions/api_test/tts/provide/manifest.json""}<_**next**_>{""sha"": ""46f4d74c30692c8ab193b54683da02bd212ef91f"", ""filename"": ""chrome/test/data/extensions/api_test/tts_engine/engine_error/test.html"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/engine_error/test.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/engine_error/test.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts_engine/engine_error/test.html?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1 @@\n+<script src=\""test.js\""></script>""}<_**next**_>{""sha"": ""d21156f4396462386b629ded5d49750f3c2275cc"", ""filename"": ""chrome/test/data/extensions/api_test/tts_engine/engine_error/test.js"", ""status"": ""added"", ""additions"": 62, ""deletions"": 0, ""changes"": 62, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/engine_error/test.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/engine_error/test.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts_engine/engine_error/test.js?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,62 @@\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+// TTS api test for Chrome on ChromeOS.\n+// browser_tests.exe --gtest_filter=\""TtsApiTest.*\""\n+\n+if (!chrome.tts) {\n+  chrome.tts = chrome.experimental.tts;\n+}\n+\n+if (!chrome.ttsEngine) {\n+  chrome.ttsEngine = chrome.experimental.ttsEngine;\n+}\n+\n+chrome.test.runTests([\n+  function testTtsEngineError() {\n+    // Register listeners for speech functions, but have speak return an\n+    // error when it's used.\n+    var speakListener = function(utterance, options, sendTtsEvent) {\n+      chrome.test.assertEq('extension speech', utterance);\n+\n+      try {\n+        // This should fail because 'foo' isn't a valid event type.\n+        sendTtsEvent({'type': 'foo'});\n+        chrome.test.fail();\n+      } catch (e) {\n+      }\n+\n+      // This won't actually send an event, and an error will be logged\n+      // to the console, because we haven't registered the 'word'\n+      // event type in our manifest.\n+      sendTtsEvent({'type': 'word'});\n+\n+      // This will succeed.\n+      sendTtsEvent({\n+        'type': 'error',\n+        'charIndex': 0,\n+        'errorMessage': 'extension tts error'});\n+    };\n+    var stopListener = function() {};\n+    chrome.ttsEngine.onSpeak.addListener(speakListener);\n+    chrome.ttsEngine.onStop.addListener(stopListener);\n+\n+    // This should go to our own TTS engine, and we can check that we\n+    // get the error message.\n+    chrome.tts.speak(\n+        'extension speech',\n+        {\n+         'onevent': function(event) {\n+           chrome.test.assertEq('error', event.type);\n+           chrome.test.assertEq('extension tts error', event.errorMessage);\n+           chrome.ttsEngine.onSpeak.removeListener(speakListener);\n+           chrome.ttsEngine.onStop.removeListener(stopListener);\n+           chrome.test.succeed();\n+         }\n+        },\n+        function() {\n+          chrome.test.assertNoLastError();\n+        });\n+  }\n+]);""}<_**next**_>{""sha"": ""7d283570f4e27f4d8b5bb8b4c48affb46eb27e49"", ""filename"": ""chrome/test/data/extensions/api_test/tts_engine/engine_word_callbacks/manifest.json"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/engine_word_callbacks/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/engine_word_callbacks/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts_engine/engine_word_callbacks/manifest.json?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,16 @@\n+{\n+  \""name\"": \""chrome.experimental.tts\"",\n+  \""version\"": \""0.1\"",\n+  \""description\"": \""browser test for chrome.experimental.tts API\"",\n+  \""background_page\"": \""test.html\"",\n+  \""tts_engine\"": {\n+    \""voices\"": [\n+      {\n+        \""voice_name\"": \""WordCallbackVoice\"",\n+        \""lang\"": \""en-US\"",\n+        \""event_types\"": [ \""end\"", \""word\"" ]\n+      }\n+    ]\n+  },\n+  \""permissions\"": [\""experimental\""]\n+}""}<_**next**_>{""sha"": ""46f4d74c30692c8ab193b54683da02bd212ef91f"", ""filename"": ""chrome/test/data/extensions/api_test/tts_engine/engine_word_callbacks/test.html"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/engine_word_callbacks/test.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/engine_word_callbacks/test.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts_engine/engine_word_callbacks/test.html?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1 @@\n+<script src=\""test.js\""></script>""}<_**next**_>{""sha"": ""9a304ba8397527525f19a2dab4f7f067086e9be5"", ""filename"": ""chrome/test/data/extensions/api_test/tts_engine/engine_word_callbacks/test.js"", ""status"": ""added"", ""additions"": 66, ""deletions"": 0, ""changes"": 66, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/engine_word_callbacks/test.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/engine_word_callbacks/test.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts_engine/engine_word_callbacks/test.js?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,66 @@\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+// TTS api test for Chrome on ChromeOS.\n+// browser_tests.exe --gtest_filter=\""TtsApiTest.*\""\n+\n+if (!chrome.tts) {\n+  chrome.tts = chrome.experimental.tts;\n+}\n+\n+if (!chrome.ttsEngine) {\n+  chrome.ttsEngine = chrome.experimental.ttsEngine;\n+}\n+\n+chrome.test.runTests([\n+  function testWordCallbacks() {\n+    // Register listeners for speech functions, enabling this extension\n+    // to be a TTS engine.\n+    var speakListener = function(utterance, options, sendTtsEvent) {\n+      chrome.test.assertNoLastError();\n+      chrome.test.assertEq('alpha beta gamma', utterance);\n+      sendTtsEvent({'type': 'word', 'charIndex': 0});\n+      sendTtsEvent({'type': 'word', 'charIndex': 6});\n+      sendTtsEvent({'type': 'word', 'charIndex': 11});\n+      sendTtsEvent({'type': 'end', 'charIndex': utterance.length});\n+    };\n+    var stopListener = function() {};\n+    chrome.ttsEngine.onSpeak.addListener(speakListener);\n+    chrome.ttsEngine.onStop.addListener(stopListener);\n+\n+    var callbacks = 0;\n+    chrome.tts.speak(\n+        'alpha beta gamma',\n+        {\n+         'onevent': function(event) {\n+           chrome.test.assertNoLastError();\n+           callbacks++;\n+           switch(callbacks) {\n+           case 1:\n+             chrome.test.assertEq('word', event.type);\n+             chrome.test.assertEq(0, event.charIndex);\n+             break;\n+           case 2:\n+             chrome.test.assertEq('word', event.type);\n+             chrome.test.assertEq(6, event.charIndex);\n+             break;\n+           case 3:\n+             chrome.test.assertEq('word', event.type);\n+             chrome.test.assertEq(11, event.charIndex);\n+             break;\n+           case 4:\n+             chrome.test.assertEq('end', event.type);\n+             chrome.test.assertEq(16, event.charIndex);\n+             chrome.test.succeed();\n+             break;\n+           default:\n+             chrome.test.fail();\n+           }\n+         }\n+        },\n+        function() {\n+          chrome.test.assertNoLastError();\n+        });\n+  }\n+]);""}<_**next**_>{""sha"": ""77b5f03c87e010b91e65d29c2a386fc94779530f"", ""filename"": ""chrome/test/data/extensions/api_test/tts_engine/register_engine/manifest.json"", ""status"": ""added"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/register_engine/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/register_engine/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts_engine/register_engine/manifest.json?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,22 @@\n+{\n+  \""name\"": \""chrome.experimental.tts\"",\n+  \""version\"": \""0.1\"",\n+  \""description\"": \""browser test for chrome.experimental.tts API\"",\n+  \""background_page\"": \""test.html\"",\n+  \""tts_engine\"": {\n+    \""voices\"": [\n+      {\n+        \""voice_name\"": \""Alice\"",\n+        \""lang\"": \""en-US\"",\n+        \""gender\"": \""female\"",\n+        \""event_types\"": [ \""end\"" ]\n+      },\n+      {\n+        \""voice_name\"": \""Pat\"",\n+        \""lang\"": \""en-US\"",\n+        \""event_types\"": [ \""end\"" ]\n+      }\n+    ]\n+  },\n+  \""permissions\"": [\""experimental\""]\n+}""}<_**next**_>{""sha"": ""46f4d74c30692c8ab193b54683da02bd212ef91f"", ""filename"": ""chrome/test/data/extensions/api_test/tts_engine/register_engine/test.html"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/register_engine/test.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/register_engine/test.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts_engine/register_engine/test.html?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1 @@\n+<script src=\""test.js\""></script>""}<_**next**_>{""sha"": ""ba9dc14dc5e5a33dfc9f1a912b344a7fea31974b"", ""filename"": ""chrome/test/data/extensions/api_test/tts_engine/register_engine/test.js"", ""status"": ""added"", ""additions"": 170, ""deletions"": 0, ""changes"": 170, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/register_engine/test.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/api_test/tts_engine/register_engine/test.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/tts_engine/register_engine/test.js?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,170 @@\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+// TTS api test for Chrome on ChromeOS.\n+// browser_tests.exe --gtest_filter=\""TtsApiTest.*\""\n+\n+if (!chrome.tts) {\n+  chrome.tts = chrome.experimental.tts;\n+}\n+\n+if (!chrome.ttsEngine) {\n+  chrome.ttsEngine = chrome.experimental.ttsEngine;\n+}\n+\n+chrome.test.runTests([\n+  function testNoListeners() {\n+    // This call should go to native speech because we haven't registered\n+    // any listeners.\n+    chrome.tts.speak(\n+        'native speech',\n+        {\n+         'onevent': function(event) {\n+           if (event.type == 'end') {\n+             chrome.test.succeed();\n+           }\n+         }\n+        }, function() {\n+          chrome.test.assertNoLastError();\n+        });\n+  },\n+  function testTtsEngine() {\n+    var calledOurEngine = false;\n+\n+    // Register listeners for speech functions, enabling this extension\n+    // to be a TTS engine.\n+    var speakListener = function(utterance, options, sendTtsEvent) {\n+        chrome.test.assertNoLastError();\n+        chrome.test.assertEq('extension speech', utterance);\n+        calledOurEngine = true;\n+        sendTtsEvent({'type': 'end', 'charIndex': utterance.length});\n+      };\n+    var stopListener = function() {};\n+    chrome.ttsEngine.onSpeak.addListener(speakListener);\n+    chrome.ttsEngine.onStop.addListener(stopListener);\n+\n+    // This call should go to our own speech engine.\n+    chrome.tts.speak(\n+        'extension speech',\n+        {\n+         'onevent': function(event) {\n+           if (event.type == 'end') {\n+             chrome.test.assertEq(true, calledOurEngine);\n+             chrome.ttsEngine.onSpeak.removeListener(speakListener);\n+             chrome.ttsEngine.onStop.removeListener(stopListener);\n+             chrome.test.succeed();\n+           }\n+         }\n+        },\n+        function() {\n+          chrome.test.assertNoLastError();\n+        });\n+  },\n+  function testVoiceMatching() {\n+    // Count the number of times our callback functions have been called.\n+    var callbacks = 0;\n+    // Count the number of times our TTS engine has been called.\n+    var speakListenerCalls = 0;\n+\n+    // Register listeners for speech functions.\n+    var speakListener = function(utterance, options, sendTtsEvent) {\n+      speakListenerCalls++;\n+      sendTtsEvent({'type': 'end', 'charIndex': utterance.length});\n+    };\n+    var stopListener = function() {};\n+    chrome.ttsEngine.onSpeak.addListener(speakListener);\n+    chrome.ttsEngine.onStop.addListener(stopListener);\n+\n+    // These don't match the voices in the manifest, so they should\n+    // go to native speech. The gmock assertions in TtsApiTest::RegisterEngine\n+    // enforce that the native TTS handlers are called.\n+    chrome.tts.speak(\n+        'native speech 2',\n+        {\n+         'voiceName': 'George',\n+         'enqueue': true,\n+         'onevent': function(event) {\n+           if (event.type == 'end') {\n+             callbacks++;\n+           }\n+         }\n+        }, function() {\n+          chrome.test.assertNoLastError();\n+        });\n+    chrome.tts.speak(\n+        'native speech 3',\n+        {\n+         'lang': 'fr-FR',\n+         'enqueue': true,\n+         'onevent': function(event) {\n+           if (event.type == 'end') {\n+             callbacks++;\n+           }\n+         }\n+        }, function() {\n+          chrome.test.assertNoLastError();\n+        });\n+\n+    // These do match the voices in the manifest, so they should go to our\n+    // own TTS engine.\n+    chrome.tts.speak(\n+        'extension speech 2',\n+        {\n+         'voiceName': 'Alice',\n+         'enqueue': true,\n+         'onevent': function(event) {\n+           if (event.type == 'end') {\n+             callbacks++;\n+           }\n+         }\n+        }, function() {\n+          chrome.test.assertNoLastError();\n+        });\n+    chrome.tts.speak(\n+        'extension speech 3',\n+        {\n+         'voiceName': 'Pat',\n+         'gender': 'male',\n+         'enqueue': true,\n+         'onevent': function(event) {\n+           if (event.type == 'end') {\n+             callbacks++;\n+             chrome.ttsEngine.onSpeak.removeListener(speakListener);\n+             chrome.ttsEngine.onStop.removeListener(stopListener);\n+             if (callbacks == 4 && speakListenerCalls == 2) {\n+               chrome.test.succeed();\n+             }\n+           }\n+         }\n+        }, function() {\n+          chrome.test.assertNoLastError();\n+        });\n+  },\n+  function testGetVoices() {\n+    // We have to register listeners, or the voices provided\n+    // by this extension won't be returned.\n+    var speakListener = function(utterance, options, sendTtsEvent) {\n+        chrome.test.assertNoLastError();\n+        chrome.test.assertEq('extension speech', utterance);\n+        sendTtsEvent({'type': 'end', 'charIndex': utterance.length});\n+      };\n+    var stopListener = function() {};\n+    chrome.ttsEngine.onSpeak.addListener(speakListener);\n+    chrome.ttsEngine.onStop.addListener(stopListener);\n+\n+    chrome.tts.getVoices(function(voices) {\n+      chrome.test.assertEq(3, voices.length);\n+\n+      chrome.test.assertEq('native', voices[0].voiceName);\n+\n+      chrome.test.assertEq('Alice', voices[1].voiceName);\n+      chrome.test.assertEq('en-US', voices[1].lang);\n+      chrome.test.assertEq('female', voices[1].gender);\n+\n+      chrome.test.assertEq('Pat', voices[2].voiceName);\n+      chrome.test.assertEq('en-US', voices[2].lang);\n+      chrome.test.succeed();\n+    });\n+  }\n+]);""}<_**next**_>{""sha"": ""91f1c28633225d928ba495864d5edfd4039c1e78"", ""filename"": ""chrome/test/data/extensions/manifest_tests/tts_engine_invalid_1.json"", ""status"": ""renamed"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_1.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_1.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_1.json?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,5 +1,5 @@\n {\n   \""name\"": \""test\"",\n   \""version\"": \""1\"",\n-  \""tts\"": \""shouldBeADict\""\n+  \""tts_engine\"": \""shouldBeADict\""\n }"", ""previous_filename"": ""chrome/test/data/extensions/manifest_tests/tts_provider_invalid_1.json""}<_**next**_>{""sha"": ""5f44e6210393666b40d5a6b2e9362939f05f0ff9"", ""filename"": ""chrome/test/data/extensions/manifest_tests/tts_engine_invalid_2.json"", ""status"": ""renamed"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_2.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_2.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_2.json?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,7 +1,7 @@\n {\n   \""name\"": \""test\"",\n   \""version\"": \""1\"",\n-  \""tts\"": {\n+  \""tts_engine\"": {\n     \""voices\"": \""shouldBeAnArray\""\n   }\n }"", ""previous_filename"": ""chrome/test/data/extensions/manifest_tests/tts_provider_invalid_2.json""}<_**next**_>{""sha"": ""109804c62f3b96a21088d9b5f51a0a3a94e2fb01"", ""filename"": ""chrome/test/data/extensions/manifest_tests/tts_engine_invalid_3.json"", ""status"": ""renamed"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_3.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_3.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_3.json?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,7 +1,7 @@\n {\n   \""name\"": \""test\"",\n   \""version\"": \""1\"",\n-  \""tts\"": {\n+  \""tts_engine\"": {\n     \""voices\"": [\n       \""shouldBeADict\""\n     ]"", ""previous_filename"": ""chrome/test/data/extensions/manifest_tests/tts_provider_invalid_3.json""}<_**next**_>{""sha"": ""340b6769ded2a0ad535852c87612cb7022cd5d5b"", ""filename"": ""chrome/test/data/extensions/manifest_tests/tts_engine_invalid_4.json"", ""status"": ""added"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_4.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_4.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_4.json?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,11 @@\n+{\n+  \""name\"": \""test\"",\n+  \""version\"": \""1\"",\n+  \""tts_engine\"": {\n+    \""voices\"": [\n+      {\n+        \""voice_name\"": [ \""Shouldn't be in an array\"" ]\n+      }\n+    ]\n+  }\n+}""}<_**next**_>{""sha"": ""bb4025b2ed161bbd1a165bde1cc0cbc89d2ff079"", ""filename"": ""chrome/test/data/extensions/manifest_tests/tts_engine_invalid_5.json"", ""status"": ""renamed"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_5.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_5.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_5.json?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,10 +1,10 @@\n {\n   \""name\"": \""test\"",\n   \""version\"": \""1\"",\n-  \""tts\"": {\n+  \""tts_engine\"": {\n     \""voices\"": [\n       {\n-        \""locale\"": \""\""\n+        \""lang\"": \""\""\n       }\n     ]\n   }"", ""previous_filename"": ""chrome/test/data/extensions/manifest_tests/tts_provider_invalid_5.json""}<_**next**_>{""sha"": ""8e73a3256aeb3a109f7f60141b0346dec1541d7b"", ""filename"": ""chrome/test/data/extensions/manifest_tests/tts_engine_invalid_6.json"", ""status"": ""renamed"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_6.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_6.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_6.json?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,10 +1,10 @@\n {\n   \""name\"": \""test\"",\n   \""version\"": \""1\"",\n-  \""tts\"": {\n+  \""tts_engine\"": {\n     \""voices\"": [\n       {\n-        \""locale\"": \""German\""\n+        \""lang\"": \""German\""\n       }\n     ]\n   }"", ""previous_filename"": ""chrome/test/data/extensions/manifest_tests/tts_provider_invalid_6.json""}<_**next**_>{""sha"": ""defd0f346780b3ffc0bff915d3e994710bfd1a20"", ""filename"": ""chrome/test/data/extensions/manifest_tests/tts_engine_invalid_7.json"", ""status"": ""renamed"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_7.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_7.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_7.json?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,7 +1,7 @@\n {\n   \""name\"": \""test\"",\n   \""version\"": \""1\"",\n-  \""tts\"": {\n+  \""tts_engine\"": {\n     \""voices\"": [\n       {\n         \""gender\"": \""alien\"""", ""previous_filename"": ""chrome/test/data/extensions/manifest_tests/tts_provider_invalid_7.json""}<_**next**_>{""sha"": ""635f4840fe19c2e98e89ce4d1291572d008202e8"", ""filename"": ""chrome/test/data/extensions/manifest_tests/tts_engine_invalid_8.json"", ""status"": ""renamed"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_8.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_8.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_8.json?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,10 +1,10 @@\n {\n   \""name\"": \""test\"",\n   \""version\"": \""1\"",\n-  \""tts\"": {\n+  \""tts_engine\"": {\n     \""voices\"": [\n       {\n-        \""voiceName\"": [ \""Shouldn't be in an array\"" ]\n+        \""event_types\"": \""shouldBeAnArray\""\n       }\n     ]\n   }"", ""previous_filename"": ""chrome/test/data/extensions/manifest_tests/tts_provider_invalid_4.json""}<_**next**_>{""sha"": ""9679e456cd8d812ceedb3251bc8468404a910e1f"", ""filename"": ""chrome/test/data/extensions/manifest_tests/tts_engine_invalid_9.json"", ""status"": ""added"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_9.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_9.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/manifest_tests/tts_engine_invalid_9.json?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -0,0 +1,11 @@\n+{\n+  \""name\"": \""test\"",\n+  \""version\"": \""1\"",\n+  \""tts_engine\"": {\n+    \""voices\"": [\n+      {\n+        \""event_types\"": [\""on vacation\""]\n+      }\n+    ]\n+  }\n+}""}<_**next**_>{""sha"": ""9b9e9add90d592c71262952163f261ab09765f47"", ""filename"": ""chrome/test/data/extensions/manifest_tests/tts_engine_valid.json"", ""status"": ""renamed"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_valid.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7/chrome/test/data/extensions/manifest_tests/tts_engine_valid.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/manifest_tests/tts_engine_valid.json?ref=c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7"", ""patch"": ""@@ -1,12 +1,13 @@\n {\n   \""name\"": \""test\"",\n   \""version\"": \""1\"",\n-  \""tts\"": {\n+  \""tts_engine\"": {\n     \""voices\"": [\n       {\n-        \""voiceName\"": \""name\"",\n-\t\""locale\"": \""en-US\"",\n+        \""voice_name\"": \""name\"",\n+\t\""lang\"": \""en-US\"",\n \t\""gender\"": \""female\"",\n+        \""event_types\"": [\""start\"", \""end\"", \""marker\""],\n \t\""other_key\"": \""other_value\""\n       }\n     ]"", ""previous_filename"": ""chrome/test/data/extensions/manifest_tests/tts_provider_valid.json""}","  if (current_utterance_ && !current_utterance_->extension_id().empty()) {/~/    current_utterance_->profile()->GetExtensionEventRouter()->/~/        DispatchEventToExtension(/~/            current_utterance_->extension_id(),/~/            events::kOnStop,/~/            ""[]"",/~/            current_utterance_->profile(),/~/            GURL());/~/  } else {/~/    GetPlatformImpl()->clear_error();/~/    GetPlatformImpl()->StopSpeaking();/~/  if (current_utterance_)/~/    current_utterance_->set_error(kSpeechInterruptedError);/~/  FinishCurrentUtterance();/~/  ClearUtteranceQueue();/~/}","1,2,3,4,5,6,7,8,9,10,11,14,15,16,17,18","void ExtensionTtsController::Stop() {
  double volume = 1.0;
  if (options->HasKey(constants::kVolumeKey)) {
    EXTENSION_FUNCTION_VALIDATE(
        options->GetDouble(constants::kVolumeKey, &volume));
    if (volume < 0.0 || volume > 1.0) {
      error_ = constants::kErrorInvalidVolume;
      return false;
    }
   }
 
","void ExtensionTtsController::Stop() {
  if (current_utterance_ && !current_utterance_->extension_id().empty()) {
    current_utterance_->profile()->GetExtensionEventRouter()->
        DispatchEventToExtension(
            current_utterance_->extension_id(),
            events::kOnStop,
            ""[]"",
            current_utterance_->profile(),
            GURL());
  } else {
    GetPlatformImpl()->clear_error();
    GetPlatformImpl()->StopSpeaking();
   }
 
  if (current_utterance_)
    current_utterance_->set_error(kSpeechInterruptedError);
  FinishCurrentUtterance();
  ClearUtteranceQueue();
}
",183848.0,C,"  double volume = 1.0;
  if (options->HasKey(constants::kVolumeKey)) {
    EXTENSION_FUNCTION_VALIDATE(
        options->GetDouble(constants::kVolumeKey, &volume));
    if (volume < 0.0 || volume > 1.0) {
      error_ = constants::kErrorInvalidVolume;
      return false;
    }
","  if (current_utterance_ && !current_utterance_->extension_id().empty()) {
    current_utterance_->profile()->GetExtensionEventRouter()->
        DispatchEventToExtension(
            current_utterance_->extension_id(),
            events::kOnStop,
            ""[]"",
            current_utterance_->profile(),
            GURL());
  } else {
    GetPlatformImpl()->clear_error();
    GetPlatformImpl()->StopSpeaking();
  if (current_utterance_)
    current_utterance_->set_error(kSpeechInterruptedError);
  FinishCurrentUtterance();
  ClearUtteranceQueue();
}
",,"@@ -2,366 +2,159 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include ""chrome/browser/extensions/extension_tts_api.h""
+
 #include <string>
-#include <vector>
 
-#include ""base/float_util.h""
-#include ""base/json/json_writer.h""
-#include ""base/message_loop.h""
 #include ""base/values.h""
-#include ""chrome/browser/extensions/extension_event_router.h""
-#include ""chrome/browser/extensions/extension_service.h""
-#include ""chrome/browser/extensions/extension_tts_api.h""
+#include ""chrome/browser/extensions/extension_tts_api_constants.h""
+#include ""chrome/browser/extensions/extension_tts_api_controller.h""
 #include ""chrome/browser/profiles/profile.h""
+#include ""ui/base/l10n/l10n_util.h""
 
-namespace util = extension_tts_api_util;
-
-namespace {
-const char kSpeechInterruptedError[] = ""Utterance interrupted."";
-const char kSpeechRemovedFromQueueError[] = ""Utterance removed from queue."";
-const int kSpeechCheckDelayIntervalMs = 100;
-};
-
-namespace events {
-const char kOnSpeak[] = ""experimental.tts.onSpeak"";
-const char kOnStop[] = ""experimental.tts.onStop"";
-};  // namespace events
-
-//
-// ExtensionTtsPlatformImpl
-//
+namespace constants = extension_tts_api_constants;
 
-std::string ExtensionTtsPlatformImpl::error() {
-  return error_;
-}
-
-void ExtensionTtsPlatformImpl::clear_error() {
-  error_ = std::string();
-}
-
-void ExtensionTtsPlatformImpl::set_error(const std::string& error) {
-  error_ = error;
-}
-
-//
-// Utterance
-//
-
-// static
-int Utterance::next_utterance_id_ = 0;
-
-Utterance::Utterance(Profile* profile,
-                     const std::string& text,
-                     DictionaryValue* options,
-                     Task* completion_task)
-    : profile_(profile),
-      id_(next_utterance_id_++),
-      text_(text),
-      rate_(-1.0),
-      pitch_(-1.0),
-      volume_(-1.0),
-      can_enqueue_(false),
-      completion_task_(completion_task) {
-  if (!options) {
-    // Use all default options.
-    options_.reset(new DictionaryValue());
-    return;
+bool ExtensionTtsSpeakFunction::RunImpl() {
+  std::string text;
+  EXTENSION_FUNCTION_VALIDATE(args_->GetString(0, &text));
+  if (text.size() > 32768) {
+    error_ = constants::kErrorUtteranceTooLong;
+    return false;
   }
 
-  options_.reset(options->DeepCopy());
-
-  if (options->HasKey(util::kVoiceNameKey))
-    options->GetString(util::kVoiceNameKey, &voice_name_);
-
-  if (options->HasKey(util::kLocaleKey))
-    options->GetString(util::kLocaleKey, &locale_);
-
-  if (options->HasKey(util::kGenderKey))
-    options->GetString(util::kGenderKey, &gender_);
-
-  if (options->GetDouble(util::kRateKey, &rate_)) {
-    if (!base::IsFinite(rate_) || rate_ < 0.0 || rate_ > 1.0)
-      rate_ = -1.0;
+  scoped_ptr<DictionaryValue> options;
+  if (args_->GetSize() >= 2) {
+    DictionaryValue* temp_options = NULL;
+    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &temp_options));
+    options.reset(temp_options->DeepCopy());
   }
 
-  if (options->GetDouble(util::kPitchKey, &pitch_)) {
-    if (!base::IsFinite(pitch_) || pitch_ < 0.0 || pitch_ > 1.0)
-      pitch_ = -1.0;
+  std::string voice_name;
+  if (options->HasKey(constants::kVoiceNameKey)) {
+    EXTENSION_FUNCTION_VALIDATE(
+        options->GetString(constants::kVoiceNameKey, &voice_name));
   }
 
-  if (options->GetDouble(util::kVolumeKey, &volume_)) {
-    if (!base::IsFinite(volume_) || volume_ < 0.0 || volume_ > 1.0)
-      volume_ = -1.0;
+  std::string lang;
+  if (options->HasKey(constants::kLangKey))
+    EXTENSION_FUNCTION_VALIDATE(options->GetString(constants::kLangKey, &lang));
+  if (!lang.empty() && !l10n_util::IsValidLocaleSyntax(lang)) {
+    error_ = constants::kErrorInvalidLang;
+    return false;
   }
 
-  if (options->HasKey(util::kEnqueueKey))
-    options->GetBoolean(util::kEnqueueKey, &can_enqueue_);
-}
-
-Utterance::~Utterance() {
-  DCHECK_EQ(completion_task_, static_cast<Task *>(NULL));
-}
-
-void Utterance::FinishAndDestroy() {
-  completion_task_->Run();
-  completion_task_ = NULL;
-  delete this;
-}
-
-//
-// ExtensionTtsController
-//
-
-// static
-ExtensionTtsController* ExtensionTtsController::GetInstance() {
-  return Singleton<ExtensionTtsController>::get();
-}
-
-ExtensionTtsController::ExtensionTtsController()
-    : ALLOW_THIS_IN_INITIALIZER_LIST(method_factory_(this)),
-      current_utterance_(NULL),
-      platform_impl_(NULL) {
-}
-
-ExtensionTtsController::~ExtensionTtsController() {
-  FinishCurrentUtterance();
-  ClearUtteranceQueue();
-}
-
-void ExtensionTtsController::SpeakOrEnqueue(Utterance* utterance) {
-  if (IsSpeaking() && utterance->can_enqueue()) {
-    utterance_queue_.push(utterance);
-  } else {
-    Stop();
-    SpeakNow(utterance);
+  std::string gender;
+  if (options->HasKey(constants::kGenderKey))
+    EXTENSION_FUNCTION_VALIDATE(
+        options->GetString(constants::kGenderKey, &gender));
+  if (!gender.empty() &&
+      gender != constants::kGenderFemale &&
+      gender != constants::kGenderMale) {
+    error_ = constants::kErrorInvalidGender;
+    return false;
   }
-}
-
-std::string ExtensionTtsController::GetMatchingExtensionId(
-    Utterance* utterance) {
-  ExtensionService* service = utterance->profile()->GetExtensionService();
-  DCHECK(service);
-  ExtensionEventRouter* event_router =
-      utterance->profile()->GetExtensionEventRouter();
-  DCHECK(event_router);
 
-  const ExtensionList* extensions = service->extensions();
-  ExtensionList::const_iterator iter;
-  for (iter = extensions->begin(); iter != extensions->end(); ++iter) {
-    const Extension* extension = *iter;
-
-    if (!event_router->ExtensionHasEventListener(
-            extension->id(), events::kOnSpeak) ||
-        !event_router->ExtensionHasEventListener(
-            extension->id(), events::kOnStop)) {
-      continue;
+  double rate = 1.0;
+  if (options->HasKey(constants::kRateKey)) {
+    EXTENSION_FUNCTION_VALIDATE(
+        options->GetDouble(constants::kRateKey, &rate));
+    if (rate < 0.1 || rate > 10.0) {
+      error_ = constants::kErrorInvalidRate;
+      return false;
     }
-
-    const std::vector<Extension::TtsVoice>& tts_voices =
-        extension->tts_voices();
-    for (size_t i = 0; i < tts_voices.size(); ++i) {
-      const Extension::TtsVoice& voice = tts_voices[i];
-      if (!voice.voice_name.empty() &&
-          !utterance->voice_name().empty() &&
-          voice.voice_name != utterance->voice_name()) {
-        continue;
-      }
-      if (!voice.locale.empty() &&
-          !utterance->locale().empty() &&
-          voice.locale != utterance->locale()) {
-        continue;
-      }
-      if (!voice.gender.empty() &&
-          !utterance->gender().empty() &&
-          voice.gender != utterance->gender()) {
-        continue;
-      }
-
-      return extension->id();
-    }
-  }
-
-  return std::string();
-}
-
-void ExtensionTtsController::SpeakNow(Utterance* utterance) {
-  std::string extension_id = GetMatchingExtensionId(utterance);
-  if (!extension_id.empty()) {
-    current_utterance_ = utterance;
-    utterance->set_extension_id(extension_id);
-
-    ListValue args;
-    args.Set(0, Value::CreateStringValue(utterance->text()));
-
-    // Pass through all options to the speech engine, except for
-    // ""enqueue"", which the speech engine doesn't need to handle.
-    DictionaryValue* options = static_cast<DictionaryValue*>(
-        utterance->options()->DeepCopy());
-    if (options->HasKey(util::kEnqueueKey))
-      options->Remove(util::kEnqueueKey, NULL);
-
-    args.Set(1, options);
-    args.Set(2, Value::CreateIntegerValue(utterance->id()));
-    std::string json_args;
-    base::JSONWriter::Write(&args, false, &json_args);
-
-    utterance->profile()->GetExtensionEventRouter()->DispatchEventToExtension(
-        extension_id,
-        events::kOnSpeak,
-        json_args,
-        utterance->profile(),
-        GURL());
-
-    return;
   }
 
-  GetPlatformImpl()->clear_error();
-  bool success = GetPlatformImpl()->Speak(
-      utterance->text(),
-      utterance->locale(),
-      utterance->gender(),
-      utterance->rate(),
-      utterance->pitch(),
-      utterance->volume());
-  if (!success) {
-    utterance->set_error(GetPlatformImpl()->error());
-    utterance->FinishAndDestroy();
-    return;
+  double pitch = 1.0;
+  if (options->HasKey(constants::kPitchKey)) {
+    EXTENSION_FUNCTION_VALIDATE(
+        options->GetDouble(constants::kPitchKey, &pitch));
+    if (pitch < 0.0 || pitch > 2.0) {
+      error_ = constants::kErrorInvalidPitch;
+      return false;
+    }
   }
-  current_utterance_ = utterance;
-
-  // Check to see if it's still speaking; finish the utterance if not and
-  // start polling if so. Checking immediately helps to avoid flaky unit
-  // tests by forcing them to set expectations for IsSpeaking.
-  CheckSpeechStatus();
-}
 
-void ExtensionTtsController::Stop() {
-  if (current_utterance_ && !current_utterance_->extension_id().empty()) {
-    current_utterance_->profile()->GetExtensionEventRouter()->
-        DispatchEventToExtension(
-            current_utterance_->extension_id(),
-            events::kOnStop,
-            ""[]"",
-            current_utterance_->profile(),
-            GURL());
-  } else {
-    GetPlatformImpl()->clear_error();
-    GetPlatformImpl()->StopSpeaking();
+  double volume = 1.0;
+  if (options->HasKey(constants::kVolumeKey)) {
+    EXTENSION_FUNCTION_VALIDATE(
+        options->GetDouble(constants::kVolumeKey, &volume));
+    if (volume < 0.0 || volume > 1.0) {
+      error_ = constants::kErrorInvalidVolume;
+      return false;
+    }
   }
 
-  if (current_utterance_)
-    current_utterance_->set_error(kSpeechInterruptedError);
-  FinishCurrentUtterance();
-  ClearUtteranceQueue();
-}
-
-void ExtensionTtsController::OnSpeechFinished(
-    int request_id, const std::string& error_message) {
-  // We may sometimes receive completion callbacks ""late"", after we've
-  // already finished the utterance (for example because another utterance
-  // interrupted or we got a call to Stop). It's also possible that a buggy
-  // extension has called this more than once. In either case it's safe to
-  // just ignore this call.
-  if (!current_utterance_ || request_id != current_utterance_->id())
-    return;
-
-  current_utterance_->set_error(error_message);
-  FinishCurrentUtterance();
-  SpeakNextUtterance();
-}
-
-bool ExtensionTtsController::IsSpeaking() const {
-  return current_utterance_ != NULL;
-}
-
-void ExtensionTtsController::FinishCurrentUtterance() {
-  if (current_utterance_) {
-    current_utterance_->FinishAndDestroy();
-    current_utterance_ = NULL;
+  bool can_enqueue = false;
+  if (options->HasKey(constants::kEnqueueKey)) {
+    EXTENSION_FUNCTION_VALIDATE(
+        options->GetBoolean(constants::kEnqueueKey, &can_enqueue));
   }
-}
 
-void ExtensionTtsController::SpeakNextUtterance() {
-  // Start speaking the next utterance in the queue.  Keep trying in case
-  // one fails but there are still more in the queue to try.
-  while (!utterance_queue_.empty() && !current_utterance_) {
-    Utterance* utterance = utterance_queue_.front();
-    utterance_queue_.pop();
-    SpeakNow(utterance);
-  }
-}
-
-void ExtensionTtsController::ClearUtteranceQueue() {
-  while (!utterance_queue_.empty()) {
-    Utterance* utterance = utterance_queue_.front();
-    utterance_queue_.pop();
-    utterance->set_error(kSpeechRemovedFromQueueError);
-    utterance->FinishAndDestroy();
+  std::set<std::string> required_event_types;
+  if (options->HasKey(constants::kRequiredEventTypesKey)) {
+    ListValue* list;
+    EXTENSION_FUNCTION_VALIDATE(
+        options->GetList(constants::kRequiredEventTypesKey, &list));
+    for (size_t i = 0; i < list->GetSize(); i++) {
+      std::string event_type;
+      if (!list->GetString(i, &event_type))
+        required_event_types.insert(event_type);
+    }
   }
-}
-
-void ExtensionTtsController::CheckSpeechStatus() {
-  if (!current_utterance_)
-    return;
 
-  if (!current_utterance_->extension_id().empty())
-    return;
-
-  if (GetPlatformImpl()->IsSpeaking() == false) {
-    FinishCurrentUtterance();
-    SpeakNextUtterance();
+  std::set<std::string> desired_event_types;
+  if (options->HasKey(constants::kDesiredEventTypesKey)) {
+    ListValue* list;
+    EXTENSION_FUNCTION_VALIDATE(
+        options->GetList(constants::kDesiredEventTypesKey, &list));
+    for (size_t i = 0; i < list->GetSize(); i++) {
+      std::string event_type;
+      if (!list->GetString(i, &event_type))
+        desired_event_types.insert(event_type);
+    }
   }
 
-  // If we're still speaking something (either the prevoius utterance or
-  // a new utterance), keep calling this method after another delay.
-  // TODO(dmazzoni): get rid of this as soon as all platform implementations
-  // provide completion callbacks rather than only supporting polling.
-  if (current_utterance_ && current_utterance_->extension_id().empty()) {
-    MessageLoop::current()->PostDelayedTask(
-        FROM_HERE, method_factory_.NewRunnableMethod(
-            &ExtensionTtsController::CheckSpeechStatus),
-        kSpeechCheckDelayIntervalMs);
+  std::string voice_extension_id;
+  if (options->HasKey(constants::kExtensionIdKey)) {
+    EXTENSION_FUNCTION_VALIDATE(
+        options->GetString(constants::kExtensionIdKey, &voice_extension_id));
   }
-}
-
-void ExtensionTtsController::SetPlatformImpl(
-    ExtensionTtsPlatformImpl* platform_impl) {
-  platform_impl_ = platform_impl;
-}
 
-ExtensionTtsPlatformImpl* ExtensionTtsController::GetPlatformImpl() {
-  if (!platform_impl_)
-    platform_impl_ = ExtensionTtsPlatformImpl::GetInstance();
-  return platform_impl_;
-}
-
-//
-// Extension API functions
-//
-
-bool ExtensionTtsSpeakFunction::RunImpl() {
-  std::string text;
-  EXTENSION_FUNCTION_VALIDATE(args_->GetString(0, &text));
-  DictionaryValue* options = NULL;
-  if (args_->GetSize() >= 2)
-    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));
-  Task* completion_task = NewRunnableMethod(
-      this, &ExtensionTtsSpeakFunction::SpeechFinished);
-  utterance_ = new Utterance(profile(), text, options, completion_task);
-
-  AddRef();  // Balanced in SpeechFinished().
-  ExtensionTtsController::GetInstance()->SpeakOrEnqueue(utterance_);
+  int src_id = -1;
+  EXTENSION_FUNCTION_VALIDATE(
+      options->GetInteger(constants::kSrcIdKey, &src_id));
+
+  // If we got this far, the arguments were all in the valid format, so
+  // send the success response to the callback now - this ensures that
+  // the callback response always arrives before events, which makes
+  // the behavior more predictable and easier to write unit tests for too.
+  SendResponse(true);
+
+  UtteranceContinuousParameters continuous_params;
+  continuous_params.rate = rate;
+  continuous_params.pitch = pitch;
+  continuous_params.volume = volume;
+
+  Utterance* utterance = new Utterance(profile());
+  utterance->set_text(text);
+  utterance->set_voice_name(voice_name);
+  utterance->set_src_extension_id(extension_id());
+  utterance->set_src_id(src_id);
+  utterance->set_src_url(source_url());
+  utterance->set_lang(lang);
+  utterance->set_gender(gender);
+  utterance->set_continuous_parameters(continuous_params);
+  utterance->set_can_enqueue(can_enqueue);
+  utterance->set_required_event_types(required_event_types);
+  utterance->set_desired_event_types(desired_event_types);
+  utterance->set_extension_id(voice_extension_id);
+  utterance->set_options(options.get());
+
+  ExtensionTtsController* controller = ExtensionTtsController::GetInstance();
+  controller->SpeakOrEnqueue(utterance);
   return true;
 }
 
-void ExtensionTtsSpeakFunction::SpeechFinished() {
-  error_ = utterance_->error();
-  bool success = error_.empty();
-  SendResponse(success);
-  Release();  // Balanced in RunImpl().
-}
-
 bool ExtensionTtsStopSpeakingFunction::RunImpl() {
   ExtensionTtsController::GetInstance()->Stop();
   return true;
@@ -373,14 +166,7 @@ bool ExtensionTtsIsSpeakingFunction::RunImpl() {
   return true;
 }
 
-bool ExtensionTtsSpeakCompletedFunction::RunImpl() {
-  int request_id;
-  std::string error_message;
-  EXTENSION_FUNCTION_VALIDATE(args_->GetInteger(0, &request_id));
-  if (args_->GetSize() >= 2)
-    EXTENSION_FUNCTION_VALIDATE(args_->GetString(1, &error_message));
-  ExtensionTtsController::GetInstance()->OnSpeechFinished(
-      request_id, error_message);
-
+bool ExtensionTtsGetVoicesFunction::RunImpl() {
+  result_.reset(ExtensionTtsController::GetInstance()->GetVoices(profile()));
   return true;
 }","void ExtensionTtsController::Stop() {
  if (current_utterance_ && !current_utterance_->extension_id().empty()) {
    current_utterance_->profile()->GetExtensionEventRouter()->
        DispatchEventToExtension(
            current_utterance_->extension_id(),
            events::kOnStop,
            ""[]"",
            current_utterance_->profile(),
            GURL());
  } else {
    GetPlatformImpl()->clear_error();
    GetPlatformImpl()->StopSpeaking();
}

  if (current_utterance_)
    current_utterance_->set_error(kSpeechInterruptedError);
  FinishCurrentUtterance();
  ClearUtteranceQueue();
}
",Chrome,c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7,3768ee10e91e95f4ff90bbe8177ffa407725d955,1.0,"void ExtensionTtsController::Stop() {
//flaw_line_below:
  if (current_utterance_ && !current_utterance_->extension_id().empty()) {
//flaw_line_below:
    current_utterance_->profile()->GetExtensionEventRouter()->
//flaw_line_below:
        DispatchEventToExtension(
//flaw_line_below:
            current_utterance_->extension_id(),
//flaw_line_below:
            events::kOnStop,
//flaw_line_below:
            ""[]"",
//flaw_line_below:
            current_utterance_->profile(),
//flaw_line_below:
            GURL());
//flaw_line_below:
  } else {
//flaw_line_below:
    GetPlatformImpl()->clear_error();
//flaw_line_below:
    GetPlatformImpl()->StopSpeaking();
//fix_flaw_line_below:
//  double volume = 1.0;
//fix_flaw_line_below:
//  if (options->HasKey(constants::kVolumeKey)) {
//fix_flaw_line_below:
//    EXTENSION_FUNCTION_VALIDATE(
//fix_flaw_line_below:
//        options->GetDouble(constants::kVolumeKey, &volume));
//fix_flaw_line_below:
//    if (volume < 0.0 || volume > 1.0) {
//fix_flaw_line_below:
//      error_ = constants::kErrorInvalidVolume;
//fix_flaw_line_below:
//      return false;
//fix_flaw_line_below:
//    }
   }
 
//flaw_line_below:
  if (current_utterance_)
//flaw_line_below:
    current_utterance_->set_error(kSpeechInterruptedError);
//flaw_line_below:
  FinishCurrentUtterance();
//flaw_line_below:
  ClearUtteranceQueue();
//flaw_line_below:
}
"
120,None,Local,Not required,None,CVE-2017-14954,https://www.cvedetails.com/cve/CVE-2017-14954/,CWE-200,Low,Partial,None,,2017-10-01,2.1,"The waitid implementation in kernel/exit.c in the Linux kernel through 4.13.4 accesses rusage data structures in unintended cases, which allows local users to obtain sensitive information, and bypass the KASLR protection mechanism, via a crafted system call.",2017-10-06,Bypass +Info ,1.0,https://github.com/torvalds/linux/commit/6c85501f2fabcfc4fc6ed976543d252c4eaf4be9,6c85501f2fabcfc4fc6ed976543d252c4eaf4be9,"fix infoleak in waitid(2)

kernel_waitid() can return a PID, an error or 0.  rusage is filled in the first
case and waitid(2) rusage should've been copied out exactly in that case, *not*
whenever kernel_waitid() has not returned an error.  Compat variant shares that
braino; none of kernel_wait4() callers do, so the below ought to fix it.

Reported-and-tested-by: Alexander Potapenko <glider@google.com>
Fixes: ce72a16fa705 (""wait4(2)/waitid(2): separate copying rusage to userland"")
Cc: stable@vger.kernel.org # v4.13
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",2.0,kernel/exit.c,"{""sha"": ""f2cd53e92147c35c43d773b1eb688098fe4b7db3"", ""filename"": ""kernel/exit.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 13, ""changes"": 23, ""blob_url"": ""https://github.com/torvalds/linux/blob/6c85501f2fabcfc4fc6ed976543d252c4eaf4be9/kernel/exit.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/6c85501f2fabcfc4fc6ed976543d252c4eaf4be9/kernel/exit.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/exit.c?ref=6c85501f2fabcfc4fc6ed976543d252c4eaf4be9"", ""patch"": ""@@ -1600,12 +1600,10 @@ SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n \tstruct waitid_info info = {.status = 0};\n \tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n \tint signo = 0;\n+\n \tif (err > 0) {\n \t\tsigno = SIGCHLD;\n \t\terr = 0;\n-\t}\n-\n-\tif (!err) {\n \t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n \t\t\treturn -EFAULT;\n \t}\n@@ -1723,16 +1721,15 @@ COMPAT_SYSCALL_DEFINE5(waitid,\n \tif (err > 0) {\n \t\tsigno = SIGCHLD;\n \t\terr = 0;\n-\t}\n-\n-\tif (!err && uru) {\n-\t\t/* kernel_waitid() overwrites everything in ru */\n-\t\tif (COMPAT_USE_64BIT_TIME)\n-\t\t\terr = copy_to_user(uru, &ru, sizeof(ru));\n-\t\telse\n-\t\t\terr = put_compat_rusage(&ru, uru);\n-\t\tif (err)\n-\t\t\treturn -EFAULT;\n+\t\tif (uru) {\n+\t\t\t/* kernel_waitid() overwrites everything in ru */\n+\t\t\tif (COMPAT_USE_64BIT_TIME)\n+\t\t\t\terr = copy_to_user(uru, &ru, sizeof(ru));\n+\t\t\telse\n+\t\t\t\terr = put_compat_rusage(&ru, uru);\n+\t\t\tif (err)\n+\t\t\t\treturn -EFAULT;\n+\t\t}\n \t}\n \n \tif (!infop)""}",	}/~/	if (!err) {,"10,11","SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
		infop, int, options, struct rusage __user *, ru)
{
	struct rusage r;
 	struct waitid_info info = {.status = 0};
 	long err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);
 	int signo = 0;

 	if (err > 0) {
 		signo = SIGCHLD;
 		err = 0;
 		if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
 			return -EFAULT;
 	}
	if (!infop)
		return err;

	user_access_begin();
	unsafe_put_user(signo, &infop->si_signo, Efault);
	unsafe_put_user(0, &infop->si_errno, Efault);
	unsafe_put_user(info.cause, &infop->si_code, Efault);
	unsafe_put_user(info.pid, &infop->si_pid, Efault);
	unsafe_put_user(info.uid, &infop->si_uid, Efault);
	unsafe_put_user(info.status, &infop->si_status, Efault);
	user_access_end();
	return err;
Efault:
	user_access_end();
	return -EFAULT;
}
","SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
		infop, int, options, struct rusage __user *, ru)
{
	struct rusage r;
 	struct waitid_info info = {.status = 0};
 	long err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);
 	int signo = 0;
 	if (err > 0) {
 		signo = SIGCHLD;
 		err = 0;
	}
	if (!err) {
 		if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
 			return -EFAULT;
 	}
	if (!infop)
		return err;

	user_access_begin();
	unsafe_put_user(signo, &infop->si_signo, Efault);
	unsafe_put_user(0, &infop->si_errno, Efault);
	unsafe_put_user(info.cause, &infop->si_code, Efault);
	unsafe_put_user(info.pid, &infop->si_pid, Efault);
	unsafe_put_user(info.uid, &infop->si_uid, Efault);
	unsafe_put_user(info.status, &infop->si_status, Efault);
	user_access_end();
	return err;
Efault:
	user_access_end();
	return -EFAULT;
}
",180915.0,C,"
","	}
	if (!err) {
",,"@@ -1600,12 +1600,10 @@ SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
 	struct waitid_info info = {.status = 0};
 	long err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);
 	int signo = 0;
+
 	if (err > 0) {
 		signo = SIGCHLD;
 		err = 0;
-	}
-
-	if (!err) {
 		if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
 			return -EFAULT;
 	}
@@ -1723,16 +1721,15 @@ COMPAT_SYSCALL_DEFINE5(waitid,
 	if (err > 0) {
 		signo = SIGCHLD;
 		err = 0;
-	}
-
-	if (!err && uru) {
-		/* kernel_waitid() overwrites everything in ru */
-		if (COMPAT_USE_64BIT_TIME)
-			err = copy_to_user(uru, &ru, sizeof(ru));
-		else
-			err = put_compat_rusage(&ru, uru);
-		if (err)
-			return -EFAULT;
+		if (uru) {
+			/* kernel_waitid() overwrites everything in ru */
+			if (COMPAT_USE_64BIT_TIME)
+				err = copy_to_user(uru, &ru, sizeof(ru));
+			else
+				err = put_compat_rusage(&ru, uru);
+			if (err)
+				return -EFAULT;
+		}
 	}
 
 	if (!infop)","SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
infop, int, options, struct rusage __user *, ru)
{
struct rusage r;
struct waitid_info info = {.status = 0};
long err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);
int signo = 0;
if (err > 0) {
signo = SIGCHLD;
err = 0;
	}
	if (!err) {
if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
return -EFAULT;
}
if (!infop)
return err;

user_access_begin();
unsafe_put_user(signo, &infop->si_signo, Efault);
unsafe_put_user(0, &infop->si_errno, Efault);
unsafe_put_user(info.cause, &infop->si_code, Efault);
unsafe_put_user(info.pid, &infop->si_pid, Efault);
unsafe_put_user(info.uid, &infop->si_uid, Efault);
unsafe_put_user(info.status, &infop->si_status, Efault);
user_access_end();
return err;
Efault:
user_access_end();
return -EFAULT;
}
",linux,6c85501f2fabcfc4fc6ed976543d252c4eaf4be9,b776e4b1a990045a7c70798f1f353c3160c26594,1.0,"SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
		infop, int, options, struct rusage __user *, ru)
{
	struct rusage r;
 	struct waitid_info info = {.status = 0};
 	long err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);
 	int signo = 0;
//fix_flaw_line_below:
//
 	if (err > 0) {
 		signo = SIGCHLD;
 		err = 0;
//flaw_line_below:
	}
//flaw_line_below:

//flaw_line_below:
	if (!err) {
 		if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
 			return -EFAULT;
 	}
	if (!infop)
		return err;

	user_access_begin();
	unsafe_put_user(signo, &infop->si_signo, Efault);
	unsafe_put_user(0, &infop->si_errno, Efault);
	unsafe_put_user(info.cause, &infop->si_code, Efault);
	unsafe_put_user(info.pid, &infop->si_pid, Efault);
	unsafe_put_user(info.uid, &infop->si_uid, Efault);
	unsafe_put_user(info.status, &infop->si_status, Efault);
	user_access_end();
	return err;
Efault:
	user_access_end();
	return -EFAULT;
}
"
129,None,Local,Not required,Complete,CVE-2014-9888,https://www.cvedetails.com/cve/CVE-2014-9888/,CWE-264,Low,Complete,Complete,,2016-08-06,7.2,"arch/arm/mm/dma-mapping.c in the Linux kernel before 3.13 on ARM platforms, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not prevent executable DMA mappings, which might allow local users to gain privileges via a crafted application, aka Android internal bug 28803642 and Qualcomm internal bug CR642735.",2016-11-28,+Priv ,1.0,https://github.com/torvalds/linux/commit/0ea1ec713f04bdfac343c9702b21cd3a7c711826,0ea1ec713f04bdfac343c9702b21cd3a7c711826,"ARM: dma-mapping: don't allow DMA mappings to be marked executable

DMA mapping permissions were being derived from pgprot_kernel directly
without using PAGE_KERNEL.  This causes them to be marked with executable
permission, which is not what we want.  Fix this.

Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>",1.0,arch/arm/mm/dma-mapping.c,"{""sha"": ""57438506d52461aaac70c12f6cd9a2b4384b6e34"", ""filename"": ""arch/arm/mm/dma-mapping.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/0ea1ec713f04bdfac343c9702b21cd3a7c711826/arch/arm/mm/dma-mapping.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0ea1ec713f04bdfac343c9702b21cd3a7c711826/arch/arm/mm/dma-mapping.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/mm/dma-mapping.c?ref=0ea1ec713f04bdfac343c9702b21cd3a7c711826"", ""patch"": ""@@ -687,7 +687,7 @@ static void *__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n \t\t    gfp_t gfp, struct dma_attrs *attrs)\n {\n-\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n+\tpgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);\n \tvoid *memory;\n \n \tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n@@ -700,7 +700,7 @@ void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n static void *arm_coherent_dma_alloc(struct device *dev, size_t size,\n \tdma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)\n {\n-\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n+\tpgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);\n \tvoid *memory;\n \n \tif (dma_alloc_from_coherent(dev, size, handle, &memory))""}","	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);",3," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, false,
			   __builtin_return_address(0));
}
"," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, false,
			   __builtin_return_address(0));
}
",180750.0,C,"	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
","	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
",,"@@ -687,7 +687,7 @@ static void *__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
-	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
+	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
@@ -700,7 +700,7 @@ void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
 	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
 {
-	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
+	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))","void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
void *memory;

if (dma_alloc_from_coherent(dev, size, handle, &memory))
return memory;

return __dma_alloc(dev, size, handle, gfp, prot, false,
__builtin_return_address(0));
}
",linux,0ea1ec713f04bdfac343c9702b21cd3a7c711826,59fd3033b55642da97b4ecde0c85de78d7229675,1.0," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
//flaw_line_below:
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
//fix_flaw_line_below:
//	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, false,
			   __builtin_return_address(0));
}
"
130,None,Remote,Not required,Partial,CVE-2010-2500,https://www.cvedetails.com/cve/CVE-2010-2500/,CWE-189,Medium,Partial,Partial,,2010-08-19,6.8,Integer overflow in the gray_render_span function in smooth/ftgrays.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.,2012-12-18,DoS Exec Code Overflow,1.0,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=6305b869d86ff415a33576df6d43729673c66eee,6305b869d86ff415a33576df6d43729673c66eee,,1.0,,,      p += ( map->rows - 1 ) * map->pitch;,12,"  gray_render_span( int             y,
                    int             count,
                    const FT_Span*  spans,
                    PWorker         worker )
  {
    unsigned char*  p;
    FT_Bitmap*      map = &worker->target;


     /* first of all, compute the scanline offset */
     p = (unsigned char*)map->buffer - y * map->pitch;
     if ( map->pitch >= 0 )
      p += (unsigned)( ( map->rows - 1 ) * map->pitch );
 
     for ( ; count > 0; count--, spans++ )
     {
      unsigned char  coverage = spans->coverage;


      if ( coverage )
      {
        /* For small-spans it is faster to do it by ourselves than
         * calling `memset'.  This is mainly due to the cost of the
         * function call.
         */
        if ( spans->len >= 8 )
          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );
        else
        {
          unsigned char*  q = p + spans->x;


          switch ( spans->len )
          {
          case 7: *q++ = (unsigned char)coverage;
          case 6: *q++ = (unsigned char)coverage;
          case 5: *q++ = (unsigned char)coverage;
          case 4: *q++ = (unsigned char)coverage;
          case 3: *q++ = (unsigned char)coverage;
          case 2: *q++ = (unsigned char)coverage;
          case 1: *q   = (unsigned char)coverage;
          default:
            ;
          }
        }
      }
    }
  }
","  gray_render_span( int             y,
                    int             count,
                    const FT_Span*  spans,
                    PWorker         worker )
  {
    unsigned char*  p;
    FT_Bitmap*      map = &worker->target;


     /* first of all, compute the scanline offset */
     p = (unsigned char*)map->buffer - y * map->pitch;
     if ( map->pitch >= 0 )
      p += ( map->rows - 1 ) * map->pitch;
 
     for ( ; count > 0; count--, spans++ )
     {
      unsigned char  coverage = spans->coverage;


      if ( coverage )
      {
        /* For small-spans it is faster to do it by ourselves than
         * calling `memset'.  This is mainly due to the cost of the
         * function call.
         */
        if ( spans->len >= 8 )
          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );
        else
        {
          unsigned char*  q = p + spans->x;


          switch ( spans->len )
          {
          case 7: *q++ = (unsigned char)coverage;
          case 6: *q++ = (unsigned char)coverage;
          case 5: *q++ = (unsigned char)coverage;
          case 4: *q++ = (unsigned char)coverage;
          case 3: *q++ = (unsigned char)coverage;
          case 2: *q++ = (unsigned char)coverage;
          case 1: *q   = (unsigned char)coverage;
          default:
            ;
          }
        }
      }
    }
  }
",178176.0,C,"      p += (unsigned)( ( map->rows - 1 ) * map->pitch );
","      p += ( map->rows - 1 ) * map->pitch;
",0ae6cf214ff1eec6499c347726a18b8a9809ab2c,"@@ -1186,7 +1186,7 @@
     /* first of all, compute the scanline offset */
     p = (unsigned char*)map->buffer - y * map->pitch;
     if ( map->pitch >= 0 )
-      p += ( map->rows - 1 ) * map->pitch;
+      p += (unsigned)( ( map->rows - 1 ) * map->pitch );
 
     for ( ; count > 0; count--, spans++ )
     {","gray_render_span( int             y,
int             count,
const FT_Span*  spans,
PWorker         worker )
{
unsigned char*  p;
FT_Bitmap*      map = &worker->target;


/* first of all, compute the scanline offset */
p = (unsigned char*)map->buffer - y * map->pitch;
if ( map->pitch >= 0 )
      p += ( map->rows - 1 ) * map->pitch;

for ( ; count > 0; count--, spans++ )
{
unsigned char  coverage = spans->coverage;


if ( coverage )
{
/* For small-spans it is faster to do it by ourselves than
* calling `memset'.  This is mainly due to the cost of the
* function call.
*/
if ( spans->len >= 8 )
FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );
else
{
unsigned char*  q = p + spans->x;


switch ( spans->len )
{
case 7: *q++ = (unsigned char)coverage;
case 6: *q++ = (unsigned char)coverage;
case 5: *q++ = (unsigned char)coverage;
case 4: *q++ = (unsigned char)coverage;
case 3: *q++ = (unsigned char)coverage;
case 2: *q++ = (unsigned char)coverage;
case 1: *q   = (unsigned char)coverage;
default:
;
}
}
}
}
}
",savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/smooth/ftgrays.c?id=6305b869d86ff415a33576df6d43729673c66eee,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/smooth/ftgrays.c?id=0ae6cf214ff1eec6499c347726a18b8a9809ab2c,1.0,"  gray_render_span( int             y,
                    int             count,
                    const FT_Span*  spans,
                    PWorker         worker )
  {
    unsigned char*  p;
    FT_Bitmap*      map = &worker->target;


     /* first of all, compute the scanline offset */
     p = (unsigned char*)map->buffer - y * map->pitch;
     if ( map->pitch >= 0 )
//flaw_line_below:
      p += ( map->rows - 1 ) * map->pitch;
//fix_flaw_line_below:
//      p += (unsigned)( ( map->rows - 1 ) * map->pitch );
 
     for ( ; count > 0; count--, spans++ )
     {
      unsigned char  coverage = spans->coverage;


      if ( coverage )
      {
        /* For small-spans it is faster to do it by ourselves than
         * calling `memset'.  This is mainly due to the cost of the
         * function call.
         */
        if ( spans->len >= 8 )
          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );
        else
        {
          unsigned char*  q = p + spans->x;


          switch ( spans->len )
          {
          case 7: *q++ = (unsigned char)coverage;
          case 6: *q++ = (unsigned char)coverage;
          case 5: *q++ = (unsigned char)coverage;
          case 4: *q++ = (unsigned char)coverage;
          case 3: *q++ = (unsigned char)coverage;
          case 2: *q++ = (unsigned char)coverage;
          case 1: *q   = (unsigned char)coverage;
          default:
            ;
          }
        }
      }
    }
  }
"
153,None,Remote,Not required,Partial,CVE-2018-14357,https://www.cvedetails.com/cve/CVE-2018-14357/,CWE-77,Low,Partial,Partial,,2018-07-17,7.5,"An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with an automatic subscription.",2019-10-02,Exec Code ,5.0,https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725,e52393740334443ae0206cab2d7caef381646725,"quote imap strings more carefully

Co-authored-by: JerikoOne <jeriko.one@gmx.us>",5.0,imap/imap.c,"{""sha"": ""0f4445b4532660e17f18a935fdacd4f492438dcf"", ""filename"": ""imap/auth_login.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/auth_login.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/auth_login.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/auth_login.c?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -65,8 +65,8 @@ enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n \n   mutt_message(_(\""Logging in...\""));\n \n-  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n-  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n+  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);\n+  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);\n \n   /* don't print the password unless we're at the ungodly debugging level\n    * of 5 or higher */""}<_**next**_>{""sha"": ""859f98727c8da58fba14c54beb6c132b8a20df85"", ""filename"": ""imap/command.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/command.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/command.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/command.c?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -499,7 +499,7 @@ static void cmd_parse_lsub(struct ImapData *idata, char *s)\n   mutt_str_strfcpy(buf, \""mailboxes \\\""\"", sizeof(buf));\n   mutt_account_tourl(&idata->conn->account, &url);\n   /* escape \\ and \"" */\n-  imap_quote_string(errstr, sizeof(errstr), list.name);\n+  imap_quote_string(errstr, sizeof(errstr), list.name, true);\n   url.path = errstr + 1;\n   url.path[strlen(url.path) - 1] = '\\0';\n   if (mutt_str_strcmp(url.user, ImapUser) == 0)""}<_**next**_>{""sha"": ""40f620a2e2bf91b34edf289784e01867ef78d830"", ""filename"": ""imap/imap.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/imap.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/imap.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/imap.c?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -464,25 +464,25 @@ static int compile_search(struct Context *ctx, const struct Pattern *pat, struct\n           return -1;\n         }\n         *delim = '\\0';\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         mutt_buffer_addch(buf, ' ');\n \n         /* and field */\n         *delim = ':';\n         delim++;\n         SKIPWS(delim);\n-        imap_quote_string(term, sizeof(term), delim);\n+        imap_quote_string(term, sizeof(term), delim, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_BODY:\n         mutt_buffer_addstr(buf, \""BODY \"");\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_WHOLE_MSG:\n         mutt_buffer_addstr(buf, \""TEXT \"");\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_SERVERSEARCH:\n@@ -495,7 +495,7 @@ static int compile_search(struct Context *ctx, const struct Pattern *pat, struct\n         }\n       }\n         mutt_buffer_addstr(buf, \""X-GM-RAW \"");\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n     }""}<_**next**_>{""sha"": ""278d4a2b13793faf7af21ea24ea6262dab32939e"", ""filename"": ""imap/imap_private.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/imap_private.h"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/imap_private.h"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/imap_private.h?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -328,7 +328,7 @@ char *imap_get_qualifier(char *buf);\n int imap_mxcmp(const char *mx1, const char *mx2);\n char *imap_next_word(char *s);\n void imap_qualify_path(char *dest, size_t len, struct ImapMbox *mx, char *path);\n-void imap_quote_string(char *dest, size_t dlen, const char *src);\n+void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick);\n void imap_unquote_string(char *s);\n void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src);\n void imap_unmunge_mbox_name(struct ImapData *idata, char *s);""}<_**next**_>{""sha"": ""614d87a5612d6769d9fdc27eb4d9557921842600"", ""filename"": ""imap/util.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/util.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/util.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/util.c?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -798,9 +798,12 @@ void imap_qualify_path(char *dest, size_t len, struct ImapMbox *mx, char *path)\n  *\n  * Surround string with quotes, escape \"" and \\ with backslash\n  */\n-void imap_quote_string(char *dest, size_t dlen, const char *src)\n+void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n {\n-  static const char quote[] = \""\\\""\\\\\"";\n+  const char *quote = \""`\\\""\\\\\"";\n+  if (!quote_backtick)\n+    quote++;\n+\n   char *pt = dest;\n   const char *s = src;\n \n@@ -874,7 +877,7 @@ void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const\n   char *buf = mutt_str_strdup(src);\n   imap_utf_encode(idata, &buf);\n \n-  imap_quote_string(dest, dlen, buf);\n+  imap_quote_string(dest, dlen, buf, false);\n \n   FREE(&buf);\n }""}","        imap_quote_string(term, sizeof(term), pat->p.str);/~/        imap_quote_string(term, sizeof(term), delim);/~/        imap_quote_string(term, sizeof(term), pat->p.str);/~/        imap_quote_string(term, sizeof(term), pat->p.str);/~/        imap_quote_string(term, sizeof(term), pat->p.str);","57,65,70,75,88","static int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)
{
  if (do_search(pat, 0) == 0)
    return 0;

  if (pat->not)
    mutt_buffer_addstr(buf, ""NOT "");

  if (pat->child)
  {
    int clauses;

    clauses = do_search(pat->child, 1);
    if (clauses > 0)
    {
      const struct Pattern *clause = pat->child;

      mutt_buffer_addch(buf, '(');

      while (clauses)
      {
        if (do_search(clause, 0))
        {
          if (pat->op == MUTT_OR && clauses > 1)
            mutt_buffer_addstr(buf, ""OR "");
          clauses--;

          if (compile_search(ctx, clause, buf) < 0)
            return -1;

          if (clauses)
            mutt_buffer_addch(buf, ' ');
        }
        clause = clause->next;
      }

      mutt_buffer_addch(buf, ')');
    }
  }
  else
  {
    char term[STRING];
    char *delim = NULL;

    switch (pat->op)
    {
      case MUTT_HEADER:
        mutt_buffer_addstr(buf, ""HEADER "");

        /* extract header name */
        delim = strchr(pat->p.str, ':');
        if (!delim)
        {
          mutt_error(_(""Header search without header name: %s""), pat->p.str);
           return -1;
         }
         *delim = '\0';
        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         mutt_buffer_addch(buf, ' ');
 
         /* and field */
         *delim = ':';
         delim++;
         SKIPWS(delim);
        imap_quote_string(term, sizeof(term), delim, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_BODY:
         mutt_buffer_addstr(buf, ""BODY "");
        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_WHOLE_MSG:
         mutt_buffer_addstr(buf, ""TEXT "");
        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_SERVERSEARCH:
      {
        struct ImapData *idata = ctx->data;
        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))
        {
          mutt_error(_(""Server-side custom search not supported: %s""), pat->p.str);
          return -1;
         }
       }
         mutt_buffer_addstr(buf, ""X-GM-RAW "");
        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
     }
  }

  return 0;
}
","static int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)
{
  if (do_search(pat, 0) == 0)
    return 0;

  if (pat->not)
    mutt_buffer_addstr(buf, ""NOT "");

  if (pat->child)
  {
    int clauses;

    clauses = do_search(pat->child, 1);
    if (clauses > 0)
    {
      const struct Pattern *clause = pat->child;

      mutt_buffer_addch(buf, '(');

      while (clauses)
      {
        if (do_search(clause, 0))
        {
          if (pat->op == MUTT_OR && clauses > 1)
            mutt_buffer_addstr(buf, ""OR "");
          clauses--;

          if (compile_search(ctx, clause, buf) < 0)
            return -1;

          if (clauses)
            mutt_buffer_addch(buf, ' ');
        }
        clause = clause->next;
      }

      mutt_buffer_addch(buf, ')');
    }
  }
  else
  {
    char term[STRING];
    char *delim = NULL;

    switch (pat->op)
    {
      case MUTT_HEADER:
        mutt_buffer_addstr(buf, ""HEADER "");

        /* extract header name */
        delim = strchr(pat->p.str, ':');
        if (!delim)
        {
          mutt_error(_(""Header search without header name: %s""), pat->p.str);
           return -1;
         }
         *delim = '\0';
        imap_quote_string(term, sizeof(term), pat->p.str);
         mutt_buffer_addstr(buf, term);
         mutt_buffer_addch(buf, ' ');
 
         /* and field */
         *delim = ':';
         delim++;
         SKIPWS(delim);
        imap_quote_string(term, sizeof(term), delim);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_BODY:
         mutt_buffer_addstr(buf, ""BODY "");
        imap_quote_string(term, sizeof(term), pat->p.str);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_WHOLE_MSG:
         mutt_buffer_addstr(buf, ""TEXT "");
        imap_quote_string(term, sizeof(term), pat->p.str);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_SERVERSEARCH:
      {
        struct ImapData *idata = ctx->data;
        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))
        {
          mutt_error(_(""Server-side custom search not supported: %s""), pat->p.str);
          return -1;
         }
       }
         mutt_buffer_addstr(buf, ""X-GM-RAW "");
        imap_quote_string(term, sizeof(term), pat->p.str);
         mutt_buffer_addstr(buf, term);
         break;
     }
  }

  return 0;
}
",182307.0,C,"        imap_quote_string(term, sizeof(term), pat->p.str, false);
        imap_quote_string(term, sizeof(term), delim, false);
        imap_quote_string(term, sizeof(term), pat->p.str, false);
        imap_quote_string(term, sizeof(term), pat->p.str, false);
        imap_quote_string(term, sizeof(term), pat->p.str, false);
","        imap_quote_string(term, sizeof(term), pat->p.str);
        imap_quote_string(term, sizeof(term), delim);
        imap_quote_string(term, sizeof(term), pat->p.str);
        imap_quote_string(term, sizeof(term), pat->p.str);
        imap_quote_string(term, sizeof(term), pat->p.str);
",,"@@ -464,25 +464,25 @@ static int compile_search(struct Context *ctx, const struct Pattern *pat, struct
           return -1;
         }
         *delim = '\0';
-        imap_quote_string(term, sizeof(term), pat->p.str);
+        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         mutt_buffer_addch(buf, ' ');
 
         /* and field */
         *delim = ':';
         delim++;
         SKIPWS(delim);
-        imap_quote_string(term, sizeof(term), delim);
+        imap_quote_string(term, sizeof(term), delim, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_BODY:
         mutt_buffer_addstr(buf, ""BODY "");
-        imap_quote_string(term, sizeof(term), pat->p.str);
+        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_WHOLE_MSG:
         mutt_buffer_addstr(buf, ""TEXT "");
-        imap_quote_string(term, sizeof(term), pat->p.str);
+        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_SERVERSEARCH:
@@ -495,7 +495,7 @@ static int compile_search(struct Context *ctx, const struct Pattern *pat, struct
         }
       }
         mutt_buffer_addstr(buf, ""X-GM-RAW "");
-        imap_quote_string(term, sizeof(term), pat->p.str);
+        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
     }","static int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)
{
if (do_search(pat, 0) == 0)
return 0;

if (pat->not)
mutt_buffer_addstr(buf, ""NOT "");

if (pat->child)
{
int clauses;

clauses = do_search(pat->child, 1);
if (clauses > 0)
{
const struct Pattern *clause = pat->child;

mutt_buffer_addch(buf, '(');

while (clauses)
{
if (do_search(clause, 0))
{
if (pat->op == MUTT_OR && clauses > 1)
mutt_buffer_addstr(buf, ""OR "");
clauses--;

if (compile_search(ctx, clause, buf) < 0)
return -1;

if (clauses)
mutt_buffer_addch(buf, ' ');
}
clause = clause->next;
}

mutt_buffer_addch(buf, ')');
}
}
else
{
char term[STRING];
char *delim = NULL;

switch (pat->op)
{
case MUTT_HEADER:
mutt_buffer_addstr(buf, ""HEADER "");

/* extract header name */
delim = strchr(pat->p.str, ':');
if (!delim)
{
mutt_error(_(""Header search without header name: %s""), pat->p.str);
return -1;
}
*delim = '\0';
        imap_quote_string(term, sizeof(term), pat->p.str);
mutt_buffer_addstr(buf, term);
mutt_buffer_addch(buf, ' ');

/* and field */
*delim = ':';
delim++;
SKIPWS(delim);
        imap_quote_string(term, sizeof(term), delim);
mutt_buffer_addstr(buf, term);
break;
case MUTT_BODY:
mutt_buffer_addstr(buf, ""BODY "");
        imap_quote_string(term, sizeof(term), pat->p.str);
mutt_buffer_addstr(buf, term);
break;
case MUTT_WHOLE_MSG:
mutt_buffer_addstr(buf, ""TEXT "");
        imap_quote_string(term, sizeof(term), pat->p.str);
mutt_buffer_addstr(buf, term);
break;
case MUTT_SERVERSEARCH:
{
struct ImapData *idata = ctx->data;
if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))
{
mutt_error(_(""Server-side custom search not supported: %s""), pat->p.str);
return -1;
}
}
mutt_buffer_addstr(buf, ""X-GM-RAW "");
        imap_quote_string(term, sizeof(term), pat->p.str);
mutt_buffer_addstr(buf, term);
break;
}
}

return 0;
}
",neomutt,e52393740334443ae0206cab2d7caef381646725,9bfab35522301794483f8f9ed60820bdec9be59e,1.0,"static int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)
{
  if (do_search(pat, 0) == 0)
    return 0;

  if (pat->not)
    mutt_buffer_addstr(buf, ""NOT "");

  if (pat->child)
  {
    int clauses;

    clauses = do_search(pat->child, 1);
    if (clauses > 0)
    {
      const struct Pattern *clause = pat->child;

      mutt_buffer_addch(buf, '(');

      while (clauses)
      {
        if (do_search(clause, 0))
        {
          if (pat->op == MUTT_OR && clauses > 1)
            mutt_buffer_addstr(buf, ""OR "");
          clauses--;

          if (compile_search(ctx, clause, buf) < 0)
            return -1;

          if (clauses)
            mutt_buffer_addch(buf, ' ');
        }
        clause = clause->next;
      }

      mutt_buffer_addch(buf, ')');
    }
  }
  else
  {
    char term[STRING];
    char *delim = NULL;

    switch (pat->op)
    {
      case MUTT_HEADER:
        mutt_buffer_addstr(buf, ""HEADER "");

        /* extract header name */
        delim = strchr(pat->p.str, ':');
        if (!delim)
        {
          mutt_error(_(""Header search without header name: %s""), pat->p.str);
           return -1;
         }
         *delim = '\0';
//flaw_line_below:
        imap_quote_string(term, sizeof(term), pat->p.str);
//fix_flaw_line_below:
//        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         mutt_buffer_addch(buf, ' ');
 
         /* and field */
         *delim = ':';
         delim++;
         SKIPWS(delim);
//flaw_line_below:
        imap_quote_string(term, sizeof(term), delim);
//fix_flaw_line_below:
//        imap_quote_string(term, sizeof(term), delim, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_BODY:
         mutt_buffer_addstr(buf, ""BODY "");
//flaw_line_below:
        imap_quote_string(term, sizeof(term), pat->p.str);
//fix_flaw_line_below:
//        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_WHOLE_MSG:
         mutt_buffer_addstr(buf, ""TEXT "");
//flaw_line_below:
        imap_quote_string(term, sizeof(term), pat->p.str);
//fix_flaw_line_below:
//        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_SERVERSEARCH:
      {
        struct ImapData *idata = ctx->data;
        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))
        {
          mutt_error(_(""Server-side custom search not supported: %s""), pat->p.str);
          return -1;
         }
       }
         mutt_buffer_addstr(buf, ""X-GM-RAW "");
//flaw_line_below:
        imap_quote_string(term, sizeof(term), pat->p.str);
//fix_flaw_line_below:
//        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
     }
  }

  return 0;
}
"
203,None,Remote,Not required,Partial,CVE-2012-4462,https://www.cvedetails.com/cve/CVE-2012-4462/,CWE-20,Medium,None,None,,2013-03-13,4.3,"aviary/jobcontrol.py in Condor, as used in Red Hat Enterprise MRG 2.3, when removing a job, allows remote attackers to cause a denial of service (condor_schedd restart) via square brackets in the cproc option.",2013-03-19,DoS,1.0,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=8f9b304c4f6c0a98dafa61b2c0e4beb3b70e4c84,8f9b304c4f6c0a98dafa61b2c0e4beb3b70e4c84,,1.0,,,       if (id.cluster < 0 || id.proc < 0) {,3," SchedulerObject::_continue(std::string key, std::string &/*reason*/, std::string &text)
 {
        PROC_ID id = getProcByString(key.c_str());
       if (id.cluster <= 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""Remove: Failed to parse id: %s\n"", key.c_str());
                text = ""Invalid Id"";
                return false;
	}

	scheduler.enqueueActOnJobMyself(id,JA_CONTINUE_JOBS,true);

	return true;
}
"," SchedulerObject::_continue(std::string key, std::string &/*reason*/, std::string &text)
 {
        PROC_ID id = getProcByString(key.c_str());
       if (id.cluster < 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""Remove: Failed to parse id: %s\n"", key.c_str());
                text = ""Invalid Id"";
                return false;
	}

	scheduler.enqueueActOnJobMyself(id,JA_CONTINUE_JOBS,true);

	return true;
}
",178003.0,CPP,"       if (id.cluster <= 0 || id.proc < 0) {
","       if (id.cluster < 0 || id.proc < 0) {
",95bcdf1d9a253d44a0bb9ab0d8c4743725c2b489,"@@ -263,7 +263,7 @@ SchedulerObject::setAttribute(std::string key,
                                                          std::string &text)
 {
        PROC_ID id = getProcByString(key.c_str());
-       if (id.cluster < 0 || id.proc < 0) {
+       if (id.cluster <= 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""SetAttribute: Failed to parse id: %s\n"", key.c_str());
                text = ""Invalid Id"";
                return false;
@@ -303,7 +303,7 @@ bool
 SchedulerObject::hold(std::string key, std::string &reason, std::string &text)
 {
        PROC_ID id = getProcByString(key.c_str());
-       if (id.cluster < 0 || id.proc < 0) {
+       if (id.cluster <= 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""Hold: Failed to parse id: %s\n"", key.c_str());
                text = ""Invalid Id"";
                return false;
@@ -329,7 +329,7 @@ bool
 SchedulerObject::release(std::string key, std::string &reason, std::string &text)
 {
        PROC_ID id = getProcByString(key.c_str());
-       if (id.cluster < 0 || id.proc < 0) {
+       if (id.cluster <= 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""Release: Failed to parse id: %s\n"", key.c_str());
                text = ""Invalid Id"";
                return false;
@@ -353,7 +353,7 @@ bool
 SchedulerObject::remove(std::string key, std::string &reason, std::string &text)
 {
        PROC_ID id = getProcByString(key.c_str());
-       if (id.cluster < 0 || id.proc < 0) {
+       if (id.cluster <= 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""Remove: Failed to parse id: %s\n"", key.c_str());
                text = ""Invalid Id"";
                return false;
@@ -375,7 +375,7 @@ bool
 SchedulerObject::suspend(std::string key, std::string &/*reason*/, std::string &text)
 {
        PROC_ID id = getProcByString(key.c_str());
-       if (id.cluster < 0 || id.proc < 0) {
+       if (id.cluster <= 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""Remove: Failed to parse id: %s\n"", key.c_str());
                text = ""Invalid Id"";
                return false;
@@ -390,7 +390,7 @@ bool
 SchedulerObject::_continue(std::string key, std::string &/*reason*/, std::string &text)
 {
        PROC_ID id = getProcByString(key.c_str());
-       if (id.cluster < 0 || id.proc < 0) {
+       if (id.cluster <= 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""Remove: Failed to parse id: %s\n"", key.c_str());
                text = ""Invalid Id"";
                return false;
","SchedulerObject::_continue(std::string key, std::string &/*reason*/, std::string &text)
{
PROC_ID id = getProcByString(key.c_str());
       if (id.cluster < 0 || id.proc < 0) {
dprintf(D_FULLDEBUG, ""Remove: Failed to parse id: %s\n"", key.c_str());
text = ""Invalid Id"";
return false;
}

scheduler.enqueueActOnJobMyself(id,JA_CONTINUE_JOBS,true);

return true;
}
",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_contrib/aviary/src/SchedulerObject.cpp;h=4d00667469e89dcb9149e22f2043289f4f16f91c;hb=8f9b304c4f6c0a98dafa61b2c0e4beb3b70e4c84,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_contrib/aviary/src/SchedulerObject.cpp;h=89d4a859b76cb70dd225dfa0dbeba110d30aae2c,1.0," SchedulerObject::_continue(std::string key, std::string &/*reason*/, std::string &text)
 {
        PROC_ID id = getProcByString(key.c_str());
//flaw_line_below:
       if (id.cluster < 0 || id.proc < 0) {
//fix_flaw_line_below:
//       if (id.cluster <= 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""Remove: Failed to parse id: %s\n"", key.c_str());
                text = ""Invalid Id"";
                return false;
	}

	scheduler.enqueueActOnJobMyself(id,JA_CONTINUE_JOBS,true);

	return true;
}
"
250,None,Remote,Not required,None,CVE-2018-6098,https://www.cvedetails.com/cve/CVE-2018-6098/,,Medium,None,Partial,,2018-12-04,4.3,Incorrect handling of confusable characters in URL Formatter in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to perform domain spoofing via IDN homographs via a crafted domain name.,2019-10-02,,4.0,https://github.com/chromium/chromium/commit/cc0bbcbe7c986094da8e58c37a21fdd179b686b0,cc0bbcbe7c986094da8e58c37a21fdd179b686b0,"Restrict Latin Small Letter Thorn (U+00FE) to Icelandic domains

This character () can be confused with both b and p when used in a domain
name. IDN spoof checker doesn't have a good way of flagging a character as
confusable with multiple characters, so it can't catch spoofs containing
this character. As a practical fix, this CL restricts this character to
domains under Iceland's ccTLD (.is). With this change, a domain name containing
"""" with a non-.is TLD will be displayed in punycode in the UI.

This change affects less than 10 real world domains with limited popularity.

Bug: 798892, 843352, 904327, 1017707
Change-Id: Ib07190dcde406bf62ce4413688a4fb4859a51030
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1879992
Commit-Queue: Mustafa Emre Acer <meacer@chromium.org>
Reviewed-by: Christopher Thompson <cthomp@chromium.org>
Cr-Commit-Position: refs/heads/master@{#709309}",5.0,components/url_formatter/url_formatter.cc,"{""sha"": ""25f95396c342a6aa01627ea474d7690c39a0f85f"", ""filename"": ""components/url_formatter/spoof_checks/idn_spoof_checker.cc"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 4, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/cc0bbcbe7c986094da8e58c37a21fdd179b686b0/components/url_formatter/spoof_checks/idn_spoof_checker.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cc0bbcbe7c986094da8e58c37a21fdd179b686b0/components/url_formatter/spoof_checks/idn_spoof_checker.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/url_formatter/spoof_checks/idn_spoof_checker.cc?ref=cc0bbcbe7c986094da8e58c37a21fdd179b686b0"", ""patch"": ""@@ -183,7 +183,7 @@ IDNSpoofChecker::IDNSpoofChecker() {\n \n   // Supplement the Unicode confusable list by the following mapping.\n   //   - {U+00E6 (\u00e6), U+04D5 (\u04d5)}  => \""ae\""\n-  //   - {U+00FE (\u00fe), U+03FC (\u03fc), U+048F (\u048f)} => p\n+  //   - {U+03FC (\u03fc), U+048F (\u048f)} => p\n   //   - {U+0127 (\u0127), U+043D (\u043d), U+045B (\u045b), U+04A3 (\u04a3), U+04A5 (\u04a5),\n   //      U+04C8 (\u04c8), U+04CA (\u04ca), U+050B (\u050b), U+0527 (\u0527), U+0529 (\u0529)} => h\n   //   - {U+0138 (\u0138), U+03BA (\u03ba), U+043A (\u043a), U+049B (\u049b), U+049D (\u049d),\n@@ -228,7 +228,7 @@ IDNSpoofChecker::IDNSpoofChecker() {\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\""ExtraConf\""),\n       icu::UnicodeString::fromUTF8(\n-          \""[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\""\n+          \""[\u00e6\u04d5] > ae; [\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\""\n           \""[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525\u0e01\u05d7] > n; \u0153 > ce;\""\n           \""[\u0167\u0442\u04ad\u050f\u4e03\u4e05\u4e06\u4e01] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\""\n           \""[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\""\n@@ -255,8 +255,9 @@ IDNSpoofChecker::~IDNSpoofChecker() {\n   uspoof_close(checker_);\n }\n \n-bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n-                                             bool is_tld_ascii) {\n+bool IDNSpoofChecker::SafeToDisplayAsUnicode(\n+    base::StringPiece16 label,\n+    base::StringPiece top_level_domain) {\n   UErrorCode status = U_ZERO_ERROR;\n   int32_t result =\n       uspoof_check(checker_, label.data(),\n@@ -283,6 +284,14 @@ bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n   if (deviation_characters_.containsSome(label_string))\n     return false;\n \n+  // Latin small letter thorn (U+00FE) can be used to spoof both b and p. It's\n+  // used in modern Icelandic orthography, so allow it for the Icelandic ccTLD\n+  // (.is) but block in any other TLD.\n+  if (label_string.length() > 1 && label_string.indexOf(\""\u00fe\"") != -1 &&\n+      top_level_domain != \"".is\"") {\n+    return false;\n+  }\n+\n   // If there's no script mixing, the input is regarded as safe without any\n   // extra check unless it falls into one of three categories:\n   //   - contains Kana letter exceptions\n@@ -300,6 +309,7 @@ bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n   if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n       kana_letters_exceptions_.containsNone(label_string) &&\n       combining_diacritics_exceptions_.containsNone(label_string)) {\n+    bool is_tld_ascii = !top_level_domain.starts_with(\"".xn--\"");\n     // Check Cyrillic confusable only for ASCII TLDs.\n     return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n   }""}<_**next**_>{""sha"": ""d91ea2fc3fd2734cfa1ba86c440ef0af322f8925"", ""filename"": ""components/url_formatter/spoof_checks/idn_spoof_checker.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/cc0bbcbe7c986094da8e58c37a21fdd179b686b0/components/url_formatter/spoof_checks/idn_spoof_checker.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cc0bbcbe7c986094da8e58c37a21fdd179b686b0/components/url_formatter/spoof_checks/idn_spoof_checker.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/url_formatter/spoof_checks/idn_spoof_checker.h?ref=cc0bbcbe7c986094da8e58c37a21fdd179b686b0"", ""patch"": ""@@ -61,7 +61,8 @@ class IDNSpoofChecker {\n   // Returns true if |label| is safe to display as Unicode. In the event of\n   // library failure, all IDN inputs will be treated as unsafe.\n   // See the function body for details on the specific safety checks performed.\n-  bool SafeToDisplayAsUnicode(base::StringPiece16 label, bool is_tld_ascii);\n+  bool SafeToDisplayAsUnicode(base::StringPiece16 label,\n+                              base::StringPiece top_level_domain);\n \n   // Returns the matching top domain if |hostname| or the last few components of\n   // |hostname| looks similar to one of top domains listed i""}<_**next**_>{""sha"": ""f02434c5ca003de12a3e403998635c3737405d93"", ""filename"": ""components/url_formatter/url_formatter.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 10, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/cc0bbcbe7c986094da8e58c37a21fdd179b686b0/components/url_formatter/url_formatter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cc0bbcbe7c986094da8e58c37a21fdd179b686b0/components/url_formatter/url_formatter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/url_formatter/url_formatter.cc?ref=cc0bbcbe7c986094da8e58c37a21fdd179b686b0"", ""patch"": ""@@ -33,7 +33,7 @@ IDNConversionResult IDNToUnicodeWithAdjustments(\n \n bool IDNToUnicodeOneComponent(const base::char16* comp,\n                               size_t comp_len,\n-                              bool is_tld_ascii,\n+                              base::StringPiece top_level_domain,\n                               bool enable_spoof_checks,\n                               base::string16* out,\n                               bool* has_idn_component);\n@@ -244,11 +244,10 @@ IDNConversionResult IDNToUnicodeWithAdjustmentsImpl(\n   input16.reserve(host.length());\n   input16.insert(input16.end(), host.begin(), host.end());\n \n-  bool is_tld_ascii = true;\n+  base::StringPiece top_level_domain;\n   size_t last_dot = host.rfind('.');\n-  if (last_dot != base::StringPiece::npos &&\n-      host.substr(last_dot).starts_with(\"".xn--\"")) {\n-    is_tld_ascii = false;\n+  if (last_dot != base::StringPiece::npos) {\n+    top_level_domain = host.substr(last_dot);\n   }\n \n   IDNConversionResult result;\n@@ -269,7 +268,7 @@ IDNConversionResult IDNToUnicodeWithAdjustmentsImpl(\n       // Add the substring that we just found.\n       bool has_idn_component = false;\n       converted_idn = IDNToUnicodeOneComponent(\n-          input16.data() + component_start, component_length, is_tld_ascii,\n+          input16.data() + component_start, component_length, top_level_domain,\n           enable_spoof_checks, &out16, &has_idn_component);\n       result.has_idn_component |= has_idn_component;\n     }\n@@ -319,8 +318,10 @@ IDNConversionResult UnsafeIDNToUnicodeWithAdjustments(\n // user. Note that this function does not deal with pure ASCII domain labels at\n // all even though it's possible to make up look-alike labels with ASCII\n // characters alone.\n-bool IsIDNComponentSafe(base::StringPiece16 label, bool is_tld_ascii) {\n-  return g_idn_spoof_checker.Get().SafeToDisplayAsUnicode(label, is_tld_ascii);\n+bool IsIDNComponentSafe(base::StringPiece16 label,\n+                        base::StringPiece top_level_domain) {\n+  return g_idn_spoof_checker.Get().SafeToDisplayAsUnicode(label,\n+                                                          top_level_domain);\n }\n \n // A wrapper to use LazyInstance<>::Leaky with ICU's UIDNA, a C pointer to\n@@ -372,7 +373,7 @@ base::LazyInstance<UIDNAWrapper>::Leaky g_uidna = LAZY_INSTANCE_INITIALIZER;\n // input has IDN, regardless of whether it was converted to unicode or not.\n bool IDNToUnicodeOneComponent(const base::char16* comp,\n                               size_t comp_len,\n-                              bool is_tld_ascii,\n+                              base::StringPiece top_level_domain,\n                               bool enable_spoof_checks,\n                               base::string16* out,\n                               bool* has_idn_component) {\n@@ -418,7 +419,7 @@ bool IDNToUnicodeOneComponent(const base::char16* comp,\n     if (IsIDNComponentSafe(\n             base::StringPiece16(out->data() + original_length,\n                                 base::checked_cast<size_t>(output_length)),\n-            is_tld_ascii)) {\n+            top_level_domain)) {\n       return true;\n     }\n   }""}","  bool is_tld_ascii = true;/~/  if (last_dot != base::StringPiece::npos &&/~/      host.substr(last_dot).starts_with("".xn--"")) {/~/    is_tld_ascii = false;/~/          input16.data() + component_start, component_length, is_tld_ascii,","11,13,14,15,36","IDNConversionResult IDNToUnicodeWithAdjustmentsImpl(
    base::StringPiece host,
    base::OffsetAdjuster::Adjustments* adjustments,
    bool enable_spoof_checks) {
  if (adjustments)
    adjustments->clear();
  base::string16 input16;
   input16.reserve(host.length());
   input16.insert(input16.end(), host.begin(), host.end());
 
  base::StringPiece top_level_domain;
   size_t last_dot = host.rfind('.');
  if (last_dot != base::StringPiece::npos) {
    top_level_domain = host.substr(last_dot);
   }
 
   IDNConversionResult result;
  base::string16 out16;
  for (size_t component_start = 0, component_end;
       component_start < input16.length();
       component_start = component_end + 1) {
    component_end = input16.find('.', component_start);
    if (component_end == base::string16::npos)
      component_end = input16.length();  // For getting the last component.
    size_t component_length = component_end - component_start;
    size_t new_component_start = out16.length();
    bool converted_idn = false;
    if (component_end > component_start) {
       bool has_idn_component = false;
       converted_idn = IDNToUnicodeOneComponent(
          input16.data() + component_start, component_length, top_level_domain,
           enable_spoof_checks, &out16, &has_idn_component);
       result.has_idn_component |= has_idn_component;
     }
    size_t new_component_length = out16.length() - new_component_start;

    if (converted_idn && adjustments) {
      adjustments->push_back(base::OffsetAdjuster::Adjustment(
          component_start, component_length, new_component_length));
    }

    if (component_end < input16.length())
      out16.push_back('.');
  }

  result.result = out16;

  if (result.has_idn_component) {
    result.matching_top_domain =
        g_idn_spoof_checker.Get().GetSimilarTopDomain(out16);
    if (enable_spoof_checks && !result.matching_top_domain.domain.empty()) {
      if (adjustments)
        adjustments->clear();
      result.result = input16;
    }
  }

  return result;
}
","IDNConversionResult IDNToUnicodeWithAdjustmentsImpl(
    base::StringPiece host,
    base::OffsetAdjuster::Adjustments* adjustments,
    bool enable_spoof_checks) {
  if (adjustments)
    adjustments->clear();
  base::string16 input16;
   input16.reserve(host.length());
   input16.insert(input16.end(), host.begin(), host.end());
 
  bool is_tld_ascii = true;
   size_t last_dot = host.rfind('.');
  if (last_dot != base::StringPiece::npos &&
      host.substr(last_dot).starts_with("".xn--"")) {
    is_tld_ascii = false;
   }
 
   IDNConversionResult result;
  base::string16 out16;
  for (size_t component_start = 0, component_end;
       component_start < input16.length();
       component_start = component_end + 1) {
    component_end = input16.find('.', component_start);
    if (component_end == base::string16::npos)
      component_end = input16.length();  // For getting the last component.
    size_t component_length = component_end - component_start;
    size_t new_component_start = out16.length();
    bool converted_idn = false;
    if (component_end > component_start) {
       bool has_idn_component = false;
       converted_idn = IDNToUnicodeOneComponent(
          input16.data() + component_start, component_length, is_tld_ascii,
           enable_spoof_checks, &out16, &has_idn_component);
       result.has_idn_component |= has_idn_component;
     }
    size_t new_component_length = out16.length() - new_component_start;

    if (converted_idn && adjustments) {
      adjustments->push_back(base::OffsetAdjuster::Adjustment(
          component_start, component_length, new_component_length));
    }

    if (component_end < input16.length())
      out16.push_back('.');
  }

  result.result = out16;

  if (result.has_idn_component) {
    result.matching_top_domain =
        g_idn_spoof_checker.Get().GetSimilarTopDomain(out16);
    if (enable_spoof_checks && !result.matching_top_domain.domain.empty()) {
      if (adjustments)
        adjustments->clear();
      result.result = input16;
    }
  }

  return result;
}
",186706.0,C,"  base::StringPiece top_level_domain;
  if (last_dot != base::StringPiece::npos) {
    top_level_domain = host.substr(last_dot);
          input16.data() + component_start, component_length, top_level_domain,
","  bool is_tld_ascii = true;
  if (last_dot != base::StringPiece::npos &&
      host.substr(last_dot).starts_with("".xn--"")) {
    is_tld_ascii = false;
          input16.data() + component_start, component_length, is_tld_ascii,
",,"@@ -33,7 +33,7 @@ IDNConversionResult IDNToUnicodeWithAdjustments(
 
 bool IDNToUnicodeOneComponent(const base::char16* comp,
                               size_t comp_len,
-                              bool is_tld_ascii,
+                              base::StringPiece top_level_domain,
                               bool enable_spoof_checks,
                               base::string16* out,
                               bool* has_idn_component);
@@ -244,11 +244,10 @@ IDNConversionResult IDNToUnicodeWithAdjustmentsImpl(
   input16.reserve(host.length());
   input16.insert(input16.end(), host.begin(), host.end());
 
-  bool is_tld_ascii = true;
+  base::StringPiece top_level_domain;
   size_t last_dot = host.rfind('.');
-  if (last_dot != base::StringPiece::npos &&
-      host.substr(last_dot).starts_with("".xn--"")) {
-    is_tld_ascii = false;
+  if (last_dot != base::StringPiece::npos) {
+    top_level_domain = host.substr(last_dot);
   }
 
   IDNConversionResult result;
@@ -269,7 +268,7 @@ IDNConversionResult IDNToUnicodeWithAdjustmentsImpl(
       // Add the substring that we just found.
       bool has_idn_component = false;
       converted_idn = IDNToUnicodeOneComponent(
-          input16.data() + component_start, component_length, is_tld_ascii,
+          input16.data() + component_start, component_length, top_level_domain,
           enable_spoof_checks, &out16, &has_idn_component);
       result.has_idn_component |= has_idn_component;
     }
@@ -319,8 +318,10 @@ IDNConversionResult UnsafeIDNToUnicodeWithAdjustments(
 // user. Note that this function does not deal with pure ASCII domain labels at
 // all even though it's possible to make up look-alike labels with ASCII
 // characters alone.
-bool IsIDNComponentSafe(base::StringPiece16 label, bool is_tld_ascii) {
-  return g_idn_spoof_checker.Get().SafeToDisplayAsUnicode(label, is_tld_ascii);
+bool IsIDNComponentSafe(base::StringPiece16 label,
+                        base::StringPiece top_level_domain) {
+  return g_idn_spoof_checker.Get().SafeToDisplayAsUnicode(label,
+                                                          top_level_domain);
 }
 
 // A wrapper to use LazyInstance<>::Leaky with ICU's UIDNA, a C pointer to
@@ -372,7 +373,7 @@ base::LazyInstance<UIDNAWrapper>::Leaky g_uidna = LAZY_INSTANCE_INITIALIZER;
 // input has IDN, regardless of whether it was converted to unicode or not.
 bool IDNToUnicodeOneComponent(const base::char16* comp,
                               size_t comp_len,
-                              bool is_tld_ascii,
+                              base::StringPiece top_level_domain,
                               bool enable_spoof_checks,
                               base::string16* out,
                               bool* has_idn_component) {
@@ -418,7 +419,7 @@ bool IDNToUnicodeOneComponent(const base::char16* comp,
     if (IsIDNComponentSafe(
             base::StringPiece16(out->data() + original_length,
                                 base::checked_cast<size_t>(output_length)),
-            is_tld_ascii)) {
+            top_level_domain)) {
       return true;
     }
   }","IDNConversionResult IDNToUnicodeWithAdjustmentsImpl(
base::StringPiece host,
base::OffsetAdjuster::Adjustments* adjustments,
bool enable_spoof_checks) {
if (adjustments)
adjustments->clear();
// Convert the ASCII input to a base::string16 for ICU.
base::string16 input16;
input16.reserve(host.length());
input16.insert(input16.end(), host.begin(), host.end());

  bool is_tld_ascii = true;
size_t last_dot = host.rfind('.');
  if (last_dot != base::StringPiece::npos &&
      host.substr(last_dot).starts_with("".xn--"")) {
    is_tld_ascii = false;
}

IDNConversionResult result;
// Do each component of the host separately, since we enforce script matching
// on a per-component basis.
base::string16 out16;
for (size_t component_start = 0, component_end;
component_start < input16.length();
component_start = component_end + 1) {
// Find the end of the component.
component_end = input16.find('.', component_start);
if (component_end == base::string16::npos)
component_end = input16.length();  // For getting the last component.
size_t component_length = component_end - component_start;
size_t new_component_start = out16.length();
bool converted_idn = false;
if (component_end > component_start) {
// Add the substring that we just found.
bool has_idn_component = false;
converted_idn = IDNToUnicodeOneComponent(
          input16.data() + component_start, component_length, is_tld_ascii,
enable_spoof_checks, &out16, &has_idn_component);
result.has_idn_component |= has_idn_component;
}
size_t new_component_length = out16.length() - new_component_start;

if (converted_idn && adjustments) {
adjustments->push_back(base::OffsetAdjuster::Adjustment(
component_start, component_length, new_component_length));
}

// Need to add the dot we just found (if we found one).
if (component_end < input16.length())
out16.push_back('.');
}

result.result = out16;

// Leave as punycode any inputs that spoof top domains.
if (result.has_idn_component) {
result.matching_top_domain =
g_idn_spoof_checker.Get().GetSimilarTopDomain(out16);
if (enable_spoof_checks && !result.matching_top_domain.domain.empty()) {
if (adjustments)
adjustments->clear();
result.result = input16;
}
}

return result;
}
",Chrome,cc0bbcbe7c986094da8e58c37a21fdd179b686b0,b608449af374c6433a8026b47b97c90c07a83850,1.0,"IDNConversionResult IDNToUnicodeWithAdjustmentsImpl(
    base::StringPiece host,
    base::OffsetAdjuster::Adjustments* adjustments,
    bool enable_spoof_checks) {
  if (adjustments)
    adjustments->clear();
  // Convert the ASCII input to a base::string16 for ICU.
  base::string16 input16;
   input16.reserve(host.length());
   input16.insert(input16.end(), host.begin(), host.end());
 
//flaw_line_below:
  bool is_tld_ascii = true;
//fix_flaw_line_below:
//  base::StringPiece top_level_domain;
   size_t last_dot = host.rfind('.');
//flaw_line_below:
  if (last_dot != base::StringPiece::npos &&
//flaw_line_below:
      host.substr(last_dot).starts_with("".xn--"")) {
//flaw_line_below:
    is_tld_ascii = false;
//fix_flaw_line_below:
//  if (last_dot != base::StringPiece::npos) {
//fix_flaw_line_below:
//    top_level_domain = host.substr(last_dot);
   }
 
   IDNConversionResult result;
  // Do each component of the host separately, since we enforce script matching
  // on a per-component basis.
  base::string16 out16;
  for (size_t component_start = 0, component_end;
       component_start < input16.length();
       component_start = component_end + 1) {
    // Find the end of the component.
    component_end = input16.find('.', component_start);
    if (component_end == base::string16::npos)
      component_end = input16.length();  // For getting the last component.
    size_t component_length = component_end - component_start;
    size_t new_component_start = out16.length();
    bool converted_idn = false;
    if (component_end > component_start) {
       // Add the substring that we just found.
       bool has_idn_component = false;
       converted_idn = IDNToUnicodeOneComponent(
//flaw_line_below:
          input16.data() + component_start, component_length, is_tld_ascii,
//fix_flaw_line_below:
//          input16.data() + component_start, component_length, top_level_domain,
           enable_spoof_checks, &out16, &has_idn_component);
       result.has_idn_component |= has_idn_component;
     }
    size_t new_component_length = out16.length() - new_component_start;

    if (converted_idn && adjustments) {
      adjustments->push_back(base::OffsetAdjuster::Adjustment(
          component_start, component_length, new_component_length));
    }

    // Need to add the dot we just found (if we found one).
    if (component_end < input16.length())
      out16.push_back('.');
  }

  result.result = out16;

  // Leave as punycode any inputs that spoof top domains.
  if (result.has_idn_component) {
    result.matching_top_domain =
        g_idn_spoof_checker.Get().GetSimilarTopDomain(out16);
    if (enable_spoof_checks && !result.matching_top_domain.domain.empty()) {
      if (adjustments)
        adjustments->clear();
      result.result = input16;
    }
  }

  return result;
}
"
278,None,Local,Not required,Partial,CVE-2017-18222,https://www.cvedetails.com/cve/CVE-2017-18222/,CWE-119,Low,Partial,Partial,,2018-03-08,4.6,"In the Linux kernel before 4.12, Hisilicon Network Subsystem (HNS) does not consider the ETH_SS_PRIV_FLAGS case when retrieving sset_count data, which allows local users to cause a denial of service (buffer overflow and memory corruption) or possibly have unspecified other impact, as demonstrated by incompatibility between hns_get_sset_count and ethtool_get_strings.",2018-05-23,DoS Overflow Mem. Corr. ,1.0,https://github.com/torvalds/linux/commit/412b65d15a7f8a93794653968308fc100f2aa87c,412b65d15a7f8a93794653968308fc100f2aa87c,"net: hns: fix ethtool_get_strings overflow in hns driver

hns_get_sset_count() returns HNS_NET_STATS_CNT and the data space allocated
is not enough for ethtool_get_strings(), which will cause random memory
corruption.

When SLAB and DEBUG_SLAB are both enabled, memory corruptions like the
the following can be observed without this patch:
[   43.115200] Slab corruption (Not tainted): Acpi-ParseExt start=ffff801fb0b69030, len=80
[   43.115206] Redzone: 0x9f911029d006462/0x5f78745f31657070.
[   43.115208] Last user: [<5f7272655f746b70>](0x5f7272655f746b70)
[   43.115214] 010: 70 70 65 31 5f 74 78 5f 70 6b 74 00 6b 6b 6b 6b  ppe1_tx_pkt.kkkk
[   43.115217] 030: 70 70 65 31 5f 74 78 5f 70 6b 74 5f 6f 6b 00 6b  ppe1_tx_pkt_ok.k
[   43.115218] Next obj: start=ffff801fb0b69098, len=80
[   43.115220] Redzone: 0x706d655f6f666966/0x9f911029d74e35b.
[   43.115229] Last user: [<ffff0000084b11b0>](acpi_os_release_object+0x28/0x38)
[   43.115231] 000: 74 79 00 6b 6b 6b 6b 6b 70 70 65 31 5f 74 78 5f  ty.kkkkkppe1_tx_
[   43.115232] 010: 70 6b 74 5f 65 72 72 5f 63 73 75 6d 5f 66 61 69  pkt_err_csum_fai

Signed-off-by: Timmy Li <lixiaoping3@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1.0,drivers/net/ethernet/hisilicon/hns/hns_dsaf_xgmac.c,"{""sha"": ""86944bc3b273fd97232a60e68f25046e68042882"", ""filename"": ""drivers/net/ethernet/hisilicon/hns/hns_dsaf_gmac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/412b65d15a7f8a93794653968308fc100f2aa87c/drivers/net/ethernet/hisilicon/hns/hns_dsaf_gmac.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/412b65d15a7f8a93794653968308fc100f2aa87c/drivers/net/ethernet/hisilicon/hns/hns_dsaf_gmac.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/hisilicon/hns/hns_dsaf_gmac.c?ref=412b65d15a7f8a93794653968308fc100f2aa87c"", ""patch"": ""@@ -666,7 +666,7 @@ static void hns_gmac_get_strings(u32 stringset, u8 *data)\n \n static int hns_gmac_get_sset_count(int stringset)\n {\n-\tif (stringset == ETH_SS_STATS)\n+\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n \t\treturn ARRAY_SIZE(g_gmac_stats_string);\n \n \treturn 0;""}<_**next**_>{""sha"": ""b62816c1574eb840f74a334b904f9fd993733116"", ""filename"": ""drivers/net/ethernet/hisilicon/hns/hns_dsaf_ppe.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/412b65d15a7f8a93794653968308fc100f2aa87c/drivers/net/ethernet/hisilicon/hns/hns_dsaf_ppe.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/412b65d15a7f8a93794653968308fc100f2aa87c/drivers/net/ethernet/hisilicon/hns/hns_dsaf_ppe.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/hisilicon/hns/hns_dsaf_ppe.c?ref=412b65d15a7f8a93794653968308fc100f2aa87c"", ""patch"": ""@@ -422,7 +422,7 @@ void hns_ppe_update_stats(struct hns_ppe_cb *ppe_cb)\n \n int hns_ppe_get_sset_count(int stringset)\n {\n-\tif (stringset == ETH_SS_STATS)\n+\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n \t\treturn ETH_PPE_STATIC_NUM;\n \treturn 0;\n }""}<_**next**_>{""sha"": ""6f3570cfb501604bea3f22d73374dd8dc28d756f"", ""filename"": ""drivers/net/ethernet/hisilicon/hns/hns_dsaf_rcb.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/412b65d15a7f8a93794653968308fc100f2aa87c/drivers/net/ethernet/hisilicon/hns/hns_dsaf_rcb.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/412b65d15a7f8a93794653968308fc100f2aa87c/drivers/net/ethernet/hisilicon/hns/hns_dsaf_rcb.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/hisilicon/hns/hns_dsaf_rcb.c?ref=412b65d15a7f8a93794653968308fc100f2aa87c"", ""patch"": ""@@ -876,7 +876,7 @@ void hns_rcb_get_stats(struct hnae_queue *queue, u64 *data)\n  */\n int hns_rcb_get_ring_sset_count(int stringset)\n {\n-\tif (stringset == ETH_SS_STATS)\n+\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n \t\treturn HNS_RING_STATIC_REG_NUM;\n \n \treturn 0;""}<_**next**_>{""sha"": ""51e7e9f5af4992b3a21f3cbfd4d27bed06d092e0"", ""filename"": ""drivers/net/ethernet/hisilicon/hns/hns_dsaf_xgmac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/412b65d15a7f8a93794653968308fc100f2aa87c/drivers/net/ethernet/hisilicon/hns/hns_dsaf_xgmac.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/412b65d15a7f8a93794653968308fc100f2aa87c/drivers/net/ethernet/hisilicon/hns/hns_dsaf_xgmac.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/hisilicon/hns/hns_dsaf_xgmac.c?ref=412b65d15a7f8a93794653968308fc100f2aa87c"", ""patch"": ""@@ -781,7 +781,7 @@ static void hns_xgmac_get_strings(u32 stringset, u8 *data)\n  */\n static int hns_xgmac_get_sset_count(int stringset)\n {\n-\tif (stringset == ETH_SS_STATS)\n+\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n \t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n \n \treturn 0;""}",	if (stringset == ETH_SS_STATS),2," static int hns_xgmac_get_sset_count(int stringset)
 {
	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
 		return ARRAY_SIZE(g_xgmac_stats_string);
 
 	return 0;
}
"," static int hns_xgmac_get_sset_count(int stringset)
 {
	if (stringset == ETH_SS_STATS)
 		return ARRAY_SIZE(g_xgmac_stats_string);
 
 	return 0;
}
",182573.0,C,"	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
","	if (stringset == ETH_SS_STATS)
",,"@@ -781,7 +781,7 @@ static void hns_xgmac_get_strings(u32 stringset, u8 *data)
  */
 static int hns_xgmac_get_sset_count(int stringset)
 {
-	if (stringset == ETH_SS_STATS)
+	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
 		return ARRAY_SIZE(g_xgmac_stats_string);
 
 	return 0;","static int hns_xgmac_get_sset_count(int stringset)
{
	if (stringset == ETH_SS_STATS)
return ARRAY_SIZE(g_xgmac_stats_string);

return 0;
}
",linux,412b65d15a7f8a93794653968308fc100f2aa87c,a9f11f963a546fea9144f6a6d1a307e814a387e7,1.0," static int hns_xgmac_get_sset_count(int stringset)
 {
//flaw_line_below:
	if (stringset == ETH_SS_STATS)
//fix_flaw_line_below:
//	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
 		return ARRAY_SIZE(g_xgmac_stats_string);
 
 	return 0;
}
"
287,None,Local,Not required,None,CVE-2017-1000380,https://www.cvedetails.com/cve/CVE-2017-1000380/,CWE-200,Low,Partial,None,,2017-06-17,2.1,"sound/core/timer.c in the Linux kernel before 4.11.5 is vulnerable to a data race in the ALSA /dev/snd/timer driver resulting in local users being able to read information belonging to other users, i.e., uninitialized memory contents may be disclosed when a read and an ioctl happen at the same time.",2017-12-05,+Info ,4.0,https://github.com/torvalds/linux/commit/d11662f4f798b50d8c8743f433842c3e40fe3378,d11662f4f798b50d8c8743f433842c3e40fe3378,"ALSA: timer: Fix race between read and ioctl

The read from ALSA timer device, the function snd_timer_user_tread(),
may access to an uninitialized struct snd_timer_user fields when the
read is concurrently performed while the ioctl like
snd_timer_user_tselect() is invoked.  We have already fixed the races
among ioctls via a mutex, but we seem to have forgotten the race
between read vs ioctl.

This patch simply applies (more exactly extends the already applied
range of) tu->ioctl_lock in snd_timer_user_tread() for closing the
race window.

Reported-by: Alexander Potapenko <glider@google.com>
Tested-by: Alexander Potapenko <glider@google.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>",2.0,sound/core/timer.c,"{""sha"": ""1118bd8e2d3c273376f7b795d26136af4881c17f"", ""filename"": ""sound/core/timer.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/d11662f4f798b50d8c8743f433842c3e40fe3378/sound/core/timer.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d11662f4f798b50d8c8743f433842c3e40fe3378/sound/core/timer.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/sound/core/timer.c?ref=d11662f4f798b50d8c8743f433842c3e40fe3378"", ""patch"": ""@@ -1959,6 +1959,7 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n \n \ttu = file->private_data;\n \tunit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);\n+\tmutex_lock(&tu->ioctl_lock);\n \tspin_lock_irq(&tu->qlock);\n \twhile ((long)count - result >= unit) {\n \t\twhile (!tu->qused) {\n@@ -1974,7 +1975,9 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n \t\t\tadd_wait_queue(&tu->qchange_sleep, &wait);\n \n \t\t\tspin_unlock_irq(&tu->qlock);\n+\t\t\tmutex_unlock(&tu->ioctl_lock);\n \t\t\tschedule();\n+\t\t\tmutex_lock(&tu->ioctl_lock);\n \t\t\tspin_lock_irq(&tu->qlock);\n \n \t\t\tremove_wait_queue(&tu->qchange_sleep, &wait);\n@@ -1994,7 +1997,6 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n \t\ttu->qused--;\n \t\tspin_unlock_irq(&tu->qlock);\n \n-\t\tmutex_lock(&tu->ioctl_lock);\n \t\tif (tu->tread) {\n \t\t\tif (copy_to_user(buffer, &tu->tqueue[qhead],\n \t\t\t\t\t sizeof(struct snd_timer_tread)))\n@@ -2004,7 +2006,6 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n \t\t\t\t\t sizeof(struct snd_timer_read)))\n \t\t\t\terr = -EFAULT;\n \t\t}\n-\t\tmutex_unlock(&tu->ioctl_lock);\n \n \t\tspin_lock_irq(&tu->qlock);\n \t\tif (err < 0)\n@@ -2014,6 +2015,7 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n \t}\n  _error:\n \tspin_unlock_irq(&tu->qlock);\n+\tmutex_unlock(&tu->ioctl_lock);\n \treturn result > 0 ? result : err;\n }\n ""}",		mutex_lock(&tu->ioctl_lock);/~/		mutex_unlock(&tu->ioctl_lock);,"45,55","static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
				   size_t count, loff_t *offset)
{
	struct snd_timer_user *tu;
	long result = 0, unit;
	int qhead;
	int err = 0;
 
 	tu = file->private_data;
 	unit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);
	mutex_lock(&tu->ioctl_lock);
 	spin_lock_irq(&tu->qlock);
 	while ((long)count - result >= unit) {
 		while (!tu->qused) {
			wait_queue_t wait;

			if ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {
				err = -EAGAIN;
				goto _error;
			}

			set_current_state(TASK_INTERRUPTIBLE);
			init_waitqueue_entry(&wait, current);
 			add_wait_queue(&tu->qchange_sleep, &wait);
 
 			spin_unlock_irq(&tu->qlock);
			mutex_unlock(&tu->ioctl_lock);
 			schedule();
			mutex_lock(&tu->ioctl_lock);
 			spin_lock_irq(&tu->qlock);
 
 			remove_wait_queue(&tu->qchange_sleep, &wait);

			if (tu->disconnected) {
				err = -ENODEV;
				goto _error;
			}
			if (signal_pending(current)) {
				err = -ERESTARTSYS;
				goto _error;
			}
		}

		qhead = tu->qhead++;
		tu->qhead %= tu->queue_size;
 		tu->qused--;
 		spin_unlock_irq(&tu->qlock);
 
 		if (tu->tread) {
 			if (copy_to_user(buffer, &tu->tqueue[qhead],
 					 sizeof(struct snd_timer_tread)))
				err = -EFAULT;
		} else {
			if (copy_to_user(buffer, &tu->queue[qhead],
 					 sizeof(struct snd_timer_read)))
 				err = -EFAULT;
 		}
 
 		spin_lock_irq(&tu->qlock);
 		if (err < 0)
			goto _error;
		result += unit;
		buffer += unit;
 	}
  _error:
 	spin_unlock_irq(&tu->qlock);
	mutex_unlock(&tu->ioctl_lock);
 	return result > 0 ? result : err;
 }
","static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
				   size_t count, loff_t *offset)
{
	struct snd_timer_user *tu;
	long result = 0, unit;
	int qhead;
	int err = 0;
 
 	tu = file->private_data;
 	unit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);
 	spin_lock_irq(&tu->qlock);
 	while ((long)count - result >= unit) {
 		while (!tu->qused) {
			wait_queue_t wait;

			if ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {
				err = -EAGAIN;
				goto _error;
			}

			set_current_state(TASK_INTERRUPTIBLE);
			init_waitqueue_entry(&wait, current);
 			add_wait_queue(&tu->qchange_sleep, &wait);
 
 			spin_unlock_irq(&tu->qlock);
 			schedule();
 			spin_lock_irq(&tu->qlock);
 
 			remove_wait_queue(&tu->qchange_sleep, &wait);

			if (tu->disconnected) {
				err = -ENODEV;
				goto _error;
			}
			if (signal_pending(current)) {
				err = -ERESTARTSYS;
				goto _error;
			}
		}

		qhead = tu->qhead++;
		tu->qhead %= tu->queue_size;
 		tu->qused--;
 		spin_unlock_irq(&tu->qlock);
 
		mutex_lock(&tu->ioctl_lock);
 		if (tu->tread) {
 			if (copy_to_user(buffer, &tu->tqueue[qhead],
 					 sizeof(struct snd_timer_tread)))
				err = -EFAULT;
		} else {
			if (copy_to_user(buffer, &tu->queue[qhead],
 					 sizeof(struct snd_timer_read)))
 				err = -EFAULT;
 		}
		mutex_unlock(&tu->ioctl_lock);
 
 		spin_lock_irq(&tu->qlock);
 		if (err < 0)
			goto _error;
		result += unit;
		buffer += unit;
 	}
  _error:
 	spin_unlock_irq(&tu->qlock);
 	return result > 0 ? result : err;
 }
",183180.0,C,"	mutex_lock(&tu->ioctl_lock);
			mutex_unlock(&tu->ioctl_lock);
			mutex_lock(&tu->ioctl_lock);
	mutex_unlock(&tu->ioctl_lock);
","		mutex_lock(&tu->ioctl_lock);
		mutex_unlock(&tu->ioctl_lock);
",,"@@ -1959,6 +1959,7 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 
 	tu = file->private_data;
 	unit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);
+	mutex_lock(&tu->ioctl_lock);
 	spin_lock_irq(&tu->qlock);
 	while ((long)count - result >= unit) {
 		while (!tu->qused) {
@@ -1974,7 +1975,9 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 			add_wait_queue(&tu->qchange_sleep, &wait);
 
 			spin_unlock_irq(&tu->qlock);
+			mutex_unlock(&tu->ioctl_lock);
 			schedule();
+			mutex_lock(&tu->ioctl_lock);
 			spin_lock_irq(&tu->qlock);
 
 			remove_wait_queue(&tu->qchange_sleep, &wait);
@@ -1994,7 +1997,6 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 		tu->qused--;
 		spin_unlock_irq(&tu->qlock);
 
-		mutex_lock(&tu->ioctl_lock);
 		if (tu->tread) {
 			if (copy_to_user(buffer, &tu->tqueue[qhead],
 					 sizeof(struct snd_timer_tread)))
@@ -2004,7 +2006,6 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 					 sizeof(struct snd_timer_read)))
 				err = -EFAULT;
 		}
-		mutex_unlock(&tu->ioctl_lock);
 
 		spin_lock_irq(&tu->qlock);
 		if (err < 0)
@@ -2014,6 +2015,7 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 	}
  _error:
 	spin_unlock_irq(&tu->qlock);
+	mutex_unlock(&tu->ioctl_lock);
 	return result > 0 ? result : err;
 }
 ","static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
size_t count, loff_t *offset)
{
struct snd_timer_user *tu;
long result = 0, unit;
int qhead;
int err = 0;

tu = file->private_data;
unit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);
spin_lock_irq(&tu->qlock);
while ((long)count - result >= unit) {
while (!tu->qused) {
wait_queue_t wait;

if ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {
err = -EAGAIN;
goto _error;
}

set_current_state(TASK_INTERRUPTIBLE);
init_waitqueue_entry(&wait, current);
add_wait_queue(&tu->qchange_sleep, &wait);

spin_unlock_irq(&tu->qlock);
schedule();
spin_lock_irq(&tu->qlock);

remove_wait_queue(&tu->qchange_sleep, &wait);

if (tu->disconnected) {
err = -ENODEV;
goto _error;
}
if (signal_pending(current)) {
err = -ERESTARTSYS;
goto _error;
}
}

qhead = tu->qhead++;
tu->qhead %= tu->queue_size;
tu->qused--;
spin_unlock_irq(&tu->qlock);

		mutex_lock(&tu->ioctl_lock);
if (tu->tread) {
if (copy_to_user(buffer, &tu->tqueue[qhead],
sizeof(struct snd_timer_tread)))
err = -EFAULT;
} else {
if (copy_to_user(buffer, &tu->queue[qhead],
sizeof(struct snd_timer_read)))
err = -EFAULT;
}
		mutex_unlock(&tu->ioctl_lock);

spin_lock_irq(&tu->qlock);
if (err < 0)
goto _error;
result += unit;
buffer += unit;
}
_error:
spin_unlock_irq(&tu->qlock);
return result > 0 ? result : err;
}
",linux,d11662f4f798b50d8c8743f433842c3e40fe3378,dd8038ec56c18680ddddf948247f53d427054f45,1.0,"static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
				   size_t count, loff_t *offset)
{
	struct snd_timer_user *tu;
	long result = 0, unit;
	int qhead;
	int err = 0;
 
 	tu = file->private_data;
 	unit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);
//fix_flaw_line_below:
//	mutex_lock(&tu->ioctl_lock);
 	spin_lock_irq(&tu->qlock);
 	while ((long)count - result >= unit) {
 		while (!tu->qused) {
			wait_queue_t wait;

			if ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {
				err = -EAGAIN;
				goto _error;
			}

			set_current_state(TASK_INTERRUPTIBLE);
			init_waitqueue_entry(&wait, current);
 			add_wait_queue(&tu->qchange_sleep, &wait);
 
 			spin_unlock_irq(&tu->qlock);
//fix_flaw_line_below:
//			mutex_unlock(&tu->ioctl_lock);
 			schedule();
//fix_flaw_line_below:
//			mutex_lock(&tu->ioctl_lock);
 			spin_lock_irq(&tu->qlock);
 
 			remove_wait_queue(&tu->qchange_sleep, &wait);

			if (tu->disconnected) {
				err = -ENODEV;
				goto _error;
			}
			if (signal_pending(current)) {
				err = -ERESTARTSYS;
				goto _error;
			}
		}

		qhead = tu->qhead++;
		tu->qhead %= tu->queue_size;
 		tu->qused--;
 		spin_unlock_irq(&tu->qlock);
 
//flaw_line_below:
		mutex_lock(&tu->ioctl_lock);
 		if (tu->tread) {
 			if (copy_to_user(buffer, &tu->tqueue[qhead],
 					 sizeof(struct snd_timer_tread)))
				err = -EFAULT;
		} else {
			if (copy_to_user(buffer, &tu->queue[qhead],
 					 sizeof(struct snd_timer_read)))
 				err = -EFAULT;
 		}
//flaw_line_below:
		mutex_unlock(&tu->ioctl_lock);
 
 		spin_lock_irq(&tu->qlock);
 		if (err < 0)
			goto _error;
		result += unit;
		buffer += unit;
 	}
  _error:
 	spin_unlock_irq(&tu->qlock);
//fix_flaw_line_below:
//	mutex_unlock(&tu->ioctl_lock);
 	return result > 0 ? result : err;
 }
"
291,,,,,,,,,,,,,,,2012-01,,7.0,https://github.com/chromium/chromium/commit/6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793,6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793,"Don't delete the current NavigationEntry when leaving an interstitial page.

BUG=107182
TEST=See bug

Review URL: http://codereview.chromium.org/8976014

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@115189 0039d316-1c4b-4281-b951-d872f2087c98",3.0,chrome/browser/safe_browsing/safe_browsing_blocking_page_unittest.cc,"{""sha"": ""feca3292c92d65297e9863f17892c60572fcb912"", ""filename"": ""chrome/browser/safe_browsing/safe_browsing_blocking_page.cc"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 6, ""changes"": 32, ""blob_url"": ""https://github.com/chromium/chromium/blob/6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793/chrome/browser/safe_browsing/safe_browsing_blocking_page.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793/chrome/browser/safe_browsing/safe_browsing_blocking_page.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/safe_browsing/safe_browsing_blocking_page.cc?ref=6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793"", ""patch"": ""@@ -457,8 +457,24 @@ void SafeBrowsingBlockingPage::CommandReceived(const std::string& cmd) {\n   }\n \n   if (command == kTakeMeBackCommand) {\n-    DontProceed();\n-    // We are deleted after this.\n+    if (is_main_frame_load_blocked_) {\n+      // If the load is blocked, we want to close the interstitial and discard\n+      // the pending entry.\n+      DontProceed();\n+      // We are deleted after this.\n+      return;\n+    }\n+\n+    // Otherwise the offending entry has committed, and we need to go back or\n+    // to a safe page.  We will close the interstitial when that page commits.\n+    if (tab()->controller().CanGoBack()) {\n+      tab()->controller().GoBack();\n+    } else {\n+      tab()->controller().LoadURL(GURL(chrome::kChromeUINewTabURL),\n+                                  content::Referrer(),\n+                                  content::PAGE_TRANSITION_START_PAGE,\n+                                  std::string());\n+    }\n     return;\n   }\n \n@@ -580,10 +596,14 @@ void SafeBrowsingBlockingPage::DontProceed() {\n \n   // We don't remove the navigation entry if the tab is being destroyed as this\n   // would trigger a navigation that would cause trouble as the render view host\n-  // for the tab has by then already been destroyed.\n-  if (navigation_entry_index_to_remove_ != -1 && !tab()->is_being_destroyed()) {\n-    tab()->controller().RemoveEntryAtIndex(navigation_entry_index_to_remove_,\n-                                           GURL(chrome::kChromeUINewTabURL));\n+  // for the tab has by then already been destroyed.  We also don't delete the\n+  // current entry if it has been committed again, which is possible on a page\n+  // that had a subresource warning.\n+  int last_committed_index = tab()->controller().last_committed_entry_index();\n+  if (navigation_entry_index_to_remove_ != -1 &&\n+      navigation_entry_index_to_remove_ != last_committed_index &&\n+      !tab()->is_being_destroyed()) {\n+    tab()->controller().RemoveEntryAtIndex(navigation_entry_index_to_remove_);\n     navigation_entry_index_to_remove_ = -1;\n   }\n   InterstitialPage::DontProceed();""}<_**next**_>{""sha"": ""b7e54d337f8c03030001080c4e577f624d99b099"", ""filename"": ""chrome/browser/safe_browsing/safe_browsing_blocking_page_test.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793/chrome/browser/safe_browsing/safe_browsing_blocking_page_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793/chrome/browser/safe_browsing/safe_browsing_blocking_page_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/safe_browsing/safe_browsing_blocking_page_test.cc?ref=6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793"", ""patch"": ""@@ -507,7 +507,13 @@ IN_PROC_BROWSER_TEST_F(SafeBrowsingBlockingPageTest, MalwareIframeDontProceed) {\n \n   ui_test_utils::NavigateToURL(browser(), url);\n \n+  ui_test_utils::WindowedNotificationObserver observer(\n+      content::NOTIFICATION_NAV_ENTRY_COMMITTED,\n+      content::Source<NavigationController>(\n+          &browser()->GetSelectedTabContentsWrapper()->tab_contents()->\n+              controller()));\n   SendCommand(\""\\\""takeMeBack\\\""\"");    // Simulate the user clicking \""back\""\n+  observer.Wait();\n   AssertNoInterstitial(false);  // Assert the interstitial is gone\n \n   EXPECT_EQ(GURL(chrome::kAboutBlankURL),    // Back to \""about:blank\""""}<_**next**_>{""sha"": ""37b1c2c6113ec5a420a82c0d8dcfa1814cf54bca"", ""filename"": ""chrome/browser/safe_browsing/safe_browsing_blocking_page_unittest.cc"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 9, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793/chrome/browser/safe_browsing/safe_browsing_blocking_page_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793/chrome/browser/safe_browsing/safe_browsing_blocking_page_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/safe_browsing/safe_browsing_blocking_page_unittest.cc?ref=6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793"", ""patch"": ""@@ -114,15 +114,17 @@ class SafeBrowsingBlockingPageTest : public ChromeRenderViewHostTestHarness,\n         content::PAGE_TRANSITION_TYPED);\n   }\n \n-  void GoBackCrossSite() {\n+  void GoBack(bool is_cross_site) {\n     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);\n     ASSERT_TRUE(entry);\n     contents()->controller().GoBack();\n \n-    // The navigation should commit in the pending RVH.\n-    contents()->TestDidNavigate(\n-        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),\n-        content::PAGE_TRANSITION_TYPED);\n+    // The pending RVH should commit for cross-site navigations.\n+    RenderViewHost* rvh = is_cross_site ?\n+        contents()->pending_rvh() :\n+        contents()->render_view_host();\n+    contents()->TestDidNavigate(rvh, entry->page_id(), GURL(entry->url()),\n+                                content::PAGE_TRANSITION_TYPED);\n   }\n \n   void ShowInterstitial(bool is_subresource, const char* url) {\n@@ -158,6 +160,15 @@ class SafeBrowsingBlockingPageTest : public ChromeRenderViewHostTestHarness,\n     MessageLoop::current()->RunAllPending();\n   }\n \n+  void DontProceedThroughSubresourceInterstitial(\n+      SafeBrowsingBlockingPage* sb_interstitial) {\n+    // CommandReceived(kTakeMeBackCommand) does a back navigation for\n+    // subresource interstitials.\n+    GoBack(false);\n+    // DontProceed() posts a task to update the SafeBrowsingService::Client.\n+    MessageLoop::current()->RunAllPending();\n+  }\n+\n   scoped_refptr<TestSafeBrowsingService> service_;\n \n  private:\n@@ -262,7 +273,7 @@ TEST_F(SafeBrowsingBlockingPageTest, PageWithMalwareResourceDontProceed) {\n   ASSERT_TRUE(sb_interstitial);\n \n   // Simulate the user clicking \""don't proceed\"".\n-  DontProceedThroughInterstitial(sb_interstitial);\n+  DontProceedThroughSubresourceInterstitial(sb_interstitial);\n   EXPECT_EQ(CANCEL, user_response());\n   EXPECT_FALSE(GetSafeBrowsingBlockingPage());\n \n@@ -333,7 +344,7 @@ TEST_F(SafeBrowsingBlockingPageTest,\n   ASSERT_TRUE(sb_interstitial);\n \n   // Simulate the user clicking \""don't proceed\"".\n-  DontProceedThroughInterstitial(sb_interstitial);\n+  DontProceedThroughSubresourceInterstitial(sb_interstitial);\n   EXPECT_EQ(CANCEL, user_response());\n   EXPECT_FALSE(GetSafeBrowsingBlockingPage());\n \n@@ -388,7 +399,7 @@ TEST_F(SafeBrowsingBlockingPageTest,\n   ASSERT_TRUE(sb_interstitial);\n \n   // Don't proceed through the 2nd interstitial.\n-  DontProceedThroughInterstitial(sb_interstitial);\n+  DontProceedThroughSubresourceInterstitial(sb_interstitial);\n   EXPECT_EQ(CANCEL, user_response());\n   EXPECT_FALSE(GetSafeBrowsingBlockingPage());\n \n@@ -473,7 +484,7 @@ TEST_F(SafeBrowsingBlockingPageTest, NavigatingBackAndForth) {\n   // Proceed, then navigate back.\n   ProceedThroughInterstitial(sb_interstitial);\n   Navigate(kBadURL, 2);  // Commit the navigation.\n-  GoBackCrossSite();\n+  GoBack(true);\n \n   // We are back on the good page.\n   sb_interstitial = GetSafeBrowsingBlockingPage();""}<_**next**_>{""sha"": ""a60cd99fb981e0168ab68d065dda9babdcc2a4c8"", ""filename"": ""content/browser/tab_contents/navigation_controller.cc"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 49, ""changes"": 70, ""blob_url"": ""https://github.com/chromium/chromium/blob/6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793/content/browser/tab_contents/navigation_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793/content/browser/tab_contents/navigation_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/tab_contents/navigation_controller.cc?ref=6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793"", ""patch"": ""@@ -359,13 +359,6 @@ void NavigationController::GoBack() {\n     return;\n   }\n \n-  // If an interstitial page is showing, going back is equivalent to hiding the\n-  // interstitial.\n-  if (tab_contents_->interstitial_page()) {\n-    tab_contents_->interstitial_page()->DontProceed();\n-    return;\n-  }\n-\n   // Base the navigation on where we are now...\n   int current_index = GetCurrentEntryIndex();\n \n@@ -385,14 +378,6 @@ void NavigationController::GoForward() {\n     return;\n   }\n \n-  // If an interstitial page is showing, the previous renderer is blocked and\n-  // cannot make new requests.  Unblock (and disable) it to allow this\n-  // navigation to succeed.  The interstitial will stay visible until the\n-  // resulting DidNavigate.\n-  if (tab_contents_->interstitial_page()) {\n-    tab_contents_->interstitial_page()->CancelForNavigation();\n-  }\n-\n   bool transient = (transient_entry_index_ != -1);\n \n   // Base the navigation on where we are now...\n@@ -430,21 +415,6 @@ void NavigationController::GoToIndex(int index) {\n     }\n   }\n \n-  // If an interstitial page is showing, the previous renderer is blocked and\n-  // cannot make new requests.\n-  if (tab_contents_->interstitial_page()) {\n-    if (index == GetCurrentEntryIndex() - 1) {\n-      // Going back one entry is equivalent to hiding the interstitial.\n-      tab_contents_->interstitial_page()->DontProceed();\n-      return;\n-    } else {\n-      // Unblock the renderer (and disable the interstitial) to allow this\n-      // navigation to succeed.  The interstitial will stay visible until the\n-      // resulting DidNavigate.\n-      tab_contents_->interstitial_page()->CancelForNavigation();\n-    }\n-  }\n-\n   DiscardNonCommittedEntries();\n \n   pending_entry_index_ = index;\n@@ -465,22 +435,11 @@ void NavigationController::GoToOffset(int offset) {\n   GoToIndex(index);\n }\n \n-void NavigationController::RemoveEntryAtIndex(int index,\n-                                              const GURL& default_url) {\n-  bool is_current = index == last_committed_entry_index_;\n+void NavigationController::RemoveEntryAtIndex(int index) {\n+  if (index == last_committed_entry_index_)\n+    return;\n+\n   RemoveEntryAtIndexInternal(index);\n-  if (is_current) {\n-    // We removed the currently shown entry, so we have to load something else.\n-    if (last_committed_entry_index_ != -1) {\n-      pending_entry_index_ = last_committed_entry_index_;\n-      NavigateToPendingEntry(NO_RELOAD);\n-    } else {\n-      // If there is nothing to show, show a default page.\n-      LoadURL(default_url.is_empty() ? GURL(\""about:blank\"") : default_url,\n-              content::Referrer(), content::PAGE_TRANSITION_START_PAGE,\n-              std::string());\n-    }\n-  }\n }\n \n void NavigationController::UpdateVirtualURLToURL(\n@@ -1074,13 +1033,12 @@ void NavigationController::PruneAllButActive() {\n \n void NavigationController::RemoveEntryAtIndexInternal(int index) {\n   DCHECK(index < entry_count());\n+  DCHECK(index != last_committed_entry_index_);\n \n   DiscardNonCommittedEntries();\n \n   entries_.erase(entries_.begin() + index);\n-  if (last_committed_entry_index_ == index)\n-    last_committed_entry_index_--;\n-  else if (last_committed_entry_index_ > index)\n+  if (last_committed_entry_index_ > index)\n     last_committed_entry_index_--;\n }\n \n@@ -1130,7 +1088,8 @@ void NavigationController::InsertOrReplaceEntry(NavigationEntry* entry,\n   }\n \n   if (entries_.size() >= max_entry_count()) {\n-    RemoveEntryAtIndex(0, GURL());\n+    DCHECK(last_committed_entry_index_ > 0);\n+    RemoveEntryAtIndex(0);\n     NotifyPrunedEntries(this, true, 1);\n   }\n \n@@ -1157,10 +1116,23 @@ void NavigationController::NavigateToPendingEntry(ReloadType reload_type) {\n       (entries_[pending_entry_index_]->transition_type() &\n           content::PAGE_TRANSITION_FORWARD_BACK)) {\n     tab_contents_->Stop();\n+\n+    // If an interstitial page is showing, we want to close it to get back\n+    // to what was showing before.\n+    if (tab_contents_->interstitial_page())\n+      tab_contents_->interstitial_page()->DontProceed();\n+\n     DiscardNonCommittedEntries();\n     return;\n   }\n \n+  // If an interstitial page is showing, the previous renderer is blocked and\n+  // cannot make new requests.  Unblock (and disable) it to allow this\n+  // navigation to succeed.  The interstitial will stay visible until the\n+  // resulting DidNavigate.\n+  if (tab_contents_->interstitial_page())\n+    tab_contents_->interstitial_page()->CancelForNavigation();\n+\n   // For session history navigations only the pending_entry_index_ is set.\n   if (!pending_entry_) {\n     DCHECK_NE(pending_entry_index_, -1);""}<_**next**_>{""sha"": ""aa4d8e0934ab0f3415a2c77be3ad583ad43c2222"", ""filename"": ""content/browser/tab_contents/navigation_controller.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793/content/browser/tab_contents/navigation_controller.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793/content/browser/tab_contents/navigation_controller.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/tab_contents/navigation_controller.h?ref=6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793"", ""patch"": ""@@ -233,10 +233,9 @@ class CONTENT_EXPORT NavigationController {\n   // Removing of entries -------------------------------------------------------\n \n   // Removes the entry at the specified |index|.  This call dicards any pending\n-  // and transient entries.  |default_url| is the URL that the navigation\n-  // controller navigates to if there are no more entries after the removal.\n-  // If |default_url| is empty, we default to \""about:blank\"".\n-  void RemoveEntryAtIndex(int index, const GURL& default_url);\n+  // and transient entries.  If the index is the last committed index, this does\n+  // nothing and returns false.\n+  void RemoveEntryAtIndex(int index);\n \n   // TabContents ---------------------------------------------------------------\n \n@@ -421,7 +420,7 @@ class CONTENT_EXPORT NavigationController {\n   // all entries after it. The new entry will become the active one.\n   void InsertOrReplaceEntry(NavigationEntry* entry, bool replace);\n \n-  // Removes the entry at |index|.\n+  // Removes the entry at |index|, as long as it is not the current entry.\n   void RemoveEntryAtIndexInternal(int index);\n \n   // Discards the pending and transient entries.""}<_**next**_>{""sha"": ""11cf628b1b72151b706e8147ae734cf141ca78b9"", ""filename"": ""content/browser/tab_contents/navigation_controller_unittest.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 29, ""changes"": 46, ""blob_url"": ""https://github.com/chromium/chromium/blob/6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793/content/browser/tab_contents/navigation_controller_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793/content/browser/tab_contents/navigation_controller_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/tab_contents/navigation_controller_unittest.cc?ref=6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793"", ""patch"": ""@@ -1652,44 +1652,32 @@ TEST_F(NavigationControllerTest, RemoveEntry) {\n       url5, content::Referrer(), content::PAGE_TRANSITION_TYPED, std::string());\n   rvh()->SendNavigate(4, url5);\n \n-  // Remove the last entry.\n-  controller().RemoveEntryAtIndex(\n-      controller().entry_count() - 1, default_url);\n+  // Try to remove the last entry.  Will fail because it is the current entry.\n+  controller().RemoveEntryAtIndex(controller().entry_count() - 1);\n+  EXPECT_EQ(5, controller().entry_count());\n+  EXPECT_EQ(4, controller().last_committed_entry_index());\n+\n+  // Go back and remove the last entry.\n+  controller().GoBack();\n+  rvh()->SendNavigate(3, url4);\n+  controller().RemoveEntryAtIndex(controller().entry_count() - 1);\n   EXPECT_EQ(4, controller().entry_count());\n   EXPECT_EQ(3, controller().last_committed_entry_index());\n-  NavigationEntry* pending_entry = controller().pending_entry();\n-  EXPECT_TRUE(pending_entry && pending_entry->url() == url4);\n+  EXPECT_FALSE(controller().pending_entry());\n \n-  // Add a pending entry.\n-  controller().LoadURL(pending_url, content::Referrer(),\n-                       content::PAGE_TRANSITION_TYPED, std::string());\n-  // Now remove the last entry.\n-  controller().RemoveEntryAtIndex(\n-      controller().entry_count() - 1, default_url);\n-  // The pending entry should have been discarded and the last committed entry\n-  // removed.\n+  // Remove an entry which is not the last committed one.\n+  controller().RemoveEntryAtIndex(0);\n   EXPECT_EQ(3, controller().entry_count());\n   EXPECT_EQ(2, controller().last_committed_entry_index());\n-  pending_entry = controller().pending_entry();\n-  EXPECT_TRUE(pending_entry && pending_entry->url() == url3);\n-\n-  // Remove an entry which is not the last committed one.\n-  controller().RemoveEntryAtIndex(0, default_url);\n-  EXPECT_EQ(2, controller().entry_count());\n-  EXPECT_EQ(1, controller().last_committed_entry_index());\n-  // No navigation should have been initiated since we did not remove the\n-  // current entry.\n   EXPECT_FALSE(controller().pending_entry());\n \n   // Remove the 2 remaining entries.\n-  controller().RemoveEntryAtIndex(1, default_url);\n-  controller().RemoveEntryAtIndex(0, default_url);\n+  controller().RemoveEntryAtIndex(1);\n+  controller().RemoveEntryAtIndex(0);\n \n-  // This should have created a pending default entry.\n-  EXPECT_EQ(0, controller().entry_count());\n-  EXPECT_EQ(-1, controller().last_committed_entry_index());\n-  pending_entry = controller().pending_entry();\n-  EXPECT_TRUE(pending_entry && pending_entry->url() == default_url);\n+  // This should leave us with only the last committed entry.\n+  EXPECT_EQ(1, controller().entry_count());\n+  EXPECT_EQ(0, controller().last_committed_entry_index());\n }\n \n // Tests the transient entry, making sure it goes away with all navigations.""}","    // The navigation should commit in the pending RVH./~/    contents()->TestDidNavigate(/~/        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),/~/        content::PAGE_TRANSITION_TYPED);","5,6,7,8","  void GoBackCrossSite() {
  void GoBack(bool is_cross_site) {
     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(entry);
     contents()->controller().GoBack();
 
    // The pending RVH should commit for cross-site navigations.
    RenderViewHost* rvh = is_cross_site ?
        contents()->pending_rvh() :
        contents()->render_view_host();
    contents()->TestDidNavigate(rvh, entry->page_id(), GURL(entry->url()),
                                content::PAGE_TRANSITION_TYPED);
   }
","  void GoBackCrossSite() {
     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(entry);
     contents()->controller().GoBack();
 
    contents()->TestDidNavigate(
        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
        content::PAGE_TRANSITION_TYPED);
   }
",184660.0,C,"  void GoBack(bool is_cross_site) {
    // The pending RVH should commit for cross-site navigations.
    RenderViewHost* rvh = is_cross_site ?
        contents()->pending_rvh() :
        contents()->render_view_host();
    contents()->TestDidNavigate(rvh, entry->page_id(), GURL(entry->url()),
                                content::PAGE_TRANSITION_TYPED);
","    contents()->TestDidNavigate(
        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
        content::PAGE_TRANSITION_TYPED);
",,"@@ -114,15 +114,17 @@ class SafeBrowsingBlockingPageTest : public ChromeRenderViewHostTestHarness,
         content::PAGE_TRANSITION_TYPED);
   }
 
-  void GoBackCrossSite() {
+  void GoBack(bool is_cross_site) {
     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(entry);
     contents()->controller().GoBack();
 
-    // The navigation should commit in the pending RVH.
-    contents()->TestDidNavigate(
-        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
-        content::PAGE_TRANSITION_TYPED);
+    // The pending RVH should commit for cross-site navigations.
+    RenderViewHost* rvh = is_cross_site ?
+        contents()->pending_rvh() :
+        contents()->render_view_host();
+    contents()->TestDidNavigate(rvh, entry->page_id(), GURL(entry->url()),
+                                content::PAGE_TRANSITION_TYPED);
   }
 
   void ShowInterstitial(bool is_subresource, const char* url) {
@@ -158,6 +160,15 @@ class SafeBrowsingBlockingPageTest : public ChromeRenderViewHostTestHarness,
     MessageLoop::current()->RunAllPending();
   }
 
+  void DontProceedThroughSubresourceInterstitial(
+      SafeBrowsingBlockingPage* sb_interstitial) {
+    // CommandReceived(kTakeMeBackCommand) does a back navigation for
+    // subresource interstitials.
+    GoBack(false);
+    // DontProceed() posts a task to update the SafeBrowsingService::Client.
+    MessageLoop::current()->RunAllPending();
+  }
+
   scoped_refptr<TestSafeBrowsingService> service_;
 
  private:
@@ -262,7 +273,7 @@ TEST_F(SafeBrowsingBlockingPageTest, PageWithMalwareResourceDontProceed) {
   ASSERT_TRUE(sb_interstitial);
 
   // Simulate the user clicking ""don't proceed"".
-  DontProceedThroughInterstitial(sb_interstitial);
+  DontProceedThroughSubresourceInterstitial(sb_interstitial);
   EXPECT_EQ(CANCEL, user_response());
   EXPECT_FALSE(GetSafeBrowsingBlockingPage());
 
@@ -333,7 +344,7 @@ TEST_F(SafeBrowsingBlockingPageTest,
   ASSERT_TRUE(sb_interstitial);
 
   // Simulate the user clicking ""don't proceed"".
-  DontProceedThroughInterstitial(sb_interstitial);
+  DontProceedThroughSubresourceInterstitial(sb_interstitial);
   EXPECT_EQ(CANCEL, user_response());
   EXPECT_FALSE(GetSafeBrowsingBlockingPage());
 
@@ -388,7 +399,7 @@ TEST_F(SafeBrowsingBlockingPageTest,
   ASSERT_TRUE(sb_interstitial);
 
   // Don't proceed through the 2nd interstitial.
-  DontProceedThroughInterstitial(sb_interstitial);
+  DontProceedThroughSubresourceInterstitial(sb_interstitial);
   EXPECT_EQ(CANCEL, user_response());
   EXPECT_FALSE(GetSafeBrowsingBlockingPage());
 
@@ -473,7 +484,7 @@ TEST_F(SafeBrowsingBlockingPageTest, NavigatingBackAndForth) {
   // Proceed, then navigate back.
   ProceedThroughInterstitial(sb_interstitial);
   Navigate(kBadURL, 2);  // Commit the navigation.
-  GoBackCrossSite();
+  GoBack(true);
 
   // We are back on the good page.
   sb_interstitial = GetSafeBrowsingBlockingPage();","void GoBackCrossSite() {
NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);
ASSERT_TRUE(entry);
contents()->controller().GoBack();

    // The navigation should commit in the pending RVH.
    contents()->TestDidNavigate(
        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
        content::PAGE_TRANSITION_TYPED);
}
",Chrome,6a13a6c2fbae0b3269743e6a141fdfe0d9ec9793,f8d74230b839def072f26049845bd9003d87eb26,1.0,"  void GoBackCrossSite() {
//fix_flaw_line_below:
//  void GoBack(bool is_cross_site) {
     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(entry);
     contents()->controller().GoBack();
 
//flaw_line_below:
    // The navigation should commit in the pending RVH.
//flaw_line_below:
    contents()->TestDidNavigate(
//flaw_line_below:
        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
//flaw_line_below:
        content::PAGE_TRANSITION_TYPED);
//fix_flaw_line_below:
//    // The pending RVH should commit for cross-site navigations.
//fix_flaw_line_below:
//    RenderViewHost* rvh = is_cross_site ?
//fix_flaw_line_below:
//        contents()->pending_rvh() :
//fix_flaw_line_below:
//        contents()->render_view_host();
//fix_flaw_line_below:
//    contents()->TestDidNavigate(rvh, entry->page_id(), GURL(entry->url()),
//fix_flaw_line_below:
//                                content::PAGE_TRANSITION_TYPED);
   }
"
307,None,Local,Not required,Partial,CVE-2015-8952,https://www.cvedetails.com/cve/CVE-2015-8952/,CWE-19,Low,None,None,,2016-10-16,2.1,"The mbcache feature in the ext2 and ext4 filesystem implementations in the Linux kernel before 4.6 mishandles xattr block caching, which allows local users to cause a denial of service (soft lockup) via filesystem operations in environments that use many attributes, as demonstrated by Ceph and Samba.",2018-03-15,DoS ,4.0,https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee,be0726d33cb8f411945884664924bed3cb8c70ee,"ext2: convert to mbcache2

The conversion is generally straightforward. We convert filesystem from
a global cache to per-fs one. Similarly to ext4 the tricky part is that
xattr block corresponding to found mbcache entry can get freed before we
get buffer lock for that block. So we have to check whether the entry is
still valid after getting the buffer lock.

Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>",1.0,fs/ext2/super.c,"{""sha"": ""f98ce7e60a0f84f71743e0dfe069c7e96c6bd648"", ""filename"": ""fs/ext2/ext2.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/be0726d33cb8f411945884664924bed3cb8c70ee/fs/ext2/ext2.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/be0726d33cb8f411945884664924bed3cb8c70ee/fs/ext2/ext2.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/ext2.h?ref=be0726d33cb8f411945884664924bed3cb8c70ee"", ""patch"": ""@@ -61,6 +61,8 @@ struct ext2_block_alloc_info {\n #define rsv_start rsv_window._rsv_start\n #define rsv_end rsv_window._rsv_end\n \n+struct mb2_cache;\n+\n /*\n  * second extended-fs super-block data in memory\n  */\n@@ -111,6 +113,7 @@ struct ext2_sb_info {\n \t * of the mount options.\n \t */\n \tspinlock_t s_lock;\n+\tstruct mb2_cache *s_mb_cache;\n };\n \n static inline spinlock_t *""}<_**next**_>{""sha"": ""b78caf25f746220ce635a3bd946bedeaf7e3e750"", ""filename"": ""fs/ext2/super.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 8, ""changes"": 25, ""blob_url"": ""https://github.com/torvalds/linux/blob/be0726d33cb8f411945884664924bed3cb8c70ee/fs/ext2/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/be0726d33cb8f411945884664924bed3cb8c70ee/fs/ext2/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/super.c?ref=be0726d33cb8f411945884664924bed3cb8c70ee"", ""patch"": ""@@ -131,7 +131,10 @@ static void ext2_put_super (struct super_block * sb)\n \n \tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n \n-\text2_xattr_put_super(sb);\n+\tif (sbi->s_mb_cache) {\n+\t\text2_xattr_destroy_cache(sbi->s_mb_cache);\n+\t\tsbi->s_mb_cache = NULL;\n+\t}\n \tif (!(sb->s_flags & MS_RDONLY)) {\n \t\tstruct ext2_super_block *es = sbi->s_es;\n \n@@ -1104,6 +1107,14 @@ static int ext2_fill_super(struct super_block *sb, void *data, int silent)\n \t\text2_msg(sb, KERN_ERR, \""error: insufficient memory\"");\n \t\tgoto failed_mount3;\n \t}\n+\n+#ifdef CONFIG_EXT2_FS_XATTR\n+\tsbi->s_mb_cache = ext2_xattr_create_cache();\n+\tif (!sbi->s_mb_cache) {\n+\t\text2_msg(sb, KERN_ERR, \""Failed to create an mb_cache\"");\n+\t\tgoto failed_mount3;\n+\t}\n+#endif\n \t/*\n \t * set up enough so that it can read an inode\n \t */\n@@ -1149,6 +1160,8 @@ static int ext2_fill_super(struct super_block *sb, void *data, int silent)\n \t\t\tsb->s_id);\n \tgoto failed_mount;\n failed_mount3:\n+\tif (sbi->s_mb_cache)\n+\t\text2_xattr_destroy_cache(sbi->s_mb_cache);\n \tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n \tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n \tpercpu_counter_destroy(&sbi->s_dirs_counter);\n@@ -1555,28 +1568,24 @@ MODULE_ALIAS_FS(\""ext2\"");\n \n static int __init init_ext2_fs(void)\n {\n-\tint err = init_ext2_xattr();\n-\tif (err)\n-\t\treturn err;\n+\tint err;\n+\n \terr = init_inodecache();\n \tif (err)\n-\t\tgoto out1;\n+\t\treturn err;\n         err = register_filesystem(&ext2_fs_type);\n \tif (err)\n \t\tgoto out;\n \treturn 0;\n out:\n \tdestroy_inodecache();\n-out1:\n-\texit_ext2_xattr();\n \treturn err;\n }\n \n static void __exit exit_ext2_fs(void)\n {\n \tunregister_filesystem(&ext2_fs_type);\n \tdestroy_inodecache();\n-\texit_ext2_xattr();\n }\n \n MODULE_AUTHOR(\""Remy Card and others\"");""}<_**next**_>{""sha"": ""7162b4869bc32515800d8ffc06ac3835ea241c8b"", ""filename"": ""fs/ext2/xattr.c"", ""status"": ""modified"", ""additions"": 67, ""deletions"": 76, ""changes"": 143, ""blob_url"": ""https://github.com/torvalds/linux/blob/be0726d33cb8f411945884664924bed3cb8c70ee/fs/ext2/xattr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/be0726d33cb8f411945884664924bed3cb8c70ee/fs/ext2/xattr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/xattr.c?ref=be0726d33cb8f411945884664924bed3cb8c70ee"", ""patch"": ""@@ -56,7 +56,7 @@\n #include <linux/buffer_head.h>\n #include <linux/init.h>\n #include <linux/slab.h>\n-#include <linux/mbcache.h>\n+#include <linux/mbcache2.h>\n #include <linux/quotaops.h>\n #include <linux/rwsem.h>\n #include <linux/security.h>\n@@ -90,14 +90,12 @@\n static int ext2_xattr_set2(struct inode *, struct buffer_head *,\n \t\t\t   struct ext2_xattr_header *);\n \n-static int ext2_xattr_cache_insert(struct buffer_head *);\n+static int ext2_xattr_cache_insert(struct mb2_cache *, struct buffer_head *);\n static struct buffer_head *ext2_xattr_cache_find(struct inode *,\n \t\t\t\t\t\t struct ext2_xattr_header *);\n static void ext2_xattr_rehash(struct ext2_xattr_header *,\n \t\t\t      struct ext2_xattr_entry *);\n \n-static struct mb_cache *ext2_xattr_cache;\n-\n static const struct xattr_handler *ext2_xattr_handler_map[] = {\n \t[EXT2_XATTR_INDEX_USER]\t\t     = &ext2_xattr_user_handler,\n #ifdef CONFIG_EXT2_FS_POSIX_ACL\n@@ -152,6 +150,7 @@ ext2_xattr_get(struct inode *inode, int name_index, const char *name,\n \tsize_t name_len, size;\n \tchar *end;\n \tint error;\n+\tstruct mb2_cache *ext2_mb_cache = EXT2_SB(inode->i_sb)->s_mb_cache;\n \n \tea_idebug(inode, \""name=%d.%s, buffer=%p, buffer_size=%ld\"",\n \t\t  name_index, name, buffer, (long)buffer_size);\n@@ -196,7 +195,7 @@ bad_block:\text2_error(inode->i_sb, \""ext2_xattr_get\"",\n \t\t\tgoto found;\n \t\tentry = next;\n \t}\n-\tif (ext2_xattr_cache_insert(bh))\n+\tif (ext2_xattr_cache_insert(ext2_mb_cache, bh))\n \t\tea_idebug(inode, \""cache insert failed\"");\n \terror = -ENODATA;\n \tgoto cleanup;\n@@ -209,7 +208,7 @@ bad_block:\text2_error(inode->i_sb, \""ext2_xattr_get\"",\n \t    le16_to_cpu(entry->e_value_offs) + size > inode->i_sb->s_blocksize)\n \t\tgoto bad_block;\n \n-\tif (ext2_xattr_cache_insert(bh))\n+\tif (ext2_xattr_cache_insert(ext2_mb_cache, bh))\n \t\tea_idebug(inode, \""cache insert failed\"");\n \tif (buffer) {\n \t\terror = -ERANGE;\n@@ -247,6 +246,7 @@ ext2_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n \tchar *end;\n \tsize_t rest = buffer_size;\n \tint error;\n+\tstruct mb2_cache *ext2_mb_cache = EXT2_SB(inode->i_sb)->s_mb_cache;\n \n \tea_idebug(inode, \""buffer=%p, buffer_size=%ld\"",\n \t\t  buffer, (long)buffer_size);\n@@ -281,7 +281,7 @@ bad_block:\text2_error(inode->i_sb, \""ext2_xattr_list\"",\n \t\t\tgoto bad_block;\n \t\tentry = next;\n \t}\n-\tif (ext2_xattr_cache_insert(bh))\n+\tif (ext2_xattr_cache_insert(ext2_mb_cache, bh))\n \t\tea_idebug(inode, \""cache insert failed\"");\n \n \t/* list the attribute names */\n@@ -483,22 +483,23 @@ bad_block:\t\text2_error(sb, \""ext2_xattr_set\"",\n \t/* Here we know that we can set the new attribute. */\n \n \tif (header) {\n-\t\tstruct mb_cache_entry *ce;\n-\n \t\t/* assert(header == HDR(bh)); */\n-\t\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev,\n-\t\t\t\t\tbh->b_blocknr);\n \t\tlock_buffer(bh);\n \t\tif (header->h_refcount == cpu_to_le32(1)) {\n+\t\t\t__u32 hash = le32_to_cpu(header->h_hash);\n+\n \t\t\tea_bdebug(bh, \""modifying in-place\"");\n-\t\t\tif (ce)\n-\t\t\t\tmb_cache_entry_free(ce);\n+\t\t\t/*\n+\t\t\t * This must happen under buffer lock for\n+\t\t\t * ext2_xattr_set2() to reliably detect modified block\n+\t\t\t */\n+\t\t\tmb2_cache_entry_delete_block(EXT2_SB(sb)->s_mb_cache,\n+\t\t\t\t\t\t     hash, bh->b_blocknr);\n+\n \t\t\t/* keep the buffer locked while modifying it. */\n \t\t} else {\n \t\t\tint offset;\n \n-\t\t\tif (ce)\n-\t\t\t\tmb_cache_entry_release(ce);\n \t\t\tunlock_buffer(bh);\n \t\t\tea_bdebug(bh, \""cloning\"");\n \t\t\theader = kmalloc(bh->b_size, GFP_KERNEL);\n@@ -626,6 +627,7 @@ ext2_xattr_set2(struct inode *inode, struct buffer_head *old_bh,\n \tstruct super_block *sb = inode->i_sb;\n \tstruct buffer_head *new_bh = NULL;\n \tint error;\n+\tstruct mb2_cache *ext2_mb_cache = EXT2_SB(sb)->s_mb_cache;\n \n \tif (header) {\n \t\tnew_bh = ext2_xattr_cache_find(inode, header);\n@@ -653,7 +655,7 @@ ext2_xattr_set2(struct inode *inode, struct buffer_head *old_bh,\n \t\t\t   don't need to change the reference count. */\n \t\t\tnew_bh = old_bh;\n \t\t\tget_bh(new_bh);\n-\t\t\text2_xattr_cache_insert(new_bh);\n+\t\t\text2_xattr_cache_insert(ext2_mb_cache, new_bh);\n \t\t} else {\n \t\t\t/* We need to allocate a new block */\n \t\t\text2_fsblk_t goal = ext2_group_first_block_no(sb,\n@@ -674,7 +676,7 @@ ext2_xattr_set2(struct inode *inode, struct buffer_head *old_bh,\n \t\t\tmemcpy(new_bh->b_data, header, new_bh->b_size);\n \t\t\tset_buffer_uptodate(new_bh);\n \t\t\tunlock_buffer(new_bh);\n-\t\t\text2_xattr_cache_insert(new_bh);\n+\t\t\text2_xattr_cache_insert(ext2_mb_cache, new_bh);\n \t\t\t\n \t\t\text2_xattr_update_super_block(sb);\n \t\t}\n@@ -707,19 +709,21 @@ ext2_xattr_set2(struct inode *inode, struct buffer_head *old_bh,\n \n \terror = 0;\n \tif (old_bh && old_bh != new_bh) {\n-\t\tstruct mb_cache_entry *ce;\n-\n \t\t/*\n \t\t * If there was an old block and we are no longer using it,\n \t\t * release the old block.\n \t\t */\n-\t\tce = mb_cache_entry_get(ext2_xattr_cache, old_bh->b_bdev,\n-\t\t\t\t\told_bh->b_blocknr);\n \t\tlock_buffer(old_bh);\n \t\tif (HDR(old_bh)->h_refcount == cpu_to_le32(1)) {\n+\t\t\t__u32 hash = le32_to_cpu(HDR(old_bh)->h_hash);\n+\n+\t\t\t/*\n+\t\t\t * This must happen under buffer lock for\n+\t\t\t * ext2_xattr_set2() to reliably detect freed block\n+\t\t\t */\n+\t\t\tmb2_cache_entry_delete_block(ext2_mb_cache,\n+\t\t\t\t\t\t     hash, old_bh->b_blocknr);\n \t\t\t/* Free the old block. */\n-\t\t\tif (ce)\n-\t\t\t\tmb_cache_entry_free(ce);\n \t\t\tea_bdebug(old_bh, \""freeing\"");\n \t\t\text2_free_blocks(inode, old_bh->b_blocknr, 1);\n \t\t\tmark_inode_dirty(inode);\n@@ -730,8 +734,6 @@ ext2_xattr_set2(struct inode *inode, struct buffer_head *old_bh,\n \t\t} else {\n \t\t\t/* Decrement the refcount only. */\n \t\t\tle32_add_cpu(&HDR(old_bh)->h_refcount, -1);\n-\t\t\tif (ce)\n-\t\t\t\tmb_cache_entry_release(ce);\n \t\t\tdquot_free_block_nodirty(inode, 1);\n \t\t\tmark_inode_dirty(inode);\n \t\t\tmark_buffer_dirty(old_bh);\n@@ -757,7 +759,6 @@ void\n ext2_xattr_delete_inode(struct inode *inode)\n {\n \tstruct buffer_head *bh = NULL;\n-\tstruct mb_cache_entry *ce;\n \n \tdown_write(&EXT2_I(inode)->xattr_sem);\n \tif (!EXT2_I(inode)->i_file_acl)\n@@ -777,19 +778,22 @@ ext2_xattr_delete_inode(struct inode *inode)\n \t\t\tEXT2_I(inode)->i_file_acl);\n \t\tgoto cleanup;\n \t}\n-\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr);\n \tlock_buffer(bh);\n \tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n-\t\tif (ce)\n-\t\t\tmb_cache_entry_free(ce);\n+\t\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n+\n+\t\t/*\n+\t\t * This must happen under buffer lock for ext2_xattr_set2() to\n+\t\t * reliably detect freed block\n+\t\t */\n+\t\tmb2_cache_entry_delete_block(EXT2_SB(inode->i_sb)->s_mb_cache,\n+\t\t\t\t\t     hash, bh->b_blocknr);\n \t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n \t\tget_bh(bh);\n \t\tbforget(bh);\n \t\tunlock_buffer(bh);\n \t} else {\n \t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n-\t\tif (ce)\n-\t\t\tmb_cache_entry_release(ce);\n \t\tea_bdebug(bh, \""refcount now=%d\"",\n \t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n \t\tunlock_buffer(bh);\n@@ -805,18 +809,6 @@ ext2_xattr_delete_inode(struct inode *inode)\n \tup_write(&EXT2_I(inode)->xattr_sem);\n }\n \n-/*\n- * ext2_xattr_put_super()\n- *\n- * This is called when a file system is unmounted.\n- */\n-void\n-ext2_xattr_put_super(struct super_block *sb)\n-{\n-\tmb_cache_shrink(sb->s_bdev);\n-}\n-\n-\n /*\n  * ext2_xattr_cache_insert()\n  *\n@@ -826,28 +818,20 @@ ext2_xattr_put_super(struct super_block *sb)\n  * Returns 0, or a negative error number on failure.\n  */\n static int\n-ext2_xattr_cache_insert(struct buffer_head *bh)\n+ext2_xattr_cache_insert(struct mb2_cache *cache, struct buffer_head *bh)\n {\n \t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n-\tstruct mb_cache_entry *ce;\n \tint error;\n \n-\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n-\tif (!ce)\n-\t\treturn -ENOMEM;\n-\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n+\terror = mb2_cache_entry_create(cache, GFP_NOFS, hash, bh->b_blocknr);\n \tif (error) {\n-\t\tmb_cache_entry_free(ce);\n \t\tif (error == -EBUSY) {\n \t\t\tea_bdebug(bh, \""already in cache (%d cache entries)\"",\n \t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n \t\t\terror = 0;\n \t\t}\n-\t} else {\n-\t\tea_bdebug(bh, \""inserting [%x] (%d cache entries)\"", (int)hash,\n-\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n-\t\tmb_cache_entry_release(ce);\n-\t}\n+\t} else\n+\t\tea_bdebug(bh, \""inserting [%x]\"", (int)hash);\n \treturn error;\n }\n \n@@ -903,31 +887,39 @@ static struct buffer_head *\n ext2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)\n {\n \t__u32 hash = le32_to_cpu(header->h_hash);\n-\tstruct mb_cache_entry *ce;\n+\tstruct mb2_cache_entry *ce;\n+\tstruct mb2_cache *ext2_mb_cache = EXT2_SB(inode->i_sb)->s_mb_cache;\n \n \tif (!header->h_hash)\n \t\treturn NULL;  /* never share */\n \tea_idebug(inode, \""looking for cached blocks [%x]\"", (int)hash);\n again:\n-\tce = mb_cache_entry_find_first(ext2_xattr_cache, inode->i_sb->s_bdev,\n-\t\t\t\t       hash);\n+\tce = mb2_cache_entry_find_first(ext2_mb_cache, hash);\n \twhile (ce) {\n \t\tstruct buffer_head *bh;\n \n-\t\tif (IS_ERR(ce)) {\n-\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n-\t\t\t\tgoto again;\n-\t\t\tbreak;\n-\t\t}\n-\n \t\tbh = sb_bread(inode->i_sb, ce->e_block);\n \t\tif (!bh) {\n \t\t\text2_error(inode->i_sb, \""ext2_xattr_cache_find\"",\n \t\t\t\t\""inode %ld: block %ld read error\"",\n \t\t\t\tinode->i_ino, (unsigned long) ce->e_block);\n \t\t} else {\n \t\t\tlock_buffer(bh);\n-\t\t\tif (le32_to_cpu(HDR(bh)->h_refcount) >\n+\t\t\t/*\n+\t\t\t * We have to be careful about races with freeing or\n+\t\t\t * rehashing of xattr block. Once we hold buffer lock\n+\t\t\t * xattr block's state is stable so we can check\n+\t\t\t * whether the block got freed / rehashed or not.\n+\t\t\t * Since we unhash mbcache entry under buffer lock when\n+\t\t\t * freeing / rehashing xattr block, checking whether\n+\t\t\t * entry is still hashed is reliable.\n+\t\t\t */\n+\t\t\tif (hlist_bl_unhashed(&ce->e_hash_list)) {\n+\t\t\t\tmb2_cache_entry_put(ext2_mb_cache, ce);\n+\t\t\t\tunlock_buffer(bh);\n+\t\t\t\tbrelse(bh);\n+\t\t\t\tgoto again;\n+\t\t\t} else if (le32_to_cpu(HDR(bh)->h_refcount) >\n \t\t\t\t   EXT2_XATTR_REFCOUNT_MAX) {\n \t\t\t\tea_idebug(inode, \""block %ld refcount %d>%d\"",\n \t\t\t\t\t  (unsigned long) ce->e_block,\n@@ -936,13 +928,14 @@ ext2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)\n \t\t\t} else if (!ext2_xattr_cmp(header, HDR(bh))) {\n \t\t\t\tea_bdebug(bh, \""b_count=%d\"",\n \t\t\t\t\t  atomic_read(&(bh->b_count)));\n-\t\t\t\tmb_cache_entry_release(ce);\n+\t\t\t\tmb2_cache_entry_touch(ext2_mb_cache, ce);\n+\t\t\t\tmb2_cache_entry_put(ext2_mb_cache, ce);\n \t\t\t\treturn bh;\n \t\t\t}\n \t\t\tunlock_buffer(bh);\n \t\t\tbrelse(bh);\n \t\t}\n-\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n+\t\tce = mb2_cache_entry_find_next(ext2_mb_cache, ce);\n \t}\n \treturn NULL;\n }\n@@ -1015,17 +1008,15 @@ static void ext2_xattr_rehash(struct ext2_xattr_header *header,\n \n #undef BLOCK_HASH_SHIFT\n \n-int __init\n-init_ext2_xattr(void)\n+#define HASH_BUCKET_BITS 10\n+\n+struct mb2_cache *ext2_xattr_create_cache(void)\n {\n-\text2_xattr_cache = mb_cache_create(\""ext2_xattr\"", 6);\n-\tif (!ext2_xattr_cache)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n+\treturn mb2_cache_create(HASH_BUCKET_BITS);\n }\n \n-void\n-exit_ext2_xattr(void)\n+void ext2_xattr_destroy_cache(struct mb2_cache *cache)\n {\n-\tmb_cache_destroy(ext2_xattr_cache);\n+\tif (cache)\n+\t\tmb2_cache_destroy(cache);\n }""}<_**next**_>{""sha"": ""6ea38aa9563a00649bf25544eed131bbe8b1d88d"", ""filename"": ""fs/ext2/xattr.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 16, ""changes"": 21, ""blob_url"": ""https://github.com/torvalds/linux/blob/be0726d33cb8f411945884664924bed3cb8c70ee/fs/ext2/xattr.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/be0726d33cb8f411945884664924bed3cb8c70ee/fs/ext2/xattr.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/xattr.h?ref=be0726d33cb8f411945884664924bed3cb8c70ee"", ""patch"": ""@@ -53,6 +53,8 @@ struct ext2_xattr_entry {\n #define EXT2_XATTR_SIZE(size) \\\n \t(((size) + EXT2_XATTR_ROUND) & ~EXT2_XATTR_ROUND)\n \n+struct mb2_cache;\n+\n # ifdef CONFIG_EXT2_FS_XATTR\n \n extern const struct xattr_handler ext2_xattr_user_handler;\n@@ -65,10 +67,9 @@ extern int ext2_xattr_get(struct inode *, int, const char *, void *, size_t);\n extern int ext2_xattr_set(struct inode *, int, const char *, const void *, size_t, int);\n \n extern void ext2_xattr_delete_inode(struct inode *);\n-extern void ext2_xattr_put_super(struct super_block *);\n \n-extern int init_ext2_xattr(void);\n-extern void exit_ext2_xattr(void);\n+extern struct mb2_cache *ext2_xattr_create_cache(void);\n+extern void ext2_xattr_destroy_cache(struct mb2_cache *cache);\n \n extern const struct xattr_handler *ext2_xattr_handlers[];\n \n@@ -93,19 +94,7 @@ ext2_xattr_delete_inode(struct inode *inode)\n {\n }\n \n-static inline void\n-ext2_xattr_put_super(struct super_block *sb)\n-{\n-}\n-\n-static inline int\n-init_ext2_xattr(void)\n-{\n-\treturn 0;\n-}\n-\n-static inline void\n-exit_ext2_xattr(void)\n+static inline void ext2_xattr_destroy_cache(struct mb2_cache *cache)\n {\n }\n ""}",	ext2_xattr_put_super(sb);,8,"static void ext2_put_super (struct super_block * sb)
{
	int db_count;
	int i;
	struct ext2_sb_info *sbi = EXT2_SB(sb);
 
 	dquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
 
	if (sbi->s_mb_cache) {
		ext2_xattr_destroy_cache(sbi->s_mb_cache);
		sbi->s_mb_cache = NULL;
	}
 	if (!(sb->s_flags & MS_RDONLY)) {
 		struct ext2_super_block *es = sbi->s_es;
 
		spin_lock(&sbi->s_lock);
		es->s_state = cpu_to_le16(sbi->s_mount_state);
		spin_unlock(&sbi->s_lock);
		ext2_sync_super(sb, es, 1);
	}
	db_count = sbi->s_gdb_count;
	for (i = 0; i < db_count; i++)
		if (sbi->s_group_desc[i])
			brelse (sbi->s_group_desc[i]);
	kfree(sbi->s_group_desc);
	kfree(sbi->s_debts);
	percpu_counter_destroy(&sbi->s_freeblocks_counter);
	percpu_counter_destroy(&sbi->s_freeinodes_counter);
	percpu_counter_destroy(&sbi->s_dirs_counter);
	brelse (sbi->s_sbh);
	sb->s_fs_info = NULL;
	kfree(sbi->s_blockgroup_lock);
	kfree(sbi);
}
","static void ext2_put_super (struct super_block * sb)
{
	int db_count;
	int i;
	struct ext2_sb_info *sbi = EXT2_SB(sb);
 
 	dquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
 
	ext2_xattr_put_super(sb);
 	if (!(sb->s_flags & MS_RDONLY)) {
 		struct ext2_super_block *es = sbi->s_es;
 
		spin_lock(&sbi->s_lock);
		es->s_state = cpu_to_le16(sbi->s_mount_state);
		spin_unlock(&sbi->s_lock);
		ext2_sync_super(sb, es, 1);
	}
	db_count = sbi->s_gdb_count;
	for (i = 0; i < db_count; i++)
		if (sbi->s_group_desc[i])
			brelse (sbi->s_group_desc[i]);
	kfree(sbi->s_group_desc);
	kfree(sbi->s_debts);
	percpu_counter_destroy(&sbi->s_freeblocks_counter);
	percpu_counter_destroy(&sbi->s_freeinodes_counter);
	percpu_counter_destroy(&sbi->s_dirs_counter);
	brelse (sbi->s_sbh);
	sb->s_fs_info = NULL;
	kfree(sbi->s_blockgroup_lock);
	kfree(sbi);
}
",183146.0,C,"	if (sbi->s_mb_cache) {
		ext2_xattr_destroy_cache(sbi->s_mb_cache);
		sbi->s_mb_cache = NULL;
	}
","	ext2_xattr_put_super(sb);
",,"@@ -131,7 +131,10 @@ static void ext2_put_super (struct super_block * sb)
 
 	dquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
 
-	ext2_xattr_put_super(sb);
+	if (sbi->s_mb_cache) {
+		ext2_xattr_destroy_cache(sbi->s_mb_cache);
+		sbi->s_mb_cache = NULL;
+	}
 	if (!(sb->s_flags & MS_RDONLY)) {
 		struct ext2_super_block *es = sbi->s_es;
 
@@ -1104,6 +1107,14 @@ static int ext2_fill_super(struct super_block *sb, void *data, int silent)
 		ext2_msg(sb, KERN_ERR, ""error: insufficient memory"");
 		goto failed_mount3;
 	}
+
+#ifdef CONFIG_EXT2_FS_XATTR
+	sbi->s_mb_cache = ext2_xattr_create_cache();
+	if (!sbi->s_mb_cache) {
+		ext2_msg(sb, KERN_ERR, ""Failed to create an mb_cache"");
+		goto failed_mount3;
+	}
+#endif
 	/*
 	 * set up enough so that it can read an inode
 	 */
@@ -1149,6 +1160,8 @@ static int ext2_fill_super(struct super_block *sb, void *data, int silent)
 			sb->s_id);
 	goto failed_mount;
 failed_mount3:
+	if (sbi->s_mb_cache)
+		ext2_xattr_destroy_cache(sbi->s_mb_cache);
 	percpu_counter_destroy(&sbi->s_freeblocks_counter);
 	percpu_counter_destroy(&sbi->s_freeinodes_counter);
 	percpu_counter_destroy(&sbi->s_dirs_counter);
@@ -1555,28 +1568,24 @@ MODULE_ALIAS_FS(""ext2"");
 
 static int __init init_ext2_fs(void)
 {
-	int err = init_ext2_xattr();
-	if (err)
-		return err;
+	int err;
+
 	err = init_inodecache();
 	if (err)
-		goto out1;
+		return err;
         err = register_filesystem(&ext2_fs_type);
 	if (err)
 		goto out;
 	return 0;
 out:
 	destroy_inodecache();
-out1:
-	exit_ext2_xattr();
 	return err;
 }
 
 static void __exit exit_ext2_fs(void)
 {
 	unregister_filesystem(&ext2_fs_type);
 	destroy_inodecache();
-	exit_ext2_xattr();
 }
 
 MODULE_AUTHOR(""Remy Card and others"");","static void ext2_put_super (struct super_block * sb)
{
int db_count;
int i;
struct ext2_sb_info *sbi = EXT2_SB(sb);

dquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);

	ext2_xattr_put_super(sb);
if (!(sb->s_flags & MS_RDONLY)) {
struct ext2_super_block *es = sbi->s_es;

spin_lock(&sbi->s_lock);
es->s_state = cpu_to_le16(sbi->s_mount_state);
spin_unlock(&sbi->s_lock);
ext2_sync_super(sb, es, 1);
}
db_count = sbi->s_gdb_count;
for (i = 0; i < db_count; i++)
if (sbi->s_group_desc[i])
brelse (sbi->s_group_desc[i]);
kfree(sbi->s_group_desc);
kfree(sbi->s_debts);
percpu_counter_destroy(&sbi->s_freeblocks_counter);
percpu_counter_destroy(&sbi->s_freeinodes_counter);
percpu_counter_destroy(&sbi->s_dirs_counter);
brelse (sbi->s_sbh);
sb->s_fs_info = NULL;
kfree(sbi->s_blockgroup_lock);
kfree(sbi);
}
",linux,be0726d33cb8f411945884664924bed3cb8c70ee,82939d7999dfc1f1998c4b1c12e2f19edbdff272,1.0,"static void ext2_put_super (struct super_block * sb)
{
	int db_count;
	int i;
	struct ext2_sb_info *sbi = EXT2_SB(sb);
 
 	dquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
 
//flaw_line_below:
	ext2_xattr_put_super(sb);
//fix_flaw_line_below:
//	if (sbi->s_mb_cache) {
//fix_flaw_line_below:
//		ext2_xattr_destroy_cache(sbi->s_mb_cache);
//fix_flaw_line_below:
//		sbi->s_mb_cache = NULL;
//fix_flaw_line_below:
//	}
 	if (!(sb->s_flags & MS_RDONLY)) {
 		struct ext2_super_block *es = sbi->s_es;
 
		spin_lock(&sbi->s_lock);
		es->s_state = cpu_to_le16(sbi->s_mount_state);
		spin_unlock(&sbi->s_lock);
		ext2_sync_super(sb, es, 1);
	}
	db_count = sbi->s_gdb_count;
	for (i = 0; i < db_count; i++)
		if (sbi->s_group_desc[i])
			brelse (sbi->s_group_desc[i]);
	kfree(sbi->s_group_desc);
	kfree(sbi->s_debts);
	percpu_counter_destroy(&sbi->s_freeblocks_counter);
	percpu_counter_destroy(&sbi->s_freeinodes_counter);
	percpu_counter_destroy(&sbi->s_dirs_counter);
	brelse (sbi->s_sbh);
	sb->s_fs_info = NULL;
	kfree(sbi->s_blockgroup_lock);
	kfree(sbi);
}
"
311,None,Remote,Not required,Complete,CVE-2016-1621,https://www.cvedetails.com/cve/CVE-2016-1621/,CWE-119,Low,Complete,Complete,,2016-03-12,10.0,"libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792.",2016-12-02,DoS Exec Code Overflow Mem. Corr. ,0.0,https://android.googlesource.com/platform/external/libvpx/+/04839626ed859623901ebd3a5fd483982186b59d,04839626ed859623901ebd3a5fd483982186b59d,"libwebm: Pull from upstream

Rolling mkvparser from upstream. Primarily for fixing a bug on parsing
failures with certain Opus WebM files.

Upstream commit hash of this pull: 574045edd4ecbeb802ee3f1d214b5510269852ae

The diff is so huge because there were some style clean ups upstream.
But it was ensured that there were no breaking changes when the style
clean ups was done upstream.

Change-Id: Ib6e907175484b4b0ae1b55ab39522ea3188ad039",3.0,libwebm/mkvparser.cpp,"{""filename"": ""libwebm/mkvparser.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/04839626ed859623901ebd3a5fd483982186b59d/libwebm/mkvparser.cpp"", ""patch"": ""@@ -12,1380 +12,1208 @@\n\n #include <new>\n #include <climits>\n \n-mkvparser::IMkvReader::~IMkvReader()\n-{\n+#ifdef _MSC_VER\n+// Disable MSVC warnings that suggest making code non-portable.\n+#pragma warning(disable : 4996)\n+#endif\n+\n+mkvparser::IMkvReader::~IMkvReader() {}\n+\n+void mkvparser::GetVersion(int& major, int& minor, int& build, int& revision) {\n+  major = 1;\n+  minor = 0;\n+  build = 0;\n+  revision = 28;\n }\n \n-void mkvparser::GetVersion(int& major, int& minor, int& build, int& revision)\n-{\n-    major = 1;\n-    minor = 0;\n-    build = 0;\n-    revision = 27;\n-}\n+long long mkvparser::ReadUInt(IMkvReader* pReader, long long pos, long& len) {\n+  assert(pReader);\n+  assert(pos >= 0);\n \n-long long mkvparser::ReadUInt(IMkvReader* pReader, long long pos, long& len)\n-{\n-    assert(pReader);\n-    assert(pos >= 0);\n+  int status;\n \n-    int status;\n+  //#ifdef _DEBUG\n+  //    long long total, available;\n+  //    status = pReader->Length(&total, &available);\n+  //    assert(status >= 0);\n+  //    assert((total < 0) || (available <= total));\n+  //    assert(pos < available);\n+  //    assert((available - pos) >= 1);  //assume here max u-int len is 8\n+  //#endif\n \n-//#ifdef _DEBUG\n-//    long long total, available;\n-//    status = pReader->Length(&total, &available);\n-//    assert(status >= 0);\n-//    assert((total < 0) || (available <= total));\n-//    assert(pos < available);\n-//    assert((available - pos) >= 1);  //assume here max u-int len is 8\n-//#endif\n+  len = 1;\n \n-    len = 1;\n+  unsigned char b;\n \n-    unsigned char b;\n+  status = pReader->Read(pos, 1, &b);\n \n+  if (status < 0)  // error or underflow\n+    return status;\n+\n+  if (status > 0)  // interpreted as \""underflow\""\n+    return E_BUFFER_NOT_FULL;\n+\n+  if (b == 0)  // we can't handle u-int values larger than 8 bytes\n+    return E_FILE_FORMAT_INVALID;\n+\n+  unsigned char m = 0x80;\n+\n+  while (!(b & m)) {\n+    m >>= 1;\n+    ++len;\n+  }\n+\n+  //#ifdef _DEBUG\n+  //    assert((available - pos) >= len);\n+  //#endif\n+\n+  long long result = b & (~m);\n+  ++pos;\n+\n+  for (int i = 1; i < len; ++i) {\n     status = pReader->Read(pos, 1, &b);\n \n-    if (status < 0)  //error or underflow\n-        return status;\n-\n-    if (status > 0)  //interpreted as \""underflow\""\n-        return E_BUFFER_NOT_FULL;\n-\n-    if (b == 0)  //we can't handle u-int values larger than 8 bytes\n-        return E_FILE_FORMAT_INVALID;\n-\n-    unsigned char m = 0x80;\n-\n-    while (!(b & m))\n-    {\n-        m >>= 1;\n-        ++len;\n+    if (status < 0) {\n+      len = 1;\n+      return status;\n     }\n \n-//#ifdef _DEBUG\n-//    assert((available - pos) >= len);\n-//#endif\n+    if (status > 0) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n+    }\n \n-    long long result = b & (~m);\n+    result <<= 8;\n+    result |= b;\n+\n     ++pos;\n+  }\n \n-    for (int i = 1; i < len; ++i)\n-    {\n-        status = pReader->Read(pos, 1, &b);\n-\n-        if (status < 0)\n-        {\n-            len = 1;\n-            return status;\n-        }\n-\n-        if (status > 0)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        result <<= 8;\n-        result |= b;\n-\n-        ++pos;\n-    }\n-\n-    return result;\n+  return result;\n }\n \n-long long mkvparser::GetUIntLength(\n-    IMkvReader* pReader,\n-    long long pos,\n-    long& len)\n-{\n-    assert(pReader);\n-    assert(pos >= 0);\n+long long mkvparser::GetUIntLength(IMkvReader* pReader, long long pos,\n+                                   long& len) {\n+  assert(pReader);\n+  assert(pos >= 0);\n \n-    long long total, available;\n+  long long total, available;\n \n-    int status = pReader->Length(&total, &available);\n-    assert(status >= 0);\n-    assert((total < 0) || (available <= total));\n+  int status = pReader->Length(&total, &available);\n+  assert(status >= 0);\n+  assert((total < 0) || (available <= total));\n \n-    len = 1;\n+  len = 1;\n \n-    if (pos >= available)\n-        return pos;  //too few bytes available\n+  if (pos >= available)\n+    return pos;  // too few bytes available\n \n+  unsigned char b;\n+\n+  status = pReader->Read(pos, 1, &b);\n+\n+  if (status < 0)\n+    return status;\n+\n+  assert(status == 0);\n+\n+  if (b == 0)  // we can't handle u-int values larger than 8 bytes\n+    return E_FILE_FORMAT_INVALID;\n+\n+  unsigned char m = 0x80;\n+\n+  while (!(b & m)) {\n+    m >>= 1;\n+    ++len;\n+  }\n+\n+  return 0;  // success\n+}\n+\n+// TODO(vigneshv): This function assumes that unsigned values never have their\n+// high bit set.\n+long long mkvparser::UnserializeUInt(IMkvReader* pReader, long long pos,\n+                                     long long size) {\n+  assert(pReader);\n+  assert(pos >= 0);\n+\n+  if ((size <= 0) || (size > 8))\n+    return E_FILE_FORMAT_INVALID;\n+\n+  long long result = 0;\n+\n+  for (long long i = 0; i < size; ++i) {\n     unsigned char b;\n \n-    status = pReader->Read(pos, 1, &b);\n+    const long status = pReader->Read(pos, 1, &b);\n \n     if (status < 0)\n-        return status;\n+      return status;\n \n-    assert(status == 0);\n+    result <<= 8;\n+    result |= b;\n \n-    if (b == 0)  //we can't handle u-int values larger than 8 bytes\n-        return E_FILE_FORMAT_INVALID;\n+    ++pos;\n+  }\n \n-    unsigned char m = 0x80;\n-\n-    while (!(b & m))\n-    {\n-        m >>= 1;\n-        ++len;\n-    }\n-\n-    return 0;  //success\n+  return result;\n }\n \n+long mkvparser::UnserializeFloat(IMkvReader* pReader, long long pos,\n+                                 long long size_, double& result) {\n+  assert(pReader);\n+  assert(pos >= 0);\n \n-long long mkvparser::UnserializeUInt(\n-    IMkvReader* pReader,\n-    long long pos,\n-    long long size)\n-{\n-    assert(pReader);\n-    assert(pos >= 0);\n+  if ((size_ != 4) && (size_ != 8))\n+    return E_FILE_FORMAT_INVALID;\n \n-    if ((size <= 0) || (size > 8))\n-        return E_FILE_FORMAT_INVALID;\n+  const long size = static_cast<long>(size_);\n \n-    long long result = 0;\n+  unsigned char buf[8];\n \n-    for (long long i = 0; i < size; ++i)\n-    {\n-        unsigned char b;\n+  const int status = pReader->Read(pos, size, buf);\n \n-        const long status = pReader->Read(pos, 1, &b);\n+  if (status < 0)  // error\n+    return status;\n \n-        if (status < 0)\n-            return status;\n+  if (size == 4) {\n+    union {\n+      float f;\n+      unsigned long ff;\n+    };\n \n-        result <<= 8;\n-        result |= b;\n+    ff = 0;\n \n-        ++pos;\n+    for (int i = 0;;) {\n+      ff |= buf[i];\n+\n+      if (++i >= 4)\n+        break;\n+\n+      ff <<= 8;\n     }\n \n-    return result;\n+    result = f;\n+  } else {\n+    assert(size == 8);\n+\n+    union {\n+      double d;\n+      unsigned long long dd;\n+    };\n+\n+    dd = 0;\n+\n+    for (int i = 0;;) {\n+      dd |= buf[i];\n+\n+      if (++i >= 8)\n+        break;\n+\n+      dd <<= 8;\n+    }\n+\n+    result = d;\n+  }\n+\n+  return 0;\n }\n \n+long mkvparser::UnserializeInt(IMkvReader* pReader, long long pos, long size,\n+                               long long& result) {\n+  assert(pReader);\n+  assert(pos >= 0);\n+  assert(size > 0);\n+  assert(size <= 8);\n \n-long mkvparser::UnserializeFloat(\n-    IMkvReader* pReader,\n-    long long pos,\n-    long long size_,\n-    double& result)\n-{\n-    assert(pReader);\n-    assert(pos >= 0);\n+  {\n+    signed char b;\n \n-    if ((size_ != 4) && (size_ != 8))\n-        return E_FILE_FORMAT_INVALID;\n+    const long status = pReader->Read(pos, 1, (unsigned char*)&b);\n \n-    const long size = static_cast<long>(size_);\n+    if (status < 0)\n+      return status;\n \n-    unsigned char buf[8];\n+    result = b;\n \n-    const int status = pReader->Read(pos, size, buf);\n+    ++pos;\n+  }\n \n-    if (status < 0)  //error\n-        return status;\n+  for (long i = 1; i < size; ++i) {\n+    unsigned char b;\n \n-    if (size == 4)\n-    {\n-        union\n-        {\n-            float f;\n-            unsigned long ff;\n-        };\n+    const long status = pReader->Read(pos, 1, &b);\n \n-        ff = 0;\n+    if (status < 0)\n+      return status;\n \n-        for (int i = 0;;)\n-        {\n-            ff |= buf[i];\n+    result <<= 8;\n+    result |= b;\n \n-            if (++i >= 4)\n-                break;\n+    ++pos;\n+  }\n \n-            ff <<= 8;\n-        }\n-\n-        result = f;\n-    }\n-    else\n-    {\n-        assert(size == 8);\n-\n-        union\n-        {\n-            double d;\n-            unsigned long long dd;\n-        };\n-\n-        dd = 0;\n-\n-        for (int i = 0;;)\n-        {\n-            dd |= buf[i];\n-\n-            if (++i >= 8)\n-                break;\n-\n-            dd <<= 8;\n-        }\n-\n-        result = d;\n-    }\n-\n-    return 0;\n+  return 0;  // success\n }\n \n+long mkvparser::UnserializeString(IMkvReader* pReader, long long pos,\n+                                  long long size_, char*& str) {\n+  delete[] str;\n+  str = NULL;\n \n-long mkvparser::UnserializeInt(\n-    IMkvReader* pReader,\n-    long long pos,\n-    long size,\n-    long long& result)\n-{\n-    assert(pReader);\n-    assert(pos >= 0);\n-    assert(size > 0);\n-    assert(size <= 8);\n+  if (size_ >= LONG_MAX)  // we need (size+1) chars\n+    return E_FILE_FORMAT_INVALID;\n \n-    {\n-        signed char b;\n+  const long size = static_cast<long>(size_);\n \n-        const long status = pReader->Read(pos, 1, (unsigned char*)&b);\n+  str = new (std::nothrow) char[size + 1];\n \n-        if (status < 0)\n-            return status;\n+  if (str == NULL)\n+    return -1;\n \n-        result = b;\n+  unsigned char* const buf = reinterpret_cast<unsigned char*>(str);\n \n-        ++pos;\n-    }\n+  const long status = pReader->Read(pos, size, buf);\n \n-    for (long i = 1; i < size; ++i)\n-    {\n-        unsigned char b;\n-\n-        const long status = pReader->Read(pos, 1, &b);\n-\n-        if (status < 0)\n-            return status;\n-\n-        result <<= 8;\n-        result |= b;\n-\n-        ++pos;\n-    }\n-\n-    return 0;  //success\n-}\n-\n-\n-long mkvparser::UnserializeString(\n-    IMkvReader* pReader,\n-    long long pos,\n-    long long size_,\n-    char*& str)\n-{\n+  if (status) {\n     delete[] str;\n     str = NULL;\n \n-    if (size_ >= LONG_MAX)  //we need (size+1) chars\n-        return E_FILE_FORMAT_INVALID;\n+    return status;\n+  }\n \n-    const long size = static_cast<long>(size_);\n+  str[size] = '\\0';\n \n-    str = new (std::nothrow) char[size+1];\n-\n-    if (str == NULL)\n-        return -1;\n-\n-    unsigned char* const buf = reinterpret_cast<unsigned char*>(str);\n-\n-    const long status = pReader->Read(pos, size, buf);\n-\n-    if (status)\n-    {\n-        delete[] str;\n-        str = NULL;\n-\n-        return status;\n-    }\n-\n-    str[size] = '\\0';\n-\n-    return 0;  //success\n+  return 0;  // success\n }\n \n+long mkvparser::ParseElementHeader(IMkvReader* pReader, long long& pos,\n+                                   long long stop, long long& id,\n+                                   long long& size) {\n+  if ((stop >= 0) && (pos >= stop))\n+    return E_FILE_FORMAT_INVALID;\n \n-long mkvparser::ParseElementHeader(\n-    IMkvReader* pReader,\n-    long long& pos,\n-    long long stop,\n-    long long& id,\n-    long long& size)\n-{\n-    if ((stop >= 0) && (pos >= stop))\n-        return E_FILE_FORMAT_INVALID;\n+  long len;\n \n-    long len;\n+  id = ReadUInt(pReader, pos, len);\n \n-    id = ReadUInt(pReader, pos, len);\n+  if (id < 0)\n+    return E_FILE_FORMAT_INVALID;\n \n-    if (id < 0)\n-        return E_FILE_FORMAT_INVALID;\n+  pos += len;  // consume id\n \n-    pos += len;  //consume id\n+  if ((stop >= 0) && (pos >= stop))\n+    return E_FILE_FORMAT_INVALID;\n \n-    if ((stop >= 0) && (pos >= stop))\n-        return E_FILE_FORMAT_INVALID;\n+  size = ReadUInt(pReader, pos, len);\n \n-    size = ReadUInt(pReader, pos, len);\n+  if (size < 0)\n+    return E_FILE_FORMAT_INVALID;\n \n-    if (size < 0)\n-        return E_FILE_FORMAT_INVALID;\n+  pos += len;  // consume length of size\n \n-    pos += len;  //consume length of size\n+  // pos now designates payload\n \n-    //pos now designates payload\n+  if ((stop >= 0) && ((pos + size) > stop))\n+    return E_FILE_FORMAT_INVALID;\n \n-    if ((stop >= 0) && ((pos + size) > stop))\n-        return E_FILE_FORMAT_INVALID;\n-\n-    return 0;  //success\n+  return 0;  // success\n }\n \n+bool mkvparser::Match(IMkvReader* pReader, long long& pos, unsigned long id_,\n+                      long long& val) {\n+  assert(pReader);\n+  assert(pos >= 0);\n \n-bool mkvparser::Match(\n-    IMkvReader* pReader,\n-    long long& pos,\n-    unsigned long id_,\n-    long long& val)\n-{\n-    assert(pReader);\n-    assert(pos >= 0);\n+  long long total, available;\n \n-    long long total, available;\n+  const long status = pReader->Length(&total, &available);\n+  assert(status >= 0);\n+  assert((total < 0) || (available <= total));\n+  if (status < 0)\n+    return false;\n \n-    const long status = pReader->Length(&total, &available);\n-    assert(status >= 0);\n-    assert((total < 0) || (available <= total));\n-    if (status < 0)\n-        return false;\n+  long len;\n \n-    long len;\n+  const long long id = ReadUInt(pReader, pos, len);\n+  assert(id >= 0);\n+  assert(len > 0);\n+  assert(len <= 8);\n+  assert((pos + len) <= available);\n \n-    const long long id = ReadUInt(pReader, pos, len);\n-    assert(id >= 0);\n-    assert(len > 0);\n-    assert(len <= 8);\n-    assert((pos + len) <= available);\n+  if ((unsigned long)id != id_)\n+    return false;\n \n-    if ((unsigned long)id != id_)\n-        return false;\n+  pos += len;  // consume id\n \n-    pos += len;  //consume id\n+  const long long size = ReadUInt(pReader, pos, len);\n+  assert(size >= 0);\n+  assert(size <= 8);\n+  assert(len > 0);\n+  assert(len <= 8);\n+  assert((pos + len) <= available);\n \n-    const long long size = ReadUInt(pReader, pos, len);\n-    assert(size >= 0);\n-    assert(size <= 8);\n-    assert(len > 0);\n-    assert(len <= 8);\n-    assert((pos + len) <= available);\n+  pos += len;  // consume length of size of payload\n \n-    pos += len;  //consume length of size of payload\n+  val = UnserializeUInt(pReader, pos, size);\n+  assert(val >= 0);\n \n-    val = UnserializeUInt(pReader, pos, size);\n-    assert(val >= 0);\n+  pos += size;  // consume size of payload\n \n-    pos += size;  //consume size of payload\n-\n-    return true;\n+  return true;\n }\n \n-bool mkvparser::Match(\n-    IMkvReader* pReader,\n-    long long& pos,\n-    unsigned long id_,\n-    unsigned char*& buf,\n-    size_t& buflen)\n-{\n-    assert(pReader);\n-    assert(pos >= 0);\n+bool mkvparser::Match(IMkvReader* pReader, long long& pos, unsigned long id_,\n+                      unsigned char*& buf, size_t& buflen) {\n+  assert(pReader);\n+  assert(pos >= 0);\n \n-    long long total, available;\n+  long long total, available;\n \n-    long status = pReader->Length(&total, &available);\n-    assert(status >= 0);\n-    assert((total < 0) || (available <= total));\n-    if (status < 0)\n-        return false;\n+  long status = pReader->Length(&total, &available);\n+  assert(status >= 0);\n+  assert((total < 0) || (available <= total));\n+  if (status < 0)\n+    return false;\n \n-    long len;\n-    const long long id = ReadUInt(pReader, pos, len);\n-    assert(id >= 0);\n-    assert(len > 0);\n-    assert(len <= 8);\n-    assert((pos + len) <= available);\n+  long len;\n+  const long long id = ReadUInt(pReader, pos, len);\n+  assert(id >= 0);\n+  assert(len > 0);\n+  assert(len <= 8);\n+  assert((pos + len) <= available);\n \n-    if ((unsigned long)id != id_)\n-        return false;\n+  if ((unsigned long)id != id_)\n+    return false;\n \n-    pos += len;  //consume id\n+  pos += len;  // consume id\n \n-    const long long size_ = ReadUInt(pReader, pos, len);\n-    assert(size_ >= 0);\n-    assert(len > 0);\n-    assert(len <= 8);\n-    assert((pos + len) <= available);\n+  const long long size_ = ReadUInt(pReader, pos, len);\n+  assert(size_ >= 0);\n+  assert(len > 0);\n+  assert(len <= 8);\n+  assert((pos + len) <= available);\n \n-    pos += len;  //consume length of size of payload\n-    assert((pos + size_) <= available);\n+  pos += len;  // consume length of size of payload\n+  assert((pos + size_) <= available);\n \n-    const long buflen_ = static_cast<long>(size_);\n+  const long buflen_ = static_cast<long>(size_);\n \n-    buf = new (std::nothrow) unsigned char[buflen_];\n-    assert(buf);  //TODO\n+  buf = new (std::nothrow) unsigned char[buflen_];\n+  assert(buf);  // TODO\n \n-    status = pReader->Read(pos, buflen_, buf);\n-    assert(status == 0);  //TODO\n+  status = pReader->Read(pos, buflen_, buf);\n+  assert(status == 0);  // TODO\n \n-    buflen = buflen_;\n+  buflen = buflen_;\n \n-    pos += size_;  //consume size of payload\n-    return true;\n+  pos += size_;  // consume size of payload\n+  return true;\n }\n \n+namespace mkvparser {\n \n-namespace mkvparser\n-{\n+EBMLHeader::EBMLHeader() : m_docType(NULL) { Init(); }\n \n-EBMLHeader::EBMLHeader() :\n-    m_docType(NULL)\n-{\n-    Init();\n-}\n+EBMLHeader::~EBMLHeader() { delete[] m_docType; }\n \n-EBMLHeader::~EBMLHeader()\n-{\n+void EBMLHeader::Init() {\n+  m_version = 1;\n+  m_readVersion = 1;\n+  m_maxIdLength = 4;\n+  m_maxSizeLength = 8;\n+\n+  if (m_docType) {\n     delete[] m_docType;\n+    m_docType = NULL;\n+  }\n+\n+  m_docTypeVersion = 1;\n+  m_docTypeReadVersion = 1;\n }\n \n-void EBMLHeader::Init()\n-{\n-    m_version = 1;\n-    m_readVersion = 1;\n-    m_maxIdLength = 4;\n-    m_maxSizeLength = 8;\n+long long EBMLHeader::Parse(IMkvReader* pReader, long long& pos) {\n+  assert(pReader);\n \n-    if (m_docType)\n-    {\n-        delete[] m_docType;\n-        m_docType = NULL;\n-    }\n+  long long total, available;\n \n-    m_docTypeVersion = 1;\n-    m_docTypeReadVersion = 1;\n-}\n+  long status = pReader->Length(&total, &available);\n \n-long long EBMLHeader::Parse(\n-    IMkvReader* pReader,\n-    long long& pos)\n-{\n-    assert(pReader);\n+  if (status < 0)  // error\n+    return status;\n \n-    long long total, available;\n+  pos = 0;\n+  long long end = (available >= 1024) ? 1024 : available;\n \n-    long status = pReader->Length(&total, &available);\n+  for (;;) {\n+    unsigned char b = 0;\n \n-    if (status < 0)  //error\n+    while (pos < end) {\n+      status = pReader->Read(pos, 1, &b);\n+\n+      if (status < 0)  // error\n         return status;\n \n-    pos = 0;\n-    long long end = (available >= 1024) ? 1024 : available;\n+      if (b == 0x1A)\n+        break;\n \n-    for (;;)\n-    {\n-        unsigned char b = 0;\n-\n-        while (pos < end)\n-        {\n-            status = pReader->Read(pos, 1, &b);\n-\n-            if (status < 0)  //error\n-                return status;\n-\n-            if (b == 0x1A)\n-                break;\n-\n-            ++pos;\n-        }\n-\n-        if (b != 0x1A)\n-        {\n-            if (pos >= 1024)\n-                return E_FILE_FORMAT_INVALID;  //don't bother looking anymore\n-\n-            if ((total >= 0) && ((total - available) < 5))\n-                return E_FILE_FORMAT_INVALID;\n-\n-            return available + 5;  //5 = 4-byte ID + 1st byte of size\n-        }\n-\n-        if ((total >= 0) && ((total - pos) < 5))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((available - pos) < 5)\n-            return pos + 5;  //try again later\n-\n-        long len;\n-\n-        const long long result = ReadUInt(pReader, pos, len);\n-\n-        if (result < 0)  //error\n-            return result;\n-\n-        if (result == 0x0A45DFA3)  //EBML Header ID\n-        {\n-            pos += len;  //consume ID\n-            break;\n-        }\n-\n-        ++pos;  //throw away just the 0x1A byte, and try again\n+      ++pos;\n     }\n \n-    //pos designates start of size field\n+    if (b != 0x1A) {\n+      if (pos >= 1024)\n+        return E_FILE_FORMAT_INVALID;  // don't bother looking anymore\n \n-    //get length of size field\n+      if ((total >= 0) && ((total - available) < 5))\n+        return E_FILE_FORMAT_INVALID;\n \n+      return available + 5;  // 5 = 4-byte ID + 1st byte of size\n+    }\n+\n+    if ((total >= 0) && ((total - pos) < 5))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if ((available - pos) < 5)\n+      return pos + 5;  // try again later\n+\n+    long len;\n+\n+    const long long result = ReadUInt(pReader, pos, len);\n+\n+    if (result < 0)  // error\n+      return result;\n+\n+    if (result == 0x0A45DFA3) {  // EBML Header ID\n+      pos += len;  // consume ID\n+      break;\n+    }\n+\n+    ++pos;  // throw away just the 0x1A byte, and try again\n+  }\n+\n+  // pos designates start of size field\n+\n+  // get length of size field\n+\n+  long len;\n+  long long result = GetUIntLength(pReader, pos, len);\n+\n+  if (result < 0)  // error\n+    return result;\n+\n+  if (result > 0)  // need more data\n+    return result;\n+\n+  assert(len > 0);\n+  assert(len <= 8);\n+\n+  if ((total >= 0) && ((total - pos) < len))\n+    return E_FILE_FORMAT_INVALID;\n+\n+  if ((available - pos) < len)\n+    return pos + len;  // try again later\n+\n+  // get the EBML header size\n+\n+  result = ReadUInt(pReader, pos, len);\n+\n+  if (result < 0)  // error\n+    return result;\n+\n+  pos += len;  // consume size field\n+\n+  // pos now designates start of payload\n+\n+  if ((total >= 0) && ((total - pos) < result))\n+    return E_FILE_FORMAT_INVALID;\n+\n+  if ((available - pos) < result)\n+    return pos + result;\n+\n+  end = pos + result;\n+\n+  Init();\n+\n+  while (pos < end) {\n+    long long id, size;\n+\n+    status = ParseElementHeader(pReader, pos, end, id, size);\n+\n+    if (status < 0)  // error\n+      return status;\n+\n+    if (size == 0)  // weird\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if (id == 0x0286) {  // version\n+      m_version = UnserializeUInt(pReader, pos, size);\n+\n+      if (m_version <= 0)\n+        return E_FILE_FORMAT_INVALID;\n+    } else if (id == 0x02F7) {  // read version\n+      m_readVersion = UnserializeUInt(pReader, pos, size);\n+\n+      if (m_readVersion <= 0)\n+        return E_FILE_FORMAT_INVALID;\n+    } else if (id == 0x02F2) {  // max id length\n+      m_maxIdLength = UnserializeUInt(pReader, pos, size);\n+\n+      if (m_maxIdLength <= 0)\n+        return E_FILE_FORMAT_INVALID;\n+    } else if (id == 0x02F3) {  // max size length\n+      m_maxSizeLength = UnserializeUInt(pReader, pos, size);\n+\n+      if (m_maxSizeLength <= 0)\n+        return E_FILE_FORMAT_INVALID;\n+    } else if (id == 0x0282) {  // doctype\n+      if (m_docType)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      status = UnserializeString(pReader, pos, size, m_docType);\n+\n+      if (status)  // error\n+        return status;\n+    } else if (id == 0x0287) {  // doctype version\n+      m_docTypeVersion = UnserializeUInt(pReader, pos, size);\n+\n+      if (m_docTypeVersion <= 0)\n+        return E_FILE_FORMAT_INVALID;\n+    } else if (id == 0x0285) {  // doctype read version\n+      m_docTypeReadVersion = UnserializeUInt(pReader, pos, size);\n+\n+      if (m_docTypeReadVersion <= 0)\n+        return E_FILE_FORMAT_INVALID;\n+    }\n+\n+    pos += size;\n+  }\n+\n+  assert(pos == end);\n+  return 0;\n+}\n+\n+Segment::Segment(IMkvReader* pReader, long long elem_start,\n+                 // long long elem_size,\n+                 long long start, long long size)\n+    : m_pReader(pReader),\n+      m_element_start(elem_start),\n+      // m_element_size(elem_size),\n+      m_start(start),\n+      m_size(size),\n+      m_pos(start),\n+      m_pUnknownSize(0),\n+      m_pSeekHead(NULL),\n+      m_pInfo(NULL),\n+      m_pTracks(NULL),\n+      m_pCues(NULL),\n+      m_pChapters(NULL),\n+      m_clusters(NULL),\n+      m_clusterCount(0),\n+      m_clusterPreloadCount(0),\n+      m_clusterSize(0) {}\n+\n+Segment::~Segment() {\n+  const long count = m_clusterCount + m_clusterPreloadCount;\n+\n+  Cluster** i = m_clusters;\n+  Cluster** j = m_clusters + count;\n+\n+  while (i != j) {\n+    Cluster* const p = *i++;\n+    assert(p);\n+\n+    delete p;\n+  }\n+\n+  delete[] m_clusters;\n+\n+  delete m_pTracks;\n+  delete m_pInfo;\n+  delete m_pCues;\n+  delete m_pChapters;\n+  delete m_pSeekHead;\n+}\n+\n+long long Segment::CreateInstance(IMkvReader* pReader, long long pos,\n+                                  Segment*& pSegment) {\n+  assert(pReader);\n+  assert(pos >= 0);\n+\n+  pSegment = NULL;\n+\n+  long long total, available;\n+\n+  const long status = pReader->Length(&total, &available);\n+\n+  if (status < 0)  // error\n+    return status;\n+\n+  if (available < 0)\n+    return -1;\n+\n+  if ((total >= 0) && (available > total))\n+    return -1;\n+\n+  // I would assume that in practice this loop would execute\n+  // exactly once, but we allow for other elements (e.g. Void)\n+  // to immediately follow the EBML header.  This is fine for\n+  // the source filter case (since the entire file is available),\n+  // but in the splitter case over a network we should probably\n+  // just give up early.  We could for example decide only to\n+  // execute this loop a maximum of, say, 10 times.\n+  // TODO:\n+  // There is an implied \""give up early\"" by only parsing up\n+  // to the available limit.  We do do that, but only if the\n+  // total file size is unknown.  We could decide to always\n+  // use what's available as our limit (irrespective of whether\n+  // we happen to know the total file length).  This would have\n+  // as its sense \""parse this much of the file before giving up\"",\n+  // which a slightly different sense from \""try to parse up to\n+  // 10 EMBL elements before giving up\"".\n+\n+  for (;;) {\n+    if ((total >= 0) && (pos >= total))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    // Read ID\n     long len;\n     long long result = GetUIntLength(pReader, pos, len);\n \n-    if (result < 0)  //error\n-        return result;\n+    if (result)  // error, or too few available bytes\n+      return result;\n \n-    if (result > 0)  //need more data\n-        return result;\n+    if ((total >= 0) && ((pos + len) > total))\n+      return E_FILE_FORMAT_INVALID;\n \n-    assert(len > 0);\n-    assert(len <= 8);\n+    if ((pos + len) > available)\n+      return pos + len;\n \n-    if ((total >= 0) && ((total -  pos) < len))\n-        return E_FILE_FORMAT_INVALID;\n+    const long long idpos = pos;\n+    const long long id = ReadUInt(pReader, pos, len);\n \n-    if ((available - pos) < len)\n-        return pos + len;  //try again later\n+    if (id < 0)  // error\n+      return id;\n \n-    //get the EBML header size\n+    pos += len;  // consume ID\n \n-    result = ReadUInt(pReader, pos, len);\n+    // Read Size\n \n-    if (result < 0)  //error\n-        return result;\n+    result = GetUIntLength(pReader, pos, len);\n \n-    pos += len;  //consume size field\n+    if (result)  // error, or too few available bytes\n+      return result;\n \n-    //pos now designates start of payload\n+    if ((total >= 0) && ((pos + len) > total))\n+      return E_FILE_FORMAT_INVALID;\n \n-    if ((total >= 0) && ((total - pos) < result))\n-        return E_FILE_FORMAT_INVALID;\n+    if ((pos + len) > available)\n+      return pos + len;\n \n-    if ((available - pos) < result)\n-        return pos + result;\n+    long long size = ReadUInt(pReader, pos, len);\n \n-    end = pos + result;\n+    if (size < 0)  // error\n+      return size;\n \n-    Init();\n+    pos += len;  // consume length of size of element\n \n-    while (pos < end)\n-    {\n-        long long id, size;\n+    // Pos now points to start of payload\n \n-        status = ParseElementHeader(\n-                    pReader,\n-                    pos,\n-                    end,\n-                    id,\n-                    size);\n+    // Handle \""unknown size\"" for live streaming of webm files.\n+    const long long unknown_size = (1LL << (7 * len)) - 1;\n \n-        if (status < 0) //error\n-            return status;\n+    if (id == 0x08538067) {  // Segment ID\n+      if (size == unknown_size)\n+        size = -1;\n \n-        if (size == 0)  //weird\n-            return E_FILE_FORMAT_INVALID;\n+      else if (total < 0)\n+        size = -1;\n \n-        if (id == 0x0286)  //version\n-        {\n-            m_version = UnserializeUInt(pReader, pos, size);\n+      else if ((pos + size) > total)\n+        size = -1;\n \n-            if (m_version <= 0)\n-                return E_FILE_FORMAT_INVALID;\n-        }\n-        else if (id == 0x02F7)  //read version\n-        {\n-            m_readVersion = UnserializeUInt(pReader, pos, size);\n+      pSegment = new (std::nothrow) Segment(pReader, idpos,\n+                                            // elem_size\n+                                            pos, size);\n \n-            if (m_readVersion <= 0)\n-                return E_FILE_FORMAT_INVALID;\n-        }\n-        else if (id == 0x02F2)  //max id length\n-        {\n-            m_maxIdLength = UnserializeUInt(pReader, pos, size);\n+      if (pSegment == 0)\n+        return -1;  // generic error\n \n-            if (m_maxIdLength <= 0)\n-                return E_FILE_FORMAT_INVALID;\n-        }\n-        else if (id == 0x02F3)  //max size length\n-        {\n-            m_maxSizeLength = UnserializeUInt(pReader, pos, size);\n-\n-            if (m_maxSizeLength <= 0)\n-                return E_FILE_FORMAT_INVALID;\n-        }\n-        else if (id == 0x0282)  //doctype\n-        {\n-            if (m_docType)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            status = UnserializeString(pReader, pos, size, m_docType);\n-\n-            if (status)  //error\n-                return status;\n-        }\n-        else if (id == 0x0287)  //doctype version\n-        {\n-            m_docTypeVersion = UnserializeUInt(pReader, pos, size);\n-\n-            if (m_docTypeVersion <= 0)\n-                return E_FILE_FORMAT_INVALID;\n-        }\n-        else if (id == 0x0285)  //doctype read version\n-        {\n-            m_docTypeReadVersion = UnserializeUInt(pReader, pos, size);\n-\n-            if (m_docTypeReadVersion <= 0)\n-                return E_FILE_FORMAT_INVALID;\n-        }\n-\n-        pos += size;\n+      return 0;  // success\n     }\n \n-    assert(pos == end);\n-    return 0;\n+    if (size == unknown_size)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if ((total >= 0) && ((pos + size) > total))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if ((pos + size) > available)\n+      return pos + size;\n+\n+    pos += size;  // consume payload\n+  }\n }\n \n+long long Segment::ParseHeaders() {\n+  // Outermost (level 0) segment object has been constructed,\n+  // and pos designates start of payload.  We need to find the\n+  // inner (level 1) elements.\n+  long long total, available;\n \n-Segment::Segment(\n-    IMkvReader* pReader,\n-    long long elem_start,\n-    //long long elem_size,\n-    long long start,\n-    long long size) :\n-    m_pReader(pReader),\n-    m_element_start(elem_start),\n-    //m_element_size(elem_size),\n-    m_start(start),\n-    m_size(size),\n-    m_pos(start),\n-    m_pUnknownSize(0),\n-    m_pSeekHead(NULL),\n-    m_pInfo(NULL),\n-    m_pTracks(NULL),\n-    m_pCues(NULL),\n-    m_pChapters(NULL),\n-    m_clusters(NULL),\n-    m_clusterCount(0),\n-    m_clusterPreloadCount(0),\n-    m_clusterSize(0)\n-{\n-}\n+  const int status = m_pReader->Length(&total, &available);\n \n+  if (status < 0)  // error\n+    return status;\n \n-Segment::~Segment()\n-{\n-    const long count = m_clusterCount + m_clusterPreloadCount;\n+  assert((total < 0) || (available <= total));\n \n-    Cluster** i = m_clusters;\n-    Cluster** j = m_clusters + count;\n+  const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n+  assert((segment_stop < 0) || (total < 0) || (segment_stop <= total));\n+  assert((segment_stop < 0) || (m_pos <= segment_stop));\n \n-    while (i != j)\n-    {\n-        Cluster* const p = *i++;\n-        assert(p);\n+  for (;;) {\n+    if ((total >= 0) && (m_pos >= total))\n+      break;\n \n-        delete p;\n-    }\n+    if ((segment_stop >= 0) && (m_pos >= segment_stop))\n+      break;\n \n-    delete[] m_clusters;\n+    long long pos = m_pos;\n+    const long long element_start = pos;\n \n-    delete m_pTracks;\n-    delete m_pInfo;\n-    delete m_pCues;\n-    delete m_pChapters;\n-    delete m_pSeekHead;\n-}\n+    if ((pos + 1) > available)\n+      return (pos + 1);\n \n+    long len;\n+    long long result = GetUIntLength(m_pReader, pos, len);\n \n-long long Segment::CreateInstance(\n-    IMkvReader* pReader,\n-    long long pos,\n-    Segment*& pSegment)\n-{\n-    assert(pReader);\n-    assert(pos >= 0);\n+    if (result < 0)  // error\n+      return result;\n \n-    pSegment = NULL;\n+    if (result > 0)  // underflow (weird)\n+      return (pos + 1);\n \n-    long long total, available;\n+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n+      return E_FILE_FORMAT_INVALID;\n \n-    const long status = pReader->Length(&total, &available);\n+    if ((pos + len) > available)\n+      return pos + len;\n \n-    if (status < 0) //error\n-        return status;\n+    const long long idpos = pos;\n+    const long long id = ReadUInt(m_pReader, idpos, len);\n \n-    if (available < 0)\n+    if (id < 0)  // error\n+      return id;\n+\n+    if (id == 0x0F43B675)  // Cluster ID\n+      break;\n+\n+    pos += len;  // consume ID\n+\n+    if ((pos + 1) > available)\n+      return (pos + 1);\n+\n+    // Read Size\n+    result = GetUIntLength(m_pReader, pos, len);\n+\n+    if (result < 0)  // error\n+      return result;\n+\n+    if (result > 0)  // underflow (weird)\n+      return (pos + 1);\n+\n+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if ((pos + len) > available)\n+      return pos + len;\n+\n+    const long long size = ReadUInt(m_pReader, pos, len);\n+\n+    if (size < 0)  // error\n+      return size;\n+\n+    pos += len;  // consume length of size of element\n+\n+    const long long element_size = size + pos - element_start;\n+\n+    // Pos now points to start of payload\n+\n+    if ((segment_stop >= 0) && ((pos + size) > segment_stop))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    // We read EBML elements either in total or nothing at all.\n+\n+    if ((pos + size) > available)\n+      return pos + size;\n+\n+    if (id == 0x0549A966) {  // Segment Info ID\n+      if (m_pInfo)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      m_pInfo = new (std::nothrow)\n+          SegmentInfo(this, pos, size, element_start, element_size);\n+\n+      if (m_pInfo == NULL)\n         return -1;\n \n-    if ((total >= 0) && (available > total))\n+      const long status = m_pInfo->Parse();\n+\n+      if (status)\n+        return status;\n+    } else if (id == 0x0654AE6B) {  // Tracks ID\n+      if (m_pTracks)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      m_pTracks = new (std::nothrow)\n+          Tracks(this, pos, size, element_start, element_size);\n+\n+      if (m_pTracks == NULL)\n         return -1;\n \n-    //I would assume that in practice this loop would execute\n-    //exactly once, but we allow for other elements (e.g. Void)\n-    //to immediately follow the EBML header.  This is fine for\n-    //the source filter case (since the entire file is available),\n-    //but in the splitter case over a network we should probably\n-    //just give up early.  We could for example decide only to\n-    //execute this loop a maximum of, say, 10 times.\n-    //TODO:\n-    //There is an implied \""give up early\"" by only parsing up\n-    //to the available limit.  We do do that, but only if the\n-    //total file size is unknown.  We could decide to always\n-    //use what's available as our limit (irrespective of whether\n-    //we happen to know the total file length).  This would have\n-    //as its sense \""parse this much of the file before giving up\"",\n-    //which a slightly different sense from \""try to parse up to\n-    //10 EMBL elements before giving up\"".\n+      const long status = m_pTracks->Parse();\n \n-    for (;;)\n-    {\n-        if ((total >= 0) && (pos >= total))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        //Read ID\n-        long len;\n-        long long result = GetUIntLength(pReader, pos, len);\n-\n-        if (result)  //error, or too few available bytes\n-            return result;\n-\n-        if ((total >= 0) && ((pos + len) > total))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((pos + len) > available)\n-            return pos + len;\n-\n-        const long long idpos = pos;\n-        const long long id = ReadUInt(pReader, pos, len);\n-\n-        if (id < 0)  //error\n-            return id;\n-\n-        pos += len;  //consume ID\n-\n-        //Read Size\n-\n-        result = GetUIntLength(pReader, pos, len);\n-\n-        if (result)  //error, or too few available bytes\n-            return result;\n-\n-        if ((total >= 0) && ((pos + len) > total))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((pos + len) > available)\n-            return pos + len;\n-\n-        long long size = ReadUInt(pReader, pos, len);\n-\n-        if (size < 0)  //error\n-            return size;\n-\n-        pos += len;  //consume length of size of element\n-\n-        //Pos now points to start of payload\n-\n-        //Handle \""unknown size\"" for live streaming of webm files.\n-        const long long unknown_size = (1LL << (7 * len)) - 1;\n-\n-        if (id == 0x08538067)  //Segment ID\n-        {\n-            if (size == unknown_size)\n-                size = -1;\n-\n-            else if (total < 0)\n-                size = -1;\n-\n-            else if ((pos + size) > total)\n-                size = -1;\n-\n-            pSegment = new (std::nothrow) Segment(\n-                                            pReader,\n-                                            idpos,\n-                                            //elem_size\n-                                            pos,\n-                                            size);\n-\n-            if (pSegment == 0)\n-                return -1;  //generic error\n-\n-            return 0;    //success\n-        }\n-\n-        if (size == unknown_size)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((total >= 0) && ((pos + size) > total))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((pos + size) > available)\n-            return pos + size;\n-\n-        pos += size;  //consume payload\n-    }\n-}\n-\n-\n-long long Segment::ParseHeaders()\n-{\n-    //Outermost (level 0) segment object has been constructed,\n-    //and pos designates start of payload.  We need to find the\n-    //inner (level 1) elements.\n-    long long total, available;\n-\n-    const int status = m_pReader->Length(&total, &available);\n-\n-    if (status < 0) //error\n+      if (status)\n         return status;\n+    } else if (id == 0x0C53BB6B) {  // Cues ID\n+      if (m_pCues == NULL) {\n+        m_pCues = new (std::nothrow)\n+            Cues(this, pos, size, element_start, element_size);\n \n-    assert((total < 0) || (available <= total));\n+        if (m_pCues == NULL)\n+          return -1;\n+      }\n+    } else if (id == 0x014D9B74) {  // SeekHead ID\n+      if (m_pSeekHead == NULL) {\n+        m_pSeekHead = new (std::nothrow)\n+            SeekHead(this, pos, size, element_start, element_size);\n \n-    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n-    assert((segment_stop < 0) || (total < 0) || (segment_stop <= total));\n-    assert((segment_stop < 0) || (m_pos <= segment_stop));\n+        if (m_pSeekHead == NULL)\n+          return -1;\n \n-    for (;;)\n-    {\n-        if ((total >= 0) && (m_pos >= total))\n-            break;\n+        const long status = m_pSeekHead->Parse();\n \n-        if ((segment_stop >= 0) && (m_pos >= segment_stop))\n-            break;\n+        if (status)\n+          return status;\n+      }\n+    } else if (id == 0x0043A770) {  // Chapters ID\n+      if (m_pChapters == NULL) {\n+        m_pChapters = new (std::nothrow)\n+            Chapters(this, pos, size, element_start, element_size);\n \n-        long long pos = m_pos;\n-        const long long element_start = pos;\n+        if (m_pChapters == NULL)\n+          return -1;\n \n-        if ((pos + 1) > available)\n-            return (pos + 1);\n+        const long status = m_pChapters->Parse();\n \n-        long len;\n-        long long result = GetUIntLength(m_pReader, pos, len);\n-\n-        if (result < 0)  //error\n-            return result;\n-\n-        if (result > 0)  //underflow (weird)\n-            return (pos + 1);\n-\n-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((pos + len) > available)\n-            return pos + len;\n-\n-        const long long idpos = pos;\n-        const long long id = ReadUInt(m_pReader, idpos, len);\n-\n-        if (id < 0)  //error\n-            return id;\n-\n-        if (id == 0x0F43B675)  //Cluster ID\n-            break;\n-\n-        pos += len;  //consume ID\n-\n-        if ((pos + 1) > available)\n-            return (pos + 1);\n-\n-        //Read Size\n-        result = GetUIntLength(m_pReader, pos, len);\n-\n-        if (result < 0)  //error\n-            return result;\n-\n-        if (result > 0)  //underflow (weird)\n-            return (pos + 1);\n-\n-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((pos + len) > available)\n-            return pos + len;\n-\n-        const long long size = ReadUInt(m_pReader, pos, len);\n-\n-        if (size < 0)  //error\n-            return size;\n-\n-        pos += len;  //consume length of size of element\n-\n-        const long long element_size = size + pos - element_start;\n-\n-        //Pos now points to start of payload\n-\n-        if ((segment_stop >= 0) && ((pos + size) > segment_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        //We read EBML elements either in total or nothing at all.\n-\n-        if ((pos + size) > available)\n-            return pos + size;\n-\n-        if (id == 0x0549A966)  //Segment Info ID\n-        {\n-            if (m_pInfo)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            m_pInfo = new (std::nothrow) SegmentInfo(\n-                                          this,\n-                                          pos,\n-                                          size,\n-                                          element_start,\n-                                          element_size);\n-\n-            if (m_pInfo == NULL)\n-                return -1;\n-\n-            const long status = m_pInfo->Parse();\n-\n-            if (status)\n-                return status;\n-        }\n-        else if (id == 0x0654AE6B)  //Tracks ID\n-        {\n-            if (m_pTracks)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            m_pTracks = new (std::nothrow) Tracks(this,\n-                                                  pos,\n-                                                  size,\n-                                                  element_start,\n-                                                  element_size);\n-\n-            if (m_pTracks == NULL)\n-                return -1;\n-\n-            const long status = m_pTracks->Parse();\n-\n-            if (status)\n-                return status;\n-        }\n-        else if (id == 0x0C53BB6B)  //Cues ID\n-        {\n-            if (m_pCues == NULL)\n-            {\n-                m_pCues = new (std::nothrow) Cues(\n-                                                this,\n-                                                pos,\n-                                                size,\n-                                                element_start,\n-                                                element_size);\n-\n-                if (m_pCues == NULL)\n-                    return -1;\n-            }\n-        }\n-        else if (id == 0x014D9B74)  //SeekHead ID\n-        {\n-            if (m_pSeekHead == NULL)\n-            {\n-                m_pSeekHead = new (std::nothrow) SeekHead(\n-                                                    this,\n-                                                    pos,\n-                                                    size,\n-                                                    element_start,\n-                                                    element_size);\n-\n-                if (m_pSeekHead == NULL)\n-                    return -1;\n-\n-                const long status = m_pSeekHead->Parse();\n-\n-                if (status)\n-                    return status;\n-            }\n-        }\n-        else if (id == 0x0043A770)  //Chapters ID\n-        {\n-            if (m_pChapters == NULL)\n-            {\n-                m_pChapters = new (std::nothrow) Chapters(\n-                                this,\n-                                pos,\n-                                size,\n-                                element_start,\n-                                element_size);\n-\n-                if (m_pChapters == NULL)\n-                  return -1;\n-\n-                const long status = m_pChapters->Parse();\n-\n-                if (status)\n-                  return status;\n-            }\n-        }\n-\n-        m_pos = pos + size;  //consume payload\n+        if (status)\n+          return status;\n+      }\n     }\n \n-    assert((segment_stop < 0) || (m_pos <= segment_stop));\n+    m_pos = pos + size;  // consume payload\n+  }\n \n-    if (m_pInfo == NULL)  //TODO: liberalize this behavior\n-        return E_FILE_FORMAT_INVALID;\n+  assert((segment_stop < 0) || (m_pos <= segment_stop));\n \n-    if (m_pTracks == NULL)\n-        return E_FILE_FORMAT_INVALID;\n+  if (m_pInfo == NULL)  // TODO: liberalize this behavior\n+    return E_FILE_FORMAT_INVALID;\n \n-    return 0;  //success\n+  if (m_pTracks == NULL)\n+    return E_FILE_FORMAT_INVALID;\n+\n+  return 0;  // success\n }\n \n+long Segment::LoadCluster(long long& pos, long& len) {\n+  for (;;) {\n+    const long result = DoLoadCluster(pos, len);\n \n-long Segment::LoadCluster(\n-    long long& pos,\n-    long& len)\n-{\n-    for (;;)\n-    {\n-        const long result = DoLoadCluster(pos, len);\n+    if (result <= 1)\n+      return result;\n+  }\n+}\n \n-        if (result <= 1)\n-            return result;\n+long Segment::DoLoadCluster(long long& pos, long& len) {\n+  if (m_pos < 0)\n+    return DoLoadClusterUnknownSize(pos, len);\n+\n+  long long total, avail;\n+\n+  long status = m_pReader->Length(&total, &avail);\n+\n+  if (status < 0)  // error\n+    return status;\n+\n+  assert((total < 0) || (avail <= total));\n+\n+  const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n+\n+  long long cluster_off = -1;  // offset relative to start of segment\n+  long long cluster_size = -1;  // size of cluster payload\n+\n+  for (;;) {\n+    if ((total >= 0) && (m_pos >= total))\n+      return 1;  // no more clusters\n+\n+    if ((segment_stop >= 0) && (m_pos >= segment_stop))\n+      return 1;  // no more clusters\n+\n+    pos = m_pos;\n+\n+    // Read ID\n+\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n     }\n-}\n \n+    long long result = GetUIntLength(m_pReader, pos, len);\n \n-long Segment::DoLoadCluster(\n-    long long& pos,\n-    long& len)\n-{\n-    if (m_pos < 0)\n-        return DoLoadClusterUnknownSize(pos, len);\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n \n-    long long total, avail;\n+    if (result > 0)  // weird\n+      return E_BUFFER_NOT_FULL;\n \n-    long status = m_pReader->Length(&total, &avail);\n+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n+      return E_FILE_FORMAT_INVALID;\n \n-    if (status < 0)  //error\n-        return status;\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n \n-    assert((total < 0) || (avail <= total));\n+    const long long idpos = pos;\n+    const long long id = ReadUInt(m_pReader, idpos, len);\n \n-    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n+    if (id < 0)  // error (or underflow)\n+      return static_cast<long>(id);\n \n-    long long cluster_off = -1;   //offset relative to start of segment\n-    long long cluster_size = -1;  //size of cluster payload\n+    pos += len;  // consume ID\n \n-    for (;;)\n-    {\n-        if ((total >= 0) && (m_pos >= total))\n-            return 1;  //no more clusters\n+    // Read Size\n \n-        if ((segment_stop >= 0) && (m_pos >= segment_stop))\n-            return 1;  //no more clusters\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n+    }\n \n-        pos = m_pos;\n+    result = GetUIntLength(m_pReader, pos, len);\n \n-        //Read ID\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n \n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n+    if (result > 0)  // weird\n+      return E_BUFFER_NOT_FULL;\n \n-        long long result = GetUIntLength(m_pReader, pos, len);\n+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n+      return E_FILE_FORMAT_INVALID;\n \n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n \n-        if (result > 0)  //weird\n-            return E_BUFFER_NOT_FULL;\n+    const long long size = ReadUInt(m_pReader, pos, len);\n \n-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n-            return E_FILE_FORMAT_INVALID;\n+    if (size < 0)  // error\n+      return static_cast<long>(size);\n \n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n+    pos += len;  // consume length of size of element\n \n-        const long long idpos = pos;\n-        const long long id = ReadUInt(m_pReader, idpos, len);\n+    // pos now points to start of payload\n \n-        if (id < 0)  //error (or underflow)\n-            return static_cast<long>(id);\n+    if (size == 0) {  // weird\n+      m_pos = pos;\n+      continue;\n+    }\n \n-        pos += len;  //consume ID\n+    const long long unknown_size = (1LL << (7 * len)) - 1;\n \n-        //Read Size\n-\n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        result = GetUIntLength(m_pReader, pos, len);\n-\n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n-\n-        if (result > 0)  //weird\n-            return E_BUFFER_NOT_FULL;\n-\n-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n-\n-        const long long size = ReadUInt(m_pReader, pos, len);\n-\n-        if (size < 0)  //error\n-            return static_cast<long>(size);\n-\n-        pos += len;  //consume length of size of element\n-\n-        //pos now points to start of payload\n-\n-        if (size == 0)  //weird\n-        {\n-            m_pos = pos;\n-            continue;\n-        }\n-\n-        const long long unknown_size = (1LL << (7 * len)) - 1;\n-\n-#if 0  //we must handle this to support live webm\n+#if 0  // we must handle this to support live webm\n         if (size == unknown_size)\n             return E_FILE_FORMAT_INVALID;  //TODO: allow this\n #endif\n \n-        if ((segment_stop >= 0) &&\n-            (size != unknown_size) &&\n-            ((pos + size) > segment_stop))\n-        {\n-            return E_FILE_FORMAT_INVALID;\n-        }\n+    if ((segment_stop >= 0) && (size != unknown_size) &&\n+        ((pos + size) > segment_stop)) {\n+      return E_FILE_FORMAT_INVALID;\n+    }\n \n-#if 0  //commented-out, to support incremental cluster parsing\n+#if 0  // commented-out, to support incremental cluster parsing\n         len = static_cast<long>(size);\n \n         if ((pos + size) > avail)\n             return E_BUFFER_NOT_FULL;\n #endif\n \n-        if (id == 0x0C53BB6B)  //Cues ID\n-        {\n-            if (size == unknown_size)\n-                return E_FILE_FORMAT_INVALID;  //TODO: liberalize\n+    if (id == 0x0C53BB6B) {  // Cues ID\n+      if (size == unknown_size)\n+        return E_FILE_FORMAT_INVALID;  // TODO: liberalize\n \n-            if (m_pCues == NULL)\n-            {\n-                const long long element_size = (pos - idpos) + size;\n+      if (m_pCues == NULL) {\n+        const long long element_size = (pos - idpos) + size;\n \n-                m_pCues = new Cues(this,\n-                                   pos,\n-                                   size,\n-                                   idpos,\n-                                   element_size);\n-                assert(m_pCues);  //TODO\n-            }\n+        m_pCues = new Cues(this, pos, size, idpos, element_size);\n+        assert(m_pCues);  // TODO\n+      }\n \n-            m_pos = pos + size;  //consume payload\n-            continue;\n-        }\n-\n-        if (id != 0x0F43B675)  //Cluster ID\n-        {\n-            if (size == unknown_size)\n-                return E_FILE_FORMAT_INVALID;  //TODO: liberalize\n-\n-            m_pos = pos + size;  //consume payload\n-            continue;\n-        }\n-\n-        //We have a cluster.\n-\n-        cluster_off = idpos - m_start;  //relative pos\n-\n-        if (size != unknown_size)\n-            cluster_size = size;\n-\n-        break;\n+      m_pos = pos + size;  // consume payload\n+      continue;\n     }\n \n-    assert(cluster_off >= 0);  //have cluster\n+    if (id != 0x0F43B675) {  // Cluster ID\n+      if (size == unknown_size)\n+        return E_FILE_FORMAT_INVALID;  // TODO: liberalize\n \n-    long long pos_;\n-    long len_;\n-\n-    status = Cluster::HasBlockEntries(this, cluster_off, pos_, len_);\n-\n-    if (status < 0) //error, or underflow\n-    {\n-        pos = pos_;\n-        len = len_;\n-\n-        return status;\n+      m_pos = pos + size;  // consume payload\n+      continue;\n     }\n \n-    //status == 0 means \""no block entries found\""\n-    //status > 0 means \""found at least one block entry\""\n+    // We have a cluster.\n \n-    //TODO:\n-    //The issue here is that the segment increments its own\n-    //pos ptr past the most recent cluster parsed, and then\n-    //starts from there to parse the next cluster.  If we\n-    //don't know the size of the current cluster, then we\n-    //must either parse its payload (as we do below), looking\n-    //for the cluster (or cues) ID to terminate the parse.\n-    //This isn't really what we want: rather, we really need\n-    //a way to create the curr cluster object immediately.\n-    //The pity is that cluster::parse can determine its own\n-    //boundary, and we largely duplicate that same logic here.\n-    //\n-    //Maybe we need to get rid of our look-ahead preloading\n-    //in source::parse???\n-    //\n-    //As we're parsing the blocks in the curr cluster\n-    //(in cluster::parse), we should have some way to signal\n-    //to the segment that we have determined the boundary,\n-    //so it can adjust its own segment::m_pos member.\n-    //\n-    //The problem is that we're asserting in asyncreadinit,\n-    //because we adjust the pos down to the curr seek pos,\n-    //and the resulting adjusted len is > 2GB.  I'm suspicious\n-    //that this is even correct, but even if it is, we can't\n-    //be loading that much data in the cache anyway.\n+    cluster_off = idpos - m_start;  // relative pos\n \n-    const long idx = m_clusterCount;\n+    if (size != unknown_size)\n+      cluster_size = size;\n \n-    if (m_clusterPreloadCount > 0)\n-    {\n-        assert(idx < m_clusterSize);\n+    break;\n+  }\n \n-        Cluster* const pCluster = m_clusters[idx];\n-        assert(pCluster);\n-        assert(pCluster->m_index < 0);\n+  assert(cluster_off >= 0);  // have cluster\n \n-        const long long off = pCluster->GetPosition();\n-        assert(off >= 0);\n+  long long pos_;\n+  long len_;\n \n-        if (off == cluster_off)  //preloaded already\n-        {\n-            if (status == 0)  //no entries found\n-                return E_FILE_FORMAT_INVALID;\n+  status = Cluster::HasBlockEntries(this, cluster_off, pos_, len_);\n \n-            if (cluster_size >= 0)\n-                pos += cluster_size;\n-            else\n-            {\n-                const long long element_size = pCluster->GetElementSize();\n+  if (status < 0) {  // error, or underflow\n+    pos = pos_;\n+    len = len_;\n \n-                if (element_size <= 0)\n-                    return E_FILE_FORMAT_INVALID;  //TODO: handle this case\n+    return status;\n+  }\n \n-                pos = pCluster->m_element_start + element_size;\n-            }\n+  // status == 0 means \""no block entries found\""\n+  // status > 0 means \""found at least one block entry\""\n \n-            pCluster->m_index = idx;  //move from preloaded to loaded\n-            ++m_clusterCount;\n-            --m_clusterPreloadCount;\n+  // TODO:\n+  // The issue here is that the segment increments its own\n+  // pos ptr past the most recent cluster parsed, and then\n+  // starts from there to parse the next cluster.  If we\n+  // don't know the size of the current cluster, then we\n+  // must either parse its payload (as we do below), looking\n+  // for the cluster (or cues) ID to terminate the parse.\n+  // This isn't really what we want: rather, we really need\n+  // a way to create the curr cluster object immediately.\n+  // The pity is that cluster::parse can determine its own\n+  // boundary, and we largely duplicate that same logic here.\n+  //\n+  // Maybe we need to get rid of our look-ahead preloading\n+  // in source::parse???\n+  //\n+  // As we're parsing the blocks in the curr cluster\n+  //(in cluster::parse), we should have some way to signal\n+  // to the segment that we have determined the boundary,\n+  // so it can adjust its own segment::m_pos member.\n+  //\n+  // The problem is that we're asserting in asyncreadinit,\n+  // because we adjust the pos down to the curr seek pos,\n+  // and the resulting adjusted len is > 2GB.  I'm suspicious\n+  // that this is even correct, but even if it is, we can't\n+  // be loading that much data in the cache anyway.\n \n-            m_pos = pos;  //consume payload\n-            assert((segment_stop < 0) || (m_pos <= segment_stop));\n+  const long idx = m_clusterCount;\n \n-            return 0;  //success\n-        }\n-    }\n-\n-    if (status == 0)  //no entries found\n-    {\n-        if (cluster_size < 0)\n-            return E_FILE_FORMAT_INVALID;  //TODO: handle this\n-\n-        pos += cluster_size;\n-\n-        if ((total >= 0) && (pos >= total))\n-        {\n-            m_pos = total;\n-            return 1;  //no more clusters\n-        }\n-\n-        if ((segment_stop >= 0) && (pos >= segment_stop))\n-        {\n-            m_pos = segment_stop;\n-            return 1;  //no more clusters\n-        }\n-\n-        m_pos = pos;\n-        return 2;  //try again\n-    }\n-\n-    //status > 0 means we have an entry\n-\n-    Cluster* const pCluster = Cluster::Create(this,\n-                                              idx,\n-                                              cluster_off);\n-                                              //element_size);\n-    assert(pCluster);\n-\n-    AppendCluster(pCluster);\n-    assert(m_clusters);\n+  if (m_clusterPreloadCount > 0) {\n     assert(idx < m_clusterSize);\n-    assert(m_clusters[idx] == pCluster);\n \n-    if (cluster_size >= 0)\n-    {\n+    Cluster* const pCluster = m_clusters[idx];\n+    assert(pCluster);\n+    assert(pCluster->m_index < 0);\n+\n+    const long long off = pCluster->GetPosition();\n+    assert(off >= 0);\n+\n+    if (off == cluster_off) {  // preloaded already\n+      if (status == 0)  // no entries found\n+        return E_FILE_FORMAT_INVALID;\n+\n+      if (cluster_size >= 0)\n         pos += cluster_size;\n+      else {\n+        const long long element_size = pCluster->GetElementSize();\n \n-        m_pos = pos;\n-        assert((segment_stop < 0) || (m_pos <= segment_stop));\n+        if (element_size <= 0)\n+          return E_FILE_FORMAT_INVALID;  // TODO: handle this case\n \n-        return 0;\n+        pos = pCluster->m_element_start + element_size;\n+      }\n+\n+      pCluster->m_index = idx;  // move from preloaded to loaded\n+      ++m_clusterCount;\n+      --m_clusterPreloadCount;\n+\n+      m_pos = pos;  // consume payload\n+      assert((segment_stop < 0) || (m_pos <= segment_stop));\n+\n+      return 0;  // success\n+    }\n+  }\n+\n+  if (status == 0) {  // no entries found\n+    if (cluster_size < 0)\n+      return E_FILE_FORMAT_INVALID;  // TODO: handle this\n+\n+    pos += cluster_size;\n+\n+    if ((total >= 0) && (pos >= total)) {\n+      m_pos = total;\n+      return 1;  // no more clusters\n     }\n \n-    m_pUnknownSize = pCluster;\n-    m_pos = -pos;\n+    if ((segment_stop >= 0) && (pos >= segment_stop)) {\n+      m_pos = segment_stop;\n+      return 1;  // no more clusters\n+    }\n \n-    return 0;  //partial success, since we have a new cluster\n+    m_pos = pos;\n+    return 2;  // try again\n+  }\n \n-    //status == 0 means \""no block entries found\""\n+  // status > 0 means we have an entry\n \n-    //pos designates start of payload\n-    //m_pos has NOT been adjusted yet (in case we need to come back here)\n+  Cluster* const pCluster = Cluster::Create(this, idx, cluster_off);\n+  // element_size);\n+  assert(pCluster);\n+\n+  AppendCluster(pCluster);\n+  assert(m_clusters);\n+  assert(idx < m_clusterSize);\n+  assert(m_clusters[idx] == pCluster);\n+\n+  if (cluster_size >= 0) {\n+    pos += cluster_size;\n+\n+    m_pos = pos;\n+    assert((segment_stop < 0) || (m_pos <= segment_stop));\n+\n+    return 0;\n+  }\n+\n+  m_pUnknownSize = pCluster;\n+  m_pos = -pos;\n+\n+  return 0;  // partial success, since we have a new cluster\n+\n+// status == 0 means \""no block entries found\""\n+\n+// pos designates start of payload\n+// m_pos has NOT been adjusted yet (in case we need to come back here)\n \n #if 0\n \n-    if (cluster_size < 0)  //unknown size\n-    {\n+    if (cluster_size < 0) {  //unknown size\n         const long long payload_pos = pos;  //absolute pos of cluster payload\n \n-        for (;;)  //determine cluster size\n-        {\n+        for (;;) {  //determine cluster size\n             if ((total >= 0) && (pos >= total))\n                 break;\n \n@@ -1518,16 +1346,11 @@\n\n     return 2;     //try to find another cluster\n \n #endif\n-\n }\n \n-\n-long Segment::DoLoadClusterUnknownSize(\n-    long long& pos,\n-    long& len)\n-{\n-    assert(m_pos < 0);\n-    assert(m_pUnknownSize);\n+long Segment::DoLoadClusterUnknownSize(long long& pos, long& len) {\n+  assert(m_pos < 0);\n+  assert(m_pUnknownSize);\n \n #if 0\n     assert(m_pUnknownSize->GetElementSize() < 0);  //TODO: verify this\n@@ -1554,8 +1377,7 @@\n\n \n     long long element_size = -1;\n \n-    for (;;)  //determine cluster size\n-    {\n+    for (;;) {  //determine cluster size\n         if ((total >= 0) && (pos >= total))\n         {\n             element_size = total - element_start;\n@@ -1604,8 +1426,7 @@\n\n         //that we have exhausted the sub-element's inside the cluster\n         //whose ID we parsed earlier.\n \n-        if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) //Cluster ID or Cues ID\n-        {\n+        if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) {  //Cluster ID or Cues ID\n             element_size = pos - element_start;\n             assert(element_size > 0);\n \n@@ -1682,348 +1503,299 @@\n\n \n     return 2;  //continue parsing\n #else\n-    const long status = m_pUnknownSize->Parse(pos, len);\n+  const long status = m_pUnknownSize->Parse(pos, len);\n \n-    if (status < 0)  //error or underflow\n-        return status;\n+  if (status < 0)  // error or underflow\n+    return status;\n \n-    if (status == 0)  //parsed a block\n-        return 2;     //continue parsing\n+  if (status == 0)  // parsed a block\n+    return 2;  // continue parsing\n \n-    assert(status > 0);   //nothing left to parse of this cluster\n+  assert(status > 0);  // nothing left to parse of this cluster\n \n-    const long long start = m_pUnknownSize->m_element_start;\n+  const long long start = m_pUnknownSize->m_element_start;\n \n-    const long long size = m_pUnknownSize->GetElementSize();\n-    assert(size >= 0);\n+  const long long size = m_pUnknownSize->GetElementSize();\n+  assert(size >= 0);\n \n-    pos = start + size;\n-    m_pos = pos;\n+  pos = start + size;\n+  m_pos = pos;\n \n-    m_pUnknownSize = 0;\n+  m_pUnknownSize = 0;\n \n-    return 2;  //continue parsing\n+  return 2;  // continue parsing\n #endif\n }\n \n+void Segment::AppendCluster(Cluster* pCluster) {\n+  assert(pCluster);\n+  assert(pCluster->m_index >= 0);\n \n-void Segment::AppendCluster(Cluster* pCluster)\n-{\n-    assert(pCluster);\n-    assert(pCluster->m_index >= 0);\n+  const long count = m_clusterCount + m_clusterPreloadCount;\n \n-    const long count = m_clusterCount + m_clusterPreloadCount;\n+  long& size = m_clusterSize;\n+  assert(size >= count);\n \n-    long& size = m_clusterSize;\n-    assert(size >= count);\n+  const long idx = pCluster->m_index;\n+  assert(idx == m_clusterCount);\n \n-    const long idx = pCluster->m_index;\n-    assert(idx == m_clusterCount);\n+  if (count >= size) {\n+    const long n = (size <= 0) ? 2048 : 2 * size;\n \n-    if (count >= size)\n-    {\n-        const long n = (size <= 0) ? 2048 : 2*size;\n+    Cluster** const qq = new Cluster* [n];\n+    Cluster** q = qq;\n \n-        Cluster** const qq = new Cluster*[n];\n-        Cluster** q = qq;\n+    Cluster** p = m_clusters;\n+    Cluster** const pp = p + count;\n \n-        Cluster** p = m_clusters;\n-        Cluster** const pp = p + count;\n+    while (p != pp)\n+      *q++ = *p++;\n \n-        while (p != pp)\n-            *q++ = *p++;\n+    delete[] m_clusters;\n \n-        delete[] m_clusters;\n+    m_clusters = qq;\n+    size = n;\n+  }\n \n-        m_clusters = qq;\n-        size = n;\n-    }\n-\n-    if (m_clusterPreloadCount > 0)\n-    {\n-        assert(m_clusters);\n-\n-        Cluster** const p = m_clusters + m_clusterCount;\n-        assert(*p);\n-        assert((*p)->m_index < 0);\n-\n-        Cluster** q = p + m_clusterPreloadCount;\n-        assert(q < (m_clusters + size));\n-\n-        for (;;)\n-        {\n-            Cluster** const qq = q - 1;\n-            assert((*qq)->m_index < 0);\n-\n-            *q = *qq;\n-            q = qq;\n-\n-            if (q == p)\n-                break;\n-        }\n-    }\n-\n-    m_clusters[idx] = pCluster;\n-    ++m_clusterCount;\n-}\n-\n-\n-void Segment::PreloadCluster(Cluster* pCluster, ptrdiff_t idx)\n-{\n-    assert(pCluster);\n-    assert(pCluster->m_index < 0);\n-    assert(idx >= m_clusterCount);\n-\n-    const long count = m_clusterCount + m_clusterPreloadCount;\n-\n-    long& size = m_clusterSize;\n-    assert(size >= count);\n-\n-    if (count >= size)\n-    {\n-        const long n = (size <= 0) ? 2048 : 2*size;\n-\n-        Cluster** const qq = new Cluster*[n];\n-        Cluster** q = qq;\n-\n-        Cluster** p = m_clusters;\n-        Cluster** const pp = p + count;\n-\n-        while (p != pp)\n-            *q++ = *p++;\n-\n-        delete[] m_clusters;\n-\n-        m_clusters = qq;\n-        size = n;\n-    }\n-\n+  if (m_clusterPreloadCount > 0) {\n     assert(m_clusters);\n \n-    Cluster** const p = m_clusters + idx;\n+    Cluster** const p = m_clusters + m_clusterCount;\n+    assert(*p);\n+    assert((*p)->m_index < 0);\n \n-    Cluster** q = m_clusters + count;\n-    assert(q >= p);\n+    Cluster** q = p + m_clusterPreloadCount;\n     assert(q < (m_clusters + size));\n \n-    while (q > p)\n-    {\n-        Cluster** const qq = q - 1;\n-        assert((*qq)->m_index < 0);\n+    for (;;) {\n+      Cluster** const qq = q - 1;\n+      assert((*qq)->m_index < 0);\n \n-        *q = *qq;\n-        q = qq;\n+      *q = *qq;\n+      q = qq;\n+\n+      if (q == p)\n+        break;\n     }\n+  }\n \n-    m_clusters[idx] = pCluster;\n-    ++m_clusterPreloadCount;\n+  m_clusters[idx] = pCluster;\n+  ++m_clusterCount;\n }\n \n+void Segment::PreloadCluster(Cluster* pCluster, ptrdiff_t idx) {\n+  assert(pCluster);\n+  assert(pCluster->m_index < 0);\n+  assert(idx >= m_clusterCount);\n \n-long Segment::Load()\n-{\n-    assert(m_clusters == NULL);\n-    assert(m_clusterSize == 0);\n-    assert(m_clusterCount == 0);\n-    //assert(m_size >= 0);\n+  const long count = m_clusterCount + m_clusterPreloadCount;\n \n-    //Outermost (level 0) segment object has been constructed,\n-    //and pos designates start of payload.  We need to find the\n-    //inner (level 1) elements.\n+  long& size = m_clusterSize;\n+  assert(size >= count);\n \n-    const long long header_status = ParseHeaders();\n+  if (count >= size) {\n+    const long n = (size <= 0) ? 2048 : 2 * size;\n \n-    if (header_status < 0)  //error\n-        return static_cast<long>(header_status);\n+    Cluster** const qq = new Cluster* [n];\n+    Cluster** q = qq;\n \n-    if (header_status > 0)  //underflow\n-        return E_BUFFER_NOT_FULL;\n+    Cluster** p = m_clusters;\n+    Cluster** const pp = p + count;\n \n-    assert(m_pInfo);\n-    assert(m_pTracks);\n+    while (p != pp)\n+      *q++ = *p++;\n \n-    for (;;)\n-    {\n-        const int status = LoadCluster();\n+    delete[] m_clusters;\n \n-        if (status < 0)  //error\n-            return status;\n+    m_clusters = qq;\n+    size = n;\n+  }\n \n-        if (status >= 1)  //no more clusters\n-            return 0;\n-    }\n+  assert(m_clusters);\n+\n+  Cluster** const p = m_clusters + idx;\n+\n+  Cluster** q = m_clusters + count;\n+  assert(q >= p);\n+  assert(q < (m_clusters + size));\n+\n+  while (q > p) {\n+    Cluster** const qq = q - 1;\n+    assert((*qq)->m_index < 0);\n+\n+    *q = *qq;\n+    q = qq;\n+  }\n+\n+  m_clusters[idx] = pCluster;\n+  ++m_clusterPreloadCount;\n }\n \n+long Segment::Load() {\n+  assert(m_clusters == NULL);\n+  assert(m_clusterSize == 0);\n+  assert(m_clusterCount == 0);\n+  // assert(m_size >= 0);\n \n-SeekHead::SeekHead(\n-    Segment* pSegment,\n-    long long start,\n-    long long size_,\n-    long long element_start,\n-    long long element_size) :\n-    m_pSegment(pSegment),\n-    m_start(start),\n-    m_size(size_),\n-    m_element_start(element_start),\n-    m_element_size(element_size),\n-    m_entries(0),\n-    m_entry_count(0),\n-    m_void_elements(0),\n-    m_void_element_count(0)\n-{\n+  // Outermost (level 0) segment object has been constructed,\n+  // and pos designates start of payload.  We need to find the\n+  // inner (level 1) elements.\n+\n+  const long long header_status = ParseHeaders();\n+\n+  if (header_status < 0)  // error\n+    return static_cast<long>(header_status);\n+\n+  if (header_status > 0)  // underflow\n+    return E_BUFFER_NOT_FULL;\n+\n+  assert(m_pInfo);\n+  assert(m_pTracks);\n+\n+  for (;;) {\n+    const int status = LoadCluster();\n+\n+    if (status < 0)  // error\n+      return status;\n+\n+    if (status >= 1)  // no more clusters\n+      return 0;\n+  }\n }\n \n+SeekHead::SeekHead(Segment* pSegment, long long start, long long size_,\n+                   long long element_start, long long element_size)\n+    : m_pSegment(pSegment),\n+      m_start(start),\n+      m_size(size_),\n+      m_element_start(element_start),\n+      m_element_size(element_size),\n+      m_entries(0),\n+      m_entry_count(0),\n+      m_void_elements(0),\n+      m_void_element_count(0) {}\n \n-SeekHead::~SeekHead()\n-{\n-    delete[] m_entries;\n-    delete[] m_void_elements;\n+SeekHead::~SeekHead() {\n+  delete[] m_entries;\n+  delete[] m_void_elements;\n }\n \n+long SeekHead::Parse() {\n+  IMkvReader* const pReader = m_pSegment->m_pReader;\n \n-long SeekHead::Parse()\n-{\n-    IMkvReader* const pReader = m_pSegment->m_pReader;\n+  long long pos = m_start;\n+  const long long stop = m_start + m_size;\n \n-    long long pos = m_start;\n-    const long long stop = m_start + m_size;\n+  // first count the seek head entries\n \n-    //first count the seek head entries\n+  int entry_count = 0;\n+  int void_element_count = 0;\n \n-    int entry_count = 0;\n-    int void_element_count = 0;\n+  while (pos < stop) {\n+    long long id, size;\n \n-    while (pos < stop)\n-    {\n-        long long id, size;\n+    const long status = ParseElementHeader(pReader, pos, stop, id, size);\n \n-        const long status = ParseElementHeader(\n-                                pReader,\n-                                pos,\n-                                stop,\n-                                id,\n-                                size);\n+    if (status < 0)  // error\n+      return status;\n \n-        if (status < 0)  //error\n-            return status;\n+    if (id == 0x0DBB)  // SeekEntry ID\n+      ++entry_count;\n+    else if (id == 0x6C)  // Void ID\n+      ++void_element_count;\n \n-        if (id == 0x0DBB)  //SeekEntry ID\n-            ++entry_count;\n-        else if (id == 0x6C)  //Void ID\n-            ++void_element_count;\n+    pos += size;  // consume payload\n+    assert(pos <= stop);\n+  }\n \n-        pos += size;  //consume payload\n-        assert(pos <= stop);\n+  assert(pos == stop);\n+\n+  m_entries = new (std::nothrow) Entry[entry_count];\n+\n+  if (m_entries == NULL)\n+    return -1;\n+\n+  m_void_elements = new (std::nothrow) VoidElement[void_element_count];\n+\n+  if (m_void_elements == NULL)\n+    return -1;\n+\n+  // now parse the entries and void elements\n+\n+  Entry* pEntry = m_entries;\n+  VoidElement* pVoidElement = m_void_elements;\n+\n+  pos = m_start;\n+\n+  while (pos < stop) {\n+    const long long idpos = pos;\n+\n+    long long id, size;\n+\n+    const long status = ParseElementHeader(pReader, pos, stop, id, size);\n+\n+    if (status < 0)  // error\n+      return status;\n+\n+    if (id == 0x0DBB) {  // SeekEntry ID\n+      if (ParseEntry(pReader, pos, size, pEntry)) {\n+        Entry& e = *pEntry++;\n+\n+        e.element_start = idpos;\n+        e.element_size = (pos + size) - idpos;\n+      }\n+    } else if (id == 0x6C) {  // Void ID\n+      VoidElement& e = *pVoidElement++;\n+\n+      e.element_start = idpos;\n+      e.element_size = (pos + size) - idpos;\n     }\n \n-    assert(pos == stop);\n+    pos += size;  // consume payload\n+    assert(pos <= stop);\n+  }\n \n-    m_entries = new (std::nothrow) Entry[entry_count];\n+  assert(pos == stop);\n \n-    if (m_entries == NULL)\n-        return -1;\n+  ptrdiff_t count_ = ptrdiff_t(pEntry - m_entries);\n+  assert(count_ >= 0);\n+  assert(count_ <= entry_count);\n \n-    m_void_elements = new (std::nothrow) VoidElement[void_element_count];\n+  m_entry_count = static_cast<int>(count_);\n \n-    if (m_void_elements == NULL)\n-        return -1;\n+  count_ = ptrdiff_t(pVoidElement - m_void_elements);\n+  assert(count_ >= 0);\n+  assert(count_ <= void_element_count);\n \n-    //now parse the entries and void elements\n+  m_void_element_count = static_cast<int>(count_);\n \n-    Entry* pEntry = m_entries;\n-    VoidElement* pVoidElement = m_void_elements;\n+  return 0;\n+}\n \n-    pos = m_start;\n+int SeekHead::GetCount() const { return m_entry_count; }\n \n-    while (pos < stop)\n-    {\n-        const long long idpos = pos;\n-\n-        long long id, size;\n-\n-        const long status = ParseElementHeader(\n-                                pReader,\n-                                pos,\n-                                stop,\n-                                id,\n-                                size);\n-\n-        if (status < 0)  //error\n-            return status;\n-\n-        if (id == 0x0DBB)  //SeekEntry ID\n-        {\n-            if (ParseEntry(pReader, pos, size, pEntry))\n-            {\n-                Entry& e = *pEntry++;\n-\n-                e.element_start = idpos;\n-                e.element_size = (pos + size) - idpos;\n-            }\n-        }\n-        else if (id == 0x6C)  //Void ID\n-        {\n-            VoidElement& e = *pVoidElement++;\n-\n-            e.element_start = idpos;\n-            e.element_size = (pos + size) - idpos;\n-        }\n-\n-        pos += size;  //consume payload\n-        assert(pos <= stop);\n-    }\n-\n-    assert(pos == stop);\n-\n-    ptrdiff_t count_ = ptrdiff_t(pEntry - m_entries);\n-    assert(count_ >= 0);\n-    assert(count_ <= entry_count);\n-\n-    m_entry_count = static_cast<int>(count_);\n-\n-    count_ = ptrdiff_t(pVoidElement - m_void_elements);\n-    assert(count_ >= 0);\n-    assert(count_ <= void_element_count);\n-\n-    m_void_element_count = static_cast<int>(count_);\n-\n+const SeekHead::Entry* SeekHead::GetEntry(int idx) const {\n+  if (idx < 0)\n     return 0;\n+\n+  if (idx >= m_entry_count)\n+    return 0;\n+\n+  return m_entries + idx;\n }\n \n+int SeekHead::GetVoidElementCount() const { return m_void_element_count; }\n \n-int SeekHead::GetCount() const\n-{\n-    return m_entry_count;\n+const SeekHead::VoidElement* SeekHead::GetVoidElement(int idx) const {\n+  if (idx < 0)\n+    return 0;\n+\n+  if (idx >= m_void_element_count)\n+    return 0;\n+\n+  return m_void_elements + idx;\n }\n \n-const SeekHead::Entry* SeekHead::GetEntry(int idx) const\n-{\n-    if (idx < 0)\n-        return 0;\n-\n-    if (idx >= m_entry_count)\n-        return 0;\n-\n-    return m_entries + idx;\n-}\n-\n-int SeekHead::GetVoidElementCount() const\n-{\n-    return m_void_element_count;\n-}\n-\n-const SeekHead::VoidElement* SeekHead::GetVoidElement(int idx) const\n-{\n-    if (idx < 0)\n-        return 0;\n-\n-    if (idx >= m_void_element_count)\n-        return 0;\n-\n-    return m_void_elements + idx;\n-}\n-\n-\n #if 0\n void Segment::ParseCues(long long off)\n {\n@@ -2073,133 +1845,122 @@\n\n     //os << \""Segment::ParseCues (end)\"" << endl;\n }\n #else\n-long Segment::ParseCues(\n-    long long off,\n-    long long& pos,\n-    long& len)\n-{\n-    if (m_pCues)\n-        return 0;  //success\n+long Segment::ParseCues(long long off, long long& pos, long& len) {\n+  if (m_pCues)\n+    return 0;  // success\n \n-    if (off < 0)\n-        return -1;\n+  if (off < 0)\n+    return -1;\n \n-    long long total, avail;\n+  long long total, avail;\n \n-    const int status = m_pReader->Length(&total, &avail);\n+  const int status = m_pReader->Length(&total, &avail);\n \n-    if (status < 0)  //error\n-        return status;\n+  if (status < 0)  // error\n+    return status;\n \n-    assert((total < 0) || (avail <= total));\n+  assert((total < 0) || (avail <= total));\n \n-    pos = m_start + off;\n+  pos = m_start + off;\n \n-    if ((total < 0) || (pos >= total))\n-        return 1;  //don't bother parsing cues\n+  if ((total < 0) || (pos >= total))\n+    return 1;  // don't bother parsing cues\n \n-    const long long element_start = pos;\n-    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n+  const long long element_start = pos;\n+  const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n \n-    if ((pos + 1) > avail)\n-    {\n-        len = 1;\n-        return E_BUFFER_NOT_FULL;\n-    }\n+  if ((pos + 1) > avail) {\n+    len = 1;\n+    return E_BUFFER_NOT_FULL;\n+  }\n \n-    long long result = GetUIntLength(m_pReader, pos, len);\n+  long long result = GetUIntLength(m_pReader, pos, len);\n \n-    if (result < 0)  //error\n-        return static_cast<long>(result);\n+  if (result < 0)  // error\n+    return static_cast<long>(result);\n \n-    if (result > 0) //underflow (weird)\n-    {\n-        len = 1;\n-        return E_BUFFER_NOT_FULL;\n-    }\n+  if (result > 0)  // underflow (weird)\n+  {\n+    len = 1;\n+    return E_BUFFER_NOT_FULL;\n+  }\n \n-    if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n-        return E_FILE_FORMAT_INVALID;\n+  if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n+    return E_FILE_FORMAT_INVALID;\n \n-    if ((pos + len) > avail)\n-        return E_BUFFER_NOT_FULL;\n+  if ((pos + len) > avail)\n+    return E_BUFFER_NOT_FULL;\n \n-    const long long idpos = pos;\n+  const long long idpos = pos;\n \n-    const long long id = ReadUInt(m_pReader, idpos, len);\n+  const long long id = ReadUInt(m_pReader, idpos, len);\n \n-    if (id != 0x0C53BB6B)  //Cues ID\n-        return E_FILE_FORMAT_INVALID;\n+  if (id != 0x0C53BB6B)  // Cues ID\n+    return E_FILE_FORMAT_INVALID;\n \n-    pos += len;  //consume ID\n-    assert((segment_stop < 0) || (pos <= segment_stop));\n+  pos += len;  // consume ID\n+  assert((segment_stop < 0) || (pos <= segment_stop));\n \n-    //Read Size\n+  // Read Size\n \n-    if ((pos + 1) > avail)\n-    {\n-        len = 1;\n-        return E_BUFFER_NOT_FULL;\n-    }\n+  if ((pos + 1) > avail) {\n+    len = 1;\n+    return E_BUFFER_NOT_FULL;\n+  }\n \n-    result = GetUIntLength(m_pReader, pos, len);\n+  result = GetUIntLength(m_pReader, pos, len);\n \n-    if (result < 0)  //error\n-        return static_cast<long>(result);\n+  if (result < 0)  // error\n+    return static_cast<long>(result);\n \n-    if (result > 0) //underflow (weird)\n-    {\n-        len = 1;\n-        return E_BUFFER_NOT_FULL;\n-    }\n+  if (result > 0)  // underflow (weird)\n+  {\n+    len = 1;\n+    return E_BUFFER_NOT_FULL;\n+  }\n \n-    if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n-        return E_FILE_FORMAT_INVALID;\n+  if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n+    return E_FILE_FORMAT_INVALID;\n \n-    if ((pos + len) > avail)\n-        return E_BUFFER_NOT_FULL;\n+  if ((pos + len) > avail)\n+    return E_BUFFER_NOT_FULL;\n \n-    const long long size = ReadUInt(m_pReader, pos, len);\n+  const long long size = ReadUInt(m_pReader, pos, len);\n \n-    if (size < 0)  //error\n-        return static_cast<long>(size);\n+  if (size < 0)  // error\n+    return static_cast<long>(size);\n \n-    if (size == 0)  //weird, although technically not illegal\n-        return 1;   //done\n+  if (size == 0)  // weird, although technically not illegal\n+    return 1;  // done\n \n-    pos += len;  //consume length of size of element\n-    assert((segment_stop < 0) || (pos <= segment_stop));\n+  pos += len;  // consume length of size of element\n+  assert((segment_stop < 0) || (pos <= segment_stop));\n \n-    //Pos now points to start of payload\n+  // Pos now points to start of payload\n \n-    const long long element_stop = pos + size;\n+  const long long element_stop = pos + size;\n \n-    if ((segment_stop >= 0) && (element_stop > segment_stop))\n-        return E_FILE_FORMAT_INVALID;\n+  if ((segment_stop >= 0) && (element_stop > segment_stop))\n+    return E_FILE_FORMAT_INVALID;\n \n-    if ((total >= 0) && (element_stop > total))\n-        return 1;  //don't bother parsing anymore\n+  if ((total >= 0) && (element_stop > total))\n+    return 1;  // don't bother parsing anymore\n \n-    len = static_cast<long>(size);\n+  len = static_cast<long>(size);\n \n-    if (element_stop > avail)\n-        return E_BUFFER_NOT_FULL;\n+  if (element_stop > avail)\n+    return E_BUFFER_NOT_FULL;\n \n-    const long long element_size = element_stop - element_start;\n+  const long long element_size = element_stop - element_start;\n \n-    m_pCues = new (std::nothrow) Cues(\n-                                    this,\n-                                    pos,\n-                                    size,\n-                                    element_start,\n-                                    element_size);\n-    assert(m_pCues);  //TODO\n+  m_pCues =\n+      new (std::nothrow) Cues(this, pos, size, element_start, element_size);\n+  assert(m_pCues);  // TODO\n \n-    return 0;  //success\n+  return 0;  // success\n }\n #endif\n \n-\n #if 0\n void Segment::ParseSeekEntry(\n     long long start,\n@@ -2259,304 +2020,269 @@\n\n         ParseCues(seekOff);\n }\n #else\n-bool SeekHead::ParseEntry(\n-    IMkvReader* pReader,\n-    long long start,\n-    long long size_,\n-    Entry* pEntry)\n-{\n-    if (size_ <= 0)\n-        return false;\n+bool SeekHead::ParseEntry(IMkvReader* pReader, long long start, long long size_,\n+                          Entry* pEntry) {\n+  if (size_ <= 0)\n+    return false;\n \n-    long long pos = start;\n-    const long long stop = start + size_;\n+  long long pos = start;\n+  const long long stop = start + size_;\n \n-    long len;\n+  long len;\n \n-    //parse the container for the level-1 element ID\n+  // parse the container for the level-1 element ID\n \n-    const long long seekIdId = ReadUInt(pReader, pos, len);\n-    //seekIdId;\n+  const long long seekIdId = ReadUInt(pReader, pos, len);\n+  // seekIdId;\n \n-    if (seekIdId != 0x13AB)  //SeekID ID\n-        return false;\n+  if (seekIdId != 0x13AB)  // SeekID ID\n+    return false;\n \n-    if ((pos + len) > stop)\n-        return false;\n+  if ((pos + len) > stop)\n+    return false;\n \n-    pos += len;  //consume SeekID id\n+  pos += len;  // consume SeekID id\n \n-    const long long seekIdSize = ReadUInt(pReader, pos, len);\n+  const long long seekIdSize = ReadUInt(pReader, pos, len);\n \n-    if (seekIdSize <= 0)\n-        return false;\n+  if (seekIdSize <= 0)\n+    return false;\n \n-    if ((pos + len) > stop)\n-        return false;\n+  if ((pos + len) > stop)\n+    return false;\n \n-    pos += len;  //consume size of field\n+  pos += len;  // consume size of field\n \n-    if ((pos + seekIdSize) > stop)\n-        return false;\n+  if ((pos + seekIdSize) > stop)\n+    return false;\n \n-    //Note that the SeekId payload really is serialized\n-    //as a \""Matroska integer\"", not as a plain binary value.\n-    //In fact, Matroska requires that ID values in the\n-    //stream exactly match the binary representation as listed\n-    //in the Matroska specification.\n-    //\n-    //This parser is more liberal, and permits IDs to have\n-    //any width.  (This could make the representation in the stream\n-    //different from what's in the spec, but it doesn't matter here,\n-    //since we always normalize \""Matroska integer\"" values.)\n+  // Note that the SeekId payload really is serialized\n+  // as a \""Matroska integer\"", not as a plain binary value.\n+  // In fact, Matroska requires that ID values in the\n+  // stream exactly match the binary representation as listed\n+  // in the Matroska specification.\n+  //\n+  // This parser is more liberal, and permits IDs to have\n+  // any width.  (This could make the representation in the stream\n+  // different from what's in the spec, but it doesn't matter here,\n+  // since we always normalize \""Matroska integer\"" values.)\n \n-    pEntry->id = ReadUInt(pReader, pos, len);  //payload\n+  pEntry->id = ReadUInt(pReader, pos, len);  // payload\n \n-    if (pEntry->id <= 0)\n-        return false;\n+  if (pEntry->id <= 0)\n+    return false;\n \n-    if (len != seekIdSize)\n-        return false;\n+  if (len != seekIdSize)\n+    return false;\n \n-    pos += seekIdSize;  //consume SeekID payload\n+  pos += seekIdSize;  // consume SeekID payload\n \n-    const long long seekPosId = ReadUInt(pReader, pos, len);\n+  const long long seekPosId = ReadUInt(pReader, pos, len);\n \n-    if (seekPosId != 0x13AC)  //SeekPos ID\n-        return false;\n+  if (seekPosId != 0x13AC)  // SeekPos ID\n+    return false;\n \n-    if ((pos + len) > stop)\n-        return false;\n+  if ((pos + len) > stop)\n+    return false;\n \n-    pos += len;  //consume id\n+  pos += len;  // consume id\n \n-    const long long seekPosSize = ReadUInt(pReader, pos, len);\n+  const long long seekPosSize = ReadUInt(pReader, pos, len);\n \n-    if (seekPosSize <= 0)\n-        return false;\n+  if (seekPosSize <= 0)\n+    return false;\n \n-    if ((pos + len) > stop)\n-        return false;\n+  if ((pos + len) > stop)\n+    return false;\n \n-    pos += len;  //consume size\n+  pos += len;  // consume size\n \n-    if ((pos + seekPosSize) > stop)\n-        return false;\n+  if ((pos + seekPosSize) > stop)\n+    return false;\n \n-    pEntry->pos = UnserializeUInt(pReader, pos, seekPosSize);\n+  pEntry->pos = UnserializeUInt(pReader, pos, seekPosSize);\n \n-    if (pEntry->pos < 0)\n-        return false;\n+  if (pEntry->pos < 0)\n+    return false;\n \n-    pos += seekPosSize;  //consume payload\n+  pos += seekPosSize;  // consume payload\n \n-    if (pos != stop)\n-        return false;\n+  if (pos != stop)\n+    return false;\n \n-    return true;\n+  return true;\n }\n #endif\n \n+Cues::Cues(Segment* pSegment, long long start_, long long size_,\n+           long long element_start, long long element_size)\n+    : m_pSegment(pSegment),\n+      m_start(start_),\n+      m_size(size_),\n+      m_element_start(element_start),\n+      m_element_size(element_size),\n+      m_cue_points(NULL),\n+      m_count(0),\n+      m_preload_count(0),\n+      m_pos(start_) {}\n \n-Cues::Cues(\n-    Segment* pSegment,\n-    long long start_,\n-    long long size_,\n-    long long element_start,\n-    long long element_size) :\n-    m_pSegment(pSegment),\n-    m_start(start_),\n-    m_size(size_),\n-    m_element_start(element_start),\n-    m_element_size(element_size),\n-    m_cue_points(NULL),\n-    m_count(0),\n-    m_preload_count(0),\n-    m_pos(start_)\n-{\n+Cues::~Cues() {\n+  const long n = m_count + m_preload_count;\n+\n+  CuePoint** p = m_cue_points;\n+  CuePoint** const q = p + n;\n+\n+  while (p != q) {\n+    CuePoint* const pCP = *p++;\n+    assert(pCP);\n+\n+    delete pCP;\n+  }\n+\n+  delete[] m_cue_points;\n }\n \n+long Cues::GetCount() const {\n+  if (m_cue_points == NULL)\n+    return -1;\n \n-Cues::~Cues()\n-{\n-    const long n = m_count + m_preload_count;\n+  return m_count;  // TODO: really ignore preload count?\n+}\n \n-    CuePoint** p = m_cue_points;\n-    CuePoint** const q = p + n;\n+bool Cues::DoneParsing() const {\n+  const long long stop = m_start + m_size;\n+  return (m_pos >= stop);\n+}\n \n-    while (p != q)\n-    {\n-        CuePoint* const pCP = *p++;\n-        assert(pCP);\n+void Cues::Init() const {\n+  if (m_cue_points)\n+    return;\n \n-        delete pCP;\n-    }\n+  assert(m_count == 0);\n+  assert(m_preload_count == 0);\n+\n+  IMkvReader* const pReader = m_pSegment->m_pReader;\n+\n+  const long long stop = m_start + m_size;\n+  long long pos = m_start;\n+\n+  long cue_points_size = 0;\n+\n+  while (pos < stop) {\n+    const long long idpos = pos;\n+\n+    long len;\n+\n+    const long long id = ReadUInt(pReader, pos, len);\n+    assert(id >= 0);  // TODO\n+    assert((pos + len) <= stop);\n+\n+    pos += len;  // consume ID\n+\n+    const long long size = ReadUInt(pReader, pos, len);\n+    assert(size >= 0);\n+    assert((pos + len) <= stop);\n+\n+    pos += len;  // consume Size field\n+    assert((pos + size) <= stop);\n+\n+    if (id == 0x3B)  // CuePoint ID\n+      PreloadCuePoint(cue_points_size, idpos);\n+\n+    pos += size;  // consume payload\n+    assert(pos <= stop);\n+  }\n+}\n+\n+void Cues::PreloadCuePoint(long& cue_points_size, long long pos) const {\n+  assert(m_count == 0);\n+\n+  if (m_preload_count >= cue_points_size) {\n+    const long n = (cue_points_size <= 0) ? 2048 : 2 * cue_points_size;\n+\n+    CuePoint** const qq = new CuePoint* [n];\n+    CuePoint** q = qq;  // beginning of target\n+\n+    CuePoint** p = m_cue_points;  // beginning of source\n+    CuePoint** const pp = p + m_preload_count;  // end of source\n+\n+    while (p != pp)\n+      *q++ = *p++;\n \n     delete[] m_cue_points;\n+\n+    m_cue_points = qq;\n+    cue_points_size = n;\n+  }\n+\n+  CuePoint* const pCP = new CuePoint(m_preload_count, pos);\n+  m_cue_points[m_preload_count++] = pCP;\n }\n \n+bool Cues::LoadCuePoint() const {\n+  // odbgstream os;\n+  // os << \""Cues::LoadCuePoint\"" << endl;\n \n-long Cues::GetCount() const\n-{\n-    if (m_cue_points == NULL)\n-        return -1;\n+  const long long stop = m_start + m_size;\n \n-    return m_count;  //TODO: really ignore preload count?\n-}\n+  if (m_pos >= stop)\n+    return false;  // nothing else to do\n \n+  Init();\n \n-bool Cues::DoneParsing() const\n-{\n-    const long long stop = m_start + m_size;\n-    return (m_pos >= stop);\n-}\n+  IMkvReader* const pReader = m_pSegment->m_pReader;\n \n+  while (m_pos < stop) {\n+    const long long idpos = m_pos;\n \n-void Cues::Init() const\n-{\n-    if (m_cue_points)\n-        return;\n+    long len;\n \n-    assert(m_count == 0);\n-    assert(m_preload_count == 0);\n+    const long long id = ReadUInt(pReader, m_pos, len);\n+    assert(id >= 0);  // TODO\n+    assert((m_pos + len) <= stop);\n \n-    IMkvReader* const pReader = m_pSegment->m_pReader;\n+    m_pos += len;  // consume ID\n \n-    const long long stop = m_start + m_size;\n-    long long pos = m_start;\n+    const long long size = ReadUInt(pReader, m_pos, len);\n+    assert(size >= 0);\n+    assert((m_pos + len) <= stop);\n \n-    long cue_points_size = 0;\n+    m_pos += len;  // consume Size field\n+    assert((m_pos + size) <= stop);\n \n-    while (pos < stop)\n-    {\n-        const long long idpos = pos;\n+    if (id != 0x3B) {  // CuePoint ID\n+      m_pos += size;  // consume payload\n+      assert(m_pos <= stop);\n \n-        long len;\n-\n-        const long long id = ReadUInt(pReader, pos, len);\n-        assert(id >= 0);  //TODO\n-        assert((pos + len) <= stop);\n-\n-        pos += len;  //consume ID\n-\n-        const long long size = ReadUInt(pReader, pos, len);\n-        assert(size >= 0);\n-        assert((pos + len) <= stop);\n-\n-        pos += len;  //consume Size field\n-        assert((pos + size) <= stop);\n-\n-        if (id == 0x3B)  //CuePoint ID\n-            PreloadCuePoint(cue_points_size, idpos);\n-\n-        pos += size;  //consume payload\n-        assert(pos <= stop);\n-    }\n-}\n-\n-\n-void Cues::PreloadCuePoint(\n-    long& cue_points_size,\n-    long long pos) const\n-{\n-    assert(m_count == 0);\n-\n-    if (m_preload_count >= cue_points_size)\n-    {\n-        const long n = (cue_points_size <= 0) ? 2048 : 2*cue_points_size;\n-\n-        CuePoint** const qq = new CuePoint*[n];\n-        CuePoint** q = qq;  //beginning of target\n-\n-        CuePoint** p = m_cue_points;                //beginning of source\n-        CuePoint** const pp = p + m_preload_count;  //end of source\n-\n-        while (p != pp)\n-            *q++ = *p++;\n-\n-        delete[] m_cue_points;\n-\n-        m_cue_points = qq;\n-        cue_points_size = n;\n+      continue;\n     }\n \n-    CuePoint* const pCP = new CuePoint(m_preload_count, pos);\n-    m_cue_points[m_preload_count++] = pCP;\n+    assert(m_preload_count > 0);\n+\n+    CuePoint* const pCP = m_cue_points[m_count];\n+    assert(pCP);\n+    assert((pCP->GetTimeCode() >= 0) || (-pCP->GetTimeCode() == idpos));\n+    if (pCP->GetTimeCode() < 0 && (-pCP->GetTimeCode() != idpos))\n+      return false;\n+\n+    pCP->Load(pReader);\n+    ++m_count;\n+    --m_preload_count;\n+\n+    m_pos += size;  // consume payload\n+    assert(m_pos <= stop);\n+\n+    return true;  // yes, we loaded a cue point\n+  }\n+\n+  // return (m_pos < stop);\n+  return false;  // no, we did not load a cue point\n }\n \n-\n-bool Cues::LoadCuePoint() const\n-{\n-    //odbgstream os;\n-    //os << \""Cues::LoadCuePoint\"" << endl;\n-\n-    const long long stop = m_start + m_size;\n-\n-    if (m_pos >= stop)\n-        return false;  //nothing else to do\n-\n-    Init();\n-\n-    IMkvReader* const pReader = m_pSegment->m_pReader;\n-\n-    while (m_pos < stop)\n-    {\n-        const long long idpos = m_pos;\n-\n-        long len;\n-\n-        const long long id = ReadUInt(pReader, m_pos, len);\n-        assert(id >= 0);  //TODO\n-        assert((m_pos + len) <= stop);\n-\n-        m_pos += len;  //consume ID\n-\n-        const long long size = ReadUInt(pReader, m_pos, len);\n-        assert(size >= 0);\n-        assert((m_pos + len) <= stop);\n-\n-        m_pos += len;  //consume Size field\n-        assert((m_pos + size) <= stop);\n-\n-        if (id != 0x3B)  //CuePoint ID\n-        {\n-            m_pos += size;  //consume payload\n-            assert(m_pos <= stop);\n-\n-            continue;\n-        }\n-\n-        assert(m_preload_count > 0);\n-\n-        CuePoint* const pCP = m_cue_points[m_count];\n-        assert(pCP);\n-        assert((pCP->GetTimeCode() >= 0) || (-pCP->GetTimeCode() == idpos));\n-        if (pCP->GetTimeCode() < 0 && (-pCP->GetTimeCode() != idpos))\n-            return false;\n-\n-        pCP->Load(pReader);\n-        ++m_count;\n-        --m_preload_count;\n-\n-        m_pos += size;  //consume payload\n-        assert(m_pos <= stop);\n-\n-        return true;  //yes, we loaded a cue point\n-    }\n-\n-    //return (m_pos < stop);\n-    return false;  //no, we did not load a cue point\n-}\n-\n-\n-bool Cues::Find(\n-    long long time_ns,\n-    const Track* pTrack,\n-    const CuePoint*& pCP,\n-    const CuePoint::TrackPosition*& pTP) const\n-{\n-    assert(time_ns >= 0);\n-    assert(pTrack);\n+bool Cues::Find(long long time_ns, const Track* pTrack, const CuePoint*& pCP,\n+                const CuePoint::TrackPosition*& pTP) const {\n+  assert(time_ns >= 0);\n+  assert(pTrack);\n \n #if 0\n     LoadCuePoint();  //establish invariant\n@@ -2614,71 +2340,68 @@\n\n     assert(pCP);\n     assert(pCP->GetTime(m_pSegment) <= time_ns);\n #else\n-    if (m_cue_points == NULL)\n-        return false;\n+  if (m_cue_points == NULL)\n+    return false;\n \n-    if (m_count == 0)\n-        return false;\n+  if (m_count == 0)\n+    return false;\n \n-    CuePoint** const ii = m_cue_points;\n-    CuePoint** i = ii;\n+  CuePoint** const ii = m_cue_points;\n+  CuePoint** i = ii;\n \n-    CuePoint** const jj = ii + m_count;\n-    CuePoint** j = jj;\n+  CuePoint** const jj = ii + m_count;\n+  CuePoint** j = jj;\n \n-    pCP = *i;\n-    assert(pCP);\n+  pCP = *i;\n+  assert(pCP);\n \n-    if (time_ns <= pCP->GetTime(m_pSegment))\n-    {\n-        pTP = pCP->Find(pTrack);\n-        return (pTP != NULL);\n-    }\n-\n-    while (i < j)\n-    {\n-        //INVARIANT:\n-        //[ii, i) <= time_ns\n-        //[i, j)  ?\n-        //[j, jj) > time_ns\n-\n-        CuePoint** const k = i + (j - i) / 2;\n-        assert(k < jj);\n-\n-        CuePoint* const pCP = *k;\n-        assert(pCP);\n-\n-        const long long t = pCP->GetTime(m_pSegment);\n-\n-        if (t <= time_ns)\n-            i = k + 1;\n-        else\n-            j = k;\n-\n-        assert(i <= j);\n-    }\n-\n-    assert(i == j);\n-    assert(i <= jj);\n-    assert(i > ii);\n-\n-    pCP = *--i;\n-    assert(pCP);\n-    assert(pCP->GetTime(m_pSegment) <= time_ns);\n-#endif\n-\n-    //TODO: here and elsewhere, it's probably not correct to search\n-    //for the cue point with this time, and then search for a matching\n-    //track.  In principle, the matching track could be on some earlier\n-    //cue point, and with our current algorithm, we'd miss it.  To make\n-    //this bullet-proof, we'd need to create a secondary structure,\n-    //with a list of cue points that apply to a track, and then search\n-    //that track-based structure for a matching cue point.\n-\n+  if (time_ns <= pCP->GetTime(m_pSegment)) {\n     pTP = pCP->Find(pTrack);\n     return (pTP != NULL);\n-}\n+  }\n \n+  while (i < j) {\n+    // INVARIANT:\n+    //[ii, i) <= time_ns\n+    //[i, j)  ?\n+    //[j, jj) > time_ns\n+\n+    CuePoint** const k = i + (j - i) / 2;\n+    assert(k < jj);\n+\n+    CuePoint* const pCP = *k;\n+    assert(pCP);\n+\n+    const long long t = pCP->GetTime(m_pSegment);\n+\n+    if (t <= time_ns)\n+      i = k + 1;\n+    else\n+      j = k;\n+\n+    assert(i <= j);\n+  }\n+\n+  assert(i == j);\n+  assert(i <= jj);\n+  assert(i > ii);\n+\n+  pCP = *--i;\n+  assert(pCP);\n+  assert(pCP->GetTime(m_pSegment) <= time_ns);\n+#endif\n+\n+  // TODO: here and elsewhere, it's probably not correct to search\n+  // for the cue point with this time, and then search for a matching\n+  // track.  In principle, the matching track could be on some earlier\n+  // cue point, and with our current algorithm, we'd miss it.  To make\n+  // this bullet-proof, we'd need to create a secondary structure,\n+  // with a list of cue points that apply to a track, and then search\n+  // that track-based structure for a matching cue point.\n+\n+  pTP = pCP->Find(pTrack);\n+  return (pTP != NULL);\n+}\n \n #if 0\n bool Cues::FindNext(\n@@ -2739,14 +2462,12 @@\n\n }\n #endif\n \n+const CuePoint* Cues::GetFirst() const {\n+  if (m_cue_points == NULL)\n+    return NULL;\n \n-const CuePoint* Cues::GetFirst() const\n-{\n-    if (m_cue_points == NULL)\n-        return NULL;\n-\n-    if (m_count == 0)\n-        return NULL;\n+  if (m_count == 0)\n+    return NULL;\n \n #if 0\n     LoadCuePoint();  //init cues\n@@ -2757,24 +2478,22 @@\n\n         return NULL;\n #endif\n \n-    CuePoint* const* const pp = m_cue_points;\n-    assert(pp);\n+  CuePoint* const* const pp = m_cue_points;\n+  assert(pp);\n \n-    CuePoint* const pCP = pp[0];\n-    assert(pCP);\n-    assert(pCP->GetTimeCode() >= 0);\n+  CuePoint* const pCP = pp[0];\n+  assert(pCP);\n+  assert(pCP->GetTimeCode() >= 0);\n \n-    return pCP;\n+  return pCP;\n }\n \n+const CuePoint* Cues::GetLast() const {\n+  if (m_cue_points == NULL)\n+    return NULL;\n \n-const CuePoint* Cues::GetLast() const\n-{\n-    if (m_cue_points == NULL)\n-        return NULL;\n-\n-    if (m_count <= 0)\n-        return NULL;\n+  if (m_count <= 0)\n+    return NULL;\n \n #if 0\n     LoadCuePoint();  //init cues\n@@ -2795,28 +2514,26 @@\n\n     pCP->Load(m_pSegment->m_pReader);\n     assert(pCP->GetTimeCode() >= 0);\n #else\n-    const long index = m_count - 1;\n+  const long index = m_count - 1;\n \n-    CuePoint* const* const pp = m_cue_points;\n-    assert(pp);\n+  CuePoint* const* const pp = m_cue_points;\n+  assert(pp);\n \n-    CuePoint* const pCP = pp[index];\n-    assert(pCP);\n-    assert(pCP->GetTimeCode() >= 0);\n+  CuePoint* const pCP = pp[index];\n+  assert(pCP);\n+  assert(pCP->GetTimeCode() >= 0);\n #endif\n \n-    return pCP;\n+  return pCP;\n }\n \n+const CuePoint* Cues::GetNext(const CuePoint* pCurr) const {\n+  if (pCurr == NULL)\n+    return NULL;\n \n-const CuePoint* Cues::GetNext(const CuePoint* pCurr) const\n-{\n-    if (pCurr == NULL)\n-        return NULL;\n-\n-    assert(pCurr->GetTimeCode() >= 0);\n-    assert(m_cue_points);\n-    assert(m_count >= 1);\n+  assert(pCurr->GetTimeCode() >= 0);\n+  assert(m_cue_points);\n+  assert(m_count >= 1);\n \n #if 0\n     const size_t count = m_count + m_preload_count;\n@@ -2838,386 +2555,347 @@\n\n \n     pNext->Load(m_pSegment->m_pReader);\n #else\n-    long index = pCurr->m_index;\n-    assert(index < m_count);\n+  long index = pCurr->m_index;\n+  assert(index < m_count);\n \n-    CuePoint* const* const pp = m_cue_points;\n-    assert(pp);\n-    assert(pp[index] == pCurr);\n+  CuePoint* const* const pp = m_cue_points;\n+  assert(pp);\n+  assert(pp[index] == pCurr);\n \n-    ++index;\n+  ++index;\n \n-    if (index >= m_count)\n-        return NULL;\n+  if (index >= m_count)\n+    return NULL;\n \n-    CuePoint* const pNext = pp[index];\n-    assert(pNext);\n-    assert(pNext->GetTimeCode() >= 0);\n+  CuePoint* const pNext = pp[index];\n+  assert(pNext);\n+  assert(pNext->GetTimeCode() >= 0);\n #endif\n \n-    return pNext;\n+  return pNext;\n }\n \n+const BlockEntry* Cues::GetBlock(const CuePoint* pCP,\n+                                 const CuePoint::TrackPosition* pTP) const {\n+  if (pCP == NULL)\n+    return NULL;\n \n-const BlockEntry* Cues::GetBlock(\n-    const CuePoint* pCP,\n-    const CuePoint::TrackPosition* pTP) const\n-{\n-    if (pCP == NULL)\n-        return NULL;\n+  if (pTP == NULL)\n+    return NULL;\n \n-    if (pTP == NULL)\n-        return NULL;\n-\n-    return m_pSegment->GetBlock(*pCP, *pTP);\n+  return m_pSegment->GetBlock(*pCP, *pTP);\n }\n \n+const BlockEntry* Segment::GetBlock(const CuePoint& cp,\n+                                    const CuePoint::TrackPosition& tp) {\n+  Cluster** const ii = m_clusters;\n+  Cluster** i = ii;\n \n-const BlockEntry* Segment::GetBlock(\n-    const CuePoint& cp,\n-    const CuePoint::TrackPosition& tp)\n-{\n-    Cluster** const ii = m_clusters;\n-    Cluster** i = ii;\n+  const long count = m_clusterCount + m_clusterPreloadCount;\n \n-    const long count = m_clusterCount + m_clusterPreloadCount;\n+  Cluster** const jj = ii + count;\n+  Cluster** j = jj;\n \n-    Cluster** const jj = ii + count;\n-    Cluster** j = jj;\n+  while (i < j) {\n+    // INVARIANT:\n+    //[ii, i) < pTP->m_pos\n+    //[i, j) ?\n+    //[j, jj)  > pTP->m_pos\n \n-    while (i < j)\n-    {\n-        //INVARIANT:\n-        //[ii, i) < pTP->m_pos\n-        //[i, j) ?\n-        //[j, jj)  > pTP->m_pos\n+    Cluster** const k = i + (j - i) / 2;\n+    assert(k < jj);\n \n-        Cluster** const k = i + (j - i) / 2;\n-        assert(k < jj);\n-\n-        Cluster* const pCluster = *k;\n-        assert(pCluster);\n-\n-        //const long long pos_ = pCluster->m_pos;\n-        //assert(pos_);\n-        //const long long pos = pos_ * ((pos_ < 0) ? -1 : 1);\n-\n-        const long long pos = pCluster->GetPosition();\n-        assert(pos >= 0);\n-\n-        if (pos < tp.m_pos)\n-            i = k + 1;\n-        else if (pos > tp.m_pos)\n-            j = k;\n-        else\n-            return pCluster->GetEntry(cp, tp);\n-    }\n-\n-    assert(i == j);\n-    //assert(Cluster::HasBlockEntries(this, tp.m_pos));\n-\n-    Cluster* const pCluster = Cluster::Create(this, -1, tp.m_pos); //, -1);\n+    Cluster* const pCluster = *k;\n     assert(pCluster);\n \n-    const ptrdiff_t idx = i - m_clusters;\n+    // const long long pos_ = pCluster->m_pos;\n+    // assert(pos_);\n+    // const long long pos = pos_ * ((pos_ < 0) ? -1 : 1);\n \n-    PreloadCluster(pCluster, idx);\n-    assert(m_clusters);\n-    assert(m_clusterPreloadCount > 0);\n-    assert(m_clusters[idx] == pCluster);\n+    const long long pos = pCluster->GetPosition();\n+    assert(pos >= 0);\n \n-    return pCluster->GetEntry(cp, tp);\n+    if (pos < tp.m_pos)\n+      i = k + 1;\n+    else if (pos > tp.m_pos)\n+      j = k;\n+    else\n+      return pCluster->GetEntry(cp, tp);\n+  }\n+\n+  assert(i == j);\n+  // assert(Cluster::HasBlockEntries(this, tp.m_pos));\n+\n+  Cluster* const pCluster = Cluster::Create(this, -1, tp.m_pos);  //, -1);\n+  assert(pCluster);\n+\n+  const ptrdiff_t idx = i - m_clusters;\n+\n+  PreloadCluster(pCluster, idx);\n+  assert(m_clusters);\n+  assert(m_clusterPreloadCount > 0);\n+  assert(m_clusters[idx] == pCluster);\n+\n+  return pCluster->GetEntry(cp, tp);\n }\n \n+const Cluster* Segment::FindOrPreloadCluster(long long requested_pos) {\n+  if (requested_pos < 0)\n+    return 0;\n \n-const Cluster* Segment::FindOrPreloadCluster(long long requested_pos)\n-{\n-    if (requested_pos < 0)\n-        return 0;\n+  Cluster** const ii = m_clusters;\n+  Cluster** i = ii;\n \n-    Cluster** const ii = m_clusters;\n-    Cluster** i = ii;\n+  const long count = m_clusterCount + m_clusterPreloadCount;\n \n-    const long count = m_clusterCount + m_clusterPreloadCount;\n+  Cluster** const jj = ii + count;\n+  Cluster** j = jj;\n \n-    Cluster** const jj = ii + count;\n-    Cluster** j = jj;\n+  while (i < j) {\n+    // INVARIANT:\n+    //[ii, i) < pTP->m_pos\n+    //[i, j) ?\n+    //[j, jj)  > pTP->m_pos\n \n-    while (i < j)\n-    {\n-        //INVARIANT:\n-        //[ii, i) < pTP->m_pos\n-        //[i, j) ?\n-        //[j, jj)  > pTP->m_pos\n+    Cluster** const k = i + (j - i) / 2;\n+    assert(k < jj);\n \n-        Cluster** const k = i + (j - i) / 2;\n-        assert(k < jj);\n-\n-        Cluster* const pCluster = *k;\n-        assert(pCluster);\n-\n-        //const long long pos_ = pCluster->m_pos;\n-        //assert(pos_);\n-        //const long long pos = pos_ * ((pos_ < 0) ? -1 : 1);\n-\n-        const long long pos = pCluster->GetPosition();\n-        assert(pos >= 0);\n-\n-        if (pos < requested_pos)\n-            i = k + 1;\n-        else if (pos > requested_pos)\n-            j = k;\n-        else\n-            return pCluster;\n-    }\n-\n-    assert(i == j);\n-    //assert(Cluster::HasBlockEntries(this, tp.m_pos));\n-\n-    Cluster* const pCluster = Cluster::Create(\n-                                this,\n-                                -1,\n-                                requested_pos);\n-                                //-1);\n+    Cluster* const pCluster = *k;\n     assert(pCluster);\n \n-    const ptrdiff_t idx = i - m_clusters;\n+    // const long long pos_ = pCluster->m_pos;\n+    // assert(pos_);\n+    // const long long pos = pos_ * ((pos_ < 0) ? -1 : 1);\n \n-    PreloadCluster(pCluster, idx);\n-    assert(m_clusters);\n-    assert(m_clusterPreloadCount > 0);\n-    assert(m_clusters[idx] == pCluster);\n+    const long long pos = pCluster->GetPosition();\n+    assert(pos >= 0);\n \n-    return pCluster;\n+    if (pos < requested_pos)\n+      i = k + 1;\n+    else if (pos > requested_pos)\n+      j = k;\n+    else\n+      return pCluster;\n+  }\n+\n+  assert(i == j);\n+  // assert(Cluster::HasBlockEntries(this, tp.m_pos));\n+\n+  Cluster* const pCluster = Cluster::Create(this, -1, requested_pos);\n+  //-1);\n+  assert(pCluster);\n+\n+  const ptrdiff_t idx = i - m_clusters;\n+\n+  PreloadCluster(pCluster, idx);\n+  assert(m_clusters);\n+  assert(m_clusterPreloadCount > 0);\n+  assert(m_clusters[idx] == pCluster);\n+\n+  return pCluster;\n }\n \n-\n-CuePoint::CuePoint(long idx, long long pos) :\n-    m_element_start(0),\n-    m_element_size(0),\n-    m_index(idx),\n-    m_timecode(-1 * pos),\n-    m_track_positions(NULL),\n-    m_track_positions_count(0)\n-{\n-    assert(pos > 0);\n+CuePoint::CuePoint(long idx, long long pos)\n+    : m_element_start(0),\n+      m_element_size(0),\n+      m_index(idx),\n+      m_timecode(-1 * pos),\n+      m_track_positions(NULL),\n+      m_track_positions_count(0) {\n+  assert(pos > 0);\n }\n \n+CuePoint::~CuePoint() { delete[] m_track_positions; }\n \n-CuePoint::~CuePoint()\n-{\n-    delete[] m_track_positions;\n-}\n+void CuePoint::Load(IMkvReader* pReader) {\n+  // odbgstream os;\n+  // os << \""CuePoint::Load(begin): timecode=\"" << m_timecode << endl;\n \n+  if (m_timecode >= 0)  // already loaded\n+    return;\n \n-void CuePoint::Load(IMkvReader* pReader)\n-{\n-    //odbgstream os;\n-    //os << \""CuePoint::Load(begin): timecode=\"" << m_timecode << endl;\n+  assert(m_track_positions == NULL);\n+  assert(m_track_positions_count == 0);\n \n-    if (m_timecode >= 0)  //already loaded\n-        return;\n+  long long pos_ = -m_timecode;\n+  const long long element_start = pos_;\n \n-    assert(m_track_positions == NULL);\n-    assert(m_track_positions_count == 0);\n+  long long stop;\n \n-    long long pos_ = -m_timecode;\n-    const long long element_start = pos_;\n+  {\n+    long len;\n \n-    long long stop;\n+    const long long id = ReadUInt(pReader, pos_, len);\n+    assert(id == 0x3B);  // CuePoint ID\n+    if (id != 0x3B)\n+      return;\n \n-    {\n-        long len;\n+    pos_ += len;  // consume ID\n \n-        const long long id = ReadUInt(pReader, pos_, len);\n-        assert(id == 0x3B);  //CuePoint ID\n-        if (id != 0x3B)\n-            return;\n+    const long long size = ReadUInt(pReader, pos_, len);\n+    assert(size >= 0);\n \n-        pos_ += len;  //consume ID\n+    pos_ += len;  // consume Size field\n+    // pos_ now points to start of payload\n \n-        const long long size = ReadUInt(pReader, pos_, len);\n-        assert(size >= 0);\n+    stop = pos_ + size;\n+  }\n \n-        pos_ += len;  //consume Size field\n-        //pos_ now points to start of payload\n+  const long long element_size = stop - element_start;\n \n-        stop = pos_ + size;\n+  long long pos = pos_;\n+\n+  // First count number of track positions\n+\n+  while (pos < stop) {\n+    long len;\n+\n+    const long long id = ReadUInt(pReader, pos, len);\n+    assert(id >= 0);  // TODO\n+    assert((pos + len) <= stop);\n+\n+    pos += len;  // consume ID\n+\n+    const long long size = ReadUInt(pReader, pos, len);\n+    assert(size >= 0);\n+    assert((pos + len) <= stop);\n+\n+    pos += len;  // consume Size field\n+    assert((pos + size) <= stop);\n+\n+    if (id == 0x33)  // CueTime ID\n+      m_timecode = UnserializeUInt(pReader, pos, size);\n+\n+    else if (id == 0x37)  // CueTrackPosition(s) ID\n+      ++m_track_positions_count;\n+\n+    pos += size;  // consume payload\n+    assert(pos <= stop);\n+  }\n+\n+  assert(m_timecode >= 0);\n+  assert(m_track_positions_count > 0);\n+\n+  // os << \""CuePoint::Load(cont'd): idpos=\"" << idpos\n+  //   << \"" timecode=\"" << m_timecode\n+  //   << endl;\n+\n+  m_track_positions = new TrackPosition[m_track_positions_count];\n+\n+  // Now parse track positions\n+\n+  TrackPosition* p = m_track_positions;\n+  pos = pos_;\n+\n+  while (pos < stop) {\n+    long len;\n+\n+    const long long id = ReadUInt(pReader, pos, len);\n+    assert(id >= 0);  // TODO\n+    assert((pos + len) <= stop);\n+\n+    pos += len;  // consume ID\n+\n+    const long long size = ReadUInt(pReader, pos, len);\n+    assert(size >= 0);\n+    assert((pos + len) <= stop);\n+\n+    pos += len;  // consume Size field\n+    assert((pos + size) <= stop);\n+\n+    if (id == 0x37) {  // CueTrackPosition(s) ID\n+      TrackPosition& tp = *p++;\n+      tp.Parse(pReader, pos, size);\n     }\n \n-    const long long element_size = stop - element_start;\n+    pos += size;  // consume payload\n+    assert(pos <= stop);\n+  }\n \n-    long long pos = pos_;\n+  assert(size_t(p - m_track_positions) == m_track_positions_count);\n \n-    //First count number of track positions\n-\n-    while (pos < stop)\n-    {\n-        long len;\n-\n-        const long long id = ReadUInt(pReader, pos, len);\n-        assert(id >= 0);  //TODO\n-        assert((pos + len) <= stop);\n-\n-        pos += len;  //consume ID\n-\n-        const long long size = ReadUInt(pReader, pos, len);\n-        assert(size >= 0);\n-        assert((pos + len) <= stop);\n-\n-        pos += len;  //consume Size field\n-        assert((pos + size) <= stop);\n-\n-        if (id == 0x33)  //CueTime ID\n-            m_timecode = UnserializeUInt(pReader, pos, size);\n-\n-        else if (id == 0x37) //CueTrackPosition(s) ID\n-            ++m_track_positions_count;\n-\n-        pos += size;  //consume payload\n-        assert(pos <= stop);\n-    }\n-\n-    assert(m_timecode >= 0);\n-    assert(m_track_positions_count > 0);\n-\n-    //os << \""CuePoint::Load(cont'd): idpos=\"" << idpos\n-    //   << \"" timecode=\"" << m_timecode\n-    //   << endl;\n-\n-    m_track_positions = new TrackPosition[m_track_positions_count];\n-\n-    //Now parse track positions\n-\n-    TrackPosition* p = m_track_positions;\n-    pos = pos_;\n-\n-    while (pos < stop)\n-    {\n-        long len;\n-\n-        const long long id = ReadUInt(pReader, pos, len);\n-        assert(id >= 0);  //TODO\n-        assert((pos + len) <= stop);\n-\n-        pos += len;  //consume ID\n-\n-        const long long size = ReadUInt(pReader, pos, len);\n-        assert(size >= 0);\n-        assert((pos + len) <= stop);\n-\n-        pos += len;  //consume Size field\n-        assert((pos + size) <= stop);\n-\n-        if (id == 0x37) //CueTrackPosition(s) ID\n-        {\n-            TrackPosition& tp = *p++;\n-            tp.Parse(pReader, pos, size);\n-        }\n-\n-        pos += size;  //consume payload\n-        assert(pos <= stop);\n-    }\n-\n-    assert(size_t(p - m_track_positions) == m_track_positions_count);\n-\n-    m_element_start = element_start;\n-    m_element_size = element_size;\n+  m_element_start = element_start;\n+  m_element_size = element_size;\n }\n \n+void CuePoint::TrackPosition::Parse(IMkvReader* pReader, long long start_,\n+                                    long long size_) {\n+  const long long stop = start_ + size_;\n+  long long pos = start_;\n \n+  m_track = -1;\n+  m_pos = -1;\n+  m_block = 1;  // default\n \n-void CuePoint::TrackPosition::Parse(\n-    IMkvReader* pReader,\n-    long long start_,\n-    long long size_)\n-{\n-    const long long stop = start_ + size_;\n-    long long pos = start_;\n+  while (pos < stop) {\n+    long len;\n \n-    m_track = -1;\n-    m_pos = -1;\n-    m_block = 1;  //default\n+    const long long id = ReadUInt(pReader, pos, len);\n+    assert(id >= 0);  // TODO\n+    assert((pos + len) <= stop);\n \n-    while (pos < stop)\n-    {\n-        long len;\n+    pos += len;  // consume ID\n \n-        const long long id = ReadUInt(pReader, pos, len);\n-        assert(id >= 0);  //TODO\n-        assert((pos + len) <= stop);\n+    const long long size = ReadUInt(pReader, pos, len);\n+    assert(size >= 0);\n+    assert((pos + len) <= stop);\n \n-        pos += len;  //consume ID\n+    pos += len;  // consume Size field\n+    assert((pos + size) <= stop);\n \n-        const long long size = ReadUInt(pReader, pos, len);\n-        assert(size >= 0);\n-        assert((pos + len) <= stop);\n+    if (id == 0x77)  // CueTrack ID\n+      m_track = UnserializeUInt(pReader, pos, size);\n \n-        pos += len;  //consume Size field\n-        assert((pos + size) <= stop);\n+    else if (id == 0x71)  // CueClusterPos ID\n+      m_pos = UnserializeUInt(pReader, pos, size);\n \n-        if (id == 0x77)  //CueTrack ID\n-            m_track = UnserializeUInt(pReader, pos, size);\n+    else if (id == 0x1378)  // CueBlockNumber\n+      m_block = UnserializeUInt(pReader, pos, size);\n \n-        else if (id == 0x71)  //CueClusterPos ID\n-            m_pos = UnserializeUInt(pReader, pos, size);\n+    pos += size;  // consume payload\n+    assert(pos <= stop);\n+  }\n \n-        else if (id == 0x1378)  //CueBlockNumber\n-            m_block = UnserializeUInt(pReader, pos, size);\n-\n-        pos += size;  //consume payload\n-        assert(pos <= stop);\n-    }\n-\n-    assert(m_pos >= 0);\n-    assert(m_track > 0);\n-    //assert(m_block > 0);\n+  assert(m_pos >= 0);\n+  assert(m_track > 0);\n+  // assert(m_block > 0);\n }\n \n+const CuePoint::TrackPosition* CuePoint::Find(const Track* pTrack) const {\n+  assert(pTrack);\n \n-const CuePoint::TrackPosition* CuePoint::Find(const Track* pTrack) const\n-{\n-    assert(pTrack);\n+  const long long n = pTrack->GetNumber();\n \n-    const long long n = pTrack->GetNumber();\n+  const TrackPosition* i = m_track_positions;\n+  const TrackPosition* const j = i + m_track_positions_count;\n \n-    const TrackPosition* i = m_track_positions;\n-    const TrackPosition* const j = i + m_track_positions_count;\n+  while (i != j) {\n+    const TrackPosition& p = *i++;\n \n-    while (i != j)\n-    {\n-        const TrackPosition& p = *i++;\n+    if (p.m_track == n)\n+      return &p;\n+  }\n \n-        if (p.m_track == n)\n-            return &p;\n-    }\n-\n-    return NULL;  //no matching track number found\n+  return NULL;  // no matching track number found\n }\n \n+long long CuePoint::GetTimeCode() const { return m_timecode; }\n \n-long long CuePoint::GetTimeCode() const\n-{\n-    return m_timecode;\n+long long CuePoint::GetTime(const Segment* pSegment) const {\n+  assert(pSegment);\n+  assert(m_timecode >= 0);\n+\n+  const SegmentInfo* const pInfo = pSegment->GetInfo();\n+  assert(pInfo);\n+\n+  const long long scale = pInfo->GetTimeCodeScale();\n+  assert(scale >= 1);\n+\n+  const long long time = scale * m_timecode;\n+\n+  return time;\n }\n \n-long long CuePoint::GetTime(const Segment* pSegment) const\n-{\n-    assert(pSegment);\n-    assert(m_timecode >= 0);\n-\n-    const SegmentInfo* const pInfo = pSegment->GetInfo();\n-    assert(pInfo);\n-\n-    const long long scale = pInfo->GetTimeCodeScale();\n-    assert(scale >= 1);\n-\n-    const long long time = scale * m_timecode;\n-\n-    return time;\n-}\n-\n-\n #if 0\n long long Segment::Unparsed() const\n {\n@@ -3232,808 +2910,745 @@\n\n     return result;\n }\n #else\n-bool Segment::DoneParsing() const\n-{\n-    if (m_size < 0)\n-    {\n-        long long total, avail;\n+bool Segment::DoneParsing() const {\n+  if (m_size < 0) {\n+    long long total, avail;\n \n-        const int status = m_pReader->Length(&total, &avail);\n+    const int status = m_pReader->Length(&total, &avail);\n \n-        if (status < 0)  //error\n-            return true;  //must assume done\n+    if (status < 0)  // error\n+      return true;  // must assume done\n \n-        if (total < 0)\n-            return false;  //assume live stream\n+    if (total < 0)\n+      return false;  // assume live stream\n \n-        return (m_pos >= total);\n-    }\n+    return (m_pos >= total);\n+  }\n \n-    const long long stop = m_start + m_size;\n+  const long long stop = m_start + m_size;\n \n-    return (m_pos >= stop);\n+  return (m_pos >= stop);\n }\n #endif\n \n+const Cluster* Segment::GetFirst() const {\n+  if ((m_clusters == NULL) || (m_clusterCount <= 0))\n+    return &m_eos;\n \n-const Cluster* Segment::GetFirst() const\n-{\n-    if ((m_clusters == NULL) || (m_clusterCount <= 0))\n-       return &m_eos;\n+  Cluster* const pCluster = m_clusters[0];\n+  assert(pCluster);\n \n-    Cluster* const pCluster = m_clusters[0];\n-    assert(pCluster);\n-\n-    return pCluster;\n+  return pCluster;\n }\n \n+const Cluster* Segment::GetLast() const {\n+  if ((m_clusters == NULL) || (m_clusterCount <= 0))\n+    return &m_eos;\n \n-const Cluster* Segment::GetLast() const\n-{\n-    if ((m_clusters == NULL) || (m_clusterCount <= 0))\n-        return &m_eos;\n+  const long idx = m_clusterCount - 1;\n \n-    const long idx = m_clusterCount - 1;\n+  Cluster* const pCluster = m_clusters[idx];\n+  assert(pCluster);\n \n-    Cluster* const pCluster = m_clusters[idx];\n-    assert(pCluster);\n-\n-    return pCluster;\n+  return pCluster;\n }\n \n+unsigned long Segment::GetCount() const { return m_clusterCount; }\n \n-unsigned long Segment::GetCount() const\n-{\n-    return m_clusterCount;\n-}\n+const Cluster* Segment::GetNext(const Cluster* pCurr) {\n+  assert(pCurr);\n+  assert(pCurr != &m_eos);\n+  assert(m_clusters);\n \n+  long idx = pCurr->m_index;\n \n-const Cluster* Segment::GetNext(const Cluster* pCurr)\n-{\n-    assert(pCurr);\n-    assert(pCurr != &m_eos);\n-    assert(m_clusters);\n+  if (idx >= 0) {\n+    assert(m_clusterCount > 0);\n+    assert(idx < m_clusterCount);\n+    assert(pCurr == m_clusters[idx]);\n \n-    long idx =  pCurr->m_index;\n+    ++idx;\n \n-    if (idx >= 0)\n-    {\n-        assert(m_clusterCount > 0);\n-        assert(idx < m_clusterCount);\n-        assert(pCurr == m_clusters[idx]);\n+    if (idx >= m_clusterCount)\n+      return &m_eos;  // caller will LoadCluster as desired\n \n-        ++idx;\n-\n-        if (idx >= m_clusterCount)\n-            return &m_eos;  //caller will LoadCluster as desired\n-\n-        Cluster* const pNext = m_clusters[idx];\n-        assert(pNext);\n-        assert(pNext->m_index >= 0);\n-        assert(pNext->m_index == idx);\n-\n-        return pNext;\n-    }\n-\n-    assert(m_clusterPreloadCount > 0);\n-\n-    long long pos = pCurr->m_element_start;\n-\n-    assert(m_size >= 0);  //TODO\n-    const long long stop = m_start + m_size;  //end of segment\n-\n-    {\n-        long len;\n-\n-        long long result = GetUIntLength(m_pReader, pos, len);\n-        assert(result == 0);\n-        assert((pos + len) <= stop);  //TODO\n-        if (result != 0)\n-            return NULL;\n-\n-        const long long id = ReadUInt(m_pReader, pos, len);\n-        assert(id == 0x0F43B675);  //Cluster ID\n-        if (id != 0x0F43B675)\n-            return NULL;\n-\n-        pos += len;  //consume ID\n-\n-        //Read Size\n-        result = GetUIntLength(m_pReader, pos, len);\n-        assert(result == 0);  //TODO\n-        assert((pos + len) <= stop);  //TODO\n-\n-        const long long size = ReadUInt(m_pReader, pos, len);\n-        assert(size > 0);  //TODO\n-        //assert((pCurr->m_size <= 0) || (pCurr->m_size == size));\n-\n-        pos += len;  //consume length of size of element\n-        assert((pos + size) <= stop);  //TODO\n-\n-        //Pos now points to start of payload\n-\n-        pos += size;  //consume payload\n-    }\n-\n-    long long off_next = 0;\n-\n-    while (pos < stop)\n-    {\n-        long len;\n-\n-        long long result = GetUIntLength(m_pReader, pos, len);\n-        assert(result == 0);\n-        assert((pos + len) <= stop);  //TODO\n-        if (result != 0)\n-            return NULL;\n-\n-        const long long idpos = pos;  //pos of next (potential) cluster\n-\n-        const long long id = ReadUInt(m_pReader, idpos, len);\n-        assert(id > 0);  //TODO\n-\n-        pos += len;  //consume ID\n-\n-        //Read Size\n-        result = GetUIntLength(m_pReader, pos, len);\n-        assert(result == 0);  //TODO\n-        assert((pos + len) <= stop);  //TODO\n-\n-        const long long size = ReadUInt(m_pReader, pos, len);\n-        assert(size >= 0);  //TODO\n-\n-        pos += len;  //consume length of size of element\n-        assert((pos + size) <= stop);  //TODO\n-\n-        //Pos now points to start of payload\n-\n-        if (size == 0)  //weird\n-            continue;\n-\n-        if (id == 0x0F43B675)  //Cluster ID\n-        {\n-            const long long off_next_ = idpos - m_start;\n-\n-            long long pos_;\n-            long len_;\n-\n-            const long status = Cluster::HasBlockEntries(\n-                                    this,\n-                                    off_next_,\n-                                    pos_,\n-                                    len_);\n-\n-            assert(status >= 0);\n-\n-            if (status > 0)\n-            {\n-                off_next = off_next_;\n-                break;\n-            }\n-        }\n-\n-        pos += size;  //consume payload\n-    }\n-\n-    if (off_next <= 0)\n-        return 0;\n-\n-    Cluster** const ii = m_clusters + m_clusterCount;\n-    Cluster** i = ii;\n-\n-    Cluster** const jj = ii + m_clusterPreloadCount;\n-    Cluster** j = jj;\n-\n-    while (i < j)\n-    {\n-        //INVARIANT:\n-        //[0, i) < pos_next\n-        //[i, j) ?\n-        //[j, jj)  > pos_next\n-\n-        Cluster** const k = i + (j - i) / 2;\n-        assert(k < jj);\n-\n-        Cluster* const pNext = *k;\n-        assert(pNext);\n-        assert(pNext->m_index < 0);\n-\n-        //const long long pos_ = pNext->m_pos;\n-        //assert(pos_);\n-        //pos = pos_ * ((pos_ < 0) ? -1 : 1);\n-\n-        pos = pNext->GetPosition();\n-\n-        if (pos < off_next)\n-            i = k + 1;\n-        else if (pos > off_next)\n-            j = k;\n-        else\n-            return pNext;\n-    }\n-\n-    assert(i == j);\n-\n-    Cluster* const pNext = Cluster::Create(this,\n-                                          -1,\n-                                          off_next);\n+    Cluster* const pNext = m_clusters[idx];\n     assert(pNext);\n-\n-    const ptrdiff_t idx_next = i - m_clusters;  //insertion position\n-\n-    PreloadCluster(pNext, idx_next);\n-    assert(m_clusters);\n-    assert(idx_next < m_clusterSize);\n-    assert(m_clusters[idx_next] == pNext);\n+    assert(pNext->m_index >= 0);\n+    assert(pNext->m_index == idx);\n \n     return pNext;\n-}\n+  }\n \n+  assert(m_clusterPreloadCount > 0);\n \n-long Segment::ParseNext(\n-    const Cluster* pCurr,\n-    const Cluster*& pResult,\n-    long long& pos,\n-    long& len)\n-{\n-    assert(pCurr);\n-    assert(!pCurr->EOS());\n-    assert(m_clusters);\n+  long long pos = pCurr->m_element_start;\n \n-    pResult = 0;\n+  assert(m_size >= 0);  // TODO\n+  const long long stop = m_start + m_size;  // end of segment\n \n-    if (pCurr->m_index >= 0)  //loaded (not merely preloaded)\n-    {\n-        assert(m_clusters[pCurr->m_index] == pCurr);\n+  {\n+    long len;\n \n-        const long next_idx = pCurr->m_index + 1;\n+    long long result = GetUIntLength(m_pReader, pos, len);\n+    assert(result == 0);\n+    assert((pos + len) <= stop);  // TODO\n+    if (result != 0)\n+      return NULL;\n \n-        if (next_idx < m_clusterCount)\n-        {\n-            pResult = m_clusters[next_idx];\n-            return 0;  //success\n-        }\n+    const long long id = ReadUInt(m_pReader, pos, len);\n+    assert(id == 0x0F43B675);  // Cluster ID\n+    if (id != 0x0F43B675)\n+      return NULL;\n \n-        //curr cluster is last among loaded\n+    pos += len;  // consume ID\n \n-        const long result = LoadCluster(pos, len);\n+    // Read Size\n+    result = GetUIntLength(m_pReader, pos, len);\n+    assert(result == 0);  // TODO\n+    assert((pos + len) <= stop);  // TODO\n \n-        if (result < 0)  //error or underflow\n-            return result;\n+    const long long size = ReadUInt(m_pReader, pos, len);\n+    assert(size > 0);  // TODO\n+    // assert((pCurr->m_size <= 0) || (pCurr->m_size == size));\n \n-        if (result > 0)  //no more clusters\n-        {\n-            //pResult = &m_eos;\n-            return 1;\n-        }\n+    pos += len;  // consume length of size of element\n+    assert((pos + size) <= stop);  // TODO\n \n-        pResult = GetLast();\n-        return 0;  //success\n+    // Pos now points to start of payload\n+\n+    pos += size;  // consume payload\n+  }\n+\n+  long long off_next = 0;\n+\n+  while (pos < stop) {\n+    long len;\n+\n+    long long result = GetUIntLength(m_pReader, pos, len);\n+    assert(result == 0);\n+    assert((pos + len) <= stop);  // TODO\n+    if (result != 0)\n+      return NULL;\n+\n+    const long long idpos = pos;  // pos of next (potential) cluster\n+\n+    const long long id = ReadUInt(m_pReader, idpos, len);\n+    assert(id > 0);  // TODO\n+\n+    pos += len;  // consume ID\n+\n+    // Read Size\n+    result = GetUIntLength(m_pReader, pos, len);\n+    assert(result == 0);  // TODO\n+    assert((pos + len) <= stop);  // TODO\n+\n+    const long long size = ReadUInt(m_pReader, pos, len);\n+    assert(size >= 0);  // TODO\n+\n+    pos += len;  // consume length of size of element\n+    assert((pos + size) <= stop);  // TODO\n+\n+    // Pos now points to start of payload\n+\n+    if (size == 0)  // weird\n+      continue;\n+\n+    if (id == 0x0F43B675) {  // Cluster ID\n+      const long long off_next_ = idpos - m_start;\n+\n+      long long pos_;\n+      long len_;\n+\n+      const long status = Cluster::HasBlockEntries(this, off_next_, pos_, len_);\n+\n+      assert(status >= 0);\n+\n+      if (status > 0) {\n+        off_next = off_next_;\n+        break;\n+      }\n     }\n \n-    assert(m_pos > 0);\n+    pos += size;  // consume payload\n+  }\n \n-    long long total, avail;\n+  if (off_next <= 0)\n+    return 0;\n \n-    long status = m_pReader->Length(&total, &avail);\n+  Cluster** const ii = m_clusters + m_clusterCount;\n+  Cluster** i = ii;\n \n-    if (status < 0)  //error\n-        return status;\n+  Cluster** const jj = ii + m_clusterPreloadCount;\n+  Cluster** j = jj;\n \n-    assert((total < 0) || (avail <= total));\n+  while (i < j) {\n+    // INVARIANT:\n+    //[0, i) < pos_next\n+    //[i, j) ?\n+    //[j, jj)  > pos_next\n \n-    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n+    Cluster** const k = i + (j - i) / 2;\n+    assert(k < jj);\n \n-    //interrogate curr cluster\n+    Cluster* const pNext = *k;\n+    assert(pNext);\n+    assert(pNext->m_index < 0);\n \n-    pos = pCurr->m_element_start;\n+    // const long long pos_ = pNext->m_pos;\n+    // assert(pos_);\n+    // pos = pos_ * ((pos_ < 0) ? -1 : 1);\n \n-    if (pCurr->m_element_size >= 0)\n-        pos += pCurr->m_element_size;\n+    pos = pNext->GetPosition();\n+\n+    if (pos < off_next)\n+      i = k + 1;\n+    else if (pos > off_next)\n+      j = k;\n     else\n-    {\n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n+      return pNext;\n+  }\n \n-        long long result = GetUIntLength(m_pReader, pos, len);\n+  assert(i == j);\n \n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n+  Cluster* const pNext = Cluster::Create(this, -1, off_next);\n+  assert(pNext);\n \n-        if (result > 0)  //weird\n-            return E_BUFFER_NOT_FULL;\n+  const ptrdiff_t idx_next = i - m_clusters;  // insertion position\n \n-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n-            return E_FILE_FORMAT_INVALID;\n+  PreloadCluster(pNext, idx_next);\n+  assert(m_clusters);\n+  assert(idx_next < m_clusterSize);\n+  assert(m_clusters[idx_next] == pNext);\n \n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n-\n-        const long long id = ReadUInt(m_pReader, pos, len);\n-\n-        if (id != 0x0F43B675)  //weird: not Cluster ID\n-            return -1;\n-\n-        pos += len;  //consume ID\n-\n-        //Read Size\n-\n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        result = GetUIntLength(m_pReader, pos, len);\n-\n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n-\n-        if (result > 0)  //weird\n-            return E_BUFFER_NOT_FULL;\n-\n-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n-\n-        const long long size = ReadUInt(m_pReader, pos, len);\n-\n-        if (size < 0) //error\n-            return static_cast<long>(size);\n-\n-        pos += len;  //consume size field\n-\n-        const long long unknown_size = (1LL << (7 * len)) - 1;\n-\n-        if (size == unknown_size)          //TODO: should never happen\n-            return E_FILE_FORMAT_INVALID;  //TODO: resolve this\n-\n-        //assert((pCurr->m_size <= 0) || (pCurr->m_size == size));\n-\n-        if ((segment_stop >= 0) && ((pos + size) > segment_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        //Pos now points to start of payload\n-\n-        pos += size;  //consume payload (that is, the current cluster)\n-        assert((segment_stop < 0) || (pos <= segment_stop));\n-\n-        //By consuming the payload, we are assuming that the curr\n-        //cluster isn't interesting.  That is, we don't bother checking\n-        //whether the payload of the curr cluster is less than what\n-        //happens to be available (obtained via IMkvReader::Length).\n-        //Presumably the caller has already dispensed with the current\n-        //cluster, and really does want the next cluster.\n-    }\n-\n-    //pos now points to just beyond the last fully-loaded cluster\n-\n-    for (;;)\n-    {\n-        const long status = DoParseNext(pResult, pos, len);\n-\n-        if (status <= 1)\n-            return status;\n-    }\n+  return pNext;\n }\n \n+long Segment::ParseNext(const Cluster* pCurr, const Cluster*& pResult,\n+                        long long& pos, long& len) {\n+  assert(pCurr);\n+  assert(!pCurr->EOS());\n+  assert(m_clusters);\n \n-long Segment::DoParseNext(\n-    const Cluster*& pResult,\n-    long long& pos,\n-    long& len)\n-{\n-    long long total, avail;\n+  pResult = 0;\n \n-    long status = m_pReader->Length(&total, &avail);\n+  if (pCurr->m_index >= 0) {  // loaded (not merely preloaded)\n+    assert(m_clusters[pCurr->m_index] == pCurr);\n \n-    if (status < 0)  //error\n-        return status;\n+    const long next_idx = pCurr->m_index + 1;\n \n-    assert((total < 0) || (avail <= total));\n+    if (next_idx < m_clusterCount) {\n+      pResult = m_clusters[next_idx];\n+      return 0;  // success\n+    }\n \n-    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n+    // curr cluster is last among loaded\n \n-    //Parse next cluster.  This is strictly a parsing activity.\n-    //Creation of a new cluster object happens later, after the\n-    //parsing is done.\n+    const long result = LoadCluster(pos, len);\n \n-    long long off_next = 0;\n-    long long cluster_size = -1;\n+    if (result < 0)  // error or underflow\n+      return result;\n \n-    for (;;)\n+    if (result > 0)  // no more clusters\n     {\n-        if ((total >= 0) && (pos >= total))\n-            return 1;  //EOF\n+      // pResult = &m_eos;\n+      return 1;\n+    }\n \n-        if ((segment_stop >= 0) && (pos >= segment_stop))\n-            return 1;  //EOF\n+    pResult = GetLast();\n+    return 0;  // success\n+  }\n \n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n+  assert(m_pos > 0);\n \n-        long long result = GetUIntLength(m_pReader, pos, len);\n+  long long total, avail;\n \n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n+  long status = m_pReader->Length(&total, &avail);\n \n-        if (result > 0)  //weird\n-            return E_BUFFER_NOT_FULL;\n+  if (status < 0)  // error\n+    return status;\n \n-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n-            return E_FILE_FORMAT_INVALID;\n+  assert((total < 0) || (avail <= total));\n \n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n+  const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n \n-        const long long idpos = pos;             //absolute\n-        const long long idoff = pos - m_start;   //relative\n+  // interrogate curr cluster\n \n-        const long long id = ReadUInt(m_pReader, idpos, len);  //absolute\n+  pos = pCurr->m_element_start;\n \n-        if (id < 0)  //error\n-            return static_cast<long>(id);\n+  if (pCurr->m_element_size >= 0)\n+    pos += pCurr->m_element_size;\n+  else {\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n+    }\n \n-        if (id == 0)  //weird\n-            return -1;  //generic error\n+    long long result = GetUIntLength(m_pReader, pos, len);\n \n-        pos += len;  //consume ID\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n \n-        //Read Size\n+    if (result > 0)  // weird\n+      return E_BUFFER_NOT_FULL;\n \n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n+      return E_FILE_FORMAT_INVALID;\n \n-        result = GetUIntLength(m_pReader, pos, len);\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n \n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n+    const long long id = ReadUInt(m_pReader, pos, len);\n \n-        if (result > 0)  //weird\n-            return E_BUFFER_NOT_FULL;\n+    if (id != 0x0F43B675)  // weird: not Cluster ID\n+      return -1;\n \n-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n-            return E_FILE_FORMAT_INVALID;\n+    pos += len;  // consume ID\n \n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n+    // Read Size\n \n-        const long long size = ReadUInt(m_pReader, pos, len);\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n+    }\n \n-        if (size < 0)  //error\n-            return static_cast<long>(size);\n+    result = GetUIntLength(m_pReader, pos, len);\n \n-        pos += len;  //consume length of size of element\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n \n-        //Pos now points to start of payload\n+    if (result > 0)  // weird\n+      return E_BUFFER_NOT_FULL;\n \n-        if (size == 0)  //weird\n-            continue;\n+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n+      return E_FILE_FORMAT_INVALID;\n \n-        const long long unknown_size = (1LL << (7 * len)) - 1;\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n \n-        if ((segment_stop >= 0) &&\n-            (size != unknown_size) &&\n-            ((pos + size) > segment_stop))\n-        {\n-            return E_FILE_FORMAT_INVALID;\n-        }\n+    const long long size = ReadUInt(m_pReader, pos, len);\n \n-        if (id == 0x0C53BB6B)  //Cues ID\n-        {\n-            if (size == unknown_size)\n-                return E_FILE_FORMAT_INVALID;\n+    if (size < 0)  // error\n+      return static_cast<long>(size);\n \n-            const long long element_stop = pos + size;\n+    pos += len;  // consume size field\n \n-            if ((segment_stop >= 0) && (element_stop > segment_stop))\n-                return E_FILE_FORMAT_INVALID;\n+    const long long unknown_size = (1LL << (7 * len)) - 1;\n \n-            const long long element_start = idpos;\n-            const long long element_size = element_stop - element_start;\n+    if (size == unknown_size)  // TODO: should never happen\n+      return E_FILE_FORMAT_INVALID;  // TODO: resolve this\n \n-            if (m_pCues == NULL)\n-            {\n-                m_pCues = new Cues(this,\n-                                    pos,\n-                                    size,\n-                                    element_start,\n-                                    element_size);\n-                assert(m_pCues);  //TODO\n-            }\n+    // assert((pCurr->m_size <= 0) || (pCurr->m_size == size));\n \n-            pos += size;  //consume payload\n-            assert((segment_stop < 0) || (pos <= segment_stop));\n+    if ((segment_stop >= 0) && ((pos + size) > segment_stop))\n+      return E_FILE_FORMAT_INVALID;\n \n-            continue;\n-        }\n+    // Pos now points to start of payload\n \n-        if (id != 0x0F43B675)  //not a Cluster ID\n-        {\n-            if (size == unknown_size)\n-                return E_FILE_FORMAT_INVALID;\n+    pos += size;  // consume payload (that is, the current cluster)\n+    assert((segment_stop < 0) || (pos <= segment_stop));\n \n-            pos += size;  //consume payload\n-            assert((segment_stop < 0) || (pos <= segment_stop));\n+    // By consuming the payload, we are assuming that the curr\n+    // cluster isn't interesting.  That is, we don't bother checking\n+    // whether the payload of the curr cluster is less than what\n+    // happens to be available (obtained via IMkvReader::Length).\n+    // Presumably the caller has already dispensed with the current\n+    // cluster, and really does want the next cluster.\n+  }\n \n-            continue;\n-        }\n+  // pos now points to just beyond the last fully-loaded cluster\n \n-#if 0 //this is commented-out to support incremental cluster parsing\n+  for (;;) {\n+    const long status = DoParseNext(pResult, pos, len);\n+\n+    if (status <= 1)\n+      return status;\n+  }\n+}\n+\n+long Segment::DoParseNext(const Cluster*& pResult, long long& pos, long& len) {\n+  long long total, avail;\n+\n+  long status = m_pReader->Length(&total, &avail);\n+\n+  if (status < 0)  // error\n+    return status;\n+\n+  assert((total < 0) || (avail <= total));\n+\n+  const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n+\n+  // Parse next cluster.  This is strictly a parsing activity.\n+  // Creation of a new cluster object happens later, after the\n+  // parsing is done.\n+\n+  long long off_next = 0;\n+  long long cluster_size = -1;\n+\n+  for (;;) {\n+    if ((total >= 0) && (pos >= total))\n+      return 1;  // EOF\n+\n+    if ((segment_stop >= 0) && (pos >= segment_stop))\n+      return 1;  // EOF\n+\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n+    }\n+\n+    long long result = GetUIntLength(m_pReader, pos, len);\n+\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n+\n+    if (result > 0)  // weird\n+      return E_BUFFER_NOT_FULL;\n+\n+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n+\n+    const long long idpos = pos;  // absolute\n+    const long long idoff = pos - m_start;  // relative\n+\n+    const long long id = ReadUInt(m_pReader, idpos, len);  // absolute\n+\n+    if (id < 0)  // error\n+      return static_cast<long>(id);\n+\n+    if (id == 0)  // weird\n+      return -1;  // generic error\n+\n+    pos += len;  // consume ID\n+\n+    // Read Size\n+\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n+    }\n+\n+    result = GetUIntLength(m_pReader, pos, len);\n+\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n+\n+    if (result > 0)  // weird\n+      return E_BUFFER_NOT_FULL;\n+\n+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n+\n+    const long long size = ReadUInt(m_pReader, pos, len);\n+\n+    if (size < 0)  // error\n+      return static_cast<long>(size);\n+\n+    pos += len;  // consume length of size of element\n+\n+    // Pos now points to start of payload\n+\n+    if (size == 0)  // weird\n+      continue;\n+\n+    const long long unknown_size = (1LL << (7 * len)) - 1;\n+\n+    if ((segment_stop >= 0) && (size != unknown_size) &&\n+        ((pos + size) > segment_stop)) {\n+      return E_FILE_FORMAT_INVALID;\n+    }\n+\n+    if (id == 0x0C53BB6B) {  // Cues ID\n+      if (size == unknown_size)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      const long long element_stop = pos + size;\n+\n+      if ((segment_stop >= 0) && (element_stop > segment_stop))\n+        return E_FILE_FORMAT_INVALID;\n+\n+      const long long element_start = idpos;\n+      const long long element_size = element_stop - element_start;\n+\n+      if (m_pCues == NULL) {\n+        m_pCues = new Cues(this, pos, size, element_start, element_size);\n+        assert(m_pCues);  // TODO\n+      }\n+\n+      pos += size;  // consume payload\n+      assert((segment_stop < 0) || (pos <= segment_stop));\n+\n+      continue;\n+    }\n+\n+    if (id != 0x0F43B675) {  // not a Cluster ID\n+      if (size == unknown_size)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      pos += size;  // consume payload\n+      assert((segment_stop < 0) || (pos <= segment_stop));\n+\n+      continue;\n+    }\n+\n+#if 0  // this is commented-out to support incremental cluster parsing\n         len = static_cast<long>(size);\n \n         if (element_stop > avail)\n             return E_BUFFER_NOT_FULL;\n #endif\n \n-        //We have a cluster.\n+    // We have a cluster.\n \n-        off_next = idoff;\n+    off_next = idoff;\n \n-        if (size != unknown_size)\n-            cluster_size = size;\n+    if (size != unknown_size)\n+      cluster_size = size;\n \n+    break;\n+  }\n+\n+  assert(off_next > 0);  // have cluster\n+\n+  // We have parsed the next cluster.\n+  // We have not created a cluster object yet.  What we need\n+  // to do now is determine whether it has already be preloaded\n+  //(in which case, an object for this cluster has already been\n+  // created), and if not, create a new cluster object.\n+\n+  Cluster** const ii = m_clusters + m_clusterCount;\n+  Cluster** i = ii;\n+\n+  Cluster** const jj = ii + m_clusterPreloadCount;\n+  Cluster** j = jj;\n+\n+  while (i < j) {\n+    // INVARIANT:\n+    //[0, i) < pos_next\n+    //[i, j) ?\n+    //[j, jj)  > pos_next\n+\n+    Cluster** const k = i + (j - i) / 2;\n+    assert(k < jj);\n+\n+    const Cluster* const pNext = *k;\n+    assert(pNext);\n+    assert(pNext->m_index < 0);\n+\n+    pos = pNext->GetPosition();\n+    assert(pos >= 0);\n+\n+    if (pos < off_next)\n+      i = k + 1;\n+    else if (pos > off_next)\n+      j = k;\n+    else {\n+      pResult = pNext;\n+      return 0;  // success\n+    }\n+  }\n+\n+  assert(i == j);\n+\n+  long long pos_;\n+  long len_;\n+\n+  status = Cluster::HasBlockEntries(this, off_next, pos_, len_);\n+\n+  if (status < 0) {  // error or underflow\n+    pos = pos_;\n+    len = len_;\n+\n+    return status;\n+  }\n+\n+  if (status > 0) {  // means \""found at least one block entry\""\n+    Cluster* const pNext = Cluster::Create(this,\n+                                           -1,  // preloaded\n+                                           off_next);\n+    // element_size);\n+    assert(pNext);\n+\n+    const ptrdiff_t idx_next = i - m_clusters;  // insertion position\n+\n+    PreloadCluster(pNext, idx_next);\n+    assert(m_clusters);\n+    assert(idx_next < m_clusterSize);\n+    assert(m_clusters[idx_next] == pNext);\n+\n+    pResult = pNext;\n+    return 0;  // success\n+  }\n+\n+  // status == 0 means \""no block entries found\""\n+\n+  if (cluster_size < 0) {  // unknown size\n+    const long long payload_pos = pos;  // absolute pos of cluster payload\n+\n+    for (;;) {  // determine cluster size\n+      if ((total >= 0) && (pos >= total))\n         break;\n-    }\n \n-    assert(off_next > 0);  //have cluster\n+      if ((segment_stop >= 0) && (pos >= segment_stop))\n+        break;  // no more clusters\n \n-    //We have parsed the next cluster.\n-    //We have not created a cluster object yet.  What we need\n-    //to do now is determine whether it has already be preloaded\n-    //(in which case, an object for this cluster has already been\n-    //created), and if not, create a new cluster object.\n+      // Read ID\n \n-    Cluster** const ii = m_clusters + m_clusterCount;\n-    Cluster** i = ii;\n+      if ((pos + 1) > avail) {\n+        len = 1;\n+        return E_BUFFER_NOT_FULL;\n+      }\n \n-    Cluster** const jj = ii + m_clusterPreloadCount;\n-    Cluster** j = jj;\n+      long long result = GetUIntLength(m_pReader, pos, len);\n \n-    while (i < j)\n-    {\n-        //INVARIANT:\n-        //[0, i) < pos_next\n-        //[i, j) ?\n-        //[j, jj)  > pos_next\n+      if (result < 0)  // error\n+        return static_cast<long>(result);\n \n-        Cluster** const k = i + (j - i) / 2;\n-        assert(k < jj);\n+      if (result > 0)  // weird\n+        return E_BUFFER_NOT_FULL;\n \n-        const Cluster* const pNext = *k;\n-        assert(pNext);\n-        assert(pNext->m_index < 0);\n+      if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n+        return E_FILE_FORMAT_INVALID;\n \n-        pos = pNext->GetPosition();\n-        assert(pos >= 0);\n+      if ((pos + len) > avail)\n+        return E_BUFFER_NOT_FULL;\n \n-        if (pos < off_next)\n-            i = k + 1;\n-        else if (pos > off_next)\n-            j = k;\n-        else\n-        {\n-            pResult = pNext;\n-            return 0;  //success\n-        }\n-    }\n+      const long long idpos = pos;\n+      const long long id = ReadUInt(m_pReader, idpos, len);\n \n-    assert(i == j);\n+      if (id < 0)  // error (or underflow)\n+        return static_cast<long>(id);\n \n-    long long pos_;\n-    long len_;\n+      // This is the distinguished set of ID's we use to determine\n+      // that we have exhausted the sub-element's inside the cluster\n+      // whose ID we parsed earlier.\n \n-    status = Cluster::HasBlockEntries(this, off_next, pos_, len_);\n+      if (id == 0x0F43B675)  // Cluster ID\n+        break;\n \n-    if (status < 0)  //error or underflow\n-    {\n-        pos = pos_;\n-        len = len_;\n+      if (id == 0x0C53BB6B)  // Cues ID\n+        break;\n \n-        return status;\n-    }\n+      pos += len;  // consume ID (of sub-element)\n \n-    if (status > 0)  //means \""found at least one block entry\""\n-    {\n-        Cluster* const pNext = Cluster::Create(this,\n-                                                -1,   //preloaded\n-                                                off_next);\n-                                                //element_size);\n-        assert(pNext);\n+      // Read Size\n \n-        const ptrdiff_t idx_next = i - m_clusters;  //insertion position\n+      if ((pos + 1) > avail) {\n+        len = 1;\n+        return E_BUFFER_NOT_FULL;\n+      }\n \n-        PreloadCluster(pNext, idx_next);\n-        assert(m_clusters);\n-        assert(idx_next < m_clusterSize);\n-        assert(m_clusters[idx_next] == pNext);\n+      result = GetUIntLength(m_pReader, pos, len);\n \n-        pResult = pNext;\n-        return 0;  //success\n-    }\n+      if (result < 0)  // error\n+        return static_cast<long>(result);\n \n-    //status == 0 means \""no block entries found\""\n+      if (result > 0)  // weird\n+        return E_BUFFER_NOT_FULL;\n \n-    if (cluster_size < 0)  //unknown size\n-    {\n-        const long long payload_pos = pos;  //absolute pos of cluster payload\n+      if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n+        return E_FILE_FORMAT_INVALID;\n \n-        for (;;)  //determine cluster size\n-        {\n-            if ((total >= 0) && (pos >= total))\n-                break;\n+      if ((pos + len) > avail)\n+        return E_BUFFER_NOT_FULL;\n \n-            if ((segment_stop >= 0) && (pos >= segment_stop))\n-                break;  //no more clusters\n+      const long long size = ReadUInt(m_pReader, pos, len);\n \n-            //Read ID\n+      if (size < 0)  // error\n+        return static_cast<long>(size);\n \n-            if ((pos + 1) > avail)\n-            {\n-                len = 1;\n-                return E_BUFFER_NOT_FULL;\n-            }\n+      pos += len;  // consume size field of element\n \n-            long long result = GetUIntLength(m_pReader, pos, len);\n+      // pos now points to start of sub-element's payload\n \n-            if (result < 0)  //error\n-                return static_cast<long>(result);\n+      if (size == 0)  // weird\n+        continue;\n \n-            if (result > 0)  //weird\n-                return E_BUFFER_NOT_FULL;\n+      const long long unknown_size = (1LL << (7 * len)) - 1;\n \n-            if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n-                return E_FILE_FORMAT_INVALID;\n+      if (size == unknown_size)\n+        return E_FILE_FORMAT_INVALID;  // not allowed for sub-elements\n \n-            if ((pos + len) > avail)\n-                return E_BUFFER_NOT_FULL;\n+      if ((segment_stop >= 0) && ((pos + size) > segment_stop))  // weird\n+        return E_FILE_FORMAT_INVALID;\n \n-            const long long idpos = pos;\n-            const long long id = ReadUInt(m_pReader, idpos, len);\n+      pos += size;  // consume payload of sub-element\n+      assert((segment_stop < 0) || (pos <= segment_stop));\n+    }  // determine cluster size\n \n-            if (id < 0)  //error (or underflow)\n-                return static_cast<long>(id);\n+    cluster_size = pos - payload_pos;\n+    assert(cluster_size >= 0);  // TODO: handle cluster_size = 0\n \n-            //This is the distinguished set of ID's we use to determine\n-            //that we have exhausted the sub-element's inside the cluster\n-            //whose ID we parsed earlier.\n+    pos = payload_pos;  // reset and re-parse original cluster\n+  }\n \n-            if (id == 0x0F43B675)  //Cluster ID\n-                break;\n+  pos += cluster_size;  // consume payload\n+  assert((segment_stop < 0) || (pos <= segment_stop));\n \n-            if (id == 0x0C53BB6B)  //Cues ID\n-                break;\n-\n-            pos += len;  //consume ID (of sub-element)\n-\n-            //Read Size\n-\n-            if ((pos + 1) > avail)\n-            {\n-                len = 1;\n-                return E_BUFFER_NOT_FULL;\n-            }\n-\n-            result = GetUIntLength(m_pReader, pos, len);\n-\n-            if (result < 0)  //error\n-                return static_cast<long>(result);\n-\n-            if (result > 0)  //weird\n-                return E_BUFFER_NOT_FULL;\n-\n-            if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n-                return E_FILE_FORMAT_INVALID;\n-\n-            if ((pos + len) > avail)\n-                return E_BUFFER_NOT_FULL;\n-\n-            const long long size = ReadUInt(m_pReader, pos, len);\n-\n-            if (size < 0)  //error\n-                return static_cast<long>(size);\n-\n-            pos += len;  //consume size field of element\n-\n-            //pos now points to start of sub-element's payload\n-\n-            if (size == 0)  //weird\n-                continue;\n-\n-            const long long unknown_size = (1LL << (7 * len)) - 1;\n-\n-            if (size == unknown_size)\n-                return E_FILE_FORMAT_INVALID;  //not allowed for sub-elements\n-\n-            if ((segment_stop >= 0) && ((pos + size) > segment_stop))  //weird\n-                return E_FILE_FORMAT_INVALID;\n-\n-            pos += size;  //consume payload of sub-element\n-            assert((segment_stop < 0) || (pos <= segment_stop));\n-        }  //determine cluster size\n-\n-        cluster_size = pos - payload_pos;\n-        assert(cluster_size >= 0);  //TODO: handle cluster_size = 0\n-\n-        pos = payload_pos;  //reset and re-parse original cluster\n-    }\n-\n-    pos += cluster_size;  //consume payload\n-    assert((segment_stop < 0) || (pos <= segment_stop));\n-\n-    return 2;             //try to find a cluster that follows next\n+  return 2;  // try to find a cluster that follows next\n }\n \n+const Cluster* Segment::FindCluster(long long time_ns) const {\n+  if ((m_clusters == NULL) || (m_clusterCount <= 0))\n+    return &m_eos;\n \n-const Cluster* Segment::FindCluster(long long time_ns) const\n-{\n-    if ((m_clusters == NULL) || (m_clusterCount <= 0))\n-        return &m_eos;\n+  {\n+    Cluster* const pCluster = m_clusters[0];\n+    assert(pCluster);\n+    assert(pCluster->m_index == 0);\n \n-    {\n-        Cluster* const pCluster = m_clusters[0];\n-        assert(pCluster);\n-        assert(pCluster->m_index == 0);\n+    if (time_ns <= pCluster->GetTime())\n+      return pCluster;\n+  }\n \n-        if (time_ns <= pCluster->GetTime())\n-            return pCluster;\n-    }\n+  // Binary search of cluster array\n \n-    //Binary search of cluster array\n+  long i = 0;\n+  long j = m_clusterCount;\n \n-    long i = 0;\n-    long j = m_clusterCount;\n+  while (i < j) {\n+    // INVARIANT:\n+    //[0, i) <= time_ns\n+    //[i, j) ?\n+    //[j, m_clusterCount)  > time_ns\n \n-    while (i < j)\n-    {\n-        //INVARIANT:\n-        //[0, i) <= time_ns\n-        //[i, j) ?\n-        //[j, m_clusterCount)  > time_ns\n-\n-        const long k = i + (j - i) / 2;\n-        assert(k < m_clusterCount);\n-\n-        Cluster* const pCluster = m_clusters[k];\n-        assert(pCluster);\n-        assert(pCluster->m_index == k);\n-\n-        const long long t = pCluster->GetTime();\n-\n-        if (t <= time_ns)\n-            i = k + 1;\n-        else\n-            j = k;\n-\n-        assert(i <= j);\n-    }\n-\n-    assert(i == j);\n-    assert(i > 0);\n-    assert(i <= m_clusterCount);\n-\n-    const long k = i - 1;\n+    const long k = i + (j - i) / 2;\n+    assert(k < m_clusterCount);\n \n     Cluster* const pCluster = m_clusters[k];\n     assert(pCluster);\n     assert(pCluster->m_index == k);\n-    assert(pCluster->GetTime() <= time_ns);\n \n-    return pCluster;\n+    const long long t = pCluster->GetTime();\n+\n+    if (t <= time_ns)\n+      i = k + 1;\n+    else\n+      j = k;\n+\n+    assert(i <= j);\n+  }\n+\n+  assert(i == j);\n+  assert(i > 0);\n+  assert(i <= m_clusterCount);\n+\n+  const long k = i - 1;\n+\n+  Cluster* const pCluster = m_clusters[k];\n+  assert(pCluster);\n+  assert(pCluster->m_index == k);\n+  assert(pCluster->GetTime() <= time_ns);\n+\n+  return pCluster;\n }\n \n-\n #if 0\n const BlockEntry* Segment::Seek(\n     long long time_ns,\n@@ -4059,8 +3674,7 @@\n\n \n     Cluster** const j = i + m_clusterCount;\n \n-    if (pTrack->GetType() == 2)  //audio\n-    {\n+    if (pTrack->GetType() == 2) {  //audio\n         //TODO: we could decide to use cues for this, as we do for video.\n         //But we only use it for video because looking around for a keyframe\n         //can get expensive.  Audio doesn't require anything special so a\n@@ -4179,7 +3793,6 @@\n\n }\n #endif\n \n-\n #if 0\n bool Segment::SearchCues(\n     long long time_ns,\n@@ -4210,845 +3823,593 @@\n\n }\n #endif\n \n+const Tracks* Segment::GetTracks() const { return m_pTracks; }\n \n-const Tracks* Segment::GetTracks() const\n-{\n-    return m_pTracks;\n+const SegmentInfo* Segment::GetInfo() const { return m_pInfo; }\n+\n+const Cues* Segment::GetCues() const { return m_pCues; }\n+\n+const Chapters* Segment::GetChapters() const { return m_pChapters; }\n+\n+const SeekHead* Segment::GetSeekHead() const { return m_pSeekHead; }\n+\n+long long Segment::GetDuration() const {\n+  assert(m_pInfo);\n+  return m_pInfo->GetDuration();\n }\n \n+Chapters::Chapters(Segment* pSegment, long long payload_start,\n+                   long long payload_size, long long element_start,\n+                   long long element_size)\n+    : m_pSegment(pSegment),\n+      m_start(payload_start),\n+      m_size(payload_size),\n+      m_element_start(element_start),\n+      m_element_size(element_size),\n+      m_editions(NULL),\n+      m_editions_size(0),\n+      m_editions_count(0) {}\n \n-const SegmentInfo* Segment::GetInfo() const\n-{\n-    return m_pInfo;\n+Chapters::~Chapters() {\n+  while (m_editions_count > 0) {\n+    Edition& e = m_editions[--m_editions_count];\n+    e.Clear();\n+  }\n }\n \n+long Chapters::Parse() {\n+  IMkvReader* const pReader = m_pSegment->m_pReader;\n \n-const Cues* Segment::GetCues() const\n-{\n-    return m_pCues;\n-}\n+  long long pos = m_start;  // payload start\n+  const long long stop = pos + m_size;  // payload stop\n \n+  while (pos < stop) {\n+    long long id, size;\n \n-const Chapters* Segment::GetChapters() const\n-{\n-  return m_pChapters;\n-}\n+    long status = ParseElementHeader(pReader, pos, stop, id, size);\n \n+    if (status < 0)  // error\n+      return status;\n \n-const SeekHead* Segment::GetSeekHead() const\n-{\n-    return m_pSeekHead;\n-}\n+    if (size == 0)  // weird\n+      continue;\n \n+    if (id == 0x05B9) {  // EditionEntry ID\n+      status = ParseEdition(pos, size);\n \n-long long Segment::GetDuration() const\n-{\n-    assert(m_pInfo);\n-    return m_pInfo->GetDuration();\n-}\n-\n-\n-Chapters::Chapters(\n-    Segment* pSegment,\n-    long long payload_start,\n-    long long payload_size,\n-    long long element_start,\n-    long long element_size) :\n-    m_pSegment(pSegment),\n-    m_start(payload_start),\n-    m_size(payload_size),\n-    m_element_start(element_start),\n-    m_element_size(element_size),\n-    m_editions(NULL),\n-    m_editions_size(0),\n-    m_editions_count(0)\n-{\n-}\n-\n-\n-Chapters::~Chapters()\n-{\n-    while (m_editions_count > 0)\n-    {\n-        Edition& e = m_editions[--m_editions_count];\n-        e.Clear();\n-    }\n-}\n-\n-\n-long Chapters::Parse()\n-{\n-    IMkvReader* const pReader = m_pSegment->m_pReader;\n-\n-    long long pos = m_start;  // payload start\n-    const long long stop = pos + m_size;  // payload stop\n-\n-    while (pos < stop)\n-    {\n-        long long id, size;\n-\n-        long status = ParseElementHeader(\n-                        pReader,\n-                        pos,\n-                        stop,\n-                        id,\n-                        size);\n-\n-        if (status < 0)  // error\n-            return status;\n-\n-        if (size == 0)  // weird\n-            continue;\n-\n-        if (id == 0x05B9)  // EditionEntry ID\n-        {\n-            status = ParseEdition(pos, size);\n-\n-            if (status < 0)  // error\n-                return status;\n-        }\n-\n-        pos += size;\n-        assert(pos <= stop);\n+      if (status < 0)  // error\n+        return status;\n     }\n \n-    assert(pos == stop);\n-    return 0;\n+    pos += size;\n+    assert(pos <= stop);\n+  }\n+\n+  assert(pos == stop);\n+  return 0;\n }\n \n+int Chapters::GetEditionCount() const { return m_editions_count; }\n \n-int Chapters::GetEditionCount() const\n-{\n-    return m_editions_count;\n+const Chapters::Edition* Chapters::GetEdition(int idx) const {\n+  if (idx < 0)\n+    return NULL;\n+\n+  if (idx >= m_editions_count)\n+    return NULL;\n+\n+  return m_editions + idx;\n }\n \n+bool Chapters::ExpandEditionsArray() {\n+  if (m_editions_size > m_editions_count)\n+    return true;  // nothing else to do\n \n-const Chapters::Edition* Chapters::GetEdition(int idx) const\n-{\n-    if (idx < 0)\n-        return NULL;\n+  const int size = (m_editions_size == 0) ? 1 : 2 * m_editions_size;\n \n-    if (idx >= m_editions_count)\n-        return NULL;\n+  Edition* const editions = new (std::nothrow) Edition[size];\n \n-    return m_editions + idx;\n+  if (editions == NULL)\n+    return false;\n+\n+  for (int idx = 0; idx < m_editions_count; ++idx) {\n+    m_editions[idx].ShallowCopy(editions[idx]);\n+  }\n+\n+  delete[] m_editions;\n+  m_editions = editions;\n+\n+  m_editions_size = size;\n+  return true;\n }\n \n+long Chapters::ParseEdition(long long pos, long long size) {\n+  if (!ExpandEditionsArray())\n+    return -1;\n \n-bool Chapters::ExpandEditionsArray()\n-{\n-    if (m_editions_size > m_editions_count)\n-        return true;  // nothing else to do\n+  Edition& e = m_editions[m_editions_count++];\n+  e.Init();\n \n-    const int size = (m_editions_size == 0) ? 1 : 2 * m_editions_size;\n+  return e.Parse(m_pSegment->m_pReader, pos, size);\n+}\n \n-    Edition* const editions = new (std::nothrow) Edition[size];\n+Chapters::Edition::Edition() {}\n \n-    if (editions == NULL)\n-        return false;\n+Chapters::Edition::~Edition() {}\n \n-    for (int idx = 0; idx < m_editions_count; ++idx)\n-    {\n-        m_editions[idx].ShallowCopy(editions[idx]);\n+int Chapters::Edition::GetAtomCount() const { return m_atoms_count; }\n+\n+const Chapters::Atom* Chapters::Edition::GetAtom(int index) const {\n+  if (index < 0)\n+    return NULL;\n+\n+  if (index >= m_atoms_count)\n+    return NULL;\n+\n+  return m_atoms + index;\n+}\n+\n+void Chapters::Edition::Init() {\n+  m_atoms = NULL;\n+  m_atoms_size = 0;\n+  m_atoms_count = 0;\n+}\n+\n+void Chapters::Edition::ShallowCopy(Edition& rhs) const {\n+  rhs.m_atoms = m_atoms;\n+  rhs.m_atoms_size = m_atoms_size;\n+  rhs.m_atoms_count = m_atoms_count;\n+}\n+\n+void Chapters::Edition::Clear() {\n+  while (m_atoms_count > 0) {\n+    Atom& a = m_atoms[--m_atoms_count];\n+    a.Clear();\n+  }\n+\n+  delete[] m_atoms;\n+  m_atoms = NULL;\n+\n+  m_atoms_size = 0;\n+}\n+\n+long Chapters::Edition::Parse(IMkvReader* pReader, long long pos,\n+                              long long size) {\n+  const long long stop = pos + size;\n+\n+  while (pos < stop) {\n+    long long id, size;\n+\n+    long status = ParseElementHeader(pReader, pos, stop, id, size);\n+\n+    if (status < 0)  // error\n+      return status;\n+\n+    if (size == 0)  // weird\n+      continue;\n+\n+    if (id == 0x36) {  // Atom ID\n+      status = ParseAtom(pReader, pos, size);\n+\n+      if (status < 0)  // error\n+        return status;\n     }\n \n-    delete[] m_editions;\n-    m_editions = editions;\n+    pos += size;\n+    assert(pos <= stop);\n+  }\n \n-    m_editions_size = size;\n-    return true;\n+  assert(pos == stop);\n+  return 0;\n }\n \n+long Chapters::Edition::ParseAtom(IMkvReader* pReader, long long pos,\n+                                  long long size) {\n+  if (!ExpandAtomsArray())\n+    return -1;\n \n-long Chapters::ParseEdition(\n-    long long pos,\n-    long long size)\n-{\n-    if (!ExpandEditionsArray())\n-        return -1;\n+  Atom& a = m_atoms[m_atoms_count++];\n+  a.Init();\n \n-    Edition& e = m_editions[m_editions_count++];\n-    e.Init();\n-\n-    return e.Parse(m_pSegment->m_pReader, pos, size);\n+  return a.Parse(pReader, pos, size);\n }\n \n+bool Chapters::Edition::ExpandAtomsArray() {\n+  if (m_atoms_size > m_atoms_count)\n+    return true;  // nothing else to do\n \n-Chapters::Edition::Edition()\n-{\n+  const int size = (m_atoms_size == 0) ? 1 : 2 * m_atoms_size;\n+\n+  Atom* const atoms = new (std::nothrow) Atom[size];\n+\n+  if (atoms == NULL)\n+    return false;\n+\n+  for (int idx = 0; idx < m_atoms_count; ++idx) {\n+    m_atoms[idx].ShallowCopy(atoms[idx]);\n+  }\n+\n+  delete[] m_atoms;\n+  m_atoms = atoms;\n+\n+  m_atoms_size = size;\n+  return true;\n }\n \n+Chapters::Atom::Atom() {}\n \n-Chapters::Edition::~Edition()\n-{\n+Chapters::Atom::~Atom() {}\n+\n+unsigned long long Chapters::Atom::GetUID() const { return m_uid; }\n+\n+const char* Chapters::Atom::GetStringUID() const { return m_string_uid; }\n+\n+long long Chapters::Atom::GetStartTimecode() const { return m_start_timecode; }\n+\n+long long Chapters::Atom::GetStopTimecode() const { return m_stop_timecode; }\n+\n+long long Chapters::Atom::GetStartTime(const Chapters* pChapters) const {\n+  return GetTime(pChapters, m_start_timecode);\n }\n \n-\n-int Chapters::Edition::GetAtomCount() const\n-{\n-    return m_atoms_count;\n+long long Chapters::Atom::GetStopTime(const Chapters* pChapters) const {\n+  return GetTime(pChapters, m_stop_timecode);\n }\n \n+int Chapters::Atom::GetDisplayCount() const { return m_displays_count; }\n \n-const Chapters::Atom* Chapters::Edition::GetAtom(int index) const\n-{\n-    if (index < 0)\n-        return NULL;\n+const Chapters::Display* Chapters::Atom::GetDisplay(int index) const {\n+  if (index < 0)\n+    return NULL;\n \n-    if (index >= m_atoms_count)\n-        return NULL;\n+  if (index >= m_displays_count)\n+    return NULL;\n \n-    return m_atoms + index;\n+  return m_displays + index;\n }\n \n+void Chapters::Atom::Init() {\n+  m_string_uid = NULL;\n+  m_uid = 0;\n+  m_start_timecode = -1;\n+  m_stop_timecode = -1;\n \n-void Chapters::Edition::Init()\n-{\n-    m_atoms = NULL;\n-    m_atoms_size = 0;\n-    m_atoms_count = 0;\n+  m_displays = NULL;\n+  m_displays_size = 0;\n+  m_displays_count = 0;\n }\n \n+void Chapters::Atom::ShallowCopy(Atom& rhs) const {\n+  rhs.m_string_uid = m_string_uid;\n+  rhs.m_uid = m_uid;\n+  rhs.m_start_timecode = m_start_timecode;\n+  rhs.m_stop_timecode = m_stop_timecode;\n \n-void Chapters::Edition::ShallowCopy(Edition& rhs) const\n-{\n-    rhs.m_atoms = m_atoms;\n-    rhs.m_atoms_size = m_atoms_size;\n-    rhs.m_atoms_count = m_atoms_count;\n+  rhs.m_displays = m_displays;\n+  rhs.m_displays_size = m_displays_size;\n+  rhs.m_displays_count = m_displays_count;\n }\n \n+void Chapters::Atom::Clear() {\n+  delete[] m_string_uid;\n+  m_string_uid = NULL;\n \n-void Chapters::Edition::Clear()\n-{\n-    while (m_atoms_count > 0)\n-    {\n-        Atom& a = m_atoms[--m_atoms_count];\n-        a.Clear();\n+  while (m_displays_count > 0) {\n+    Display& d = m_displays[--m_displays_count];\n+    d.Clear();\n+  }\n+\n+  delete[] m_displays;\n+  m_displays = NULL;\n+\n+  m_displays_size = 0;\n+}\n+\n+long Chapters::Atom::Parse(IMkvReader* pReader, long long pos, long long size) {\n+  const long long stop = pos + size;\n+\n+  while (pos < stop) {\n+    long long id, size;\n+\n+    long status = ParseElementHeader(pReader, pos, stop, id, size);\n+\n+    if (status < 0)  // error\n+      return status;\n+\n+    if (size == 0)  // weird\n+      continue;\n+\n+    if (id == 0x00) {  // Display ID\n+      status = ParseDisplay(pReader, pos, size);\n+\n+      if (status < 0)  // error\n+        return status;\n+    } else if (id == 0x1654) {  // StringUID ID\n+      status = UnserializeString(pReader, pos, size, m_string_uid);\n+\n+      if (status < 0)  // error\n+        return status;\n+    } else if (id == 0x33C4) {  // UID ID\n+      long long val;\n+      status = UnserializeInt(pReader, pos, size, val);\n+\n+      if (val < 0)  // error\n+        return status;\n+\n+      m_uid = static_cast<unsigned long long>(val);\n+    } else if (id == 0x11) {  // TimeStart ID\n+      const long long val = UnserializeUInt(pReader, pos, size);\n+\n+      if (val < 0)  // error\n+        return static_cast<long>(val);\n+\n+      m_start_timecode = val;\n+    } else if (id == 0x12) {  // TimeEnd ID\n+      const long long val = UnserializeUInt(pReader, pos, size);\n+\n+      if (val < 0)  // error\n+        return static_cast<long>(val);\n+\n+      m_stop_timecode = val;\n     }\n \n-    delete[] m_atoms;\n-    m_atoms = NULL;\n+    pos += size;\n+    assert(pos <= stop);\n+  }\n \n-    m_atoms_size = 0;\n+  assert(pos == stop);\n+  return 0;\n }\n \n+long long Chapters::Atom::GetTime(const Chapters* pChapters,\n+                                  long long timecode) {\n+  if (pChapters == NULL)\n+    return -1;\n \n-long Chapters::Edition::Parse(\n-    IMkvReader* pReader,\n-    long long pos,\n-    long long size)\n-{\n-    const long long stop = pos + size;\n+  Segment* const pSegment = pChapters->m_pSegment;\n \n-    while (pos < stop)\n-    {\n-        long long id, size;\n+  if (pSegment == NULL)  // weird\n+    return -1;\n \n-        long status = ParseElementHeader(\n-                        pReader,\n-                        pos,\n-                        stop,\n-                        id,\n-                        size);\n+  const SegmentInfo* const pInfo = pSegment->GetInfo();\n \n-        if (status < 0)  // error\n-            return status;\n+  if (pInfo == NULL)\n+    return -1;\n \n-        if (size == 0)  // weird\n-            continue;\n+  const long long timecode_scale = pInfo->GetTimeCodeScale();\n \n-        if (id == 0x36)  // Atom ID\n-        {\n-            status = ParseAtom(pReader, pos, size);\n+  if (timecode_scale < 1)  // weird\n+    return -1;\n \n-            if (status < 0)  // error\n-                return status;\n-        }\n+  if (timecode < 0)\n+    return -1;\n \n-        pos += size;\n-        assert(pos <= stop);\n+  const long long result = timecode_scale * timecode;\n+\n+  return result;\n+}\n+\n+long Chapters::Atom::ParseDisplay(IMkvReader* pReader, long long pos,\n+                                  long long size) {\n+  if (!ExpandDisplaysArray())\n+    return -1;\n+\n+  Display& d = m_displays[m_displays_count++];\n+  d.Init();\n+\n+  return d.Parse(pReader, pos, size);\n+}\n+\n+bool Chapters::Atom::ExpandDisplaysArray() {\n+  if (m_displays_size > m_displays_count)\n+    return true;  // nothing else to do\n+\n+  const int size = (m_displays_size == 0) ? 1 : 2 * m_displays_size;\n+\n+  Display* const displays = new (std::nothrow) Display[size];\n+\n+  if (displays == NULL)\n+    return false;\n+\n+  for (int idx = 0; idx < m_displays_count; ++idx) {\n+    m_displays[idx].ShallowCopy(displays[idx]);\n+  }\n+\n+  delete[] m_displays;\n+  m_displays = displays;\n+\n+  m_displays_size = size;\n+  return true;\n+}\n+\n+Chapters::Display::Display() {}\n+\n+Chapters::Display::~Display() {}\n+\n+const char* Chapters::Display::GetString() const { return m_string; }\n+\n+const char* Chapters::Display::GetLanguage() const { return m_language; }\n+\n+const char* Chapters::Display::GetCountry() const { return m_country; }\n+\n+void Chapters::Display::Init() {\n+  m_string = NULL;\n+  m_language = NULL;\n+  m_country = NULL;\n+}\n+\n+void Chapters::Display::ShallowCopy(Display& rhs) const {\n+  rhs.m_string = m_string;\n+  rhs.m_language = m_language;\n+  rhs.m_country = m_country;\n+}\n+\n+void Chapters::Display::Clear() {\n+  delete[] m_string;\n+  m_string = NULL;\n+\n+  delete[] m_language;\n+  m_language = NULL;\n+\n+  delete[] m_country;\n+  m_country = NULL;\n+}\n+\n+long Chapters::Display::Parse(IMkvReader* pReader, long long pos,\n+                              long long size) {\n+  const long long stop = pos + size;\n+\n+  while (pos < stop) {\n+    long long id, size;\n+\n+    long status = ParseElementHeader(pReader, pos, stop, id, size);\n+\n+    if (status < 0)  // error\n+      return status;\n+\n+    if (size == 0)  // weird\n+      continue;\n+\n+    if (id == 0x05) {  // ChapterString ID\n+      status = UnserializeString(pReader, pos, size, m_string);\n+\n+      if (status)\n+        return status;\n+    } else if (id == 0x037C) {  // ChapterLanguage ID\n+      status = UnserializeString(pReader, pos, size, m_language);\n+\n+      if (status)\n+        return status;\n+    } else if (id == 0x037E) {  // ChapterCountry ID\n+      status = UnserializeString(pReader, pos, size, m_country);\n+\n+      if (status)\n+        return status;\n     }\n \n-    assert(pos == stop);\n-    return 0;\n+    pos += size;\n+    assert(pos <= stop);\n+  }\n+\n+  assert(pos == stop);\n+  return 0;\n }\n \n+SegmentInfo::SegmentInfo(Segment* pSegment, long long start, long long size_,\n+                         long long element_start, long long element_size)\n+    : m_pSegment(pSegment),\n+      m_start(start),\n+      m_size(size_),\n+      m_element_start(element_start),\n+      m_element_size(element_size),\n+      m_pMuxingAppAsUTF8(NULL),\n+      m_pWritingAppAsUTF8(NULL),\n+      m_pTitleAsUTF8(NULL) {}\n \n-long Chapters::Edition::ParseAtom(\n-    IMkvReader* pReader,\n-    long long pos,\n-    long long size)\n-{\n-    if (!ExpandAtomsArray())\n-        return -1;\n+SegmentInfo::~SegmentInfo() {\n+  delete[] m_pMuxingAppAsUTF8;\n+  m_pMuxingAppAsUTF8 = NULL;\n \n-    Atom& a = m_atoms[m_atoms_count++];\n-    a.Init();\n+  delete[] m_pWritingAppAsUTF8;\n+  m_pWritingAppAsUTF8 = NULL;\n \n-    return a.Parse(pReader, pos, size);\n+  delete[] m_pTitleAsUTF8;\n+  m_pTitleAsUTF8 = NULL;\n }\n \n+long SegmentInfo::Parse() {\n+  assert(m_pMuxingAppAsUTF8 == NULL);\n+  assert(m_pWritingAppAsUTF8 == NULL);\n+  assert(m_pTitleAsUTF8 == NULL);\n \n-bool Chapters::Edition::ExpandAtomsArray()\n-{\n-    if (m_atoms_size > m_atoms_count)\n-        return true;  // nothing else to do\n+  IMkvReader* const pReader = m_pSegment->m_pReader;\n \n-    const int size = (m_atoms_size == 0) ? 1 : 2 * m_atoms_size;\n+  long long pos = m_start;\n+  const long long stop = m_start + m_size;\n \n-    Atom* const atoms = new (std::nothrow) Atom[size];\n+  m_timecodeScale = 1000000;\n+  m_duration = -1;\n \n-    if (atoms == NULL)\n-        return false;\n+  while (pos < stop) {\n+    long long id, size;\n \n-    for (int idx = 0; idx < m_atoms_count; ++idx)\n-    {\n-        m_atoms[idx].ShallowCopy(atoms[idx]);\n+    const long status = ParseElementHeader(pReader, pos, stop, id, size);\n+\n+    if (status < 0)  // error\n+      return status;\n+\n+    if (id == 0x0AD7B1) {  // Timecode Scale\n+      m_timecodeScale = UnserializeUInt(pReader, pos, size);\n+\n+      if (m_timecodeScale <= 0)\n+        return E_FILE_FORMAT_INVALID;\n+    } else if (id == 0x0489) {  // Segment duration\n+      const long status = UnserializeFloat(pReader, pos, size, m_duration);\n+\n+      if (status < 0)\n+        return status;\n+\n+      if (m_duration < 0)\n+        return E_FILE_FORMAT_INVALID;\n+    } else if (id == 0x0D80) {  // MuxingApp\n+      const long status =\n+          UnserializeString(pReader, pos, size, m_pMuxingAppAsUTF8);\n+\n+      if (status)\n+        return status;\n+    } else if (id == 0x1741) {  // WritingApp\n+      const long status =\n+          UnserializeString(pReader, pos, size, m_pWritingAppAsUTF8);\n+\n+      if (status)\n+        return status;\n+    } else if (id == 0x3BA9) {  // Title\n+      const long status = UnserializeString(pReader, pos, size, m_pTitleAsUTF8);\n+\n+      if (status)\n+        return status;\n     }\n \n-    delete[] m_atoms;\n-    m_atoms = atoms;\n+    pos += size;\n+    assert(pos <= stop);\n+  }\n \n-    m_atoms_size = size;\n-    return true;\n+  assert(pos == stop);\n+\n+  return 0;\n }\n \n+long long SegmentInfo::GetTimeCodeScale() const { return m_timecodeScale; }\n \n-Chapters::Atom::Atom()\n-{\n+long long SegmentInfo::GetDuration() const {\n+  if (m_duration < 0)\n+    return -1;\n+\n+  assert(m_timecodeScale >= 1);\n+\n+  const double dd = double(m_duration) * double(m_timecodeScale);\n+  const long long d = static_cast<long long>(dd);\n+\n+  return d;\n }\n \n-\n-Chapters::Atom::~Atom()\n-{\n+const char* SegmentInfo::GetMuxingAppAsUTF8() const {\n+  return m_pMuxingAppAsUTF8;\n }\n \n-\n-unsigned long long Chapters::Atom::GetUID() const\n-{\n-    return m_uid;\n+const char* SegmentInfo::GetWritingAppAsUTF8() const {\n+  return m_pWritingAppAsUTF8;\n }\n \n-\n-const char* Chapters::Atom::GetStringUID() const\n-{\n-    return m_string_uid;\n-}\n-\n-\n-long long Chapters::Atom::GetStartTimecode() const\n-{\n-    return m_start_timecode;\n-}\n-\n-\n-long long Chapters::Atom::GetStopTimecode() const\n-{\n-    return m_stop_timecode;\n-}\n-\n-\n-long long Chapters::Atom::GetStartTime(const Chapters* pChapters) const\n-{\n-    return GetTime(pChapters, m_start_timecode);\n-}\n-\n-\n-long long Chapters::Atom::GetStopTime(const Chapters* pChapters) const\n-{\n-    return GetTime(pChapters, m_stop_timecode);\n-}\n-\n-\n-int Chapters::Atom::GetDisplayCount() const\n-{\n-    return m_displays_count;\n-}\n-\n-\n-const Chapters::Display* Chapters::Atom::GetDisplay(int index) const\n-{\n-    if (index < 0)\n-        return NULL;\n-\n-    if (index >= m_displays_count)\n-        return NULL;\n-\n-    return m_displays + index;\n-}\n-\n-\n-void Chapters::Atom::Init()\n-{\n-    m_string_uid = NULL;\n-    m_uid = 0;\n-    m_start_timecode = -1;\n-    m_stop_timecode = -1;\n-\n-    m_displays = NULL;\n-    m_displays_size = 0;\n-    m_displays_count = 0;\n-}\n-\n-\n-void Chapters::Atom::ShallowCopy(Atom& rhs) const\n-{\n-    rhs.m_string_uid = m_string_uid;\n-    rhs.m_uid = m_uid;\n-    rhs.m_start_timecode = m_start_timecode;\n-    rhs.m_stop_timecode = m_stop_timecode;\n-\n-    rhs.m_displays = m_displays;\n-    rhs.m_displays_size = m_displays_size;\n-    rhs.m_displays_count = m_displays_count;\n-}\n-\n-\n-void Chapters::Atom::Clear()\n-{\n-    delete[] m_string_uid;\n-    m_string_uid = NULL;\n-\n-    while (m_displays_count > 0)\n-    {\n-        Display& d = m_displays[--m_displays_count];\n-        d.Clear();\n-    }\n-\n-    delete[] m_displays;\n-    m_displays = NULL;\n-\n-    m_displays_size = 0;\n-}\n-\n-\n-long Chapters::Atom::Parse(\n-    IMkvReader* pReader,\n-    long long pos,\n-    long long size)\n-{\n-    const long long stop = pos + size;\n-\n-    while (pos < stop)\n-    {\n-        long long id, size;\n-\n-        long status = ParseElementHeader(\n-                        pReader,\n-                        pos,\n-                        stop,\n-                        id,\n-                        size);\n-\n-        if (status < 0)  // error\n-            return status;\n-\n-        if (size == 0)  // weird\n-            continue;\n-\n-        if (id == 0x00)  // Display ID\n-        {\n-            status = ParseDisplay(pReader, pos, size);\n-\n-            if (status < 0)  // error\n-                return status;\n-        }\n-        else if (id == 0x1654)  // StringUID ID\n-        {\n-            status = UnserializeString(pReader, pos, size, m_string_uid);\n-\n-            if (status < 0)  // error\n-                return status;\n-        }\n-        else if (id == 0x33C4)  // UID ID\n-        {\n-            long long val;\n-            status = UnserializeInt(pReader, pos, size, val);\n-\n-            if (status < 0)  // error\n-                return status;\n-\n-            m_uid = val;\n-        }\n-        else if (id == 0x11)  // TimeStart ID\n-        {\n-            const long long val = UnserializeUInt(pReader, pos, size);\n-\n-            if (val < 0)  // error\n-                return static_cast<long>(val);\n-\n-            m_start_timecode = val;\n-        }\n-        else if (id == 0x12)  // TimeEnd ID\n-        {\n-            const long long val = UnserializeUInt(pReader, pos, size);\n-\n-            if (val < 0)  // error\n-                return static_cast<long>(val);\n-\n-            m_stop_timecode = val;\n-        }\n-\n-        pos += size;\n-        assert(pos <= stop);\n-    }\n-\n-    assert(pos == stop);\n-    return 0;\n-}\n-\n-\n-long long Chapters::Atom::GetTime(\n-    const Chapters* pChapters,\n-    long long timecode)\n-{\n-    if (pChapters == NULL)\n-        return -1;\n-\n-    Segment* const pSegment = pChapters->m_pSegment;\n-\n-    if (pSegment == NULL)  // weird\n-        return -1;\n-\n-    const SegmentInfo* const pInfo = pSegment->GetInfo();\n-\n-    if (pInfo == NULL)\n-        return -1;\n-\n-    const long long timecode_scale = pInfo->GetTimeCodeScale();\n-\n-    if (timecode_scale < 1)  // weird\n-        return -1;\n-\n-    if (timecode < 0)\n-        return -1;\n-\n-    const long long result = timecode_scale * timecode;\n-\n-    return result;\n-}\n-\n-\n-long Chapters::Atom::ParseDisplay(\n-    IMkvReader* pReader,\n-    long long pos,\n-    long long size)\n-{\n-    if (!ExpandDisplaysArray())\n-        return -1;\n-\n-    Display& d = m_displays[m_displays_count++];\n-    d.Init();\n-\n-    return d.Parse(pReader, pos, size);\n-}\n-\n-\n-bool Chapters::Atom::ExpandDisplaysArray()\n-{\n-    if (m_displays_size > m_displays_count)\n-        return true;  // nothing else to do\n-\n-    const int size = (m_displays_size == 0) ? 1 : 2 * m_displays_size;\n-\n-    Display* const displays = new (std::nothrow) Display[size];\n-\n-    if (displays == NULL)\n-        return false;\n-\n-    for (int idx = 0; idx < m_displays_count; ++idx)\n-    {\n-        m_displays[idx].ShallowCopy(displays[idx]);\n-    }\n-\n-    delete[] m_displays;\n-    m_displays = displays;\n-\n-    m_displays_size = size;\n-    return true;\n-}\n-\n-\n-Chapters::Display::Display()\n-{\n-}\n-\n-\n-Chapters::Display::~Display()\n-{\n-}\n-\n-\n-const char* Chapters::Display::GetString() const\n-{\n-    return m_string;\n-}\n-\n-\n-const char* Chapters::Display::GetLanguage() const\n-{\n-    return m_language;\n-}\n-\n-\n-const char* Chapters::Display::GetCountry() const\n-{\n-    return m_country;\n-}\n-\n-\n-void Chapters::Display::Init()\n-{\n-    m_string = NULL;\n-    m_language = NULL;\n-    m_country = NULL;\n-}\n-\n-\n-void Chapters::Display::ShallowCopy(Display& rhs) const\n-{\n-    rhs.m_string = m_string;\n-    rhs.m_language = m_language;\n-    rhs.m_country = m_country;\n-}\n-\n-\n-void Chapters::Display::Clear()\n-{\n-    delete[] m_string;\n-    m_string = NULL;\n-\n-    delete[] m_language;\n-    m_language = NULL;\n-\n-    delete[] m_country;\n-    m_country = NULL;\n-}\n-\n-\n-long Chapters::Display::Parse(\n-    IMkvReader* pReader,\n-    long long pos,\n-    long long size)\n-{\n-    const long long stop = pos + size;\n-\n-    while (pos < stop)\n-    {\n-        long long id, size;\n-\n-        long status = ParseElementHeader(\n-                        pReader,\n-                        pos,\n-                        stop,\n-                        id,\n-                        size);\n-\n-        if (status < 0)  // error\n-            return status;\n-\n-        if (size == 0)  // weird\n-            continue;\n-\n-        if (id == 0x05)  // ChapterString ID\n-        {\n-            status = UnserializeString(pReader, pos, size, m_string);\n-\n-            if (status)\n-              return status;\n-        }\n-        else if (id == 0x037C)  // ChapterLanguage ID\n-        {\n-            status = UnserializeString(pReader, pos, size, m_language);\n-\n-            if (status)\n-              return status;\n-        }\n-        else if (id == 0x037E)  // ChapterCountry ID\n-        {\n-            status = UnserializeString(pReader, pos, size, m_country);\n-\n-            if (status)\n-              return status;\n-        }\n-\n-        pos += size;\n-        assert(pos <= stop);\n-    }\n-\n-    assert(pos == stop);\n-    return 0;\n-}\n-\n-\n-SegmentInfo::SegmentInfo(\n-    Segment* pSegment,\n-    long long start,\n-    long long size_,\n-    long long element_start,\n-    long long element_size) :\n-    m_pSegment(pSegment),\n-    m_start(start),\n-    m_size(size_),\n-    m_element_start(element_start),\n-    m_element_size(element_size),\n-    m_pMuxingAppAsUTF8(NULL),\n-    m_pWritingAppAsUTF8(NULL),\n-    m_pTitleAsUTF8(NULL)\n-{\n-}\n-\n-SegmentInfo::~SegmentInfo()\n-{\n-    delete[] m_pMuxingAppAsUTF8;\n-    m_pMuxingAppAsUTF8 = NULL;\n-\n-    delete[] m_pWritingAppAsUTF8;\n-    m_pWritingAppAsUTF8 = NULL;\n-\n-    delete[] m_pTitleAsUTF8;\n-    m_pTitleAsUTF8 = NULL;\n-}\n-\n-\n-long SegmentInfo::Parse()\n-{\n-    assert(m_pMuxingAppAsUTF8 == NULL);\n-    assert(m_pWritingAppAsUTF8 == NULL);\n-    assert(m_pTitleAsUTF8 == NULL);\n-\n-    IMkvReader* const pReader = m_pSegment->m_pReader;\n-\n-    long long pos = m_start;\n-    const long long stop = m_start + m_size;\n-\n-    m_timecodeScale = 1000000;\n-    m_duration = -1;\n-\n-    while (pos < stop)\n-    {\n-        long long id, size;\n-\n-        const long status = ParseElementHeader(\n-                                pReader,\n-                                pos,\n-                                stop,\n-                                id,\n-                                size);\n-\n-        if (status < 0)  //error\n-            return status;\n-\n-        if (id == 0x0AD7B1)  //Timecode Scale\n-        {\n-            m_timecodeScale = UnserializeUInt(pReader, pos, size);\n-\n-            if (m_timecodeScale <= 0)\n-                return E_FILE_FORMAT_INVALID;\n-        }\n-        else if (id == 0x0489)  //Segment duration\n-        {\n-            const long status = UnserializeFloat(\n-                                    pReader,\n-                                    pos,\n-                                    size,\n-                                    m_duration);\n-\n-            if (status < 0)\n-                return status;\n-\n-            if (m_duration < 0)\n-                return E_FILE_FORMAT_INVALID;\n-        }\n-        else if (id == 0x0D80)  //MuxingApp\n-        {\n-            const long status = UnserializeString(\n-                                    pReader,\n-                                    pos,\n-                                    size,\n-                                    m_pMuxingAppAsUTF8);\n-\n-            if (status)\n-                return status;\n-        }\n-        else if (id == 0x1741)  //WritingApp\n-        {\n-            const long status = UnserializeString(\n-                                    pReader,\n-                                    pos,\n-                                    size,\n-                                    m_pWritingAppAsUTF8);\n-\n-            if (status)\n-                return status;\n-        }\n-        else if (id == 0x3BA9)  //Title\n-        {\n-            const long status = UnserializeString(\n-                                    pReader,\n-                                    pos,\n-                                    size,\n-                                    m_pTitleAsUTF8);\n-\n-            if (status)\n-                return status;\n-        }\n-\n-        pos += size;\n-        assert(pos <= stop);\n-    }\n-\n-    assert(pos == stop);\n-\n-    return 0;\n-}\n-\n-\n-long long SegmentInfo::GetTimeCodeScale() const\n-{\n-    return m_timecodeScale;\n-}\n-\n-\n-long long SegmentInfo::GetDuration() const\n-{\n-    if (m_duration < 0)\n-        return -1;\n-\n-    assert(m_timecodeScale >= 1);\n-\n-    const double dd = double(m_duration) * double(m_timecodeScale);\n-    const long long d = static_cast<long long>(dd);\n-\n-    return d;\n-}\n-\n-const char* SegmentInfo::GetMuxingAppAsUTF8() const\n-{\n-    return m_pMuxingAppAsUTF8;\n-}\n-\n-\n-const char* SegmentInfo::GetWritingAppAsUTF8() const\n-{\n-    return m_pWritingAppAsUTF8;\n-}\n-\n-const char* SegmentInfo::GetTitleAsUTF8() const\n-{\n-    return m_pTitleAsUTF8;\n-}\n+const char* SegmentInfo::GetTitleAsUTF8() const { return m_pTitleAsUTF8; }\n \n ///////////////////////////////////////////////////////////////\n // ContentEncoding element\n ContentEncoding::ContentCompression::ContentCompression()\n-    : algo(0),\n-      settings(NULL),\n-      settings_len(0) {\n-}\n+    : algo(0), settings(NULL), settings_len(0) {}\n \n ContentEncoding::ContentCompression::~ContentCompression() {\n-  delete [] settings;\n+  delete[] settings;\n }\n \n ContentEncoding::ContentEncryption::ContentEncryption()\n@@ -5060,13 +4421,12 @@\n\n       sig_key_id(NULL),\n       sig_key_id_len(0),\n       sig_algo(0),\n-      sig_hash_algo(0) {\n-}\n+      sig_hash_algo(0) {}\n \n ContentEncoding::ContentEncryption::~ContentEncryption() {\n-  delete [] key_id;\n-  delete [] signature;\n-  delete [] sig_key_id;\n+  delete[] key_id;\n+  delete[] signature;\n+  delete[] sig_key_id;\n }\n \n ContentEncoding::ContentEncoding()\n@@ -5076,8 +4436,7 @@\n\n       encryption_entries_end_(NULL),\n       encoding_order_(0),\n       encoding_scope_(1),\n-      encoding_type_(0) {\n-}\n+      encoding_type_(0) {}\n \n ContentEncoding::~ContentEncoding() {\n   ContentCompression** comp_i = compression_entries_;\n@@ -5088,7 +4447,7 @@\n\n     delete comp;\n   }\n \n-  delete [] compression_entries_;\n+  delete[] compression_entries_;\n \n   ContentEncryption** enc_i = encryption_entries_;\n   ContentEncryption** const enc_j = encryption_entries_end_;\n@@ -5098,10 +4457,9 @@\n\n     delete enc;\n   }\n \n-  delete [] encryption_entries_;\n+  delete[] encryption_entries_;\n }\n \n-\n const ContentEncoding::ContentCompression*\n ContentEncoding::GetCompressionByIndex(unsigned long idx) const {\n   const ptrdiff_t count = compression_entries_end_ - compression_entries_;\n@@ -5120,8 +4478,8 @@\n\n   return static_cast<unsigned long>(count);\n }\n \n-const ContentEncoding::ContentEncryption*\n-ContentEncoding::GetEncryptionByIndex(unsigned long idx) const {\n+const ContentEncoding::ContentEncryption* ContentEncoding::GetEncryptionByIndex(\n+    unsigned long idx) const {\n   const ptrdiff_t count = encryption_entries_end_ - encryption_entries_;\n   assert(count >= 0);\n \n@@ -5139,9 +4497,7 @@\n\n }\n \n long ContentEncoding::ParseContentEncAESSettingsEntry(\n-    long long start,\n-    long long size,\n-    IMkvReader* pReader,\n+    long long start, long long size, IMkvReader* pReader,\n     ContentEncAESSettings* aes) {\n   assert(pReader);\n   assert(aes);\n@@ -5151,12 +4507,8 @@\n\n \n   while (pos < stop) {\n     long long id, size;\n-    const long status = ParseElementHeader(pReader,\n-                                           pos,\n-                                           stop,\n-                                           id,\n-                                           size);\n-    if (status < 0)  //error\n+    const long status = ParseElementHeader(pReader, pos, stop, id, size);\n+    if (status < 0)  // error\n       return status;\n \n     if (id == 0x7E8) {\n@@ -5166,15 +4518,14 @@\n\n         return E_FILE_FORMAT_INVALID;\n     }\n \n-    pos += size;  //consume payload\n+    pos += size;  // consume payload\n     assert(pos <= stop);\n   }\n \n   return 0;\n }\n \n-long ContentEncoding::ParseContentEncodingEntry(long long start,\n-                                                long long size,\n+long ContentEncoding::ParseContentEncodingEntry(long long start, long long size,\n                                                 IMkvReader* pReader) {\n   assert(pReader);\n \n@@ -5187,12 +4538,8 @@\n\n \n   while (pos < stop) {\n     long long id, size;\n-    const long status = ParseElementHeader(pReader,\n-                                           pos,\n-                                           stop,\n-                                           id,\n-                                           size);\n-    if (status < 0)  //error\n+    const long status = ParseElementHeader(pReader, pos, stop, id, size);\n+    if (status < 0)  // error\n       return status;\n \n     if (id == 0x1034)  // ContentCompression ID\n@@ -5201,7 +4548,7 @@\n\n     if (id == 0x1035)  // ContentEncryption ID\n       ++encryption_count;\n \n-    pos += size;  //consume payload\n+    pos += size;  // consume payload\n     assert(pos <= stop);\n   }\n \n@@ -5210,7 +4557,7 @@\n\n \n   if (compression_count > 0) {\n     compression_entries_ =\n-        new (std::nothrow) ContentCompression*[compression_count];\n+        new (std::nothrow) ContentCompression* [compression_count];\n     if (!compression_entries_)\n       return -1;\n     compression_entries_end_ = compression_entries_;\n@@ -5218,9 +4565,9 @@\n\n \n   if (encryption_count > 0) {\n     encryption_entries_ =\n-        new (std::nothrow) ContentEncryption*[encryption_count];\n+        new (std::nothrow) ContentEncryption* [encryption_count];\n     if (!encryption_entries_) {\n-      delete [] compression_entries_;\n+      delete[] compression_entries_;\n       return -1;\n     }\n     encryption_entries_end_ = encryption_entries_;\n@@ -5229,12 +4576,8 @@\n\n   pos = start;\n   while (pos < stop) {\n     long long id, size;\n-    long status = ParseElementHeader(pReader,\n-                                     pos,\n-                                     stop,\n-                                     id,\n-                                     size);\n-    if (status < 0)  //error\n+    long status = ParseElementHeader(pReader, pos, stop, id, size);\n+    if (status < 0)  // error\n       return status;\n \n     if (id == 0x1031) {\n@@ -5251,7 +4594,7 @@\n\n     } else if (id == 0x1034) {\n       // ContentCompression ID\n       ContentCompression* const compression =\n-        new (std::nothrow) ContentCompression();\n+          new (std::nothrow) ContentCompression();\n       if (!compression)\n         return -1;\n \n@@ -5276,7 +4619,7 @@\n\n       *encryption_entries_end_++ = encryption;\n     }\n \n-    pos += size;  //consume payload\n+    pos += size;  // consume payload\n     assert(pos <= stop);\n   }\n \n@@ -5284,11 +4627,9 @@\n\n   return 0;\n }\n \n-long ContentEncoding::ParseCompressionEntry(\n-    long long start,\n-    long long size,\n-    IMkvReader* pReader,\n-    ContentCompression* compression) {\n+long ContentEncoding::ParseCompressionEntry(long long start, long long size,\n+                                            IMkvReader* pReader,\n+                                            ContentCompression* compression) {\n   assert(pReader);\n   assert(compression);\n \n@@ -5299,12 +4640,8 @@\n\n \n   while (pos < stop) {\n     long long id, size;\n-    const long status = ParseElementHeader(pReader,\n-                                           pos,\n-                                           stop,\n-                                           id,\n-                                           size);\n-    if (status < 0)  //error\n+    const long status = ParseElementHeader(pReader, pos, stop, id, size);\n+    if (status < 0)  // error\n       return status;\n \n     if (id == 0x254) {\n@@ -5325,9 +4662,10 @@\n\n       if (buf == NULL)\n         return -1;\n \n-      const int read_status = pReader->Read(pos, buflen, buf);\n+      const int read_status =\n+          pReader->Read(pos, static_cast<long>(buflen), buf);\n       if (read_status) {\n-        delete [] buf;\n+        delete[] buf;\n         return status;\n       }\n \n@@ -5335,7 +4673,7 @@\n\n       compression->settings_len = buflen;\n     }\n \n-    pos += size;  //consume payload\n+    pos += size;  // consume payload\n     assert(pos <= stop);\n   }\n \n@@ -5346,11 +4684,9 @@\n\n   return 0;\n }\n \n-long ContentEncoding::ParseEncryptionEntry(\n-    long long start,\n-    long long size,\n-    IMkvReader* pReader,\n-    ContentEncryption* encryption) {\n+long ContentEncoding::ParseEncryptionEntry(long long start, long long size,\n+                                           IMkvReader* pReader,\n+                                           ContentEncryption* encryption) {\n   assert(pReader);\n   assert(encryption);\n \n@@ -5359,12 +4695,8 @@\n\n \n   while (pos < stop) {\n     long long id, size;\n-    const long status = ParseElementHeader(pReader,\n-                                           pos,\n-                                           stop,\n-                                           id,\n-                                           size);\n-    if (status < 0)  //error\n+    const long status = ParseElementHeader(pReader, pos, stop, id, size);\n+    if (status < 0)  // error\n       return status;\n \n     if (id == 0x7E1) {\n@@ -5374,7 +4706,7 @@\n\n         return E_FILE_FORMAT_INVALID;\n     } else if (id == 0x7E2) {\n       // ContentEncKeyID\n-      delete[] encryption->key_id;\n+      delete[] encryption -> key_id;\n       encryption->key_id = NULL;\n       encryption->key_id_len = 0;\n \n@@ -5387,9 +4719,10 @@\n\n       if (buf == NULL)\n         return -1;\n \n-      const int read_status = pReader->Read(pos, buflen, buf);\n+      const int read_status =\n+          pReader->Read(pos, static_cast<long>(buflen), buf);\n       if (read_status) {\n-        delete [] buf;\n+        delete[] buf;\n         return status;\n       }\n \n@@ -5397,7 +4730,7 @@\n\n       encryption->key_id_len = buflen;\n     } else if (id == 0x7E3) {\n       // ContentSignature\n-      delete[] encryption->signature;\n+      delete[] encryption -> signature;\n       encryption->signature = NULL;\n       encryption->signature_len = 0;\n \n@@ -5410,9 +4743,10 @@\n\n       if (buf == NULL)\n         return -1;\n \n-      const int read_status = pReader->Read(pos, buflen, buf);\n+      const int read_status =\n+          pReader->Read(pos, static_cast<long>(buflen), buf);\n       if (read_status) {\n-        delete [] buf;\n+        delete[] buf;\n         return status;\n       }\n \n@@ -5420,7 +4754,7 @@\n\n       encryption->signature_len = buflen;\n     } else if (id == 0x7E4) {\n       // ContentSigKeyID\n-      delete[] encryption->sig_key_id;\n+      delete[] encryption -> sig_key_id;\n       encryption->sig_key_id = NULL;\n       encryption->sig_key_id_len = 0;\n \n@@ -5433,9 +4767,10 @@\n\n       if (buf == NULL)\n         return -1;\n \n-      const int read_status = pReader->Read(pos, buflen, buf);\n+      const int read_status =\n+          pReader->Read(pos, static_cast<long>(buflen), buf);\n       if (read_status) {\n-        delete [] buf;\n+        delete[] buf;\n         return status;\n       }\n \n@@ -5450,400 +4785,322 @@\n\n     } else if (id == 0x7E7) {\n       // ContentEncAESSettings\n       const long status = ParseContentEncAESSettingsEntry(\n-          pos,\n-          size,\n-          pReader,\n-          &encryption->aes_settings);\n+          pos, size, pReader, &encryption->aes_settings);\n       if (status)\n         return status;\n     }\n \n-    pos += size;  //consume payload\n+    pos += size;  // consume payload\n     assert(pos <= stop);\n   }\n \n   return 0;\n }\n \n-Track::Track(\n-    Segment* pSegment,\n-    long long element_start,\n-    long long element_size) :\n-    m_pSegment(pSegment),\n-    m_element_start(element_start),\n-    m_element_size(element_size),\n-    content_encoding_entries_(NULL),\n-    content_encoding_entries_end_(NULL)\n-{\n+Track::Track(Segment* pSegment, long long element_start, long long element_size)\n+    : m_pSegment(pSegment),\n+      m_element_start(element_start),\n+      m_element_size(element_size),\n+      content_encoding_entries_(NULL),\n+      content_encoding_entries_end_(NULL) {}\n+\n+Track::~Track() {\n+  Info& info = const_cast<Info&>(m_info);\n+  info.Clear();\n+\n+  ContentEncoding** i = content_encoding_entries_;\n+  ContentEncoding** const j = content_encoding_entries_end_;\n+\n+  while (i != j) {\n+    ContentEncoding* const encoding = *i++;\n+    delete encoding;\n+  }\n+\n+  delete[] content_encoding_entries_;\n }\n \n-Track::~Track()\n-{\n-    Info& info = const_cast<Info&>(m_info);\n-    info.Clear();\n+long Track::Create(Segment* pSegment, const Info& info, long long element_start,\n+                   long long element_size, Track*& pResult) {\n+  if (pResult)\n+    return -1;\n \n-    ContentEncoding** i = content_encoding_entries_;\n-    ContentEncoding** const j = content_encoding_entries_end_;\n+  Track* const pTrack =\n+      new (std::nothrow) Track(pSegment, element_start, element_size);\n \n-    while (i != j) {\n-        ContentEncoding* const encoding = *i++;\n-        delete encoding;\n-    }\n+  if (pTrack == NULL)\n+    return -1;  // generic error\n \n-    delete [] content_encoding_entries_;\n+  const int status = info.Copy(pTrack->m_info);\n+\n+  if (status) {  // error\n+    delete pTrack;\n+    return status;\n+  }\n+\n+  pResult = pTrack;\n+  return 0;  // success\n }\n \n-long Track::Create(\n-    Segment* pSegment,\n-    const Info& info,\n-    long long element_start,\n-    long long element_size,\n-    Track*& pResult)\n-{\n-    if (pResult)\n-        return -1;\n+Track::Info::Info()\n+    : uid(0),\n+      defaultDuration(0),\n+      codecDelay(0),\n+      seekPreRoll(0),\n+      nameAsUTF8(NULL),\n+      language(NULL),\n+      codecId(NULL),\n+      codecNameAsUTF8(NULL),\n+      codecPrivate(NULL),\n+      codecPrivateSize(0),\n+      lacing(false) {}\n \n-    Track* const pTrack = new (std::nothrow) Track(pSegment,\n-                                                   element_start,\n-                                                   element_size);\n+Track::Info::~Info() { Clear(); }\n \n-    if (pTrack == NULL)\n-        return -1;  //generic error\n+void Track::Info::Clear() {\n+  delete[] nameAsUTF8;\n+  nameAsUTF8 = NULL;\n \n-    const int status = info.Copy(pTrack->m_info);\n+  delete[] language;\n+  language = NULL;\n \n-    if (status)  // error\n-    {\n-        delete pTrack;\n-        return status;\n-    }\n+  delete[] codecId;\n+  codecId = NULL;\n \n-    pResult = pTrack;\n-    return 0;  //success\n+  delete[] codecPrivate;\n+  codecPrivate = NULL;\n+  codecPrivateSize = 0;\n+\n+  delete[] codecNameAsUTF8;\n+  codecNameAsUTF8 = NULL;\n }\n \n-Track::Info::Info():\n-    uid(0),\n-    defaultDuration(0),\n-    codecDelay(0),\n-    seekPreRoll(0),\n-    nameAsUTF8(NULL),\n-    language(NULL),\n-    codecId(NULL),\n-    codecNameAsUTF8(NULL),\n-    codecPrivate(NULL),\n-    codecPrivateSize(0),\n-    lacing(false)\n-{\n-}\n+int Track::Info::CopyStr(char* Info::*str, Info& dst_) const {\n+  if (str == static_cast<char * Info::*>(NULL))\n+    return -1;\n \n-Track::Info::~Info()\n-{\n-    Clear();\n-}\n+  char*& dst = dst_.*str;\n \n-void Track::Info::Clear()\n-{\n-    delete[] nameAsUTF8;\n-    nameAsUTF8 = NULL;\n+  if (dst)  // should be NULL already\n+    return -1;\n \n-    delete[] language;\n-    language = NULL;\n+  const char* const src = this->*str;\n \n-    delete[] codecId;\n-    codecId = NULL;\n-\n-    delete[] codecPrivate;\n-    codecPrivate = NULL;\n-    codecPrivateSize = 0;\n-\n-    delete[] codecNameAsUTF8;\n-    codecNameAsUTF8 = NULL;\n-}\n-\n-int Track::Info::CopyStr(char* Info::*str, Info& dst_) const\n-{\n-    if (str == static_cast<char* Info::*>(NULL))\n-        return -1;\n-\n-    char*& dst = dst_.*str;\n-\n-    if (dst)  //should be NULL already\n-        return -1;\n-\n-    const char* const src = this->*str;\n-\n-    if (src == NULL)\n-        return 0;\n-\n-    const size_t len = strlen(src);\n-\n-    dst = new (std::nothrow) char[len+1];\n-\n-    if (dst == NULL)\n-        return -1;\n-\n-    strcpy(dst, src);\n-\n+  if (src == NULL)\n     return 0;\n+\n+  const size_t len = strlen(src);\n+\n+  dst = new (std::nothrow) char[len + 1];\n+\n+  if (dst == NULL)\n+    return -1;\n+\n+  strcpy(dst, src);\n+\n+  return 0;\n }\n \n+int Track::Info::Copy(Info& dst) const {\n+  if (&dst == this)\n+    return 0;\n \n-int Track::Info::Copy(Info& dst) const\n-{\n-    if (&dst == this)\n-        return 0;\n+  dst.type = type;\n+  dst.number = number;\n+  dst.defaultDuration = defaultDuration;\n+  dst.codecDelay = codecDelay;\n+  dst.seekPreRoll = seekPreRoll;\n+  dst.uid = uid;\n+  dst.lacing = lacing;\n+  dst.settings = settings;\n \n-    dst.type = type;\n-    dst.number = number;\n-    dst.defaultDuration = defaultDuration;\n-    dst.codecDelay = codecDelay;\n-    dst.seekPreRoll = seekPreRoll;\n-    dst.uid = uid;\n-    dst.lacing = lacing;\n-    dst.settings = settings;\n+  // We now copy the string member variables from src to dst.\n+  // This involves memory allocation so in principle the operation\n+  // can fail (indeed, that's why we have Info::Copy), so we must\n+  // report this to the caller.  An error return from this function\n+  // therefore implies that the copy was only partially successful.\n \n-    //We now copy the string member variables from src to dst.\n-    //This involves memory allocation so in principle the operation\n-    //can fail (indeed, that's why we have Info::Copy), so we must\n-    //report this to the caller.  An error return from this function\n-    //therefore implies that the copy was only partially successful.\n+  if (int status = CopyStr(&Info::nameAsUTF8, dst))\n+    return status;\n \n-    if (int status = CopyStr(&Info::nameAsUTF8, dst))\n-        return status;\n+  if (int status = CopyStr(&Info::language, dst))\n+    return status;\n \n-    if (int status = CopyStr(&Info::language, dst))\n-        return status;\n+  if (int status = CopyStr(&Info::codecId, dst))\n+    return status;\n \n-    if (int status = CopyStr(&Info::codecId, dst))\n-        return status;\n+  if (int status = CopyStr(&Info::codecNameAsUTF8, dst))\n+    return status;\n \n-    if (int status = CopyStr(&Info::codecNameAsUTF8, dst))\n-        return status;\n+  if (codecPrivateSize > 0) {\n+    if (codecPrivate == NULL)\n+      return -1;\n \n-    if (codecPrivateSize > 0)\n-    {\n-        if (codecPrivate == NULL)\n-            return -1;\n+    if (dst.codecPrivate)\n+      return -1;\n \n-        if (dst.codecPrivate)\n-            return -1;\n+    if (dst.codecPrivateSize != 0)\n+      return -1;\n \n-        if (dst.codecPrivateSize != 0)\n-            return -1;\n+    dst.codecPrivate = new (std::nothrow) unsigned char[codecPrivateSize];\n \n-        dst.codecPrivate = new (std::nothrow) unsigned char[codecPrivateSize];\n+    if (dst.codecPrivate == NULL)\n+      return -1;\n \n-        if (dst.codecPrivate == NULL)\n-            return -1;\n+    memcpy(dst.codecPrivate, codecPrivate, codecPrivateSize);\n+    dst.codecPrivateSize = codecPrivateSize;\n+  }\n \n-        memcpy(dst.codecPrivate, codecPrivate, codecPrivateSize);\n-        dst.codecPrivateSize = codecPrivateSize;\n+  return 0;\n+}\n+\n+const BlockEntry* Track::GetEOS() const { return &m_eos; }\n+\n+long Track::GetType() const { return m_info.type; }\n+\n+long Track::GetNumber() const { return m_info.number; }\n+\n+unsigned long long Track::GetUid() const { return m_info.uid; }\n+\n+const char* Track::GetNameAsUTF8() const { return m_info.nameAsUTF8; }\n+\n+const char* Track::GetLanguage() const { return m_info.language; }\n+\n+const char* Track::GetCodecNameAsUTF8() const { return m_info.codecNameAsUTF8; }\n+\n+const char* Track::GetCodecId() const { return m_info.codecId; }\n+\n+const unsigned char* Track::GetCodecPrivate(size_t& size) const {\n+  size = m_info.codecPrivateSize;\n+  return m_info.codecPrivate;\n+}\n+\n+bool Track::GetLacing() const { return m_info.lacing; }\n+\n+unsigned long long Track::GetDefaultDuration() const {\n+  return m_info.defaultDuration;\n+}\n+\n+unsigned long long Track::GetCodecDelay() const { return m_info.codecDelay; }\n+\n+unsigned long long Track::GetSeekPreRoll() const { return m_info.seekPreRoll; }\n+\n+long Track::GetFirst(const BlockEntry*& pBlockEntry) const {\n+  const Cluster* pCluster = m_pSegment->GetFirst();\n+\n+  for (int i = 0;;) {\n+    if (pCluster == NULL) {\n+      pBlockEntry = GetEOS();\n+      return 1;\n     }\n \n-    return 0;\n-}\n-\n-const BlockEntry* Track::GetEOS() const\n-{\n-    return &m_eos;\n-}\n-\n-long Track::GetType() const\n-{\n-    return m_info.type;\n-}\n-\n-long Track::GetNumber() const\n-{\n-    return m_info.number;\n-}\n-\n-unsigned long long Track::GetUid() const\n-{\n-    return m_info.uid;\n-}\n-\n-const char* Track::GetNameAsUTF8() const\n-{\n-    return m_info.nameAsUTF8;\n-}\n-\n-const char* Track::GetLanguage() const\n-{\n-    return m_info.language;\n-}\n-\n-const char* Track::GetCodecNameAsUTF8() const\n-{\n-    return m_info.codecNameAsUTF8;\n-}\n-\n-\n-const char* Track::GetCodecId() const\n-{\n-    return m_info.codecId;\n-}\n-\n-const unsigned char* Track::GetCodecPrivate(size_t& size) const\n-{\n-    size = m_info.codecPrivateSize;\n-    return m_info.codecPrivate;\n-}\n-\n-\n-bool Track::GetLacing() const\n-{\n-    return m_info.lacing;\n-}\n-\n-unsigned long long Track::GetDefaultDuration() const\n-{\n-    return m_info.defaultDuration;\n-}\n-\n-unsigned long long Track::GetCodecDelay() const\n-{\n-    return m_info.codecDelay;\n-}\n-\n-unsigned long long Track::GetSeekPreRoll() const\n-{\n-    return m_info.seekPreRoll;\n-}\n-\n-long Track::GetFirst(const BlockEntry*& pBlockEntry) const\n-{\n-    const Cluster* pCluster = m_pSegment->GetFirst();\n-\n-    for (int i = 0; ; )\n-    {\n-        if (pCluster == NULL)\n-        {\n-            pBlockEntry = GetEOS();\n-            return 1;\n-        }\n-\n-        if (pCluster->EOS())\n-        {\n+    if (pCluster->EOS()) {\n #if 0\n-            if (m_pSegment->Unparsed() <= 0)  //all clusters have been loaded\n-            {\n+            if (m_pSegment->Unparsed() <= 0) {  //all clusters have been loaded\n                 pBlockEntry = GetEOS();\n                 return 1;\n             }\n #else\n-            if (m_pSegment->DoneParsing())\n-            {\n-                pBlockEntry = GetEOS();\n-                return 1;\n-            }\n+      if (m_pSegment->DoneParsing()) {\n+        pBlockEntry = GetEOS();\n+        return 1;\n+      }\n #endif\n \n-            pBlockEntry = 0;\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        long status = pCluster->GetFirst(pBlockEntry);\n-\n-        if (status < 0)  //error\n-            return status;\n-\n-        if (pBlockEntry == 0)  //empty cluster\n-        {\n-            pCluster = m_pSegment->GetNext(pCluster);\n-            continue;\n-        }\n-\n-        for (;;)\n-        {\n-            const Block* const pBlock = pBlockEntry->GetBlock();\n-            assert(pBlock);\n-\n-            const long long tn = pBlock->GetTrackNumber();\n-\n-            if ((tn == m_info.number) && VetEntry(pBlockEntry))\n-                return 0;\n-\n-            const BlockEntry* pNextEntry;\n-\n-            status = pCluster->GetNext(pBlockEntry, pNextEntry);\n-\n-            if (status < 0)  //error\n-                return status;\n-\n-            if (pNextEntry == 0)\n-                break;\n-\n-            pBlockEntry = pNextEntry;\n-        }\n-\n-        ++i;\n-\n-        if (i >= 100)\n-            break;\n-\n-        pCluster = m_pSegment->GetNext(pCluster);\n+      pBlockEntry = 0;\n+      return E_BUFFER_NOT_FULL;\n     }\n \n-    //NOTE: if we get here, it means that we didn't find a block with\n-    //a matching track number.  We interpret that as an error (which\n-    //might be too conservative).\n+    long status = pCluster->GetFirst(pBlockEntry);\n \n-    pBlockEntry = GetEOS();  //so we can return a non-NULL value\n-    return 1;\n-}\n+    if (status < 0)  // error\n+      return status;\n \n+    if (pBlockEntry == 0) {  // empty cluster\n+      pCluster = m_pSegment->GetNext(pCluster);\n+      continue;\n+    }\n \n-long Track::GetNext(\n-    const BlockEntry* pCurrEntry,\n-    const BlockEntry*& pNextEntry) const\n-{\n-    assert(pCurrEntry);\n-    assert(!pCurrEntry->EOS());  //?\n+    for (;;) {\n+      const Block* const pBlock = pBlockEntry->GetBlock();\n+      assert(pBlock);\n \n-    const Block* const pCurrBlock = pCurrEntry->GetBlock();\n-    assert(pCurrBlock && pCurrBlock->GetTrackNumber() == m_info.number);\n-    if (!pCurrBlock || pCurrBlock->GetTrackNumber() != m_info.number)\n-        return -1;\n+      const long long tn = pBlock->GetTrackNumber();\n \n-    const Cluster* pCluster = pCurrEntry->GetCluster();\n-    assert(pCluster);\n-    assert(!pCluster->EOS());\n+      if ((tn == m_info.number) && VetEntry(pBlockEntry))\n+        return 0;\n \n-    long status = pCluster->GetNext(pCurrEntry, pNextEntry);\n+      const BlockEntry* pNextEntry;\n \n-    if (status < 0)  //error\n+      status = pCluster->GetNext(pBlockEntry, pNextEntry);\n+\n+      if (status < 0)  // error\n         return status;\n \n-    for (int i = 0; ; )\n-    {\n-        while (pNextEntry)\n-        {\n-            const Block* const pNextBlock = pNextEntry->GetBlock();\n-            assert(pNextBlock);\n+      if (pNextEntry == 0)\n+        break;\n \n-            if (pNextBlock->GetTrackNumber() == m_info.number)\n-                return 0;\n+      pBlockEntry = pNextEntry;\n+    }\n \n-            pCurrEntry = pNextEntry;\n+    ++i;\n \n-            status = pCluster->GetNext(pCurrEntry, pNextEntry);\n+    if (i >= 100)\n+      break;\n \n-            if (status < 0) //error\n-                return status;\n-        }\n+    pCluster = m_pSegment->GetNext(pCluster);\n+  }\n \n-        pCluster = m_pSegment->GetNext(pCluster);\n+  // NOTE: if we get here, it means that we didn't find a block with\n+  // a matching track number.  We interpret that as an error (which\n+  // might be too conservative).\n \n-        if (pCluster == NULL)\n-        {\n-            pNextEntry = GetEOS();\n-            return 1;\n-        }\n+  pBlockEntry = GetEOS();  // so we can return a non-NULL value\n+  return 1;\n+}\n \n-        if (pCluster->EOS())\n-        {\n+long Track::GetNext(const BlockEntry* pCurrEntry,\n+                    const BlockEntry*& pNextEntry) const {\n+  assert(pCurrEntry);\n+  assert(!pCurrEntry->EOS());  //?\n+\n+  const Block* const pCurrBlock = pCurrEntry->GetBlock();\n+  assert(pCurrBlock && pCurrBlock->GetTrackNumber() == m_info.number);\n+  if (!pCurrBlock || pCurrBlock->GetTrackNumber() != m_info.number)\n+    return -1;\n+\n+  const Cluster* pCluster = pCurrEntry->GetCluster();\n+  assert(pCluster);\n+  assert(!pCluster->EOS());\n+\n+  long status = pCluster->GetNext(pCurrEntry, pNextEntry);\n+\n+  if (status < 0)  // error\n+    return status;\n+\n+  for (int i = 0;;) {\n+    while (pNextEntry) {\n+      const Block* const pNextBlock = pNextEntry->GetBlock();\n+      assert(pNextBlock);\n+\n+      if (pNextBlock->GetTrackNumber() == m_info.number)\n+        return 0;\n+\n+      pCurrEntry = pNextEntry;\n+\n+      status = pCluster->GetNext(pCurrEntry, pNextEntry);\n+\n+      if (status < 0)  // error\n+        return status;\n+    }\n+\n+    pCluster = m_pSegment->GetNext(pCluster);\n+\n+    if (pCluster == NULL) {\n+      pNextEntry = GetEOS();\n+      return 1;\n+    }\n+\n+    if (pCluster->EOS()) {\n #if 0\n             if (m_pSegment->Unparsed() <= 0)   //all clusters have been loaded\n             {\n@@ -5851,155 +5108,148 @@\n\n                 return 1;\n             }\n #else\n-            if (m_pSegment->DoneParsing())\n-            {\n-                pNextEntry = GetEOS();\n-                return 1;\n-            }\n+      if (m_pSegment->DoneParsing()) {\n+        pNextEntry = GetEOS();\n+        return 1;\n+      }\n #endif\n \n-            //TODO: there is a potential O(n^2) problem here: we tell the\n-            //caller to (pre)load another cluster, which he does, but then he\n-            //calls GetNext again, which repeats the same search.  This is\n-            //a pathological case, since the only way it can happen is if\n-            //there exists a long sequence of clusters none of which contain a\n-            // block from this track.  One way around this problem is for the\n-            //caller to be smarter when he loads another cluster: don't call\n-            //us back until you have a cluster that contains a block from this\n-            //track. (Of course, that's not cheap either, since our caller\n-            //would have to scan the each cluster as it's loaded, so that\n-            //would just push back the problem.)\n+      // TODO: there is a potential O(n^2) problem here: we tell the\n+      // caller to (pre)load another cluster, which he does, but then he\n+      // calls GetNext again, which repeats the same search.  This is\n+      // a pathological case, since the only way it can happen is if\n+      // there exists a long sequence of clusters none of which contain a\n+      // block from this track.  One way around this problem is for the\n+      // caller to be smarter when he loads another cluster: don't call\n+      // us back until you have a cluster that contains a block from this\n+      // track. (Of course, that's not cheap either, since our caller\n+      // would have to scan the each cluster as it's loaded, so that\n+      // would just push back the problem.)\n \n-            pNextEntry = NULL;\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        status = pCluster->GetFirst(pNextEntry);\n-\n-        if (status < 0)  //error\n-            return status;\n-\n-        if (pNextEntry == NULL)  //empty cluster\n-            continue;\n-\n-        ++i;\n-\n-        if (i >= 100)\n-            break;\n+      pNextEntry = NULL;\n+      return E_BUFFER_NOT_FULL;\n     }\n \n-    //NOTE: if we get here, it means that we didn't find a block with\n-    //a matching track number after lots of searching, so we give\n-    //up trying.\n+    status = pCluster->GetFirst(pNextEntry);\n \n-    pNextEntry = GetEOS();  //so we can return a non-NULL value\n-    return 1;\n+    if (status < 0)  // error\n+      return status;\n+\n+    if (pNextEntry == NULL)  // empty cluster\n+      continue;\n+\n+    ++i;\n+\n+    if (i >= 100)\n+      break;\n+  }\n+\n+  // NOTE: if we get here, it means that we didn't find a block with\n+  // a matching track number after lots of searching, so we give\n+  // up trying.\n+\n+  pNextEntry = GetEOS();  // so we can return a non-NULL value\n+  return 1;\n }\n \n-bool Track::VetEntry(const BlockEntry* pBlockEntry) const\n-{\n-    assert(pBlockEntry);\n-    const Block* const pBlock = pBlockEntry->GetBlock();\n-    assert(pBlock);\n-    assert(pBlock->GetTrackNumber() == m_info.number);\n-    if (!pBlock || pBlock->GetTrackNumber() != m_info.number)\n-        return false;\n+bool Track::VetEntry(const BlockEntry* pBlockEntry) const {\n+  assert(pBlockEntry);\n+  const Block* const pBlock = pBlockEntry->GetBlock();\n+  assert(pBlock);\n+  assert(pBlock->GetTrackNumber() == m_info.number);\n+  if (!pBlock || pBlock->GetTrackNumber() != m_info.number)\n+    return false;\n \n-    // This function is used during a seek to determine whether the\n-    // frame is a valid seek target.  This default function simply\n-    // returns true, which means all frames are valid seek targets.\n-    // It gets overridden by the VideoTrack class, because only video\n-    // keyframes can be used as seek target.\n+  // This function is used during a seek to determine whether the\n+  // frame is a valid seek target.  This default function simply\n+  // returns true, which means all frames are valid seek targets.\n+  // It gets overridden by the VideoTrack class, because only video\n+  // keyframes can be used as seek target.\n \n-    return true;\n+  return true;\n }\n \n-long Track::Seek(\n-    long long time_ns,\n-    const BlockEntry*& pResult) const\n-{\n-    const long status = GetFirst(pResult);\n+long Track::Seek(long long time_ns, const BlockEntry*& pResult) const {\n+  const long status = GetFirst(pResult);\n \n-    if (status < 0)  //buffer underflow, etc\n-        return status;\n+  if (status < 0)  // buffer underflow, etc\n+    return status;\n \n-    assert(pResult);\n+  assert(pResult);\n \n-    if (pResult->EOS())\n-        return 0;\n+  if (pResult->EOS())\n+    return 0;\n \n-    const Cluster* pCluster = pResult->GetCluster();\n+  const Cluster* pCluster = pResult->GetCluster();\n+  assert(pCluster);\n+  assert(pCluster->GetIndex() >= 0);\n+\n+  if (time_ns <= pResult->GetBlock()->GetTime(pCluster))\n+    return 0;\n+\n+  Cluster** const clusters = m_pSegment->m_clusters;\n+  assert(clusters);\n+\n+  const long count = m_pSegment->GetCount();  // loaded only, not preloaded\n+  assert(count > 0);\n+\n+  Cluster** const i = clusters + pCluster->GetIndex();\n+  assert(i);\n+  assert(*i == pCluster);\n+  assert(pCluster->GetTime() <= time_ns);\n+\n+  Cluster** const j = clusters + count;\n+\n+  Cluster** lo = i;\n+  Cluster** hi = j;\n+\n+  while (lo < hi) {\n+    // INVARIANT:\n+    //[i, lo) <= time_ns\n+    //[lo, hi) ?\n+    //[hi, j)  > time_ns\n+\n+    Cluster** const mid = lo + (hi - lo) / 2;\n+    assert(mid < hi);\n+\n+    pCluster = *mid;\n     assert(pCluster);\n     assert(pCluster->GetIndex() >= 0);\n+    assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));\n \n-    if (time_ns <= pResult->GetBlock()->GetTime(pCluster))\n-        return 0;\n+    const long long t = pCluster->GetTime();\n \n-    Cluster** const clusters = m_pSegment->m_clusters;\n-    assert(clusters);\n+    if (t <= time_ns)\n+      lo = mid + 1;\n+    else\n+      hi = mid;\n \n-    const long count = m_pSegment->GetCount();  //loaded only, not preloaded\n-    assert(count > 0);\n+    assert(lo <= hi);\n+  }\n \n-    Cluster** const i = clusters + pCluster->GetIndex();\n-    assert(i);\n-    assert(*i == pCluster);\n+  assert(lo == hi);\n+  assert(lo > i);\n+  assert(lo <= j);\n+\n+  while (lo > i) {\n+    pCluster = *--lo;\n+    assert(pCluster);\n     assert(pCluster->GetTime() <= time_ns);\n \n-    Cluster** const j = clusters + count;\n+    pResult = pCluster->GetEntry(this);\n \n-    Cluster** lo = i;\n-    Cluster** hi = j;\n+    if ((pResult != 0) && !pResult->EOS())\n+      return 0;\n \n-    while (lo < hi)\n-    {\n-        //INVARIANT:\n-        //[i, lo) <= time_ns\n-        //[lo, hi) ?\n-        //[hi, j)  > time_ns\n+    // landed on empty cluster (no entries)\n+  }\n \n-        Cluster** const mid = lo + (hi - lo) / 2;\n-        assert(mid < hi);\n-\n-        pCluster = *mid;\n-        assert(pCluster);\n-        assert(pCluster->GetIndex() >= 0);\n-        assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));\n-\n-        const long long t = pCluster->GetTime();\n-\n-        if (t <= time_ns)\n-            lo = mid + 1;\n-        else\n-            hi = mid;\n-\n-        assert(lo <= hi);\n-    }\n-\n-    assert(lo == hi);\n-    assert(lo > i);\n-    assert(lo <= j);\n-\n-    while (lo > i)\n-    {\n-        pCluster = *--lo;\n-        assert(pCluster);\n-        assert(pCluster->GetTime() <= time_ns);\n-\n-        pResult = pCluster->GetEntry(this);\n-\n-        if ((pResult != 0) && !pResult->EOS())\n-            return 0;\n-\n-        //landed on empty cluster (no entries)\n-    }\n-\n-    pResult = GetEOS();  //weird\n-    return 0;\n+  pResult = GetEOS();  // weird\n+  return 0;\n }\n \n-const ContentEncoding*\n-Track::GetContentEncodingByIndex(unsigned long idx) const {\n+const ContentEncoding* Track::GetContentEncodingByIndex(\n+    unsigned long idx) const {\n   const ptrdiff_t count =\n       content_encoding_entries_end_ - content_encoding_entries_;\n   assert(count >= 0);\n@@ -6029,27 +5279,22 @@\n\n   int count = 0;\n   while (pos < stop) {\n     long long id, size;\n-    const long status = ParseElementHeader(pReader,\n-                                           pos,\n-                                           stop,\n-                                           id,\n-                                           size);\n-    if (status < 0)  //error\n+    const long status = ParseElementHeader(pReader, pos, stop, id, size);\n+    if (status < 0)  // error\n       return status;\n \n-\n-    //pos now designates start of element\n+    // pos now designates start of element\n     if (id == 0x2240)  // ContentEncoding ID\n       ++count;\n \n-    pos += size;  //consume payload\n+    pos += size;  // consume payload\n     assert(pos <= stop);\n   }\n \n   if (count <= 0)\n     return -1;\n \n-  content_encoding_entries_ = new (std::nothrow) ContentEncoding*[count];\n+  content_encoding_entries_ = new (std::nothrow) ContentEncoding* [count];\n   if (!content_encoding_entries_)\n     return -1;\n \n@@ -6058,24 +5303,18 @@\n\n   pos = start;\n   while (pos < stop) {\n     long long id, size;\n-    long status = ParseElementHeader(pReader,\n-                                     pos,\n-                                     stop,\n-                                     id,\n-                                     size);\n-    if (status < 0)  //error\n+    long status = ParseElementHeader(pReader, pos, stop, id, size);\n+    if (status < 0)  // error\n       return status;\n \n-    //pos now designates start of element\n-    if (id == 0x2240) { // ContentEncoding ID\n+    // pos now designates start of element\n+    if (id == 0x2240) {  // ContentEncoding ID\n       ContentEncoding* const content_encoding =\n           new (std::nothrow) ContentEncoding();\n       if (!content_encoding)\n         return -1;\n \n-      status = content_encoding->ParseContentEncodingEntry(pos,\n-                                                           size,\n-                                                           pReader);\n+      status = content_encoding->ParseContentEncodingEntry(pos, size, pReader);\n       if (status) {\n         delete content_encoding;\n         return status;\n@@ -6084,7 +5323,7 @@\n\n       *content_encoding_entries_end_++ = content_encoding;\n     }\n \n-    pos += size;  //consume payload\n+    pos += size;  // consume payload\n     assert(pos <= stop);\n   }\n \n@@ -6093,219 +5332,175 @@\n\n   return 0;\n }\n \n-Track::EOSBlock::EOSBlock() :\n-    BlockEntry(NULL, LONG_MIN)\n-{\n-}\n+Track::EOSBlock::EOSBlock() : BlockEntry(NULL, LONG_MIN) {}\n \n-BlockEntry::Kind Track::EOSBlock::GetKind() const\n-{\n-    return kBlockEOS;\n-}\n+BlockEntry::Kind Track::EOSBlock::GetKind() const { return kBlockEOS; }\n \n+const Block* Track::EOSBlock::GetBlock() const { return NULL; }\n \n-const Block* Track::EOSBlock::GetBlock() const\n-{\n-    return NULL;\n-}\n+VideoTrack::VideoTrack(Segment* pSegment, long long element_start,\n+                       long long element_size)\n+    : Track(pSegment, element_start, element_size) {}\n \n+long VideoTrack::Parse(Segment* pSegment, const Info& info,\n+                       long long element_start, long long element_size,\n+                       VideoTrack*& pResult) {\n+  if (pResult)\n+    return -1;\n \n-VideoTrack::VideoTrack(\n-    Segment* pSegment,\n-    long long element_start,\n-    long long element_size) :\n-    Track(pSegment, element_start, element_size)\n-{\n-}\n+  if (info.type != Track::kVideo)\n+    return -1;\n \n+  long long width = 0;\n+  long long height = 0;\n+  double rate = 0.0;\n \n-long VideoTrack::Parse(\n-    Segment* pSegment,\n-    const Info& info,\n-    long long element_start,\n-    long long element_size,\n-    VideoTrack*& pResult)\n-{\n-    if (pResult)\n-        return -1;\n+  IMkvReader* const pReader = pSegment->m_pReader;\n \n-    if (info.type != Track::kVideo)\n-        return -1;\n+  const Settings& s = info.settings;\n+  assert(s.start >= 0);\n+  assert(s.size >= 0);\n \n-    long long width = 0;\n-    long long height = 0;\n-    double rate = 0.0;\n+  long long pos = s.start;\n+  assert(pos >= 0);\n \n-    IMkvReader* const pReader = pSegment->m_pReader;\n+  const long long stop = pos + s.size;\n \n-    const Settings& s = info.settings;\n-    assert(s.start >= 0);\n-    assert(s.size >= 0);\n+  while (pos < stop) {\n+    long long id, size;\n \n-    long long pos = s.start;\n-    assert(pos >= 0);\n+    const long status = ParseElementHeader(pReader, pos, stop, id, size);\n \n-    const long long stop = pos + s.size;\n+    if (status < 0)  // error\n+      return status;\n \n-    while (pos < stop)\n-    {\n-        long long id, size;\n+    if (id == 0x30) {  // pixel width\n+      width = UnserializeUInt(pReader, pos, size);\n \n-        const long status = ParseElementHeader(\n-                                pReader,\n-                                pos,\n-                                stop,\n-                                id,\n-                                size);\n+      if (width <= 0)\n+        return E_FILE_FORMAT_INVALID;\n+    } else if (id == 0x3A) {  // pixel height\n+      height = UnserializeUInt(pReader, pos, size);\n \n-        if (status < 0)  //error\n-            return status;\n+      if (height <= 0)\n+        return E_FILE_FORMAT_INVALID;\n+    } else if (id == 0x0383E3) {  // frame rate\n+      const long status = UnserializeFloat(pReader, pos, size, rate);\n \n-        if (id == 0x30)  //pixel width\n-        {\n-            width = UnserializeUInt(pReader, pos, size);\n-\n-            if (width <= 0)\n-                return E_FILE_FORMAT_INVALID;\n-        }\n-        else if (id == 0x3A)  //pixel height\n-        {\n-            height = UnserializeUInt(pReader, pos, size);\n-\n-            if (height <= 0)\n-                return E_FILE_FORMAT_INVALID;\n-        }\n-        else if (id == 0x0383E3)  //frame rate\n-        {\n-            const long status = UnserializeFloat(\n-                                    pReader,\n-                                    pos,\n-                                    size,\n-                                    rate);\n-\n-            if (status < 0)\n-                return status;\n-\n-            if (rate <= 0)\n-                return E_FILE_FORMAT_INVALID;\n-        }\n-\n-        pos += size;  //consume payload\n-        assert(pos <= stop);\n-    }\n-\n-    assert(pos == stop);\n-\n-    VideoTrack* const pTrack = new (std::nothrow) VideoTrack(pSegment,\n-                                                             element_start,\n-                                                             element_size);\n-\n-    if (pTrack == NULL)\n-        return -1;  //generic error\n-\n-    const int status = info.Copy(pTrack->m_info);\n-\n-    if (status)  // error\n-    {\n-        delete pTrack;\n-        return status;\n-    }\n-\n-    pTrack->m_width = width;\n-    pTrack->m_height = height;\n-    pTrack->m_rate = rate;\n-\n-    pResult = pTrack;\n-    return 0;  //success\n-}\n-\n-\n-bool VideoTrack::VetEntry(const BlockEntry* pBlockEntry) const\n-{\n-    return Track::VetEntry(pBlockEntry) && pBlockEntry->GetBlock()->IsKey();\n-}\n-\n-long VideoTrack::Seek(\n-    long long time_ns,\n-    const BlockEntry*& pResult) const\n-{\n-    const long status = GetFirst(pResult);\n-\n-    if (status < 0)  //buffer underflow, etc\n+      if (status < 0)\n         return status;\n \n-    assert(pResult);\n+      if (rate <= 0)\n+        return E_FILE_FORMAT_INVALID;\n+    }\n \n-    if (pResult->EOS())\n-        return 0;\n+    pos += size;  // consume payload\n+    assert(pos <= stop);\n+  }\n \n-    const Cluster* pCluster = pResult->GetCluster();\n+  assert(pos == stop);\n+\n+  VideoTrack* const pTrack =\n+      new (std::nothrow) VideoTrack(pSegment, element_start, element_size);\n+\n+  if (pTrack == NULL)\n+    return -1;  // generic error\n+\n+  const int status = info.Copy(pTrack->m_info);\n+\n+  if (status) {  // error\n+    delete pTrack;\n+    return status;\n+  }\n+\n+  pTrack->m_width = width;\n+  pTrack->m_height = height;\n+  pTrack->m_rate = rate;\n+\n+  pResult = pTrack;\n+  return 0;  // success\n+}\n+\n+bool VideoTrack::VetEntry(const BlockEntry* pBlockEntry) const {\n+  return Track::VetEntry(pBlockEntry) && pBlockEntry->GetBlock()->IsKey();\n+}\n+\n+long VideoTrack::Seek(long long time_ns, const BlockEntry*& pResult) const {\n+  const long status = GetFirst(pResult);\n+\n+  if (status < 0)  // buffer underflow, etc\n+    return status;\n+\n+  assert(pResult);\n+\n+  if (pResult->EOS())\n+    return 0;\n+\n+  const Cluster* pCluster = pResult->GetCluster();\n+  assert(pCluster);\n+  assert(pCluster->GetIndex() >= 0);\n+\n+  if (time_ns <= pResult->GetBlock()->GetTime(pCluster))\n+    return 0;\n+\n+  Cluster** const clusters = m_pSegment->m_clusters;\n+  assert(clusters);\n+\n+  const long count = m_pSegment->GetCount();  // loaded only, not pre-loaded\n+  assert(count > 0);\n+\n+  Cluster** const i = clusters + pCluster->GetIndex();\n+  assert(i);\n+  assert(*i == pCluster);\n+  assert(pCluster->GetTime() <= time_ns);\n+\n+  Cluster** const j = clusters + count;\n+\n+  Cluster** lo = i;\n+  Cluster** hi = j;\n+\n+  while (lo < hi) {\n+    // INVARIANT:\n+    //[i, lo) <= time_ns\n+    //[lo, hi) ?\n+    //[hi, j)  > time_ns\n+\n+    Cluster** const mid = lo + (hi - lo) / 2;\n+    assert(mid < hi);\n+\n+    pCluster = *mid;\n     assert(pCluster);\n     assert(pCluster->GetIndex() >= 0);\n+    assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));\n \n-    if (time_ns <= pResult->GetBlock()->GetTime(pCluster))\n-        return 0;\n+    const long long t = pCluster->GetTime();\n \n-    Cluster** const clusters = m_pSegment->m_clusters;\n-    assert(clusters);\n+    if (t <= time_ns)\n+      lo = mid + 1;\n+    else\n+      hi = mid;\n \n-    const long count = m_pSegment->GetCount();  //loaded only, not pre-loaded\n-    assert(count > 0);\n+    assert(lo <= hi);\n+  }\n \n-    Cluster** const i = clusters + pCluster->GetIndex();\n-    assert(i);\n-    assert(*i == pCluster);\n-    assert(pCluster->GetTime() <= time_ns);\n+  assert(lo == hi);\n+  assert(lo > i);\n+  assert(lo <= j);\n \n-    Cluster** const j = clusters + count;\n+  pCluster = *--lo;\n+  assert(pCluster);\n+  assert(pCluster->GetTime() <= time_ns);\n \n-    Cluster** lo = i;\n-    Cluster** hi = j;\n+  pResult = pCluster->GetEntry(this, time_ns);\n \n-    while (lo < hi)\n-    {\n-        //INVARIANT:\n-        //[i, lo) <= time_ns\n-        //[lo, hi) ?\n-        //[hi, j)  > time_ns\n+  if ((pResult != 0) && !pResult->EOS())  // found a keyframe\n+    return 0;\n \n-        Cluster** const mid = lo + (hi - lo) / 2;\n-        assert(mid < hi);\n-\n-        pCluster = *mid;\n-        assert(pCluster);\n-        assert(pCluster->GetIndex() >= 0);\n-        assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));\n-\n-        const long long t = pCluster->GetTime();\n-\n-        if (t <= time_ns)\n-            lo = mid + 1;\n-        else\n-            hi = mid;\n-\n-        assert(lo <= hi);\n-    }\n-\n-    assert(lo == hi);\n-    assert(lo > i);\n-    assert(lo <= j);\n-\n+  while (lo != i) {\n     pCluster = *--lo;\n     assert(pCluster);\n     assert(pCluster->GetTime() <= time_ns);\n \n-    pResult = pCluster->GetEntry(this, time_ns);\n-\n-    if ((pResult != 0) && !pResult->EOS())  //found a keyframe\n-        return 0;\n-\n-    while (lo != i)\n-    {\n-        pCluster = *--lo;\n-        assert(pCluster);\n-        assert(pCluster->GetTime() <= time_ns);\n-\n #if 0\n         //TODO:\n         //We need to handle the case when a cluster\n@@ -6314,651 +5509,501 @@\n\n         //good enough.\n         pResult = pCluster->GetMaxKey(this);\n #else\n-        pResult = pCluster->GetEntry(this, time_ns);\n+    pResult = pCluster->GetEntry(this, time_ns);\n #endif\n \n-        if ((pResult != 0) && !pResult->EOS())\n-            return 0;\n+    if ((pResult != 0) && !pResult->EOS())\n+      return 0;\n+  }\n+\n+  // weird: we're on the first cluster, but no keyframe found\n+  // should never happen but we must return something anyway\n+\n+  pResult = GetEOS();\n+  return 0;\n+}\n+\n+long long VideoTrack::GetWidth() const { return m_width; }\n+\n+long long VideoTrack::GetHeight() const { return m_height; }\n+\n+double VideoTrack::GetFrameRate() const { return m_rate; }\n+\n+AudioTrack::AudioTrack(Segment* pSegment, long long element_start,\n+                       long long element_size)\n+    : Track(pSegment, element_start, element_size) {}\n+\n+long AudioTrack::Parse(Segment* pSegment, const Info& info,\n+                       long long element_start, long long element_size,\n+                       AudioTrack*& pResult) {\n+  if (pResult)\n+    return -1;\n+\n+  if (info.type != Track::kAudio)\n+    return -1;\n+\n+  IMkvReader* const pReader = pSegment->m_pReader;\n+\n+  const Settings& s = info.settings;\n+  assert(s.start >= 0);\n+  assert(s.size >= 0);\n+\n+  long long pos = s.start;\n+  assert(pos >= 0);\n+\n+  const long long stop = pos + s.size;\n+\n+  double rate = 8000.0;  // MKV default\n+  long long channels = 1;\n+  long long bit_depth = 0;\n+\n+  while (pos < stop) {\n+    long long id, size;\n+\n+    long status = ParseElementHeader(pReader, pos, stop, id, size);\n+\n+    if (status < 0)  // error\n+      return status;\n+\n+    if (id == 0x35) {  // Sample Rate\n+      status = UnserializeFloat(pReader, pos, size, rate);\n+\n+      if (status < 0)\n+        return status;\n+\n+      if (rate <= 0)\n+        return E_FILE_FORMAT_INVALID;\n+    } else if (id == 0x1F) {  // Channel Count\n+      channels = UnserializeUInt(pReader, pos, size);\n+\n+      if (channels <= 0)\n+        return E_FILE_FORMAT_INVALID;\n+    } else if (id == 0x2264) {  // Bit Depth\n+      bit_depth = UnserializeUInt(pReader, pos, size);\n+\n+      if (bit_depth <= 0)\n+        return E_FILE_FORMAT_INVALID;\n     }\n \n-    //weird: we're on the first cluster, but no keyframe found\n-    //should never happen but we must return something anyway\n+    pos += size;  // consume payload\n+    assert(pos <= stop);\n+  }\n \n-    pResult = GetEOS();\n-    return 0;\n+  assert(pos == stop);\n+\n+  AudioTrack* const pTrack =\n+      new (std::nothrow) AudioTrack(pSegment, element_start, element_size);\n+\n+  if (pTrack == NULL)\n+    return -1;  // generic error\n+\n+  const int status = info.Copy(pTrack->m_info);\n+\n+  if (status) {\n+    delete pTrack;\n+    return status;\n+  }\n+\n+  pTrack->m_rate = rate;\n+  pTrack->m_channels = channels;\n+  pTrack->m_bitDepth = bit_depth;\n+\n+  pResult = pTrack;\n+  return 0;  // success\n }\n \n+double AudioTrack::GetSamplingRate() const { return m_rate; }\n \n-long long VideoTrack::GetWidth() const\n-{\n-    return m_width;\n-}\n+long long AudioTrack::GetChannels() const { return m_channels; }\n \n+long long AudioTrack::GetBitDepth() const { return m_bitDepth; }\n \n-long long VideoTrack::GetHeight() const\n-{\n-    return m_height;\n-}\n+Tracks::Tracks(Segment* pSegment, long long start, long long size_,\n+               long long element_start, long long element_size)\n+    : m_pSegment(pSegment),\n+      m_start(start),\n+      m_size(size_),\n+      m_element_start(element_start),\n+      m_element_size(element_size),\n+      m_trackEntries(NULL),\n+      m_trackEntriesEnd(NULL) {}\n \n+long Tracks::Parse() {\n+  assert(m_trackEntries == NULL);\n+  assert(m_trackEntriesEnd == NULL);\n \n-double VideoTrack::GetFrameRate() const\n-{\n-    return m_rate;\n-}\n+  const long long stop = m_start + m_size;\n+  IMkvReader* const pReader = m_pSegment->m_pReader;\n \n+  int count = 0;\n+  long long pos = m_start;\n \n-AudioTrack::AudioTrack(\n-    Segment* pSegment,\n-    long long element_start,\n-    long long element_size) :\n-    Track(pSegment, element_start, element_size)\n-{\n-}\n+  while (pos < stop) {\n+    long long id, size;\n \n+    const long status = ParseElementHeader(pReader, pos, stop, id, size);\n \n-long AudioTrack::Parse(\n-    Segment* pSegment,\n-    const Info& info,\n-    long long element_start,\n-    long long element_size,\n-    AudioTrack*& pResult)\n-{\n-    if (pResult)\n-        return -1;\n+    if (status < 0)  // error\n+      return status;\n \n-    if (info.type != Track::kAudio)\n-        return -1;\n+    if (size == 0)  // weird\n+      continue;\n \n-    IMkvReader* const pReader = pSegment->m_pReader;\n+    if (id == 0x2E)  // TrackEntry ID\n+      ++count;\n \n-    const Settings& s = info.settings;\n-    assert(s.start >= 0);\n-    assert(s.size >= 0);\n+    pos += size;  // consume payload\n+    assert(pos <= stop);\n+  }\n \n-    long long pos = s.start;\n-    assert(pos >= 0);\n+  assert(pos == stop);\n \n-    const long long stop = pos + s.size;\n+  if (count <= 0)\n+    return 0;  // success\n \n-    double rate = 8000.0;  // MKV default\n-    long long channels = 1;\n-    long long bit_depth = 0;\n+  m_trackEntries = new (std::nothrow) Track* [count];\n \n-    while (pos < stop)\n-    {\n-        long long id, size;\n+  if (m_trackEntries == NULL)\n+    return -1;\n \n-        long status = ParseElementHeader(\n-                                pReader,\n-                                pos,\n-                                stop,\n-                                id,\n-                                size);\n+  m_trackEntriesEnd = m_trackEntries;\n \n-        if (status < 0)  //error\n-            return status;\n+  pos = m_start;\n \n-        if (id == 0x35)  //Sample Rate\n-        {\n-            status = UnserializeFloat(pReader, pos, size, rate);\n+  while (pos < stop) {\n+    const long long element_start = pos;\n \n-            if (status < 0)\n-                return status;\n+    long long id, payload_size;\n \n-            if (rate <= 0)\n-                return E_FILE_FORMAT_INVALID;\n-        }\n-        else if (id == 0x1F)  //Channel Count\n-        {\n-            channels = UnserializeUInt(pReader, pos, size);\n+    const long status =\n+        ParseElementHeader(pReader, pos, stop, id, payload_size);\n \n-            if (channels <= 0)\n-                return E_FILE_FORMAT_INVALID;\n-        }\n-        else if (id == 0x2264)  //Bit Depth\n-        {\n-            bit_depth = UnserializeUInt(pReader, pos, size);\n+    if (status < 0)  // error\n+      return status;\n \n-            if (bit_depth <= 0)\n-                return E_FILE_FORMAT_INVALID;\n-        }\n+    if (payload_size == 0)  // weird\n+      continue;\n \n-        pos += size;  //consume payload\n-        assert(pos <= stop);\n+    const long long payload_stop = pos + payload_size;\n+    assert(payload_stop <= stop);  // checked in ParseElement\n+\n+    const long long element_size = payload_stop - element_start;\n+\n+    if (id == 0x2E) {  // TrackEntry ID\n+      Track*& pTrack = *m_trackEntriesEnd;\n+      pTrack = NULL;\n+\n+      const long status = ParseTrackEntry(pos, payload_size, element_start,\n+                                          element_size, pTrack);\n+\n+      if (status)\n+        return status;\n+\n+      if (pTrack)\n+        ++m_trackEntriesEnd;\n     }\n \n-    assert(pos == stop);\n+    pos = payload_stop;\n+    assert(pos <= stop);\n+  }\n \n-    AudioTrack* const pTrack = new (std::nothrow) AudioTrack(pSegment,\n-                                                             element_start,\n-                                                             element_size);\n+  assert(pos == stop);\n \n-    if (pTrack == NULL)\n-        return -1;  //generic error\n+  return 0;  // success\n+}\n \n-    const int status = info.Copy(pTrack->m_info);\n+unsigned long Tracks::GetTracksCount() const {\n+  const ptrdiff_t result = m_trackEntriesEnd - m_trackEntries;\n+  assert(result >= 0);\n+\n+  return static_cast<unsigned long>(result);\n+}\n+\n+long Tracks::ParseTrackEntry(long long track_start, long long track_size,\n+                             long long element_start, long long element_size,\n+                             Track*& pResult) const {\n+  if (pResult)\n+    return -1;\n+\n+  IMkvReader* const pReader = m_pSegment->m_pReader;\n+\n+  long long pos = track_start;\n+  const long long track_stop = track_start + track_size;\n+\n+  Track::Info info;\n+\n+  info.type = 0;\n+  info.number = 0;\n+  info.uid = 0;\n+  info.defaultDuration = 0;\n+\n+  Track::Settings v;\n+  v.start = -1;\n+  v.size = -1;\n+\n+  Track::Settings a;\n+  a.start = -1;\n+  a.size = -1;\n+\n+  Track::Settings e;  // content_encodings_settings;\n+  e.start = -1;\n+  e.size = -1;\n+\n+  long long lacing = 1;  // default is true\n+\n+  while (pos < track_stop) {\n+    long long id, size;\n+\n+    const long status = ParseElementHeader(pReader, pos, track_stop, id, size);\n+\n+    if (status < 0)  // error\n+      return status;\n+\n+    if (size < 0)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    const long long start = pos;\n+\n+    if (id == 0x60) {  // VideoSettings ID\n+      v.start = start;\n+      v.size = size;\n+    } else if (id == 0x61) {  // AudioSettings ID\n+      a.start = start;\n+      a.size = size;\n+    } else if (id == 0x2D80) {  // ContentEncodings ID\n+      e.start = start;\n+      e.size = size;\n+    } else if (id == 0x33C5) {  // Track UID\n+      if (size > 8)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      info.uid = 0;\n+\n+      long long pos_ = start;\n+      const long long pos_end = start + size;\n+\n+      while (pos_ != pos_end) {\n+        unsigned char b;\n+\n+        const int status = pReader->Read(pos_, 1, &b);\n+\n+        if (status)\n+          return status;\n+\n+        info.uid <<= 8;\n+        info.uid |= b;\n+\n+        ++pos_;\n+      }\n+    } else if (id == 0x57) {  // Track Number\n+      const long long num = UnserializeUInt(pReader, pos, size);\n+\n+      if ((num <= 0) || (num > 127))\n+        return E_FILE_FORMAT_INVALID;\n+\n+      info.number = static_cast<long>(num);\n+    } else if (id == 0x03) {  // Track Type\n+      const long long type = UnserializeUInt(pReader, pos, size);\n+\n+      if ((type <= 0) || (type > 254))\n+        return E_FILE_FORMAT_INVALID;\n+\n+      info.type = static_cast<long>(type);\n+    } else if (id == 0x136E) {  // Track Name\n+      const long status =\n+          UnserializeString(pReader, pos, size, info.nameAsUTF8);\n+\n+      if (status)\n+        return status;\n+    } else if (id == 0x02B59C) {  // Track Language\n+      const long status = UnserializeString(pReader, pos, size, info.language);\n+\n+      if (status)\n+        return status;\n+    } else if (id == 0x03E383) {  // Default Duration\n+      const long long duration = UnserializeUInt(pReader, pos, size);\n+\n+      if (duration < 0)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      info.defaultDuration = static_cast<unsigned long long>(duration);\n+    } else if (id == 0x06) {  // CodecID\n+      const long status = UnserializeString(pReader, pos, size, info.codecId);\n+\n+      if (status)\n+        return status;\n+    } else if (id == 0x1C) {  // lacing\n+      lacing = UnserializeUInt(pReader, pos, size);\n+\n+      if ((lacing < 0) || (lacing > 1))\n+        return E_FILE_FORMAT_INVALID;\n+    } else if (id == 0x23A2) {  // Codec Private\n+      delete[] info.codecPrivate;\n+      info.codecPrivate = NULL;\n+      info.codecPrivateSize = 0;\n+\n+      const size_t buflen = static_cast<size_t>(size);\n+\n+      if (buflen) {\n+        typedef unsigned char* buf_t;\n+\n+        const buf_t buf = new (std::nothrow) unsigned char[buflen];\n+\n+        if (buf == NULL)\n+          return -1;\n+\n+        const int status = pReader->Read(pos, static_cast<long>(buflen), buf);\n+\n+        if (status) {\n+          delete[] buf;\n+          return status;\n+        }\n+\n+        info.codecPrivate = buf;\n+        info.codecPrivateSize = buflen;\n+      }\n+    } else if (id == 0x058688) {  // Codec Name\n+      const long status =\n+          UnserializeString(pReader, pos, size, info.codecNameAsUTF8);\n+\n+      if (status)\n+        return status;\n+    } else if (id == 0x16AA) {  // Codec Delay\n+      info.codecDelay = UnserializeUInt(pReader, pos, size);\n+    } else if (id == 0x16BB) {  // Seek Pre Roll\n+      info.seekPreRoll = UnserializeUInt(pReader, pos, size);\n+    }\n+\n+    pos += size;  // consume payload\n+    assert(pos <= track_stop);\n+  }\n+\n+  assert(pos == track_stop);\n+\n+  if (info.number <= 0)  // not specified\n+    return E_FILE_FORMAT_INVALID;\n+\n+  if (GetTrackByNumber(info.number))\n+    return E_FILE_FORMAT_INVALID;\n+\n+  if (info.type <= 0)  // not specified\n+    return E_FILE_FORMAT_INVALID;\n+\n+  info.lacing = (lacing > 0) ? true : false;\n+\n+  if (info.type == Track::kVideo) {\n+    if (v.start < 0)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if (a.start >= 0)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    info.settings = v;\n+\n+    VideoTrack* pTrack = NULL;\n+\n+    const long status = VideoTrack::Parse(m_pSegment, info, element_start,\n+                                          element_size, pTrack);\n \n     if (status)\n-    {\n-        delete pTrack;\n-        return status;\n-    }\n-\n-    pTrack->m_rate = rate;\n-    pTrack->m_channels = channels;\n-    pTrack->m_bitDepth = bit_depth;\n+      return status;\n \n     pResult = pTrack;\n-    return 0;  //success\n+    assert(pResult);\n+\n+    if (e.start >= 0)\n+      pResult->ParseContentEncodingsEntry(e.start, e.size);\n+  } else if (info.type == Track::kAudio) {\n+    if (a.start < 0)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if (v.start >= 0)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    info.settings = a;\n+\n+    AudioTrack* pTrack = NULL;\n+\n+    const long status = AudioTrack::Parse(m_pSegment, info, element_start,\n+                                          element_size, pTrack);\n+\n+    if (status)\n+      return status;\n+\n+    pResult = pTrack;\n+    assert(pResult);\n+\n+    if (e.start >= 0)\n+      pResult->ParseContentEncodingsEntry(e.start, e.size);\n+  } else {\n+    // neither video nor audio - probably metadata or subtitles\n+\n+    if (a.start >= 0)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if (v.start >= 0)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if (e.start >= 0)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    info.settings.start = -1;\n+    info.settings.size = 0;\n+\n+    Track* pTrack = NULL;\n+\n+    const long status =\n+        Track::Create(m_pSegment, info, element_start, element_size, pTrack);\n+\n+    if (status)\n+      return status;\n+\n+    pResult = pTrack;\n+    assert(pResult);\n+  }\n+\n+  return 0;  // success\n }\n \n+Tracks::~Tracks() {\n+  Track** i = m_trackEntries;\n+  Track** const j = m_trackEntriesEnd;\n \n-double AudioTrack::GetSamplingRate() const\n-{\n-    return m_rate;\n+  while (i != j) {\n+    Track* const pTrack = *i++;\n+    delete pTrack;\n+  }\n+\n+  delete[] m_trackEntries;\n }\n \n+const Track* Tracks::GetTrackByNumber(long tn) const {\n+  if (tn < 0)\n+    return NULL;\n \n-long long AudioTrack::GetChannels() const\n-{\n-    return m_channels;\n+  Track** i = m_trackEntries;\n+  Track** const j = m_trackEntriesEnd;\n+\n+  while (i != j) {\n+    Track* const pTrack = *i++;\n+\n+    if (pTrack == NULL)\n+      continue;\n+\n+    if (tn == pTrack->GetNumber())\n+      return pTrack;\n+  }\n+\n+  return NULL;  // not found\n }\n \n-long long AudioTrack::GetBitDepth() const\n-{\n-    return m_bitDepth;\n-}\n+const Track* Tracks::GetTrackByIndex(unsigned long idx) const {\n+  const ptrdiff_t count = m_trackEntriesEnd - m_trackEntries;\n \n-Tracks::Tracks(\n-    Segment* pSegment,\n-    long long start,\n-    long long size_,\n-    long long element_start,\n-    long long element_size) :\n-    m_pSegment(pSegment),\n-    m_start(start),\n-    m_size(size_),\n-    m_element_start(element_start),\n-    m_element_size(element_size),\n-    m_trackEntries(NULL),\n-    m_trackEntriesEnd(NULL)\n-{\n-}\n+  if (idx >= static_cast<unsigned long>(count))\n+    return NULL;\n \n-\n-long Tracks::Parse()\n-{\n-    assert(m_trackEntries == NULL);\n-    assert(m_trackEntriesEnd == NULL);\n-\n-    const long long stop = m_start + m_size;\n-    IMkvReader* const pReader = m_pSegment->m_pReader;\n-\n-    int count = 0;\n-    long long pos = m_start;\n-\n-    while (pos < stop)\n-    {\n-        long long id, size;\n-\n-        const long status = ParseElementHeader(\n-                                pReader,\n-                                pos,\n-                                stop,\n-                                id,\n-                                size);\n-\n-        if (status < 0)  //error\n-            return status;\n-\n-        if (size == 0)  //weird\n-            continue;\n-\n-        if (id == 0x2E)  //TrackEntry ID\n-            ++count;\n-\n-        pos += size;  //consume payload\n-        assert(pos <= stop);\n-    }\n-\n-    assert(pos == stop);\n-\n-    if (count <= 0)\n-        return 0;  //success\n-\n-    m_trackEntries = new (std::nothrow) Track*[count];\n-\n-    if (m_trackEntries == NULL)\n-        return -1;\n-\n-    m_trackEntriesEnd = m_trackEntries;\n-\n-    pos = m_start;\n-\n-    while (pos < stop)\n-    {\n-        const long long element_start = pos;\n-\n-        long long id, payload_size;\n-\n-        const long status = ParseElementHeader(\n-                                pReader,\n-                                pos,\n-                                stop,\n-                                id,\n-                                payload_size);\n-\n-        if (status < 0)  //error\n-            return status;\n-\n-        if (payload_size == 0)  //weird\n-            continue;\n-\n-        const long long payload_stop = pos + payload_size;\n-        assert(payload_stop <= stop);  //checked in ParseElement\n-\n-        const long long element_size = payload_stop - element_start;\n-\n-        if (id == 0x2E)  //TrackEntry ID\n-        {\n-            Track*& pTrack = *m_trackEntriesEnd;\n-            pTrack = NULL;\n-\n-            const long status = ParseTrackEntry(\n-                                    pos,\n-                                    payload_size,\n-                                    element_start,\n-                                    element_size,\n-                                    pTrack);\n-\n-            if (status)\n-                return status;\n-\n-            if (pTrack)\n-                ++m_trackEntriesEnd;\n-        }\n-\n-        pos = payload_stop;\n-        assert(pos <= stop);\n-    }\n-\n-    assert(pos == stop);\n-\n-    return 0;  //success\n-}\n-\n-\n-unsigned long Tracks::GetTracksCount() const\n-{\n-    const ptrdiff_t result = m_trackEntriesEnd - m_trackEntries;\n-    assert(result >= 0);\n-\n-    return static_cast<unsigned long>(result);\n-}\n-\n-long Tracks::ParseTrackEntry(\n-    long long track_start,\n-    long long track_size,\n-    long long element_start,\n-    long long element_size,\n-    Track*& pResult) const\n-{\n-    if (pResult)\n-        return -1;\n-\n-    IMkvReader* const pReader = m_pSegment->m_pReader;\n-\n-    long long pos = track_start;\n-    const long long track_stop = track_start + track_size;\n-\n-    Track::Info info;\n-\n-    info.type = 0;\n-    info.number = 0;\n-    info.uid = 0;\n-    info.defaultDuration = 0;\n-\n-    Track::Settings v;\n-    v.start = -1;\n-    v.size = -1;\n-\n-    Track::Settings a;\n-    a.start = -1;\n-    a.size = -1;\n-\n-    Track::Settings e;  //content_encodings_settings;\n-    e.start = -1;\n-    e.size = -1;\n-\n-    long long lacing = 1;  //default is true\n-\n-    while (pos < track_stop)\n-    {\n-        long long id, size;\n-\n-        const long status = ParseElementHeader(\n-                                pReader,\n-                                pos,\n-                                track_stop,\n-                                id,\n-                                size);\n-\n-        if (status < 0)  //error\n-            return status;\n-\n-        if (size < 0)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        const long long start = pos;\n-\n-        if (id == 0x60)  // VideoSettings ID\n-        {\n-            v.start = start;\n-            v.size = size;\n-        }\n-        else if (id == 0x61)  // AudioSettings ID\n-        {\n-            a.start = start;\n-            a.size = size;\n-        }\n-        else if (id == 0x2D80) // ContentEncodings ID\n-        {\n-            e.start = start;\n-            e.size = size;\n-        }\n-        else if (id == 0x33C5)  //Track UID\n-        {\n-            if (size > 8)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            info.uid = 0;\n-\n-            long long pos_ = start;\n-            const long long pos_end = start + size;\n-\n-            while (pos_ != pos_end)\n-            {\n-                unsigned char b;\n-\n-                const int status = pReader->Read(pos_, 1, &b);\n-\n-                if (status)\n-                    return status;\n-\n-                info.uid <<= 8;\n-                info.uid |= b;\n-\n-                ++pos_;\n-            }\n-        }\n-        else if (id == 0x57)  //Track Number\n-        {\n-            const long long num = UnserializeUInt(pReader, pos, size);\n-\n-            if ((num <= 0) || (num > 127))\n-                return E_FILE_FORMAT_INVALID;\n-\n-            info.number = static_cast<long>(num);\n-        }\n-        else if (id == 0x03)  //Track Type\n-        {\n-            const long long type = UnserializeUInt(pReader, pos, size);\n-\n-            if ((type <= 0) || (type > 254))\n-                return E_FILE_FORMAT_INVALID;\n-\n-            info.type = static_cast<long>(type);\n-        }\n-        else if (id == 0x136E)  //Track Name\n-        {\n-            const long status = UnserializeString(\n-                                    pReader,\n-                                    pos,\n-                                    size,\n-                                    info.nameAsUTF8);\n-\n-            if (status)\n-                return status;\n-        }\n-        else if (id == 0x02B59C)  //Track Language\n-        {\n-            const long status = UnserializeString(\n-                                    pReader,\n-                                    pos,\n-                                    size,\n-                                    info.language);\n-\n-            if (status)\n-                return status;\n-        }\n-        else if (id == 0x03E383)  //Default Duration\n-        {\n-            const long long duration = UnserializeUInt(pReader, pos, size);\n-\n-            if (duration < 0)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            info.defaultDuration = static_cast<unsigned long long>(duration);\n-        }\n-        else if (id == 0x06)  //CodecID\n-        {\n-            const long status = UnserializeString(\n-                                    pReader,\n-                                    pos,\n-                                    size,\n-                                    info.codecId);\n-\n-            if (status)\n-                return status;\n-        }\n-        else if (id == 0x1C)  //lacing\n-        {\n-            lacing = UnserializeUInt(pReader, pos, size);\n-\n-            if ((lacing < 0) || (lacing > 1))\n-                return E_FILE_FORMAT_INVALID;\n-        }\n-        else if (id == 0x23A2)  //Codec Private\n-        {\n-            delete[] info.codecPrivate;\n-            info.codecPrivate = NULL;\n-            info.codecPrivateSize = 0;\n-\n-            const size_t buflen = static_cast<size_t>(size);\n-\n-            if (buflen)\n-            {\n-                typedef unsigned char* buf_t;\n-\n-                const buf_t buf = new (std::nothrow) unsigned char[buflen];\n-\n-                if (buf == NULL)\n-                    return -1;\n-\n-                const int status = pReader->Read(pos, buflen, buf);\n-\n-                if (status)\n-                {\n-                    delete[] buf;\n-                    return status;\n-                }\n-\n-                info.codecPrivate = buf;\n-                info.codecPrivateSize = buflen;\n-            }\n-        }\n-        else if (id == 0x058688)  //Codec Name\n-        {\n-            const long status = UnserializeString(\n-                                    pReader,\n-                                    pos,\n-                                    size,\n-                                    info.codecNameAsUTF8);\n-\n-            if (status)\n-                return status;\n-        }\n-        else if (id == 0x16AA)  //Codec Delay\n-        {\n-            info.codecDelay = UnserializeUInt(pReader, pos, size);\n-\n-        }\n-        else if (id == 0x16BB) //Seek Pre Roll\n-        {\n-            info.seekPreRoll = UnserializeUInt(pReader, pos, size);\n-        }\n-\n-        pos += size;  //consume payload\n-        assert(pos <= track_stop);\n-    }\n-\n-    assert(pos == track_stop);\n-\n-    if (info.number <= 0)  //not specified\n-        return E_FILE_FORMAT_INVALID;\n-\n-    if (GetTrackByNumber(info.number))\n-        return E_FILE_FORMAT_INVALID;\n-\n-    if (info.type <= 0)  //not specified\n-        return E_FILE_FORMAT_INVALID;\n-\n-    info.lacing = (lacing > 0) ? true : false;\n-\n-    if (info.type == Track::kVideo)\n-    {\n-        if (v.start < 0)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if (a.start >= 0)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        info.settings = v;\n-\n-        VideoTrack* pTrack = NULL;\n-\n-        const long status = VideoTrack::Parse(m_pSegment,\n-                                              info,\n-                                              element_start,\n-                                              element_size,\n-                                              pTrack);\n-\n-        if (status)\n-            return status;\n-\n-        pResult = pTrack;\n-        assert(pResult);\n-\n-        if (e.start >= 0)\n-            pResult->ParseContentEncodingsEntry(e.start, e.size);\n-    }\n-    else if (info.type == Track::kAudio)\n-    {\n-        if (a.start < 0)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if (v.start >= 0)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        info.settings = a;\n-\n-        AudioTrack* pTrack = NULL;\n-\n-        const long status = AudioTrack::Parse(m_pSegment,\n-                                              info,\n-                                              element_start,\n-                                              element_size,\n-                                              pTrack);\n-\n-        if (status)\n-            return status;\n-\n-        pResult = pTrack;\n-        assert(pResult);\n-\n-        if (e.start >= 0)\n-            pResult->ParseContentEncodingsEntry(e.start, e.size);\n-    }\n-    else\n-    {\n-        // neither video nor audio - probably metadata or subtitles\n-\n-        if (a.start >= 0)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if (v.start >= 0)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if (e.start >= 0)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        info.settings.start = -1;\n-        info.settings.size = 0;\n-\n-        Track* pTrack = NULL;\n-\n-        const long status = Track::Create(m_pSegment,\n-                                          info,\n-                                          element_start,\n-                                          element_size,\n-                                          pTrack);\n-\n-        if (status)\n-            return status;\n-\n-        pResult = pTrack;\n-        assert(pResult);\n-    }\n-\n-    return 0;  //success\n-}\n-\n-\n-Tracks::~Tracks()\n-{\n-    Track** i = m_trackEntries;\n-    Track** const j = m_trackEntriesEnd;\n-\n-    while (i != j)\n-    {\n-        Track* const pTrack = *i++;\n-        delete pTrack;\n-    }\n-\n-    delete[] m_trackEntries;\n-}\n-\n-const Track* Tracks::GetTrackByNumber(long tn) const\n-{\n-    if (tn < 0)\n-        return NULL;\n-\n-    Track** i = m_trackEntries;\n-    Track** const j = m_trackEntriesEnd;\n-\n-    while (i != j)\n-    {\n-        Track* const pTrack = *i++;\n-\n-        if (pTrack == NULL)\n-            continue;\n-\n-        if (tn == pTrack->GetNumber())\n-            return pTrack;\n-    }\n-\n-    return NULL;  //not found\n-}\n-\n-\n-const Track* Tracks::GetTrackByIndex(unsigned long idx) const\n-{\n-    const ptrdiff_t count = m_trackEntriesEnd - m_trackEntries;\n-\n-    if (idx >= static_cast<unsigned long>(count))\n-         return NULL;\n-\n-    return m_trackEntries[idx];\n+  return m_trackEntries[idx];\n }\n \n #if 0\n@@ -6980,104 +6025,100 @@\n\n }\n #endif\n \n+long Cluster::Load(long long& pos, long& len) const {\n+  assert(m_pSegment);\n+  assert(m_pos >= m_element_start);\n \n-long Cluster::Load(long long& pos, long& len) const\n-{\n-    assert(m_pSegment);\n-    assert(m_pos >= m_element_start);\n+  if (m_timecode >= 0)  // at least partially loaded\n+    return 0;\n \n-    if (m_timecode >= 0)  //at least partially loaded\n-        return 0;\n+  assert(m_pos == m_element_start);\n+  assert(m_element_size < 0);\n \n-    assert(m_pos == m_element_start);\n-    assert(m_element_size < 0);\n+  IMkvReader* const pReader = m_pSegment->m_pReader;\n \n-    IMkvReader* const pReader = m_pSegment->m_pReader;\n+  long long total, avail;\n \n-    long long total, avail;\n+  const int status = pReader->Length(&total, &avail);\n \n-    const int status = pReader->Length(&total, &avail);\n+  if (status < 0)  // error\n+    return status;\n \n-    if (status < 0)  //error\n-        return status;\n+  assert((total < 0) || (avail <= total));\n+  assert((total < 0) || (m_pos <= total));  // TODO: verify this\n \n-    assert((total < 0) || (avail <= total));\n-    assert((total < 0) || (m_pos <= total));  //TODO: verify this\n+  pos = m_pos;\n \n-    pos = m_pos;\n+  long long cluster_size = -1;\n \n-    long long cluster_size = -1;\n-\n-    {\n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        long long result = GetUIntLength(pReader, pos, len);\n-\n-        if (result < 0)  //error or underflow\n-            return static_cast<long>(result);\n-\n-        if (result > 0)  //underflow (weird)\n-            return E_BUFFER_NOT_FULL;\n-\n-        //if ((pos + len) > segment_stop)\n-        //    return E_FILE_FORMAT_INVALID;\n-\n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n-\n-        const long long id_ = ReadUInt(pReader, pos, len);\n-\n-        if (id_ < 0)  //error\n-            return static_cast<long>(id_);\n-\n-        if (id_ != 0x0F43B675)  //Cluster ID\n-            return E_FILE_FORMAT_INVALID;\n-\n-        pos += len;  //consume id\n-\n-        //read cluster size\n-\n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        result = GetUIntLength(pReader, pos, len);\n-\n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n-\n-        if (result > 0)  //weird\n-            return E_BUFFER_NOT_FULL;\n-\n-        //if ((pos + len) > segment_stop)\n-        //    return E_FILE_FORMAT_INVALID;\n-\n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n-\n-        const long long size = ReadUInt(pReader, pos, len);\n-\n-        if (size < 0)  //error\n-            return static_cast<long>(cluster_size);\n-\n-        if (size == 0)\n-            return E_FILE_FORMAT_INVALID;  //TODO: verify this\n-\n-        pos += len;  //consume length of size of element\n-\n-        const long long unknown_size = (1LL << (7 * len)) - 1;\n-\n-        if (size != unknown_size)\n-            cluster_size = size;\n+  {\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n     }\n \n-    //pos points to start of payload\n+    long long result = GetUIntLength(pReader, pos, len);\n+\n+    if (result < 0)  // error or underflow\n+      return static_cast<long>(result);\n+\n+    if (result > 0)  // underflow (weird)\n+      return E_BUFFER_NOT_FULL;\n+\n+    // if ((pos + len) > segment_stop)\n+    //    return E_FILE_FORMAT_INVALID;\n+\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n+\n+    const long long id_ = ReadUInt(pReader, pos, len);\n+\n+    if (id_ < 0)  // error\n+      return static_cast<long>(id_);\n+\n+    if (id_ != 0x0F43B675)  // Cluster ID\n+      return E_FILE_FORMAT_INVALID;\n+\n+    pos += len;  // consume id\n+\n+    // read cluster size\n+\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n+    }\n+\n+    result = GetUIntLength(pReader, pos, len);\n+\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n+\n+    if (result > 0)  // weird\n+      return E_BUFFER_NOT_FULL;\n+\n+    // if ((pos + len) > segment_stop)\n+    //    return E_FILE_FORMAT_INVALID;\n+\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n+\n+    const long long size = ReadUInt(pReader, pos, len);\n+\n+    if (size < 0)  // error\n+      return static_cast<long>(cluster_size);\n+\n+    if (size == 0)\n+      return E_FILE_FORMAT_INVALID;  // TODO: verify this\n+\n+    pos += len;  // consume length of size of element\n+\n+    const long long unknown_size = (1LL << (7 * len)) - 1;\n+\n+    if (size != unknown_size)\n+      cluster_size = size;\n+  }\n+\n+// pos points to start of payload\n \n #if 0\n     len = static_cast<long>(size_);\n@@ -7086,403 +6127,376 @@\n\n         return E_BUFFER_NOT_FULL;\n #endif\n \n-    long long timecode = -1;\n-    long long new_pos = -1;\n-    bool bBlock = false;\n+  long long timecode = -1;\n+  long long new_pos = -1;\n+  bool bBlock = false;\n \n-    long long cluster_stop = (cluster_size < 0) ? -1 : pos + cluster_size;\n+  long long cluster_stop = (cluster_size < 0) ? -1 : pos + cluster_size;\n \n-    for (;;)\n-    {\n-        if ((cluster_stop >= 0) && (pos >= cluster_stop))\n-            break;\n+  for (;;) {\n+    if ((cluster_stop >= 0) && (pos >= cluster_stop))\n+      break;\n \n-        //Parse ID\n+    // Parse ID\n \n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        long long result = GetUIntLength(pReader, pos, len);\n-\n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n-\n-        if (result > 0)  //weird\n-            return E_BUFFER_NOT_FULL;\n-\n-        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n-\n-        const long long id = ReadUInt(pReader, pos, len);\n-\n-        if (id < 0) //error\n-            return static_cast<long>(id);\n-\n-        if (id == 0)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        //This is the distinguished set of ID's we use to determine\n-        //that we have exhausted the sub-element's inside the cluster\n-        //whose ID we parsed earlier.\n-\n-        if (id == 0x0F43B675)  //Cluster ID\n-            break;\n-\n-        if (id == 0x0C53BB6B)  //Cues ID\n-            break;\n-\n-        pos += len;  //consume ID field\n-\n-        //Parse Size\n-\n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        result = GetUIntLength(pReader, pos, len);\n-\n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n-\n-        if (result > 0)  //weird\n-            return E_BUFFER_NOT_FULL;\n-\n-        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n-\n-        const long long size = ReadUInt(pReader, pos, len);\n-\n-        if (size < 0)  //error\n-            return static_cast<long>(size);\n-\n-        const long long unknown_size = (1LL << (7 * len)) - 1;\n-\n-        if (size == unknown_size)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        pos += len;  //consume size field\n-\n-        if ((cluster_stop >= 0) && (pos > cluster_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        //pos now points to start of payload\n-\n-        if (size == 0)  //weird\n-            continue;\n-\n-        if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if (id == 0x67)  //TimeCode ID\n-        {\n-            len = static_cast<long>(size);\n-\n-            if ((pos + size) > avail)\n-                return E_BUFFER_NOT_FULL;\n-\n-            timecode = UnserializeUInt(pReader, pos, size);\n-\n-            if (timecode < 0)  //error (or underflow)\n-                return static_cast<long>(timecode);\n-\n-            new_pos = pos + size;\n-\n-            if (bBlock)\n-                break;\n-        }\n-        else if (id == 0x20)  //BlockGroup ID\n-        {\n-            bBlock = true;\n-            break;\n-        }\n-        else if (id == 0x23)  //SimpleBlock ID\n-        {\n-            bBlock = true;\n-            break;\n-        }\n-\n-        pos += size;  //consume payload\n-        assert((cluster_stop < 0) || (pos <= cluster_stop));\n-    }\n-\n-    assert((cluster_stop < 0) || (pos <= cluster_stop));\n-\n-    if (timecode < 0)  //no timecode found\n-        return E_FILE_FORMAT_INVALID;\n-\n-    if (!bBlock)\n-        return E_FILE_FORMAT_INVALID;\n-\n-    m_pos = new_pos;  //designates position just beyond timecode payload\n-    m_timecode = timecode;  // m_timecode >= 0 means we're partially loaded\n-\n-    if (cluster_size >= 0)\n-        m_element_size = cluster_stop - m_element_start;\n-\n-    return 0;\n-}\n-\n-\n-long Cluster::Parse(long long& pos, long& len) const\n-{\n-    long status = Load(pos, len);\n-\n-    if (status < 0)\n-        return status;\n-\n-    assert(m_pos >= m_element_start);\n-    assert(m_timecode >= 0);\n-    //assert(m_size > 0);\n-    //assert(m_element_size > m_size);\n-\n-    const long long cluster_stop =\n-        (m_element_size < 0) ? -1 : m_element_start + m_element_size;\n-\n-    if ((cluster_stop >= 0) && (m_pos >= cluster_stop))\n-        return 1;  //nothing else to do\n-\n-    IMkvReader* const pReader = m_pSegment->m_pReader;\n-\n-    long long total, avail;\n-\n-    status = pReader->Length(&total, &avail);\n-\n-    if (status < 0)  //error\n-        return status;\n-\n-    assert((total < 0) || (avail <= total));\n-\n-    pos = m_pos;\n-\n-    for (;;)\n-    {\n-        if ((cluster_stop >= 0) && (pos >= cluster_stop))\n-            break;\n-\n-        if ((total >= 0) && (pos >= total))\n-        {\n-            if (m_element_size < 0)\n-                m_element_size = pos - m_element_start;\n-\n-            break;\n-        }\n-\n-        //Parse ID\n-\n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        long long result = GetUIntLength(pReader, pos, len);\n-\n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n-\n-        if (result > 0)  //weird\n-            return E_BUFFER_NOT_FULL;\n-\n-        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n-\n-        const long long id = ReadUInt(pReader, pos, len);\n-\n-        if (id < 0) //error\n-            return static_cast<long>(id);\n-\n-        if (id == 0)  //weird\n-            return E_FILE_FORMAT_INVALID;\n-\n-        //This is the distinguished set of ID's we use to determine\n-        //that we have exhausted the sub-element's inside the cluster\n-        //whose ID we parsed earlier.\n-\n-        if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) //Cluster or Cues ID\n-        {\n-            if (m_element_size < 0)\n-                m_element_size = pos - m_element_start;\n-\n-            break;\n-        }\n-\n-        pos += len;  //consume ID field\n-\n-        //Parse Size\n-\n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        result = GetUIntLength(pReader, pos, len);\n-\n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n-\n-        if (result > 0)  //weird\n-            return E_BUFFER_NOT_FULL;\n-\n-        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n-\n-        const long long size = ReadUInt(pReader, pos, len);\n-\n-        if (size < 0)  //error\n-            return static_cast<long>(size);\n-\n-        const long long unknown_size = (1LL << (7 * len)) - 1;\n-\n-        if (size == unknown_size)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        pos += len;  //consume size field\n-\n-        if ((cluster_stop >= 0) && (pos > cluster_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        //pos now points to start of payload\n-\n-        if (size == 0)  //weird\n-            continue;\n-\n-        //const long long block_start = pos;\n-        const long long block_stop = pos + size;\n-\n-        if (cluster_stop >= 0)\n-        {\n-            if (block_stop > cluster_stop)\n-            {\n-                if ((id == 0x20) || (id == 0x23))\n-                    return E_FILE_FORMAT_INVALID;\n-\n-                pos = cluster_stop;\n-                break;\n-            }\n-        }\n-        else if ((total >= 0) && (block_stop > total))\n-        {\n-            m_element_size = total - m_element_start;\n-            pos = total;\n-            break;\n-        }\n-        else if (block_stop > avail)\n-        {\n-            len = static_cast<long>(size);\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        Cluster* const this_ = const_cast<Cluster*>(this);\n-\n-        if (id == 0x20)  //BlockGroup\n-            return this_->ParseBlockGroup(size, pos, len);\n-\n-        if (id == 0x23)  //SimpleBlock\n-            return this_->ParseSimpleBlock(size, pos, len);\n-\n-        pos += size;  //consume payload\n-        assert((cluster_stop < 0) || (pos <= cluster_stop));\n-    }\n-\n-    assert(m_element_size > 0);\n-\n-    m_pos = pos;\n-    assert((cluster_stop < 0) || (m_pos <= cluster_stop));\n-\n-    if (m_entries_count > 0)\n-    {\n-        const long idx = m_entries_count - 1;\n-\n-        const BlockEntry* const pLast = m_entries[idx];\n-        assert(pLast);\n-\n-        const Block* const pBlock = pLast->GetBlock();\n-        assert(pBlock);\n-\n-        const long long start = pBlock->m_start;\n-\n-        if ((total >= 0) && (start > total))\n-            return -1;  //defend against trucated stream\n-\n-        const long long size = pBlock->m_size;\n-\n-        const long long stop = start + size;\n-        assert((cluster_stop < 0) || (stop <= cluster_stop));\n-\n-        if ((total >= 0) && (stop > total))\n-            return -1;  //defend against trucated stream\n-    }\n-\n-    return 1;  //no more entries\n-}\n-\n-\n-long Cluster::ParseSimpleBlock(\n-    long long block_size,\n-    long long& pos,\n-    long& len)\n-{\n-    const long long block_start = pos;\n-    const long long block_stop = pos + block_size;\n-\n-    IMkvReader* const pReader = m_pSegment->m_pReader;\n-\n-    long long total, avail;\n-\n-    long status = pReader->Length(&total, &avail);\n-\n-    if (status < 0)  //error\n-        return status;\n-\n-    assert((total < 0) || (avail <= total));\n-\n-    //parse track number\n-\n-    if ((pos + 1) > avail)\n-    {\n-        len = 1;\n-        return E_BUFFER_NOT_FULL;\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n     }\n \n     long long result = GetUIntLength(pReader, pos, len);\n \n-    if (result < 0)  //error\n-        return static_cast<long>(result);\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n \n-    if (result > 0)  //weird\n-        return E_BUFFER_NOT_FULL;\n+    if (result > 0)  // weird\n+      return E_BUFFER_NOT_FULL;\n \n-    if ((pos + len) > block_stop)\n-        return E_FILE_FORMAT_INVALID;\n+    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n+      return E_FILE_FORMAT_INVALID;\n \n     if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n+\n+    const long long id = ReadUInt(pReader, pos, len);\n+\n+    if (id < 0)  // error\n+      return static_cast<long>(id);\n+\n+    if (id == 0)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    // This is the distinguished set of ID's we use to determine\n+    // that we have exhausted the sub-element's inside the cluster\n+    // whose ID we parsed earlier.\n+\n+    if (id == 0x0F43B675)  // Cluster ID\n+      break;\n+\n+    if (id == 0x0C53BB6B)  // Cues ID\n+      break;\n+\n+    pos += len;  // consume ID field\n+\n+    // Parse Size\n+\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n+    }\n+\n+    result = GetUIntLength(pReader, pos, len);\n+\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n+\n+    if (result > 0)  // weird\n+      return E_BUFFER_NOT_FULL;\n+\n+    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n+\n+    const long long size = ReadUInt(pReader, pos, len);\n+\n+    if (size < 0)  // error\n+      return static_cast<long>(size);\n+\n+    const long long unknown_size = (1LL << (7 * len)) - 1;\n+\n+    if (size == unknown_size)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    pos += len;  // consume size field\n+\n+    if ((cluster_stop >= 0) && (pos > cluster_stop))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    // pos now points to start of payload\n+\n+    if (size == 0)  // weird\n+      continue;\n+\n+    if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if (id == 0x67) {  // TimeCode ID\n+      len = static_cast<long>(size);\n+\n+      if ((pos + size) > avail)\n         return E_BUFFER_NOT_FULL;\n \n-    const long long track = ReadUInt(pReader, pos, len);\n+      timecode = UnserializeUInt(pReader, pos, size);\n \n-    if (track < 0) //error\n-        return static_cast<long>(track);\n+      if (timecode < 0)  // error (or underflow)\n+        return static_cast<long>(timecode);\n \n-    if (track == 0)\n-        return E_FILE_FORMAT_INVALID;\n+      new_pos = pos + size;\n+\n+      if (bBlock)\n+        break;\n+    } else if (id == 0x20) {  // BlockGroup ID\n+      bBlock = true;\n+      break;\n+    } else if (id == 0x23) {  // SimpleBlock ID\n+      bBlock = true;\n+      break;\n+    }\n+\n+    pos += size;  // consume payload\n+    assert((cluster_stop < 0) || (pos <= cluster_stop));\n+  }\n+\n+  assert((cluster_stop < 0) || (pos <= cluster_stop));\n+\n+  if (timecode < 0)  // no timecode found\n+    return E_FILE_FORMAT_INVALID;\n+\n+  if (!bBlock)\n+    return E_FILE_FORMAT_INVALID;\n+\n+  m_pos = new_pos;  // designates position just beyond timecode payload\n+  m_timecode = timecode;  // m_timecode >= 0 means we're partially loaded\n+\n+  if (cluster_size >= 0)\n+    m_element_size = cluster_stop - m_element_start;\n+\n+  return 0;\n+}\n+\n+long Cluster::Parse(long long& pos, long& len) const {\n+  long status = Load(pos, len);\n+\n+  if (status < 0)\n+    return status;\n+\n+  assert(m_pos >= m_element_start);\n+  assert(m_timecode >= 0);\n+  // assert(m_size > 0);\n+  // assert(m_element_size > m_size);\n+\n+  const long long cluster_stop =\n+      (m_element_size < 0) ? -1 : m_element_start + m_element_size;\n+\n+  if ((cluster_stop >= 0) && (m_pos >= cluster_stop))\n+    return 1;  // nothing else to do\n+\n+  IMkvReader* const pReader = m_pSegment->m_pReader;\n+\n+  long long total, avail;\n+\n+  status = pReader->Length(&total, &avail);\n+\n+  if (status < 0)  // error\n+    return status;\n+\n+  assert((total < 0) || (avail <= total));\n+\n+  pos = m_pos;\n+\n+  for (;;) {\n+    if ((cluster_stop >= 0) && (pos >= cluster_stop))\n+      break;\n+\n+    if ((total >= 0) && (pos >= total)) {\n+      if (m_element_size < 0)\n+        m_element_size = pos - m_element_start;\n+\n+      break;\n+    }\n+\n+    // Parse ID\n+\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n+    }\n+\n+    long long result = GetUIntLength(pReader, pos, len);\n+\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n+\n+    if (result > 0)  // weird\n+      return E_BUFFER_NOT_FULL;\n+\n+    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n+\n+    const long long id = ReadUInt(pReader, pos, len);\n+\n+    if (id < 0)  // error\n+      return static_cast<long>(id);\n+\n+    if (id == 0)  // weird\n+      return E_FILE_FORMAT_INVALID;\n+\n+    // This is the distinguished set of ID's we use to determine\n+    // that we have exhausted the sub-element's inside the cluster\n+    // whose ID we parsed earlier.\n+\n+    if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) {  // Cluster or Cues ID\n+      if (m_element_size < 0)\n+        m_element_size = pos - m_element_start;\n+\n+      break;\n+    }\n+\n+    pos += len;  // consume ID field\n+\n+    // Parse Size\n+\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n+    }\n+\n+    result = GetUIntLength(pReader, pos, len);\n+\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n+\n+    if (result > 0)  // weird\n+      return E_BUFFER_NOT_FULL;\n+\n+    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n+\n+    const long long size = ReadUInt(pReader, pos, len);\n+\n+    if (size < 0)  // error\n+      return static_cast<long>(size);\n+\n+    const long long unknown_size = (1LL << (7 * len)) - 1;\n+\n+    if (size == unknown_size)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    pos += len;  // consume size field\n+\n+    if ((cluster_stop >= 0) && (pos > cluster_stop))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    // pos now points to start of payload\n+\n+    if (size == 0)  // weird\n+      continue;\n+\n+    // const long long block_start = pos;\n+    const long long block_stop = pos + size;\n+\n+    if (cluster_stop >= 0) {\n+      if (block_stop > cluster_stop) {\n+        if ((id == 0x20) || (id == 0x23))\n+          return E_FILE_FORMAT_INVALID;\n+\n+        pos = cluster_stop;\n+        break;\n+      }\n+    } else if ((total >= 0) && (block_stop > total)) {\n+      m_element_size = total - m_element_start;\n+      pos = total;\n+      break;\n+    } else if (block_stop > avail) {\n+      len = static_cast<long>(size);\n+      return E_BUFFER_NOT_FULL;\n+    }\n+\n+    Cluster* const this_ = const_cast<Cluster*>(this);\n+\n+    if (id == 0x20)  // BlockGroup\n+      return this_->ParseBlockGroup(size, pos, len);\n+\n+    if (id == 0x23)  // SimpleBlock\n+      return this_->ParseSimpleBlock(size, pos, len);\n+\n+    pos += size;  // consume payload\n+    assert((cluster_stop < 0) || (pos <= cluster_stop));\n+  }\n+\n+  assert(m_element_size > 0);\n+\n+  m_pos = pos;\n+  assert((cluster_stop < 0) || (m_pos <= cluster_stop));\n+\n+  if (m_entries_count > 0) {\n+    const long idx = m_entries_count - 1;\n+\n+    const BlockEntry* const pLast = m_entries[idx];\n+    assert(pLast);\n+\n+    const Block* const pBlock = pLast->GetBlock();\n+    assert(pBlock);\n+\n+    const long long start = pBlock->m_start;\n+\n+    if ((total >= 0) && (start > total))\n+      return -1;  // defend against trucated stream\n+\n+    const long long size = pBlock->m_size;\n+\n+    const long long stop = start + size;\n+    assert((cluster_stop < 0) || (stop <= cluster_stop));\n+\n+    if ((total >= 0) && (stop > total))\n+      return -1;  // defend against trucated stream\n+  }\n+\n+  return 1;  // no more entries\n+}\n+\n+long Cluster::ParseSimpleBlock(long long block_size, long long& pos,\n+                               long& len) {\n+  const long long block_start = pos;\n+  const long long block_stop = pos + block_size;\n+\n+  IMkvReader* const pReader = m_pSegment->m_pReader;\n+\n+  long long total, avail;\n+\n+  long status = pReader->Length(&total, &avail);\n+\n+  if (status < 0)  // error\n+    return status;\n+\n+  assert((total < 0) || (avail <= total));\n+\n+  // parse track number\n+\n+  if ((pos + 1) > avail) {\n+    len = 1;\n+    return E_BUFFER_NOT_FULL;\n+  }\n+\n+  long long result = GetUIntLength(pReader, pos, len);\n+\n+  if (result < 0)  // error\n+    return static_cast<long>(result);\n+\n+  if (result > 0)  // weird\n+    return E_BUFFER_NOT_FULL;\n+\n+  if ((pos + len) > block_stop)\n+    return E_FILE_FORMAT_INVALID;\n+\n+  if ((pos + len) > avail)\n+    return E_BUFFER_NOT_FULL;\n+\n+  const long long track = ReadUInt(pReader, pos, len);\n+\n+  if (track < 0)  // error\n+    return static_cast<long>(track);\n+\n+  if (track == 0)\n+    return E_FILE_FORMAT_INVALID;\n \n #if 0\n     //TODO(matthewjheaney)\n@@ -7514,228 +6528,208 @@\n\n         return E_FILE_FORMAT_INVALID;\n #endif\n \n-    pos += len;  //consume track number\n+  pos += len;  // consume track number\n \n-    if ((pos + 2) > block_stop)\n-        return E_FILE_FORMAT_INVALID;\n+  if ((pos + 2) > block_stop)\n+    return E_FILE_FORMAT_INVALID;\n \n-    if ((pos + 2) > avail)\n-    {\n-        len = 2;\n-        return E_BUFFER_NOT_FULL;\n-    }\n+  if ((pos + 2) > avail) {\n+    len = 2;\n+    return E_BUFFER_NOT_FULL;\n+  }\n \n-    pos += 2;  //consume timecode\n+  pos += 2;  // consume timecode\n \n-    if ((pos + 1) > block_stop)\n-        return E_FILE_FORMAT_INVALID;\n+  if ((pos + 1) > block_stop)\n+    return E_FILE_FORMAT_INVALID;\n \n-    if ((pos + 1) > avail)\n-    {\n-        len = 1;\n-        return E_BUFFER_NOT_FULL;\n-    }\n+  if ((pos + 1) > avail) {\n+    len = 1;\n+    return E_BUFFER_NOT_FULL;\n+  }\n \n-    unsigned char flags;\n+  unsigned char flags;\n \n-    status = pReader->Read(pos, 1, &flags);\n+  status = pReader->Read(pos, 1, &flags);\n \n-    if (status < 0)  //error or underflow\n-    {\n-        len = 1;\n-        return status;\n-    }\n+  if (status < 0) {  // error or underflow\n+    len = 1;\n+    return status;\n+  }\n \n-    ++pos;  //consume flags byte\n-    assert(pos <= avail);\n+  ++pos;  // consume flags byte\n+  assert(pos <= avail);\n \n-    if (pos >= block_stop)\n-        return E_FILE_FORMAT_INVALID;\n+  if (pos >= block_stop)\n+    return E_FILE_FORMAT_INVALID;\n \n-    const int lacing = int(flags & 0x06) >> 1;\n+  const int lacing = int(flags & 0x06) >> 1;\n \n-    if ((lacing != 0) && (block_stop > avail))\n-    {\n-        len = static_cast<long>(block_stop - pos);\n-        return E_BUFFER_NOT_FULL;\n-    }\n+  if ((lacing != 0) && (block_stop > avail)) {\n+    len = static_cast<long>(block_stop - pos);\n+    return E_BUFFER_NOT_FULL;\n+  }\n \n-    status = CreateBlock(0x23,  //simple block id\n-                         block_start, block_size,\n-                         0);  //DiscardPadding\n+  status = CreateBlock(0x23,  // simple block id\n+                       block_start, block_size,\n+                       0);  // DiscardPadding\n \n-    if (status != 0)\n-        return status;\n+  if (status != 0)\n+    return status;\n \n-    m_pos = block_stop;\n+  m_pos = block_stop;\n \n-    return 0;  //success\n+  return 0;  // success\n }\n \n+long Cluster::ParseBlockGroup(long long payload_size, long long& pos,\n+                              long& len) {\n+  const long long payload_start = pos;\n+  const long long payload_stop = pos + payload_size;\n \n-long Cluster::ParseBlockGroup(\n-    long long payload_size,\n-    long long& pos,\n-    long& len)\n-{\n-    const long long payload_start = pos;\n-    const long long payload_stop = pos + payload_size;\n+  IMkvReader* const pReader = m_pSegment->m_pReader;\n \n-    IMkvReader* const pReader = m_pSegment->m_pReader;\n+  long long total, avail;\n \n-    long long total, avail;\n+  long status = pReader->Length(&total, &avail);\n \n-    long status = pReader->Length(&total, &avail);\n+  if (status < 0)  // error\n+    return status;\n \n-    if (status < 0)  //error\n-        return status;\n+  assert((total < 0) || (avail <= total));\n \n-    assert((total < 0) || (avail <= total));\n+  if ((total >= 0) && (payload_stop > total))\n+    return E_FILE_FORMAT_INVALID;\n \n-    if ((total >= 0) && (payload_stop > total))\n-        return E_FILE_FORMAT_INVALID;\n+  if (payload_stop > avail) {\n+    len = static_cast<long>(payload_size);\n+    return E_BUFFER_NOT_FULL;\n+  }\n \n-    if (payload_stop > avail)\n-    {\n-         len = static_cast<long>(payload_size);\n-         return E_BUFFER_NOT_FULL;\n+  long long discard_padding = 0;\n+\n+  while (pos < payload_stop) {\n+    // parse sub-block element ID\n+\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n     }\n \n-    long long discard_padding = 0;\n+    long long result = GetUIntLength(pReader, pos, len);\n \n-    while (pos < payload_stop)\n-    {\n-        //parse sub-block element ID\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n \n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n+    if (result > 0)  // weird\n+      return E_BUFFER_NOT_FULL;\n \n-        long long result = GetUIntLength(pReader, pos, len);\n+    if ((pos + len) > payload_stop)\n+      return E_FILE_FORMAT_INVALID;\n \n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n \n-        if (result > 0)  //weird\n-            return E_BUFFER_NOT_FULL;\n+    const long long id = ReadUInt(pReader, pos, len);\n \n-        if ((pos + len) > payload_stop)\n-            return E_FILE_FORMAT_INVALID;\n+    if (id < 0)  // error\n+      return static_cast<long>(id);\n \n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n+    if (id == 0)  // not a value ID\n+      return E_FILE_FORMAT_INVALID;\n \n-        const long long id = ReadUInt(pReader, pos, len);\n+    pos += len;  // consume ID field\n \n-        if (id < 0) //error\n-            return static_cast<long>(id);\n+    // Parse Size\n \n-        if (id == 0)  //not a value ID\n-            return E_FILE_FORMAT_INVALID;\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n+    }\n \n-        pos += len;  //consume ID field\n+    result = GetUIntLength(pReader, pos, len);\n \n-        //Parse Size\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n \n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n+    if (result > 0)  // weird\n+      return E_BUFFER_NOT_FULL;\n \n-        result = GetUIntLength(pReader, pos, len);\n+    if ((pos + len) > payload_stop)\n+      return E_FILE_FORMAT_INVALID;\n \n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n \n-        if (result > 0)  //weird\n-            return E_BUFFER_NOT_FULL;\n+    const long long size = ReadUInt(pReader, pos, len);\n \n-        if ((pos + len) > payload_stop)\n-            return E_FILE_FORMAT_INVALID;\n+    if (size < 0)  // error\n+      return static_cast<long>(size);\n \n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n+    pos += len;  // consume size field\n \n-        const long long size = ReadUInt(pReader, pos, len);\n+    // pos now points to start of sub-block group payload\n \n-        if (size < 0)  //error\n-            return static_cast<long>(size);\n+    if (pos > payload_stop)\n+      return E_FILE_FORMAT_INVALID;\n \n-        pos += len;  //consume size field\n+    if (size == 0)  // weird\n+      continue;\n \n-        //pos now points to start of sub-block group payload\n+    const long long unknown_size = (1LL << (7 * len)) - 1;\n \n-        if (pos > payload_stop)\n-            return E_FILE_FORMAT_INVALID;\n+    if (size == unknown_size)\n+      return E_FILE_FORMAT_INVALID;\n \n-        if (size == 0)  //weird\n-            continue;\n+    if (id == 0x35A2) {  // DiscardPadding\n+      status = UnserializeInt(pReader, pos, size, discard_padding);\n \n-        const long long unknown_size = (1LL << (7 * len)) - 1;\n+      if (status < 0)  // error\n+        return status;\n+    }\n \n-        if (size == unknown_size)\n-            return E_FILE_FORMAT_INVALID;\n+    if (id != 0x21) {  // sub-part of BlockGroup is not a Block\n+      pos += size;  // consume sub-part of block group\n \n-        if (id == 0x35A2)  //DiscardPadding\n-        {\n-            result = GetUIntLength(pReader, pos, len);\n+      if (pos > payload_stop)\n+        return E_FILE_FORMAT_INVALID;\n \n-            if (result < 0)  //error\n-                return static_cast<long>(result);\n+      continue;\n+    }\n \n-            status = UnserializeInt(pReader, pos, len, discard_padding);\n+    const long long block_stop = pos + size;\n \n-            if (status < 0)  //error\n-                return status;\n-        }\n+    if (block_stop > payload_stop)\n+      return E_FILE_FORMAT_INVALID;\n \n-        if (id != 0x21)  //sub-part of BlockGroup is not a Block\n-        {\n-            pos += size;  //consume sub-part of block group\n+    // parse track number\n \n-            if (pos > payload_stop)\n-                return E_FILE_FORMAT_INVALID;\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n+    }\n \n-            continue;\n-        }\n+    result = GetUIntLength(pReader, pos, len);\n \n-        const long long block_stop = pos + size;\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n \n-        if (block_stop > payload_stop)\n-            return E_FILE_FORMAT_INVALID;\n+    if (result > 0)  // weird\n+      return E_BUFFER_NOT_FULL;\n \n-        //parse track number\n+    if ((pos + len) > block_stop)\n+      return E_FILE_FORMAT_INVALID;\n \n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n \n-        result = GetUIntLength(pReader, pos, len);\n+    const long long track = ReadUInt(pReader, pos, len);\n \n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n+    if (track < 0)  // error\n+      return static_cast<long>(track);\n \n-        if (result > 0)  //weird\n-            return E_BUFFER_NOT_FULL;\n-\n-        if ((pos + len) > block_stop)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n-\n-        const long long track = ReadUInt(pReader, pos, len);\n-\n-        if (track < 0) //error\n-            return static_cast<long>(track);\n-\n-        if (track == 0)\n-            return E_FILE_FORMAT_INVALID;\n+    if (track == 0)\n+      return E_FILE_FORMAT_INVALID;\n \n #if 0\n         //TODO(matthewjheaney)\n@@ -7767,213 +6761,173 @@\n\n             return E_FILE_FORMAT_INVALID;\n #endif\n \n-        pos += len;  //consume track number\n+    pos += len;  // consume track number\n \n-        if ((pos + 2) > block_stop)\n-            return E_FILE_FORMAT_INVALID;\n+    if ((pos + 2) > block_stop)\n+      return E_FILE_FORMAT_INVALID;\n \n-        if ((pos + 2) > avail)\n-        {\n-            len = 2;\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        pos += 2;  //consume timecode\n-\n-        if ((pos + 1) > block_stop)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        unsigned char flags;\n-\n-        status = pReader->Read(pos, 1, &flags);\n-\n-        if (status < 0)  //error or underflow\n-        {\n-            len = 1;\n-            return status;\n-        }\n-\n-        ++pos;  //consume flags byte\n-        assert(pos <= avail);\n-\n-        if (pos >= block_stop)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        const int lacing = int(flags & 0x06) >> 1;\n-\n-        if ((lacing != 0) && (block_stop > avail))\n-        {\n-            len = static_cast<long>(block_stop - pos);\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        pos = block_stop;  //consume block-part of block group\n-        assert(pos <= payload_stop);\n+    if ((pos + 2) > avail) {\n+      len = 2;\n+      return E_BUFFER_NOT_FULL;\n     }\n \n-    assert(pos == payload_stop);\n+    pos += 2;  // consume timecode\n \n-    status = CreateBlock(0x20,  //BlockGroup ID\n-                         payload_start, payload_size,\n-                         discard_padding);\n-    if (status != 0)\n-        return status;\n+    if ((pos + 1) > block_stop)\n+      return E_FILE_FORMAT_INVALID;\n \n-    m_pos = payload_stop;\n-\n-    return 0;  //success\n-}\n-\n-\n-long Cluster::GetEntry(long index, const mkvparser::BlockEntry*& pEntry) const\n-{\n-    assert(m_pos >= m_element_start);\n-\n-    pEntry = NULL;\n-\n-    if (index < 0)\n-        return -1;  //generic error\n-\n-    if (m_entries_count < 0)\n-        return E_BUFFER_NOT_FULL;\n-\n-    assert(m_entries);\n-    assert(m_entries_size > 0);\n-    assert(m_entries_count <= m_entries_size);\n-\n-    if (index < m_entries_count)\n-    {\n-        pEntry = m_entries[index];\n-        assert(pEntry);\n-\n-        return 1;  //found entry\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n     }\n \n-    if (m_element_size < 0)        //we don't know cluster end yet\n-        return E_BUFFER_NOT_FULL;  //underflow\n+    unsigned char flags;\n \n-    const long long element_stop = m_element_start + m_element_size;\n+    status = pReader->Read(pos, 1, &flags);\n \n-    if (m_pos >= element_stop)\n-        return 0;  //nothing left to parse\n-\n-    return E_BUFFER_NOT_FULL;  //underflow, since more remains to be parsed\n-}\n-\n-\n-Cluster* Cluster::Create(\n-    Segment* pSegment,\n-    long idx,\n-    long long off)\n-    //long long element_size)\n-{\n-    assert(pSegment);\n-    assert(off >= 0);\n-\n-    const long long element_start = pSegment->m_start + off;\n-\n-    Cluster* const pCluster = new Cluster(pSegment,\n-                                          idx,\n-                                          element_start);\n-                                          //element_size);\n-    assert(pCluster);\n-\n-    return pCluster;\n-}\n-\n-\n-Cluster::Cluster() :\n-    m_pSegment(NULL),\n-    m_element_start(0),\n-    m_index(0),\n-    m_pos(0),\n-    m_element_size(0),\n-    m_timecode(0),\n-    m_entries(NULL),\n-    m_entries_size(0),\n-    m_entries_count(0)  //means \""no entries\""\n-{\n-}\n-\n-\n-Cluster::Cluster(\n-    Segment* pSegment,\n-    long idx,\n-    long long element_start\n-    /* long long element_size */ ) :\n-    m_pSegment(pSegment),\n-    m_element_start(element_start),\n-    m_index(idx),\n-    m_pos(element_start),\n-    m_element_size(-1 /* element_size */ ),\n-    m_timecode(-1),\n-    m_entries(NULL),\n-    m_entries_size(0),\n-    m_entries_count(-1)  //means \""has not been parsed yet\""\n-{\n-}\n-\n-\n-Cluster::~Cluster()\n-{\n-    if (m_entries_count <= 0)\n-        return;\n-\n-    BlockEntry** i = m_entries;\n-    BlockEntry** const j = m_entries + m_entries_count;\n-\n-    while (i != j)\n-    {\n-         BlockEntry* p = *i++;\n-         assert(p);\n-\n-         delete p;\n+    if (status < 0) {  // error or underflow\n+      len = 1;\n+      return status;\n     }\n \n-    delete[] m_entries;\n+    ++pos;  // consume flags byte\n+    assert(pos <= avail);\n+\n+    if (pos >= block_stop)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    const int lacing = int(flags & 0x06) >> 1;\n+\n+    if ((lacing != 0) && (block_stop > avail)) {\n+      len = static_cast<long>(block_stop - pos);\n+      return E_BUFFER_NOT_FULL;\n+    }\n+\n+    pos = block_stop;  // consume block-part of block group\n+    assert(pos <= payload_stop);\n+  }\n+\n+  assert(pos == payload_stop);\n+\n+  status = CreateBlock(0x20,  // BlockGroup ID\n+                       payload_start, payload_size, discard_padding);\n+  if (status != 0)\n+    return status;\n+\n+  m_pos = payload_stop;\n+\n+  return 0;  // success\n }\n \n+long Cluster::GetEntry(long index, const mkvparser::BlockEntry*& pEntry) const {\n+  assert(m_pos >= m_element_start);\n \n-bool Cluster::EOS() const\n+  pEntry = NULL;\n+\n+  if (index < 0)\n+    return -1;  // generic error\n+\n+  if (m_entries_count < 0)\n+    return E_BUFFER_NOT_FULL;\n+\n+  assert(m_entries);\n+  assert(m_entries_size > 0);\n+  assert(m_entries_count <= m_entries_size);\n+\n+  if (index < m_entries_count) {\n+    pEntry = m_entries[index];\n+    assert(pEntry);\n+\n+    return 1;  // found entry\n+  }\n+\n+  if (m_element_size < 0)  // we don't know cluster end yet\n+    return E_BUFFER_NOT_FULL;  // underflow\n+\n+  const long long element_stop = m_element_start + m_element_size;\n+\n+  if (m_pos >= element_stop)\n+    return 0;  // nothing left to parse\n+\n+  return E_BUFFER_NOT_FULL;  // underflow, since more remains to be parsed\n+}\n+\n+Cluster* Cluster::Create(Segment* pSegment, long idx, long long off)\n+// long long element_size)\n {\n-    return (m_pSegment == NULL);\n+  assert(pSegment);\n+  assert(off >= 0);\n+\n+  const long long element_start = pSegment->m_start + off;\n+\n+  Cluster* const pCluster = new Cluster(pSegment, idx, element_start);\n+  // element_size);\n+  assert(pCluster);\n+\n+  return pCluster;\n }\n \n+Cluster::Cluster()\n+    : m_pSegment(NULL),\n+      m_element_start(0),\n+      m_index(0),\n+      m_pos(0),\n+      m_element_size(0),\n+      m_timecode(0),\n+      m_entries(NULL),\n+      m_entries_size(0),\n+      m_entries_count(0)  // means \""no entries\""\n+{}\n \n-long Cluster::GetIndex() const\n-{\n-    return m_index;\n+Cluster::Cluster(Segment* pSegment, long idx, long long element_start\n+                 /* long long element_size */)\n+    : m_pSegment(pSegment),\n+      m_element_start(element_start),\n+      m_index(idx),\n+      m_pos(element_start),\n+      m_element_size(-1 /* element_size */),\n+      m_timecode(-1),\n+      m_entries(NULL),\n+      m_entries_size(0),\n+      m_entries_count(-1)  // means \""has not been parsed yet\""\n+{}\n+\n+Cluster::~Cluster() {\n+  if (m_entries_count <= 0)\n+    return;\n+\n+  BlockEntry** i = m_entries;\n+  BlockEntry** const j = m_entries + m_entries_count;\n+\n+  while (i != j) {\n+    BlockEntry* p = *i++;\n+    assert(p);\n+\n+    delete p;\n+  }\n+\n+  delete[] m_entries;\n }\n \n+bool Cluster::EOS() const { return (m_pSegment == NULL); }\n \n-long long Cluster::GetPosition() const\n-{\n-    const long long pos = m_element_start - m_pSegment->m_start;\n-    assert(pos >= 0);\n+long Cluster::GetIndex() const { return m_index; }\n \n-    return pos;\n+long long Cluster::GetPosition() const {\n+  const long long pos = m_element_start - m_pSegment->m_start;\n+  assert(pos >= 0);\n+\n+  return pos;\n }\n \n-\n-long long Cluster::GetElementSize() const\n-{\n-    return m_element_size;\n-}\n-\n+long long Cluster::GetElementSize() const { return m_element_size; }\n \n #if 0\n bool Cluster::HasBlockEntries(\n     const Segment* pSegment,\n-    long long off)  //relative to start of segment payload\n-{\n+    long long off) {\n     assert(pSegment);\n-    assert(off >= 0);  //relative to segment\n+    assert(off >= 0);  //relative to start of segment payload\n \n     IMkvReader* const pReader = pSegment->m_pReader;\n \n@@ -8030,631 +6984,558 @@\n\n }\n #endif\n \n-\n long Cluster::HasBlockEntries(\n     const Segment* pSegment,\n-    long long off,  //relative to start of segment payload\n-    long long& pos,\n-    long& len)\n-{\n-    assert(pSegment);\n-    assert(off >= 0);  //relative to segment\n+    long long off,  // relative to start of segment payload\n+    long long& pos, long& len) {\n+  assert(pSegment);\n+  assert(off >= 0);  // relative to segment\n \n-    IMkvReader* const pReader = pSegment->m_pReader;\n+  IMkvReader* const pReader = pSegment->m_pReader;\n \n-    long long total, avail;\n+  long long total, avail;\n \n-    long status = pReader->Length(&total, &avail);\n+  long status = pReader->Length(&total, &avail);\n \n-    if (status < 0)  //error\n-        return status;\n+  if (status < 0)  // error\n+    return status;\n \n-    assert((total < 0) || (avail <= total));\n+  assert((total < 0) || (avail <= total));\n \n-    pos = pSegment->m_start + off;  //absolute\n+  pos = pSegment->m_start + off;  // absolute\n \n-    if ((total >= 0) && (pos >= total))\n-        return 0;  //we don't even have a complete cluster\n+  if ((total >= 0) && (pos >= total))\n+    return 0;  // we don't even have a complete cluster\n \n-    const long long segment_stop =\n-        (pSegment->m_size < 0) ? -1 : pSegment->m_start + pSegment->m_size;\n+  const long long segment_stop =\n+      (pSegment->m_size < 0) ? -1 : pSegment->m_start + pSegment->m_size;\n \n-    long long cluster_stop = -1;  //interpreted later to mean \""unknown size\""\n+  long long cluster_stop = -1;  // interpreted later to mean \""unknown size\""\n \n-    {\n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        long long result = GetUIntLength(pReader, pos, len);\n-\n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n-\n-        if (result > 0)  //need more data\n-            return E_BUFFER_NOT_FULL;\n-\n-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((total >= 0) && ((pos + len) > total))\n-            return 0;\n-\n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n-\n-        const long long id = ReadUInt(pReader, pos, len);\n-\n-        if (id < 0)  //error\n-            return static_cast<long>(id);\n-\n-        if (id != 0x0F43B675)  //weird: not cluster ID\n-            return -1;         //generic error\n-\n-        pos += len;  //consume Cluster ID field\n-\n-        //read size field\n-\n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        result = GetUIntLength(pReader, pos, len);\n-\n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n-\n-        if (result > 0)  //weird\n-            return E_BUFFER_NOT_FULL;\n-\n-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((total >= 0) && ((pos + len) > total))\n-            return 0;\n-\n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n-\n-        const long long size = ReadUInt(pReader, pos, len);\n-\n-        if (size < 0)  //error\n-            return static_cast<long>(size);\n-\n-        if (size == 0)\n-            return 0;  //cluster does not have entries\n-\n-        pos += len;  //consume size field\n-\n-        //pos now points to start of payload\n-\n-        const long long unknown_size = (1LL << (7 * len)) - 1;\n-\n-        if (size != unknown_size)\n-        {\n-            cluster_stop = pos + size;\n-            assert(cluster_stop >= 0);\n-\n-            if ((segment_stop >= 0) && (cluster_stop > segment_stop))\n-                return E_FILE_FORMAT_INVALID;\n-\n-            if ((total >= 0) && (cluster_stop > total))\n-                //return E_FILE_FORMAT_INVALID;  //too conservative\n-                return 0;  //cluster does not have any entries\n-        }\n+  {\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n     }\n \n-    for (;;)\n-    {\n-        if ((cluster_stop >= 0) && (pos >= cluster_stop))\n-            return 0;  //no entries detected\n+    long long result = GetUIntLength(pReader, pos, len);\n \n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n \n-        long long result = GetUIntLength(pReader, pos, len);\n+    if (result > 0)  // need more data\n+      return E_BUFFER_NOT_FULL;\n \n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n+      return E_FILE_FORMAT_INVALID;\n \n-        if (result > 0)  //need more data\n-            return E_BUFFER_NOT_FULL;\n+    if ((total >= 0) && ((pos + len) > total))\n+      return 0;\n \n-        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n-            return E_FILE_FORMAT_INVALID;\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n \n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n+    const long long id = ReadUInt(pReader, pos, len);\n \n-        const long long id = ReadUInt(pReader, pos, len);\n+    if (id < 0)  // error\n+      return static_cast<long>(id);\n \n-        if (id < 0)  //error\n-            return static_cast<long>(id);\n+    if (id != 0x0F43B675)  // weird: not cluster ID\n+      return -1;  // generic error\n \n-        //This is the distinguished set of ID's we use to determine\n-        //that we have exhausted the sub-element's inside the cluster\n-        //whose ID we parsed earlier.\n+    pos += len;  // consume Cluster ID field\n \n-        if (id == 0x0F43B675)  //Cluster ID\n-            return 0;  //no entries found\n+    // read size field\n \n-        if (id == 0x0C53BB6B)  //Cues ID\n-            return 0;  //no entries found\n-\n-        pos += len;  //consume id field\n-\n-        if ((cluster_stop >= 0) && (pos >= cluster_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        //read size field\n-\n-        if ((pos + 1) > avail)\n-        {\n-            len = 1;\n-            return E_BUFFER_NOT_FULL;\n-        }\n-\n-        result = GetUIntLength(pReader, pos, len);\n-\n-        if (result < 0)  //error\n-            return static_cast<long>(result);\n-\n-        if (result > 0)  //underflow\n-            return E_BUFFER_NOT_FULL;\n-\n-        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if ((pos + len) > avail)\n-            return E_BUFFER_NOT_FULL;\n-\n-        const long long size = ReadUInt(pReader, pos, len);\n-\n-        if (size < 0)  //error\n-            return static_cast<long>(size);\n-\n-        pos += len;  //consume size field\n-\n-        //pos now points to start of payload\n-\n-        if ((cluster_stop >= 0) && (pos > cluster_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if (size == 0)  //weird\n-            continue;\n-\n-        const long long unknown_size = (1LL << (7 * len)) - 1;\n-\n-        if (size == unknown_size)\n-            return E_FILE_FORMAT_INVALID;  //not supported inside cluster\n-\n-        if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))\n-            return E_FILE_FORMAT_INVALID;\n-\n-        if (id == 0x20)  //BlockGroup ID\n-            return 1;    //have at least one entry\n-\n-        if (id == 0x23)  //SimpleBlock ID\n-            return 1;    //have at least one entry\n-\n-        pos += size;  //consume payload\n-        assert((cluster_stop < 0) || (pos <= cluster_stop));\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n     }\n+\n+    result = GetUIntLength(pReader, pos, len);\n+\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n+\n+    if (result > 0)  // weird\n+      return E_BUFFER_NOT_FULL;\n+\n+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if ((total >= 0) && ((pos + len) > total))\n+      return 0;\n+\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n+\n+    const long long size = ReadUInt(pReader, pos, len);\n+\n+    if (size < 0)  // error\n+      return static_cast<long>(size);\n+\n+    if (size == 0)\n+      return 0;  // cluster does not have entries\n+\n+    pos += len;  // consume size field\n+\n+    // pos now points to start of payload\n+\n+    const long long unknown_size = (1LL << (7 * len)) - 1;\n+\n+    if (size != unknown_size) {\n+      cluster_stop = pos + size;\n+      assert(cluster_stop >= 0);\n+\n+      if ((segment_stop >= 0) && (cluster_stop > segment_stop))\n+        return E_FILE_FORMAT_INVALID;\n+\n+      if ((total >= 0) && (cluster_stop > total))\n+        // return E_FILE_FORMAT_INVALID;  //too conservative\n+        return 0;  // cluster does not have any entries\n+    }\n+  }\n+\n+  for (;;) {\n+    if ((cluster_stop >= 0) && (pos >= cluster_stop))\n+      return 0;  // no entries detected\n+\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n+    }\n+\n+    long long result = GetUIntLength(pReader, pos, len);\n+\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n+\n+    if (result > 0)  // need more data\n+      return E_BUFFER_NOT_FULL;\n+\n+    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n+\n+    const long long id = ReadUInt(pReader, pos, len);\n+\n+    if (id < 0)  // error\n+      return static_cast<long>(id);\n+\n+    // This is the distinguished set of ID's we use to determine\n+    // that we have exhausted the sub-element's inside the cluster\n+    // whose ID we parsed earlier.\n+\n+    if (id == 0x0F43B675)  // Cluster ID\n+      return 0;  // no entries found\n+\n+    if (id == 0x0C53BB6B)  // Cues ID\n+      return 0;  // no entries found\n+\n+    pos += len;  // consume id field\n+\n+    if ((cluster_stop >= 0) && (pos >= cluster_stop))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    // read size field\n+\n+    if ((pos + 1) > avail) {\n+      len = 1;\n+      return E_BUFFER_NOT_FULL;\n+    }\n+\n+    result = GetUIntLength(pReader, pos, len);\n+\n+    if (result < 0)  // error\n+      return static_cast<long>(result);\n+\n+    if (result > 0)  // underflow\n+      return E_BUFFER_NOT_FULL;\n+\n+    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if ((pos + len) > avail)\n+      return E_BUFFER_NOT_FULL;\n+\n+    const long long size = ReadUInt(pReader, pos, len);\n+\n+    if (size < 0)  // error\n+      return static_cast<long>(size);\n+\n+    pos += len;  // consume size field\n+\n+    // pos now points to start of payload\n+\n+    if ((cluster_stop >= 0) && (pos > cluster_stop))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if (size == 0)  // weird\n+      continue;\n+\n+    const long long unknown_size = (1LL << (7 * len)) - 1;\n+\n+    if (size == unknown_size)\n+      return E_FILE_FORMAT_INVALID;  // not supported inside cluster\n+\n+    if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if (id == 0x20)  // BlockGroup ID\n+      return 1;  // have at least one entry\n+\n+    if (id == 0x23)  // SimpleBlock ID\n+      return 1;  // have at least one entry\n+\n+    pos += size;  // consume payload\n+    assert((cluster_stop < 0) || (pos <= cluster_stop));\n+  }\n }\n \n+long long Cluster::GetTimeCode() const {\n+  long long pos;\n+  long len;\n \n-long long Cluster::GetTimeCode() const\n-{\n+  const long status = Load(pos, len);\n+\n+  if (status < 0)  // error\n+    return status;\n+\n+  return m_timecode;\n+}\n+\n+long long Cluster::GetTime() const {\n+  const long long tc = GetTimeCode();\n+\n+  if (tc < 0)\n+    return tc;\n+\n+  const SegmentInfo* const pInfo = m_pSegment->GetInfo();\n+  assert(pInfo);\n+\n+  const long long scale = pInfo->GetTimeCodeScale();\n+  assert(scale >= 1);\n+\n+  const long long t = m_timecode * scale;\n+\n+  return t;\n+}\n+\n+long long Cluster::GetFirstTime() const {\n+  const BlockEntry* pEntry;\n+\n+  const long status = GetFirst(pEntry);\n+\n+  if (status < 0)  // error\n+    return status;\n+\n+  if (pEntry == NULL)  // empty cluster\n+    return GetTime();\n+\n+  const Block* const pBlock = pEntry->GetBlock();\n+  assert(pBlock);\n+\n+  return pBlock->GetTime(this);\n+}\n+\n+long long Cluster::GetLastTime() const {\n+  const BlockEntry* pEntry;\n+\n+  const long status = GetLast(pEntry);\n+\n+  if (status < 0)  // error\n+    return status;\n+\n+  if (pEntry == NULL)  // empty cluster\n+    return GetTime();\n+\n+  const Block* const pBlock = pEntry->GetBlock();\n+  assert(pBlock);\n+\n+  return pBlock->GetTime(this);\n+}\n+\n+long Cluster::CreateBlock(long long id,\n+                          long long pos,  // absolute pos of payload\n+                          long long size, long long discard_padding) {\n+  assert((id == 0x20) || (id == 0x23));  // BlockGroup or SimpleBlock\n+\n+  if (m_entries_count < 0) {  // haven't parsed anything yet\n+    assert(m_entries == NULL);\n+    assert(m_entries_size == 0);\n+\n+    m_entries_size = 1024;\n+    m_entries = new BlockEntry* [m_entries_size];\n+\n+    m_entries_count = 0;\n+  } else {\n+    assert(m_entries);\n+    assert(m_entries_size > 0);\n+    assert(m_entries_count <= m_entries_size);\n+\n+    if (m_entries_count >= m_entries_size) {\n+      const long entries_size = 2 * m_entries_size;\n+\n+      BlockEntry** const entries = new BlockEntry* [entries_size];\n+      assert(entries);\n+\n+      BlockEntry** src = m_entries;\n+      BlockEntry** const src_end = src + m_entries_count;\n+\n+      BlockEntry** dst = entries;\n+\n+      while (src != src_end)\n+        *dst++ = *src++;\n+\n+      delete[] m_entries;\n+\n+      m_entries = entries;\n+      m_entries_size = entries_size;\n+    }\n+  }\n+\n+  if (id == 0x20)  // BlockGroup ID\n+    return CreateBlockGroup(pos, size, discard_padding);\n+  else  // SimpleBlock ID\n+    return CreateSimpleBlock(pos, size);\n+}\n+\n+long Cluster::CreateBlockGroup(long long start_offset, long long size,\n+                               long long discard_padding) {\n+  assert(m_entries);\n+  assert(m_entries_size > 0);\n+  assert(m_entries_count >= 0);\n+  assert(m_entries_count < m_entries_size);\n+\n+  IMkvReader* const pReader = m_pSegment->m_pReader;\n+\n+  long long pos = start_offset;\n+  const long long stop = start_offset + size;\n+\n+  // For WebM files, there is a bias towards previous reference times\n+  //(in order to support alt-ref frames, which refer back to the previous\n+  // keyframe).  Normally a 0 value is not possible, but here we tenatively\n+  // allow 0 as the value of a reference frame, with the interpretation\n+  // that this is a \""previous\"" reference time.\n+\n+  long long prev = 1;  // nonce\n+  long long next = 0;  // nonce\n+  long long duration = -1;  // really, this is unsigned\n+\n+  long long bpos = -1;\n+  long long bsize = -1;\n+\n+  while (pos < stop) {\n+    long len;\n+    const long long id = ReadUInt(pReader, pos, len);\n+    assert(id >= 0);  // TODO\n+    assert((pos + len) <= stop);\n+\n+    pos += len;  // consume ID\n+\n+    const long long size = ReadUInt(pReader, pos, len);\n+    assert(size >= 0);  // TODO\n+    assert((pos + len) <= stop);\n+\n+    pos += len;  // consume size\n+\n+    if (id == 0x21) {  // Block ID\n+      if (bpos < 0) {  // Block ID\n+        bpos = pos;\n+        bsize = size;\n+      }\n+    } else if (id == 0x1B) {  // Duration ID\n+      assert(size <= 8);\n+\n+      duration = UnserializeUInt(pReader, pos, size);\n+      assert(duration >= 0);  // TODO\n+    } else if (id == 0x7B) {  // ReferenceBlock\n+      assert(size <= 8);\n+      const long size_ = static_cast<long>(size);\n+\n+      long long time;\n+\n+      long status = UnserializeInt(pReader, pos, size_, time);\n+      assert(status == 0);\n+      if (status != 0)\n+        return -1;\n+\n+      if (time <= 0)  // see note above\n+        prev = time;\n+      else  // weird\n+        next = time;\n+    }\n+\n+    pos += size;  // consume payload\n+    assert(pos <= stop);\n+  }\n+\n+  assert(pos == stop);\n+  assert(bpos >= 0);\n+  assert(bsize >= 0);\n+\n+  const long idx = m_entries_count;\n+\n+  BlockEntry** const ppEntry = m_entries + idx;\n+  BlockEntry*& pEntry = *ppEntry;\n+\n+  pEntry = new (std::nothrow)\n+      BlockGroup(this, idx, bpos, bsize, prev, next, duration, discard_padding);\n+\n+  if (pEntry == NULL)\n+    return -1;  // generic error\n+\n+  BlockGroup* const p = static_cast<BlockGroup*>(pEntry);\n+\n+  const long status = p->Parse();\n+\n+  if (status == 0) {  // success\n+    ++m_entries_count;\n+    return 0;\n+  }\n+\n+  delete pEntry;\n+  pEntry = 0;\n+\n+  return status;\n+}\n+\n+long Cluster::CreateSimpleBlock(long long st, long long sz) {\n+  assert(m_entries);\n+  assert(m_entries_size > 0);\n+  assert(m_entries_count >= 0);\n+  assert(m_entries_count < m_entries_size);\n+\n+  const long idx = m_entries_count;\n+\n+  BlockEntry** const ppEntry = m_entries + idx;\n+  BlockEntry*& pEntry = *ppEntry;\n+\n+  pEntry = new (std::nothrow) SimpleBlock(this, idx, st, sz);\n+\n+  if (pEntry == NULL)\n+    return -1;  // generic error\n+\n+  SimpleBlock* const p = static_cast<SimpleBlock*>(pEntry);\n+\n+  const long status = p->Parse();\n+\n+  if (status == 0) {\n+    ++m_entries_count;\n+    return 0;\n+  }\n+\n+  delete pEntry;\n+  pEntry = 0;\n+\n+  return status;\n+}\n+\n+long Cluster::GetFirst(const BlockEntry*& pFirst) const {\n+  if (m_entries_count <= 0) {\n     long long pos;\n     long len;\n \n-    const long status = Load(pos, len);\n+    const long status = Parse(pos, len);\n \n-    if (status < 0) //error\n-        return status;\n-\n-    return m_timecode;\n-}\n-\n-\n-long long Cluster::GetTime() const\n-{\n-    const long long tc = GetTimeCode();\n-\n-    if (tc < 0)\n-        return tc;\n-\n-    const SegmentInfo* const pInfo = m_pSegment->GetInfo();\n-    assert(pInfo);\n-\n-    const long long scale = pInfo->GetTimeCodeScale();\n-    assert(scale >= 1);\n-\n-    const long long t = m_timecode * scale;\n-\n-    return t;\n-}\n-\n-\n-long long Cluster::GetFirstTime() const\n-{\n-    const BlockEntry* pEntry;\n-\n-    const long status = GetFirst(pEntry);\n-\n-    if (status < 0)  //error\n-        return status;\n-\n-    if (pEntry == NULL)  //empty cluster\n-        return GetTime();\n-\n-    const Block* const pBlock = pEntry->GetBlock();\n-    assert(pBlock);\n-\n-    return pBlock->GetTime(this);\n-}\n-\n-\n-long long Cluster::GetLastTime() const\n-{\n-    const BlockEntry* pEntry;\n-\n-    const long status = GetLast(pEntry);\n-\n-    if (status < 0)  //error\n-        return status;\n-\n-    if (pEntry == NULL)  //empty cluster\n-        return GetTime();\n-\n-    const Block* const pBlock = pEntry->GetBlock();\n-    assert(pBlock);\n-\n-    return pBlock->GetTime(this);\n-}\n-\n-\n-long Cluster::CreateBlock(\n-    long long id,\n-    long long pos,   //absolute pos of payload\n-    long long size,\n-    long long discard_padding)\n-{\n-    assert((id == 0x20) || (id == 0x23));  //BlockGroup or SimpleBlock\n-\n-    if (m_entries_count < 0)  //haven't parsed anything yet\n-    {\n-        assert(m_entries == NULL);\n-        assert(m_entries_size == 0);\n-\n-        m_entries_size = 1024;\n-        m_entries = new BlockEntry*[m_entries_size];\n-\n-        m_entries_count = 0;\n-    }\n-    else\n-    {\n-        assert(m_entries);\n-        assert(m_entries_size > 0);\n-        assert(m_entries_count <= m_entries_size);\n-\n-        if (m_entries_count >= m_entries_size)\n-        {\n-            const long entries_size = 2 * m_entries_size;\n-\n-            BlockEntry** const entries = new BlockEntry*[entries_size];\n-            assert(entries);\n-\n-            BlockEntry** src = m_entries;\n-            BlockEntry** const src_end = src + m_entries_count;\n-\n-            BlockEntry** dst = entries;\n-\n-            while (src != src_end)\n-                *dst++ = *src++;\n-\n-            delete[] m_entries;\n-\n-            m_entries = entries;\n-            m_entries_size = entries_size;\n-        }\n+    if (status < 0) {  // error\n+      pFirst = NULL;\n+      return status;\n     }\n \n-    if (id == 0x20)  //BlockGroup ID\n-        return CreateBlockGroup(pos, size, discard_padding);\n-    else  //SimpleBlock ID\n-        return CreateSimpleBlock(pos, size);\n+    if (m_entries_count <= 0) {  // empty cluster\n+      pFirst = NULL;\n+      return 0;\n+    }\n+  }\n+\n+  assert(m_entries);\n+\n+  pFirst = m_entries[0];\n+  assert(pFirst);\n+\n+  return 0;  // success\n }\n \n+long Cluster::GetLast(const BlockEntry*& pLast) const {\n+  for (;;) {\n+    long long pos;\n+    long len;\n \n-long Cluster::CreateBlockGroup(\n-    long long start_offset,\n-    long long size,\n-    long long discard_padding)\n-{\n-    assert(m_entries);\n-    assert(m_entries_size > 0);\n-    assert(m_entries_count >= 0);\n-    assert(m_entries_count < m_entries_size);\n+    const long status = Parse(pos, len);\n \n-    IMkvReader* const pReader = m_pSegment->m_pReader;\n-\n-    long long pos = start_offset;\n-    const long long stop = start_offset + size;\n-\n-    //For WebM files, there is a bias towards previous reference times\n-    //(in order to support alt-ref frames, which refer back to the previous\n-    //keyframe).  Normally a 0 value is not possible, but here we tenatively\n-    //allow 0 as the value of a reference frame, with the interpretation\n-    //that this is a \""previous\"" reference time.\n-\n-    long long prev = 1;  //nonce\n-    long long next = 0;  //nonce\n-    long long duration = -1;  //really, this is unsigned\n-\n-    long long bpos = -1;\n-    long long bsize = -1;\n-\n-    while (pos < stop)\n-    {\n-        long len;\n-        const long long id = ReadUInt(pReader, pos, len);\n-        assert(id >= 0);  //TODO\n-        assert((pos + len) <= stop);\n-\n-        pos += len;  //consume ID\n-\n-        const long long size = ReadUInt(pReader, pos, len);\n-        assert(size >= 0);  //TODO\n-        assert((pos + len) <= stop);\n-\n-        pos += len;  //consume size\n-\n-        if (id == 0x21) //Block ID\n-        {\n-            if (bpos < 0) //Block ID\n-            {\n-                bpos = pos;\n-                bsize = size;\n-            }\n-        }\n-        else if (id == 0x1B)  //Duration ID\n-        {\n-            assert(size <= 8);\n-\n-            duration = UnserializeUInt(pReader, pos, size);\n-            assert(duration >= 0);  //TODO\n-        }\n-        else if (id == 0x7B)  //ReferenceBlock\n-        {\n-            assert(size <= 8);\n-            const long size_ = static_cast<long>(size);\n-\n-            long long time;\n-\n-            long status = UnserializeInt(pReader, pos, size_, time);\n-            assert(status == 0);\n-            if (status != 0)\n-                return -1;\n-\n-            if (time <= 0)  //see note above\n-                prev = time;\n-            else  //weird\n-                next = time;\n-        }\n-\n-        pos += size;  //consume payload\n-        assert(pos <= stop);\n+    if (status < 0) {  // error\n+      pLast = NULL;\n+      return status;\n     }\n \n-    assert(pos == stop);\n-    assert(bpos >= 0);\n-    assert(bsize >= 0);\n+    if (status > 0)  // no new block\n+      break;\n+  }\n \n-    const long idx = m_entries_count;\n-\n-    BlockEntry** const ppEntry = m_entries + idx;\n-    BlockEntry*& pEntry = *ppEntry;\n-\n-    pEntry = new (std::nothrow) BlockGroup(\n-                                  this,\n-                                  idx,\n-                                  bpos,\n-                                  bsize,\n-                                  prev,\n-                                  next,\n-                                  duration,\n-                                  discard_padding);\n-\n-    if (pEntry == NULL)\n-        return -1;  //generic error\n-\n-    BlockGroup* const p = static_cast<BlockGroup*>(pEntry);\n-\n-    const long status = p->Parse();\n-\n-    if (status == 0)  //success\n-    {\n-        ++m_entries_count;\n-        return 0;\n-    }\n-\n-    delete pEntry;\n-    pEntry = 0;\n-\n-    return status;\n-}\n-\n-\n-\n-long Cluster::CreateSimpleBlock(\n-    long long st,\n-    long long sz)\n-{\n-    assert(m_entries);\n-    assert(m_entries_size > 0);\n-    assert(m_entries_count >= 0);\n-    assert(m_entries_count < m_entries_size);\n-\n-    const long idx = m_entries_count;\n-\n-    BlockEntry** const ppEntry = m_entries + idx;\n-    BlockEntry*& pEntry = *ppEntry;\n-\n-    pEntry = new (std::nothrow) SimpleBlock(this, idx, st, sz);\n-\n-    if (pEntry == NULL)\n-        return -1;  //generic error\n-\n-    SimpleBlock* const p = static_cast<SimpleBlock*>(pEntry);\n-\n-    const long status = p->Parse();\n-\n-    if (status == 0)\n-    {\n-        ++m_entries_count;\n-        return 0;\n-    }\n-\n-    delete pEntry;\n-    pEntry = 0;\n-\n-    return status;\n-}\n-\n-\n-long Cluster::GetFirst(const BlockEntry*& pFirst) const\n-{\n-    if (m_entries_count <= 0)\n-    {\n-        long long pos;\n-        long len;\n-\n-        const long status = Parse(pos, len);\n-\n-        if (status < 0)  //error\n-        {\n-            pFirst = NULL;\n-            return status;\n-        }\n-\n-        if (m_entries_count <= 0)  //empty cluster\n-        {\n-            pFirst = NULL;\n-            return 0;\n-        }\n-    }\n-\n-    assert(m_entries);\n-\n-    pFirst = m_entries[0];\n-    assert(pFirst);\n-\n-    return 0;  //success\n-}\n-\n-long Cluster::GetLast(const BlockEntry*& pLast) const\n-{\n-    for (;;)\n-    {\n-        long long pos;\n-        long len;\n-\n-        const long status = Parse(pos, len);\n-\n-        if (status < 0)  //error\n-        {\n-            pLast = NULL;\n-            return status;\n-        }\n-\n-        if (status > 0)  //no new block\n-            break;\n-    }\n-\n-    if (m_entries_count <= 0)\n-    {\n-        pLast = NULL;\n-        return 0;\n-    }\n-\n-    assert(m_entries);\n-\n-    const long idx = m_entries_count - 1;\n-\n-    pLast = m_entries[idx];\n-    assert(pLast);\n-\n+  if (m_entries_count <= 0) {\n+    pLast = NULL;\n     return 0;\n+  }\n+\n+  assert(m_entries);\n+\n+  const long idx = m_entries_count - 1;\n+\n+  pLast = m_entries[idx];\n+  assert(pLast);\n+\n+  return 0;\n }\n \n+long Cluster::GetNext(const BlockEntry* pCurr, const BlockEntry*& pNext) const {\n+  assert(pCurr);\n+  assert(m_entries);\n+  assert(m_entries_count > 0);\n \n-long Cluster::GetNext(\n-    const BlockEntry* pCurr,\n-    const BlockEntry*& pNext) const\n-{\n-    assert(pCurr);\n+  size_t idx = pCurr->GetIndex();\n+  assert(idx < size_t(m_entries_count));\n+  assert(m_entries[idx] == pCurr);\n+\n+  ++idx;\n+\n+  if (idx >= size_t(m_entries_count)) {\n+    long long pos;\n+    long len;\n+\n+    const long status = Parse(pos, len);\n+\n+    if (status < 0) {  // error\n+      pNext = NULL;\n+      return status;\n+    }\n+\n+    if (status > 0) {\n+      pNext = NULL;\n+      return 0;\n+    }\n+\n     assert(m_entries);\n     assert(m_entries_count > 0);\n-\n-    size_t idx = pCurr->GetIndex();\n     assert(idx < size_t(m_entries_count));\n-    assert(m_entries[idx] == pCurr);\n+  }\n \n-    ++idx;\n+  pNext = m_entries[idx];\n+  assert(pNext);\n \n-    if (idx >= size_t(m_entries_count))\n-    {\n-        long long pos;\n-        long len;\n-\n-        const long status = Parse(pos, len);\n-\n-        if (status < 0)  //error\n-        {\n-            pNext = NULL;\n-            return status;\n-        }\n-\n-        if (status > 0)\n-        {\n-            pNext = NULL;\n-            return 0;\n-        }\n-\n-        assert(m_entries);\n-        assert(m_entries_count > 0);\n-        assert(idx < size_t(m_entries_count));\n-    }\n-\n-    pNext = m_entries[idx];\n-    assert(pNext);\n-\n-    return 0;\n+  return 0;\n }\n \n+long Cluster::GetEntryCount() const { return m_entries_count; }\n \n-long Cluster::GetEntryCount() const\n-{\n-    return m_entries_count;\n-}\n+const BlockEntry* Cluster::GetEntry(const Track* pTrack,\n+                                    long long time_ns) const {\n+  assert(pTrack);\n \n-\n-const BlockEntry* Cluster::GetEntry(\n-    const Track* pTrack,\n-    long long time_ns) const\n-{\n-    assert(pTrack);\n-\n-    if (m_pSegment == NULL)  //this is the special EOS cluster\n-        return pTrack->GetEOS();\n+  if (m_pSegment == NULL)  // this is the special EOS cluster\n+    return pTrack->GetEOS();\n \n #if 0\n \n@@ -8707,76 +7588,66 @@\n\n \n #else\n \n-    const BlockEntry* pResult = pTrack->GetEOS();\n+  const BlockEntry* pResult = pTrack->GetEOS();\n \n-    long index = 0;\n+  long index = 0;\n \n-    for (;;)\n-    {\n-        if (index >= m_entries_count)\n-        {\n-            long long pos;\n-            long len;\n+  for (;;) {\n+    if (index >= m_entries_count) {\n+      long long pos;\n+      long len;\n \n-            const long status = Parse(pos, len);\n-            assert(status >= 0);\n+      const long status = Parse(pos, len);\n+      assert(status >= 0);\n \n-            if (status > 0)  //completely parsed, and no more entries\n-                return pResult;\n+      if (status > 0)  // completely parsed, and no more entries\n+        return pResult;\n \n-            if (status < 0)  //should never happen\n-                return 0;\n+      if (status < 0)  // should never happen\n+        return 0;\n \n-            assert(m_entries);\n-            assert(index < m_entries_count);\n-        }\n-\n-        const BlockEntry* const pEntry = m_entries[index];\n-        assert(pEntry);\n-        assert(!pEntry->EOS());\n-\n-        const Block* const pBlock = pEntry->GetBlock();\n-        assert(pBlock);\n-\n-        if (pBlock->GetTrackNumber() != pTrack->GetNumber())\n-        {\n-            ++index;\n-            continue;\n-        }\n-\n-        if (pTrack->VetEntry(pEntry))\n-        {\n-            if (time_ns < 0)  //just want first candidate block\n-                return pEntry;\n-\n-            const long long ns = pBlock->GetTime(this);\n-\n-            if (ns > time_ns)\n-                return pResult;\n-\n-            pResult = pEntry;  //have a candidate\n-        }\n-        else if (time_ns >= 0)\n-        {\n-            const long long ns = pBlock->GetTime(this);\n-\n-            if (ns > time_ns)\n-                return pResult;\n-        }\n-\n-        ++index;\n+      assert(m_entries);\n+      assert(index < m_entries_count);\n     }\n \n+    const BlockEntry* const pEntry = m_entries[index];\n+    assert(pEntry);\n+    assert(!pEntry->EOS());\n+\n+    const Block* const pBlock = pEntry->GetBlock();\n+    assert(pBlock);\n+\n+    if (pBlock->GetTrackNumber() != pTrack->GetNumber()) {\n+      ++index;\n+      continue;\n+    }\n+\n+    if (pTrack->VetEntry(pEntry)) {\n+      if (time_ns < 0)  // just want first candidate block\n+        return pEntry;\n+\n+      const long long ns = pBlock->GetTime(this);\n+\n+      if (ns > time_ns)\n+        return pResult;\n+\n+      pResult = pEntry;  // have a candidate\n+    } else if (time_ns >= 0) {\n+      const long long ns = pBlock->GetTime(this);\n+\n+      if (ns > time_ns)\n+        return pResult;\n+    }\n+\n+    ++index;\n+  }\n+\n #endif\n }\n \n-\n-const BlockEntry*\n-Cluster::GetEntry(\n-    const CuePoint& cp,\n-    const CuePoint::TrackPosition& tp) const\n-{\n-    assert(m_pSegment);\n+const BlockEntry* Cluster::GetEntry(const CuePoint& cp,\n+                                    const CuePoint::TrackPosition& tp) const {\n+  assert(m_pSegment);\n \n #if 0\n \n@@ -8867,114 +7738,105 @@\n\n \n #else\n \n-    const long long tc = cp.GetTimeCode();\n+  const long long tc = cp.GetTimeCode();\n \n-    if (tp.m_block > 0)\n-    {\n-        const long block = static_cast<long>(tp.m_block);\n-        const long index = block - 1;\n+  if (tp.m_block > 0) {\n+    const long block = static_cast<long>(tp.m_block);\n+    const long index = block - 1;\n \n-        while (index >= m_entries_count)\n-        {\n-            long long pos;\n-            long len;\n+    while (index >= m_entries_count) {\n+      long long pos;\n+      long len;\n \n-            const long status = Parse(pos, len);\n+      const long status = Parse(pos, len);\n \n-            if (status < 0)  //TODO: can this happen?\n-                return NULL;\n+      if (status < 0)  // TODO: can this happen?\n+        return NULL;\n \n-            if (status > 0)  //nothing remains to be parsed\n-                return NULL;\n-        }\n-\n-        const BlockEntry* const pEntry = m_entries[index];\n-        assert(pEntry);\n-        assert(!pEntry->EOS());\n-\n-        const Block* const pBlock = pEntry->GetBlock();\n-        assert(pBlock);\n-\n-        if ((pBlock->GetTrackNumber() == tp.m_track) &&\n-            (pBlock->GetTimeCode(this) == tc))\n-        {\n-            return pEntry;\n-        }\n+      if (status > 0)  // nothing remains to be parsed\n+        return NULL;\n     }\n \n-    long index = 0;\n+    const BlockEntry* const pEntry = m_entries[index];\n+    assert(pEntry);\n+    assert(!pEntry->EOS());\n \n-    for (;;)\n-    {\n-        if (index >= m_entries_count)\n-        {\n-            long long pos;\n-            long len;\n+    const Block* const pBlock = pEntry->GetBlock();\n+    assert(pBlock);\n \n-            const long status = Parse(pos, len);\n-\n-            if (status < 0)  //TODO: can this happen?\n-                return NULL;\n-\n-            if (status > 0)  //nothing remains to be parsed\n-                return NULL;\n-\n-            assert(m_entries);\n-            assert(index < m_entries_count);\n-        }\n-\n-        const BlockEntry* const pEntry = m_entries[index];\n-        assert(pEntry);\n-        assert(!pEntry->EOS());\n-\n-        const Block* const pBlock = pEntry->GetBlock();\n-        assert(pBlock);\n-\n-        if (pBlock->GetTrackNumber() != tp.m_track)\n-        {\n-            ++index;\n-            continue;\n-        }\n-\n-        const long long tc_ = pBlock->GetTimeCode(this);\n-\n-        if (tc_ < tc)\n-        {\n-            ++index;\n-            continue;\n-        }\n-\n-        if (tc_ > tc)\n-            return NULL;\n-\n-        const Tracks* const pTracks = m_pSegment->GetTracks();\n-        assert(pTracks);\n-\n-        const long tn = static_cast<long>(tp.m_track);\n-        const Track* const pTrack = pTracks->GetTrackByNumber(tn);\n-\n-        if (pTrack == NULL)\n-            return NULL;\n-\n-        const long long type = pTrack->GetType();\n-\n-        if (type == 2)  //audio\n-            return pEntry;\n-\n-        if (type != 1)  //not video\n-            return NULL;\n-\n-        if (!pBlock->IsKey())\n-            return NULL;\n-\n-        return pEntry;\n+    if ((pBlock->GetTrackNumber() == tp.m_track) &&\n+        (pBlock->GetTimeCode(this) == tc)) {\n+      return pEntry;\n     }\n+  }\n+\n+  long index = 0;\n+\n+  for (;;) {\n+    if (index >= m_entries_count) {\n+      long long pos;\n+      long len;\n+\n+      const long status = Parse(pos, len);\n+\n+      if (status < 0)  // TODO: can this happen?\n+        return NULL;\n+\n+      if (status > 0)  // nothing remains to be parsed\n+        return NULL;\n+\n+      assert(m_entries);\n+      assert(index < m_entries_count);\n+    }\n+\n+    const BlockEntry* const pEntry = m_entries[index];\n+    assert(pEntry);\n+    assert(!pEntry->EOS());\n+\n+    const Block* const pBlock = pEntry->GetBlock();\n+    assert(pBlock);\n+\n+    if (pBlock->GetTrackNumber() != tp.m_track) {\n+      ++index;\n+      continue;\n+    }\n+\n+    const long long tc_ = pBlock->GetTimeCode(this);\n+\n+    if (tc_ < tc) {\n+      ++index;\n+      continue;\n+    }\n+\n+    if (tc_ > tc)\n+      return NULL;\n+\n+    const Tracks* const pTracks = m_pSegment->GetTracks();\n+    assert(pTracks);\n+\n+    const long tn = static_cast<long>(tp.m_track);\n+    const Track* const pTrack = pTracks->GetTrackByNumber(tn);\n+\n+    if (pTrack == NULL)\n+      return NULL;\n+\n+    const long long type = pTrack->GetType();\n+\n+    if (type == 2)  // audio\n+      return pEntry;\n+\n+    if (type != 1)  // not video\n+      return NULL;\n+\n+    if (!pBlock->IsKey())\n+      return NULL;\n+\n+    return pEntry;\n+  }\n \n #endif\n-\n }\n \n-\n #if 0\n const BlockEntry* Cluster::GetMaxKey(const VideoTrack* pTrack) const\n {\n@@ -9011,97 +7873,46 @@\n\n }\n #endif\n \n+BlockEntry::BlockEntry(Cluster* p, long idx) : m_pCluster(p), m_index(idx) {}\n \n-BlockEntry::BlockEntry(Cluster* p, long idx) :\n-    m_pCluster(p),\n-    m_index(idx)\n-{\n+BlockEntry::~BlockEntry() {}\n+\n+bool BlockEntry::EOS() const { return (GetKind() == kBlockEOS); }\n+\n+const Cluster* BlockEntry::GetCluster() const { return m_pCluster; }\n+\n+long BlockEntry::GetIndex() const { return m_index; }\n+\n+SimpleBlock::SimpleBlock(Cluster* pCluster, long idx, long long start,\n+                         long long size)\n+    : BlockEntry(pCluster, idx), m_block(start, size, 0) {}\n+\n+long SimpleBlock::Parse() { return m_block.Parse(m_pCluster); }\n+\n+BlockEntry::Kind SimpleBlock::GetKind() const { return kBlockSimple; }\n+\n+const Block* SimpleBlock::GetBlock() const { return &m_block; }\n+\n+BlockGroup::BlockGroup(Cluster* pCluster, long idx, long long block_start,\n+                       long long block_size, long long prev, long long next,\n+                       long long duration, long long discard_padding)\n+    : BlockEntry(pCluster, idx),\n+      m_block(block_start, block_size, discard_padding),\n+      m_prev(prev),\n+      m_next(next),\n+      m_duration(duration) {}\n+\n+long BlockGroup::Parse() {\n+  const long status = m_block.Parse(m_pCluster);\n+\n+  if (status)\n+    return status;\n+\n+  m_block.SetKey((m_prev > 0) && (m_next <= 0));\n+\n+  return 0;\n }\n \n-\n-BlockEntry::~BlockEntry()\n-{\n-}\n-\n-\n-bool BlockEntry::EOS() const\n-{\n-    return (GetKind() == kBlockEOS);\n-}\n-\n-\n-const Cluster* BlockEntry::GetCluster() const\n-{\n-    return m_pCluster;\n-}\n-\n-\n-long BlockEntry::GetIndex() const\n-{\n-    return m_index;\n-}\n-\n-\n-SimpleBlock::SimpleBlock(\n-    Cluster* pCluster,\n-    long idx,\n-    long long start,\n-    long long size) :\n-    BlockEntry(pCluster, idx),\n-    m_block(start, size, 0)\n-{\n-}\n-\n-\n-long SimpleBlock::Parse()\n-{\n-    return m_block.Parse(m_pCluster);\n-}\n-\n-\n-BlockEntry::Kind SimpleBlock::GetKind() const\n-{\n-    return kBlockSimple;\n-}\n-\n-\n-const Block* SimpleBlock::GetBlock() const\n-{\n-    return &m_block;\n-}\n-\n-\n-BlockGroup::BlockGroup(\n-    Cluster* pCluster,\n-    long idx,\n-    long long block_start,\n-    long long block_size,\n-    long long prev,\n-    long long next,\n-    long long duration,\n-    long long discard_padding) :\n-    BlockEntry(pCluster, idx),\n-    m_block(block_start, block_size, discard_padding),\n-    m_prev(prev),\n-    m_next(next),\n-    m_duration(duration)\n-{\n-}\n-\n-\n-long BlockGroup::Parse()\n-{\n-    const long status = m_block.Parse(m_pCluster);\n-\n-    if (status)\n-        return status;\n-\n-    m_block.SetKey((m_prev > 0) && (m_next <= 0));\n-\n-    return 0;\n-}\n-\n-\n #if 0\n void BlockGroup::ParseBlock(long long start, long long size)\n {\n@@ -9118,496 +7929,428 @@\n\n }\n #endif\n \n+BlockEntry::Kind BlockGroup::GetKind() const { return kBlockGroup; }\n \n-BlockEntry::Kind BlockGroup::GetKind() const\n-{\n-    return kBlockGroup;\n-}\n+const Block* BlockGroup::GetBlock() const { return &m_block; }\n \n+long long BlockGroup::GetPrevTimeCode() const { return m_prev; }\n \n-const Block* BlockGroup::GetBlock() const\n-{\n-    return &m_block;\n-}\n+long long BlockGroup::GetNextTimeCode() const { return m_next; }\n \n+long long BlockGroup::GetDurationTimeCode() const { return m_duration; }\n \n-long long BlockGroup::GetPrevTimeCode() const\n-{\n-    return m_prev;\n-}\n+Block::Block(long long start, long long size_, long long discard_padding)\n+    : m_start(start),\n+      m_size(size_),\n+      m_track(0),\n+      m_timecode(-1),\n+      m_flags(0),\n+      m_frames(NULL),\n+      m_frame_count(-1),\n+      m_discard_padding(discard_padding) {}\n \n+Block::~Block() { delete[] m_frames; }\n \n-long long BlockGroup::GetNextTimeCode() const\n-{\n-    return m_next;\n-}\n+long Block::Parse(const Cluster* pCluster) {\n+  if (pCluster == NULL)\n+    return -1;\n \n-long long BlockGroup::GetDurationTimeCode() const\n-{\n-    return m_duration;\n-}\n+  if (pCluster->m_pSegment == NULL)\n+    return -1;\n \n-Block::Block(long long start, long long size_, long long discard_padding) :\n-    m_start(start),\n-    m_size(size_),\n-    m_track(0),\n-    m_timecode(-1),\n-    m_flags(0),\n-    m_frames(NULL),\n-    m_frame_count(-1),\n-    m_discard_padding(discard_padding)\n-{\n-}\n+  assert(m_start >= 0);\n+  assert(m_size >= 0);\n+  assert(m_track <= 0);\n+  assert(m_frames == NULL);\n+  assert(m_frame_count <= 0);\n \n+  long long pos = m_start;\n+  const long long stop = m_start + m_size;\n \n-Block::~Block()\n-{\n-    delete[] m_frames;\n-}\n+  long len;\n \n+  IMkvReader* const pReader = pCluster->m_pSegment->m_pReader;\n \n-long Block::Parse(const Cluster* pCluster)\n-{\n-    if (pCluster == NULL)\n-        return -1;\n+  m_track = ReadUInt(pReader, pos, len);\n \n-    if (pCluster->m_pSegment == NULL)\n-        return -1;\n+  if (m_track <= 0)\n+    return E_FILE_FORMAT_INVALID;\n \n-    assert(m_start >= 0);\n-    assert(m_size >= 0);\n-    assert(m_track <= 0);\n-    assert(m_frames == NULL);\n-    assert(m_frame_count <= 0);\n+  if ((pos + len) > stop)\n+    return E_FILE_FORMAT_INVALID;\n \n-    long long pos = m_start;\n-    const long long stop = m_start + m_size;\n+  pos += len;  // consume track number\n \n-    long len;\n+  if ((stop - pos) < 2)\n+    return E_FILE_FORMAT_INVALID;\n \n-    IMkvReader* const pReader = pCluster->m_pSegment->m_pReader;\n+  long status;\n+  long long value;\n \n-    m_track = ReadUInt(pReader, pos, len);\n+  status = UnserializeInt(pReader, pos, 2, value);\n \n-    if (m_track <= 0)\n-        return E_FILE_FORMAT_INVALID;\n+  if (status)\n+    return E_FILE_FORMAT_INVALID;\n \n-    if ((pos + len) > stop)\n-        return E_FILE_FORMAT_INVALID;\n+  if (value < SHRT_MIN)\n+    return E_FILE_FORMAT_INVALID;\n \n-    pos += len;  //consume track number\n+  if (value > SHRT_MAX)\n+    return E_FILE_FORMAT_INVALID;\n \n-    if ((stop - pos) < 2)\n-        return E_FILE_FORMAT_INVALID;\n+  m_timecode = static_cast<short>(value);\n \n-    long status;\n-    long long value;\n+  pos += 2;\n \n-    status = UnserializeInt(pReader, pos, 2, value);\n+  if ((stop - pos) <= 0)\n+    return E_FILE_FORMAT_INVALID;\n \n-    if (status)\n-        return E_FILE_FORMAT_INVALID;\n+  status = pReader->Read(pos, 1, &m_flags);\n \n-    if (value < SHRT_MIN)\n-        return E_FILE_FORMAT_INVALID;\n+  if (status)\n+    return E_FILE_FORMAT_INVALID;\n \n-    if (value > SHRT_MAX)\n-        return E_FILE_FORMAT_INVALID;\n+  const int lacing = int(m_flags & 0x06) >> 1;\n \n-    m_timecode = static_cast<short>(value);\n+  ++pos;  // consume flags byte\n \n-    pos += 2;\n+  if (lacing == 0) {  // no lacing\n+    if (pos > stop)\n+      return E_FILE_FORMAT_INVALID;\n \n-    if ((stop - pos) <= 0)\n-        return E_FILE_FORMAT_INVALID;\n-\n-    status = pReader->Read(pos, 1, &m_flags);\n-\n-    if (status)\n-        return E_FILE_FORMAT_INVALID;\n-\n-    const int lacing = int(m_flags & 0x06) >> 1;\n-\n-    ++pos;  //consume flags byte\n-\n-    if (lacing == 0)  //no lacing\n-    {\n-        if (pos > stop)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        m_frame_count = 1;\n-        m_frames = new Frame[m_frame_count];\n-\n-        Frame& f = m_frames[0];\n-        f.pos = pos;\n-\n-        const long long frame_size = stop - pos;\n-\n-        if (frame_size > LONG_MAX)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        f.len = static_cast<long>(frame_size);\n-\n-        return 0;  //success\n-    }\n-\n-    if (pos >= stop)\n-        return E_FILE_FORMAT_INVALID;\n-\n-    unsigned char biased_count;\n-\n-    status = pReader->Read(pos, 1, &biased_count);\n-\n-    if (status)\n-        return E_FILE_FORMAT_INVALID;\n-\n-    ++pos;  //consume frame count\n-    assert(pos <= stop);\n-\n-    m_frame_count = int(biased_count) + 1;\n-\n+    m_frame_count = 1;\n     m_frames = new Frame[m_frame_count];\n-    assert(m_frames);\n \n-    if (lacing == 1)  //Xiph\n-    {\n-        Frame* pf = m_frames;\n-        Frame* const pf_end = pf + m_frame_count;\n+    Frame& f = m_frames[0];\n+    f.pos = pos;\n \n-        long size = 0;\n-        int frame_count = m_frame_count;\n+    const long long frame_size = stop - pos;\n \n-        while (frame_count > 1)\n-        {\n-            long frame_size = 0;\n+    if (frame_size > LONG_MAX)\n+      return E_FILE_FORMAT_INVALID;\n \n-            for (;;)\n-            {\n-                unsigned char val;\n+    f.len = static_cast<long>(frame_size);\n \n-                if (pos >= stop)\n-                    return E_FILE_FORMAT_INVALID;\n+    return 0;  // success\n+  }\n \n-                status = pReader->Read(pos, 1, &val);\n+  if (pos >= stop)\n+    return E_FILE_FORMAT_INVALID;\n \n-                if (status)\n-                    return E_FILE_FORMAT_INVALID;\n+  unsigned char biased_count;\n \n-                ++pos;  //consume xiph size byte\n+  status = pReader->Read(pos, 1, &biased_count);\n \n-                frame_size += val;\n+  if (status)\n+    return E_FILE_FORMAT_INVALID;\n \n-                if (val < 255)\n-                    break;\n-            }\n+  ++pos;  // consume frame count\n+  assert(pos <= stop);\n \n-            Frame& f = *pf++;\n-            assert(pf < pf_end);\n+  m_frame_count = int(biased_count) + 1;\n \n-            f.pos = 0;  //patch later\n+  m_frames = new Frame[m_frame_count];\n+  assert(m_frames);\n \n-            f.len = frame_size;\n-            size += frame_size;  //contribution of this frame\n+  if (lacing == 1) {  // Xiph\n+    Frame* pf = m_frames;\n+    Frame* const pf_end = pf + m_frame_count;\n \n-            --frame_count;\n-        }\n+    long size = 0;\n+    int frame_count = m_frame_count;\n \n-        assert(pf < pf_end);\n-        assert(pos <= stop);\n+    while (frame_count > 1) {\n+      long frame_size = 0;\n \n-        {\n-            Frame& f = *pf++;\n-\n-            if (pf != pf_end)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            f.pos = 0;  //patch later\n-\n-            const long long total_size = stop - pos;\n-\n-            if (total_size < size)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            const long long frame_size = total_size - size;\n-\n-            if (frame_size > LONG_MAX)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            f.len = static_cast<long>(frame_size);\n-        }\n-\n-        pf = m_frames;\n-        while (pf != pf_end)\n-        {\n-            Frame& f = *pf++;\n-            assert((pos + f.len) <= stop);\n-\n-            f.pos = pos;\n-            pos += f.len;\n-        }\n-\n-        assert(pos == stop);\n-    }\n-    else if (lacing == 2)  //fixed-size lacing\n-    {\n-        const long long total_size = stop - pos;\n-\n-        if ((total_size % m_frame_count) != 0)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        const long long frame_size = total_size / m_frame_count;\n-\n-        if (frame_size > LONG_MAX)\n-            return E_FILE_FORMAT_INVALID;\n-\n-        Frame* pf = m_frames;\n-        Frame* const pf_end = pf + m_frame_count;\n-\n-        while (pf != pf_end)\n-        {\n-            assert((pos + frame_size) <= stop);\n-\n-            Frame& f = *pf++;\n-\n-            f.pos = pos;\n-            f.len = static_cast<long>(frame_size);\n-\n-            pos += frame_size;\n-        }\n-\n-        assert(pos == stop);\n-    }\n-    else\n-    {\n-        assert(lacing == 3);  //EBML lacing\n+      for (;;) {\n+        unsigned char val;\n \n         if (pos >= stop)\n-            return E_FILE_FORMAT_INVALID;\n+          return E_FILE_FORMAT_INVALID;\n \n-        long size = 0;\n-        int frame_count = m_frame_count;\n+        status = pReader->Read(pos, 1, &val);\n \n-        long long frame_size = ReadUInt(pReader, pos, len);\n+        if (status)\n+          return E_FILE_FORMAT_INVALID;\n \n-        if (frame_size < 0)\n-            return E_FILE_FORMAT_INVALID;\n+        ++pos;  // consume xiph size byte\n \n-        if (frame_size > LONG_MAX)\n-            return E_FILE_FORMAT_INVALID;\n+        frame_size += val;\n \n-        if ((pos + len) > stop)\n-            return E_FILE_FORMAT_INVALID;\n+        if (val < 255)\n+          break;\n+      }\n \n-        pos += len; //consume length of size of first frame\n+      Frame& f = *pf++;\n+      assert(pf < pf_end);\n \n-        if ((pos + frame_size) > stop)\n-            return E_FILE_FORMAT_INVALID;\n+      f.pos = 0;  // patch later\n \n-        Frame* pf = m_frames;\n-        Frame* const pf_end = pf + m_frame_count;\n+      f.len = frame_size;\n+      size += frame_size;  // contribution of this frame\n \n-        {\n-            Frame& curr = *pf;\n-\n-            curr.pos = 0;  //patch later\n-\n-            curr.len = static_cast<long>(frame_size);\n-            size += curr.len;  //contribution of this frame\n-        }\n-\n-        --frame_count;\n-\n-        while (frame_count > 1)\n-        {\n-            if (pos >= stop)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            assert(pf < pf_end);\n-\n-            const Frame& prev = *pf++;\n-            assert(prev.len == frame_size);\n-            if (prev.len != frame_size)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            assert(pf < pf_end);\n-\n-            Frame& curr = *pf;\n-\n-            curr.pos = 0;  //patch later\n-\n-            const long long delta_size_ = ReadUInt(pReader, pos, len);\n-\n-            if (delta_size_ < 0)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            if ((pos + len) > stop)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            pos += len;  //consume length of (delta) size\n-            assert(pos <= stop);\n-\n-            const int exp = 7*len - 1;\n-            const long long bias = (1LL << exp) - 1LL;\n-            const long long delta_size = delta_size_ - bias;\n-\n-            frame_size += delta_size;\n-\n-            if (frame_size < 0)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            if (frame_size > LONG_MAX)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            curr.len = static_cast<long>(frame_size);\n-            size += curr.len;  //contribution of this frame\n-\n-            --frame_count;\n-        }\n-\n-        {\n-            assert(pos <= stop);\n-            assert(pf < pf_end);\n-\n-            const Frame& prev = *pf++;\n-            assert(prev.len == frame_size);\n-            if (prev.len != frame_size)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            assert(pf < pf_end);\n-\n-            Frame& curr = *pf++;\n-            assert(pf == pf_end);\n-\n-            curr.pos = 0;  //patch later\n-\n-            const long long total_size = stop - pos;\n-\n-            if (total_size < size)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            frame_size = total_size - size;\n-\n-            if (frame_size > LONG_MAX)\n-                return E_FILE_FORMAT_INVALID;\n-\n-            curr.len = static_cast<long>(frame_size);\n-        }\n-\n-        pf = m_frames;\n-        while (pf != pf_end)\n-        {\n-            Frame& f = *pf++;\n-            assert((pos + f.len) <= stop);\n-\n-            f.pos = pos;\n-            pos += f.len;\n-        }\n-\n-        assert(pos == stop);\n+      --frame_count;\n     }\n \n-    return 0;  //success\n+    assert(pf < pf_end);\n+    assert(pos <= stop);\n+\n+    {\n+      Frame& f = *pf++;\n+\n+      if (pf != pf_end)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      f.pos = 0;  // patch later\n+\n+      const long long total_size = stop - pos;\n+\n+      if (total_size < size)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      const long long frame_size = total_size - size;\n+\n+      if (frame_size > LONG_MAX)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      f.len = static_cast<long>(frame_size);\n+    }\n+\n+    pf = m_frames;\n+    while (pf != pf_end) {\n+      Frame& f = *pf++;\n+      assert((pos + f.len) <= stop);\n+\n+      f.pos = pos;\n+      pos += f.len;\n+    }\n+\n+    assert(pos == stop);\n+  } else if (lacing == 2) {  // fixed-size lacing\n+    const long long total_size = stop - pos;\n+\n+    if ((total_size % m_frame_count) != 0)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    const long long frame_size = total_size / m_frame_count;\n+\n+    if (frame_size > LONG_MAX)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    Frame* pf = m_frames;\n+    Frame* const pf_end = pf + m_frame_count;\n+\n+    while (pf != pf_end) {\n+      assert((pos + frame_size) <= stop);\n+\n+      Frame& f = *pf++;\n+\n+      f.pos = pos;\n+      f.len = static_cast<long>(frame_size);\n+\n+      pos += frame_size;\n+    }\n+\n+    assert(pos == stop);\n+  } else {\n+    assert(lacing == 3);  // EBML lacing\n+\n+    if (pos >= stop)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    long size = 0;\n+    int frame_count = m_frame_count;\n+\n+    long long frame_size = ReadUInt(pReader, pos, len);\n+\n+    if (frame_size < 0)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if (frame_size > LONG_MAX)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    if ((pos + len) > stop)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    pos += len;  // consume length of size of first frame\n+\n+    if ((pos + frame_size) > stop)\n+      return E_FILE_FORMAT_INVALID;\n+\n+    Frame* pf = m_frames;\n+    Frame* const pf_end = pf + m_frame_count;\n+\n+    {\n+      Frame& curr = *pf;\n+\n+      curr.pos = 0;  // patch later\n+\n+      curr.len = static_cast<long>(frame_size);\n+      size += curr.len;  // contribution of this frame\n+    }\n+\n+    --frame_count;\n+\n+    while (frame_count > 1) {\n+      if (pos >= stop)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      assert(pf < pf_end);\n+\n+      const Frame& prev = *pf++;\n+      assert(prev.len == frame_size);\n+      if (prev.len != frame_size)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      assert(pf < pf_end);\n+\n+      Frame& curr = *pf;\n+\n+      curr.pos = 0;  // patch later\n+\n+      const long long delta_size_ = ReadUInt(pReader, pos, len);\n+\n+      if (delta_size_ < 0)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      if ((pos + len) > stop)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      pos += len;  // consume length of (delta) size\n+      assert(pos <= stop);\n+\n+      const int exp = 7 * len - 1;\n+      const long long bias = (1LL << exp) - 1LL;\n+      const long long delta_size = delta_size_ - bias;\n+\n+      frame_size += delta_size;\n+\n+      if (frame_size < 0)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      if (frame_size > LONG_MAX)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      curr.len = static_cast<long>(frame_size);\n+      size += curr.len;  // contribution of this frame\n+\n+      --frame_count;\n+    }\n+\n+    {\n+      assert(pos <= stop);\n+      assert(pf < pf_end);\n+\n+      const Frame& prev = *pf++;\n+      assert(prev.len == frame_size);\n+      if (prev.len != frame_size)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      assert(pf < pf_end);\n+\n+      Frame& curr = *pf++;\n+      assert(pf == pf_end);\n+\n+      curr.pos = 0;  // patch later\n+\n+      const long long total_size = stop - pos;\n+\n+      if (total_size < size)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      frame_size = total_size - size;\n+\n+      if (frame_size > LONG_MAX)\n+        return E_FILE_FORMAT_INVALID;\n+\n+      curr.len = static_cast<long>(frame_size);\n+    }\n+\n+    pf = m_frames;\n+    while (pf != pf_end) {\n+      Frame& f = *pf++;\n+      assert((pos + f.len) <= stop);\n+\n+      f.pos = pos;\n+      pos += f.len;\n+    }\n+\n+    assert(pos == stop);\n+  }\n+\n+  return 0;  // success\n }\n \n+long long Block::GetTimeCode(const Cluster* pCluster) const {\n+  if (pCluster == 0)\n+    return m_timecode;\n \n-long long Block::GetTimeCode(const Cluster* pCluster) const\n-{\n-    if (pCluster == 0)\n-        return m_timecode;\n+  const long long tc0 = pCluster->GetTimeCode();\n+  assert(tc0 >= 0);\n \n-    const long long tc0 = pCluster->GetTimeCode();\n-    assert(tc0 >= 0);\n+  const long long tc = tc0 + m_timecode;\n \n-    const long long tc = tc0 + m_timecode;\n-\n-    return tc;  //unscaled timecode units\n+  return tc;  // unscaled timecode units\n }\n \n+long long Block::GetTime(const Cluster* pCluster) const {\n+  assert(pCluster);\n \n-long long Block::GetTime(const Cluster* pCluster) const\n-{\n-    assert(pCluster);\n+  const long long tc = GetTimeCode(pCluster);\n \n-    const long long tc = GetTimeCode(pCluster);\n+  const Segment* const pSegment = pCluster->m_pSegment;\n+  const SegmentInfo* const pInfo = pSegment->GetInfo();\n+  assert(pInfo);\n \n-    const Segment* const pSegment = pCluster->m_pSegment;\n-    const SegmentInfo* const pInfo = pSegment->GetInfo();\n-    assert(pInfo);\n+  const long long scale = pInfo->GetTimeCodeScale();\n+  assert(scale >= 1);\n \n-    const long long scale = pInfo->GetTimeCodeScale();\n-    assert(scale >= 1);\n+  const long long ns = tc * scale;\n \n-    const long long ns = tc * scale;\n-\n-    return ns;\n+  return ns;\n }\n \n+long long Block::GetTrackNumber() const { return m_track; }\n \n-long long Block::GetTrackNumber() const\n-{\n-    return m_track;\n+bool Block::IsKey() const {\n+  return ((m_flags & static_cast<unsigned char>(1 << 7)) != 0);\n }\n \n-\n-bool Block::IsKey() const\n-{\n-    return ((m_flags & static_cast<unsigned char>(1 << 7)) != 0);\n+void Block::SetKey(bool bKey) {\n+  if (bKey)\n+    m_flags |= static_cast<unsigned char>(1 << 7);\n+  else\n+    m_flags &= 0x7F;\n }\n \n+bool Block::IsInvisible() const { return bool(int(m_flags & 0x08) != 0); }\n \n-void Block::SetKey(bool bKey)\n-{\n-    if (bKey)\n-        m_flags |= static_cast<unsigned char>(1 << 7);\n-    else\n-        m_flags &= 0x7F;\n+Block::Lacing Block::GetLacing() const {\n+  const int value = int(m_flags & 0x06) >> 1;\n+  return static_cast<Lacing>(value);\n }\n \n+int Block::GetFrameCount() const { return m_frame_count; }\n \n-bool Block::IsInvisible() const\n-{\n-    return bool(int(m_flags & 0x08) != 0);\n+const Block::Frame& Block::GetFrame(int idx) const {\n+  assert(idx >= 0);\n+  assert(idx < m_frame_count);\n+\n+  const Frame& f = m_frames[idx];\n+  assert(f.pos > 0);\n+  assert(f.len > 0);\n+\n+  return f;\n }\n \n+long Block::Frame::Read(IMkvReader* pReader, unsigned char* buf) const {\n+  assert(pReader);\n+  assert(buf);\n \n-Block::Lacing Block::GetLacing() const\n-{\n-    const int value = int(m_flags & 0x06) >> 1;\n-    return static_cast<Lacing>(value);\n+  const long status = pReader->Read(pos, len, buf);\n+  return status;\n }\n \n+long long Block::GetDiscardPadding() const { return m_discard_padding; }\n \n-int Block::GetFrameCount() const\n-{\n-    return m_frame_count;\n-}\n-\n-\n-const Block::Frame& Block::GetFrame(int idx) const\n-{\n-    assert(idx >= 0);\n-    assert(idx < m_frame_count);\n-\n-    const Frame& f = m_frames[idx];\n-    assert(f.pos > 0);\n-    assert(f.len > 0);\n-\n-    return f;\n-}\n-\n-\n-long Block::Frame::Read(IMkvReader* pReader, unsigned char* buf) const\n-{\n-    assert(pReader);\n-    assert(buf);\n-\n-    const long status = pReader->Read(pos, len, buf);\n-    return status;\n-}\n-\n-long long Block::GetDiscardPadding() const\n-{\n-    return m_discard_padding;\n-}\n-\n-}  //end namespace mkvparser\n+}  // end namespace mkvparser\n""}<_**next**_>{""filename"": ""libwebm/mkvparser.hpp"", ""raw_url"": ""https://android.googlesource.com/platform/external/libvpx/+/04839626ed859623901ebd3a5fd483982186b59d/libwebm/mkvparser.hpp"", ""patch"": ""@@ -13,19 +13,18 @@\n\n #include <cstdio>\n #include <cstddef>\n \n-namespace mkvparser\n-{\n+namespace mkvparser {\n \n const int E_FILE_FORMAT_INVALID = -2;\n const int E_BUFFER_NOT_FULL = -3;\n \n-class IMkvReader\n-{\n-public:\n-    virtual int Read(long long pos, long len, unsigned char* buf) = 0;\n-    virtual int Length(long long* total, long long* available) = 0;\n-protected:\n-    virtual ~IMkvReader();\n+class IMkvReader {\n+ public:\n+  virtual int Read(long long pos, long len, unsigned char* buf) = 0;\n+  virtual int Length(long long* total, long long* available) = 0;\n+\n+ protected:\n+  virtual ~IMkvReader();\n };\n \n long long GetUIntLength(IMkvReader*, long long, long&);\n@@ -35,170 +34,148 @@\n\n long UnserializeFloat(IMkvReader*, long long pos, long long size, double&);\n long UnserializeInt(IMkvReader*, long long pos, long len, long long& result);\n \n-long UnserializeString(\n-        IMkvReader*,\n-        long long pos,\n-        long long size,\n-        char*& str);\n+long UnserializeString(IMkvReader*, long long pos, long long size, char*& str);\n \n-long ParseElementHeader(\n-    IMkvReader* pReader,\n-    long long& pos,  //consume id and size fields\n-    long long stop,  //if you know size of element's parent\n-    long long& id,\n-    long long& size);\n+long ParseElementHeader(IMkvReader* pReader,\n+                        long long& pos,  // consume id and size fields\n+                        long long stop,  // if you know size of element's parent\n+                        long long& id, long long& size);\n \n bool Match(IMkvReader*, long long&, unsigned long, long long&);\n bool Match(IMkvReader*, long long&, unsigned long, unsigned char*&, size_t&);\n \n void GetVersion(int& major, int& minor, int& build, int& revision);\n \n-struct EBMLHeader\n-{\n-    EBMLHeader();\n-    ~EBMLHeader();\n-    long long m_version;\n-    long long m_readVersion;\n-    long long m_maxIdLength;\n-    long long m_maxSizeLength;\n-    char* m_docType;\n-    long long m_docTypeVersion;\n-    long long m_docTypeReadVersion;\n+struct EBMLHeader {\n+  EBMLHeader();\n+  ~EBMLHeader();\n+  long long m_version;\n+  long long m_readVersion;\n+  long long m_maxIdLength;\n+  long long m_maxSizeLength;\n+  char* m_docType;\n+  long long m_docTypeVersion;\n+  long long m_docTypeReadVersion;\n \n-    long long Parse(IMkvReader*, long long&);\n-    void Init();\n+  long long Parse(IMkvReader*, long long&);\n+  void Init();\n };\n \n-\n class Segment;\n class Track;\n class Cluster;\n \n-class Block\n-{\n-    Block(const Block&);\n-    Block& operator=(const Block&);\n+class Block {\n+  Block(const Block&);\n+  Block& operator=(const Block&);\n \n-public:\n-    const long long m_start;\n-    const long long m_size;\n+ public:\n+  const long long m_start;\n+  const long long m_size;\n \n-    Block(long long start, long long size, long long discard_padding);\n-    ~Block();\n+  Block(long long start, long long size, long long discard_padding);\n+  ~Block();\n \n-    long Parse(const Cluster*);\n+  long Parse(const Cluster*);\n \n-    long long GetTrackNumber() const;\n-    long long GetTimeCode(const Cluster*) const;  //absolute, but not scaled\n-    long long GetTime(const Cluster*) const;      //absolute, and scaled (ns)\n-    bool IsKey() const;\n-    void SetKey(bool);\n-    bool IsInvisible() const;\n+  long long GetTrackNumber() const;\n+  long long GetTimeCode(const Cluster*) const;  // absolute, but not scaled\n+  long long GetTime(const Cluster*) const;  // absolute, and scaled (ns)\n+  bool IsKey() const;\n+  void SetKey(bool);\n+  bool IsInvisible() const;\n \n-    enum Lacing { kLacingNone, kLacingXiph, kLacingFixed, kLacingEbml };\n-    Lacing GetLacing() const;\n+  enum Lacing { kLacingNone, kLacingXiph, kLacingFixed, kLacingEbml };\n+  Lacing GetLacing() const;\n \n-    int GetFrameCount() const;  //to index frames: [0, count)\n+  int GetFrameCount() const;  // to index frames: [0, count)\n \n-    struct Frame\n-    {\n-        long long pos;  //absolute offset\n-        long len;\n+  struct Frame {\n+    long long pos;  // absolute offset\n+    long len;\n \n-        long Read(IMkvReader*, unsigned char*) const;\n-    };\n+    long Read(IMkvReader*, unsigned char*) const;\n+  };\n \n-    const Frame& GetFrame(int frame_index) const;\n+  const Frame& GetFrame(int frame_index) const;\n \n-    long long GetDiscardPadding() const;\n+  long long GetDiscardPadding() const;\n \n-private:\n-    long long m_track;   //Track::Number()\n-    short m_timecode;  //relative to cluster\n-    unsigned char m_flags;\n+ private:\n+  long long m_track;  // Track::Number()\n+  short m_timecode;  // relative to cluster\n+  unsigned char m_flags;\n \n-    Frame* m_frames;\n-    int m_frame_count;\n+  Frame* m_frames;\n+  int m_frame_count;\n \n-protected:\n-    const long long m_discard_padding;\n+ protected:\n+  const long long m_discard_padding;\n };\n \n+class BlockEntry {\n+  BlockEntry(const BlockEntry&);\n+  BlockEntry& operator=(const BlockEntry&);\n \n-class BlockEntry\n-{\n-    BlockEntry(const BlockEntry&);\n-    BlockEntry& operator=(const BlockEntry&);\n+ protected:\n+  BlockEntry(Cluster*, long index);\n \n-protected:\n-    BlockEntry(Cluster*, long index);\n+ public:\n+  virtual ~BlockEntry();\n \n-public:\n-    virtual ~BlockEntry();\n+  bool EOS() const;\n+  const Cluster* GetCluster() const;\n+  long GetIndex() const;\n+  virtual const Block* GetBlock() const = 0;\n \n-    bool EOS() const;\n-    const Cluster* GetCluster() const;\n-    long GetIndex() const;\n-    virtual const Block* GetBlock() const = 0;\n+  enum Kind { kBlockEOS, kBlockSimple, kBlockGroup };\n+  virtual Kind GetKind() const = 0;\n \n-    enum Kind { kBlockEOS, kBlockSimple, kBlockGroup };\n-    virtual Kind GetKind() const = 0;\n-\n-protected:\n-    Cluster* const m_pCluster;\n-    const long m_index;\n-\n+ protected:\n+  Cluster* const m_pCluster;\n+  const long m_index;\n };\n \n+class SimpleBlock : public BlockEntry {\n+  SimpleBlock(const SimpleBlock&);\n+  SimpleBlock& operator=(const SimpleBlock&);\n \n-class SimpleBlock : public BlockEntry\n-{\n-    SimpleBlock(const SimpleBlock&);\n-    SimpleBlock& operator=(const SimpleBlock&);\n+ public:\n+  SimpleBlock(Cluster*, long index, long long start, long long size);\n+  long Parse();\n \n-public:\n-    SimpleBlock(Cluster*, long index, long long start, long long size);\n-    long Parse();\n+  Kind GetKind() const;\n+  const Block* GetBlock() const;\n \n-    Kind GetKind() const;\n-    const Block* GetBlock() const;\n-\n-protected:\n-    Block m_block;\n-\n+ protected:\n+  Block m_block;\n };\n \n+class BlockGroup : public BlockEntry {\n+  BlockGroup(const BlockGroup&);\n+  BlockGroup& operator=(const BlockGroup&);\n \n-class BlockGroup : public BlockEntry\n-{\n-    BlockGroup(const BlockGroup&);\n-    BlockGroup& operator=(const BlockGroup&);\n+ public:\n+  BlockGroup(Cluster*, long index,\n+             long long block_start,  // absolute pos of block's payload\n+             long long block_size,  // size of block's payload\n+             long long prev, long long next, long long duration,\n+             long long discard_padding);\n \n-public:\n-    BlockGroup(\n-        Cluster*,\n-        long index,\n-        long long block_start, //absolute pos of block's payload\n-        long long block_size,  //size of block's payload\n-        long long prev,\n-        long long next,\n-        long long duration,\n-        long long discard_padding);\n+  long Parse();\n \n-    long Parse();\n+  Kind GetKind() const;\n+  const Block* GetBlock() const;\n \n-    Kind GetKind() const;\n-    const Block* GetBlock() const;\n+  long long GetPrevTimeCode() const;  // relative to block's time\n+  long long GetNextTimeCode() const;  // as above\n+  long long GetDurationTimeCode() const;\n \n-    long long GetPrevTimeCode() const;  //relative to block's time\n-    long long GetNextTimeCode() const;  //as above\n-    long long GetDurationTimeCode() const;\n-\n-private:\n-    Block m_block;\n-    const long long m_prev;\n-    const long long m_next;\n-    const long long m_duration;\n+ private:\n+  Block m_block;\n+  const long long m_prev;\n+  const long long m_next;\n+  const long long m_duration;\n };\n \n ///////////////////////////////////////////////////////////////\n@@ -206,635 +183,552 @@\n\n // Elements used to describe if the track data has been encrypted or\n // compressed with zlib or header stripping.\n class ContentEncoding {\n-public:\n-    enum {\n-      kCTR = 1\n-    };\n+ public:\n+  enum { kCTR = 1 };\n \n-    ContentEncoding();\n-    ~ContentEncoding();\n+  ContentEncoding();\n+  ~ContentEncoding();\n \n-    // ContentCompression element names\n-    struct ContentCompression {\n-        ContentCompression();\n-        ~ContentCompression();\n+  // ContentCompression element names\n+  struct ContentCompression {\n+    ContentCompression();\n+    ~ContentCompression();\n \n-        unsigned long long algo;\n-        unsigned char* settings;\n-        long long settings_len;\n-    };\n+    unsigned long long algo;\n+    unsigned char* settings;\n+    long long settings_len;\n+  };\n \n-    // ContentEncAESSettings element names\n-    struct ContentEncAESSettings {\n-      ContentEncAESSettings() : cipher_mode(kCTR) {}\n-      ~ContentEncAESSettings() {}\n+  // ContentEncAESSettings element names\n+  struct ContentEncAESSettings {\n+    ContentEncAESSettings() : cipher_mode(kCTR) {}\n+    ~ContentEncAESSettings() {}\n \n-      unsigned long long cipher_mode;\n-    };\n+    unsigned long long cipher_mode;\n+  };\n \n-    // ContentEncryption element names\n-    struct ContentEncryption {\n-        ContentEncryption();\n-        ~ContentEncryption();\n+  // ContentEncryption element names\n+  struct ContentEncryption {\n+    ContentEncryption();\n+    ~ContentEncryption();\n \n-        unsigned long long algo;\n-        unsigned char* key_id;\n-        long long key_id_len;\n-        unsigned char* signature;\n-        long long signature_len;\n-        unsigned char* sig_key_id;\n-        long long sig_key_id_len;\n-        unsigned long long sig_algo;\n-        unsigned long long sig_hash_algo;\n+    unsigned long long algo;\n+    unsigned char* key_id;\n+    long long key_id_len;\n+    unsigned char* signature;\n+    long long signature_len;\n+    unsigned char* sig_key_id;\n+    long long sig_key_id_len;\n+    unsigned long long sig_algo;\n+    unsigned long long sig_hash_algo;\n \n-        ContentEncAESSettings aes_settings;\n-    };\n+    ContentEncAESSettings aes_settings;\n+  };\n \n-    // Returns ContentCompression represented by |idx|. Returns NULL if |idx|\n-    // is out of bounds.\n-    const ContentCompression* GetCompressionByIndex(unsigned long idx) const;\n+  // Returns ContentCompression represented by |idx|. Returns NULL if |idx|\n+  // is out of bounds.\n+  const ContentCompression* GetCompressionByIndex(unsigned long idx) const;\n \n-    // Returns number of ContentCompression elements in this ContentEncoding\n-    // element.\n-    unsigned long GetCompressionCount() const;\n+  // Returns number of ContentCompression elements in this ContentEncoding\n+  // element.\n+  unsigned long GetCompressionCount() const;\n \n-    // Parses the ContentCompression element from |pReader|. |start| is the\n-    // starting offset of the ContentCompression payload. |size| is the size in\n-    // bytes of the ContentCompression payload. |compression| is where the parsed\n-    // values will be stored.\n-    long ParseCompressionEntry(long long start,\n-                               long long size,\n-                               IMkvReader* pReader,\n-                               ContentCompression* compression);\n+  // Parses the ContentCompression element from |pReader|. |start| is the\n+  // starting offset of the ContentCompression payload. |size| is the size in\n+  // bytes of the ContentCompression payload. |compression| is where the parsed\n+  // values will be stored.\n+  long ParseCompressionEntry(long long start, long long size,\n+                             IMkvReader* pReader,\n+                             ContentCompression* compression);\n \n-    // Returns ContentEncryption represented by |idx|. Returns NULL if |idx|\n-    // is out of bounds.\n-    const ContentEncryption* GetEncryptionByIndex(unsigned long idx) const;\n+  // Returns ContentEncryption represented by |idx|. Returns NULL if |idx|\n+  // is out of bounds.\n+  const ContentEncryption* GetEncryptionByIndex(unsigned long idx) const;\n \n-    // Returns number of ContentEncryption elements in this ContentEncoding\n-    // element.\n-    unsigned long GetEncryptionCount() const;\n+  // Returns number of ContentEncryption elements in this ContentEncoding\n+  // element.\n+  unsigned long GetEncryptionCount() const;\n \n-    // Parses the ContentEncAESSettings element from |pReader|. |start| is the\n-    // starting offset of the ContentEncAESSettings payload. |size| is the\n-    // size in bytes of the ContentEncAESSettings payload. |encryption| is\n-    // where the parsed values will be stored.\n-    long ParseContentEncAESSettingsEntry(long long start,\n-                                         long long size,\n-                                         IMkvReader* pReader,\n-                                         ContentEncAESSettings* aes);\n+  // Parses the ContentEncAESSettings element from |pReader|. |start| is the\n+  // starting offset of the ContentEncAESSettings payload. |size| is the\n+  // size in bytes of the ContentEncAESSettings payload. |encryption| is\n+  // where the parsed values will be stored.\n+  long ParseContentEncAESSettingsEntry(long long start, long long size,\n+                                       IMkvReader* pReader,\n+                                       ContentEncAESSettings* aes);\n \n-    // Parses the ContentEncoding element from |pReader|. |start| is the\n-    // starting offset of the ContentEncoding payload. |size| is the size in\n-    // bytes of the ContentEncoding payload. Returns true on success.\n-    long ParseContentEncodingEntry(long long start,\n-                                   long long size,\n-                                   IMkvReader* pReader);\n+  // Parses the ContentEncoding element from |pReader|. |start| is the\n+  // starting offset of the ContentEncoding payload. |size| is the size in\n+  // bytes of the ContentEncoding payload. Returns true on success.\n+  long ParseContentEncodingEntry(long long start, long long size,\n+                                 IMkvReader* pReader);\n \n-    // Parses the ContentEncryption element from |pReader|. |start| is the\n-    // starting offset of the ContentEncryption payload. |size| is the size in\n-    // bytes of the ContentEncryption payload. |encryption| is where the parsed\n-    // values will be stored.\n-    long ParseEncryptionEntry(long long start,\n-                              long long size,\n-                              IMkvReader* pReader,\n-                              ContentEncryption* encryption);\n+  // Parses the ContentEncryption element from |pReader|. |start| is the\n+  // starting offset of the ContentEncryption payload. |size| is the size in\n+  // bytes of the ContentEncryption payload. |encryption| is where the parsed\n+  // values will be stored.\n+  long ParseEncryptionEntry(long long start, long long size,\n+                            IMkvReader* pReader, ContentEncryption* encryption);\n \n-    unsigned long long encoding_order() const { return encoding_order_; }\n-    unsigned long long encoding_scope() const { return encoding_scope_; }\n-    unsigned long long encoding_type() const { return encoding_type_; }\n+  unsigned long long encoding_order() const { return encoding_order_; }\n+  unsigned long long encoding_scope() const { return encoding_scope_; }\n+  unsigned long long encoding_type() const { return encoding_type_; }\n \n-private:\n-    // Member variables for list of ContentCompression elements.\n-    ContentCompression** compression_entries_;\n-    ContentCompression** compression_entries_end_;\n+ private:\n+  // Member variables for list of ContentCompression elements.\n+  ContentCompression** compression_entries_;\n+  ContentCompression** compression_entries_end_;\n \n-    // Member variables for list of ContentEncryption elements.\n-    ContentEncryption** encryption_entries_;\n-    ContentEncryption** encryption_entries_end_;\n+  // Member variables for list of ContentEncryption elements.\n+  ContentEncryption** encryption_entries_;\n+  ContentEncryption** encryption_entries_end_;\n \n-    // ContentEncoding element names\n-    unsigned long long encoding_order_;\n-    unsigned long long encoding_scope_;\n-    unsigned long long encoding_type_;\n+  // ContentEncoding element names\n+  unsigned long long encoding_order_;\n+  unsigned long long encoding_scope_;\n+  unsigned long long encoding_type_;\n \n-    // LIBWEBM_DISALLOW_COPY_AND_ASSIGN(ContentEncoding);\n-    ContentEncoding(const ContentEncoding&);\n-    ContentEncoding& operator=(const ContentEncoding&);\n+  // LIBWEBM_DISALLOW_COPY_AND_ASSIGN(ContentEncoding);\n+  ContentEncoding(const ContentEncoding&);\n+  ContentEncoding& operator=(const ContentEncoding&);\n };\n \n-class Track\n-{\n-    Track(const Track&);\n-    Track& operator=(const Track&);\n+class Track {\n+  Track(const Track&);\n+  Track& operator=(const Track&);\n \n-public:\n-    class Info;\n-    static long Create(\n-        Segment*,\n-        const Info&,\n-        long long element_start,\n-        long long element_size,\n-        Track*&);\n+ public:\n+  class Info;\n+  static long Create(Segment*, const Info&, long long element_start,\n+                     long long element_size, Track*&);\n \n-    enum Type {\n-        kVideo = 1,\n-        kAudio = 2,\n-        kSubtitle = 0x11,\n-        kMetadata = 0x21\n-     };\n+  enum Type { kVideo = 1, kAudio = 2, kSubtitle = 0x11, kMetadata = 0x21 };\n \n-    Segment* const m_pSegment;\n-    const long long m_element_start;\n-    const long long m_element_size;\n-    virtual ~Track();\n+  Segment* const m_pSegment;\n+  const long long m_element_start;\n+  const long long m_element_size;\n+  virtual ~Track();\n \n-    long GetType() const;\n-    long GetNumber() const;\n-    unsigned long long GetUid() const;\n-    const char* GetNameAsUTF8() const;\n+  long GetType() const;\n+  long GetNumber() const;\n+  unsigned long long GetUid() const;\n+  const char* GetNameAsUTF8() const;\n+  const char* GetLanguage() const;\n+  const char* GetCodecNameAsUTF8() const;\n+  const char* GetCodecId() const;\n+  const unsigned char* GetCodecPrivate(size_t&) const;\n+  bool GetLacing() const;\n+  unsigned long long GetDefaultDuration() const;\n+  unsigned long long GetCodecDelay() const;\n+  unsigned long long GetSeekPreRoll() const;\n+\n+  const BlockEntry* GetEOS() const;\n+\n+  struct Settings {\n+    long long start;\n+    long long size;\n+  };\n+\n+  class Info {\n+   public:\n+    Info();\n+    ~Info();\n+    int Copy(Info&) const;\n+    void Clear();\n+    long type;\n+    long number;\n+    unsigned long long uid;\n+    unsigned long long defaultDuration;\n+    unsigned long long codecDelay;\n+    unsigned long long seekPreRoll;\n+    char* nameAsUTF8;\n+    char* language;\n+    char* codecId;\n+    char* codecNameAsUTF8;\n+    unsigned char* codecPrivate;\n+    size_t codecPrivateSize;\n+    bool lacing;\n+    Settings settings;\n+\n+   private:\n+    Info(const Info&);\n+    Info& operator=(const Info&);\n+    int CopyStr(char* Info::*str, Info&) const;\n+  };\n+\n+  long GetFirst(const BlockEntry*&) const;\n+  long GetNext(const BlockEntry* pCurr, const BlockEntry*& pNext) const;\n+  virtual bool VetEntry(const BlockEntry*) const;\n+  virtual long Seek(long long time_ns, const BlockEntry*&) const;\n+\n+  const ContentEncoding* GetContentEncodingByIndex(unsigned long idx) const;\n+  unsigned long GetContentEncodingCount() const;\n+\n+  long ParseContentEncodingsEntry(long long start, long long size);\n+\n+ protected:\n+  Track(Segment*, long long element_start, long long element_size);\n+\n+  Info m_info;\n+\n+  class EOSBlock : public BlockEntry {\n+   public:\n+    EOSBlock();\n+\n+    Kind GetKind() const;\n+    const Block* GetBlock() const;\n+  };\n+\n+  EOSBlock m_eos;\n+\n+ private:\n+  ContentEncoding** content_encoding_entries_;\n+  ContentEncoding** content_encoding_entries_end_;\n+};\n+\n+class VideoTrack : public Track {\n+  VideoTrack(const VideoTrack&);\n+  VideoTrack& operator=(const VideoTrack&);\n+\n+  VideoTrack(Segment*, long long element_start, long long element_size);\n+\n+ public:\n+  static long Parse(Segment*, const Info&, long long element_start,\n+                    long long element_size, VideoTrack*&);\n+\n+  long long GetWidth() const;\n+  long long GetHeight() const;\n+  double GetFrameRate() const;\n+\n+  bool VetEntry(const BlockEntry*) const;\n+  long Seek(long long time_ns, const BlockEntry*&) const;\n+\n+ private:\n+  long long m_width;\n+  long long m_height;\n+  double m_rate;\n+};\n+\n+class AudioTrack : public Track {\n+  AudioTrack(const AudioTrack&);\n+  AudioTrack& operator=(const AudioTrack&);\n+\n+  AudioTrack(Segment*, long long element_start, long long element_size);\n+\n+ public:\n+  static long Parse(Segment*, const Info&, long long element_start,\n+                    long long element_size, AudioTrack*&);\n+\n+  double GetSamplingRate() const;\n+  long long GetChannels() const;\n+  long long GetBitDepth() const;\n+\n+ private:\n+  double m_rate;\n+  long long m_channels;\n+  long long m_bitDepth;\n+};\n+\n+class Tracks {\n+  Tracks(const Tracks&);\n+  Tracks& operator=(const Tracks&);\n+\n+ public:\n+  Segment* const m_pSegment;\n+  const long long m_start;\n+  const long long m_size;\n+  const long long m_element_start;\n+  const long long m_element_size;\n+\n+  Tracks(Segment*, long long start, long long size, long long element_start,\n+         long long element_size);\n+\n+  ~Tracks();\n+\n+  long Parse();\n+\n+  unsigned long GetTracksCount() const;\n+\n+  const Track* GetTrackByNumber(long tn) const;\n+  const Track* GetTrackByIndex(unsigned long idx) const;\n+\n+ private:\n+  Track** m_trackEntries;\n+  Track** m_trackEntriesEnd;\n+\n+  long ParseTrackEntry(long long payload_start, long long payload_size,\n+                       long long element_start, long long element_size,\n+                       Track*&) const;\n+};\n+\n+class Chapters {\n+  Chapters(const Chapters&);\n+  Chapters& operator=(const Chapters&);\n+\n+ public:\n+  Segment* const m_pSegment;\n+  const long long m_start;\n+  const long long m_size;\n+  const long long m_element_start;\n+  const long long m_element_size;\n+\n+  Chapters(Segment*, long long payload_start, long long payload_size,\n+           long long element_start, long long element_size);\n+\n+  ~Chapters();\n+\n+  long Parse();\n+\n+  class Atom;\n+  class Edition;\n+\n+  class Display {\n+    friend class Atom;\n+    Display();\n+    Display(const Display&);\n+    ~Display();\n+    Display& operator=(const Display&);\n+\n+   public:\n+    const char* GetString() const;\n     const char* GetLanguage() const;\n-    const char* GetCodecNameAsUTF8() const;\n-    const char* GetCodecId() const;\n-    const unsigned char* GetCodecPrivate(size_t&) const;\n-    bool GetLacing() const;\n-    unsigned long long GetDefaultDuration() const;\n-    unsigned long long GetCodecDelay() const;\n-    unsigned long long GetSeekPreRoll() const;\n+    const char* GetCountry() const;\n \n-    const BlockEntry* GetEOS() const;\n+   private:\n+    void Init();\n+    void ShallowCopy(Display&) const;\n+    void Clear();\n+    long Parse(IMkvReader*, long long pos, long long size);\n \n-    struct Settings\n-    {\n-        long long start;\n-        long long size;\n-    };\n+    char* m_string;\n+    char* m_language;\n+    char* m_country;\n+  };\n \n-    class Info\n-    {\n-    public:\n-        Info();\n-        ~Info();\n-        int Copy(Info&) const;\n-        void Clear();\n-        long type;\n-        long number;\n-        unsigned long long uid;\n-        unsigned long long defaultDuration;\n-        unsigned long long codecDelay;\n-        unsigned long long seekPreRoll;\n-        char* nameAsUTF8;\n-        char* language;\n-        char* codecId;\n-        char* codecNameAsUTF8;\n-        unsigned char* codecPrivate;\n-        size_t codecPrivateSize;\n-        bool lacing;\n-        Settings settings;\n+  class Atom {\n+    friend class Edition;\n+    Atom();\n+    Atom(const Atom&);\n+    ~Atom();\n+    Atom& operator=(const Atom&);\n \n-    private:\n-        Info(const Info&);\n-        Info& operator=(const Info&);\n-        int CopyStr(char* Info::*str, Info&) const;\n-    };\n+   public:\n+    unsigned long long GetUID() const;\n+    const char* GetStringUID() const;\n \n-    long GetFirst(const BlockEntry*&) const;\n-    long GetNext(const BlockEntry* pCurr, const BlockEntry*& pNext) const;\n-    virtual bool VetEntry(const BlockEntry*) const;\n-    virtual long Seek(long long time_ns, const BlockEntry*&) const;\n+    long long GetStartTimecode() const;\n+    long long GetStopTimecode() const;\n \n-    const ContentEncoding* GetContentEncodingByIndex(unsigned long idx) const;\n-    unsigned long GetContentEncodingCount() const;\n+    long long GetStartTime(const Chapters*) const;\n+    long long GetStopTime(const Chapters*) const;\n \n-    long ParseContentEncodingsEntry(long long start, long long size);\n+    int GetDisplayCount() const;\n+    const Display* GetDisplay(int index) const;\n \n-protected:\n-    Track(\n-        Segment*,\n-        long long element_start,\n-        long long element_size);\n+   private:\n+    void Init();\n+    void ShallowCopy(Atom&) const;\n+    void Clear();\n+    long Parse(IMkvReader*, long long pos, long long size);\n+    static long long GetTime(const Chapters*, long long timecode);\n \n-    Info m_info;\n+    long ParseDisplay(IMkvReader*, long long pos, long long size);\n+    bool ExpandDisplaysArray();\n \n-    class EOSBlock : public BlockEntry\n-    {\n-    public:\n-        EOSBlock();\n+    char* m_string_uid;\n+    unsigned long long m_uid;\n+    long long m_start_timecode;\n+    long long m_stop_timecode;\n \n-        Kind GetKind() const;\n-        const Block* GetBlock() const;\n-    };\n+    Display* m_displays;\n+    int m_displays_size;\n+    int m_displays_count;\n+  };\n \n-    EOSBlock m_eos;\n+  class Edition {\n+    friend class Chapters;\n+    Edition();\n+    Edition(const Edition&);\n+    ~Edition();\n+    Edition& operator=(const Edition&);\n \n-private:\n-    ContentEncoding** content_encoding_entries_;\n-    ContentEncoding** content_encoding_entries_end_;\n+   public:\n+    int GetAtomCount() const;\n+    const Atom* GetAtom(int index) const;\n+\n+   private:\n+    void Init();\n+    void ShallowCopy(Edition&) const;\n+    void Clear();\n+    long Parse(IMkvReader*, long long pos, long long size);\n+\n+    long ParseAtom(IMkvReader*, long long pos, long long size);\n+    bool ExpandAtomsArray();\n+\n+    Atom* m_atoms;\n+    int m_atoms_size;\n+    int m_atoms_count;\n+  };\n+\n+  int GetEditionCount() const;\n+  const Edition* GetEdition(int index) const;\n+\n+ private:\n+  long ParseEdition(long long pos, long long size);\n+  bool ExpandEditionsArray();\n+\n+  Edition* m_editions;\n+  int m_editions_size;\n+  int m_editions_count;\n };\n \n+class SegmentInfo {\n+  SegmentInfo(const SegmentInfo&);\n+  SegmentInfo& operator=(const SegmentInfo&);\n \n-class VideoTrack : public Track\n-{\n-    VideoTrack(const VideoTrack&);\n-    VideoTrack& operator=(const VideoTrack&);\n+ public:\n+  Segment* const m_pSegment;\n+  const long long m_start;\n+  const long long m_size;\n+  const long long m_element_start;\n+  const long long m_element_size;\n \n-    VideoTrack(\n-        Segment*,\n-        long long element_start,\n-        long long element_size);\n+  SegmentInfo(Segment*, long long start, long long size,\n+              long long element_start, long long element_size);\n \n-public:\n-    static long Parse(\n-        Segment*,\n-        const Info&,\n-        long long element_start,\n-        long long element_size,\n-        VideoTrack*&);\n+  ~SegmentInfo();\n \n-    long long GetWidth() const;\n-    long long GetHeight() const;\n-    double GetFrameRate() const;\n+  long Parse();\n \n-    bool VetEntry(const BlockEntry*) const;\n-    long Seek(long long time_ns, const BlockEntry*&) const;\n+  long long GetTimeCodeScale() const;\n+  long long GetDuration() const;  // scaled\n+  const char* GetMuxingAppAsUTF8() const;\n+  const char* GetWritingAppAsUTF8() const;\n+  const char* GetTitleAsUTF8() const;\n \n-private:\n-    long long m_width;\n-    long long m_height;\n-    double m_rate;\n-\n+ private:\n+  long long m_timecodeScale;\n+  double m_duration;\n+  char* m_pMuxingAppAsUTF8;\n+  char* m_pWritingAppAsUTF8;\n+  char* m_pTitleAsUTF8;\n };\n \n+class SeekHead {\n+  SeekHead(const SeekHead&);\n+  SeekHead& operator=(const SeekHead&);\n \n-class AudioTrack : public Track\n-{\n-    AudioTrack(const AudioTrack&);\n-    AudioTrack& operator=(const AudioTrack&);\n+ public:\n+  Segment* const m_pSegment;\n+  const long long m_start;\n+  const long long m_size;\n+  const long long m_element_start;\n+  const long long m_element_size;\n \n-    AudioTrack(\n-        Segment*,\n-        long long element_start,\n-        long long element_size);\n-public:\n-    static long Parse(\n-        Segment*,\n-        const Info&,\n-        long long element_start,\n-        long long element_size,\n-        AudioTrack*&);\n+  SeekHead(Segment*, long long start, long long size, long long element_start,\n+           long long element_size);\n \n-    double GetSamplingRate() const;\n-    long long GetChannels() const;\n-    long long GetBitDepth() const;\n+  ~SeekHead();\n \n-private:\n-    double m_rate;\n-    long long m_channels;\n-    long long m_bitDepth;\n-};\n+  long Parse();\n \n+  struct Entry {\n+    // the SeekHead entry payload\n+    long long id;\n+    long long pos;\n \n-class Tracks\n-{\n-    Tracks(const Tracks&);\n-    Tracks& operator=(const Tracks&);\n+    // absolute pos of SeekEntry ID\n+    long long element_start;\n \n-public:\n-    Segment* const m_pSegment;\n-    const long long m_start;\n-    const long long m_size;\n-    const long long m_element_start;\n-    const long long m_element_size;\n+    // SeekEntry ID size + size size + payload\n+    long long element_size;\n+  };\n \n-    Tracks(\n-        Segment*,\n-        long long start,\n-        long long size,\n-        long long element_start,\n-        long long element_size);\n+  int GetCount() const;\n+  const Entry* GetEntry(int idx) const;\n \n-    ~Tracks();\n+  struct VoidElement {\n+    // absolute pos of Void ID\n+    long long element_start;\n \n-    long Parse();\n+    // ID size + size size + payload size\n+    long long element_size;\n+  };\n \n-    unsigned long GetTracksCount() const;\n+  int GetVoidElementCount() const;\n+  const VoidElement* GetVoidElement(int idx) const;\n \n-    const Track* GetTrackByNumber(long tn) const;\n-    const Track* GetTrackByIndex(unsigned long idx) const;\n+ private:\n+  Entry* m_entries;\n+  int m_entry_count;\n \n-private:\n-    Track** m_trackEntries;\n-    Track** m_trackEntriesEnd;\n+  VoidElement* m_void_elements;\n+  int m_void_element_count;\n \n-    long ParseTrackEntry(\n-        long long payload_start,\n-        long long payload_size,\n-        long long element_start,\n-        long long element_size,\n-        Track*&) const;\n-\n-};\n-\n-\n-class Chapters\n-{\n-    Chapters(const Chapters&);\n-    Chapters& operator=(const Chapters&);\n-\n-public:\n-    Segment* const m_pSegment;\n-    const long long m_start;\n-    const long long m_size;\n-    const long long m_element_start;\n-    const long long m_element_size;\n-\n-    Chapters(\n-        Segment*,\n-        long long payload_start,\n-        long long payload_size,\n-        long long element_start,\n-        long long element_size);\n-\n-    ~Chapters();\n-\n-    long Parse();\n-\n-    class Atom;\n-    class Edition;\n-\n-    class Display\n-    {\n-        friend class Atom;\n-        Display();\n-        Display(const Display&);\n-        ~Display();\n-        Display& operator=(const Display&);\n-    public:\n-        const char* GetString() const;\n-        const char* GetLanguage() const;\n-        const char* GetCountry() const;\n-    private:\n-        void Init();\n-        void ShallowCopy(Display&) const;\n-        void Clear();\n-        long Parse(IMkvReader*, long long pos, long long size);\n-\n-        char* m_string;\n-        char* m_language;\n-        char* m_country;\n-    };\n-\n-    class Atom\n-    {\n-        friend class Edition;\n-        Atom();\n-        Atom(const Atom&);\n-        ~Atom();\n-        Atom& operator=(const Atom&);\n-    public:\n-        unsigned long long GetUID() const;\n-        const char* GetStringUID() const;\n-\n-        long long GetStartTimecode() const;\n-        long long GetStopTimecode() const;\n-\n-        long long GetStartTime(const Chapters*) const;\n-        long long GetStopTime(const Chapters*) const;\n-\n-        int GetDisplayCount() const;\n-        const Display* GetDisplay(int index) const;\n-    private:\n-        void Init();\n-        void ShallowCopy(Atom&) const;\n-        void Clear();\n-        long Parse(IMkvReader*, long long pos, long long size);\n-        static long long GetTime(const Chapters*, long long timecode);\n-\n-        long ParseDisplay(IMkvReader*, long long pos, long long size);\n-        bool ExpandDisplaysArray();\n-\n-        char* m_string_uid;\n-        unsigned long long m_uid;\n-        long long m_start_timecode;\n-        long long m_stop_timecode;\n-\n-        Display* m_displays;\n-        int m_displays_size;\n-        int m_displays_count;\n-    };\n-\n-    class Edition\n-    {\n-        friend class Chapters;\n-        Edition();\n-        Edition(const Edition&);\n-        ~Edition();\n-        Edition& operator=(const Edition&);\n-    public:\n-        int GetAtomCount() const;\n-        const Atom* GetAtom(int index) const;\n-    private:\n-        void Init();\n-        void ShallowCopy(Edition&) const;\n-        void Clear();\n-        long Parse(IMkvReader*, long long pos, long long size);\n-\n-        long ParseAtom(IMkvReader*, long long pos, long long size);\n-        bool ExpandAtomsArray();\n-\n-        Atom* m_atoms;\n-        int m_atoms_size;\n-        int m_atoms_count;\n-    };\n-\n-    int GetEditionCount() const;\n-    const Edition* GetEdition(int index) const;\n-\n-private:\n-    long ParseEdition(long long pos, long long size);\n-    bool ExpandEditionsArray();\n-\n-    Edition* m_editions;\n-    int m_editions_size;\n-    int m_editions_count;\n-\n-};\n-\n-\n-class SegmentInfo\n-{\n-    SegmentInfo(const SegmentInfo&);\n-    SegmentInfo& operator=(const SegmentInfo&);\n-\n-public:\n-    Segment* const m_pSegment;\n-    const long long m_start;\n-    const long long m_size;\n-    const long long m_element_start;\n-    const long long m_element_size;\n-\n-    SegmentInfo(\n-        Segment*,\n-        long long start,\n-        long long size,\n-        long long element_start,\n-        long long element_size);\n-\n-    ~SegmentInfo();\n-\n-    long Parse();\n-\n-    long long GetTimeCodeScale() const;\n-    long long GetDuration() const;  //scaled\n-    const char* GetMuxingAppAsUTF8() const;\n-    const char* GetWritingAppAsUTF8() const;\n-    const char* GetTitleAsUTF8() const;\n-\n-private:\n-    long long m_timecodeScale;\n-    double m_duration;\n-    char* m_pMuxingAppAsUTF8;\n-    char* m_pWritingAppAsUTF8;\n-    char* m_pTitleAsUTF8;\n-};\n-\n-\n-class SeekHead\n-{\n-    SeekHead(const SeekHead&);\n-    SeekHead& operator=(const SeekHead&);\n-\n-public:\n-    Segment* const m_pSegment;\n-    const long long m_start;\n-    const long long m_size;\n-    const long long m_element_start;\n-    const long long m_element_size;\n-\n-    SeekHead(\n-        Segment*,\n-        long long start,\n-        long long size,\n-        long long element_start,\n-        long long element_size);\n-\n-    ~SeekHead();\n-\n-    long Parse();\n-\n-    struct Entry\n-    {\n-        //the SeekHead entry payload\n-        long long id;\n-        long long pos;\n-\n-        //absolute pos of SeekEntry ID\n-        long long element_start;\n-\n-        //SeekEntry ID size + size size + payload\n-        long long element_size;\n-    };\n-\n-    int GetCount() const;\n-    const Entry* GetEntry(int idx) const;\n-\n-    struct VoidElement\n-    {\n-        //absolute pos of Void ID\n-        long long element_start;\n-\n-        //ID size + size size + payload size\n-        long long element_size;\n-    };\n-\n-    int GetVoidElementCount() const;\n-    const VoidElement* GetVoidElement(int idx) const;\n-\n-private:\n-    Entry* m_entries;\n-    int m_entry_count;\n-\n-    VoidElement* m_void_elements;\n-    int m_void_element_count;\n-\n-    static bool ParseEntry(\n-        IMkvReader*,\n-        long long pos,  //payload\n-        long long size,\n-        Entry*);\n-\n+  static bool ParseEntry(IMkvReader*,\n+                         long long pos,  // payload\n+                         long long size, Entry*);\n };\n \n class Cues;\n-class CuePoint\n-{\n-    friend class Cues;\n+class CuePoint {\n+  friend class Cues;\n \n-    CuePoint(long, long long);\n-    ~CuePoint();\n+  CuePoint(long, long long);\n+  ~CuePoint();\n \n-    CuePoint(const CuePoint&);\n-    CuePoint& operator=(const CuePoint&);\n+  CuePoint(const CuePoint&);\n+  CuePoint& operator=(const CuePoint&);\n \n-public:\n-    long long m_element_start;\n-    long long m_element_size;\n+ public:\n+  long long m_element_start;\n+  long long m_element_size;\n \n-    void Load(IMkvReader*);\n+  void Load(IMkvReader*);\n \n-    long long GetTimeCode() const;      //absolute but unscaled\n-    long long GetTime(const Segment*) const;  //absolute and scaled (ns units)\n+  long long GetTimeCode() const;  // absolute but unscaled\n+  long long GetTime(const Segment*) const;  // absolute and scaled (ns units)\n \n-    struct TrackPosition\n-    {\n-        long long m_track;\n-        long long m_pos;  //of cluster\n-        long long m_block;\n-        //codec_state  //defaults to 0\n-        //reference = clusters containing req'd referenced blocks\n-        //  reftime = timecode of the referenced block\n+  struct TrackPosition {\n+    long long m_track;\n+    long long m_pos;  // of cluster\n+    long long m_block;\n+    // codec_state  //defaults to 0\n+    // reference = clusters containing req'd referenced blocks\n+    //  reftime = timecode of the referenced block\n \n-        void Parse(IMkvReader*, long long, long long);\n-    };\n+    void Parse(IMkvReader*, long long, long long);\n+  };\n \n-    const TrackPosition* Find(const Track*) const;\n+  const TrackPosition* Find(const Track*) const;\n \n-private:\n-    const long m_index;\n-    long long m_timecode;\n-    TrackPosition* m_track_positions;\n-    size_t m_track_positions_count;\n-\n+ private:\n+  const long m_index;\n+  long long m_timecode;\n+  TrackPosition* m_track_positions;\n+  size_t m_track_positions_count;\n };\n \n+class Cues {\n+  friend class Segment;\n \n-class Cues\n-{\n-    friend class Segment;\n+  Cues(Segment*, long long start, long long size, long long element_start,\n+       long long element_size);\n+  ~Cues();\n \n-    Cues(\n-        Segment*,\n-        long long start,\n-        long long size,\n-        long long element_start,\n-        long long element_size);\n-    ~Cues();\n+  Cues(const Cues&);\n+  Cues& operator=(const Cues&);\n \n-    Cues(const Cues&);\n-    Cues& operator=(const Cues&);\n+ public:\n+  Segment* const m_pSegment;\n+  const long long m_start;\n+  const long long m_size;\n+  const long long m_element_start;\n+  const long long m_element_size;\n \n-public:\n-    Segment* const m_pSegment;\n-    const long long m_start;\n-    const long long m_size;\n-    const long long m_element_start;\n-    const long long m_element_size;\n-\n-    bool Find(  //lower bound of time_ns\n-        long long time_ns,\n-        const Track*,\n-        const CuePoint*&,\n-        const CuePoint::TrackPosition*&) const;\n+  bool Find(  // lower bound of time_ns\n+      long long time_ns, const Track*, const CuePoint*&,\n+      const CuePoint::TrackPosition*&) const;\n \n #if 0\n     bool FindNext(  //upper_bound of time_ns\n@@ -844,165 +738,144 @@\n\n         const CuePoint::TrackPosition*&) const;\n #endif\n \n-    const CuePoint* GetFirst() const;\n-    const CuePoint* GetLast() const;\n-    const CuePoint* GetNext(const CuePoint*) const;\n+  const CuePoint* GetFirst() const;\n+  const CuePoint* GetLast() const;\n+  const CuePoint* GetNext(const CuePoint*) const;\n \n-    const BlockEntry* GetBlock(\n-                        const CuePoint*,\n-                        const CuePoint::TrackPosition*) const;\n+  const BlockEntry* GetBlock(const CuePoint*,\n+                             const CuePoint::TrackPosition*) const;\n \n-    bool LoadCuePoint() const;\n-    long GetCount() const;  //loaded only\n-    //long GetTotal() const;  //loaded + preloaded\n-    bool DoneParsing() const;\n+  bool LoadCuePoint() const;\n+  long GetCount() const;  // loaded only\n+  // long GetTotal() const;  //loaded + preloaded\n+  bool DoneParsing() const;\n \n-private:\n-    void Init() const;\n-    void PreloadCuePoint(long&, long long) const;\n+ private:\n+  void Init() const;\n+  void PreloadCuePoint(long&, long long) const;\n \n-    mutable CuePoint** m_cue_points;\n-    mutable long m_count;\n-    mutable long m_preload_count;\n-    mutable long long m_pos;\n-\n+  mutable CuePoint** m_cue_points;\n+  mutable long m_count;\n+  mutable long m_preload_count;\n+  mutable long long m_pos;\n };\n \n+class Cluster {\n+  friend class Segment;\n \n-class Cluster\n-{\n-    friend class Segment;\n+  Cluster(const Cluster&);\n+  Cluster& operator=(const Cluster&);\n \n-    Cluster(const Cluster&);\n-    Cluster& operator=(const Cluster&);\n+ public:\n+  Segment* const m_pSegment;\n \n-public:\n-    Segment* const m_pSegment;\n+ public:\n+  static Cluster* Create(Segment*,\n+                         long index,  // index in segment\n+                         long long off);  // offset relative to segment\n+  // long long element_size);\n \n-public:\n-    static Cluster* Create(\n-        Segment*,\n-        long index,       //index in segment\n-        long long off);   //offset relative to segment\n-        //long long element_size);\n+  Cluster();  // EndOfStream\n+  ~Cluster();\n \n-    Cluster();  //EndOfStream\n-    ~Cluster();\n+  bool EOS() const;\n \n-    bool EOS() const;\n+  long long GetTimeCode() const;  // absolute, but not scaled\n+  long long GetTime() const;  // absolute, and scaled (nanosecond units)\n+  long long GetFirstTime() const;  // time (ns) of first (earliest) block\n+  long long GetLastTime() const;  // time (ns) of last (latest) block\n \n-    long long GetTimeCode() const;   //absolute, but not scaled\n-    long long GetTime() const;       //absolute, and scaled (nanosecond units)\n-    long long GetFirstTime() const;  //time (ns) of first (earliest) block\n-    long long GetLastTime() const;   //time (ns) of last (latest) block\n+  long GetFirst(const BlockEntry*&) const;\n+  long GetLast(const BlockEntry*&) const;\n+  long GetNext(const BlockEntry* curr, const BlockEntry*& next) const;\n \n-    long GetFirst(const BlockEntry*&) const;\n-    long GetLast(const BlockEntry*&) const;\n-    long GetNext(const BlockEntry* curr, const BlockEntry*& next) const;\n+  const BlockEntry* GetEntry(const Track*, long long ns = -1) const;\n+  const BlockEntry* GetEntry(const CuePoint&,\n+                             const CuePoint::TrackPosition&) const;\n+  // const BlockEntry* GetMaxKey(const VideoTrack*) const;\n \n-    const BlockEntry* GetEntry(const Track*, long long ns = -1) const;\n-    const BlockEntry* GetEntry(\n-        const CuePoint&,\n-        const CuePoint::TrackPosition&) const;\n-    //const BlockEntry* GetMaxKey(const VideoTrack*) const;\n+  //    static bool HasBlockEntries(const Segment*, long long);\n \n-//    static bool HasBlockEntries(const Segment*, long long);\n+  static long HasBlockEntries(const Segment*, long long idoff, long long& pos,\n+                              long& size);\n \n-    static long HasBlockEntries(\n-            const Segment*,\n-            long long idoff,\n-            long long& pos,\n-            long& size);\n+  long GetEntryCount() const;\n \n-    long GetEntryCount() const;\n+  long Load(long long& pos, long& size) const;\n \n-    long Load(long long& pos, long& size) const;\n+  long Parse(long long& pos, long& size) const;\n+  long GetEntry(long index, const mkvparser::BlockEntry*&) const;\n \n-    long Parse(long long& pos, long& size) const;\n-    long GetEntry(long index, const mkvparser::BlockEntry*&) const;\n+ protected:\n+  Cluster(Segment*, long index, long long element_start);\n+  // long long element_size);\n \n-protected:\n-    Cluster(\n-        Segment*,\n-        long index,\n-        long long element_start);\n-        //long long element_size);\n+ public:\n+  const long long m_element_start;\n+  long long GetPosition() const;  // offset relative to segment\n \n-public:\n-    const long long m_element_start;\n-    long long GetPosition() const;  //offset relative to segment\n+  long GetIndex() const;\n+  long long GetElementSize() const;\n+  // long long GetPayloadSize() const;\n \n-    long GetIndex() const;\n-    long long GetElementSize() const;\n-    //long long GetPayloadSize() const;\n+  // long long Unparsed() const;\n \n-    //long long Unparsed() const;\n+ private:\n+  long m_index;\n+  mutable long long m_pos;\n+  // mutable long long m_size;\n+  mutable long long m_element_size;\n+  mutable long long m_timecode;\n+  mutable BlockEntry** m_entries;\n+  mutable long m_entries_size;\n+  mutable long m_entries_count;\n \n-private:\n-    long m_index;\n-    mutable long long m_pos;\n-    //mutable long long m_size;\n-    mutable long long m_element_size;\n-    mutable long long m_timecode;\n-    mutable BlockEntry** m_entries;\n-    mutable long m_entries_size;\n-    mutable long m_entries_count;\n+  long ParseSimpleBlock(long long, long long&, long&);\n+  long ParseBlockGroup(long long, long long&, long&);\n \n-    long ParseSimpleBlock(long long, long long&, long&);\n-    long ParseBlockGroup(long long, long long&, long&);\n-\n-    long CreateBlock(long long id, long long pos, long long size,\n-                     long long discard_padding);\n-    long CreateBlockGroup(long long start_offset, long long size,\n-                          long long discard_padding);\n-    long CreateSimpleBlock(long long, long long);\n-\n+  long CreateBlock(long long id, long long pos, long long size,\n+                   long long discard_padding);\n+  long CreateBlockGroup(long long start_offset, long long size,\n+                        long long discard_padding);\n+  long CreateSimpleBlock(long long, long long);\n };\n \n+class Segment {\n+  friend class Cues;\n+  friend class Track;\n+  friend class VideoTrack;\n \n-class Segment\n-{\n-    friend class Cues;\n-    friend class Track;\n-    friend class VideoTrack;\n+  Segment(const Segment&);\n+  Segment& operator=(const Segment&);\n \n-    Segment(const Segment&);\n-    Segment& operator=(const Segment&);\n+ private:\n+  Segment(IMkvReader*, long long elem_start,\n+          // long long elem_size,\n+          long long pos, long long size);\n \n-private:\n-    Segment(\n-        IMkvReader*,\n-        long long elem_start,\n-        //long long elem_size,\n-        long long pos,\n-        long long size);\n+ public:\n+  IMkvReader* const m_pReader;\n+  const long long m_element_start;\n+  // const long long m_element_size;\n+  const long long m_start;  // posn of segment payload\n+  const long long m_size;  // size of segment payload\n+  Cluster m_eos;  // TODO: make private?\n \n-public:\n-    IMkvReader* const m_pReader;\n-    const long long m_element_start;\n-    //const long long m_element_size;\n-    const long long m_start;  //posn of segment payload\n-    const long long m_size;   //size of segment payload\n-    Cluster m_eos;  //TODO: make private?\n+  static long long CreateInstance(IMkvReader*, long long, Segment*&);\n+  ~Segment();\n \n-    static long long CreateInstance(IMkvReader*, long long, Segment*&);\n-    ~Segment();\n+  long Load();  // loads headers and all clusters\n \n-    long Load();  //loads headers and all clusters\n+  // for incremental loading\n+  // long long Unparsed() const;\n+  bool DoneParsing() const;\n+  long long ParseHeaders();  // stops when first cluster is found\n+  // long FindNextCluster(long long& pos, long& size) const;\n+  long LoadCluster(long long& pos, long& size);  // load one cluster\n+  long LoadCluster();\n \n-    //for incremental loading\n-    //long long Unparsed() const;\n-    bool DoneParsing() const;\n-    long long ParseHeaders();  //stops when first cluster is found\n-    //long FindNextCluster(long long& pos, long& size) const;\n-    long LoadCluster(long long& pos, long& size);  //load one cluster\n-    long LoadCluster();\n-\n-    long ParseNext(\n-            const Cluster* pCurr,\n-            const Cluster*& pNext,\n-            long long& pos,\n-            long& size);\n+  long ParseNext(const Cluster* pCurr, const Cluster*& pNext, long long& pos,\n+                 long& size);\n \n #if 0\n     //This pair parses one cluster, but only changes the state of the\n@@ -1011,69 +884,62 @@\n\n     bool AddCluster(long long cluster_pos, long long new_pos);\n #endif\n \n-    const SeekHead* GetSeekHead() const;\n-    const Tracks* GetTracks() const;\n-    const SegmentInfo* GetInfo() const;\n-    const Cues* GetCues() const;\n-    const Chapters* GetChapters() const;\n+  const SeekHead* GetSeekHead() const;\n+  const Tracks* GetTracks() const;\n+  const SegmentInfo* GetInfo() const;\n+  const Cues* GetCues() const;\n+  const Chapters* GetChapters() const;\n \n-    long long GetDuration() const;\n+  long long GetDuration() const;\n \n-    unsigned long GetCount() const;\n-    const Cluster* GetFirst() const;\n-    const Cluster* GetLast() const;\n-    const Cluster* GetNext(const Cluster*);\n+  unsigned long GetCount() const;\n+  const Cluster* GetFirst() const;\n+  const Cluster* GetLast() const;\n+  const Cluster* GetNext(const Cluster*);\n \n-    const Cluster* FindCluster(long long time_nanoseconds) const;\n-    //const BlockEntry* Seek(long long time_nanoseconds, const Track*) const;\n+  const Cluster* FindCluster(long long time_nanoseconds) const;\n+  // const BlockEntry* Seek(long long time_nanoseconds, const Track*) const;\n \n-    const Cluster* FindOrPreloadCluster(long long pos);\n+  const Cluster* FindOrPreloadCluster(long long pos);\n \n-    long ParseCues(\n-        long long cues_off,  //offset relative to start of segment\n-        long long& parse_pos,\n-        long& parse_len);\n+  long ParseCues(long long cues_off,  // offset relative to start of segment\n+                 long long& parse_pos, long& parse_len);\n \n-private:\n+ private:\n+  long long m_pos;  // absolute file posn; what has been consumed so far\n+  Cluster* m_pUnknownSize;\n \n-    long long m_pos;  //absolute file posn; what has been consumed so far\n-    Cluster* m_pUnknownSize;\n+  SeekHead* m_pSeekHead;\n+  SegmentInfo* m_pInfo;\n+  Tracks* m_pTracks;\n+  Cues* m_pCues;\n+  Chapters* m_pChapters;\n+  Cluster** m_clusters;\n+  long m_clusterCount;  // number of entries for which m_index >= 0\n+  long m_clusterPreloadCount;  // number of entries for which m_index < 0\n+  long m_clusterSize;  // array size\n \n-    SeekHead* m_pSeekHead;\n-    SegmentInfo* m_pInfo;\n-    Tracks* m_pTracks;\n-    Cues* m_pCues;\n-    Chapters* m_pChapters;\n-    Cluster** m_clusters;\n-    long m_clusterCount;         //number of entries for which m_index >= 0\n-    long m_clusterPreloadCount;  //number of entries for which m_index < 0\n-    long m_clusterSize;          //array size\n+  long DoLoadCluster(long long&, long&);\n+  long DoLoadClusterUnknownSize(long long&, long&);\n+  long DoParseNext(const Cluster*&, long long&, long&);\n \n-    long DoLoadCluster(long long&, long&);\n-    long DoLoadClusterUnknownSize(long long&, long&);\n-    long DoParseNext(const Cluster*&, long long&, long&);\n+  void AppendCluster(Cluster*);\n+  void PreloadCluster(Cluster*, ptrdiff_t);\n \n-    void AppendCluster(Cluster*);\n-    void PreloadCluster(Cluster*, ptrdiff_t);\n+  // void ParseSeekHead(long long pos, long long size);\n+  // void ParseSeekEntry(long long pos, long long size);\n+  // void ParseCues(long long);\n \n-    //void ParseSeekHead(long long pos, long long size);\n-    //void ParseSeekEntry(long long pos, long long size);\n-    //void ParseCues(long long);\n-\n-    const BlockEntry* GetBlock(\n-        const CuePoint&,\n-        const CuePoint::TrackPosition&);\n-\n+  const BlockEntry* GetBlock(const CuePoint&, const CuePoint::TrackPosition&);\n };\n \n-}  //end namespace mkvparser\n+}  // end namespace mkvparser\n \n-inline long mkvparser::Segment::LoadCluster()\n-{\n-    long long pos;\n-    long size;\n+inline long mkvparser::Segment::LoadCluster() {\n+  long long pos;\n+  long size;\n \n-    return LoadCluster(pos, size);\n+  return LoadCluster(pos, size);\n }\n \n-#endif  //MKVPARSER_HPP\n+#endif  // MKVPARSER_HPP\n""}",{/~/    return m_prev;/~/},"1,2,3","long long BlockGroup::GetPrevTimeCode() const
","long long BlockGroup::GetPrevTimeCode() const
{
    return m_prev;
}
",188373.0,C,,"{
    return m_prev;
}
",,"@@ -12,1380 +12,1208 @@

 #include <new>
 #include <climits>
 
-mkvparser::IMkvReader::~IMkvReader()
-{
+#ifdef _MSC_VER
+// Disable MSVC warnings that suggest making code non-portable.
+#pragma warning(disable : 4996)
+#endif
+
+mkvparser::IMkvReader::~IMkvReader() {}
+
+void mkvparser::GetVersion(int& major, int& minor, int& build, int& revision) {
+  major = 1;
+  minor = 0;
+  build = 0;
+  revision = 28;
 }
 
-void mkvparser::GetVersion(int& major, int& minor, int& build, int& revision)
-{
-    major = 1;
-    minor = 0;
-    build = 0;
-    revision = 27;
-}
+long long mkvparser::ReadUInt(IMkvReader* pReader, long long pos, long& len) {
+  assert(pReader);
+  assert(pos >= 0);
 
-long long mkvparser::ReadUInt(IMkvReader* pReader, long long pos, long& len)
-{
-    assert(pReader);
-    assert(pos >= 0);
+  int status;
 
-    int status;
+  //#ifdef _DEBUG
+  //    long long total, available;
+  //    status = pReader->Length(&total, &available);
+  //    assert(status >= 0);
+  //    assert((total < 0) || (available <= total));
+  //    assert(pos < available);
+  //    assert((available - pos) >= 1);  //assume here max u-int len is 8
+  //#endif
 
-//#ifdef _DEBUG
-//    long long total, available;
-//    status = pReader->Length(&total, &available);
-//    assert(status >= 0);
-//    assert((total < 0) || (available <= total));
-//    assert(pos < available);
-//    assert((available - pos) >= 1);  //assume here max u-int len is 8
-//#endif
+  len = 1;
 
-    len = 1;
+  unsigned char b;
 
-    unsigned char b;
+  status = pReader->Read(pos, 1, &b);
 
+  if (status < 0)  // error or underflow
+    return status;
+
+  if (status > 0)  // interpreted as ""underflow""
+    return E_BUFFER_NOT_FULL;
+
+  if (b == 0)  // we can't handle u-int values larger than 8 bytes
+    return E_FILE_FORMAT_INVALID;
+
+  unsigned char m = 0x80;
+
+  while (!(b & m)) {
+    m >>= 1;
+    ++len;
+  }
+
+  //#ifdef _DEBUG
+  //    assert((available - pos) >= len);
+  //#endif
+
+  long long result = b & (~m);
+  ++pos;
+
+  for (int i = 1; i < len; ++i) {
     status = pReader->Read(pos, 1, &b);
 
-    if (status < 0)  //error or underflow
-        return status;
-
-    if (status > 0)  //interpreted as ""underflow""
-        return E_BUFFER_NOT_FULL;
-
-    if (b == 0)  //we can't handle u-int values larger than 8 bytes
-        return E_FILE_FORMAT_INVALID;
-
-    unsigned char m = 0x80;
-
-    while (!(b & m))
-    {
-        m >>= 1;
-        ++len;
+    if (status < 0) {
+      len = 1;
+      return status;
     }
 
-//#ifdef _DEBUG
-//    assert((available - pos) >= len);
-//#endif
+    if (status > 0) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
+    }
 
-    long long result = b & (~m);
+    result <<= 8;
+    result |= b;
+
     ++pos;
+  }
 
-    for (int i = 1; i < len; ++i)
-    {
-        status = pReader->Read(pos, 1, &b);
-
-        if (status < 0)
-        {
-            len = 1;
-            return status;
-        }
-
-        if (status > 0)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
-
-        result <<= 8;
-        result |= b;
-
-        ++pos;
-    }
-
-    return result;
+  return result;
 }
 
-long long mkvparser::GetUIntLength(
-    IMkvReader* pReader,
-    long long pos,
-    long& len)
-{
-    assert(pReader);
-    assert(pos >= 0);
+long long mkvparser::GetUIntLength(IMkvReader* pReader, long long pos,
+                                   long& len) {
+  assert(pReader);
+  assert(pos >= 0);
 
-    long long total, available;
+  long long total, available;
 
-    int status = pReader->Length(&total, &available);
-    assert(status >= 0);
-    assert((total < 0) || (available <= total));
+  int status = pReader->Length(&total, &available);
+  assert(status >= 0);
+  assert((total < 0) || (available <= total));
 
-    len = 1;
+  len = 1;
 
-    if (pos >= available)
-        return pos;  //too few bytes available
+  if (pos >= available)
+    return pos;  // too few bytes available
 
+  unsigned char b;
+
+  status = pReader->Read(pos, 1, &b);
+
+  if (status < 0)
+    return status;
+
+  assert(status == 0);
+
+  if (b == 0)  // we can't handle u-int values larger than 8 bytes
+    return E_FILE_FORMAT_INVALID;
+
+  unsigned char m = 0x80;
+
+  while (!(b & m)) {
+    m >>= 1;
+    ++len;
+  }
+
+  return 0;  // success
+}
+
+// TODO(vigneshv): This function assumes that unsigned values never have their
+// high bit set.
+long long mkvparser::UnserializeUInt(IMkvReader* pReader, long long pos,
+                                     long long size) {
+  assert(pReader);
+  assert(pos >= 0);
+
+  if ((size <= 0) || (size > 8))
+    return E_FILE_FORMAT_INVALID;
+
+  long long result = 0;
+
+  for (long long i = 0; i < size; ++i) {
     unsigned char b;
 
-    status = pReader->Read(pos, 1, &b);
+    const long status = pReader->Read(pos, 1, &b);
 
     if (status < 0)
-        return status;
+      return status;
 
-    assert(status == 0);
+    result <<= 8;
+    result |= b;
 
-    if (b == 0)  //we can't handle u-int values larger than 8 bytes
-        return E_FILE_FORMAT_INVALID;
+    ++pos;
+  }
 
-    unsigned char m = 0x80;
-
-    while (!(b & m))
-    {
-        m >>= 1;
-        ++len;
-    }
-
-    return 0;  //success
+  return result;
 }
 
+long mkvparser::UnserializeFloat(IMkvReader* pReader, long long pos,
+                                 long long size_, double& result) {
+  assert(pReader);
+  assert(pos >= 0);
 
-long long mkvparser::UnserializeUInt(
-    IMkvReader* pReader,
-    long long pos,
-    long long size)
-{
-    assert(pReader);
-    assert(pos >= 0);
+  if ((size_ != 4) && (size_ != 8))
+    return E_FILE_FORMAT_INVALID;
 
-    if ((size <= 0) || (size > 8))
-        return E_FILE_FORMAT_INVALID;
+  const long size = static_cast<long>(size_);
 
-    long long result = 0;
+  unsigned char buf[8];
 
-    for (long long i = 0; i < size; ++i)
-    {
-        unsigned char b;
+  const int status = pReader->Read(pos, size, buf);
 
-        const long status = pReader->Read(pos, 1, &b);
+  if (status < 0)  // error
+    return status;
 
-        if (status < 0)
-            return status;
+  if (size == 4) {
+    union {
+      float f;
+      unsigned long ff;
+    };
 
-        result <<= 8;
-        result |= b;
+    ff = 0;
 
-        ++pos;
+    for (int i = 0;;) {
+      ff |= buf[i];
+
+      if (++i >= 4)
+        break;
+
+      ff <<= 8;
     }
 
-    return result;
+    result = f;
+  } else {
+    assert(size == 8);
+
+    union {
+      double d;
+      unsigned long long dd;
+    };
+
+    dd = 0;
+
+    for (int i = 0;;) {
+      dd |= buf[i];
+
+      if (++i >= 8)
+        break;
+
+      dd <<= 8;
+    }
+
+    result = d;
+  }
+
+  return 0;
 }
 
+long mkvparser::UnserializeInt(IMkvReader* pReader, long long pos, long size,
+                               long long& result) {
+  assert(pReader);
+  assert(pos >= 0);
+  assert(size > 0);
+  assert(size <= 8);
 
-long mkvparser::UnserializeFloat(
-    IMkvReader* pReader,
-    long long pos,
-    long long size_,
-    double& result)
-{
-    assert(pReader);
-    assert(pos >= 0);
+  {
+    signed char b;
 
-    if ((size_ != 4) && (size_ != 8))
-        return E_FILE_FORMAT_INVALID;
+    const long status = pReader->Read(pos, 1, (unsigned char*)&b);
 
-    const long size = static_cast<long>(size_);
+    if (status < 0)
+      return status;
 
-    unsigned char buf[8];
+    result = b;
 
-    const int status = pReader->Read(pos, size, buf);
+    ++pos;
+  }
 
-    if (status < 0)  //error
-        return status;
+  for (long i = 1; i < size; ++i) {
+    unsigned char b;
 
-    if (size == 4)
-    {
-        union
-        {
-            float f;
-            unsigned long ff;
-        };
+    const long status = pReader->Read(pos, 1, &b);
 
-        ff = 0;
+    if (status < 0)
+      return status;
 
-        for (int i = 0;;)
-        {
-            ff |= buf[i];
+    result <<= 8;
+    result |= b;
 
-            if (++i >= 4)
-                break;
+    ++pos;
+  }
 
-            ff <<= 8;
-        }
-
-        result = f;
-    }
-    else
-    {
-        assert(size == 8);
-
-        union
-        {
-            double d;
-            unsigned long long dd;
-        };
-
-        dd = 0;
-
-        for (int i = 0;;)
-        {
-            dd |= buf[i];
-
-            if (++i >= 8)
-                break;
-
-            dd <<= 8;
-        }
-
-        result = d;
-    }
-
-    return 0;
+  return 0;  // success
 }
 
+long mkvparser::UnserializeString(IMkvReader* pReader, long long pos,
+                                  long long size_, char*& str) {
+  delete[] str;
+  str = NULL;
 
-long mkvparser::UnserializeInt(
-    IMkvReader* pReader,
-    long long pos,
-    long size,
-    long long& result)
-{
-    assert(pReader);
-    assert(pos >= 0);
-    assert(size > 0);
-    assert(size <= 8);
+  if (size_ >= LONG_MAX)  // we need (size+1) chars
+    return E_FILE_FORMAT_INVALID;
 
-    {
-        signed char b;
+  const long size = static_cast<long>(size_);
 
-        const long status = pReader->Read(pos, 1, (unsigned char*)&b);
+  str = new (std::nothrow) char[size + 1];
 
-        if (status < 0)
-            return status;
+  if (str == NULL)
+    return -1;
 
-        result = b;
+  unsigned char* const buf = reinterpret_cast<unsigned char*>(str);
 
-        ++pos;
-    }
+  const long status = pReader->Read(pos, size, buf);
 
-    for (long i = 1; i < size; ++i)
-    {
-        unsigned char b;
-
-        const long status = pReader->Read(pos, 1, &b);
-
-        if (status < 0)
-            return status;
-
-        result <<= 8;
-        result |= b;
-
-        ++pos;
-    }
-
-    return 0;  //success
-}
-
-
-long mkvparser::UnserializeString(
-    IMkvReader* pReader,
-    long long pos,
-    long long size_,
-    char*& str)
-{
+  if (status) {
     delete[] str;
     str = NULL;
 
-    if (size_ >= LONG_MAX)  //we need (size+1) chars
-        return E_FILE_FORMAT_INVALID;
+    return status;
+  }
 
-    const long size = static_cast<long>(size_);
+  str[size] = '\0';
 
-    str = new (std::nothrow) char[size+1];
-
-    if (str == NULL)
-        return -1;
-
-    unsigned char* const buf = reinterpret_cast<unsigned char*>(str);
-
-    const long status = pReader->Read(pos, size, buf);
-
-    if (status)
-    {
-        delete[] str;
-        str = NULL;
-
-        return status;
-    }
-
-    str[size] = '\0';
-
-    return 0;  //success
+  return 0;  // success
 }
 
+long mkvparser::ParseElementHeader(IMkvReader* pReader, long long& pos,
+                                   long long stop, long long& id,
+                                   long long& size) {
+  if ((stop >= 0) && (pos >= stop))
+    return E_FILE_FORMAT_INVALID;
 
-long mkvparser::ParseElementHeader(
-    IMkvReader* pReader,
-    long long& pos,
-    long long stop,
-    long long& id,
-    long long& size)
-{
-    if ((stop >= 0) && (pos >= stop))
-        return E_FILE_FORMAT_INVALID;
+  long len;
 
-    long len;
+  id = ReadUInt(pReader, pos, len);
 
-    id = ReadUInt(pReader, pos, len);
+  if (id < 0)
+    return E_FILE_FORMAT_INVALID;
 
-    if (id < 0)
-        return E_FILE_FORMAT_INVALID;
+  pos += len;  // consume id
 
-    pos += len;  //consume id
+  if ((stop >= 0) && (pos >= stop))
+    return E_FILE_FORMAT_INVALID;
 
-    if ((stop >= 0) && (pos >= stop))
-        return E_FILE_FORMAT_INVALID;
+  size = ReadUInt(pReader, pos, len);
 
-    size = ReadUInt(pReader, pos, len);
+  if (size < 0)
+    return E_FILE_FORMAT_INVALID;
 
-    if (size < 0)
-        return E_FILE_FORMAT_INVALID;
+  pos += len;  // consume length of size
 
-    pos += len;  //consume length of size
+  // pos now designates payload
 
-    //pos now designates payload
+  if ((stop >= 0) && ((pos + size) > stop))
+    return E_FILE_FORMAT_INVALID;
 
-    if ((stop >= 0) && ((pos + size) > stop))
-        return E_FILE_FORMAT_INVALID;
-
-    return 0;  //success
+  return 0;  // success
 }
 
+bool mkvparser::Match(IMkvReader* pReader, long long& pos, unsigned long id_,
+                      long long& val) {
+  assert(pReader);
+  assert(pos >= 0);
 
-bool mkvparser::Match(
-    IMkvReader* pReader,
-    long long& pos,
-    unsigned long id_,
-    long long& val)
-{
-    assert(pReader);
-    assert(pos >= 0);
+  long long total, available;
 
-    long long total, available;
+  const long status = pReader->Length(&total, &available);
+  assert(status >= 0);
+  assert((total < 0) || (available <= total));
+  if (status < 0)
+    return false;
 
-    const long status = pReader->Length(&total, &available);
-    assert(status >= 0);
-    assert((total < 0) || (available <= total));
-    if (status < 0)
-        return false;
+  long len;
 
-    long len;
+  const long long id = ReadUInt(pReader, pos, len);
+  assert(id >= 0);
+  assert(len > 0);
+  assert(len <= 8);
+  assert((pos + len) <= available);
 
-    const long long id = ReadUInt(pReader, pos, len);
-    assert(id >= 0);
-    assert(len > 0);
-    assert(len <= 8);
-    assert((pos + len) <= available);
+  if ((unsigned long)id != id_)
+    return false;
 
-    if ((unsigned long)id != id_)
-        return false;
+  pos += len;  // consume id
 
-    pos += len;  //consume id
+  const long long size = ReadUInt(pReader, pos, len);
+  assert(size >= 0);
+  assert(size <= 8);
+  assert(len > 0);
+  assert(len <= 8);
+  assert((pos + len) <= available);
 
-    const long long size = ReadUInt(pReader, pos, len);
-    assert(size >= 0);
-    assert(size <= 8);
-    assert(len > 0);
-    assert(len <= 8);
-    assert((pos + len) <= available);
+  pos += len;  // consume length of size of payload
 
-    pos += len;  //consume length of size of payload
+  val = UnserializeUInt(pReader, pos, size);
+  assert(val >= 0);
 
-    val = UnserializeUInt(pReader, pos, size);
-    assert(val >= 0);
+  pos += size;  // consume size of payload
 
-    pos += size;  //consume size of payload
-
-    return true;
+  return true;
 }
 
-bool mkvparser::Match(
-    IMkvReader* pReader,
-    long long& pos,
-    unsigned long id_,
-    unsigned char*& buf,
-    size_t& buflen)
-{
-    assert(pReader);
-    assert(pos >= 0);
+bool mkvparser::Match(IMkvReader* pReader, long long& pos, unsigned long id_,
+                      unsigned char*& buf, size_t& buflen) {
+  assert(pReader);
+  assert(pos >= 0);
 
-    long long total, available;
+  long long total, available;
 
-    long status = pReader->Length(&total, &available);
-    assert(status >= 0);
-    assert((total < 0) || (available <= total));
-    if (status < 0)
-        return false;
+  long status = pReader->Length(&total, &available);
+  assert(status >= 0);
+  assert((total < 0) || (available <= total));
+  if (status < 0)
+    return false;
 
-    long len;
-    const long long id = ReadUInt(pReader, pos, len);
-    assert(id >= 0);
-    assert(len > 0);
-    assert(len <= 8);
-    assert((pos + len) <= available);
+  long len;
+  const long long id = ReadUInt(pReader, pos, len);
+  assert(id >= 0);
+  assert(len > 0);
+  assert(len <= 8);
+  assert((pos + len) <= available);
 
-    if ((unsigned long)id != id_)
-        return false;
+  if ((unsigned long)id != id_)
+    return false;
 
-    pos += len;  //consume id
+  pos += len;  // consume id
 
-    const long long size_ = ReadUInt(pReader, pos, len);
-    assert(size_ >= 0);
-    assert(len > 0);
-    assert(len <= 8);
-    assert((pos + len) <= available);
+  const long long size_ = ReadUInt(pReader, pos, len);
+  assert(size_ >= 0);
+  assert(len > 0);
+  assert(len <= 8);
+  assert((pos + len) <= available);
 
-    pos += len;  //consume length of size of payload
-    assert((pos + size_) <= available);
+  pos += len;  // consume length of size of payload
+  assert((pos + size_) <= available);
 
-    const long buflen_ = static_cast<long>(size_);
+  const long buflen_ = static_cast<long>(size_);
 
-    buf = new (std::nothrow) unsigned char[buflen_];
-    assert(buf);  //TODO
+  buf = new (std::nothrow) unsigned char[buflen_];
+  assert(buf);  // TODO
 
-    status = pReader->Read(pos, buflen_, buf);
-    assert(status == 0);  //TODO
+  status = pReader->Read(pos, buflen_, buf);
+  assert(status == 0);  // TODO
 
-    buflen = buflen_;
+  buflen = buflen_;
 
-    pos += size_;  //consume size of payload
-    return true;
+  pos += size_;  // consume size of payload
+  return true;
 }
 
+namespace mkvparser {
 
-namespace mkvparser
-{
+EBMLHeader::EBMLHeader() : m_docType(NULL) { Init(); }
 
-EBMLHeader::EBMLHeader() :
-    m_docType(NULL)
-{
-    Init();
-}
+EBMLHeader::~EBMLHeader() { delete[] m_docType; }
 
-EBMLHeader::~EBMLHeader()
-{
+void EBMLHeader::Init() {
+  m_version = 1;
+  m_readVersion = 1;
+  m_maxIdLength = 4;
+  m_maxSizeLength = 8;
+
+  if (m_docType) {
     delete[] m_docType;
+    m_docType = NULL;
+  }
+
+  m_docTypeVersion = 1;
+  m_docTypeReadVersion = 1;
 }
 
-void EBMLHeader::Init()
-{
-    m_version = 1;
-    m_readVersion = 1;
-    m_maxIdLength = 4;
-    m_maxSizeLength = 8;
+long long EBMLHeader::Parse(IMkvReader* pReader, long long& pos) {
+  assert(pReader);
 
-    if (m_docType)
-    {
-        delete[] m_docType;
-        m_docType = NULL;
-    }
+  long long total, available;
 
-    m_docTypeVersion = 1;
-    m_docTypeReadVersion = 1;
-}
+  long status = pReader->Length(&total, &available);
 
-long long EBMLHeader::Parse(
-    IMkvReader* pReader,
-    long long& pos)
-{
-    assert(pReader);
+  if (status < 0)  // error
+    return status;
 
-    long long total, available;
+  pos = 0;
+  long long end = (available >= 1024) ? 1024 : available;
 
-    long status = pReader->Length(&total, &available);
+  for (;;) {
+    unsigned char b = 0;
 
-    if (status < 0)  //error
+    while (pos < end) {
+      status = pReader->Read(pos, 1, &b);
+
+      if (status < 0)  // error
         return status;
 
-    pos = 0;
-    long long end = (available >= 1024) ? 1024 : available;
+      if (b == 0x1A)
+        break;
 
-    for (;;)
-    {
-        unsigned char b = 0;
-
-        while (pos < end)
-        {
-            status = pReader->Read(pos, 1, &b);
-
-            if (status < 0)  //error
-                return status;
-
-            if (b == 0x1A)
-                break;
-
-            ++pos;
-        }
-
-        if (b != 0x1A)
-        {
-            if (pos >= 1024)
-                return E_FILE_FORMAT_INVALID;  //don't bother looking anymore
-
-            if ((total >= 0) && ((total - available) < 5))
-                return E_FILE_FORMAT_INVALID;
-
-            return available + 5;  //5 = 4-byte ID + 1st byte of size
-        }
-
-        if ((total >= 0) && ((total - pos) < 5))
-            return E_FILE_FORMAT_INVALID;
-
-        if ((available - pos) < 5)
-            return pos + 5;  //try again later
-
-        long len;
-
-        const long long result = ReadUInt(pReader, pos, len);
-
-        if (result < 0)  //error
-            return result;
-
-        if (result == 0x0A45DFA3)  //EBML Header ID
-        {
-            pos += len;  //consume ID
-            break;
-        }
-
-        ++pos;  //throw away just the 0x1A byte, and try again
+      ++pos;
     }
 
-    //pos designates start of size field
+    if (b != 0x1A) {
+      if (pos >= 1024)
+        return E_FILE_FORMAT_INVALID;  // don't bother looking anymore
 
-    //get length of size field
+      if ((total >= 0) && ((total - available) < 5))
+        return E_FILE_FORMAT_INVALID;
 
+      return available + 5;  // 5 = 4-byte ID + 1st byte of size
+    }
+
+    if ((total >= 0) && ((total - pos) < 5))
+      return E_FILE_FORMAT_INVALID;
+
+    if ((available - pos) < 5)
+      return pos + 5;  // try again later
+
+    long len;
+
+    const long long result = ReadUInt(pReader, pos, len);
+
+    if (result < 0)  // error
+      return result;
+
+    if (result == 0x0A45DFA3) {  // EBML Header ID
+      pos += len;  // consume ID
+      break;
+    }
+
+    ++pos;  // throw away just the 0x1A byte, and try again
+  }
+
+  // pos designates start of size field
+
+  // get length of size field
+
+  long len;
+  long long result = GetUIntLength(pReader, pos, len);
+
+  if (result < 0)  // error
+    return result;
+
+  if (result > 0)  // need more data
+    return result;
+
+  assert(len > 0);
+  assert(len <= 8);
+
+  if ((total >= 0) && ((total - pos) < len))
+    return E_FILE_FORMAT_INVALID;
+
+  if ((available - pos) < len)
+    return pos + len;  // try again later
+
+  // get the EBML header size
+
+  result = ReadUInt(pReader, pos, len);
+
+  if (result < 0)  // error
+    return result;
+
+  pos += len;  // consume size field
+
+  // pos now designates start of payload
+
+  if ((total >= 0) && ((total - pos) < result))
+    return E_FILE_FORMAT_INVALID;
+
+  if ((available - pos) < result)
+    return pos + result;
+
+  end = pos + result;
+
+  Init();
+
+  while (pos < end) {
+    long long id, size;
+
+    status = ParseElementHeader(pReader, pos, end, id, size);
+
+    if (status < 0)  // error
+      return status;
+
+    if (size == 0)  // weird
+      return E_FILE_FORMAT_INVALID;
+
+    if (id == 0x0286) {  // version
+      m_version = UnserializeUInt(pReader, pos, size);
+
+      if (m_version <= 0)
+        return E_FILE_FORMAT_INVALID;
+    } else if (id == 0x02F7) {  // read version
+      m_readVersion = UnserializeUInt(pReader, pos, size);
+
+      if (m_readVersion <= 0)
+        return E_FILE_FORMAT_INVALID;
+    } else if (id == 0x02F2) {  // max id length
+      m_maxIdLength = UnserializeUInt(pReader, pos, size);
+
+      if (m_maxIdLength <= 0)
+        return E_FILE_FORMAT_INVALID;
+    } else if (id == 0x02F3) {  // max size length
+      m_maxSizeLength = UnserializeUInt(pReader, pos, size);
+
+      if (m_maxSizeLength <= 0)
+        return E_FILE_FORMAT_INVALID;
+    } else if (id == 0x0282) {  // doctype
+      if (m_docType)
+        return E_FILE_FORMAT_INVALID;
+
+      status = UnserializeString(pReader, pos, size, m_docType);
+
+      if (status)  // error
+        return status;
+    } else if (id == 0x0287) {  // doctype version
+      m_docTypeVersion = UnserializeUInt(pReader, pos, size);
+
+      if (m_docTypeVersion <= 0)
+        return E_FILE_FORMAT_INVALID;
+    } else if (id == 0x0285) {  // doctype read version
+      m_docTypeReadVersion = UnserializeUInt(pReader, pos, size);
+
+      if (m_docTypeReadVersion <= 0)
+        return E_FILE_FORMAT_INVALID;
+    }
+
+    pos += size;
+  }
+
+  assert(pos == end);
+  return 0;
+}
+
+Segment::Segment(IMkvReader* pReader, long long elem_start,
+                 // long long elem_size,
+                 long long start, long long size)
+    : m_pReader(pReader),
+      m_element_start(elem_start),
+      // m_element_size(elem_size),
+      m_start(start),
+      m_size(size),
+      m_pos(start),
+      m_pUnknownSize(0),
+      m_pSeekHead(NULL),
+      m_pInfo(NULL),
+      m_pTracks(NULL),
+      m_pCues(NULL),
+      m_pChapters(NULL),
+      m_clusters(NULL),
+      m_clusterCount(0),
+      m_clusterPreloadCount(0),
+      m_clusterSize(0) {}
+
+Segment::~Segment() {
+  const long count = m_clusterCount + m_clusterPreloadCount;
+
+  Cluster** i = m_clusters;
+  Cluster** j = m_clusters + count;
+
+  while (i != j) {
+    Cluster* const p = *i++;
+    assert(p);
+
+    delete p;
+  }
+
+  delete[] m_clusters;
+
+  delete m_pTracks;
+  delete m_pInfo;
+  delete m_pCues;
+  delete m_pChapters;
+  delete m_pSeekHead;
+}
+
+long long Segment::CreateInstance(IMkvReader* pReader, long long pos,
+                                  Segment*& pSegment) {
+  assert(pReader);
+  assert(pos >= 0);
+
+  pSegment = NULL;
+
+  long long total, available;
+
+  const long status = pReader->Length(&total, &available);
+
+  if (status < 0)  // error
+    return status;
+
+  if (available < 0)
+    return -1;
+
+  if ((total >= 0) && (available > total))
+    return -1;
+
+  // I would assume that in practice this loop would execute
+  // exactly once, but we allow for other elements (e.g. Void)
+  // to immediately follow the EBML header.  This is fine for
+  // the source filter case (since the entire file is available),
+  // but in the splitter case over a network we should probably
+  // just give up early.  We could for example decide only to
+  // execute this loop a maximum of, say, 10 times.
+  // TODO:
+  // There is an implied ""give up early"" by only parsing up
+  // to the available limit.  We do do that, but only if the
+  // total file size is unknown.  We could decide to always
+  // use what's available as our limit (irrespective of whether
+  // we happen to know the total file length).  This would have
+  // as its sense ""parse this much of the file before giving up"",
+  // which a slightly different sense from ""try to parse up to
+  // 10 EMBL elements before giving up"".
+
+  for (;;) {
+    if ((total >= 0) && (pos >= total))
+      return E_FILE_FORMAT_INVALID;
+
+    // Read ID
     long len;
     long long result = GetUIntLength(pReader, pos, len);
 
-    if (result < 0)  //error
-        return result;
+    if (result)  // error, or too few available bytes
+      return result;
 
-    if (result > 0)  //need more data
-        return result;
+    if ((total >= 0) && ((pos + len) > total))
+      return E_FILE_FORMAT_INVALID;
 
-    assert(len > 0);
-    assert(len <= 8);
+    if ((pos + len) > available)
+      return pos + len;
 
-    if ((total >= 0) && ((total -  pos) < len))
-        return E_FILE_FORMAT_INVALID;
+    const long long idpos = pos;
+    const long long id = ReadUInt(pReader, pos, len);
 
-    if ((available - pos) < len)
-        return pos + len;  //try again later
+    if (id < 0)  // error
+      return id;
 
-    //get the EBML header size
+    pos += len;  // consume ID
 
-    result = ReadUInt(pReader, pos, len);
+    // Read Size
 
-    if (result < 0)  //error
-        return result;
+    result = GetUIntLength(pReader, pos, len);
 
-    pos += len;  //consume size field
+    if (result)  // error, or too few available bytes
+      return result;
 
-    //pos now designates start of payload
+    if ((total >= 0) && ((pos + len) > total))
+      return E_FILE_FORMAT_INVALID;
 
-    if ((total >= 0) && ((total - pos) < result))
-        return E_FILE_FORMAT_INVALID;
+    if ((pos + len) > available)
+      return pos + len;
 
-    if ((available - pos) < result)
-        return pos + result;
+    long long size = ReadUInt(pReader, pos, len);
 
-    end = pos + result;
+    if (size < 0)  // error
+      return size;
 
-    Init();
+    pos += len;  // consume length of size of element
 
-    while (pos < end)
-    {
-        long long id, size;
+    // Pos now points to start of payload
 
-        status = ParseElementHeader(
-                    pReader,
-                    pos,
-                    end,
-                    id,
-                    size);
+    // Handle ""unknown size"" for live streaming of webm files.
+    const long long unknown_size = (1LL << (7 * len)) - 1;
 
-        if (status < 0) //error
-            return status;
+    if (id == 0x08538067) {  // Segment ID
+      if (size == unknown_size)
+        size = -1;
 
-        if (size == 0)  //weird
-            return E_FILE_FORMAT_INVALID;
+      else if (total < 0)
+        size = -1;
 
-        if (id == 0x0286)  //version
-        {
-            m_version = UnserializeUInt(pReader, pos, size);
+      else if ((pos + size) > total)
+        size = -1;
 
-            if (m_version <= 0)
-                return E_FILE_FORMAT_INVALID;
-        }
-        else if (id == 0x02F7)  //read version
-        {
-            m_readVersion = UnserializeUInt(pReader, pos, size);
+      pSegment = new (std::nothrow) Segment(pReader, idpos,
+                                            // elem_size
+                                            pos, size);
 
-            if (m_readVersion <= 0)
-                return E_FILE_FORMAT_INVALID;
-        }
-        else if (id == 0x02F2)  //max id length
-        {
-            m_maxIdLength = UnserializeUInt(pReader, pos, size);
+      if (pSegment == 0)
+        return -1;  // generic error
 
-            if (m_maxIdLength <= 0)
-                return E_FILE_FORMAT_INVALID;
-        }
-        else if (id == 0x02F3)  //max size length
-        {
-            m_maxSizeLength = UnserializeUInt(pReader, pos, size);
-
-            if (m_maxSizeLength <= 0)
-                return E_FILE_FORMAT_INVALID;
-        }
-        else if (id == 0x0282)  //doctype
-        {
-            if (m_docType)
-                return E_FILE_FORMAT_INVALID;
-
-            status = UnserializeString(pReader, pos, size, m_docType);
-
-            if (status)  //error
-                return status;
-        }
-        else if (id == 0x0287)  //doctype version
-        {
-            m_docTypeVersion = UnserializeUInt(pReader, pos, size);
-
-            if (m_docTypeVersion <= 0)
-                return E_FILE_FORMAT_INVALID;
-        }
-        else if (id == 0x0285)  //doctype read version
-        {
-            m_docTypeReadVersion = UnserializeUInt(pReader, pos, size);
-
-            if (m_docTypeReadVersion <= 0)
-                return E_FILE_FORMAT_INVALID;
-        }
-
-        pos += size;
+      return 0;  // success
     }
 
-    assert(pos == end);
-    return 0;
+    if (size == unknown_size)
+      return E_FILE_FORMAT_INVALID;
+
+    if ((total >= 0) && ((pos + size) > total))
+      return E_FILE_FORMAT_INVALID;
+
+    if ((pos + size) > available)
+      return pos + size;
+
+    pos += size;  // consume payload
+  }
 }
 
+long long Segment::ParseHeaders() {
+  // Outermost (level 0) segment object has been constructed,
+  // and pos designates start of payload.  We need to find the
+  // inner (level 1) elements.
+  long long total, available;
 
-Segment::Segment(
-    IMkvReader* pReader,
-    long long elem_start,
-    //long long elem_size,
-    long long start,
-    long long size) :
-    m_pReader(pReader),
-    m_element_start(elem_start),
-    //m_element_size(elem_size),
-    m_start(start),
-    m_size(size),
-    m_pos(start),
-    m_pUnknownSize(0),
-    m_pSeekHead(NULL),
-    m_pInfo(NULL),
-    m_pTracks(NULL),
-    m_pCues(NULL),
-    m_pChapters(NULL),
-    m_clusters(NULL),
-    m_clusterCount(0),
-    m_clusterPreloadCount(0),
-    m_clusterSize(0)
-{
-}
+  const int status = m_pReader->Length(&total, &available);
 
+  if (status < 0)  // error
+    return status;
 
-Segment::~Segment()
-{
-    const long count = m_clusterCount + m_clusterPreloadCount;
+  assert((total < 0) || (available <= total));
 
-    Cluster** i = m_clusters;
-    Cluster** j = m_clusters + count;
+  const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
+  assert((segment_stop < 0) || (total < 0) || (segment_stop <= total));
+  assert((segment_stop < 0) || (m_pos <= segment_stop));
 
-    while (i != j)
-    {
-        Cluster* const p = *i++;
-        assert(p);
+  for (;;) {
+    if ((total >= 0) && (m_pos >= total))
+      break;
 
-        delete p;
-    }
+    if ((segment_stop >= 0) && (m_pos >= segment_stop))
+      break;
 
-    delete[] m_clusters;
+    long long pos = m_pos;
+    const long long element_start = pos;
 
-    delete m_pTracks;
-    delete m_pInfo;
-    delete m_pCues;
-    delete m_pChapters;
-    delete m_pSeekHead;
-}
+    if ((pos + 1) > available)
+      return (pos + 1);
 
+    long len;
+    long long result = GetUIntLength(m_pReader, pos, len);
 
-long long Segment::CreateInstance(
-    IMkvReader* pReader,
-    long long pos,
-    Segment*& pSegment)
-{
-    assert(pReader);
-    assert(pos >= 0);
+    if (result < 0)  // error
+      return result;
 
-    pSegment = NULL;
+    if (result > 0)  // underflow (weird)
+      return (pos + 1);
 
-    long long total, available;
+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
+      return E_FILE_FORMAT_INVALID;
 
-    const long status = pReader->Length(&total, &available);
+    if ((pos + len) > available)
+      return pos + len;
 
-    if (status < 0) //error
-        return status;
+    const long long idpos = pos;
+    const long long id = ReadUInt(m_pReader, idpos, len);
 
-    if (available < 0)
+    if (id < 0)  // error
+      return id;
+
+    if (id == 0x0F43B675)  // Cluster ID
+      break;
+
+    pos += len;  // consume ID
+
+    if ((pos + 1) > available)
+      return (pos + 1);
+
+    // Read Size
+    result = GetUIntLength(m_pReader, pos, len);
+
+    if (result < 0)  // error
+      return result;
+
+    if (result > 0)  // underflow (weird)
+      return (pos + 1);
+
+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
+      return E_FILE_FORMAT_INVALID;
+
+    if ((pos + len) > available)
+      return pos + len;
+
+    const long long size = ReadUInt(m_pReader, pos, len);
+
+    if (size < 0)  // error
+      return size;
+
+    pos += len;  // consume length of size of element
+
+    const long long element_size = size + pos - element_start;
+
+    // Pos now points to start of payload
+
+    if ((segment_stop >= 0) && ((pos + size) > segment_stop))
+      return E_FILE_FORMAT_INVALID;
+
+    // We read EBML elements either in total or nothing at all.
+
+    if ((pos + size) > available)
+      return pos + size;
+
+    if (id == 0x0549A966) {  // Segment Info ID
+      if (m_pInfo)
+        return E_FILE_FORMAT_INVALID;
+
+      m_pInfo = new (std::nothrow)
+          SegmentInfo(this, pos, size, element_start, element_size);
+
+      if (m_pInfo == NULL)
         return -1;
 
-    if ((total >= 0) && (available > total))
+      const long status = m_pInfo->Parse();
+
+      if (status)
+        return status;
+    } else if (id == 0x0654AE6B) {  // Tracks ID
+      if (m_pTracks)
+        return E_FILE_FORMAT_INVALID;
+
+      m_pTracks = new (std::nothrow)
+          Tracks(this, pos, size, element_start, element_size);
+
+      if (m_pTracks == NULL)
         return -1;
 
-    //I would assume that in practice this loop would execute
-    //exactly once, but we allow for other elements (e.g. Void)
-    //to immediately follow the EBML header.  This is fine for
-    //the source filter case (since the entire file is available),
-    //but in the splitter case over a network we should probably
-    //just give up early.  We could for example decide only to
-    //execute this loop a maximum of, say, 10 times.
-    //TODO:
-    //There is an implied ""give up early"" by only parsing up
-    //to the available limit.  We do do that, but only if the
-    //total file size is unknown.  We could decide to always
-    //use what's available as our limit (irrespective of whether
-    //we happen to know the total file length).  This would have
-    //as its sense ""parse this much of the file before giving up"",
-    //which a slightly different sense from ""try to parse up to
-    //10 EMBL elements before giving up"".
+      const long status = m_pTracks->Parse();
 
-    for (;;)
-    {
-        if ((total >= 0) && (pos >= total))
-            return E_FILE_FORMAT_INVALID;
-
-        //Read ID
-        long len;
-        long long result = GetUIntLength(pReader, pos, len);
-
-        if (result)  //error, or too few available bytes
-            return result;
-
-        if ((total >= 0) && ((pos + len) > total))
-            return E_FILE_FORMAT_INVALID;
-
-        if ((pos + len) > available)
-            return pos + len;
-
-        const long long idpos = pos;
-        const long long id = ReadUInt(pReader, pos, len);
-
-        if (id < 0)  //error
-            return id;
-
-        pos += len;  //consume ID
-
-        //Read Size
-
-        result = GetUIntLength(pReader, pos, len);
-
-        if (result)  //error, or too few available bytes
-            return result;
-
-        if ((total >= 0) && ((pos + len) > total))
-            return E_FILE_FORMAT_INVALID;
-
-        if ((pos + len) > available)
-            return pos + len;
-
-        long long size = ReadUInt(pReader, pos, len);
-
-        if (size < 0)  //error
-            return size;
-
-        pos += len;  //consume length of size of element
-
-        //Pos now points to start of payload
-
-        //Handle ""unknown size"" for live streaming of webm files.
-        const long long unknown_size = (1LL << (7 * len)) - 1;
-
-        if (id == 0x08538067)  //Segment ID
-        {
-            if (size == unknown_size)
-                size = -1;
-
-            else if (total < 0)
-                size = -1;
-
-            else if ((pos + size) > total)
-                size = -1;
-
-            pSegment = new (std::nothrow) Segment(
-                                            pReader,
-                                            idpos,
-                                            //elem_size
-                                            pos,
-                                            size);
-
-            if (pSegment == 0)
-                return -1;  //generic error
-
-            return 0;    //success
-        }
-
-        if (size == unknown_size)
-            return E_FILE_FORMAT_INVALID;
-
-        if ((total >= 0) && ((pos + size) > total))
-            return E_FILE_FORMAT_INVALID;
-
-        if ((pos + size) > available)
-            return pos + size;
-
-        pos += size;  //consume payload
-    }
-}
-
-
-long long Segment::ParseHeaders()
-{
-    //Outermost (level 0) segment object has been constructed,
-    //and pos designates start of payload.  We need to find the
-    //inner (level 1) elements.
-    long long total, available;
-
-    const int status = m_pReader->Length(&total, &available);
-
-    if (status < 0) //error
+      if (status)
         return status;
+    } else if (id == 0x0C53BB6B) {  // Cues ID
+      if (m_pCues == NULL) {
+        m_pCues = new (std::nothrow)
+            Cues(this, pos, size, element_start, element_size);
 
-    assert((total < 0) || (available <= total));
+        if (m_pCues == NULL)
+          return -1;
+      }
+    } else if (id == 0x014D9B74) {  // SeekHead ID
+      if (m_pSeekHead == NULL) {
+        m_pSeekHead = new (std::nothrow)
+            SeekHead(this, pos, size, element_start, element_size);
 
-    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
-    assert((segment_stop < 0) || (total < 0) || (segment_stop <= total));
-    assert((segment_stop < 0) || (m_pos <= segment_stop));
+        if (m_pSeekHead == NULL)
+          return -1;
 
-    for (;;)
-    {
-        if ((total >= 0) && (m_pos >= total))
-            break;
+        const long status = m_pSeekHead->Parse();
 
-        if ((segment_stop >= 0) && (m_pos >= segment_stop))
-            break;
+        if (status)
+          return status;
+      }
+    } else if (id == 0x0043A770) {  // Chapters ID
+      if (m_pChapters == NULL) {
+        m_pChapters = new (std::nothrow)
+            Chapters(this, pos, size, element_start, element_size);
 
-        long long pos = m_pos;
-        const long long element_start = pos;
+        if (m_pChapters == NULL)
+          return -1;
 
-        if ((pos + 1) > available)
-            return (pos + 1);
+        const long status = m_pChapters->Parse();
 
-        long len;
-        long long result = GetUIntLength(m_pReader, pos, len);
-
-        if (result < 0)  //error
-            return result;
-
-        if (result > 0)  //underflow (weird)
-            return (pos + 1);
-
-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        if ((pos + len) > available)
-            return pos + len;
-
-        const long long idpos = pos;
-        const long long id = ReadUInt(m_pReader, idpos, len);
-
-        if (id < 0)  //error
-            return id;
-
-        if (id == 0x0F43B675)  //Cluster ID
-            break;
-
-        pos += len;  //consume ID
-
-        if ((pos + 1) > available)
-            return (pos + 1);
-
-        //Read Size
-        result = GetUIntLength(m_pReader, pos, len);
-
-        if (result < 0)  //error
-            return result;
-
-        if (result > 0)  //underflow (weird)
-            return (pos + 1);
-
-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        if ((pos + len) > available)
-            return pos + len;
-
-        const long long size = ReadUInt(m_pReader, pos, len);
-
-        if (size < 0)  //error
-            return size;
-
-        pos += len;  //consume length of size of element
-
-        const long long element_size = size + pos - element_start;
-
-        //Pos now points to start of payload
-
-        if ((segment_stop >= 0) && ((pos + size) > segment_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        //We read EBML elements either in total or nothing at all.
-
-        if ((pos + size) > available)
-            return pos + size;
-
-        if (id == 0x0549A966)  //Segment Info ID
-        {
-            if (m_pInfo)
-                return E_FILE_FORMAT_INVALID;
-
-            m_pInfo = new (std::nothrow) SegmentInfo(
-                                          this,
-                                          pos,
-                                          size,
-                                          element_start,
-                                          element_size);
-
-            if (m_pInfo == NULL)
-                return -1;
-
-            const long status = m_pInfo->Parse();
-
-            if (status)
-                return status;
-        }
-        else if (id == 0x0654AE6B)  //Tracks ID
-        {
-            if (m_pTracks)
-                return E_FILE_FORMAT_INVALID;
-
-            m_pTracks = new (std::nothrow) Tracks(this,
-                                                  pos,
-                                                  size,
-                                                  element_start,
-                                                  element_size);
-
-            if (m_pTracks == NULL)
-                return -1;
-
-            const long status = m_pTracks->Parse();
-
-            if (status)
-                return status;
-        }
-        else if (id == 0x0C53BB6B)  //Cues ID
-        {
-            if (m_pCues == NULL)
-            {
-                m_pCues = new (std::nothrow) Cues(
-                                                this,
-                                                pos,
-                                                size,
-                                                element_start,
-                                                element_size);
-
-                if (m_pCues == NULL)
-                    return -1;
-            }
-        }
-        else if (id == 0x014D9B74)  //SeekHead ID
-        {
-            if (m_pSeekHead == NULL)
-            {
-                m_pSeekHead = new (std::nothrow) SeekHead(
-                                                    this,
-                                                    pos,
-                                                    size,
-                                                    element_start,
-                                                    element_size);
-
-                if (m_pSeekHead == NULL)
-                    return -1;
-
-                const long status = m_pSeekHead->Parse();
-
-                if (status)
-                    return status;
-            }
-        }
-        else if (id == 0x0043A770)  //Chapters ID
-        {
-            if (m_pChapters == NULL)
-            {
-                m_pChapters = new (std::nothrow) Chapters(
-                                this,
-                                pos,
-                                size,
-                                element_start,
-                                element_size);
-
-                if (m_pChapters == NULL)
-                  return -1;
-
-                const long status = m_pChapters->Parse();
-
-                if (status)
-                  return status;
-            }
-        }
-
-        m_pos = pos + size;  //consume payload
+        if (status)
+          return status;
+      }
     }
 
-    assert((segment_stop < 0) || (m_pos <= segment_stop));
+    m_pos = pos + size;  // consume payload
+  }
 
-    if (m_pInfo == NULL)  //TODO: liberalize this behavior
-        return E_FILE_FORMAT_INVALID;
+  assert((segment_stop < 0) || (m_pos <= segment_stop));
 
-    if (m_pTracks == NULL)
-        return E_FILE_FORMAT_INVALID;
+  if (m_pInfo == NULL)  // TODO: liberalize this behavior
+    return E_FILE_FORMAT_INVALID;
 
-    return 0;  //success
+  if (m_pTracks == NULL)
+    return E_FILE_FORMAT_INVALID;
+
+  return 0;  // success
 }
 
+long Segment::LoadCluster(long long& pos, long& len) {
+  for (;;) {
+    const long result = DoLoadCluster(pos, len);
 
-long Segment::LoadCluster(
-    long long& pos,
-    long& len)
-{
-    for (;;)
-    {
-        const long result = DoLoadCluster(pos, len);
+    if (result <= 1)
+      return result;
+  }
+}
 
-        if (result <= 1)
-            return result;
+long Segment::DoLoadCluster(long long& pos, long& len) {
+  if (m_pos < 0)
+    return DoLoadClusterUnknownSize(pos, len);
+
+  long long total, avail;
+
+  long status = m_pReader->Length(&total, &avail);
+
+  if (status < 0)  // error
+    return status;
+
+  assert((total < 0) || (avail <= total));
+
+  const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
+
+  long long cluster_off = -1;  // offset relative to start of segment
+  long long cluster_size = -1;  // size of cluster payload
+
+  for (;;) {
+    if ((total >= 0) && (m_pos >= total))
+      return 1;  // no more clusters
+
+    if ((segment_stop >= 0) && (m_pos >= segment_stop))
+      return 1;  // no more clusters
+
+    pos = m_pos;
+
+    // Read ID
+
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
     }
-}
 
+    long long result = GetUIntLength(m_pReader, pos, len);
 
-long Segment::DoLoadCluster(
-    long long& pos,
-    long& len)
-{
-    if (m_pos < 0)
-        return DoLoadClusterUnknownSize(pos, len);
+    if (result < 0)  // error
+      return static_cast<long>(result);
 
-    long long total, avail;
+    if (result > 0)  // weird
+      return E_BUFFER_NOT_FULL;
 
-    long status = m_pReader->Length(&total, &avail);
+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
+      return E_FILE_FORMAT_INVALID;
 
-    if (status < 0)  //error
-        return status;
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
 
-    assert((total < 0) || (avail <= total));
+    const long long idpos = pos;
+    const long long id = ReadUInt(m_pReader, idpos, len);
 
-    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
+    if (id < 0)  // error (or underflow)
+      return static_cast<long>(id);
 
-    long long cluster_off = -1;   //offset relative to start of segment
-    long long cluster_size = -1;  //size of cluster payload
+    pos += len;  // consume ID
 
-    for (;;)
-    {
-        if ((total >= 0) && (m_pos >= total))
-            return 1;  //no more clusters
+    // Read Size
 
-        if ((segment_stop >= 0) && (m_pos >= segment_stop))
-            return 1;  //no more clusters
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
+    }
 
-        pos = m_pos;
+    result = GetUIntLength(m_pReader, pos, len);
 
-        //Read ID
+    if (result < 0)  // error
+      return static_cast<long>(result);
 
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
+    if (result > 0)  // weird
+      return E_BUFFER_NOT_FULL;
 
-        long long result = GetUIntLength(m_pReader, pos, len);
+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
+      return E_FILE_FORMAT_INVALID;
 
-        if (result < 0)  //error
-            return static_cast<long>(result);
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
 
-        if (result > 0)  //weird
-            return E_BUFFER_NOT_FULL;
+    const long long size = ReadUInt(m_pReader, pos, len);
 
-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
-            return E_FILE_FORMAT_INVALID;
+    if (size < 0)  // error
+      return static_cast<long>(size);
 
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
+    pos += len;  // consume length of size of element
 
-        const long long idpos = pos;
-        const long long id = ReadUInt(m_pReader, idpos, len);
+    // pos now points to start of payload
 
-        if (id < 0)  //error (or underflow)
-            return static_cast<long>(id);
+    if (size == 0) {  // weird
+      m_pos = pos;
+      continue;
+    }
 
-        pos += len;  //consume ID
+    const long long unknown_size = (1LL << (7 * len)) - 1;
 
-        //Read Size
-
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
-
-        result = GetUIntLength(m_pReader, pos, len);
-
-        if (result < 0)  //error
-            return static_cast<long>(result);
-
-        if (result > 0)  //weird
-            return E_BUFFER_NOT_FULL;
-
-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
-
-        const long long size = ReadUInt(m_pReader, pos, len);
-
-        if (size < 0)  //error
-            return static_cast<long>(size);
-
-        pos += len;  //consume length of size of element
-
-        //pos now points to start of payload
-
-        if (size == 0)  //weird
-        {
-            m_pos = pos;
-            continue;
-        }
-
-        const long long unknown_size = (1LL << (7 * len)) - 1;
-
-#if 0  //we must handle this to support live webm
+#if 0  // we must handle this to support live webm
         if (size == unknown_size)
             return E_FILE_FORMAT_INVALID;  //TODO: allow this
 #endif
 
-        if ((segment_stop >= 0) &&
-            (size != unknown_size) &&
-            ((pos + size) > segment_stop))
-        {
-            return E_FILE_FORMAT_INVALID;
-        }
+    if ((segment_stop >= 0) && (size != unknown_size) &&
+        ((pos + size) > segment_stop)) {
+      return E_FILE_FORMAT_INVALID;
+    }
 
-#if 0  //commented-out, to support incremental cluster parsing
+#if 0  // commented-out, to support incremental cluster parsing
         len = static_cast<long>(size);
 
         if ((pos + size) > avail)
             return E_BUFFER_NOT_FULL;
 #endif
 
-        if (id == 0x0C53BB6B)  //Cues ID
-        {
-            if (size == unknown_size)
-                return E_FILE_FORMAT_INVALID;  //TODO: liberalize
+    if (id == 0x0C53BB6B) {  // Cues ID
+      if (size == unknown_size)
+        return E_FILE_FORMAT_INVALID;  // TODO: liberalize
 
-            if (m_pCues == NULL)
-            {
-                const long long element_size = (pos - idpos) + size;
+      if (m_pCues == NULL) {
+        const long long element_size = (pos - idpos) + size;
 
-                m_pCues = new Cues(this,
-                                   pos,
-                                   size,
-                                   idpos,
-                                   element_size);
-                assert(m_pCues);  //TODO
-            }
+        m_pCues = new Cues(this, pos, size, idpos, element_size);
+        assert(m_pCues);  // TODO
+      }
 
-            m_pos = pos + size;  //consume payload
-            continue;
-        }
-
-        if (id != 0x0F43B675)  //Cluster ID
-        {
-            if (size == unknown_size)
-                return E_FILE_FORMAT_INVALID;  //TODO: liberalize
-
-            m_pos = pos + size;  //consume payload
-            continue;
-        }
-
-        //We have a cluster.
-
-        cluster_off = idpos - m_start;  //relative pos
-
-        if (size != unknown_size)
-            cluster_size = size;
-
-        break;
+      m_pos = pos + size;  // consume payload
+      continue;
     }
 
-    assert(cluster_off >= 0);  //have cluster
+    if (id != 0x0F43B675) {  // Cluster ID
+      if (size == unknown_size)
+        return E_FILE_FORMAT_INVALID;  // TODO: liberalize
 
-    long long pos_;
-    long len_;
-
-    status = Cluster::HasBlockEntries(this, cluster_off, pos_, len_);
-
-    if (status < 0) //error, or underflow
-    {
-        pos = pos_;
-        len = len_;
-
-        return status;
+      m_pos = pos + size;  // consume payload
+      continue;
     }
 
-    //status == 0 means ""no block entries found""
-    //status > 0 means ""found at least one block entry""
+    // We have a cluster.
 
-    //TODO:
-    //The issue here is that the segment increments its own
-    //pos ptr past the most recent cluster parsed, and then
-    //starts from there to parse the next cluster.  If we
-    //don't know the size of the current cluster, then we
-    //must either parse its payload (as we do below), looking
-    //for the cluster (or cues) ID to terminate the parse.
-    //This isn't really what we want: rather, we really need
-    //a way to create the curr cluster object immediately.
-    //The pity is that cluster::parse can determine its own
-    //boundary, and we largely duplicate that same logic here.
-    //
-    //Maybe we need to get rid of our look-ahead preloading
-    //in source::parse???
-    //
-    //As we're parsing the blocks in the curr cluster
-    //(in cluster::parse), we should have some way to signal
-    //to the segment that we have determined the boundary,
-    //so it can adjust its own segment::m_pos member.
-    //
-    //The problem is that we're asserting in asyncreadinit,
-    //because we adjust the pos down to the curr seek pos,
-    //and the resulting adjusted len is > 2GB.  I'm suspicious
-    //that this is even correct, but even if it is, we can't
-    //be loading that much data in the cache anyway.
+    cluster_off = idpos - m_start;  // relative pos
 
-    const long idx = m_clusterCount;
+    if (size != unknown_size)
+      cluster_size = size;
 
-    if (m_clusterPreloadCount > 0)
-    {
-        assert(idx < m_clusterSize);
+    break;
+  }
 
-        Cluster* const pCluster = m_clusters[idx];
-        assert(pCluster);
-        assert(pCluster->m_index < 0);
+  assert(cluster_off >= 0);  // have cluster
 
-        const long long off = pCluster->GetPosition();
-        assert(off >= 0);
+  long long pos_;
+  long len_;
 
-        if (off == cluster_off)  //preloaded already
-        {
-            if (status == 0)  //no entries found
-                return E_FILE_FORMAT_INVALID;
+  status = Cluster::HasBlockEntries(this, cluster_off, pos_, len_);
 
-            if (cluster_size >= 0)
-                pos += cluster_size;
-            else
-            {
-                const long long element_size = pCluster->GetElementSize();
+  if (status < 0) {  // error, or underflow
+    pos = pos_;
+    len = len_;
 
-                if (element_size <= 0)
-                    return E_FILE_FORMAT_INVALID;  //TODO: handle this case
+    return status;
+  }
 
-                pos = pCluster->m_element_start + element_size;
-            }
+  // status == 0 means ""no block entries found""
+  // status > 0 means ""found at least one block entry""
 
-            pCluster->m_index = idx;  //move from preloaded to loaded
-            ++m_clusterCount;
-            --m_clusterPreloadCount;
+  // TODO:
+  // The issue here is that the segment increments its own
+  // pos ptr past the most recent cluster parsed, and then
+  // starts from there to parse the next cluster.  If we
+  // don't know the size of the current cluster, then we
+  // must either parse its payload (as we do below), looking
+  // for the cluster (or cues) ID to terminate the parse.
+  // This isn't really what we want: rather, we really need
+  // a way to create the curr cluster object immediately.
+  // The pity is that cluster::parse can determine its own
+  // boundary, and we largely duplicate that same logic here.
+  //
+  // Maybe we need to get rid of our look-ahead preloading
+  // in source::parse???
+  //
+  // As we're parsing the blocks in the curr cluster
+  //(in cluster::parse), we should have some way to signal
+  // to the segment that we have determined the boundary,
+  // so it can adjust its own segment::m_pos member.
+  //
+  // The problem is that we're asserting in asyncreadinit,
+  // because we adjust the pos down to the curr seek pos,
+  // and the resulting adjusted len is > 2GB.  I'm suspicious
+  // that this is even correct, but even if it is, we can't
+  // be loading that much data in the cache anyway.
 
-            m_pos = pos;  //consume payload
-            assert((segment_stop < 0) || (m_pos <= segment_stop));
+  const long idx = m_clusterCount;
 
-            return 0;  //success
-        }
-    }
-
-    if (status == 0)  //no entries found
-    {
-        if (cluster_size < 0)
-            return E_FILE_FORMAT_INVALID;  //TODO: handle this
-
-        pos += cluster_size;
-
-        if ((total >= 0) && (pos >= total))
-        {
-            m_pos = total;
-            return 1;  //no more clusters
-        }
-
-        if ((segment_stop >= 0) && (pos >= segment_stop))
-        {
-            m_pos = segment_stop;
-            return 1;  //no more clusters
-        }
-
-        m_pos = pos;
-        return 2;  //try again
-    }
-
-    //status > 0 means we have an entry
-
-    Cluster* const pCluster = Cluster::Create(this,
-                                              idx,
-                                              cluster_off);
-                                              //element_size);
-    assert(pCluster);
-
-    AppendCluster(pCluster);
-    assert(m_clusters);
+  if (m_clusterPreloadCount > 0) {
     assert(idx < m_clusterSize);
-    assert(m_clusters[idx] == pCluster);
 
-    if (cluster_size >= 0)
-    {
+    Cluster* const pCluster = m_clusters[idx];
+    assert(pCluster);
+    assert(pCluster->m_index < 0);
+
+    const long long off = pCluster->GetPosition();
+    assert(off >= 0);
+
+    if (off == cluster_off) {  // preloaded already
+      if (status == 0)  // no entries found
+        return E_FILE_FORMAT_INVALID;
+
+      if (cluster_size >= 0)
         pos += cluster_size;
+      else {
+        const long long element_size = pCluster->GetElementSize();
 
-        m_pos = pos;
-        assert((segment_stop < 0) || (m_pos <= segment_stop));
+        if (element_size <= 0)
+          return E_FILE_FORMAT_INVALID;  // TODO: handle this case
 
-        return 0;
+        pos = pCluster->m_element_start + element_size;
+      }
+
+      pCluster->m_index = idx;  // move from preloaded to loaded
+      ++m_clusterCount;
+      --m_clusterPreloadCount;
+
+      m_pos = pos;  // consume payload
+      assert((segment_stop < 0) || (m_pos <= segment_stop));
+
+      return 0;  // success
+    }
+  }
+
+  if (status == 0) {  // no entries found
+    if (cluster_size < 0)
+      return E_FILE_FORMAT_INVALID;  // TODO: handle this
+
+    pos += cluster_size;
+
+    if ((total >= 0) && (pos >= total)) {
+      m_pos = total;
+      return 1;  // no more clusters
     }
 
-    m_pUnknownSize = pCluster;
-    m_pos = -pos;
+    if ((segment_stop >= 0) && (pos >= segment_stop)) {
+      m_pos = segment_stop;
+      return 1;  // no more clusters
+    }
 
-    return 0;  //partial success, since we have a new cluster
+    m_pos = pos;
+    return 2;  // try again
+  }
 
-    //status == 0 means ""no block entries found""
+  // status > 0 means we have an entry
 
-    //pos designates start of payload
-    //m_pos has NOT been adjusted yet (in case we need to come back here)
+  Cluster* const pCluster = Cluster::Create(this, idx, cluster_off);
+  // element_size);
+  assert(pCluster);
+
+  AppendCluster(pCluster);
+  assert(m_clusters);
+  assert(idx < m_clusterSize);
+  assert(m_clusters[idx] == pCluster);
+
+  if (cluster_size >= 0) {
+    pos += cluster_size;
+
+    m_pos = pos;
+    assert((segment_stop < 0) || (m_pos <= segment_stop));
+
+    return 0;
+  }
+
+  m_pUnknownSize = pCluster;
+  m_pos = -pos;
+
+  return 0;  // partial success, since we have a new cluster
+
+// status == 0 means ""no block entries found""
+
+// pos designates start of payload
+// m_pos has NOT been adjusted yet (in case we need to come back here)
 
 #if 0
 
-    if (cluster_size < 0)  //unknown size
-    {
+    if (cluster_size < 0) {  //unknown size
         const long long payload_pos = pos;  //absolute pos of cluster payload
 
-        for (;;)  //determine cluster size
-        {
+        for (;;) {  //determine cluster size
             if ((total >= 0) && (pos >= total))
                 break;
 
@@ -1518,16 +1346,11 @@

     return 2;     //try to find another cluster
 
 #endif
-
 }
 
-
-long Segment::DoLoadClusterUnknownSize(
-    long long& pos,
-    long& len)
-{
-    assert(m_pos < 0);
-    assert(m_pUnknownSize);
+long Segment::DoLoadClusterUnknownSize(long long& pos, long& len) {
+  assert(m_pos < 0);
+  assert(m_pUnknownSize);
 
 #if 0
     assert(m_pUnknownSize->GetElementSize() < 0);  //TODO: verify this
@@ -1554,8 +1377,7 @@

 
     long long element_size = -1;
 
-    for (;;)  //determine cluster size
-    {
+    for (;;) {  //determine cluster size
         if ((total >= 0) && (pos >= total))
         {
             element_size = total - element_start;
@@ -1604,8 +1426,7 @@

         //that we have exhausted the sub-element's inside the cluster
         //whose ID we parsed earlier.
 
-        if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) //Cluster ID or Cues ID
-        {
+        if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) {  //Cluster ID or Cues ID
             element_size = pos - element_start;
             assert(element_size > 0);
 
@@ -1682,348 +1503,299 @@

 
     return 2;  //continue parsing
 #else
-    const long status = m_pUnknownSize->Parse(pos, len);
+  const long status = m_pUnknownSize->Parse(pos, len);
 
-    if (status < 0)  //error or underflow
-        return status;
+  if (status < 0)  // error or underflow
+    return status;
 
-    if (status == 0)  //parsed a block
-        return 2;     //continue parsing
+  if (status == 0)  // parsed a block
+    return 2;  // continue parsing
 
-    assert(status > 0);   //nothing left to parse of this cluster
+  assert(status > 0);  // nothing left to parse of this cluster
 
-    const long long start = m_pUnknownSize->m_element_start;
+  const long long start = m_pUnknownSize->m_element_start;
 
-    const long long size = m_pUnknownSize->GetElementSize();
-    assert(size >= 0);
+  const long long size = m_pUnknownSize->GetElementSize();
+  assert(size >= 0);
 
-    pos = start + size;
-    m_pos = pos;
+  pos = start + size;
+  m_pos = pos;
 
-    m_pUnknownSize = 0;
+  m_pUnknownSize = 0;
 
-    return 2;  //continue parsing
+  return 2;  // continue parsing
 #endif
 }
 
+void Segment::AppendCluster(Cluster* pCluster) {
+  assert(pCluster);
+  assert(pCluster->m_index >= 0);
 
-void Segment::AppendCluster(Cluster* pCluster)
-{
-    assert(pCluster);
-    assert(pCluster->m_index >= 0);
+  const long count = m_clusterCount + m_clusterPreloadCount;
 
-    const long count = m_clusterCount + m_clusterPreloadCount;
+  long& size = m_clusterSize;
+  assert(size >= count);
 
-    long& size = m_clusterSize;
-    assert(size >= count);
+  const long idx = pCluster->m_index;
+  assert(idx == m_clusterCount);
 
-    const long idx = pCluster->m_index;
-    assert(idx == m_clusterCount);
+  if (count >= size) {
+    const long n = (size <= 0) ? 2048 : 2 * size;
 
-    if (count >= size)
-    {
-        const long n = (size <= 0) ? 2048 : 2*size;
+    Cluster** const qq = new Cluster* [n];
+    Cluster** q = qq;
 
-        Cluster** const qq = new Cluster*[n];
-        Cluster** q = qq;
+    Cluster** p = m_clusters;
+    Cluster** const pp = p + count;
 
-        Cluster** p = m_clusters;
-        Cluster** const pp = p + count;
+    while (p != pp)
+      *q++ = *p++;
 
-        while (p != pp)
-            *q++ = *p++;
+    delete[] m_clusters;
 
-        delete[] m_clusters;
+    m_clusters = qq;
+    size = n;
+  }
 
-        m_clusters = qq;
-        size = n;
-    }
-
-    if (m_clusterPreloadCount > 0)
-    {
-        assert(m_clusters);
-
-        Cluster** const p = m_clusters + m_clusterCount;
-        assert(*p);
-        assert((*p)->m_index < 0);
-
-        Cluster** q = p + m_clusterPreloadCount;
-        assert(q < (m_clusters + size));
-
-        for (;;)
-        {
-            Cluster** const qq = q - 1;
-            assert((*qq)->m_index < 0);
-
-            *q = *qq;
-            q = qq;
-
-            if (q == p)
-                break;
-        }
-    }
-
-    m_clusters[idx] = pCluster;
-    ++m_clusterCount;
-}
-
-
-void Segment::PreloadCluster(Cluster* pCluster, ptrdiff_t idx)
-{
-    assert(pCluster);
-    assert(pCluster->m_index < 0);
-    assert(idx >= m_clusterCount);
-
-    const long count = m_clusterCount + m_clusterPreloadCount;
-
-    long& size = m_clusterSize;
-    assert(size >= count);
-
-    if (count >= size)
-    {
-        const long n = (size <= 0) ? 2048 : 2*size;
-
-        Cluster** const qq = new Cluster*[n];
-        Cluster** q = qq;
-
-        Cluster** p = m_clusters;
-        Cluster** const pp = p + count;
-
-        while (p != pp)
-            *q++ = *p++;
-
-        delete[] m_clusters;
-
-        m_clusters = qq;
-        size = n;
-    }
-
+  if (m_clusterPreloadCount > 0) {
     assert(m_clusters);
 
-    Cluster** const p = m_clusters + idx;
+    Cluster** const p = m_clusters + m_clusterCount;
+    assert(*p);
+    assert((*p)->m_index < 0);
 
-    Cluster** q = m_clusters + count;
-    assert(q >= p);
+    Cluster** q = p + m_clusterPreloadCount;
     assert(q < (m_clusters + size));
 
-    while (q > p)
-    {
-        Cluster** const qq = q - 1;
-        assert((*qq)->m_index < 0);
+    for (;;) {
+      Cluster** const qq = q - 1;
+      assert((*qq)->m_index < 0);
 
-        *q = *qq;
-        q = qq;
+      *q = *qq;
+      q = qq;
+
+      if (q == p)
+        break;
     }
+  }
 
-    m_clusters[idx] = pCluster;
-    ++m_clusterPreloadCount;
+  m_clusters[idx] = pCluster;
+  ++m_clusterCount;
 }
 
+void Segment::PreloadCluster(Cluster* pCluster, ptrdiff_t idx) {
+  assert(pCluster);
+  assert(pCluster->m_index < 0);
+  assert(idx >= m_clusterCount);
 
-long Segment::Load()
-{
-    assert(m_clusters == NULL);
-    assert(m_clusterSize == 0);
-    assert(m_clusterCount == 0);
-    //assert(m_size >= 0);
+  const long count = m_clusterCount + m_clusterPreloadCount;
 
-    //Outermost (level 0) segment object has been constructed,
-    //and pos designates start of payload.  We need to find the
-    //inner (level 1) elements.
+  long& size = m_clusterSize;
+  assert(size >= count);
 
-    const long long header_status = ParseHeaders();
+  if (count >= size) {
+    const long n = (size <= 0) ? 2048 : 2 * size;
 
-    if (header_status < 0)  //error
-        return static_cast<long>(header_status);
+    Cluster** const qq = new Cluster* [n];
+    Cluster** q = qq;
 
-    if (header_status > 0)  //underflow
-        return E_BUFFER_NOT_FULL;
+    Cluster** p = m_clusters;
+    Cluster** const pp = p + count;
 
-    assert(m_pInfo);
-    assert(m_pTracks);
+    while (p != pp)
+      *q++ = *p++;
 
-    for (;;)
-    {
-        const int status = LoadCluster();
+    delete[] m_clusters;
 
-        if (status < 0)  //error
-            return status;
+    m_clusters = qq;
+    size = n;
+  }
 
-        if (status >= 1)  //no more clusters
-            return 0;
-    }
+  assert(m_clusters);
+
+  Cluster** const p = m_clusters + idx;
+
+  Cluster** q = m_clusters + count;
+  assert(q >= p);
+  assert(q < (m_clusters + size));
+
+  while (q > p) {
+    Cluster** const qq = q - 1;
+    assert((*qq)->m_index < 0);
+
+    *q = *qq;
+    q = qq;
+  }
+
+  m_clusters[idx] = pCluster;
+  ++m_clusterPreloadCount;
 }
 
+long Segment::Load() {
+  assert(m_clusters == NULL);
+  assert(m_clusterSize == 0);
+  assert(m_clusterCount == 0);
+  // assert(m_size >= 0);
 
-SeekHead::SeekHead(
-    Segment* pSegment,
-    long long start,
-    long long size_,
-    long long element_start,
-    long long element_size) :
-    m_pSegment(pSegment),
-    m_start(start),
-    m_size(size_),
-    m_element_start(element_start),
-    m_element_size(element_size),
-    m_entries(0),
-    m_entry_count(0),
-    m_void_elements(0),
-    m_void_element_count(0)
-{
+  // Outermost (level 0) segment object has been constructed,
+  // and pos designates start of payload.  We need to find the
+  // inner (level 1) elements.
+
+  const long long header_status = ParseHeaders();
+
+  if (header_status < 0)  // error
+    return static_cast<long>(header_status);
+
+  if (header_status > 0)  // underflow
+    return E_BUFFER_NOT_FULL;
+
+  assert(m_pInfo);
+  assert(m_pTracks);
+
+  for (;;) {
+    const int status = LoadCluster();
+
+    if (status < 0)  // error
+      return status;
+
+    if (status >= 1)  // no more clusters
+      return 0;
+  }
 }
 
+SeekHead::SeekHead(Segment* pSegment, long long start, long long size_,
+                   long long element_start, long long element_size)
+    : m_pSegment(pSegment),
+      m_start(start),
+      m_size(size_),
+      m_element_start(element_start),
+      m_element_size(element_size),
+      m_entries(0),
+      m_entry_count(0),
+      m_void_elements(0),
+      m_void_element_count(0) {}
 
-SeekHead::~SeekHead()
-{
-    delete[] m_entries;
-    delete[] m_void_elements;
+SeekHead::~SeekHead() {
+  delete[] m_entries;
+  delete[] m_void_elements;
 }
 
+long SeekHead::Parse() {
+  IMkvReader* const pReader = m_pSegment->m_pReader;
 
-long SeekHead::Parse()
-{
-    IMkvReader* const pReader = m_pSegment->m_pReader;
+  long long pos = m_start;
+  const long long stop = m_start + m_size;
 
-    long long pos = m_start;
-    const long long stop = m_start + m_size;
+  // first count the seek head entries
 
-    //first count the seek head entries
+  int entry_count = 0;
+  int void_element_count = 0;
 
-    int entry_count = 0;
-    int void_element_count = 0;
+  while (pos < stop) {
+    long long id, size;
 
-    while (pos < stop)
-    {
-        long long id, size;
+    const long status = ParseElementHeader(pReader, pos, stop, id, size);
 
-        const long status = ParseElementHeader(
-                                pReader,
-                                pos,
-                                stop,
-                                id,
-                                size);
+    if (status < 0)  // error
+      return status;
 
-        if (status < 0)  //error
-            return status;
+    if (id == 0x0DBB)  // SeekEntry ID
+      ++entry_count;
+    else if (id == 0x6C)  // Void ID
+      ++void_element_count;
 
-        if (id == 0x0DBB)  //SeekEntry ID
-            ++entry_count;
-        else if (id == 0x6C)  //Void ID
-            ++void_element_count;
+    pos += size;  // consume payload
+    assert(pos <= stop);
+  }
 
-        pos += size;  //consume payload
-        assert(pos <= stop);
+  assert(pos == stop);
+
+  m_entries = new (std::nothrow) Entry[entry_count];
+
+  if (m_entries == NULL)
+    return -1;
+
+  m_void_elements = new (std::nothrow) VoidElement[void_element_count];
+
+  if (m_void_elements == NULL)
+    return -1;
+
+  // now parse the entries and void elements
+
+  Entry* pEntry = m_entries;
+  VoidElement* pVoidElement = m_void_elements;
+
+  pos = m_start;
+
+  while (pos < stop) {
+    const long long idpos = pos;
+
+    long long id, size;
+
+    const long status = ParseElementHeader(pReader, pos, stop, id, size);
+
+    if (status < 0)  // error
+      return status;
+
+    if (id == 0x0DBB) {  // SeekEntry ID
+      if (ParseEntry(pReader, pos, size, pEntry)) {
+        Entry& e = *pEntry++;
+
+        e.element_start = idpos;
+        e.element_size = (pos + size) - idpos;
+      }
+    } else if (id == 0x6C) {  // Void ID
+      VoidElement& e = *pVoidElement++;
+
+      e.element_start = idpos;
+      e.element_size = (pos + size) - idpos;
     }
 
-    assert(pos == stop);
+    pos += size;  // consume payload
+    assert(pos <= stop);
+  }
 
-    m_entries = new (std::nothrow) Entry[entry_count];
+  assert(pos == stop);
 
-    if (m_entries == NULL)
-        return -1;
+  ptrdiff_t count_ = ptrdiff_t(pEntry - m_entries);
+  assert(count_ >= 0);
+  assert(count_ <= entry_count);
 
-    m_void_elements = new (std::nothrow) VoidElement[void_element_count];
+  m_entry_count = static_cast<int>(count_);
 
-    if (m_void_elements == NULL)
-        return -1;
+  count_ = ptrdiff_t(pVoidElement - m_void_elements);
+  assert(count_ >= 0);
+  assert(count_ <= void_element_count);
 
-    //now parse the entries and void elements
+  m_void_element_count = static_cast<int>(count_);
 
-    Entry* pEntry = m_entries;
-    VoidElement* pVoidElement = m_void_elements;
+  return 0;
+}
 
-    pos = m_start;
+int SeekHead::GetCount() const { return m_entry_count; }
 
-    while (pos < stop)
-    {
-        const long long idpos = pos;
-
-        long long id, size;
-
-        const long status = ParseElementHeader(
-                                pReader,
-                                pos,
-                                stop,
-                                id,
-                                size);
-
-        if (status < 0)  //error
-            return status;
-
-        if (id == 0x0DBB)  //SeekEntry ID
-        {
-            if (ParseEntry(pReader, pos, size, pEntry))
-            {
-                Entry& e = *pEntry++;
-
-                e.element_start = idpos;
-                e.element_size = (pos + size) - idpos;
-            }
-        }
-        else if (id == 0x6C)  //Void ID
-        {
-            VoidElement& e = *pVoidElement++;
-
-            e.element_start = idpos;
-            e.element_size = (pos + size) - idpos;
-        }
-
-        pos += size;  //consume payload
-        assert(pos <= stop);
-    }
-
-    assert(pos == stop);
-
-    ptrdiff_t count_ = ptrdiff_t(pEntry - m_entries);
-    assert(count_ >= 0);
-    assert(count_ <= entry_count);
-
-    m_entry_count = static_cast<int>(count_);
-
-    count_ = ptrdiff_t(pVoidElement - m_void_elements);
-    assert(count_ >= 0);
-    assert(count_ <= void_element_count);
-
-    m_void_element_count = static_cast<int>(count_);
-
+const SeekHead::Entry* SeekHead::GetEntry(int idx) const {
+  if (idx < 0)
     return 0;
+
+  if (idx >= m_entry_count)
+    return 0;
+
+  return m_entries + idx;
 }
 
+int SeekHead::GetVoidElementCount() const { return m_void_element_count; }
 
-int SeekHead::GetCount() const
-{
-    return m_entry_count;
+const SeekHead::VoidElement* SeekHead::GetVoidElement(int idx) const {
+  if (idx < 0)
+    return 0;
+
+  if (idx >= m_void_element_count)
+    return 0;
+
+  return m_void_elements + idx;
 }
 
-const SeekHead::Entry* SeekHead::GetEntry(int idx) const
-{
-    if (idx < 0)
-        return 0;
-
-    if (idx >= m_entry_count)
-        return 0;
-
-    return m_entries + idx;
-}
-
-int SeekHead::GetVoidElementCount() const
-{
-    return m_void_element_count;
-}
-
-const SeekHead::VoidElement* SeekHead::GetVoidElement(int idx) const
-{
-    if (idx < 0)
-        return 0;
-
-    if (idx >= m_void_element_count)
-        return 0;
-
-    return m_void_elements + idx;
-}
-
-
 #if 0
 void Segment::ParseCues(long long off)
 {
@@ -2073,133 +1845,122 @@

     //os << ""Segment::ParseCues (end)"" << endl;
 }
 #else
-long Segment::ParseCues(
-    long long off,
-    long long& pos,
-    long& len)
-{
-    if (m_pCues)
-        return 0;  //success
+long Segment::ParseCues(long long off, long long& pos, long& len) {
+  if (m_pCues)
+    return 0;  // success
 
-    if (off < 0)
-        return -1;
+  if (off < 0)
+    return -1;
 
-    long long total, avail;
+  long long total, avail;
 
-    const int status = m_pReader->Length(&total, &avail);
+  const int status = m_pReader->Length(&total, &avail);
 
-    if (status < 0)  //error
-        return status;
+  if (status < 0)  // error
+    return status;
 
-    assert((total < 0) || (avail <= total));
+  assert((total < 0) || (avail <= total));
 
-    pos = m_start + off;
+  pos = m_start + off;
 
-    if ((total < 0) || (pos >= total))
-        return 1;  //don't bother parsing cues
+  if ((total < 0) || (pos >= total))
+    return 1;  // don't bother parsing cues
 
-    const long long element_start = pos;
-    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
+  const long long element_start = pos;
+  const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
 
-    if ((pos + 1) > avail)
-    {
-        len = 1;
-        return E_BUFFER_NOT_FULL;
-    }
+  if ((pos + 1) > avail) {
+    len = 1;
+    return E_BUFFER_NOT_FULL;
+  }
 
-    long long result = GetUIntLength(m_pReader, pos, len);
+  long long result = GetUIntLength(m_pReader, pos, len);
 
-    if (result < 0)  //error
-        return static_cast<long>(result);
+  if (result < 0)  // error
+    return static_cast<long>(result);
 
-    if (result > 0) //underflow (weird)
-    {
-        len = 1;
-        return E_BUFFER_NOT_FULL;
-    }
+  if (result > 0)  // underflow (weird)
+  {
+    len = 1;
+    return E_BUFFER_NOT_FULL;
+  }
 
-    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
-        return E_FILE_FORMAT_INVALID;
+  if ((segment_stop >= 0) && ((pos + len) > segment_stop))
+    return E_FILE_FORMAT_INVALID;
 
-    if ((pos + len) > avail)
-        return E_BUFFER_NOT_FULL;
+  if ((pos + len) > avail)
+    return E_BUFFER_NOT_FULL;
 
-    const long long idpos = pos;
+  const long long idpos = pos;
 
-    const long long id = ReadUInt(m_pReader, idpos, len);
+  const long long id = ReadUInt(m_pReader, idpos, len);
 
-    if (id != 0x0C53BB6B)  //Cues ID
-        return E_FILE_FORMAT_INVALID;
+  if (id != 0x0C53BB6B)  // Cues ID
+    return E_FILE_FORMAT_INVALID;
 
-    pos += len;  //consume ID
-    assert((segment_stop < 0) || (pos <= segment_stop));
+  pos += len;  // consume ID
+  assert((segment_stop < 0) || (pos <= segment_stop));
 
-    //Read Size
+  // Read Size
 
-    if ((pos + 1) > avail)
-    {
-        len = 1;
-        return E_BUFFER_NOT_FULL;
-    }
+  if ((pos + 1) > avail) {
+    len = 1;
+    return E_BUFFER_NOT_FULL;
+  }
 
-    result = GetUIntLength(m_pReader, pos, len);
+  result = GetUIntLength(m_pReader, pos, len);
 
-    if (result < 0)  //error
-        return static_cast<long>(result);
+  if (result < 0)  // error
+    return static_cast<long>(result);
 
-    if (result > 0) //underflow (weird)
-    {
-        len = 1;
-        return E_BUFFER_NOT_FULL;
-    }
+  if (result > 0)  // underflow (weird)
+  {
+    len = 1;
+    return E_BUFFER_NOT_FULL;
+  }
 
-    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
-        return E_FILE_FORMAT_INVALID;
+  if ((segment_stop >= 0) && ((pos + len) > segment_stop))
+    return E_FILE_FORMAT_INVALID;
 
-    if ((pos + len) > avail)
-        return E_BUFFER_NOT_FULL;
+  if ((pos + len) > avail)
+    return E_BUFFER_NOT_FULL;
 
-    const long long size = ReadUInt(m_pReader, pos, len);
+  const long long size = ReadUInt(m_pReader, pos, len);
 
-    if (size < 0)  //error
-        return static_cast<long>(size);
+  if (size < 0)  // error
+    return static_cast<long>(size);
 
-    if (size == 0)  //weird, although technically not illegal
-        return 1;   //done
+  if (size == 0)  // weird, although technically not illegal
+    return 1;  // done
 
-    pos += len;  //consume length of size of element
-    assert((segment_stop < 0) || (pos <= segment_stop));
+  pos += len;  // consume length of size of element
+  assert((segment_stop < 0) || (pos <= segment_stop));
 
-    //Pos now points to start of payload
+  // Pos now points to start of payload
 
-    const long long element_stop = pos + size;
+  const long long element_stop = pos + size;
 
-    if ((segment_stop >= 0) && (element_stop > segment_stop))
-        return E_FILE_FORMAT_INVALID;
+  if ((segment_stop >= 0) && (element_stop > segment_stop))
+    return E_FILE_FORMAT_INVALID;
 
-    if ((total >= 0) && (element_stop > total))
-        return 1;  //don't bother parsing anymore
+  if ((total >= 0) && (element_stop > total))
+    return 1;  // don't bother parsing anymore
 
-    len = static_cast<long>(size);
+  len = static_cast<long>(size);
 
-    if (element_stop > avail)
-        return E_BUFFER_NOT_FULL;
+  if (element_stop > avail)
+    return E_BUFFER_NOT_FULL;
 
-    const long long element_size = element_stop - element_start;
+  const long long element_size = element_stop - element_start;
 
-    m_pCues = new (std::nothrow) Cues(
-                                    this,
-                                    pos,
-                                    size,
-                                    element_start,
-                                    element_size);
-    assert(m_pCues);  //TODO
+  m_pCues =
+      new (std::nothrow) Cues(this, pos, size, element_start, element_size);
+  assert(m_pCues);  // TODO
 
-    return 0;  //success
+  return 0;  // success
 }
 #endif
 
-
 #if 0
 void Segment::ParseSeekEntry(
     long long start,
@@ -2259,304 +2020,269 @@

         ParseCues(seekOff);
 }
 #else
-bool SeekHead::ParseEntry(
-    IMkvReader* pReader,
-    long long start,
-    long long size_,
-    Entry* pEntry)
-{
-    if (size_ <= 0)
-        return false;
+bool SeekHead::ParseEntry(IMkvReader* pReader, long long start, long long size_,
+                          Entry* pEntry) {
+  if (size_ <= 0)
+    return false;
 
-    long long pos = start;
-    const long long stop = start + size_;
+  long long pos = start;
+  const long long stop = start + size_;
 
-    long len;
+  long len;
 
-    //parse the container for the level-1 element ID
+  // parse the container for the level-1 element ID
 
-    const long long seekIdId = ReadUInt(pReader, pos, len);
-    //seekIdId;
+  const long long seekIdId = ReadUInt(pReader, pos, len);
+  // seekIdId;
 
-    if (seekIdId != 0x13AB)  //SeekID ID
-        return false;
+  if (seekIdId != 0x13AB)  // SeekID ID
+    return false;
 
-    if ((pos + len) > stop)
-        return false;
+  if ((pos + len) > stop)
+    return false;
 
-    pos += len;  //consume SeekID id
+  pos += len;  // consume SeekID id
 
-    const long long seekIdSize = ReadUInt(pReader, pos, len);
+  const long long seekIdSize = ReadUInt(pReader, pos, len);
 
-    if (seekIdSize <= 0)
-        return false;
+  if (seekIdSize <= 0)
+    return false;
 
-    if ((pos + len) > stop)
-        return false;
+  if ((pos + len) > stop)
+    return false;
 
-    pos += len;  //consume size of field
+  pos += len;  // consume size of field
 
-    if ((pos + seekIdSize) > stop)
-        return false;
+  if ((pos + seekIdSize) > stop)
+    return false;
 
-    //Note that the SeekId payload really is serialized
-    //as a ""Matroska integer"", not as a plain binary value.
-    //In fact, Matroska requires that ID values in the
-    //stream exactly match the binary representation as listed
-    //in the Matroska specification.
-    //
-    //This parser is more liberal, and permits IDs to have
-    //any width.  (This could make the representation in the stream
-    //different from what's in the spec, but it doesn't matter here,
-    //since we always normalize ""Matroska integer"" values.)
+  // Note that the SeekId payload really is serialized
+  // as a ""Matroska integer"", not as a plain binary value.
+  // In fact, Matroska requires that ID values in the
+  // stream exactly match the binary representation as listed
+  // in the Matroska specification.
+  //
+  // This parser is more liberal, and permits IDs to have
+  // any width.  (This could make the representation in the stream
+  // different from what's in the spec, but it doesn't matter here,
+  // since we always normalize ""Matroska integer"" values.)
 
-    pEntry->id = ReadUInt(pReader, pos, len);  //payload
+  pEntry->id = ReadUInt(pReader, pos, len);  // payload
 
-    if (pEntry->id <= 0)
-        return false;
+  if (pEntry->id <= 0)
+    return false;
 
-    if (len != seekIdSize)
-        return false;
+  if (len != seekIdSize)
+    return false;
 
-    pos += seekIdSize;  //consume SeekID payload
+  pos += seekIdSize;  // consume SeekID payload
 
-    const long long seekPosId = ReadUInt(pReader, pos, len);
+  const long long seekPosId = ReadUInt(pReader, pos, len);
 
-    if (seekPosId != 0x13AC)  //SeekPos ID
-        return false;
+  if (seekPosId != 0x13AC)  // SeekPos ID
+    return false;
 
-    if ((pos + len) > stop)
-        return false;
+  if ((pos + len) > stop)
+    return false;
 
-    pos += len;  //consume id
+  pos += len;  // consume id
 
-    const long long seekPosSize = ReadUInt(pReader, pos, len);
+  const long long seekPosSize = ReadUInt(pReader, pos, len);
 
-    if (seekPosSize <= 0)
-        return false;
+  if (seekPosSize <= 0)
+    return false;
 
-    if ((pos + len) > stop)
-        return false;
+  if ((pos + len) > stop)
+    return false;
 
-    pos += len;  //consume size
+  pos += len;  // consume size
 
-    if ((pos + seekPosSize) > stop)
-        return false;
+  if ((pos + seekPosSize) > stop)
+    return false;
 
-    pEntry->pos = UnserializeUInt(pReader, pos, seekPosSize);
+  pEntry->pos = UnserializeUInt(pReader, pos, seekPosSize);
 
-    if (pEntry->pos < 0)
-        return false;
+  if (pEntry->pos < 0)
+    return false;
 
-    pos += seekPosSize;  //consume payload
+  pos += seekPosSize;  // consume payload
 
-    if (pos != stop)
-        return false;
+  if (pos != stop)
+    return false;
 
-    return true;
+  return true;
 }
 #endif
 
+Cues::Cues(Segment* pSegment, long long start_, long long size_,
+           long long element_start, long long element_size)
+    : m_pSegment(pSegment),
+      m_start(start_),
+      m_size(size_),
+      m_element_start(element_start),
+      m_element_size(element_size),
+      m_cue_points(NULL),
+      m_count(0),
+      m_preload_count(0),
+      m_pos(start_) {}
 
-Cues::Cues(
-    Segment* pSegment,
-    long long start_,
-    long long size_,
-    long long element_start,
-    long long element_size) :
-    m_pSegment(pSegment),
-    m_start(start_),
-    m_size(size_),
-    m_element_start(element_start),
-    m_element_size(element_size),
-    m_cue_points(NULL),
-    m_count(0),
-    m_preload_count(0),
-    m_pos(start_)
-{
+Cues::~Cues() {
+  const long n = m_count + m_preload_count;
+
+  CuePoint** p = m_cue_points;
+  CuePoint** const q = p + n;
+
+  while (p != q) {
+    CuePoint* const pCP = *p++;
+    assert(pCP);
+
+    delete pCP;
+  }
+
+  delete[] m_cue_points;
 }
 
+long Cues::GetCount() const {
+  if (m_cue_points == NULL)
+    return -1;
 
-Cues::~Cues()
-{
-    const long n = m_count + m_preload_count;
+  return m_count;  // TODO: really ignore preload count?
+}
 
-    CuePoint** p = m_cue_points;
-    CuePoint** const q = p + n;
+bool Cues::DoneParsing() const {
+  const long long stop = m_start + m_size;
+  return (m_pos >= stop);
+}
 
-    while (p != q)
-    {
-        CuePoint* const pCP = *p++;
-        assert(pCP);
+void Cues::Init() const {
+  if (m_cue_points)
+    return;
 
-        delete pCP;
-    }
+  assert(m_count == 0);
+  assert(m_preload_count == 0);
+
+  IMkvReader* const pReader = m_pSegment->m_pReader;
+
+  const long long stop = m_start + m_size;
+  long long pos = m_start;
+
+  long cue_points_size = 0;
+
+  while (pos < stop) {
+    const long long idpos = pos;
+
+    long len;
+
+    const long long id = ReadUInt(pReader, pos, len);
+    assert(id >= 0);  // TODO
+    assert((pos + len) <= stop);
+
+    pos += len;  // consume ID
+
+    const long long size = ReadUInt(pReader, pos, len);
+    assert(size >= 0);
+    assert((pos + len) <= stop);
+
+    pos += len;  // consume Size field
+    assert((pos + size) <= stop);
+
+    if (id == 0x3B)  // CuePoint ID
+      PreloadCuePoint(cue_points_size, idpos);
+
+    pos += size;  // consume payload
+    assert(pos <= stop);
+  }
+}
+
+void Cues::PreloadCuePoint(long& cue_points_size, long long pos) const {
+  assert(m_count == 0);
+
+  if (m_preload_count >= cue_points_size) {
+    const long n = (cue_points_size <= 0) ? 2048 : 2 * cue_points_size;
+
+    CuePoint** const qq = new CuePoint* [n];
+    CuePoint** q = qq;  // beginning of target
+
+    CuePoint** p = m_cue_points;  // beginning of source
+    CuePoint** const pp = p + m_preload_count;  // end of source
+
+    while (p != pp)
+      *q++ = *p++;
 
     delete[] m_cue_points;
+
+    m_cue_points = qq;
+    cue_points_size = n;
+  }
+
+  CuePoint* const pCP = new CuePoint(m_preload_count, pos);
+  m_cue_points[m_preload_count++] = pCP;
 }
 
+bool Cues::LoadCuePoint() const {
+  // odbgstream os;
+  // os << ""Cues::LoadCuePoint"" << endl;
 
-long Cues::GetCount() const
-{
-    if (m_cue_points == NULL)
-        return -1;
+  const long long stop = m_start + m_size;
 
-    return m_count;  //TODO: really ignore preload count?
-}
+  if (m_pos >= stop)
+    return false;  // nothing else to do
 
+  Init();
 
-bool Cues::DoneParsing() const
-{
-    const long long stop = m_start + m_size;
-    return (m_pos >= stop);
-}
+  IMkvReader* const pReader = m_pSegment->m_pReader;
 
+  while (m_pos < stop) {
+    const long long idpos = m_pos;
 
-void Cues::Init() const
-{
-    if (m_cue_points)
-        return;
+    long len;
 
-    assert(m_count == 0);
-    assert(m_preload_count == 0);
+    const long long id = ReadUInt(pReader, m_pos, len);
+    assert(id >= 0);  // TODO
+    assert((m_pos + len) <= stop);
 
-    IMkvReader* const pReader = m_pSegment->m_pReader;
+    m_pos += len;  // consume ID
 
-    const long long stop = m_start + m_size;
-    long long pos = m_start;
+    const long long size = ReadUInt(pReader, m_pos, len);
+    assert(size >= 0);
+    assert((m_pos + len) <= stop);
 
-    long cue_points_size = 0;
+    m_pos += len;  // consume Size field
+    assert((m_pos + size) <= stop);
 
-    while (pos < stop)
-    {
-        const long long idpos = pos;
+    if (id != 0x3B) {  // CuePoint ID
+      m_pos += size;  // consume payload
+      assert(m_pos <= stop);
 
-        long len;
-
-        const long long id = ReadUInt(pReader, pos, len);
-        assert(id >= 0);  //TODO
-        assert((pos + len) <= stop);
-
-        pos += len;  //consume ID
-
-        const long long size = ReadUInt(pReader, pos, len);
-        assert(size >= 0);
-        assert((pos + len) <= stop);
-
-        pos += len;  //consume Size field
-        assert((pos + size) <= stop);
-
-        if (id == 0x3B)  //CuePoint ID
-            PreloadCuePoint(cue_points_size, idpos);
-
-        pos += size;  //consume payload
-        assert(pos <= stop);
-    }
-}
-
-
-void Cues::PreloadCuePoint(
-    long& cue_points_size,
-    long long pos) const
-{
-    assert(m_count == 0);
-
-    if (m_preload_count >= cue_points_size)
-    {
-        const long n = (cue_points_size <= 0) ? 2048 : 2*cue_points_size;
-
-        CuePoint** const qq = new CuePoint*[n];
-        CuePoint** q = qq;  //beginning of target
-
-        CuePoint** p = m_cue_points;                //beginning of source
-        CuePoint** const pp = p + m_preload_count;  //end of source
-
-        while (p != pp)
-            *q++ = *p++;
-
-        delete[] m_cue_points;
-
-        m_cue_points = qq;
-        cue_points_size = n;
+      continue;
     }
 
-    CuePoint* const pCP = new CuePoint(m_preload_count, pos);
-    m_cue_points[m_preload_count++] = pCP;
+    assert(m_preload_count > 0);
+
+    CuePoint* const pCP = m_cue_points[m_count];
+    assert(pCP);
+    assert((pCP->GetTimeCode() >= 0) || (-pCP->GetTimeCode() == idpos));
+    if (pCP->GetTimeCode() < 0 && (-pCP->GetTimeCode() != idpos))
+      return false;
+
+    pCP->Load(pReader);
+    ++m_count;
+    --m_preload_count;
+
+    m_pos += size;  // consume payload
+    assert(m_pos <= stop);
+
+    return true;  // yes, we loaded a cue point
+  }
+
+  // return (m_pos < stop);
+  return false;  // no, we did not load a cue point
 }
 
-
-bool Cues::LoadCuePoint() const
-{
-    //odbgstream os;
-    //os << ""Cues::LoadCuePoint"" << endl;
-
-    const long long stop = m_start + m_size;
-
-    if (m_pos >= stop)
-        return false;  //nothing else to do
-
-    Init();
-
-    IMkvReader* const pReader = m_pSegment->m_pReader;
-
-    while (m_pos < stop)
-    {
-        const long long idpos = m_pos;
-
-        long len;
-
-        const long long id = ReadUInt(pReader, m_pos, len);
-        assert(id >= 0);  //TODO
-        assert((m_pos + len) <= stop);
-
-        m_pos += len;  //consume ID
-
-        const long long size = ReadUInt(pReader, m_pos, len);
-        assert(size >= 0);
-        assert((m_pos + len) <= stop);
-
-        m_pos += len;  //consume Size field
-        assert((m_pos + size) <= stop);
-
-        if (id != 0x3B)  //CuePoint ID
-        {
-            m_pos += size;  //consume payload
-            assert(m_pos <= stop);
-
-            continue;
-        }
-
-        assert(m_preload_count > 0);
-
-        CuePoint* const pCP = m_cue_points[m_count];
-        assert(pCP);
-        assert((pCP->GetTimeCode() >= 0) || (-pCP->GetTimeCode() == idpos));
-        if (pCP->GetTimeCode() < 0 && (-pCP->GetTimeCode() != idpos))
-            return false;
-
-        pCP->Load(pReader);
-        ++m_count;
-        --m_preload_count;
-
-        m_pos += size;  //consume payload
-        assert(m_pos <= stop);
-
-        return true;  //yes, we loaded a cue point
-    }
-
-    //return (m_pos < stop);
-    return false;  //no, we did not load a cue point
-}
-
-
-bool Cues::Find(
-    long long time_ns,
-    const Track* pTrack,
-    const CuePoint*& pCP,
-    const CuePoint::TrackPosition*& pTP) const
-{
-    assert(time_ns >= 0);
-    assert(pTrack);
+bool Cues::Find(long long time_ns, const Track* pTrack, const CuePoint*& pCP,
+                const CuePoint::TrackPosition*& pTP) const {
+  assert(time_ns >= 0);
+  assert(pTrack);
 
 #if 0
     LoadCuePoint();  //establish invariant
@@ -2614,71 +2340,68 @@

     assert(pCP);
     assert(pCP->GetTime(m_pSegment) <= time_ns);
 #else
-    if (m_cue_points == NULL)
-        return false;
+  if (m_cue_points == NULL)
+    return false;
 
-    if (m_count == 0)
-        return false;
+  if (m_count == 0)
+    return false;
 
-    CuePoint** const ii = m_cue_points;
-    CuePoint** i = ii;
+  CuePoint** const ii = m_cue_points;
+  CuePoint** i = ii;
 
-    CuePoint** const jj = ii + m_count;
-    CuePoint** j = jj;
+  CuePoint** const jj = ii + m_count;
+  CuePoint** j = jj;
 
-    pCP = *i;
-    assert(pCP);
+  pCP = *i;
+  assert(pCP);
 
-    if (time_ns <= pCP->GetTime(m_pSegment))
-    {
-        pTP = pCP->Find(pTrack);
-        return (pTP != NULL);
-    }
-
-    while (i < j)
-    {
-        //INVARIANT:
-        //[ii, i) <= time_ns
-        //[i, j)  ?
-        //[j, jj) > time_ns
-
-        CuePoint** const k = i + (j - i) / 2;
-        assert(k < jj);
-
-        CuePoint* const pCP = *k;
-        assert(pCP);
-
-        const long long t = pCP->GetTime(m_pSegment);
-
-        if (t <= time_ns)
-            i = k + 1;
-        else
-            j = k;
-
-        assert(i <= j);
-    }
-
-    assert(i == j);
-    assert(i <= jj);
-    assert(i > ii);
-
-    pCP = *--i;
-    assert(pCP);
-    assert(pCP->GetTime(m_pSegment) <= time_ns);
-#endif
-
-    //TODO: here and elsewhere, it's probably not correct to search
-    //for the cue point with this time, and then search for a matching
-    //track.  In principle, the matching track could be on some earlier
-    //cue point, and with our current algorithm, we'd miss it.  To make
-    //this bullet-proof, we'd need to create a secondary structure,
-    //with a list of cue points that apply to a track, and then search
-    //that track-based structure for a matching cue point.
-
+  if (time_ns <= pCP->GetTime(m_pSegment)) {
     pTP = pCP->Find(pTrack);
     return (pTP != NULL);
-}
+  }
 
+  while (i < j) {
+    // INVARIANT:
+    //[ii, i) <= time_ns
+    //[i, j)  ?
+    //[j, jj) > time_ns
+
+    CuePoint** const k = i + (j - i) / 2;
+    assert(k < jj);
+
+    CuePoint* const pCP = *k;
+    assert(pCP);
+
+    const long long t = pCP->GetTime(m_pSegment);
+
+    if (t <= time_ns)
+      i = k + 1;
+    else
+      j = k;
+
+    assert(i <= j);
+  }
+
+  assert(i == j);
+  assert(i <= jj);
+  assert(i > ii);
+
+  pCP = *--i;
+  assert(pCP);
+  assert(pCP->GetTime(m_pSegment) <= time_ns);
+#endif
+
+  // TODO: here and elsewhere, it's probably not correct to search
+  // for the cue point with this time, and then search for a matching
+  // track.  In principle, the matching track could be on some earlier
+  // cue point, and with our current algorithm, we'd miss it.  To make
+  // this bullet-proof, we'd need to create a secondary structure,
+  // with a list of cue points that apply to a track, and then search
+  // that track-based structure for a matching cue point.
+
+  pTP = pCP->Find(pTrack);
+  return (pTP != NULL);
+}
 
 #if 0
 bool Cues::FindNext(
@@ -2739,14 +2462,12 @@

 }
 #endif
 
+const CuePoint* Cues::GetFirst() const {
+  if (m_cue_points == NULL)
+    return NULL;
 
-const CuePoint* Cues::GetFirst() const
-{
-    if (m_cue_points == NULL)
-        return NULL;
-
-    if (m_count == 0)
-        return NULL;
+  if (m_count == 0)
+    return NULL;
 
 #if 0
     LoadCuePoint();  //init cues
@@ -2757,24 +2478,22 @@

         return NULL;
 #endif
 
-    CuePoint* const* const pp = m_cue_points;
-    assert(pp);
+  CuePoint* const* const pp = m_cue_points;
+  assert(pp);
 
-    CuePoint* const pCP = pp[0];
-    assert(pCP);
-    assert(pCP->GetTimeCode() >= 0);
+  CuePoint* const pCP = pp[0];
+  assert(pCP);
+  assert(pCP->GetTimeCode() >= 0);
 
-    return pCP;
+  return pCP;
 }
 
+const CuePoint* Cues::GetLast() const {
+  if (m_cue_points == NULL)
+    return NULL;
 
-const CuePoint* Cues::GetLast() const
-{
-    if (m_cue_points == NULL)
-        return NULL;
-
-    if (m_count <= 0)
-        return NULL;
+  if (m_count <= 0)
+    return NULL;
 
 #if 0
     LoadCuePoint();  //init cues
@@ -2795,28 +2514,26 @@

     pCP->Load(m_pSegment->m_pReader);
     assert(pCP->GetTimeCode() >= 0);
 #else
-    const long index = m_count - 1;
+  const long index = m_count - 1;
 
-    CuePoint* const* const pp = m_cue_points;
-    assert(pp);
+  CuePoint* const* const pp = m_cue_points;
+  assert(pp);
 
-    CuePoint* const pCP = pp[index];
-    assert(pCP);
-    assert(pCP->GetTimeCode() >= 0);
+  CuePoint* const pCP = pp[index];
+  assert(pCP);
+  assert(pCP->GetTimeCode() >= 0);
 #endif
 
-    return pCP;
+  return pCP;
 }
 
+const CuePoint* Cues::GetNext(const CuePoint* pCurr) const {
+  if (pCurr == NULL)
+    return NULL;
 
-const CuePoint* Cues::GetNext(const CuePoint* pCurr) const
-{
-    if (pCurr == NULL)
-        return NULL;
-
-    assert(pCurr->GetTimeCode() >= 0);
-    assert(m_cue_points);
-    assert(m_count >= 1);
+  assert(pCurr->GetTimeCode() >= 0);
+  assert(m_cue_points);
+  assert(m_count >= 1);
 
 #if 0
     const size_t count = m_count + m_preload_count;
@@ -2838,386 +2555,347 @@

 
     pNext->Load(m_pSegment->m_pReader);
 #else
-    long index = pCurr->m_index;
-    assert(index < m_count);
+  long index = pCurr->m_index;
+  assert(index < m_count);
 
-    CuePoint* const* const pp = m_cue_points;
-    assert(pp);
-    assert(pp[index] == pCurr);
+  CuePoint* const* const pp = m_cue_points;
+  assert(pp);
+  assert(pp[index] == pCurr);
 
-    ++index;
+  ++index;
 
-    if (index >= m_count)
-        return NULL;
+  if (index >= m_count)
+    return NULL;
 
-    CuePoint* const pNext = pp[index];
-    assert(pNext);
-    assert(pNext->GetTimeCode() >= 0);
+  CuePoint* const pNext = pp[index];
+  assert(pNext);
+  assert(pNext->GetTimeCode() >= 0);
 #endif
 
-    return pNext;
+  return pNext;
 }
 
+const BlockEntry* Cues::GetBlock(const CuePoint* pCP,
+                                 const CuePoint::TrackPosition* pTP) const {
+  if (pCP == NULL)
+    return NULL;
 
-const BlockEntry* Cues::GetBlock(
-    const CuePoint* pCP,
-    const CuePoint::TrackPosition* pTP) const
-{
-    if (pCP == NULL)
-        return NULL;
+  if (pTP == NULL)
+    return NULL;
 
-    if (pTP == NULL)
-        return NULL;
-
-    return m_pSegment->GetBlock(*pCP, *pTP);
+  return m_pSegment->GetBlock(*pCP, *pTP);
 }
 
+const BlockEntry* Segment::GetBlock(const CuePoint& cp,
+                                    const CuePoint::TrackPosition& tp) {
+  Cluster** const ii = m_clusters;
+  Cluster** i = ii;
 
-const BlockEntry* Segment::GetBlock(
-    const CuePoint& cp,
-    const CuePoint::TrackPosition& tp)
-{
-    Cluster** const ii = m_clusters;
-    Cluster** i = ii;
+  const long count = m_clusterCount + m_clusterPreloadCount;
 
-    const long count = m_clusterCount + m_clusterPreloadCount;
+  Cluster** const jj = ii + count;
+  Cluster** j = jj;
 
-    Cluster** const jj = ii + count;
-    Cluster** j = jj;
+  while (i < j) {
+    // INVARIANT:
+    //[ii, i) < pTP->m_pos
+    //[i, j) ?
+    //[j, jj)  > pTP->m_pos
 
-    while (i < j)
-    {
-        //INVARIANT:
-        //[ii, i) < pTP->m_pos
-        //[i, j) ?
-        //[j, jj)  > pTP->m_pos
+    Cluster** const k = i + (j - i) / 2;
+    assert(k < jj);
 
-        Cluster** const k = i + (j - i) / 2;
-        assert(k < jj);
-
-        Cluster* const pCluster = *k;
-        assert(pCluster);
-
-        //const long long pos_ = pCluster->m_pos;
-        //assert(pos_);
-        //const long long pos = pos_ * ((pos_ < 0) ? -1 : 1);
-
-        const long long pos = pCluster->GetPosition();
-        assert(pos >= 0);
-
-        if (pos < tp.m_pos)
-            i = k + 1;
-        else if (pos > tp.m_pos)
-            j = k;
-        else
-            return pCluster->GetEntry(cp, tp);
-    }
-
-    assert(i == j);
-    //assert(Cluster::HasBlockEntries(this, tp.m_pos));
-
-    Cluster* const pCluster = Cluster::Create(this, -1, tp.m_pos); //, -1);
+    Cluster* const pCluster = *k;
     assert(pCluster);
 
-    const ptrdiff_t idx = i - m_clusters;
+    // const long long pos_ = pCluster->m_pos;
+    // assert(pos_);
+    // const long long pos = pos_ * ((pos_ < 0) ? -1 : 1);
 
-    PreloadCluster(pCluster, idx);
-    assert(m_clusters);
-    assert(m_clusterPreloadCount > 0);
-    assert(m_clusters[idx] == pCluster);
+    const long long pos = pCluster->GetPosition();
+    assert(pos >= 0);
 
-    return pCluster->GetEntry(cp, tp);
+    if (pos < tp.m_pos)
+      i = k + 1;
+    else if (pos > tp.m_pos)
+      j = k;
+    else
+      return pCluster->GetEntry(cp, tp);
+  }
+
+  assert(i == j);
+  // assert(Cluster::HasBlockEntries(this, tp.m_pos));
+
+  Cluster* const pCluster = Cluster::Create(this, -1, tp.m_pos);  //, -1);
+  assert(pCluster);
+
+  const ptrdiff_t idx = i - m_clusters;
+
+  PreloadCluster(pCluster, idx);
+  assert(m_clusters);
+  assert(m_clusterPreloadCount > 0);
+  assert(m_clusters[idx] == pCluster);
+
+  return pCluster->GetEntry(cp, tp);
 }
 
+const Cluster* Segment::FindOrPreloadCluster(long long requested_pos) {
+  if (requested_pos < 0)
+    return 0;
 
-const Cluster* Segment::FindOrPreloadCluster(long long requested_pos)
-{
-    if (requested_pos < 0)
-        return 0;
+  Cluster** const ii = m_clusters;
+  Cluster** i = ii;
 
-    Cluster** const ii = m_clusters;
-    Cluster** i = ii;
+  const long count = m_clusterCount + m_clusterPreloadCount;
 
-    const long count = m_clusterCount + m_clusterPreloadCount;
+  Cluster** const jj = ii + count;
+  Cluster** j = jj;
 
-    Cluster** const jj = ii + count;
-    Cluster** j = jj;
+  while (i < j) {
+    // INVARIANT:
+    //[ii, i) < pTP->m_pos
+    //[i, j) ?
+    //[j, jj)  > pTP->m_pos
 
-    while (i < j)
-    {
-        //INVARIANT:
-        //[ii, i) < pTP->m_pos
-        //[i, j) ?
-        //[j, jj)  > pTP->m_pos
+    Cluster** const k = i + (j - i) / 2;
+    assert(k < jj);
 
-        Cluster** const k = i + (j - i) / 2;
-        assert(k < jj);
-
-        Cluster* const pCluster = *k;
-        assert(pCluster);
-
-        //const long long pos_ = pCluster->m_pos;
-        //assert(pos_);
-        //const long long pos = pos_ * ((pos_ < 0) ? -1 : 1);
-
-        const long long pos = pCluster->GetPosition();
-        assert(pos >= 0);
-
-        if (pos < requested_pos)
-            i = k + 1;
-        else if (pos > requested_pos)
-            j = k;
-        else
-            return pCluster;
-    }
-
-    assert(i == j);
-    //assert(Cluster::HasBlockEntries(this, tp.m_pos));
-
-    Cluster* const pCluster = Cluster::Create(
-                                this,
-                                -1,
-                                requested_pos);
-                                //-1);
+    Cluster* const pCluster = *k;
     assert(pCluster);
 
-    const ptrdiff_t idx = i - m_clusters;
+    // const long long pos_ = pCluster->m_pos;
+    // assert(pos_);
+    // const long long pos = pos_ * ((pos_ < 0) ? -1 : 1);
 
-    PreloadCluster(pCluster, idx);
-    assert(m_clusters);
-    assert(m_clusterPreloadCount > 0);
-    assert(m_clusters[idx] == pCluster);
+    const long long pos = pCluster->GetPosition();
+    assert(pos >= 0);
 
-    return pCluster;
+    if (pos < requested_pos)
+      i = k + 1;
+    else if (pos > requested_pos)
+      j = k;
+    else
+      return pCluster;
+  }
+
+  assert(i == j);
+  // assert(Cluster::HasBlockEntries(this, tp.m_pos));
+
+  Cluster* const pCluster = Cluster::Create(this, -1, requested_pos);
+  //-1);
+  assert(pCluster);
+
+  const ptrdiff_t idx = i - m_clusters;
+
+  PreloadCluster(pCluster, idx);
+  assert(m_clusters);
+  assert(m_clusterPreloadCount > 0);
+  assert(m_clusters[idx] == pCluster);
+
+  return pCluster;
 }
 
-
-CuePoint::CuePoint(long idx, long long pos) :
-    m_element_start(0),
-    m_element_size(0),
-    m_index(idx),
-    m_timecode(-1 * pos),
-    m_track_positions(NULL),
-    m_track_positions_count(0)
-{
-    assert(pos > 0);
+CuePoint::CuePoint(long idx, long long pos)
+    : m_element_start(0),
+      m_element_size(0),
+      m_index(idx),
+      m_timecode(-1 * pos),
+      m_track_positions(NULL),
+      m_track_positions_count(0) {
+  assert(pos > 0);
 }
 
+CuePoint::~CuePoint() { delete[] m_track_positions; }
 
-CuePoint::~CuePoint()
-{
-    delete[] m_track_positions;
-}
+void CuePoint::Load(IMkvReader* pReader) {
+  // odbgstream os;
+  // os << ""CuePoint::Load(begin): timecode="" << m_timecode << endl;
 
+  if (m_timecode >= 0)  // already loaded
+    return;
 
-void CuePoint::Load(IMkvReader* pReader)
-{
-    //odbgstream os;
-    //os << ""CuePoint::Load(begin): timecode="" << m_timecode << endl;
+  assert(m_track_positions == NULL);
+  assert(m_track_positions_count == 0);
 
-    if (m_timecode >= 0)  //already loaded
-        return;
+  long long pos_ = -m_timecode;
+  const long long element_start = pos_;
 
-    assert(m_track_positions == NULL);
-    assert(m_track_positions_count == 0);
+  long long stop;
 
-    long long pos_ = -m_timecode;
-    const long long element_start = pos_;
+  {
+    long len;
 
-    long long stop;
+    const long long id = ReadUInt(pReader, pos_, len);
+    assert(id == 0x3B);  // CuePoint ID
+    if (id != 0x3B)
+      return;
 
-    {
-        long len;
+    pos_ += len;  // consume ID
 
-        const long long id = ReadUInt(pReader, pos_, len);
-        assert(id == 0x3B);  //CuePoint ID
-        if (id != 0x3B)
-            return;
+    const long long size = ReadUInt(pReader, pos_, len);
+    assert(size >= 0);
 
-        pos_ += len;  //consume ID
+    pos_ += len;  // consume Size field
+    // pos_ now points to start of payload
 
-        const long long size = ReadUInt(pReader, pos_, len);
-        assert(size >= 0);
+    stop = pos_ + size;
+  }
 
-        pos_ += len;  //consume Size field
-        //pos_ now points to start of payload
+  const long long element_size = stop - element_start;
 
-        stop = pos_ + size;
+  long long pos = pos_;
+
+  // First count number of track positions
+
+  while (pos < stop) {
+    long len;
+
+    const long long id = ReadUInt(pReader, pos, len);
+    assert(id >= 0);  // TODO
+    assert((pos + len) <= stop);
+
+    pos += len;  // consume ID
+
+    const long long size = ReadUInt(pReader, pos, len);
+    assert(size >= 0);
+    assert((pos + len) <= stop);
+
+    pos += len;  // consume Size field
+    assert((pos + size) <= stop);
+
+    if (id == 0x33)  // CueTime ID
+      m_timecode = UnserializeUInt(pReader, pos, size);
+
+    else if (id == 0x37)  // CueTrackPosition(s) ID
+      ++m_track_positions_count;
+
+    pos += size;  // consume payload
+    assert(pos <= stop);
+  }
+
+  assert(m_timecode >= 0);
+  assert(m_track_positions_count > 0);
+
+  // os << ""CuePoint::Load(cont'd): idpos="" << idpos
+  //   << "" timecode="" << m_timecode
+  //   << endl;
+
+  m_track_positions = new TrackPosition[m_track_positions_count];
+
+  // Now parse track positions
+
+  TrackPosition* p = m_track_positions;
+  pos = pos_;
+
+  while (pos < stop) {
+    long len;
+
+    const long long id = ReadUInt(pReader, pos, len);
+    assert(id >= 0);  // TODO
+    assert((pos + len) <= stop);
+
+    pos += len;  // consume ID
+
+    const long long size = ReadUInt(pReader, pos, len);
+    assert(size >= 0);
+    assert((pos + len) <= stop);
+
+    pos += len;  // consume Size field
+    assert((pos + size) <= stop);
+
+    if (id == 0x37) {  // CueTrackPosition(s) ID
+      TrackPosition& tp = *p++;
+      tp.Parse(pReader, pos, size);
     }
 
-    const long long element_size = stop - element_start;
+    pos += size;  // consume payload
+    assert(pos <= stop);
+  }
 
-    long long pos = pos_;
+  assert(size_t(p - m_track_positions) == m_track_positions_count);
 
-    //First count number of track positions
-
-    while (pos < stop)
-    {
-        long len;
-
-        const long long id = ReadUInt(pReader, pos, len);
-        assert(id >= 0);  //TODO
-        assert((pos + len) <= stop);
-
-        pos += len;  //consume ID
-
-        const long long size = ReadUInt(pReader, pos, len);
-        assert(size >= 0);
-        assert((pos + len) <= stop);
-
-        pos += len;  //consume Size field
-        assert((pos + size) <= stop);
-
-        if (id == 0x33)  //CueTime ID
-            m_timecode = UnserializeUInt(pReader, pos, size);
-
-        else if (id == 0x37) //CueTrackPosition(s) ID
-            ++m_track_positions_count;
-
-        pos += size;  //consume payload
-        assert(pos <= stop);
-    }
-
-    assert(m_timecode >= 0);
-    assert(m_track_positions_count > 0);
-
-    //os << ""CuePoint::Load(cont'd): idpos="" << idpos
-    //   << "" timecode="" << m_timecode
-    //   << endl;
-
-    m_track_positions = new TrackPosition[m_track_positions_count];
-
-    //Now parse track positions
-
-    TrackPosition* p = m_track_positions;
-    pos = pos_;
-
-    while (pos < stop)
-    {
-        long len;
-
-        const long long id = ReadUInt(pReader, pos, len);
-        assert(id >= 0);  //TODO
-        assert((pos + len) <= stop);
-
-        pos += len;  //consume ID
-
-        const long long size = ReadUInt(pReader, pos, len);
-        assert(size >= 0);
-        assert((pos + len) <= stop);
-
-        pos += len;  //consume Size field
-        assert((pos + size) <= stop);
-
-        if (id == 0x37) //CueTrackPosition(s) ID
-        {
-            TrackPosition& tp = *p++;
-            tp.Parse(pReader, pos, size);
-        }
-
-        pos += size;  //consume payload
-        assert(pos <= stop);
-    }
-
-    assert(size_t(p - m_track_positions) == m_track_positions_count);
-
-    m_element_start = element_start;
-    m_element_size = element_size;
+  m_element_start = element_start;
+  m_element_size = element_size;
 }
 
+void CuePoint::TrackPosition::Parse(IMkvReader* pReader, long long start_,
+                                    long long size_) {
+  const long long stop = start_ + size_;
+  long long pos = start_;
 
+  m_track = -1;
+  m_pos = -1;
+  m_block = 1;  // default
 
-void CuePoint::TrackPosition::Parse(
-    IMkvReader* pReader,
-    long long start_,
-    long long size_)
-{
-    const long long stop = start_ + size_;
-    long long pos = start_;
+  while (pos < stop) {
+    long len;
 
-    m_track = -1;
-    m_pos = -1;
-    m_block = 1;  //default
+    const long long id = ReadUInt(pReader, pos, len);
+    assert(id >= 0);  // TODO
+    assert((pos + len) <= stop);
 
-    while (pos < stop)
-    {
-        long len;
+    pos += len;  // consume ID
 
-        const long long id = ReadUInt(pReader, pos, len);
-        assert(id >= 0);  //TODO
-        assert((pos + len) <= stop);
+    const long long size = ReadUInt(pReader, pos, len);
+    assert(size >= 0);
+    assert((pos + len) <= stop);
 
-        pos += len;  //consume ID
+    pos += len;  // consume Size field
+    assert((pos + size) <= stop);
 
-        const long long size = ReadUInt(pReader, pos, len);
-        assert(size >= 0);
-        assert((pos + len) <= stop);
+    if (id == 0x77)  // CueTrack ID
+      m_track = UnserializeUInt(pReader, pos, size);
 
-        pos += len;  //consume Size field
-        assert((pos + size) <= stop);
+    else if (id == 0x71)  // CueClusterPos ID
+      m_pos = UnserializeUInt(pReader, pos, size);
 
-        if (id == 0x77)  //CueTrack ID
-            m_track = UnserializeUInt(pReader, pos, size);
+    else if (id == 0x1378)  // CueBlockNumber
+      m_block = UnserializeUInt(pReader, pos, size);
 
-        else if (id == 0x71)  //CueClusterPos ID
-            m_pos = UnserializeUInt(pReader, pos, size);
+    pos += size;  // consume payload
+    assert(pos <= stop);
+  }
 
-        else if (id == 0x1378)  //CueBlockNumber
-            m_block = UnserializeUInt(pReader, pos, size);
-
-        pos += size;  //consume payload
-        assert(pos <= stop);
-    }
-
-    assert(m_pos >= 0);
-    assert(m_track > 0);
-    //assert(m_block > 0);
+  assert(m_pos >= 0);
+  assert(m_track > 0);
+  // assert(m_block > 0);
 }
 
+const CuePoint::TrackPosition* CuePoint::Find(const Track* pTrack) const {
+  assert(pTrack);
 
-const CuePoint::TrackPosition* CuePoint::Find(const Track* pTrack) const
-{
-    assert(pTrack);
+  const long long n = pTrack->GetNumber();
 
-    const long long n = pTrack->GetNumber();
+  const TrackPosition* i = m_track_positions;
+  const TrackPosition* const j = i + m_track_positions_count;
 
-    const TrackPosition* i = m_track_positions;
-    const TrackPosition* const j = i + m_track_positions_count;
+  while (i != j) {
+    const TrackPosition& p = *i++;
 
-    while (i != j)
-    {
-        const TrackPosition& p = *i++;
+    if (p.m_track == n)
+      return &p;
+  }
 
-        if (p.m_track == n)
-            return &p;
-    }
-
-    return NULL;  //no matching track number found
+  return NULL;  // no matching track number found
 }
 
+long long CuePoint::GetTimeCode() const { return m_timecode; }
 
-long long CuePoint::GetTimeCode() const
-{
-    return m_timecode;
+long long CuePoint::GetTime(const Segment* pSegment) const {
+  assert(pSegment);
+  assert(m_timecode >= 0);
+
+  const SegmentInfo* const pInfo = pSegment->GetInfo();
+  assert(pInfo);
+
+  const long long scale = pInfo->GetTimeCodeScale();
+  assert(scale >= 1);
+
+  const long long time = scale * m_timecode;
+
+  return time;
 }
 
-long long CuePoint::GetTime(const Segment* pSegment) const
-{
-    assert(pSegment);
-    assert(m_timecode >= 0);
-
-    const SegmentInfo* const pInfo = pSegment->GetInfo();
-    assert(pInfo);
-
-    const long long scale = pInfo->GetTimeCodeScale();
-    assert(scale >= 1);
-
-    const long long time = scale * m_timecode;
-
-    return time;
-}
-
-
 #if 0
 long long Segment::Unparsed() const
 {
@@ -3232,808 +2910,745 @@

     return result;
 }
 #else
-bool Segment::DoneParsing() const
-{
-    if (m_size < 0)
-    {
-        long long total, avail;
+bool Segment::DoneParsing() const {
+  if (m_size < 0) {
+    long long total, avail;
 
-        const int status = m_pReader->Length(&total, &avail);
+    const int status = m_pReader->Length(&total, &avail);
 
-        if (status < 0)  //error
-            return true;  //must assume done
+    if (status < 0)  // error
+      return true;  // must assume done
 
-        if (total < 0)
-            return false;  //assume live stream
+    if (total < 0)
+      return false;  // assume live stream
 
-        return (m_pos >= total);
-    }
+    return (m_pos >= total);
+  }
 
-    const long long stop = m_start + m_size;
+  const long long stop = m_start + m_size;
 
-    return (m_pos >= stop);
+  return (m_pos >= stop);
 }
 #endif
 
+const Cluster* Segment::GetFirst() const {
+  if ((m_clusters == NULL) || (m_clusterCount <= 0))
+    return &m_eos;
 
-const Cluster* Segment::GetFirst() const
-{
-    if ((m_clusters == NULL) || (m_clusterCount <= 0))
-       return &m_eos;
+  Cluster* const pCluster = m_clusters[0];
+  assert(pCluster);
 
-    Cluster* const pCluster = m_clusters[0];
-    assert(pCluster);
-
-    return pCluster;
+  return pCluster;
 }
 
+const Cluster* Segment::GetLast() const {
+  if ((m_clusters == NULL) || (m_clusterCount <= 0))
+    return &m_eos;
 
-const Cluster* Segment::GetLast() const
-{
-    if ((m_clusters == NULL) || (m_clusterCount <= 0))
-        return &m_eos;
+  const long idx = m_clusterCount - 1;
 
-    const long idx = m_clusterCount - 1;
+  Cluster* const pCluster = m_clusters[idx];
+  assert(pCluster);
 
-    Cluster* const pCluster = m_clusters[idx];
-    assert(pCluster);
-
-    return pCluster;
+  return pCluster;
 }
 
+unsigned long Segment::GetCount() const { return m_clusterCount; }
 
-unsigned long Segment::GetCount() const
-{
-    return m_clusterCount;
-}
+const Cluster* Segment::GetNext(const Cluster* pCurr) {
+  assert(pCurr);
+  assert(pCurr != &m_eos);
+  assert(m_clusters);
 
+  long idx = pCurr->m_index;
 
-const Cluster* Segment::GetNext(const Cluster* pCurr)
-{
-    assert(pCurr);
-    assert(pCurr != &m_eos);
-    assert(m_clusters);
+  if (idx >= 0) {
+    assert(m_clusterCount > 0);
+    assert(idx < m_clusterCount);
+    assert(pCurr == m_clusters[idx]);
 
-    long idx =  pCurr->m_index;
+    ++idx;
 
-    if (idx >= 0)
-    {
-        assert(m_clusterCount > 0);
-        assert(idx < m_clusterCount);
-        assert(pCurr == m_clusters[idx]);
+    if (idx >= m_clusterCount)
+      return &m_eos;  // caller will LoadCluster as desired
 
-        ++idx;
-
-        if (idx >= m_clusterCount)
-            return &m_eos;  //caller will LoadCluster as desired
-
-        Cluster* const pNext = m_clusters[idx];
-        assert(pNext);
-        assert(pNext->m_index >= 0);
-        assert(pNext->m_index == idx);
-
-        return pNext;
-    }
-
-    assert(m_clusterPreloadCount > 0);
-
-    long long pos = pCurr->m_element_start;
-
-    assert(m_size >= 0);  //TODO
-    const long long stop = m_start + m_size;  //end of segment
-
-    {
-        long len;
-
-        long long result = GetUIntLength(m_pReader, pos, len);
-        assert(result == 0);
-        assert((pos + len) <= stop);  //TODO
-        if (result != 0)
-            return NULL;
-
-        const long long id = ReadUInt(m_pReader, pos, len);
-        assert(id == 0x0F43B675);  //Cluster ID
-        if (id != 0x0F43B675)
-            return NULL;
-
-        pos += len;  //consume ID
-
-        //Read Size
-        result = GetUIntLength(m_pReader, pos, len);
-        assert(result == 0);  //TODO
-        assert((pos + len) <= stop);  //TODO
-
-        const long long size = ReadUInt(m_pReader, pos, len);
-        assert(size > 0);  //TODO
-        //assert((pCurr->m_size <= 0) || (pCurr->m_size == size));
-
-        pos += len;  //consume length of size of element
-        assert((pos + size) <= stop);  //TODO
-
-        //Pos now points to start of payload
-
-        pos += size;  //consume payload
-    }
-
-    long long off_next = 0;
-
-    while (pos < stop)
-    {
-        long len;
-
-        long long result = GetUIntLength(m_pReader, pos, len);
-        assert(result == 0);
-        assert((pos + len) <= stop);  //TODO
-        if (result != 0)
-            return NULL;
-
-        const long long idpos = pos;  //pos of next (potential) cluster
-
-        const long long id = ReadUInt(m_pReader, idpos, len);
-        assert(id > 0);  //TODO
-
-        pos += len;  //consume ID
-
-        //Read Size
-        result = GetUIntLength(m_pReader, pos, len);
-        assert(result == 0);  //TODO
-        assert((pos + len) <= stop);  //TODO
-
-        const long long size = ReadUInt(m_pReader, pos, len);
-        assert(size >= 0);  //TODO
-
-        pos += len;  //consume length of size of element
-        assert((pos + size) <= stop);  //TODO
-
-        //Pos now points to start of payload
-
-        if (size == 0)  //weird
-            continue;
-
-        if (id == 0x0F43B675)  //Cluster ID
-        {
-            const long long off_next_ = idpos - m_start;
-
-            long long pos_;
-            long len_;
-
-            const long status = Cluster::HasBlockEntries(
-                                    this,
-                                    off_next_,
-                                    pos_,
-                                    len_);
-
-            assert(status >= 0);
-
-            if (status > 0)
-            {
-                off_next = off_next_;
-                break;
-            }
-        }
-
-        pos += size;  //consume payload
-    }
-
-    if (off_next <= 0)
-        return 0;
-
-    Cluster** const ii = m_clusters + m_clusterCount;
-    Cluster** i = ii;
-
-    Cluster** const jj = ii + m_clusterPreloadCount;
-    Cluster** j = jj;
-
-    while (i < j)
-    {
-        //INVARIANT:
-        //[0, i) < pos_next
-        //[i, j) ?
-        //[j, jj)  > pos_next
-
-        Cluster** const k = i + (j - i) / 2;
-        assert(k < jj);
-
-        Cluster* const pNext = *k;
-        assert(pNext);
-        assert(pNext->m_index < 0);
-
-        //const long long pos_ = pNext->m_pos;
-        //assert(pos_);
-        //pos = pos_ * ((pos_ < 0) ? -1 : 1);
-
-        pos = pNext->GetPosition();
-
-        if (pos < off_next)
-            i = k + 1;
-        else if (pos > off_next)
-            j = k;
-        else
-            return pNext;
-    }
-
-    assert(i == j);
-
-    Cluster* const pNext = Cluster::Create(this,
-                                          -1,
-                                          off_next);
+    Cluster* const pNext = m_clusters[idx];
     assert(pNext);
-
-    const ptrdiff_t idx_next = i - m_clusters;  //insertion position
-
-    PreloadCluster(pNext, idx_next);
-    assert(m_clusters);
-    assert(idx_next < m_clusterSize);
-    assert(m_clusters[idx_next] == pNext);
+    assert(pNext->m_index >= 0);
+    assert(pNext->m_index == idx);
 
     return pNext;
-}
+  }
 
+  assert(m_clusterPreloadCount > 0);
 
-long Segment::ParseNext(
-    const Cluster* pCurr,
-    const Cluster*& pResult,
-    long long& pos,
-    long& len)
-{
-    assert(pCurr);
-    assert(!pCurr->EOS());
-    assert(m_clusters);
+  long long pos = pCurr->m_element_start;
 
-    pResult = 0;
+  assert(m_size >= 0);  // TODO
+  const long long stop = m_start + m_size;  // end of segment
 
-    if (pCurr->m_index >= 0)  //loaded (not merely preloaded)
-    {
-        assert(m_clusters[pCurr->m_index] == pCurr);
+  {
+    long len;
 
-        const long next_idx = pCurr->m_index + 1;
+    long long result = GetUIntLength(m_pReader, pos, len);
+    assert(result == 0);
+    assert((pos + len) <= stop);  // TODO
+    if (result != 0)
+      return NULL;
 
-        if (next_idx < m_clusterCount)
-        {
-            pResult = m_clusters[next_idx];
-            return 0;  //success
-        }
+    const long long id = ReadUInt(m_pReader, pos, len);
+    assert(id == 0x0F43B675);  // Cluster ID
+    if (id != 0x0F43B675)
+      return NULL;
 
-        //curr cluster is last among loaded
+    pos += len;  // consume ID
 
-        const long result = LoadCluster(pos, len);
+    // Read Size
+    result = GetUIntLength(m_pReader, pos, len);
+    assert(result == 0);  // TODO
+    assert((pos + len) <= stop);  // TODO
 
-        if (result < 0)  //error or underflow
-            return result;
+    const long long size = ReadUInt(m_pReader, pos, len);
+    assert(size > 0);  // TODO
+    // assert((pCurr->m_size <= 0) || (pCurr->m_size == size));
 
-        if (result > 0)  //no more clusters
-        {
-            //pResult = &m_eos;
-            return 1;
-        }
+    pos += len;  // consume length of size of element
+    assert((pos + size) <= stop);  // TODO
 
-        pResult = GetLast();
-        return 0;  //success
+    // Pos now points to start of payload
+
+    pos += size;  // consume payload
+  }
+
+  long long off_next = 0;
+
+  while (pos < stop) {
+    long len;
+
+    long long result = GetUIntLength(m_pReader, pos, len);
+    assert(result == 0);
+    assert((pos + len) <= stop);  // TODO
+    if (result != 0)
+      return NULL;
+
+    const long long idpos = pos;  // pos of next (potential) cluster
+
+    const long long id = ReadUInt(m_pReader, idpos, len);
+    assert(id > 0);  // TODO
+
+    pos += len;  // consume ID
+
+    // Read Size
+    result = GetUIntLength(m_pReader, pos, len);
+    assert(result == 0);  // TODO
+    assert((pos + len) <= stop);  // TODO
+
+    const long long size = ReadUInt(m_pReader, pos, len);
+    assert(size >= 0);  // TODO
+
+    pos += len;  // consume length of size of element
+    assert((pos + size) <= stop);  // TODO
+
+    // Pos now points to start of payload
+
+    if (size == 0)  // weird
+      continue;
+
+    if (id == 0x0F43B675) {  // Cluster ID
+      const long long off_next_ = idpos - m_start;
+
+      long long pos_;
+      long len_;
+
+      const long status = Cluster::HasBlockEntries(this, off_next_, pos_, len_);
+
+      assert(status >= 0);
+
+      if (status > 0) {
+        off_next = off_next_;
+        break;
+      }
     }
 
-    assert(m_pos > 0);
+    pos += size;  // consume payload
+  }
 
-    long long total, avail;
+  if (off_next <= 0)
+    return 0;
 
-    long status = m_pReader->Length(&total, &avail);
+  Cluster** const ii = m_clusters + m_clusterCount;
+  Cluster** i = ii;
 
-    if (status < 0)  //error
-        return status;
+  Cluster** const jj = ii + m_clusterPreloadCount;
+  Cluster** j = jj;
 
-    assert((total < 0) || (avail <= total));
+  while (i < j) {
+    // INVARIANT:
+    //[0, i) < pos_next
+    //[i, j) ?
+    //[j, jj)  > pos_next
 
-    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
+    Cluster** const k = i + (j - i) / 2;
+    assert(k < jj);
 
-    //interrogate curr cluster
+    Cluster* const pNext = *k;
+    assert(pNext);
+    assert(pNext->m_index < 0);
 
-    pos = pCurr->m_element_start;
+    // const long long pos_ = pNext->m_pos;
+    // assert(pos_);
+    // pos = pos_ * ((pos_ < 0) ? -1 : 1);
 
-    if (pCurr->m_element_size >= 0)
-        pos += pCurr->m_element_size;
+    pos = pNext->GetPosition();
+
+    if (pos < off_next)
+      i = k + 1;
+    else if (pos > off_next)
+      j = k;
     else
-    {
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
+      return pNext;
+  }
 
-        long long result = GetUIntLength(m_pReader, pos, len);
+  assert(i == j);
 
-        if (result < 0)  //error
-            return static_cast<long>(result);
+  Cluster* const pNext = Cluster::Create(this, -1, off_next);
+  assert(pNext);
 
-        if (result > 0)  //weird
-            return E_BUFFER_NOT_FULL;
+  const ptrdiff_t idx_next = i - m_clusters;  // insertion position
 
-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
-            return E_FILE_FORMAT_INVALID;
+  PreloadCluster(pNext, idx_next);
+  assert(m_clusters);
+  assert(idx_next < m_clusterSize);
+  assert(m_clusters[idx_next] == pNext);
 
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
-
-        const long long id = ReadUInt(m_pReader, pos, len);
-
-        if (id != 0x0F43B675)  //weird: not Cluster ID
-            return -1;
-
-        pos += len;  //consume ID
-
-        //Read Size
-
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
-
-        result = GetUIntLength(m_pReader, pos, len);
-
-        if (result < 0)  //error
-            return static_cast<long>(result);
-
-        if (result > 0)  //weird
-            return E_BUFFER_NOT_FULL;
-
-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
-
-        const long long size = ReadUInt(m_pReader, pos, len);
-
-        if (size < 0) //error
-            return static_cast<long>(size);
-
-        pos += len;  //consume size field
-
-        const long long unknown_size = (1LL << (7 * len)) - 1;
-
-        if (size == unknown_size)          //TODO: should never happen
-            return E_FILE_FORMAT_INVALID;  //TODO: resolve this
-
-        //assert((pCurr->m_size <= 0) || (pCurr->m_size == size));
-
-        if ((segment_stop >= 0) && ((pos + size) > segment_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        //Pos now points to start of payload
-
-        pos += size;  //consume payload (that is, the current cluster)
-        assert((segment_stop < 0) || (pos <= segment_stop));
-
-        //By consuming the payload, we are assuming that the curr
-        //cluster isn't interesting.  That is, we don't bother checking
-        //whether the payload of the curr cluster is less than what
-        //happens to be available (obtained via IMkvReader::Length).
-        //Presumably the caller has already dispensed with the current
-        //cluster, and really does want the next cluster.
-    }
-
-    //pos now points to just beyond the last fully-loaded cluster
-
-    for (;;)
-    {
-        const long status = DoParseNext(pResult, pos, len);
-
-        if (status <= 1)
-            return status;
-    }
+  return pNext;
 }
 
+long Segment::ParseNext(const Cluster* pCurr, const Cluster*& pResult,
+                        long long& pos, long& len) {
+  assert(pCurr);
+  assert(!pCurr->EOS());
+  assert(m_clusters);
 
-long Segment::DoParseNext(
-    const Cluster*& pResult,
-    long long& pos,
-    long& len)
-{
-    long long total, avail;
+  pResult = 0;
 
-    long status = m_pReader->Length(&total, &avail);
+  if (pCurr->m_index >= 0) {  // loaded (not merely preloaded)
+    assert(m_clusters[pCurr->m_index] == pCurr);
 
-    if (status < 0)  //error
-        return status;
+    const long next_idx = pCurr->m_index + 1;
 
-    assert((total < 0) || (avail <= total));
+    if (next_idx < m_clusterCount) {
+      pResult = m_clusters[next_idx];
+      return 0;  // success
+    }
 
-    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
+    // curr cluster is last among loaded
 
-    //Parse next cluster.  This is strictly a parsing activity.
-    //Creation of a new cluster object happens later, after the
-    //parsing is done.
+    const long result = LoadCluster(pos, len);
 
-    long long off_next = 0;
-    long long cluster_size = -1;
+    if (result < 0)  // error or underflow
+      return result;
 
-    for (;;)
+    if (result > 0)  // no more clusters
     {
-        if ((total >= 0) && (pos >= total))
-            return 1;  //EOF
+      // pResult = &m_eos;
+      return 1;
+    }
 
-        if ((segment_stop >= 0) && (pos >= segment_stop))
-            return 1;  //EOF
+    pResult = GetLast();
+    return 0;  // success
+  }
 
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
+  assert(m_pos > 0);
 
-        long long result = GetUIntLength(m_pReader, pos, len);
+  long long total, avail;
 
-        if (result < 0)  //error
-            return static_cast<long>(result);
+  long status = m_pReader->Length(&total, &avail);
 
-        if (result > 0)  //weird
-            return E_BUFFER_NOT_FULL;
+  if (status < 0)  // error
+    return status;
 
-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
-            return E_FILE_FORMAT_INVALID;
+  assert((total < 0) || (avail <= total));
 
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
+  const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
 
-        const long long idpos = pos;             //absolute
-        const long long idoff = pos - m_start;   //relative
+  // interrogate curr cluster
 
-        const long long id = ReadUInt(m_pReader, idpos, len);  //absolute
+  pos = pCurr->m_element_start;
 
-        if (id < 0)  //error
-            return static_cast<long>(id);
+  if (pCurr->m_element_size >= 0)
+    pos += pCurr->m_element_size;
+  else {
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
+    }
 
-        if (id == 0)  //weird
-            return -1;  //generic error
+    long long result = GetUIntLength(m_pReader, pos, len);
 
-        pos += len;  //consume ID
+    if (result < 0)  // error
+      return static_cast<long>(result);
 
-        //Read Size
+    if (result > 0)  // weird
+      return E_BUFFER_NOT_FULL;
 
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
+      return E_FILE_FORMAT_INVALID;
 
-        result = GetUIntLength(m_pReader, pos, len);
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
 
-        if (result < 0)  //error
-            return static_cast<long>(result);
+    const long long id = ReadUInt(m_pReader, pos, len);
 
-        if (result > 0)  //weird
-            return E_BUFFER_NOT_FULL;
+    if (id != 0x0F43B675)  // weird: not Cluster ID
+      return -1;
 
-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
-            return E_FILE_FORMAT_INVALID;
+    pos += len;  // consume ID
 
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
+    // Read Size
 
-        const long long size = ReadUInt(m_pReader, pos, len);
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
+    }
 
-        if (size < 0)  //error
-            return static_cast<long>(size);
+    result = GetUIntLength(m_pReader, pos, len);
 
-        pos += len;  //consume length of size of element
+    if (result < 0)  // error
+      return static_cast<long>(result);
 
-        //Pos now points to start of payload
+    if (result > 0)  // weird
+      return E_BUFFER_NOT_FULL;
 
-        if (size == 0)  //weird
-            continue;
+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
+      return E_FILE_FORMAT_INVALID;
 
-        const long long unknown_size = (1LL << (7 * len)) - 1;
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
 
-        if ((segment_stop >= 0) &&
-            (size != unknown_size) &&
-            ((pos + size) > segment_stop))
-        {
-            return E_FILE_FORMAT_INVALID;
-        }
+    const long long size = ReadUInt(m_pReader, pos, len);
 
-        if (id == 0x0C53BB6B)  //Cues ID
-        {
-            if (size == unknown_size)
-                return E_FILE_FORMAT_INVALID;
+    if (size < 0)  // error
+      return static_cast<long>(size);
 
-            const long long element_stop = pos + size;
+    pos += len;  // consume size field
 
-            if ((segment_stop >= 0) && (element_stop > segment_stop))
-                return E_FILE_FORMAT_INVALID;
+    const long long unknown_size = (1LL << (7 * len)) - 1;
 
-            const long long element_start = idpos;
-            const long long element_size = element_stop - element_start;
+    if (size == unknown_size)  // TODO: should never happen
+      return E_FILE_FORMAT_INVALID;  // TODO: resolve this
 
-            if (m_pCues == NULL)
-            {
-                m_pCues = new Cues(this,
-                                    pos,
-                                    size,
-                                    element_start,
-                                    element_size);
-                assert(m_pCues);  //TODO
-            }
+    // assert((pCurr->m_size <= 0) || (pCurr->m_size == size));
 
-            pos += size;  //consume payload
-            assert((segment_stop < 0) || (pos <= segment_stop));
+    if ((segment_stop >= 0) && ((pos + size) > segment_stop))
+      return E_FILE_FORMAT_INVALID;
 
-            continue;
-        }
+    // Pos now points to start of payload
 
-        if (id != 0x0F43B675)  //not a Cluster ID
-        {
-            if (size == unknown_size)
-                return E_FILE_FORMAT_INVALID;
+    pos += size;  // consume payload (that is, the current cluster)
+    assert((segment_stop < 0) || (pos <= segment_stop));
 
-            pos += size;  //consume payload
-            assert((segment_stop < 0) || (pos <= segment_stop));
+    // By consuming the payload, we are assuming that the curr
+    // cluster isn't interesting.  That is, we don't bother checking
+    // whether the payload of the curr cluster is less than what
+    // happens to be available (obtained via IMkvReader::Length).
+    // Presumably the caller has already dispensed with the current
+    // cluster, and really does want the next cluster.
+  }
 
-            continue;
-        }
+  // pos now points to just beyond the last fully-loaded cluster
 
-#if 0 //this is commented-out to support incremental cluster parsing
+  for (;;) {
+    const long status = DoParseNext(pResult, pos, len);
+
+    if (status <= 1)
+      return status;
+  }
+}
+
+long Segment::DoParseNext(const Cluster*& pResult, long long& pos, long& len) {
+  long long total, avail;
+
+  long status = m_pReader->Length(&total, &avail);
+
+  if (status < 0)  // error
+    return status;
+
+  assert((total < 0) || (avail <= total));
+
+  const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
+
+  // Parse next cluster.  This is strictly a parsing activity.
+  // Creation of a new cluster object happens later, after the
+  // parsing is done.
+
+  long long off_next = 0;
+  long long cluster_size = -1;
+
+  for (;;) {
+    if ((total >= 0) && (pos >= total))
+      return 1;  // EOF
+
+    if ((segment_stop >= 0) && (pos >= segment_stop))
+      return 1;  // EOF
+
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
+    }
+
+    long long result = GetUIntLength(m_pReader, pos, len);
+
+    if (result < 0)  // error
+      return static_cast<long>(result);
+
+    if (result > 0)  // weird
+      return E_BUFFER_NOT_FULL;
+
+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
+      return E_FILE_FORMAT_INVALID;
+
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
+
+    const long long idpos = pos;  // absolute
+    const long long idoff = pos - m_start;  // relative
+
+    const long long id = ReadUInt(m_pReader, idpos, len);  // absolute
+
+    if (id < 0)  // error
+      return static_cast<long>(id);
+
+    if (id == 0)  // weird
+      return -1;  // generic error
+
+    pos += len;  // consume ID
+
+    // Read Size
+
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
+    }
+
+    result = GetUIntLength(m_pReader, pos, len);
+
+    if (result < 0)  // error
+      return static_cast<long>(result);
+
+    if (result > 0)  // weird
+      return E_BUFFER_NOT_FULL;
+
+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
+      return E_FILE_FORMAT_INVALID;
+
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
+
+    const long long size = ReadUInt(m_pReader, pos, len);
+
+    if (size < 0)  // error
+      return static_cast<long>(size);
+
+    pos += len;  // consume length of size of element
+
+    // Pos now points to start of payload
+
+    if (size == 0)  // weird
+      continue;
+
+    const long long unknown_size = (1LL << (7 * len)) - 1;
+
+    if ((segment_stop >= 0) && (size != unknown_size) &&
+        ((pos + size) > segment_stop)) {
+      return E_FILE_FORMAT_INVALID;
+    }
+
+    if (id == 0x0C53BB6B) {  // Cues ID
+      if (size == unknown_size)
+        return E_FILE_FORMAT_INVALID;
+
+      const long long element_stop = pos + size;
+
+      if ((segment_stop >= 0) && (element_stop > segment_stop))
+        return E_FILE_FORMAT_INVALID;
+
+      const long long element_start = idpos;
+      const long long element_size = element_stop - element_start;
+
+      if (m_pCues == NULL) {
+        m_pCues = new Cues(this, pos, size, element_start, element_size);
+        assert(m_pCues);  // TODO
+      }
+
+      pos += size;  // consume payload
+      assert((segment_stop < 0) || (pos <= segment_stop));
+
+      continue;
+    }
+
+    if (id != 0x0F43B675) {  // not a Cluster ID
+      if (size == unknown_size)
+        return E_FILE_FORMAT_INVALID;
+
+      pos += size;  // consume payload
+      assert((segment_stop < 0) || (pos <= segment_stop));
+
+      continue;
+    }
+
+#if 0  // this is commented-out to support incremental cluster parsing
         len = static_cast<long>(size);
 
         if (element_stop > avail)
             return E_BUFFER_NOT_FULL;
 #endif
 
-        //We have a cluster.
+    // We have a cluster.
 
-        off_next = idoff;
+    off_next = idoff;
 
-        if (size != unknown_size)
-            cluster_size = size;
+    if (size != unknown_size)
+      cluster_size = size;
 
+    break;
+  }
+
+  assert(off_next > 0);  // have cluster
+
+  // We have parsed the next cluster.
+  // We have not created a cluster object yet.  What we need
+  // to do now is determine whether it has already be preloaded
+  //(in which case, an object for this cluster has already been
+  // created), and if not, create a new cluster object.
+
+  Cluster** const ii = m_clusters + m_clusterCount;
+  Cluster** i = ii;
+
+  Cluster** const jj = ii + m_clusterPreloadCount;
+  Cluster** j = jj;
+
+  while (i < j) {
+    // INVARIANT:
+    //[0, i) < pos_next
+    //[i, j) ?
+    //[j, jj)  > pos_next
+
+    Cluster** const k = i + (j - i) / 2;
+    assert(k < jj);
+
+    const Cluster* const pNext = *k;
+    assert(pNext);
+    assert(pNext->m_index < 0);
+
+    pos = pNext->GetPosition();
+    assert(pos >= 0);
+
+    if (pos < off_next)
+      i = k + 1;
+    else if (pos > off_next)
+      j = k;
+    else {
+      pResult = pNext;
+      return 0;  // success
+    }
+  }
+
+  assert(i == j);
+
+  long long pos_;
+  long len_;
+
+  status = Cluster::HasBlockEntries(this, off_next, pos_, len_);
+
+  if (status < 0) {  // error or underflow
+    pos = pos_;
+    len = len_;
+
+    return status;
+  }
+
+  if (status > 0) {  // means ""found at least one block entry""
+    Cluster* const pNext = Cluster::Create(this,
+                                           -1,  // preloaded
+                                           off_next);
+    // element_size);
+    assert(pNext);
+
+    const ptrdiff_t idx_next = i - m_clusters;  // insertion position
+
+    PreloadCluster(pNext, idx_next);
+    assert(m_clusters);
+    assert(idx_next < m_clusterSize);
+    assert(m_clusters[idx_next] == pNext);
+
+    pResult = pNext;
+    return 0;  // success
+  }
+
+  // status == 0 means ""no block entries found""
+
+  if (cluster_size < 0) {  // unknown size
+    const long long payload_pos = pos;  // absolute pos of cluster payload
+
+    for (;;) {  // determine cluster size
+      if ((total >= 0) && (pos >= total))
         break;
-    }
 
-    assert(off_next > 0);  //have cluster
+      if ((segment_stop >= 0) && (pos >= segment_stop))
+        break;  // no more clusters
 
-    //We have parsed the next cluster.
-    //We have not created a cluster object yet.  What we need
-    //to do now is determine whether it has already be preloaded
-    //(in which case, an object for this cluster has already been
-    //created), and if not, create a new cluster object.
+      // Read ID
 
-    Cluster** const ii = m_clusters + m_clusterCount;
-    Cluster** i = ii;
+      if ((pos + 1) > avail) {
+        len = 1;
+        return E_BUFFER_NOT_FULL;
+      }
 
-    Cluster** const jj = ii + m_clusterPreloadCount;
-    Cluster** j = jj;
+      long long result = GetUIntLength(m_pReader, pos, len);
 
-    while (i < j)
-    {
-        //INVARIANT:
-        //[0, i) < pos_next
-        //[i, j) ?
-        //[j, jj)  > pos_next
+      if (result < 0)  // error
+        return static_cast<long>(result);
 
-        Cluster** const k = i + (j - i) / 2;
-        assert(k < jj);
+      if (result > 0)  // weird
+        return E_BUFFER_NOT_FULL;
 
-        const Cluster* const pNext = *k;
-        assert(pNext);
-        assert(pNext->m_index < 0);
+      if ((segment_stop >= 0) && ((pos + len) > segment_stop))
+        return E_FILE_FORMAT_INVALID;
 
-        pos = pNext->GetPosition();
-        assert(pos >= 0);
+      if ((pos + len) > avail)
+        return E_BUFFER_NOT_FULL;
 
-        if (pos < off_next)
-            i = k + 1;
-        else if (pos > off_next)
-            j = k;
-        else
-        {
-            pResult = pNext;
-            return 0;  //success
-        }
-    }
+      const long long idpos = pos;
+      const long long id = ReadUInt(m_pReader, idpos, len);
 
-    assert(i == j);
+      if (id < 0)  // error (or underflow)
+        return static_cast<long>(id);
 
-    long long pos_;
-    long len_;
+      // This is the distinguished set of ID's we use to determine
+      // that we have exhausted the sub-element's inside the cluster
+      // whose ID we parsed earlier.
 
-    status = Cluster::HasBlockEntries(this, off_next, pos_, len_);
+      if (id == 0x0F43B675)  // Cluster ID
+        break;
 
-    if (status < 0)  //error or underflow
-    {
-        pos = pos_;
-        len = len_;
+      if (id == 0x0C53BB6B)  // Cues ID
+        break;
 
-        return status;
-    }
+      pos += len;  // consume ID (of sub-element)
 
-    if (status > 0)  //means ""found at least one block entry""
-    {
-        Cluster* const pNext = Cluster::Create(this,
-                                                -1,   //preloaded
-                                                off_next);
-                                                //element_size);
-        assert(pNext);
+      // Read Size
 
-        const ptrdiff_t idx_next = i - m_clusters;  //insertion position
+      if ((pos + 1) > avail) {
+        len = 1;
+        return E_BUFFER_NOT_FULL;
+      }
 
-        PreloadCluster(pNext, idx_next);
-        assert(m_clusters);
-        assert(idx_next < m_clusterSize);
-        assert(m_clusters[idx_next] == pNext);
+      result = GetUIntLength(m_pReader, pos, len);
 
-        pResult = pNext;
-        return 0;  //success
-    }
+      if (result < 0)  // error
+        return static_cast<long>(result);
 
-    //status == 0 means ""no block entries found""
+      if (result > 0)  // weird
+        return E_BUFFER_NOT_FULL;
 
-    if (cluster_size < 0)  //unknown size
-    {
-        const long long payload_pos = pos;  //absolute pos of cluster payload
+      if ((segment_stop >= 0) && ((pos + len) > segment_stop))
+        return E_FILE_FORMAT_INVALID;
 
-        for (;;)  //determine cluster size
-        {
-            if ((total >= 0) && (pos >= total))
-                break;
+      if ((pos + len) > avail)
+        return E_BUFFER_NOT_FULL;
 
-            if ((segment_stop >= 0) && (pos >= segment_stop))
-                break;  //no more clusters
+      const long long size = ReadUInt(m_pReader, pos, len);
 
-            //Read ID
+      if (size < 0)  // error
+        return static_cast<long>(size);
 
-            if ((pos + 1) > avail)
-            {
-                len = 1;
-                return E_BUFFER_NOT_FULL;
-            }
+      pos += len;  // consume size field of element
 
-            long long result = GetUIntLength(m_pReader, pos, len);
+      // pos now points to start of sub-element's payload
 
-            if (result < 0)  //error
-                return static_cast<long>(result);
+      if (size == 0)  // weird
+        continue;
 
-            if (result > 0)  //weird
-                return E_BUFFER_NOT_FULL;
+      const long long unknown_size = (1LL << (7 * len)) - 1;
 
-            if ((segment_stop >= 0) && ((pos + len) > segment_stop))
-                return E_FILE_FORMAT_INVALID;
+      if (size == unknown_size)
+        return E_FILE_FORMAT_INVALID;  // not allowed for sub-elements
 
-            if ((pos + len) > avail)
-                return E_BUFFER_NOT_FULL;
+      if ((segment_stop >= 0) && ((pos + size) > segment_stop))  // weird
+        return E_FILE_FORMAT_INVALID;
 
-            const long long idpos = pos;
-            const long long id = ReadUInt(m_pReader, idpos, len);
+      pos += size;  // consume payload of sub-element
+      assert((segment_stop < 0) || (pos <= segment_stop));
+    }  // determine cluster size
 
-            if (id < 0)  //error (or underflow)
-                return static_cast<long>(id);
+    cluster_size = pos - payload_pos;
+    assert(cluster_size >= 0);  // TODO: handle cluster_size = 0
 
-            //This is the distinguished set of ID's we use to determine
-            //that we have exhausted the sub-element's inside the cluster
-            //whose ID we parsed earlier.
+    pos = payload_pos;  // reset and re-parse original cluster
+  }
 
-            if (id == 0x0F43B675)  //Cluster ID
-                break;
+  pos += cluster_size;  // consume payload
+  assert((segment_stop < 0) || (pos <= segment_stop));
 
-            if (id == 0x0C53BB6B)  //Cues ID
-                break;
-
-            pos += len;  //consume ID (of sub-element)
-
-            //Read Size
-
-            if ((pos + 1) > avail)
-            {
-                len = 1;
-                return E_BUFFER_NOT_FULL;
-            }
-
-            result = GetUIntLength(m_pReader, pos, len);
-
-            if (result < 0)  //error
-                return static_cast<long>(result);
-
-            if (result > 0)  //weird
-                return E_BUFFER_NOT_FULL;
-
-            if ((segment_stop >= 0) && ((pos + len) > segment_stop))
-                return E_FILE_FORMAT_INVALID;
-
-            if ((pos + len) > avail)
-                return E_BUFFER_NOT_FULL;
-
-            const long long size = ReadUInt(m_pReader, pos, len);
-
-            if (size < 0)  //error
-                return static_cast<long>(size);
-
-            pos += len;  //consume size field of element
-
-            //pos now points to start of sub-element's payload
-
-            if (size == 0)  //weird
-                continue;
-
-            const long long unknown_size = (1LL << (7 * len)) - 1;
-
-            if (size == unknown_size)
-                return E_FILE_FORMAT_INVALID;  //not allowed for sub-elements
-
-            if ((segment_stop >= 0) && ((pos + size) > segment_stop))  //weird
-                return E_FILE_FORMAT_INVALID;
-
-            pos += size;  //consume payload of sub-element
-            assert((segment_stop < 0) || (pos <= segment_stop));
-        }  //determine cluster size
-
-        cluster_size = pos - payload_pos;
-        assert(cluster_size >= 0);  //TODO: handle cluster_size = 0
-
-        pos = payload_pos;  //reset and re-parse original cluster
-    }
-
-    pos += cluster_size;  //consume payload
-    assert((segment_stop < 0) || (pos <= segment_stop));
-
-    return 2;             //try to find a cluster that follows next
+  return 2;  // try to find a cluster that follows next
 }
 
+const Cluster* Segment::FindCluster(long long time_ns) const {
+  if ((m_clusters == NULL) || (m_clusterCount <= 0))
+    return &m_eos;
 
-const Cluster* Segment::FindCluster(long long time_ns) const
-{
-    if ((m_clusters == NULL) || (m_clusterCount <= 0))
-        return &m_eos;
+  {
+    Cluster* const pCluster = m_clusters[0];
+    assert(pCluster);
+    assert(pCluster->m_index == 0);
 
-    {
-        Cluster* const pCluster = m_clusters[0];
-        assert(pCluster);
-        assert(pCluster->m_index == 0);
+    if (time_ns <= pCluster->GetTime())
+      return pCluster;
+  }
 
-        if (time_ns <= pCluster->GetTime())
-            return pCluster;
-    }
+  // Binary search of cluster array
 
-    //Binary search of cluster array
+  long i = 0;
+  long j = m_clusterCount;
 
-    long i = 0;
-    long j = m_clusterCount;
+  while (i < j) {
+    // INVARIANT:
+    //[0, i) <= time_ns
+    //[i, j) ?
+    //[j, m_clusterCount)  > time_ns
 
-    while (i < j)
-    {
-        //INVARIANT:
-        //[0, i) <= time_ns
-        //[i, j) ?
-        //[j, m_clusterCount)  > time_ns
-
-        const long k = i + (j - i) / 2;
-        assert(k < m_clusterCount);
-
-        Cluster* const pCluster = m_clusters[k];
-        assert(pCluster);
-        assert(pCluster->m_index == k);
-
-        const long long t = pCluster->GetTime();
-
-        if (t <= time_ns)
-            i = k + 1;
-        else
-            j = k;
-
-        assert(i <= j);
-    }
-
-    assert(i == j);
-    assert(i > 0);
-    assert(i <= m_clusterCount);
-
-    const long k = i - 1;
+    const long k = i + (j - i) / 2;
+    assert(k < m_clusterCount);
 
     Cluster* const pCluster = m_clusters[k];
     assert(pCluster);
     assert(pCluster->m_index == k);
-    assert(pCluster->GetTime() <= time_ns);
 
-    return pCluster;
+    const long long t = pCluster->GetTime();
+
+    if (t <= time_ns)
+      i = k + 1;
+    else
+      j = k;
+
+    assert(i <= j);
+  }
+
+  assert(i == j);
+  assert(i > 0);
+  assert(i <= m_clusterCount);
+
+  const long k = i - 1;
+
+  Cluster* const pCluster = m_clusters[k];
+  assert(pCluster);
+  assert(pCluster->m_index == k);
+  assert(pCluster->GetTime() <= time_ns);
+
+  return pCluster;
 }
 
-
 #if 0
 const BlockEntry* Segment::Seek(
     long long time_ns,
@@ -4059,8 +3674,7 @@

 
     Cluster** const j = i + m_clusterCount;
 
-    if (pTrack->GetType() == 2)  //audio
-    {
+    if (pTrack->GetType() == 2) {  //audio
         //TODO: we could decide to use cues for this, as we do for video.
         //But we only use it for video because looking around for a keyframe
         //can get expensive.  Audio doesn't require anything special so a
@@ -4179,7 +3793,6 @@

 }
 #endif
 
-
 #if 0
 bool Segment::SearchCues(
     long long time_ns,
@@ -4210,845 +3823,593 @@

 }
 #endif
 
+const Tracks* Segment::GetTracks() const { return m_pTracks; }
 
-const Tracks* Segment::GetTracks() const
-{
-    return m_pTracks;
+const SegmentInfo* Segment::GetInfo() const { return m_pInfo; }
+
+const Cues* Segment::GetCues() const { return m_pCues; }
+
+const Chapters* Segment::GetChapters() const { return m_pChapters; }
+
+const SeekHead* Segment::GetSeekHead() const { return m_pSeekHead; }
+
+long long Segment::GetDuration() const {
+  assert(m_pInfo);
+  return m_pInfo->GetDuration();
 }
 
+Chapters::Chapters(Segment* pSegment, long long payload_start,
+                   long long payload_size, long long element_start,
+                   long long element_size)
+    : m_pSegment(pSegment),
+      m_start(payload_start),
+      m_size(payload_size),
+      m_element_start(element_start),
+      m_element_size(element_size),
+      m_editions(NULL),
+      m_editions_size(0),
+      m_editions_count(0) {}
 
-const SegmentInfo* Segment::GetInfo() const
-{
-    return m_pInfo;
+Chapters::~Chapters() {
+  while (m_editions_count > 0) {
+    Edition& e = m_editions[--m_editions_count];
+    e.Clear();
+  }
 }
 
+long Chapters::Parse() {
+  IMkvReader* const pReader = m_pSegment->m_pReader;
 
-const Cues* Segment::GetCues() const
-{
-    return m_pCues;
-}
+  long long pos = m_start;  // payload start
+  const long long stop = pos + m_size;  // payload stop
 
+  while (pos < stop) {
+    long long id, size;
 
-const Chapters* Segment::GetChapters() const
-{
-  return m_pChapters;
-}
+    long status = ParseElementHeader(pReader, pos, stop, id, size);
 
+    if (status < 0)  // error
+      return status;
 
-const SeekHead* Segment::GetSeekHead() const
-{
-    return m_pSeekHead;
-}
+    if (size == 0)  // weird
+      continue;
 
+    if (id == 0x05B9) {  // EditionEntry ID
+      status = ParseEdition(pos, size);
 
-long long Segment::GetDuration() const
-{
-    assert(m_pInfo);
-    return m_pInfo->GetDuration();
-}
-
-
-Chapters::Chapters(
-    Segment* pSegment,
-    long long payload_start,
-    long long payload_size,
-    long long element_start,
-    long long element_size) :
-    m_pSegment(pSegment),
-    m_start(payload_start),
-    m_size(payload_size),
-    m_element_start(element_start),
-    m_element_size(element_size),
-    m_editions(NULL),
-    m_editions_size(0),
-    m_editions_count(0)
-{
-}
-
-
-Chapters::~Chapters()
-{
-    while (m_editions_count > 0)
-    {
-        Edition& e = m_editions[--m_editions_count];
-        e.Clear();
-    }
-}
-
-
-long Chapters::Parse()
-{
-    IMkvReader* const pReader = m_pSegment->m_pReader;
-
-    long long pos = m_start;  // payload start
-    const long long stop = pos + m_size;  // payload stop
-
-    while (pos < stop)
-    {
-        long long id, size;
-
-        long status = ParseElementHeader(
-                        pReader,
-                        pos,
-                        stop,
-                        id,
-                        size);
-
-        if (status < 0)  // error
-            return status;
-
-        if (size == 0)  // weird
-            continue;
-
-        if (id == 0x05B9)  // EditionEntry ID
-        {
-            status = ParseEdition(pos, size);
-
-            if (status < 0)  // error
-                return status;
-        }
-
-        pos += size;
-        assert(pos <= stop);
+      if (status < 0)  // error
+        return status;
     }
 
-    assert(pos == stop);
-    return 0;
+    pos += size;
+    assert(pos <= stop);
+  }
+
+  assert(pos == stop);
+  return 0;
 }
 
+int Chapters::GetEditionCount() const { return m_editions_count; }
 
-int Chapters::GetEditionCount() const
-{
-    return m_editions_count;
+const Chapters::Edition* Chapters::GetEdition(int idx) const {
+  if (idx < 0)
+    return NULL;
+
+  if (idx >= m_editions_count)
+    return NULL;
+
+  return m_editions + idx;
 }
 
+bool Chapters::ExpandEditionsArray() {
+  if (m_editions_size > m_editions_count)
+    return true;  // nothing else to do
 
-const Chapters::Edition* Chapters::GetEdition(int idx) const
-{
-    if (idx < 0)
-        return NULL;
+  const int size = (m_editions_size == 0) ? 1 : 2 * m_editions_size;
 
-    if (idx >= m_editions_count)
-        return NULL;
+  Edition* const editions = new (std::nothrow) Edition[size];
 
-    return m_editions + idx;
+  if (editions == NULL)
+    return false;
+
+  for (int idx = 0; idx < m_editions_count; ++idx) {
+    m_editions[idx].ShallowCopy(editions[idx]);
+  }
+
+  delete[] m_editions;
+  m_editions = editions;
+
+  m_editions_size = size;
+  return true;
 }
 
+long Chapters::ParseEdition(long long pos, long long size) {
+  if (!ExpandEditionsArray())
+    return -1;
 
-bool Chapters::ExpandEditionsArray()
-{
-    if (m_editions_size > m_editions_count)
-        return true;  // nothing else to do
+  Edition& e = m_editions[m_editions_count++];
+  e.Init();
 
-    const int size = (m_editions_size == 0) ? 1 : 2 * m_editions_size;
+  return e.Parse(m_pSegment->m_pReader, pos, size);
+}
 
-    Edition* const editions = new (std::nothrow) Edition[size];
+Chapters::Edition::Edition() {}
 
-    if (editions == NULL)
-        return false;
+Chapters::Edition::~Edition() {}
 
-    for (int idx = 0; idx < m_editions_count; ++idx)
-    {
-        m_editions[idx].ShallowCopy(editions[idx]);
+int Chapters::Edition::GetAtomCount() const { return m_atoms_count; }
+
+const Chapters::Atom* Chapters::Edition::GetAtom(int index) const {
+  if (index < 0)
+    return NULL;
+
+  if (index >= m_atoms_count)
+    return NULL;
+
+  return m_atoms + index;
+}
+
+void Chapters::Edition::Init() {
+  m_atoms = NULL;
+  m_atoms_size = 0;
+  m_atoms_count = 0;
+}
+
+void Chapters::Edition::ShallowCopy(Edition& rhs) const {
+  rhs.m_atoms = m_atoms;
+  rhs.m_atoms_size = m_atoms_size;
+  rhs.m_atoms_count = m_atoms_count;
+}
+
+void Chapters::Edition::Clear() {
+  while (m_atoms_count > 0) {
+    Atom& a = m_atoms[--m_atoms_count];
+    a.Clear();
+  }
+
+  delete[] m_atoms;
+  m_atoms = NULL;
+
+  m_atoms_size = 0;
+}
+
+long Chapters::Edition::Parse(IMkvReader* pReader, long long pos,
+                              long long size) {
+  const long long stop = pos + size;
+
+  while (pos < stop) {
+    long long id, size;
+
+    long status = ParseElementHeader(pReader, pos, stop, id, size);
+
+    if (status < 0)  // error
+      return status;
+
+    if (size == 0)  // weird
+      continue;
+
+    if (id == 0x36) {  // Atom ID
+      status = ParseAtom(pReader, pos, size);
+
+      if (status < 0)  // error
+        return status;
     }
 
-    delete[] m_editions;
-    m_editions = editions;
+    pos += size;
+    assert(pos <= stop);
+  }
 
-    m_editions_size = size;
-    return true;
+  assert(pos == stop);
+  return 0;
 }
 
+long Chapters::Edition::ParseAtom(IMkvReader* pReader, long long pos,
+                                  long long size) {
+  if (!ExpandAtomsArray())
+    return -1;
 
-long Chapters::ParseEdition(
-    long long pos,
-    long long size)
-{
-    if (!ExpandEditionsArray())
-        return -1;
+  Atom& a = m_atoms[m_atoms_count++];
+  a.Init();
 
-    Edition& e = m_editions[m_editions_count++];
-    e.Init();
-
-    return e.Parse(m_pSegment->m_pReader, pos, size);
+  return a.Parse(pReader, pos, size);
 }
 
+bool Chapters::Edition::ExpandAtomsArray() {
+  if (m_atoms_size > m_atoms_count)
+    return true;  // nothing else to do
 
-Chapters::Edition::Edition()
-{
+  const int size = (m_atoms_size == 0) ? 1 : 2 * m_atoms_size;
+
+  Atom* const atoms = new (std::nothrow) Atom[size];
+
+  if (atoms == NULL)
+    return false;
+
+  for (int idx = 0; idx < m_atoms_count; ++idx) {
+    m_atoms[idx].ShallowCopy(atoms[idx]);
+  }
+
+  delete[] m_atoms;
+  m_atoms = atoms;
+
+  m_atoms_size = size;
+  return true;
 }
 
+Chapters::Atom::Atom() {}
 
-Chapters::Edition::~Edition()
-{
+Chapters::Atom::~Atom() {}
+
+unsigned long long Chapters::Atom::GetUID() const { return m_uid; }
+
+const char* Chapters::Atom::GetStringUID() const { return m_string_uid; }
+
+long long Chapters::Atom::GetStartTimecode() const { return m_start_timecode; }
+
+long long Chapters::Atom::GetStopTimecode() const { return m_stop_timecode; }
+
+long long Chapters::Atom::GetStartTime(const Chapters* pChapters) const {
+  return GetTime(pChapters, m_start_timecode);
 }
 
-
-int Chapters::Edition::GetAtomCount() const
-{
-    return m_atoms_count;
+long long Chapters::Atom::GetStopTime(const Chapters* pChapters) const {
+  return GetTime(pChapters, m_stop_timecode);
 }
 
+int Chapters::Atom::GetDisplayCount() const { return m_displays_count; }
 
-const Chapters::Atom* Chapters::Edition::GetAtom(int index) const
-{
-    if (index < 0)
-        return NULL;
+const Chapters::Display* Chapters::Atom::GetDisplay(int index) const {
+  if (index < 0)
+    return NULL;
 
-    if (index >= m_atoms_count)
-        return NULL;
+  if (index >= m_displays_count)
+    return NULL;
 
-    return m_atoms + index;
+  return m_displays + index;
 }
 
+void Chapters::Atom::Init() {
+  m_string_uid = NULL;
+  m_uid = 0;
+  m_start_timecode = -1;
+  m_stop_timecode = -1;
 
-void Chapters::Edition::Init()
-{
-    m_atoms = NULL;
-    m_atoms_size = 0;
-    m_atoms_count = 0;
+  m_displays = NULL;
+  m_displays_size = 0;
+  m_displays_count = 0;
 }
 
+void Chapters::Atom::ShallowCopy(Atom& rhs) const {
+  rhs.m_string_uid = m_string_uid;
+  rhs.m_uid = m_uid;
+  rhs.m_start_timecode = m_start_timecode;
+  rhs.m_stop_timecode = m_stop_timecode;
 
-void Chapters::Edition::ShallowCopy(Edition& rhs) const
-{
-    rhs.m_atoms = m_atoms;
-    rhs.m_atoms_size = m_atoms_size;
-    rhs.m_atoms_count = m_atoms_count;
+  rhs.m_displays = m_displays;
+  rhs.m_displays_size = m_displays_size;
+  rhs.m_displays_count = m_displays_count;
 }
 
+void Chapters::Atom::Clear() {
+  delete[] m_string_uid;
+  m_string_uid = NULL;
 
-void Chapters::Edition::Clear()
-{
-    while (m_atoms_count > 0)
-    {
-        Atom& a = m_atoms[--m_atoms_count];
-        a.Clear();
+  while (m_displays_count > 0) {
+    Display& d = m_displays[--m_displays_count];
+    d.Clear();
+  }
+
+  delete[] m_displays;
+  m_displays = NULL;
+
+  m_displays_size = 0;
+}
+
+long Chapters::Atom::Parse(IMkvReader* pReader, long long pos, long long size) {
+  const long long stop = pos + size;
+
+  while (pos < stop) {
+    long long id, size;
+
+    long status = ParseElementHeader(pReader, pos, stop, id, size);
+
+    if (status < 0)  // error
+      return status;
+
+    if (size == 0)  // weird
+      continue;
+
+    if (id == 0x00) {  // Display ID
+      status = ParseDisplay(pReader, pos, size);
+
+      if (status < 0)  // error
+        return status;
+    } else if (id == 0x1654) {  // StringUID ID
+      status = UnserializeString(pReader, pos, size, m_string_uid);
+
+      if (status < 0)  // error
+        return status;
+    } else if (id == 0x33C4) {  // UID ID
+      long long val;
+      status = UnserializeInt(pReader, pos, size, val);
+
+      if (val < 0)  // error
+        return status;
+
+      m_uid = static_cast<unsigned long long>(val);
+    } else if (id == 0x11) {  // TimeStart ID
+      const long long val = UnserializeUInt(pReader, pos, size);
+
+      if (val < 0)  // error
+        return static_cast<long>(val);
+
+      m_start_timecode = val;
+    } else if (id == 0x12) {  // TimeEnd ID
+      const long long val = UnserializeUInt(pReader, pos, size);
+
+      if (val < 0)  // error
+        return static_cast<long>(val);
+
+      m_stop_timecode = val;
     }
 
-    delete[] m_atoms;
-    m_atoms = NULL;
+    pos += size;
+    assert(pos <= stop);
+  }
 
-    m_atoms_size = 0;
+  assert(pos == stop);
+  return 0;
 }
 
+long long Chapters::Atom::GetTime(const Chapters* pChapters,
+                                  long long timecode) {
+  if (pChapters == NULL)
+    return -1;
 
-long Chapters::Edition::Parse(
-    IMkvReader* pReader,
-    long long pos,
-    long long size)
-{
-    const long long stop = pos + size;
+  Segment* const pSegment = pChapters->m_pSegment;
 
-    while (pos < stop)
-    {
-        long long id, size;
+  if (pSegment == NULL)  // weird
+    return -1;
 
-        long status = ParseElementHeader(
-                        pReader,
-                        pos,
-                        stop,
-                        id,
-                        size);
+  const SegmentInfo* const pInfo = pSegment->GetInfo();
 
-        if (status < 0)  // error
-            return status;
+  if (pInfo == NULL)
+    return -1;
 
-        if (size == 0)  // weird
-            continue;
+  const long long timecode_scale = pInfo->GetTimeCodeScale();
 
-        if (id == 0x36)  // Atom ID
-        {
-            status = ParseAtom(pReader, pos, size);
+  if (timecode_scale < 1)  // weird
+    return -1;
 
-            if (status < 0)  // error
-                return status;
-        }
+  if (timecode < 0)
+    return -1;
 
-        pos += size;
-        assert(pos <= stop);
+  const long long result = timecode_scale * timecode;
+
+  return result;
+}
+
+long Chapters::Atom::ParseDisplay(IMkvReader* pReader, long long pos,
+                                  long long size) {
+  if (!ExpandDisplaysArray())
+    return -1;
+
+  Display& d = m_displays[m_displays_count++];
+  d.Init();
+
+  return d.Parse(pReader, pos, size);
+}
+
+bool Chapters::Atom::ExpandDisplaysArray() {
+  if (m_displays_size > m_displays_count)
+    return true;  // nothing else to do
+
+  const int size = (m_displays_size == 0) ? 1 : 2 * m_displays_size;
+
+  Display* const displays = new (std::nothrow) Display[size];
+
+  if (displays == NULL)
+    return false;
+
+  for (int idx = 0; idx < m_displays_count; ++idx) {
+    m_displays[idx].ShallowCopy(displays[idx]);
+  }
+
+  delete[] m_displays;
+  m_displays = displays;
+
+  m_displays_size = size;
+  return true;
+}
+
+Chapters::Display::Display() {}
+
+Chapters::Display::~Display() {}
+
+const char* Chapters::Display::GetString() const { return m_string; }
+
+const char* Chapters::Display::GetLanguage() const { return m_language; }
+
+const char* Chapters::Display::GetCountry() const { return m_country; }
+
+void Chapters::Display::Init() {
+  m_string = NULL;
+  m_language = NULL;
+  m_country = NULL;
+}
+
+void Chapters::Display::ShallowCopy(Display& rhs) const {
+  rhs.m_string = m_string;
+  rhs.m_language = m_language;
+  rhs.m_country = m_country;
+}
+
+void Chapters::Display::Clear() {
+  delete[] m_string;
+  m_string = NULL;
+
+  delete[] m_language;
+  m_language = NULL;
+
+  delete[] m_country;
+  m_country = NULL;
+}
+
+long Chapters::Display::Parse(IMkvReader* pReader, long long pos,
+                              long long size) {
+  const long long stop = pos + size;
+
+  while (pos < stop) {
+    long long id, size;
+
+    long status = ParseElementHeader(pReader, pos, stop, id, size);
+
+    if (status < 0)  // error
+      return status;
+
+    if (size == 0)  // weird
+      continue;
+
+    if (id == 0x05) {  // ChapterString ID
+      status = UnserializeString(pReader, pos, size, m_string);
+
+      if (status)
+        return status;
+    } else if (id == 0x037C) {  // ChapterLanguage ID
+      status = UnserializeString(pReader, pos, size, m_language);
+
+      if (status)
+        return status;
+    } else if (id == 0x037E) {  // ChapterCountry ID
+      status = UnserializeString(pReader, pos, size, m_country);
+
+      if (status)
+        return status;
     }
 
-    assert(pos == stop);
-    return 0;
+    pos += size;
+    assert(pos <= stop);
+  }
+
+  assert(pos == stop);
+  return 0;
 }
 
+SegmentInfo::SegmentInfo(Segment* pSegment, long long start, long long size_,
+                         long long element_start, long long element_size)
+    : m_pSegment(pSegment),
+      m_start(start),
+      m_size(size_),
+      m_element_start(element_start),
+      m_element_size(element_size),
+      m_pMuxingAppAsUTF8(NULL),
+      m_pWritingAppAsUTF8(NULL),
+      m_pTitleAsUTF8(NULL) {}
 
-long Chapters::Edition::ParseAtom(
-    IMkvReader* pReader,
-    long long pos,
-    long long size)
-{
-    if (!ExpandAtomsArray())
-        return -1;
+SegmentInfo::~SegmentInfo() {
+  delete[] m_pMuxingAppAsUTF8;
+  m_pMuxingAppAsUTF8 = NULL;
 
-    Atom& a = m_atoms[m_atoms_count++];
-    a.Init();
+  delete[] m_pWritingAppAsUTF8;
+  m_pWritingAppAsUTF8 = NULL;
 
-    return a.Parse(pReader, pos, size);
+  delete[] m_pTitleAsUTF8;
+  m_pTitleAsUTF8 = NULL;
 }
 
+long SegmentInfo::Parse() {
+  assert(m_pMuxingAppAsUTF8 == NULL);
+  assert(m_pWritingAppAsUTF8 == NULL);
+  assert(m_pTitleAsUTF8 == NULL);
 
-bool Chapters::Edition::ExpandAtomsArray()
-{
-    if (m_atoms_size > m_atoms_count)
-        return true;  // nothing else to do
+  IMkvReader* const pReader = m_pSegment->m_pReader;
 
-    const int size = (m_atoms_size == 0) ? 1 : 2 * m_atoms_size;
+  long long pos = m_start;
+  const long long stop = m_start + m_size;
 
-    Atom* const atoms = new (std::nothrow) Atom[size];
+  m_timecodeScale = 1000000;
+  m_duration = -1;
 
-    if (atoms == NULL)
-        return false;
+  while (pos < stop) {
+    long long id, size;
 
-    for (int idx = 0; idx < m_atoms_count; ++idx)
-    {
-        m_atoms[idx].ShallowCopy(atoms[idx]);
+    const long status = ParseElementHeader(pReader, pos, stop, id, size);
+
+    if (status < 0)  // error
+      return status;
+
+    if (id == 0x0AD7B1) {  // Timecode Scale
+      m_timecodeScale = UnserializeUInt(pReader, pos, size);
+
+      if (m_timecodeScale <= 0)
+        return E_FILE_FORMAT_INVALID;
+    } else if (id == 0x0489) {  // Segment duration
+      const long status = UnserializeFloat(pReader, pos, size, m_duration);
+
+      if (status < 0)
+        return status;
+
+      if (m_duration < 0)
+        return E_FILE_FORMAT_INVALID;
+    } else if (id == 0x0D80) {  // MuxingApp
+      const long status =
+          UnserializeString(pReader, pos, size, m_pMuxingAppAsUTF8);
+
+      if (status)
+        return status;
+    } else if (id == 0x1741) {  // WritingApp
+      const long status =
+          UnserializeString(pReader, pos, size, m_pWritingAppAsUTF8);
+
+      if (status)
+        return status;
+    } else if (id == 0x3BA9) {  // Title
+      const long status = UnserializeString(pReader, pos, size, m_pTitleAsUTF8);
+
+      if (status)
+        return status;
     }
 
-    delete[] m_atoms;
-    m_atoms = atoms;
+    pos += size;
+    assert(pos <= stop);
+  }
 
-    m_atoms_size = size;
-    return true;
+  assert(pos == stop);
+
+  return 0;
 }
 
+long long SegmentInfo::GetTimeCodeScale() const { return m_timecodeScale; }
 
-Chapters::Atom::Atom()
-{
+long long SegmentInfo::GetDuration() const {
+  if (m_duration < 0)
+    return -1;
+
+  assert(m_timecodeScale >= 1);
+
+  const double dd = double(m_duration) * double(m_timecodeScale);
+  const long long d = static_cast<long long>(dd);
+
+  return d;
 }
 
-
-Chapters::Atom::~Atom()
-{
+const char* SegmentInfo::GetMuxingAppAsUTF8() const {
+  return m_pMuxingAppAsUTF8;
 }
 
-
-unsigned long long Chapters::Atom::GetUID() const
-{
-    return m_uid;
+const char* SegmentInfo::GetWritingAppAsUTF8() const {
+  return m_pWritingAppAsUTF8;
 }
 
-
-const char* Chapters::Atom::GetStringUID() const
-{
-    return m_string_uid;
-}
-
-
-long long Chapters::Atom::GetStartTimecode() const
-{
-    return m_start_timecode;
-}
-
-
-long long Chapters::Atom::GetStopTimecode() const
-{
-    return m_stop_timecode;
-}
-
-
-long long Chapters::Atom::GetStartTime(const Chapters* pChapters) const
-{
-    return GetTime(pChapters, m_start_timecode);
-}
-
-
-long long Chapters::Atom::GetStopTime(const Chapters* pChapters) const
-{
-    return GetTime(pChapters, m_stop_timecode);
-}
-
-
-int Chapters::Atom::GetDisplayCount() const
-{
-    return m_displays_count;
-}
-
-
-const Chapters::Display* Chapters::Atom::GetDisplay(int index) const
-{
-    if (index < 0)
-        return NULL;
-
-    if (index >= m_displays_count)
-        return NULL;
-
-    return m_displays + index;
-}
-
-
-void Chapters::Atom::Init()
-{
-    m_string_uid = NULL;
-    m_uid = 0;
-    m_start_timecode = -1;
-    m_stop_timecode = -1;
-
-    m_displays = NULL;
-    m_displays_size = 0;
-    m_displays_count = 0;
-}
-
-
-void Chapters::Atom::ShallowCopy(Atom& rhs) const
-{
-    rhs.m_string_uid = m_string_uid;
-    rhs.m_uid = m_uid;
-    rhs.m_start_timecode = m_start_timecode;
-    rhs.m_stop_timecode = m_stop_timecode;
-
-    rhs.m_displays = m_displays;
-    rhs.m_displays_size = m_displays_size;
-    rhs.m_displays_count = m_displays_count;
-}
-
-
-void Chapters::Atom::Clear()
-{
-    delete[] m_string_uid;
-    m_string_uid = NULL;
-
-    while (m_displays_count > 0)
-    {
-        Display& d = m_displays[--m_displays_count];
-        d.Clear();
-    }
-
-    delete[] m_displays;
-    m_displays = NULL;
-
-    m_displays_size = 0;
-}
-
-
-long Chapters::Atom::Parse(
-    IMkvReader* pReader,
-    long long pos,
-    long long size)
-{
-    const long long stop = pos + size;
-
-    while (pos < stop)
-    {
-        long long id, size;
-
-        long status = ParseElementHeader(
-                        pReader,
-                        pos,
-                        stop,
-                        id,
-                        size);
-
-        if (status < 0)  // error
-            return status;
-
-        if (size == 0)  // weird
-            continue;
-
-        if (id == 0x00)  // Display ID
-        {
-            status = ParseDisplay(pReader, pos, size);
-
-            if (status < 0)  // error
-                return status;
-        }
-        else if (id == 0x1654)  // StringUID ID
-        {
-            status = UnserializeString(pReader, pos, size, m_string_uid);
-
-            if (status < 0)  // error
-                return status;
-        }
-        else if (id == 0x33C4)  // UID ID
-        {
-            long long val;
-            status = UnserializeInt(pReader, pos, size, val);
-
-            if (status < 0)  // error
-                return status;
-
-            m_uid = val;
-        }
-        else if (id == 0x11)  // TimeStart ID
-        {
-            const long long val = UnserializeUInt(pReader, pos, size);
-
-            if (val < 0)  // error
-                return static_cast<long>(val);
-
-            m_start_timecode = val;
-        }
-        else if (id == 0x12)  // TimeEnd ID
-        {
-            const long long val = UnserializeUInt(pReader, pos, size);
-
-            if (val < 0)  // error
-                return static_cast<long>(val);
-
-            m_stop_timecode = val;
-        }
-
-        pos += size;
-        assert(pos <= stop);
-    }
-
-    assert(pos == stop);
-    return 0;
-}
-
-
-long long Chapters::Atom::GetTime(
-    const Chapters* pChapters,
-    long long timecode)
-{
-    if (pChapters == NULL)
-        return -1;
-
-    Segment* const pSegment = pChapters->m_pSegment;
-
-    if (pSegment == NULL)  // weird
-        return -1;
-
-    const SegmentInfo* const pInfo = pSegment->GetInfo();
-
-    if (pInfo == NULL)
-        return -1;
-
-    const long long timecode_scale = pInfo->GetTimeCodeScale();
-
-    if (timecode_scale < 1)  // weird
-        return -1;
-
-    if (timecode < 0)
-        return -1;
-
-    const long long result = timecode_scale * timecode;
-
-    return result;
-}
-
-
-long Chapters::Atom::ParseDisplay(
-    IMkvReader* pReader,
-    long long pos,
-    long long size)
-{
-    if (!ExpandDisplaysArray())
-        return -1;
-
-    Display& d = m_displays[m_displays_count++];
-    d.Init();
-
-    return d.Parse(pReader, pos, size);
-}
-
-
-bool Chapters::Atom::ExpandDisplaysArray()
-{
-    if (m_displays_size > m_displays_count)
-        return true;  // nothing else to do
-
-    const int size = (m_displays_size == 0) ? 1 : 2 * m_displays_size;
-
-    Display* const displays = new (std::nothrow) Display[size];
-
-    if (displays == NULL)
-        return false;
-
-    for (int idx = 0; idx < m_displays_count; ++idx)
-    {
-        m_displays[idx].ShallowCopy(displays[idx]);
-    }
-
-    delete[] m_displays;
-    m_displays = displays;
-
-    m_displays_size = size;
-    return true;
-}
-
-
-Chapters::Display::Display()
-{
-}
-
-
-Chapters::Display::~Display()
-{
-}
-
-
-const char* Chapters::Display::GetString() const
-{
-    return m_string;
-}
-
-
-const char* Chapters::Display::GetLanguage() const
-{
-    return m_language;
-}
-
-
-const char* Chapters::Display::GetCountry() const
-{
-    return m_country;
-}
-
-
-void Chapters::Display::Init()
-{
-    m_string = NULL;
-    m_language = NULL;
-    m_country = NULL;
-}
-
-
-void Chapters::Display::ShallowCopy(Display& rhs) const
-{
-    rhs.m_string = m_string;
-    rhs.m_language = m_language;
-    rhs.m_country = m_country;
-}
-
-
-void Chapters::Display::Clear()
-{
-    delete[] m_string;
-    m_string = NULL;
-
-    delete[] m_language;
-    m_language = NULL;
-
-    delete[] m_country;
-    m_country = NULL;
-}
-
-
-long Chapters::Display::Parse(
-    IMkvReader* pReader,
-    long long pos,
-    long long size)
-{
-    const long long stop = pos + size;
-
-    while (pos < stop)
-    {
-        long long id, size;
-
-        long status = ParseElementHeader(
-                        pReader,
-                        pos,
-                        stop,
-                        id,
-                        size);
-
-        if (status < 0)  // error
-            return status;
-
-        if (size == 0)  // weird
-            continue;
-
-        if (id == 0x05)  // ChapterString ID
-        {
-            status = UnserializeString(pReader, pos, size, m_string);
-
-            if (status)
-              return status;
-        }
-        else if (id == 0x037C)  // ChapterLanguage ID
-        {
-            status = UnserializeString(pReader, pos, size, m_language);
-
-            if (status)
-              return status;
-        }
-        else if (id == 0x037E)  // ChapterCountry ID
-        {
-            status = UnserializeString(pReader, pos, size, m_country);
-
-            if (status)
-              return status;
-        }
-
-        pos += size;
-        assert(pos <= stop);
-    }
-
-    assert(pos == stop);
-    return 0;
-}
-
-
-SegmentInfo::SegmentInfo(
-    Segment* pSegment,
-    long long start,
-    long long size_,
-    long long element_start,
-    long long element_size) :
-    m_pSegment(pSegment),
-    m_start(start),
-    m_size(size_),
-    m_element_start(element_start),
-    m_element_size(element_size),
-    m_pMuxingAppAsUTF8(NULL),
-    m_pWritingAppAsUTF8(NULL),
-    m_pTitleAsUTF8(NULL)
-{
-}
-
-SegmentInfo::~SegmentInfo()
-{
-    delete[] m_pMuxingAppAsUTF8;
-    m_pMuxingAppAsUTF8 = NULL;
-
-    delete[] m_pWritingAppAsUTF8;
-    m_pWritingAppAsUTF8 = NULL;
-
-    delete[] m_pTitleAsUTF8;
-    m_pTitleAsUTF8 = NULL;
-}
-
-
-long SegmentInfo::Parse()
-{
-    assert(m_pMuxingAppAsUTF8 == NULL);
-    assert(m_pWritingAppAsUTF8 == NULL);
-    assert(m_pTitleAsUTF8 == NULL);
-
-    IMkvReader* const pReader = m_pSegment->m_pReader;
-
-    long long pos = m_start;
-    const long long stop = m_start + m_size;
-
-    m_timecodeScale = 1000000;
-    m_duration = -1;
-
-    while (pos < stop)
-    {
-        long long id, size;
-
-        const long status = ParseElementHeader(
-                                pReader,
-                                pos,
-                                stop,
-                                id,
-                                size);
-
-        if (status < 0)  //error
-            return status;
-
-        if (id == 0x0AD7B1)  //Timecode Scale
-        {
-            m_timecodeScale = UnserializeUInt(pReader, pos, size);
-
-            if (m_timecodeScale <= 0)
-                return E_FILE_FORMAT_INVALID;
-        }
-        else if (id == 0x0489)  //Segment duration
-        {
-            const long status = UnserializeFloat(
-                                    pReader,
-                                    pos,
-                                    size,
-                                    m_duration);
-
-            if (status < 0)
-                return status;
-
-            if (m_duration < 0)
-                return E_FILE_FORMAT_INVALID;
-        }
-        else if (id == 0x0D80)  //MuxingApp
-        {
-            const long status = UnserializeString(
-                                    pReader,
-                                    pos,
-                                    size,
-                                    m_pMuxingAppAsUTF8);
-
-            if (status)
-                return status;
-        }
-        else if (id == 0x1741)  //WritingApp
-        {
-            const long status = UnserializeString(
-                                    pReader,
-                                    pos,
-                                    size,
-                                    m_pWritingAppAsUTF8);
-
-            if (status)
-                return status;
-        }
-        else if (id == 0x3BA9)  //Title
-        {
-            const long status = UnserializeString(
-                                    pReader,
-                                    pos,
-                                    size,
-                                    m_pTitleAsUTF8);
-
-            if (status)
-                return status;
-        }
-
-        pos += size;
-        assert(pos <= stop);
-    }
-
-    assert(pos == stop);
-
-    return 0;
-}
-
-
-long long SegmentInfo::GetTimeCodeScale() const
-{
-    return m_timecodeScale;
-}
-
-
-long long SegmentInfo::GetDuration() const
-{
-    if (m_duration < 0)
-        return -1;
-
-    assert(m_timecodeScale >= 1);
-
-    const double dd = double(m_duration) * double(m_timecodeScale);
-    const long long d = static_cast<long long>(dd);
-
-    return d;
-}
-
-const char* SegmentInfo::GetMuxingAppAsUTF8() const
-{
-    return m_pMuxingAppAsUTF8;
-}
-
-
-const char* SegmentInfo::GetWritingAppAsUTF8() const
-{
-    return m_pWritingAppAsUTF8;
-}
-
-const char* SegmentInfo::GetTitleAsUTF8() const
-{
-    return m_pTitleAsUTF8;
-}
+const char* SegmentInfo::GetTitleAsUTF8() const { return m_pTitleAsUTF8; }
 
 ///////////////////////////////////////////////////////////////
 // ContentEncoding element
 ContentEncoding::ContentCompression::ContentCompression()
-    : algo(0),
-      settings(NULL),
-      settings_len(0) {
-}
+    : algo(0), settings(NULL), settings_len(0) {}
 
 ContentEncoding::ContentCompression::~ContentCompression() {
-  delete [] settings;
+  delete[] settings;
 }
 
 ContentEncoding::ContentEncryption::ContentEncryption()
@@ -5060,13 +4421,12 @@

       sig_key_id(NULL),
       sig_key_id_len(0),
       sig_algo(0),
-      sig_hash_algo(0) {
-}
+      sig_hash_algo(0) {}
 
 ContentEncoding::ContentEncryption::~ContentEncryption() {
-  delete [] key_id;
-  delete [] signature;
-  delete [] sig_key_id;
+  delete[] key_id;
+  delete[] signature;
+  delete[] sig_key_id;
 }
 
 ContentEncoding::ContentEncoding()
@@ -5076,8 +4436,7 @@

       encryption_entries_end_(NULL),
       encoding_order_(0),
       encoding_scope_(1),
-      encoding_type_(0) {
-}
+      encoding_type_(0) {}
 
 ContentEncoding::~ContentEncoding() {
   ContentCompression** comp_i = compression_entries_;
@@ -5088,7 +4447,7 @@

     delete comp;
   }
 
-  delete [] compression_entries_;
+  delete[] compression_entries_;
 
   ContentEncryption** enc_i = encryption_entries_;
   ContentEncryption** const enc_j = encryption_entries_end_;
@@ -5098,10 +4457,9 @@

     delete enc;
   }
 
-  delete [] encryption_entries_;
+  delete[] encryption_entries_;
 }
 
-
 const ContentEncoding::ContentCompression*
 ContentEncoding::GetCompressionByIndex(unsigned long idx) const {
   const ptrdiff_t count = compression_entries_end_ - compression_entries_;
@@ -5120,8 +4478,8 @@

   return static_cast<unsigned long>(count);
 }
 
-const ContentEncoding::ContentEncryption*
-ContentEncoding::GetEncryptionByIndex(unsigned long idx) const {
+const ContentEncoding::ContentEncryption* ContentEncoding::GetEncryptionByIndex(
+    unsigned long idx) const {
   const ptrdiff_t count = encryption_entries_end_ - encryption_entries_;
   assert(count >= 0);
 
@@ -5139,9 +4497,7 @@

 }
 
 long ContentEncoding::ParseContentEncAESSettingsEntry(
-    long long start,
-    long long size,
-    IMkvReader* pReader,
+    long long start, long long size, IMkvReader* pReader,
     ContentEncAESSettings* aes) {
   assert(pReader);
   assert(aes);
@@ -5151,12 +4507,8 @@

 
   while (pos < stop) {
     long long id, size;
-    const long status = ParseElementHeader(pReader,
-                                           pos,
-                                           stop,
-                                           id,
-                                           size);
-    if (status < 0)  //error
+    const long status = ParseElementHeader(pReader, pos, stop, id, size);
+    if (status < 0)  // error
       return status;
 
     if (id == 0x7E8) {
@@ -5166,15 +4518,14 @@

         return E_FILE_FORMAT_INVALID;
     }
 
-    pos += size;  //consume payload
+    pos += size;  // consume payload
     assert(pos <= stop);
   }
 
   return 0;
 }
 
-long ContentEncoding::ParseContentEncodingEntry(long long start,
-                                                long long size,
+long ContentEncoding::ParseContentEncodingEntry(long long start, long long size,
                                                 IMkvReader* pReader) {
   assert(pReader);
 
@@ -5187,12 +4538,8 @@

 
   while (pos < stop) {
     long long id, size;
-    const long status = ParseElementHeader(pReader,
-                                           pos,
-                                           stop,
-                                           id,
-                                           size);
-    if (status < 0)  //error
+    const long status = ParseElementHeader(pReader, pos, stop, id, size);
+    if (status < 0)  // error
       return status;
 
     if (id == 0x1034)  // ContentCompression ID
@@ -5201,7 +4548,7 @@

     if (id == 0x1035)  // ContentEncryption ID
       ++encryption_count;
 
-    pos += size;  //consume payload
+    pos += size;  // consume payload
     assert(pos <= stop);
   }
 
@@ -5210,7 +4557,7 @@

 
   if (compression_count > 0) {
     compression_entries_ =
-        new (std::nothrow) ContentCompression*[compression_count];
+        new (std::nothrow) ContentCompression* [compression_count];
     if (!compression_entries_)
       return -1;
     compression_entries_end_ = compression_entries_;
@@ -5218,9 +4565,9 @@

 
   if (encryption_count > 0) {
     encryption_entries_ =
-        new (std::nothrow) ContentEncryption*[encryption_count];
+        new (std::nothrow) ContentEncryption* [encryption_count];
     if (!encryption_entries_) {
-      delete [] compression_entries_;
+      delete[] compression_entries_;
       return -1;
     }
     encryption_entries_end_ = encryption_entries_;
@@ -5229,12 +4576,8 @@

   pos = start;
   while (pos < stop) {
     long long id, size;
-    long status = ParseElementHeader(pReader,
-                                     pos,
-                                     stop,
-                                     id,
-                                     size);
-    if (status < 0)  //error
+    long status = ParseElementHeader(pReader, pos, stop, id, size);
+    if (status < 0)  // error
       return status;
 
     if (id == 0x1031) {
@@ -5251,7 +4594,7 @@

     } else if (id == 0x1034) {
       // ContentCompression ID
       ContentCompression* const compression =
-        new (std::nothrow) ContentCompression();
+          new (std::nothrow) ContentCompression();
       if (!compression)
         return -1;
 
@@ -5276,7 +4619,7 @@

       *encryption_entries_end_++ = encryption;
     }
 
-    pos += size;  //consume payload
+    pos += size;  // consume payload
     assert(pos <= stop);
   }
 
@@ -5284,11 +4627,9 @@

   return 0;
 }
 
-long ContentEncoding::ParseCompressionEntry(
-    long long start,
-    long long size,
-    IMkvReader* pReader,
-    ContentCompression* compression) {
+long ContentEncoding::ParseCompressionEntry(long long start, long long size,
+                                            IMkvReader* pReader,
+                                            ContentCompression* compression) {
   assert(pReader);
   assert(compression);
 
@@ -5299,12 +4640,8 @@

 
   while (pos < stop) {
     long long id, size;
-    const long status = ParseElementHeader(pReader,
-                                           pos,
-                                           stop,
-                                           id,
-                                           size);
-    if (status < 0)  //error
+    const long status = ParseElementHeader(pReader, pos, stop, id, size);
+    if (status < 0)  // error
       return status;
 
     if (id == 0x254) {
@@ -5325,9 +4662,10 @@

       if (buf == NULL)
         return -1;
 
-      const int read_status = pReader->Read(pos, buflen, buf);
+      const int read_status =
+          pReader->Read(pos, static_cast<long>(buflen), buf);
       if (read_status) {
-        delete [] buf;
+        delete[] buf;
         return status;
       }
 
@@ -5335,7 +4673,7 @@

       compression->settings_len = buflen;
     }
 
-    pos += size;  //consume payload
+    pos += size;  // consume payload
     assert(pos <= stop);
   }
 
@@ -5346,11 +4684,9 @@

   return 0;
 }
 
-long ContentEncoding::ParseEncryptionEntry(
-    long long start,
-    long long size,
-    IMkvReader* pReader,
-    ContentEncryption* encryption) {
+long ContentEncoding::ParseEncryptionEntry(long long start, long long size,
+                                           IMkvReader* pReader,
+                                           ContentEncryption* encryption) {
   assert(pReader);
   assert(encryption);
 
@@ -5359,12 +4695,8 @@

 
   while (pos < stop) {
     long long id, size;
-    const long status = ParseElementHeader(pReader,
-                                           pos,
-                                           stop,
-                                           id,
-                                           size);
-    if (status < 0)  //error
+    const long status = ParseElementHeader(pReader, pos, stop, id, size);
+    if (status < 0)  // error
       return status;
 
     if (id == 0x7E1) {
@@ -5374,7 +4706,7 @@

         return E_FILE_FORMAT_INVALID;
     } else if (id == 0x7E2) {
       // ContentEncKeyID
-      delete[] encryption->key_id;
+      delete[] encryption -> key_id;
       encryption->key_id = NULL;
       encryption->key_id_len = 0;
 
@@ -5387,9 +4719,10 @@

       if (buf == NULL)
         return -1;
 
-      const int read_status = pReader->Read(pos, buflen, buf);
+      const int read_status =
+          pReader->Read(pos, static_cast<long>(buflen), buf);
       if (read_status) {
-        delete [] buf;
+        delete[] buf;
         return status;
       }
 
@@ -5397,7 +4730,7 @@

       encryption->key_id_len = buflen;
     } else if (id == 0x7E3) {
       // ContentSignature
-      delete[] encryption->signature;
+      delete[] encryption -> signature;
       encryption->signature = NULL;
       encryption->signature_len = 0;
 
@@ -5410,9 +4743,10 @@

       if (buf == NULL)
         return -1;
 
-      const int read_status = pReader->Read(pos, buflen, buf);
+      const int read_status =
+          pReader->Read(pos, static_cast<long>(buflen), buf);
       if (read_status) {
-        delete [] buf;
+        delete[] buf;
         return status;
       }
 
@@ -5420,7 +4754,7 @@

       encryption->signature_len = buflen;
     } else if (id == 0x7E4) {
       // ContentSigKeyID
-      delete[] encryption->sig_key_id;
+      delete[] encryption -> sig_key_id;
       encryption->sig_key_id = NULL;
       encryption->sig_key_id_len = 0;
 
@@ -5433,9 +4767,10 @@

       if (buf == NULL)
         return -1;
 
-      const int read_status = pReader->Read(pos, buflen, buf);
+      const int read_status =
+          pReader->Read(pos, static_cast<long>(buflen), buf);
       if (read_status) {
-        delete [] buf;
+        delete[] buf;
         return status;
       }
 
@@ -5450,400 +4785,322 @@

     } else if (id == 0x7E7) {
       // ContentEncAESSettings
       const long status = ParseContentEncAESSettingsEntry(
-          pos,
-          size,
-          pReader,
-          &encryption->aes_settings);
+          pos, size, pReader, &encryption->aes_settings);
       if (status)
         return status;
     }
 
-    pos += size;  //consume payload
+    pos += size;  // consume payload
     assert(pos <= stop);
   }
 
   return 0;
 }
 
-Track::Track(
-    Segment* pSegment,
-    long long element_start,
-    long long element_size) :
-    m_pSegment(pSegment),
-    m_element_start(element_start),
-    m_element_size(element_size),
-    content_encoding_entries_(NULL),
-    content_encoding_entries_end_(NULL)
-{
+Track::Track(Segment* pSegment, long long element_start, long long element_size)
+    : m_pSegment(pSegment),
+      m_element_start(element_start),
+      m_element_size(element_size),
+      content_encoding_entries_(NULL),
+      content_encoding_entries_end_(NULL) {}
+
+Track::~Track() {
+  Info& info = const_cast<Info&>(m_info);
+  info.Clear();
+
+  ContentEncoding** i = content_encoding_entries_;
+  ContentEncoding** const j = content_encoding_entries_end_;
+
+  while (i != j) {
+    ContentEncoding* const encoding = *i++;
+    delete encoding;
+  }
+
+  delete[] content_encoding_entries_;
 }
 
-Track::~Track()
-{
-    Info& info = const_cast<Info&>(m_info);
-    info.Clear();
+long Track::Create(Segment* pSegment, const Info& info, long long element_start,
+                   long long element_size, Track*& pResult) {
+  if (pResult)
+    return -1;
 
-    ContentEncoding** i = content_encoding_entries_;
-    ContentEncoding** const j = content_encoding_entries_end_;
+  Track* const pTrack =
+      new (std::nothrow) Track(pSegment, element_start, element_size);
 
-    while (i != j) {
-        ContentEncoding* const encoding = *i++;
-        delete encoding;
-    }
+  if (pTrack == NULL)
+    return -1;  // generic error
 
-    delete [] content_encoding_entries_;
+  const int status = info.Copy(pTrack->m_info);
+
+  if (status) {  // error
+    delete pTrack;
+    return status;
+  }
+
+  pResult = pTrack;
+  return 0;  // success
 }
 
-long Track::Create(
-    Segment* pSegment,
-    const Info& info,
-    long long element_start,
-    long long element_size,
-    Track*& pResult)
-{
-    if (pResult)
-        return -1;
+Track::Info::Info()
+    : uid(0),
+      defaultDuration(0),
+      codecDelay(0),
+      seekPreRoll(0),
+      nameAsUTF8(NULL),
+      language(NULL),
+      codecId(NULL),
+      codecNameAsUTF8(NULL),
+      codecPrivate(NULL),
+      codecPrivateSize(0),
+      lacing(false) {}
 
-    Track* const pTrack = new (std::nothrow) Track(pSegment,
-                                                   element_start,
-                                                   element_size);
+Track::Info::~Info() { Clear(); }
 
-    if (pTrack == NULL)
-        return -1;  //generic error
+void Track::Info::Clear() {
+  delete[] nameAsUTF8;
+  nameAsUTF8 = NULL;
 
-    const int status = info.Copy(pTrack->m_info);
+  delete[] language;
+  language = NULL;
 
-    if (status)  // error
-    {
-        delete pTrack;
-        return status;
-    }
+  delete[] codecId;
+  codecId = NULL;
 
-    pResult = pTrack;
-    return 0;  //success
+  delete[] codecPrivate;
+  codecPrivate = NULL;
+  codecPrivateSize = 0;
+
+  delete[] codecNameAsUTF8;
+  codecNameAsUTF8 = NULL;
 }
 
-Track::Info::Info():
-    uid(0),
-    defaultDuration(0),
-    codecDelay(0),
-    seekPreRoll(0),
-    nameAsUTF8(NULL),
-    language(NULL),
-    codecId(NULL),
-    codecNameAsUTF8(NULL),
-    codecPrivate(NULL),
-    codecPrivateSize(0),
-    lacing(false)
-{
-}
+int Track::Info::CopyStr(char* Info::*str, Info& dst_) const {
+  if (str == static_cast<char * Info::*>(NULL))
+    return -1;
 
-Track::Info::~Info()
-{
-    Clear();
-}
+  char*& dst = dst_.*str;
 
-void Track::Info::Clear()
-{
-    delete[] nameAsUTF8;
-    nameAsUTF8 = NULL;
+  if (dst)  // should be NULL already
+    return -1;
 
-    delete[] language;
-    language = NULL;
+  const char* const src = this->*str;
 
-    delete[] codecId;
-    codecId = NULL;
-
-    delete[] codecPrivate;
-    codecPrivate = NULL;
-    codecPrivateSize = 0;
-
-    delete[] codecNameAsUTF8;
-    codecNameAsUTF8 = NULL;
-}
-
-int Track::Info::CopyStr(char* Info::*str, Info& dst_) const
-{
-    if (str == static_cast<char* Info::*>(NULL))
-        return -1;
-
-    char*& dst = dst_.*str;
-
-    if (dst)  //should be NULL already
-        return -1;
-
-    const char* const src = this->*str;
-
-    if (src == NULL)
-        return 0;
-
-    const size_t len = strlen(src);
-
-    dst = new (std::nothrow) char[len+1];
-
-    if (dst == NULL)
-        return -1;
-
-    strcpy(dst, src);
-
+  if (src == NULL)
     return 0;
+
+  const size_t len = strlen(src);
+
+  dst = new (std::nothrow) char[len + 1];
+
+  if (dst == NULL)
+    return -1;
+
+  strcpy(dst, src);
+
+  return 0;
 }
 
+int Track::Info::Copy(Info& dst) const {
+  if (&dst == this)
+    return 0;
 
-int Track::Info::Copy(Info& dst) const
-{
-    if (&dst == this)
-        return 0;
+  dst.type = type;
+  dst.number = number;
+  dst.defaultDuration = defaultDuration;
+  dst.codecDelay = codecDelay;
+  dst.seekPreRoll = seekPreRoll;
+  dst.uid = uid;
+  dst.lacing = lacing;
+  dst.settings = settings;
 
-    dst.type = type;
-    dst.number = number;
-    dst.defaultDuration = defaultDuration;
-    dst.codecDelay = codecDelay;
-    dst.seekPreRoll = seekPreRoll;
-    dst.uid = uid;
-    dst.lacing = lacing;
-    dst.settings = settings;
+  // We now copy the string member variables from src to dst.
+  // This involves memory allocation so in principle the operation
+  // can fail (indeed, that's why we have Info::Copy), so we must
+  // report this to the caller.  An error return from this function
+  // therefore implies that the copy was only partially successful.
 
-    //We now copy the string member variables from src to dst.
-    //This involves memory allocation so in principle the operation
-    //can fail (indeed, that's why we have Info::Copy), so we must
-    //report this to the caller.  An error return from this function
-    //therefore implies that the copy was only partially successful.
+  if (int status = CopyStr(&Info::nameAsUTF8, dst))
+    return status;
 
-    if (int status = CopyStr(&Info::nameAsUTF8, dst))
-        return status;
+  if (int status = CopyStr(&Info::language, dst))
+    return status;
 
-    if (int status = CopyStr(&Info::language, dst))
-        return status;
+  if (int status = CopyStr(&Info::codecId, dst))
+    return status;
 
-    if (int status = CopyStr(&Info::codecId, dst))
-        return status;
+  if (int status = CopyStr(&Info::codecNameAsUTF8, dst))
+    return status;
 
-    if (int status = CopyStr(&Info::codecNameAsUTF8, dst))
-        return status;
+  if (codecPrivateSize > 0) {
+    if (codecPrivate == NULL)
+      return -1;
 
-    if (codecPrivateSize > 0)
-    {
-        if (codecPrivate == NULL)
-            return -1;
+    if (dst.codecPrivate)
+      return -1;
 
-        if (dst.codecPrivate)
-            return -1;
+    if (dst.codecPrivateSize != 0)
+      return -1;
 
-        if (dst.codecPrivateSize != 0)
-            return -1;
+    dst.codecPrivate = new (std::nothrow) unsigned char[codecPrivateSize];
 
-        dst.codecPrivate = new (std::nothrow) unsigned char[codecPrivateSize];
+    if (dst.codecPrivate == NULL)
+      return -1;
 
-        if (dst.codecPrivate == NULL)
-            return -1;
+    memcpy(dst.codecPrivate, codecPrivate, codecPrivateSize);
+    dst.codecPrivateSize = codecPrivateSize;
+  }
 
-        memcpy(dst.codecPrivate, codecPrivate, codecPrivateSize);
-        dst.codecPrivateSize = codecPrivateSize;
+  return 0;
+}
+
+const BlockEntry* Track::GetEOS() const { return &m_eos; }
+
+long Track::GetType() const { return m_info.type; }
+
+long Track::GetNumber() const { return m_info.number; }
+
+unsigned long long Track::GetUid() const { return m_info.uid; }
+
+const char* Track::GetNameAsUTF8() const { return m_info.nameAsUTF8; }
+
+const char* Track::GetLanguage() const { return m_info.language; }
+
+const char* Track::GetCodecNameAsUTF8() const { return m_info.codecNameAsUTF8; }
+
+const char* Track::GetCodecId() const { return m_info.codecId; }
+
+const unsigned char* Track::GetCodecPrivate(size_t& size) const {
+  size = m_info.codecPrivateSize;
+  return m_info.codecPrivate;
+}
+
+bool Track::GetLacing() const { return m_info.lacing; }
+
+unsigned long long Track::GetDefaultDuration() const {
+  return m_info.defaultDuration;
+}
+
+unsigned long long Track::GetCodecDelay() const { return m_info.codecDelay; }
+
+unsigned long long Track::GetSeekPreRoll() const { return m_info.seekPreRoll; }
+
+long Track::GetFirst(const BlockEntry*& pBlockEntry) const {
+  const Cluster* pCluster = m_pSegment->GetFirst();
+
+  for (int i = 0;;) {
+    if (pCluster == NULL) {
+      pBlockEntry = GetEOS();
+      return 1;
     }
 
-    return 0;
-}
-
-const BlockEntry* Track::GetEOS() const
-{
-    return &m_eos;
-}
-
-long Track::GetType() const
-{
-    return m_info.type;
-}
-
-long Track::GetNumber() const
-{
-    return m_info.number;
-}
-
-unsigned long long Track::GetUid() const
-{
-    return m_info.uid;
-}
-
-const char* Track::GetNameAsUTF8() const
-{
-    return m_info.nameAsUTF8;
-}
-
-const char* Track::GetLanguage() const
-{
-    return m_info.language;
-}
-
-const char* Track::GetCodecNameAsUTF8() const
-{
-    return m_info.codecNameAsUTF8;
-}
-
-
-const char* Track::GetCodecId() const
-{
-    return m_info.codecId;
-}
-
-const unsigned char* Track::GetCodecPrivate(size_t& size) const
-{
-    size = m_info.codecPrivateSize;
-    return m_info.codecPrivate;
-}
-
-
-bool Track::GetLacing() const
-{
-    return m_info.lacing;
-}
-
-unsigned long long Track::GetDefaultDuration() const
-{
-    return m_info.defaultDuration;
-}
-
-unsigned long long Track::GetCodecDelay() const
-{
-    return m_info.codecDelay;
-}
-
-unsigned long long Track::GetSeekPreRoll() const
-{
-    return m_info.seekPreRoll;
-}
-
-long Track::GetFirst(const BlockEntry*& pBlockEntry) const
-{
-    const Cluster* pCluster = m_pSegment->GetFirst();
-
-    for (int i = 0; ; )
-    {
-        if (pCluster == NULL)
-        {
-            pBlockEntry = GetEOS();
-            return 1;
-        }
-
-        if (pCluster->EOS())
-        {
+    if (pCluster->EOS()) {
 #if 0
-            if (m_pSegment->Unparsed() <= 0)  //all clusters have been loaded
-            {
+            if (m_pSegment->Unparsed() <= 0) {  //all clusters have been loaded
                 pBlockEntry = GetEOS();
                 return 1;
             }
 #else
-            if (m_pSegment->DoneParsing())
-            {
-                pBlockEntry = GetEOS();
-                return 1;
-            }
+      if (m_pSegment->DoneParsing()) {
+        pBlockEntry = GetEOS();
+        return 1;
+      }
 #endif
 
-            pBlockEntry = 0;
-            return E_BUFFER_NOT_FULL;
-        }
-
-        long status = pCluster->GetFirst(pBlockEntry);
-
-        if (status < 0)  //error
-            return status;
-
-        if (pBlockEntry == 0)  //empty cluster
-        {
-            pCluster = m_pSegment->GetNext(pCluster);
-            continue;
-        }
-
-        for (;;)
-        {
-            const Block* const pBlock = pBlockEntry->GetBlock();
-            assert(pBlock);
-
-            const long long tn = pBlock->GetTrackNumber();
-
-            if ((tn == m_info.number) && VetEntry(pBlockEntry))
-                return 0;
-
-            const BlockEntry* pNextEntry;
-
-            status = pCluster->GetNext(pBlockEntry, pNextEntry);
-
-            if (status < 0)  //error
-                return status;
-
-            if (pNextEntry == 0)
-                break;
-
-            pBlockEntry = pNextEntry;
-        }
-
-        ++i;
-
-        if (i >= 100)
-            break;
-
-        pCluster = m_pSegment->GetNext(pCluster);
+      pBlockEntry = 0;
+      return E_BUFFER_NOT_FULL;
     }
 
-    //NOTE: if we get here, it means that we didn't find a block with
-    //a matching track number.  We interpret that as an error (which
-    //might be too conservative).
+    long status = pCluster->GetFirst(pBlockEntry);
 
-    pBlockEntry = GetEOS();  //so we can return a non-NULL value
-    return 1;
-}
+    if (status < 0)  // error
+      return status;
 
+    if (pBlockEntry == 0) {  // empty cluster
+      pCluster = m_pSegment->GetNext(pCluster);
+      continue;
+    }
 
-long Track::GetNext(
-    const BlockEntry* pCurrEntry,
-    const BlockEntry*& pNextEntry) const
-{
-    assert(pCurrEntry);
-    assert(!pCurrEntry->EOS());  //?
+    for (;;) {
+      const Block* const pBlock = pBlockEntry->GetBlock();
+      assert(pBlock);
 
-    const Block* const pCurrBlock = pCurrEntry->GetBlock();
-    assert(pCurrBlock && pCurrBlock->GetTrackNumber() == m_info.number);
-    if (!pCurrBlock || pCurrBlock->GetTrackNumber() != m_info.number)
-        return -1;
+      const long long tn = pBlock->GetTrackNumber();
 
-    const Cluster* pCluster = pCurrEntry->GetCluster();
-    assert(pCluster);
-    assert(!pCluster->EOS());
+      if ((tn == m_info.number) && VetEntry(pBlockEntry))
+        return 0;
 
-    long status = pCluster->GetNext(pCurrEntry, pNextEntry);
+      const BlockEntry* pNextEntry;
 
-    if (status < 0)  //error
+      status = pCluster->GetNext(pBlockEntry, pNextEntry);
+
+      if (status < 0)  // error
         return status;
 
-    for (int i = 0; ; )
-    {
-        while (pNextEntry)
-        {
-            const Block* const pNextBlock = pNextEntry->GetBlock();
-            assert(pNextBlock);
+      if (pNextEntry == 0)
+        break;
 
-            if (pNextBlock->GetTrackNumber() == m_info.number)
-                return 0;
+      pBlockEntry = pNextEntry;
+    }
 
-            pCurrEntry = pNextEntry;
+    ++i;
 
-            status = pCluster->GetNext(pCurrEntry, pNextEntry);
+    if (i >= 100)
+      break;
 
-            if (status < 0) //error
-                return status;
-        }
+    pCluster = m_pSegment->GetNext(pCluster);
+  }
 
-        pCluster = m_pSegment->GetNext(pCluster);
+  // NOTE: if we get here, it means that we didn't find a block with
+  // a matching track number.  We interpret that as an error (which
+  // might be too conservative).
 
-        if (pCluster == NULL)
-        {
-            pNextEntry = GetEOS();
-            return 1;
-        }
+  pBlockEntry = GetEOS();  // so we can return a non-NULL value
+  return 1;
+}
 
-        if (pCluster->EOS())
-        {
+long Track::GetNext(const BlockEntry* pCurrEntry,
+                    const BlockEntry*& pNextEntry) const {
+  assert(pCurrEntry);
+  assert(!pCurrEntry->EOS());  //?
+
+  const Block* const pCurrBlock = pCurrEntry->GetBlock();
+  assert(pCurrBlock && pCurrBlock->GetTrackNumber() == m_info.number);
+  if (!pCurrBlock || pCurrBlock->GetTrackNumber() != m_info.number)
+    return -1;
+
+  const Cluster* pCluster = pCurrEntry->GetCluster();
+  assert(pCluster);
+  assert(!pCluster->EOS());
+
+  long status = pCluster->GetNext(pCurrEntry, pNextEntry);
+
+  if (status < 0)  // error
+    return status;
+
+  for (int i = 0;;) {
+    while (pNextEntry) {
+      const Block* const pNextBlock = pNextEntry->GetBlock();
+      assert(pNextBlock);
+
+      if (pNextBlock->GetTrackNumber() == m_info.number)
+        return 0;
+
+      pCurrEntry = pNextEntry;
+
+      status = pCluster->GetNext(pCurrEntry, pNextEntry);
+
+      if (status < 0)  // error
+        return status;
+    }
+
+    pCluster = m_pSegment->GetNext(pCluster);
+
+    if (pCluster == NULL) {
+      pNextEntry = GetEOS();
+      return 1;
+    }
+
+    if (pCluster->EOS()) {
 #if 0
             if (m_pSegment->Unparsed() <= 0)   //all clusters have been loaded
             {
@@ -5851,155 +5108,148 @@

                 return 1;
             }
 #else
-            if (m_pSegment->DoneParsing())
-            {
-                pNextEntry = GetEOS();
-                return 1;
-            }
+      if (m_pSegment->DoneParsing()) {
+        pNextEntry = GetEOS();
+        return 1;
+      }
 #endif
 
-            //TODO: there is a potential O(n^2) problem here: we tell the
-            //caller to (pre)load another cluster, which he does, but then he
-            //calls GetNext again, which repeats the same search.  This is
-            //a pathological case, since the only way it can happen is if
-            //there exists a long sequence of clusters none of which contain a
-            // block from this track.  One way around this problem is for the
-            //caller to be smarter when he loads another cluster: don't call
-            //us back until you have a cluster that contains a block from this
-            //track. (Of course, that's not cheap either, since our caller
-            //would have to scan the each cluster as it's loaded, so that
-            //would just push back the problem.)
+      // TODO: there is a potential O(n^2) problem here: we tell the
+      // caller to (pre)load another cluster, which he does, but then he
+      // calls GetNext again, which repeats the same search.  This is
+      // a pathological case, since the only way it can happen is if
+      // there exists a long sequence of clusters none of which contain a
+      // block from this track.  One way around this problem is for the
+      // caller to be smarter when he loads another cluster: don't call
+      // us back until you have a cluster that contains a block from this
+      // track. (Of course, that's not cheap either, since our caller
+      // would have to scan the each cluster as it's loaded, so that
+      // would just push back the problem.)
 
-            pNextEntry = NULL;
-            return E_BUFFER_NOT_FULL;
-        }
-
-        status = pCluster->GetFirst(pNextEntry);
-
-        if (status < 0)  //error
-            return status;
-
-        if (pNextEntry == NULL)  //empty cluster
-            continue;
-
-        ++i;
-
-        if (i >= 100)
-            break;
+      pNextEntry = NULL;
+      return E_BUFFER_NOT_FULL;
     }
 
-    //NOTE: if we get here, it means that we didn't find a block with
-    //a matching track number after lots of searching, so we give
-    //up trying.
+    status = pCluster->GetFirst(pNextEntry);
 
-    pNextEntry = GetEOS();  //so we can return a non-NULL value
-    return 1;
+    if (status < 0)  // error
+      return status;
+
+    if (pNextEntry == NULL)  // empty cluster
+      continue;
+
+    ++i;
+
+    if (i >= 100)
+      break;
+  }
+
+  // NOTE: if we get here, it means that we didn't find a block with
+  // a matching track number after lots of searching, so we give
+  // up trying.
+
+  pNextEntry = GetEOS();  // so we can return a non-NULL value
+  return 1;
 }
 
-bool Track::VetEntry(const BlockEntry* pBlockEntry) const
-{
-    assert(pBlockEntry);
-    const Block* const pBlock = pBlockEntry->GetBlock();
-    assert(pBlock);
-    assert(pBlock->GetTrackNumber() == m_info.number);
-    if (!pBlock || pBlock->GetTrackNumber() != m_info.number)
-        return false;
+bool Track::VetEntry(const BlockEntry* pBlockEntry) const {
+  assert(pBlockEntry);
+  const Block* const pBlock = pBlockEntry->GetBlock();
+  assert(pBlock);
+  assert(pBlock->GetTrackNumber() == m_info.number);
+  if (!pBlock || pBlock->GetTrackNumber() != m_info.number)
+    return false;
 
-    // This function is used during a seek to determine whether the
-    // frame is a valid seek target.  This default function simply
-    // returns true, which means all frames are valid seek targets.
-    // It gets overridden by the VideoTrack class, because only video
-    // keyframes can be used as seek target.
+  // This function is used during a seek to determine whether the
+  // frame is a valid seek target.  This default function simply
+  // returns true, which means all frames are valid seek targets.
+  // It gets overridden by the VideoTrack class, because only video
+  // keyframes can be used as seek target.
 
-    return true;
+  return true;
 }
 
-long Track::Seek(
-    long long time_ns,
-    const BlockEntry*& pResult) const
-{
-    const long status = GetFirst(pResult);
+long Track::Seek(long long time_ns, const BlockEntry*& pResult) const {
+  const long status = GetFirst(pResult);
 
-    if (status < 0)  //buffer underflow, etc
-        return status;
+  if (status < 0)  // buffer underflow, etc
+    return status;
 
-    assert(pResult);
+  assert(pResult);
 
-    if (pResult->EOS())
-        return 0;
+  if (pResult->EOS())
+    return 0;
 
-    const Cluster* pCluster = pResult->GetCluster();
+  const Cluster* pCluster = pResult->GetCluster();
+  assert(pCluster);
+  assert(pCluster->GetIndex() >= 0);
+
+  if (time_ns <= pResult->GetBlock()->GetTime(pCluster))
+    return 0;
+
+  Cluster** const clusters = m_pSegment->m_clusters;
+  assert(clusters);
+
+  const long count = m_pSegment->GetCount();  // loaded only, not preloaded
+  assert(count > 0);
+
+  Cluster** const i = clusters + pCluster->GetIndex();
+  assert(i);
+  assert(*i == pCluster);
+  assert(pCluster->GetTime() <= time_ns);
+
+  Cluster** const j = clusters + count;
+
+  Cluster** lo = i;
+  Cluster** hi = j;
+
+  while (lo < hi) {
+    // INVARIANT:
+    //[i, lo) <= time_ns
+    //[lo, hi) ?
+    //[hi, j)  > time_ns
+
+    Cluster** const mid = lo + (hi - lo) / 2;
+    assert(mid < hi);
+
+    pCluster = *mid;
     assert(pCluster);
     assert(pCluster->GetIndex() >= 0);
+    assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));
 
-    if (time_ns <= pResult->GetBlock()->GetTime(pCluster))
-        return 0;
+    const long long t = pCluster->GetTime();
 
-    Cluster** const clusters = m_pSegment->m_clusters;
-    assert(clusters);
+    if (t <= time_ns)
+      lo = mid + 1;
+    else
+      hi = mid;
 
-    const long count = m_pSegment->GetCount();  //loaded only, not preloaded
-    assert(count > 0);
+    assert(lo <= hi);
+  }
 
-    Cluster** const i = clusters + pCluster->GetIndex();
-    assert(i);
-    assert(*i == pCluster);
+  assert(lo == hi);
+  assert(lo > i);
+  assert(lo <= j);
+
+  while (lo > i) {
+    pCluster = *--lo;
+    assert(pCluster);
     assert(pCluster->GetTime() <= time_ns);
 
-    Cluster** const j = clusters + count;
+    pResult = pCluster->GetEntry(this);
 
-    Cluster** lo = i;
-    Cluster** hi = j;
+    if ((pResult != 0) && !pResult->EOS())
+      return 0;
 
-    while (lo < hi)
-    {
-        //INVARIANT:
-        //[i, lo) <= time_ns
-        //[lo, hi) ?
-        //[hi, j)  > time_ns
+    // landed on empty cluster (no entries)
+  }
 
-        Cluster** const mid = lo + (hi - lo) / 2;
-        assert(mid < hi);
-
-        pCluster = *mid;
-        assert(pCluster);
-        assert(pCluster->GetIndex() >= 0);
-        assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));
-
-        const long long t = pCluster->GetTime();
-
-        if (t <= time_ns)
-            lo = mid + 1;
-        else
-            hi = mid;
-
-        assert(lo <= hi);
-    }
-
-    assert(lo == hi);
-    assert(lo > i);
-    assert(lo <= j);
-
-    while (lo > i)
-    {
-        pCluster = *--lo;
-        assert(pCluster);
-        assert(pCluster->GetTime() <= time_ns);
-
-        pResult = pCluster->GetEntry(this);
-
-        if ((pResult != 0) && !pResult->EOS())
-            return 0;
-
-        //landed on empty cluster (no entries)
-    }
-
-    pResult = GetEOS();  //weird
-    return 0;
+  pResult = GetEOS();  // weird
+  return 0;
 }
 
-const ContentEncoding*
-Track::GetContentEncodingByIndex(unsigned long idx) const {
+const ContentEncoding* Track::GetContentEncodingByIndex(
+    unsigned long idx) const {
   const ptrdiff_t count =
       content_encoding_entries_end_ - content_encoding_entries_;
   assert(count >= 0);
@@ -6029,27 +5279,22 @@

   int count = 0;
   while (pos < stop) {
     long long id, size;
-    const long status = ParseElementHeader(pReader,
-                                           pos,
-                                           stop,
-                                           id,
-                                           size);
-    if (status < 0)  //error
+    const long status = ParseElementHeader(pReader, pos, stop, id, size);
+    if (status < 0)  // error
       return status;
 
-
-    //pos now designates start of element
+    // pos now designates start of element
     if (id == 0x2240)  // ContentEncoding ID
       ++count;
 
-    pos += size;  //consume payload
+    pos += size;  // consume payload
     assert(pos <= stop);
   }
 
   if (count <= 0)
     return -1;
 
-  content_encoding_entries_ = new (std::nothrow) ContentEncoding*[count];
+  content_encoding_entries_ = new (std::nothrow) ContentEncoding* [count];
   if (!content_encoding_entries_)
     return -1;
 
@@ -6058,24 +5303,18 @@

   pos = start;
   while (pos < stop) {
     long long id, size;
-    long status = ParseElementHeader(pReader,
-                                     pos,
-                                     stop,
-                                     id,
-                                     size);
-    if (status < 0)  //error
+    long status = ParseElementHeader(pReader, pos, stop, id, size);
+    if (status < 0)  // error
       return status;
 
-    //pos now designates start of element
-    if (id == 0x2240) { // ContentEncoding ID
+    // pos now designates start of element
+    if (id == 0x2240) {  // ContentEncoding ID
       ContentEncoding* const content_encoding =
           new (std::nothrow) ContentEncoding();
       if (!content_encoding)
         return -1;
 
-      status = content_encoding->ParseContentEncodingEntry(pos,
-                                                           size,
-                                                           pReader);
+      status = content_encoding->ParseContentEncodingEntry(pos, size, pReader);
       if (status) {
         delete content_encoding;
         return status;
@@ -6084,7 +5323,7 @@

       *content_encoding_entries_end_++ = content_encoding;
     }
 
-    pos += size;  //consume payload
+    pos += size;  // consume payload
     assert(pos <= stop);
   }
 
@@ -6093,219 +5332,175 @@

   return 0;
 }
 
-Track::EOSBlock::EOSBlock() :
-    BlockEntry(NULL, LONG_MIN)
-{
-}
+Track::EOSBlock::EOSBlock() : BlockEntry(NULL, LONG_MIN) {}
 
-BlockEntry::Kind Track::EOSBlock::GetKind() const
-{
-    return kBlockEOS;
-}
+BlockEntry::Kind Track::EOSBlock::GetKind() const { return kBlockEOS; }
 
+const Block* Track::EOSBlock::GetBlock() const { return NULL; }
 
-const Block* Track::EOSBlock::GetBlock() const
-{
-    return NULL;
-}
+VideoTrack::VideoTrack(Segment* pSegment, long long element_start,
+                       long long element_size)
+    : Track(pSegment, element_start, element_size) {}
 
+long VideoTrack::Parse(Segment* pSegment, const Info& info,
+                       long long element_start, long long element_size,
+                       VideoTrack*& pResult) {
+  if (pResult)
+    return -1;
 
-VideoTrack::VideoTrack(
-    Segment* pSegment,
-    long long element_start,
-    long long element_size) :
-    Track(pSegment, element_start, element_size)
-{
-}
+  if (info.type != Track::kVideo)
+    return -1;
 
+  long long width = 0;
+  long long height = 0;
+  double rate = 0.0;
 
-long VideoTrack::Parse(
-    Segment* pSegment,
-    const Info& info,
-    long long element_start,
-    long long element_size,
-    VideoTrack*& pResult)
-{
-    if (pResult)
-        return -1;
+  IMkvReader* const pReader = pSegment->m_pReader;
 
-    if (info.type != Track::kVideo)
-        return -1;
+  const Settings& s = info.settings;
+  assert(s.start >= 0);
+  assert(s.size >= 0);
 
-    long long width = 0;
-    long long height = 0;
-    double rate = 0.0;
+  long long pos = s.start;
+  assert(pos >= 0);
 
-    IMkvReader* const pReader = pSegment->m_pReader;
+  const long long stop = pos + s.size;
 
-    const Settings& s = info.settings;
-    assert(s.start >= 0);
-    assert(s.size >= 0);
+  while (pos < stop) {
+    long long id, size;
 
-    long long pos = s.start;
-    assert(pos >= 0);
+    const long status = ParseElementHeader(pReader, pos, stop, id, size);
 
-    const long long stop = pos + s.size;
+    if (status < 0)  // error
+      return status;
 
-    while (pos < stop)
-    {
-        long long id, size;
+    if (id == 0x30) {  // pixel width
+      width = UnserializeUInt(pReader, pos, size);
 
-        const long status = ParseElementHeader(
-                                pReader,
-                                pos,
-                                stop,
-                                id,
-                                size);
+      if (width <= 0)
+        return E_FILE_FORMAT_INVALID;
+    } else if (id == 0x3A) {  // pixel height
+      height = UnserializeUInt(pReader, pos, size);
 
-        if (status < 0)  //error
-            return status;
+      if (height <= 0)
+        return E_FILE_FORMAT_INVALID;
+    } else if (id == 0x0383E3) {  // frame rate
+      const long status = UnserializeFloat(pReader, pos, size, rate);
 
-        if (id == 0x30)  //pixel width
-        {
-            width = UnserializeUInt(pReader, pos, size);
-
-            if (width <= 0)
-                return E_FILE_FORMAT_INVALID;
-        }
-        else if (id == 0x3A)  //pixel height
-        {
-            height = UnserializeUInt(pReader, pos, size);
-
-            if (height <= 0)
-                return E_FILE_FORMAT_INVALID;
-        }
-        else if (id == 0x0383E3)  //frame rate
-        {
-            const long status = UnserializeFloat(
-                                    pReader,
-                                    pos,
-                                    size,
-                                    rate);
-
-            if (status < 0)
-                return status;
-
-            if (rate <= 0)
-                return E_FILE_FORMAT_INVALID;
-        }
-
-        pos += size;  //consume payload
-        assert(pos <= stop);
-    }
-
-    assert(pos == stop);
-
-    VideoTrack* const pTrack = new (std::nothrow) VideoTrack(pSegment,
-                                                             element_start,
-                                                             element_size);
-
-    if (pTrack == NULL)
-        return -1;  //generic error
-
-    const int status = info.Copy(pTrack->m_info);
-
-    if (status)  // error
-    {
-        delete pTrack;
-        return status;
-    }
-
-    pTrack->m_width = width;
-    pTrack->m_height = height;
-    pTrack->m_rate = rate;
-
-    pResult = pTrack;
-    return 0;  //success
-}
-
-
-bool VideoTrack::VetEntry(const BlockEntry* pBlockEntry) const
-{
-    return Track::VetEntry(pBlockEntry) && pBlockEntry->GetBlock()->IsKey();
-}
-
-long VideoTrack::Seek(
-    long long time_ns,
-    const BlockEntry*& pResult) const
-{
-    const long status = GetFirst(pResult);
-
-    if (status < 0)  //buffer underflow, etc
+      if (status < 0)
         return status;
 
-    assert(pResult);
+      if (rate <= 0)
+        return E_FILE_FORMAT_INVALID;
+    }
 
-    if (pResult->EOS())
-        return 0;
+    pos += size;  // consume payload
+    assert(pos <= stop);
+  }
 
-    const Cluster* pCluster = pResult->GetCluster();
+  assert(pos == stop);
+
+  VideoTrack* const pTrack =
+      new (std::nothrow) VideoTrack(pSegment, element_start, element_size);
+
+  if (pTrack == NULL)
+    return -1;  // generic error
+
+  const int status = info.Copy(pTrack->m_info);
+
+  if (status) {  // error
+    delete pTrack;
+    return status;
+  }
+
+  pTrack->m_width = width;
+  pTrack->m_height = height;
+  pTrack->m_rate = rate;
+
+  pResult = pTrack;
+  return 0;  // success
+}
+
+bool VideoTrack::VetEntry(const BlockEntry* pBlockEntry) const {
+  return Track::VetEntry(pBlockEntry) && pBlockEntry->GetBlock()->IsKey();
+}
+
+long VideoTrack::Seek(long long time_ns, const BlockEntry*& pResult) const {
+  const long status = GetFirst(pResult);
+
+  if (status < 0)  // buffer underflow, etc
+    return status;
+
+  assert(pResult);
+
+  if (pResult->EOS())
+    return 0;
+
+  const Cluster* pCluster = pResult->GetCluster();
+  assert(pCluster);
+  assert(pCluster->GetIndex() >= 0);
+
+  if (time_ns <= pResult->GetBlock()->GetTime(pCluster))
+    return 0;
+
+  Cluster** const clusters = m_pSegment->m_clusters;
+  assert(clusters);
+
+  const long count = m_pSegment->GetCount();  // loaded only, not pre-loaded
+  assert(count > 0);
+
+  Cluster** const i = clusters + pCluster->GetIndex();
+  assert(i);
+  assert(*i == pCluster);
+  assert(pCluster->GetTime() <= time_ns);
+
+  Cluster** const j = clusters + count;
+
+  Cluster** lo = i;
+  Cluster** hi = j;
+
+  while (lo < hi) {
+    // INVARIANT:
+    //[i, lo) <= time_ns
+    //[lo, hi) ?
+    //[hi, j)  > time_ns
+
+    Cluster** const mid = lo + (hi - lo) / 2;
+    assert(mid < hi);
+
+    pCluster = *mid;
     assert(pCluster);
     assert(pCluster->GetIndex() >= 0);
+    assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));
 
-    if (time_ns <= pResult->GetBlock()->GetTime(pCluster))
-        return 0;
+    const long long t = pCluster->GetTime();
 
-    Cluster** const clusters = m_pSegment->m_clusters;
-    assert(clusters);
+    if (t <= time_ns)
+      lo = mid + 1;
+    else
+      hi = mid;
 
-    const long count = m_pSegment->GetCount();  //loaded only, not pre-loaded
-    assert(count > 0);
+    assert(lo <= hi);
+  }
 
-    Cluster** const i = clusters + pCluster->GetIndex();
-    assert(i);
-    assert(*i == pCluster);
-    assert(pCluster->GetTime() <= time_ns);
+  assert(lo == hi);
+  assert(lo > i);
+  assert(lo <= j);
 
-    Cluster** const j = clusters + count;
+  pCluster = *--lo;
+  assert(pCluster);
+  assert(pCluster->GetTime() <= time_ns);
 
-    Cluster** lo = i;
-    Cluster** hi = j;
+  pResult = pCluster->GetEntry(this, time_ns);
 
-    while (lo < hi)
-    {
-        //INVARIANT:
-        //[i, lo) <= time_ns
-        //[lo, hi) ?
-        //[hi, j)  > time_ns
+  if ((pResult != 0) && !pResult->EOS())  // found a keyframe
+    return 0;
 
-        Cluster** const mid = lo + (hi - lo) / 2;
-        assert(mid < hi);
-
-        pCluster = *mid;
-        assert(pCluster);
-        assert(pCluster->GetIndex() >= 0);
-        assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));
-
-        const long long t = pCluster->GetTime();
-
-        if (t <= time_ns)
-            lo = mid + 1;
-        else
-            hi = mid;
-
-        assert(lo <= hi);
-    }
-
-    assert(lo == hi);
-    assert(lo > i);
-    assert(lo <= j);
-
+  while (lo != i) {
     pCluster = *--lo;
     assert(pCluster);
     assert(pCluster->GetTime() <= time_ns);
 
-    pResult = pCluster->GetEntry(this, time_ns);
-
-    if ((pResult != 0) && !pResult->EOS())  //found a keyframe
-        return 0;
-
-    while (lo != i)
-    {
-        pCluster = *--lo;
-        assert(pCluster);
-        assert(pCluster->GetTime() <= time_ns);
-
 #if 0
         //TODO:
         //We need to handle the case when a cluster
@@ -6314,651 +5509,501 @@

         //good enough.
         pResult = pCluster->GetMaxKey(this);
 #else
-        pResult = pCluster->GetEntry(this, time_ns);
+    pResult = pCluster->GetEntry(this, time_ns);
 #endif
 
-        if ((pResult != 0) && !pResult->EOS())
-            return 0;
+    if ((pResult != 0) && !pResult->EOS())
+      return 0;
+  }
+
+  // weird: we're on the first cluster, but no keyframe found
+  // should never happen but we must return something anyway
+
+  pResult = GetEOS();
+  return 0;
+}
+
+long long VideoTrack::GetWidth() const { return m_width; }
+
+long long VideoTrack::GetHeight() const { return m_height; }
+
+double VideoTrack::GetFrameRate() const { return m_rate; }
+
+AudioTrack::AudioTrack(Segment* pSegment, long long element_start,
+                       long long element_size)
+    : Track(pSegment, element_start, element_size) {}
+
+long AudioTrack::Parse(Segment* pSegment, const Info& info,
+                       long long element_start, long long element_size,
+                       AudioTrack*& pResult) {
+  if (pResult)
+    return -1;
+
+  if (info.type != Track::kAudio)
+    return -1;
+
+  IMkvReader* const pReader = pSegment->m_pReader;
+
+  const Settings& s = info.settings;
+  assert(s.start >= 0);
+  assert(s.size >= 0);
+
+  long long pos = s.start;
+  assert(pos >= 0);
+
+  const long long stop = pos + s.size;
+
+  double rate = 8000.0;  // MKV default
+  long long channels = 1;
+  long long bit_depth = 0;
+
+  while (pos < stop) {
+    long long id, size;
+
+    long status = ParseElementHeader(pReader, pos, stop, id, size);
+
+    if (status < 0)  // error
+      return status;
+
+    if (id == 0x35) {  // Sample Rate
+      status = UnserializeFloat(pReader, pos, size, rate);
+
+      if (status < 0)
+        return status;
+
+      if (rate <= 0)
+        return E_FILE_FORMAT_INVALID;
+    } else if (id == 0x1F) {  // Channel Count
+      channels = UnserializeUInt(pReader, pos, size);
+
+      if (channels <= 0)
+        return E_FILE_FORMAT_INVALID;
+    } else if (id == 0x2264) {  // Bit Depth
+      bit_depth = UnserializeUInt(pReader, pos, size);
+
+      if (bit_depth <= 0)
+        return E_FILE_FORMAT_INVALID;
     }
 
-    //weird: we're on the first cluster, but no keyframe found
-    //should never happen but we must return something anyway
+    pos += size;  // consume payload
+    assert(pos <= stop);
+  }
 
-    pResult = GetEOS();
-    return 0;
+  assert(pos == stop);
+
+  AudioTrack* const pTrack =
+      new (std::nothrow) AudioTrack(pSegment, element_start, element_size);
+
+  if (pTrack == NULL)
+    return -1;  // generic error
+
+  const int status = info.Copy(pTrack->m_info);
+
+  if (status) {
+    delete pTrack;
+    return status;
+  }
+
+  pTrack->m_rate = rate;
+  pTrack->m_channels = channels;
+  pTrack->m_bitDepth = bit_depth;
+
+  pResult = pTrack;
+  return 0;  // success
 }
 
+double AudioTrack::GetSamplingRate() const { return m_rate; }
 
-long long VideoTrack::GetWidth() const
-{
-    return m_width;
-}
+long long AudioTrack::GetChannels() const { return m_channels; }
 
+long long AudioTrack::GetBitDepth() const { return m_bitDepth; }
 
-long long VideoTrack::GetHeight() const
-{
-    return m_height;
-}
+Tracks::Tracks(Segment* pSegment, long long start, long long size_,
+               long long element_start, long long element_size)
+    : m_pSegment(pSegment),
+      m_start(start),
+      m_size(size_),
+      m_element_start(element_start),
+      m_element_size(element_size),
+      m_trackEntries(NULL),
+      m_trackEntriesEnd(NULL) {}
 
+long Tracks::Parse() {
+  assert(m_trackEntries == NULL);
+  assert(m_trackEntriesEnd == NULL);
 
-double VideoTrack::GetFrameRate() const
-{
-    return m_rate;
-}
+  const long long stop = m_start + m_size;
+  IMkvReader* const pReader = m_pSegment->m_pReader;
 
+  int count = 0;
+  long long pos = m_start;
 
-AudioTrack::AudioTrack(
-    Segment* pSegment,
-    long long element_start,
-    long long element_size) :
-    Track(pSegment, element_start, element_size)
-{
-}
+  while (pos < stop) {
+    long long id, size;
 
+    const long status = ParseElementHeader(pReader, pos, stop, id, size);
 
-long AudioTrack::Parse(
-    Segment* pSegment,
-    const Info& info,
-    long long element_start,
-    long long element_size,
-    AudioTrack*& pResult)
-{
-    if (pResult)
-        return -1;
+    if (status < 0)  // error
+      return status;
 
-    if (info.type != Track::kAudio)
-        return -1;
+    if (size == 0)  // weird
+      continue;
 
-    IMkvReader* const pReader = pSegment->m_pReader;
+    if (id == 0x2E)  // TrackEntry ID
+      ++count;
 
-    const Settings& s = info.settings;
-    assert(s.start >= 0);
-    assert(s.size >= 0);
+    pos += size;  // consume payload
+    assert(pos <= stop);
+  }
 
-    long long pos = s.start;
-    assert(pos >= 0);
+  assert(pos == stop);
 
-    const long long stop = pos + s.size;
+  if (count <= 0)
+    return 0;  // success
 
-    double rate = 8000.0;  // MKV default
-    long long channels = 1;
-    long long bit_depth = 0;
+  m_trackEntries = new (std::nothrow) Track* [count];
 
-    while (pos < stop)
-    {
-        long long id, size;
+  if (m_trackEntries == NULL)
+    return -1;
 
-        long status = ParseElementHeader(
-                                pReader,
-                                pos,
-                                stop,
-                                id,
-                                size);
+  m_trackEntriesEnd = m_trackEntries;
 
-        if (status < 0)  //error
-            return status;
+  pos = m_start;
 
-        if (id == 0x35)  //Sample Rate
-        {
-            status = UnserializeFloat(pReader, pos, size, rate);
+  while (pos < stop) {
+    const long long element_start = pos;
 
-            if (status < 0)
-                return status;
+    long long id, payload_size;
 
-            if (rate <= 0)
-                return E_FILE_FORMAT_INVALID;
-        }
-        else if (id == 0x1F)  //Channel Count
-        {
-            channels = UnserializeUInt(pReader, pos, size);
+    const long status =
+        ParseElementHeader(pReader, pos, stop, id, payload_size);
 
-            if (channels <= 0)
-                return E_FILE_FORMAT_INVALID;
-        }
-        else if (id == 0x2264)  //Bit Depth
-        {
-            bit_depth = UnserializeUInt(pReader, pos, size);
+    if (status < 0)  // error
+      return status;
 
-            if (bit_depth <= 0)
-                return E_FILE_FORMAT_INVALID;
-        }
+    if (payload_size == 0)  // weird
+      continue;
 
-        pos += size;  //consume payload
-        assert(pos <= stop);
+    const long long payload_stop = pos + payload_size;
+    assert(payload_stop <= stop);  // checked in ParseElement
+
+    const long long element_size = payload_stop - element_start;
+
+    if (id == 0x2E) {  // TrackEntry ID
+      Track*& pTrack = *m_trackEntriesEnd;
+      pTrack = NULL;
+
+      const long status = ParseTrackEntry(pos, payload_size, element_start,
+                                          element_size, pTrack);
+
+      if (status)
+        return status;
+
+      if (pTrack)
+        ++m_trackEntriesEnd;
     }
 
-    assert(pos == stop);
+    pos = payload_stop;
+    assert(pos <= stop);
+  }
 
-    AudioTrack* const pTrack = new (std::nothrow) AudioTrack(pSegment,
-                                                             element_start,
-                                                             element_size);
+  assert(pos == stop);
 
-    if (pTrack == NULL)
-        return -1;  //generic error
+  return 0;  // success
+}
 
-    const int status = info.Copy(pTrack->m_info);
+unsigned long Tracks::GetTracksCount() const {
+  const ptrdiff_t result = m_trackEntriesEnd - m_trackEntries;
+  assert(result >= 0);
+
+  return static_cast<unsigned long>(result);
+}
+
+long Tracks::ParseTrackEntry(long long track_start, long long track_size,
+                             long long element_start, long long element_size,
+                             Track*& pResult) const {
+  if (pResult)
+    return -1;
+
+  IMkvReader* const pReader = m_pSegment->m_pReader;
+
+  long long pos = track_start;
+  const long long track_stop = track_start + track_size;
+
+  Track::Info info;
+
+  info.type = 0;
+  info.number = 0;
+  info.uid = 0;
+  info.defaultDuration = 0;
+
+  Track::Settings v;
+  v.start = -1;
+  v.size = -1;
+
+  Track::Settings a;
+  a.start = -1;
+  a.size = -1;
+
+  Track::Settings e;  // content_encodings_settings;
+  e.start = -1;
+  e.size = -1;
+
+  long long lacing = 1;  // default is true
+
+  while (pos < track_stop) {
+    long long id, size;
+
+    const long status = ParseElementHeader(pReader, pos, track_stop, id, size);
+
+    if (status < 0)  // error
+      return status;
+
+    if (size < 0)
+      return E_FILE_FORMAT_INVALID;
+
+    const long long start = pos;
+
+    if (id == 0x60) {  // VideoSettings ID
+      v.start = start;
+      v.size = size;
+    } else if (id == 0x61) {  // AudioSettings ID
+      a.start = start;
+      a.size = size;
+    } else if (id == 0x2D80) {  // ContentEncodings ID
+      e.start = start;
+      e.size = size;
+    } else if (id == 0x33C5) {  // Track UID
+      if (size > 8)
+        return E_FILE_FORMAT_INVALID;
+
+      info.uid = 0;
+
+      long long pos_ = start;
+      const long long pos_end = start + size;
+
+      while (pos_ != pos_end) {
+        unsigned char b;
+
+        const int status = pReader->Read(pos_, 1, &b);
+
+        if (status)
+          return status;
+
+        info.uid <<= 8;
+        info.uid |= b;
+
+        ++pos_;
+      }
+    } else if (id == 0x57) {  // Track Number
+      const long long num = UnserializeUInt(pReader, pos, size);
+
+      if ((num <= 0) || (num > 127))
+        return E_FILE_FORMAT_INVALID;
+
+      info.number = static_cast<long>(num);
+    } else if (id == 0x03) {  // Track Type
+      const long long type = UnserializeUInt(pReader, pos, size);
+
+      if ((type <= 0) || (type > 254))
+        return E_FILE_FORMAT_INVALID;
+
+      info.type = static_cast<long>(type);
+    } else if (id == 0x136E) {  // Track Name
+      const long status =
+          UnserializeString(pReader, pos, size, info.nameAsUTF8);
+
+      if (status)
+        return status;
+    } else if (id == 0x02B59C) {  // Track Language
+      const long status = UnserializeString(pReader, pos, size, info.language);
+
+      if (status)
+        return status;
+    } else if (id == 0x03E383) {  // Default Duration
+      const long long duration = UnserializeUInt(pReader, pos, size);
+
+      if (duration < 0)
+        return E_FILE_FORMAT_INVALID;
+
+      info.defaultDuration = static_cast<unsigned long long>(duration);
+    } else if (id == 0x06) {  // CodecID
+      const long status = UnserializeString(pReader, pos, size, info.codecId);
+
+      if (status)
+        return status;
+    } else if (id == 0x1C) {  // lacing
+      lacing = UnserializeUInt(pReader, pos, size);
+
+      if ((lacing < 0) || (lacing > 1))
+        return E_FILE_FORMAT_INVALID;
+    } else if (id == 0x23A2) {  // Codec Private
+      delete[] info.codecPrivate;
+      info.codecPrivate = NULL;
+      info.codecPrivateSize = 0;
+
+      const size_t buflen = static_cast<size_t>(size);
+
+      if (buflen) {
+        typedef unsigned char* buf_t;
+
+        const buf_t buf = new (std::nothrow) unsigned char[buflen];
+
+        if (buf == NULL)
+          return -1;
+
+        const int status = pReader->Read(pos, static_cast<long>(buflen), buf);
+
+        if (status) {
+          delete[] buf;
+          return status;
+        }
+
+        info.codecPrivate = buf;
+        info.codecPrivateSize = buflen;
+      }
+    } else if (id == 0x058688) {  // Codec Name
+      const long status =
+          UnserializeString(pReader, pos, size, info.codecNameAsUTF8);
+
+      if (status)
+        return status;
+    } else if (id == 0x16AA) {  // Codec Delay
+      info.codecDelay = UnserializeUInt(pReader, pos, size);
+    } else if (id == 0x16BB) {  // Seek Pre Roll
+      info.seekPreRoll = UnserializeUInt(pReader, pos, size);
+    }
+
+    pos += size;  // consume payload
+    assert(pos <= track_stop);
+  }
+
+  assert(pos == track_stop);
+
+  if (info.number <= 0)  // not specified
+    return E_FILE_FORMAT_INVALID;
+
+  if (GetTrackByNumber(info.number))
+    return E_FILE_FORMAT_INVALID;
+
+  if (info.type <= 0)  // not specified
+    return E_FILE_FORMAT_INVALID;
+
+  info.lacing = (lacing > 0) ? true : false;
+
+  if (info.type == Track::kVideo) {
+    if (v.start < 0)
+      return E_FILE_FORMAT_INVALID;
+
+    if (a.start >= 0)
+      return E_FILE_FORMAT_INVALID;
+
+    info.settings = v;
+
+    VideoTrack* pTrack = NULL;
+
+    const long status = VideoTrack::Parse(m_pSegment, info, element_start,
+                                          element_size, pTrack);
 
     if (status)
-    {
-        delete pTrack;
-        return status;
-    }
-
-    pTrack->m_rate = rate;
-    pTrack->m_channels = channels;
-    pTrack->m_bitDepth = bit_depth;
+      return status;
 
     pResult = pTrack;
-    return 0;  //success
+    assert(pResult);
+
+    if (e.start >= 0)
+      pResult->ParseContentEncodingsEntry(e.start, e.size);
+  } else if (info.type == Track::kAudio) {
+    if (a.start < 0)
+      return E_FILE_FORMAT_INVALID;
+
+    if (v.start >= 0)
+      return E_FILE_FORMAT_INVALID;
+
+    info.settings = a;
+
+    AudioTrack* pTrack = NULL;
+
+    const long status = AudioTrack::Parse(m_pSegment, info, element_start,
+                                          element_size, pTrack);
+
+    if (status)
+      return status;
+
+    pResult = pTrack;
+    assert(pResult);
+
+    if (e.start >= 0)
+      pResult->ParseContentEncodingsEntry(e.start, e.size);
+  } else {
+    // neither video nor audio - probably metadata or subtitles
+
+    if (a.start >= 0)
+      return E_FILE_FORMAT_INVALID;
+
+    if (v.start >= 0)
+      return E_FILE_FORMAT_INVALID;
+
+    if (e.start >= 0)
+      return E_FILE_FORMAT_INVALID;
+
+    info.settings.start = -1;
+    info.settings.size = 0;
+
+    Track* pTrack = NULL;
+
+    const long status =
+        Track::Create(m_pSegment, info, element_start, element_size, pTrack);
+
+    if (status)
+      return status;
+
+    pResult = pTrack;
+    assert(pResult);
+  }
+
+  return 0;  // success
 }
 
+Tracks::~Tracks() {
+  Track** i = m_trackEntries;
+  Track** const j = m_trackEntriesEnd;
 
-double AudioTrack::GetSamplingRate() const
-{
-    return m_rate;
+  while (i != j) {
+    Track* const pTrack = *i++;
+    delete pTrack;
+  }
+
+  delete[] m_trackEntries;
 }
 
+const Track* Tracks::GetTrackByNumber(long tn) const {
+  if (tn < 0)
+    return NULL;
 
-long long AudioTrack::GetChannels() const
-{
-    return m_channels;
+  Track** i = m_trackEntries;
+  Track** const j = m_trackEntriesEnd;
+
+  while (i != j) {
+    Track* const pTrack = *i++;
+
+    if (pTrack == NULL)
+      continue;
+
+    if (tn == pTrack->GetNumber())
+      return pTrack;
+  }
+
+  return NULL;  // not found
 }
 
-long long AudioTrack::GetBitDepth() const
-{
-    return m_bitDepth;
-}
+const Track* Tracks::GetTrackByIndex(unsigned long idx) const {
+  const ptrdiff_t count = m_trackEntriesEnd - m_trackEntries;
 
-Tracks::Tracks(
-    Segment* pSegment,
-    long long start,
-    long long size_,
-    long long element_start,
-    long long element_size) :
-    m_pSegment(pSegment),
-    m_start(start),
-    m_size(size_),
-    m_element_start(element_start),
-    m_element_size(element_size),
-    m_trackEntries(NULL),
-    m_trackEntriesEnd(NULL)
-{
-}
+  if (idx >= static_cast<unsigned long>(count))
+    return NULL;
 
-
-long Tracks::Parse()
-{
-    assert(m_trackEntries == NULL);
-    assert(m_trackEntriesEnd == NULL);
-
-    const long long stop = m_start + m_size;
-    IMkvReader* const pReader = m_pSegment->m_pReader;
-
-    int count = 0;
-    long long pos = m_start;
-
-    while (pos < stop)
-    {
-        long long id, size;
-
-        const long status = ParseElementHeader(
-                                pReader,
-                                pos,
-                                stop,
-                                id,
-                                size);
-
-        if (status < 0)  //error
-            return status;
-
-        if (size == 0)  //weird
-            continue;
-
-        if (id == 0x2E)  //TrackEntry ID
-            ++count;
-
-        pos += size;  //consume payload
-        assert(pos <= stop);
-    }
-
-    assert(pos == stop);
-
-    if (count <= 0)
-        return 0;  //success
-
-    m_trackEntries = new (std::nothrow) Track*[count];
-
-    if (m_trackEntries == NULL)
-        return -1;
-
-    m_trackEntriesEnd = m_trackEntries;
-
-    pos = m_start;
-
-    while (pos < stop)
-    {
-        const long long element_start = pos;
-
-        long long id, payload_size;
-
-        const long status = ParseElementHeader(
-                                pReader,
-                                pos,
-                                stop,
-                                id,
-                                payload_size);
-
-        if (status < 0)  //error
-            return status;
-
-        if (payload_size == 0)  //weird
-            continue;
-
-        const long long payload_stop = pos + payload_size;
-        assert(payload_stop <= stop);  //checked in ParseElement
-
-        const long long element_size = payload_stop - element_start;
-
-        if (id == 0x2E)  //TrackEntry ID
-        {
-            Track*& pTrack = *m_trackEntriesEnd;
-            pTrack = NULL;
-
-            const long status = ParseTrackEntry(
-                                    pos,
-                                    payload_size,
-                                    element_start,
-                                    element_size,
-                                    pTrack);
-
-            if (status)
-                return status;
-
-            if (pTrack)
-                ++m_trackEntriesEnd;
-        }
-
-        pos = payload_stop;
-        assert(pos <= stop);
-    }
-
-    assert(pos == stop);
-
-    return 0;  //success
-}
-
-
-unsigned long Tracks::GetTracksCount() const
-{
-    const ptrdiff_t result = m_trackEntriesEnd - m_trackEntries;
-    assert(result >= 0);
-
-    return static_cast<unsigned long>(result);
-}
-
-long Tracks::ParseTrackEntry(
-    long long track_start,
-    long long track_size,
-    long long element_start,
-    long long element_size,
-    Track*& pResult) const
-{
-    if (pResult)
-        return -1;
-
-    IMkvReader* const pReader = m_pSegment->m_pReader;
-
-    long long pos = track_start;
-    const long long track_stop = track_start + track_size;
-
-    Track::Info info;
-
-    info.type = 0;
-    info.number = 0;
-    info.uid = 0;
-    info.defaultDuration = 0;
-
-    Track::Settings v;
-    v.start = -1;
-    v.size = -1;
-
-    Track::Settings a;
-    a.start = -1;
-    a.size = -1;
-
-    Track::Settings e;  //content_encodings_settings;
-    e.start = -1;
-    e.size = -1;
-
-    long long lacing = 1;  //default is true
-
-    while (pos < track_stop)
-    {
-        long long id, size;
-
-        const long status = ParseElementHeader(
-                                pReader,
-                                pos,
-                                track_stop,
-                                id,
-                                size);
-
-        if (status < 0)  //error
-            return status;
-
-        if (size < 0)
-            return E_FILE_FORMAT_INVALID;
-
-        const long long start = pos;
-
-        if (id == 0x60)  // VideoSettings ID
-        {
-            v.start = start;
-            v.size = size;
-        }
-        else if (id == 0x61)  // AudioSettings ID
-        {
-            a.start = start;
-            a.size = size;
-        }
-        else if (id == 0x2D80) // ContentEncodings ID
-        {
-            e.start = start;
-            e.size = size;
-        }
-        else if (id == 0x33C5)  //Track UID
-        {
-            if (size > 8)
-                return E_FILE_FORMAT_INVALID;
-
-            info.uid = 0;
-
-            long long pos_ = start;
-            const long long pos_end = start + size;
-
-            while (pos_ != pos_end)
-            {
-                unsigned char b;
-
-                const int status = pReader->Read(pos_, 1, &b);
-
-                if (status)
-                    return status;
-
-                info.uid <<= 8;
-                info.uid |= b;
-
-                ++pos_;
-            }
-        }
-        else if (id == 0x57)  //Track Number
-        {
-            const long long num = UnserializeUInt(pReader, pos, size);
-
-            if ((num <= 0) || (num > 127))
-                return E_FILE_FORMAT_INVALID;
-
-            info.number = static_cast<long>(num);
-        }
-        else if (id == 0x03)  //Track Type
-        {
-            const long long type = UnserializeUInt(pReader, pos, size);
-
-            if ((type <= 0) || (type > 254))
-                return E_FILE_FORMAT_INVALID;
-
-            info.type = static_cast<long>(type);
-        }
-        else if (id == 0x136E)  //Track Name
-        {
-            const long status = UnserializeString(
-                                    pReader,
-                                    pos,
-                                    size,
-                                    info.nameAsUTF8);
-
-            if (status)
-                return status;
-        }
-        else if (id == 0x02B59C)  //Track Language
-        {
-            const long status = UnserializeString(
-                                    pReader,
-                                    pos,
-                                    size,
-                                    info.language);
-
-            if (status)
-                return status;
-        }
-        else if (id == 0x03E383)  //Default Duration
-        {
-            const long long duration = UnserializeUInt(pReader, pos, size);
-
-            if (duration < 0)
-                return E_FILE_FORMAT_INVALID;
-
-            info.defaultDuration = static_cast<unsigned long long>(duration);
-        }
-        else if (id == 0x06)  //CodecID
-        {
-            const long status = UnserializeString(
-                                    pReader,
-                                    pos,
-                                    size,
-                                    info.codecId);
-
-            if (status)
-                return status;
-        }
-        else if (id == 0x1C)  //lacing
-        {
-            lacing = UnserializeUInt(pReader, pos, size);
-
-            if ((lacing < 0) || (lacing > 1))
-                return E_FILE_FORMAT_INVALID;
-        }
-        else if (id == 0x23A2)  //Codec Private
-        {
-            delete[] info.codecPrivate;
-            info.codecPrivate = NULL;
-            info.codecPrivateSize = 0;
-
-            const size_t buflen = static_cast<size_t>(size);
-
-            if (buflen)
-            {
-                typedef unsigned char* buf_t;
-
-                const buf_t buf = new (std::nothrow) unsigned char[buflen];
-
-                if (buf == NULL)
-                    return -1;
-
-                const int status = pReader->Read(pos, buflen, buf);
-
-                if (status)
-                {
-                    delete[] buf;
-                    return status;
-                }
-
-                info.codecPrivate = buf;
-                info.codecPrivateSize = buflen;
-            }
-        }
-        else if (id == 0x058688)  //Codec Name
-        {
-            const long status = UnserializeString(
-                                    pReader,
-                                    pos,
-                                    size,
-                                    info.codecNameAsUTF8);
-
-            if (status)
-                return status;
-        }
-        else if (id == 0x16AA)  //Codec Delay
-        {
-            info.codecDelay = UnserializeUInt(pReader, pos, size);
-
-        }
-        else if (id == 0x16BB) //Seek Pre Roll
-        {
-            info.seekPreRoll = UnserializeUInt(pReader, pos, size);
-        }
-
-        pos += size;  //consume payload
-        assert(pos <= track_stop);
-    }
-
-    assert(pos == track_stop);
-
-    if (info.number <= 0)  //not specified
-        return E_FILE_FORMAT_INVALID;
-
-    if (GetTrackByNumber(info.number))
-        return E_FILE_FORMAT_INVALID;
-
-    if (info.type <= 0)  //not specified
-        return E_FILE_FORMAT_INVALID;
-
-    info.lacing = (lacing > 0) ? true : false;
-
-    if (info.type == Track::kVideo)
-    {
-        if (v.start < 0)
-            return E_FILE_FORMAT_INVALID;
-
-        if (a.start >= 0)
-            return E_FILE_FORMAT_INVALID;
-
-        info.settings = v;
-
-        VideoTrack* pTrack = NULL;
-
-        const long status = VideoTrack::Parse(m_pSegment,
-                                              info,
-                                              element_start,
-                                              element_size,
-                                              pTrack);
-
-        if (status)
-            return status;
-
-        pResult = pTrack;
-        assert(pResult);
-
-        if (e.start >= 0)
-            pResult->ParseContentEncodingsEntry(e.start, e.size);
-    }
-    else if (info.type == Track::kAudio)
-    {
-        if (a.start < 0)
-            return E_FILE_FORMAT_INVALID;
-
-        if (v.start >= 0)
-            return E_FILE_FORMAT_INVALID;
-
-        info.settings = a;
-
-        AudioTrack* pTrack = NULL;
-
-        const long status = AudioTrack::Parse(m_pSegment,
-                                              info,
-                                              element_start,
-                                              element_size,
-                                              pTrack);
-
-        if (status)
-            return status;
-
-        pResult = pTrack;
-        assert(pResult);
-
-        if (e.start >= 0)
-            pResult->ParseContentEncodingsEntry(e.start, e.size);
-    }
-    else
-    {
-        // neither video nor audio - probably metadata or subtitles
-
-        if (a.start >= 0)
-            return E_FILE_FORMAT_INVALID;
-
-        if (v.start >= 0)
-            return E_FILE_FORMAT_INVALID;
-
-        if (e.start >= 0)
-            return E_FILE_FORMAT_INVALID;
-
-        info.settings.start = -1;
-        info.settings.size = 0;
-
-        Track* pTrack = NULL;
-
-        const long status = Track::Create(m_pSegment,
-                                          info,
-                                          element_start,
-                                          element_size,
-                                          pTrack);
-
-        if (status)
-            return status;
-
-        pResult = pTrack;
-        assert(pResult);
-    }
-
-    return 0;  //success
-}
-
-
-Tracks::~Tracks()
-{
-    Track** i = m_trackEntries;
-    Track** const j = m_trackEntriesEnd;
-
-    while (i != j)
-    {
-        Track* const pTrack = *i++;
-        delete pTrack;
-    }
-
-    delete[] m_trackEntries;
-}
-
-const Track* Tracks::GetTrackByNumber(long tn) const
-{
-    if (tn < 0)
-        return NULL;
-
-    Track** i = m_trackEntries;
-    Track** const j = m_trackEntriesEnd;
-
-    while (i != j)
-    {
-        Track* const pTrack = *i++;
-
-        if (pTrack == NULL)
-            continue;
-
-        if (tn == pTrack->GetNumber())
-            return pTrack;
-    }
-
-    return NULL;  //not found
-}
-
-
-const Track* Tracks::GetTrackByIndex(unsigned long idx) const
-{
-    const ptrdiff_t count = m_trackEntriesEnd - m_trackEntries;
-
-    if (idx >= static_cast<unsigned long>(count))
-         return NULL;
-
-    return m_trackEntries[idx];
+  return m_trackEntries[idx];
 }
 
 #if 0
@@ -6980,104 +6025,100 @@

 }
 #endif
 
+long Cluster::Load(long long& pos, long& len) const {
+  assert(m_pSegment);
+  assert(m_pos >= m_element_start);
 
-long Cluster::Load(long long& pos, long& len) const
-{
-    assert(m_pSegment);
-    assert(m_pos >= m_element_start);
+  if (m_timecode >= 0)  // at least partially loaded
+    return 0;
 
-    if (m_timecode >= 0)  //at least partially loaded
-        return 0;
+  assert(m_pos == m_element_start);
+  assert(m_element_size < 0);
 
-    assert(m_pos == m_element_start);
-    assert(m_element_size < 0);
+  IMkvReader* const pReader = m_pSegment->m_pReader;
 
-    IMkvReader* const pReader = m_pSegment->m_pReader;
+  long long total, avail;
 
-    long long total, avail;
+  const int status = pReader->Length(&total, &avail);
 
-    const int status = pReader->Length(&total, &avail);
+  if (status < 0)  // error
+    return status;
 
-    if (status < 0)  //error
-        return status;
+  assert((total < 0) || (avail <= total));
+  assert((total < 0) || (m_pos <= total));  // TODO: verify this
 
-    assert((total < 0) || (avail <= total));
-    assert((total < 0) || (m_pos <= total));  //TODO: verify this
+  pos = m_pos;
 
-    pos = m_pos;
+  long long cluster_size = -1;
 
-    long long cluster_size = -1;
-
-    {
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
-
-        long long result = GetUIntLength(pReader, pos, len);
-
-        if (result < 0)  //error or underflow
-            return static_cast<long>(result);
-
-        if (result > 0)  //underflow (weird)
-            return E_BUFFER_NOT_FULL;
-
-        //if ((pos + len) > segment_stop)
-        //    return E_FILE_FORMAT_INVALID;
-
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
-
-        const long long id_ = ReadUInt(pReader, pos, len);
-
-        if (id_ < 0)  //error
-            return static_cast<long>(id_);
-
-        if (id_ != 0x0F43B675)  //Cluster ID
-            return E_FILE_FORMAT_INVALID;
-
-        pos += len;  //consume id
-
-        //read cluster size
-
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
-
-        result = GetUIntLength(pReader, pos, len);
-
-        if (result < 0)  //error
-            return static_cast<long>(result);
-
-        if (result > 0)  //weird
-            return E_BUFFER_NOT_FULL;
-
-        //if ((pos + len) > segment_stop)
-        //    return E_FILE_FORMAT_INVALID;
-
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
-
-        const long long size = ReadUInt(pReader, pos, len);
-
-        if (size < 0)  //error
-            return static_cast<long>(cluster_size);
-
-        if (size == 0)
-            return E_FILE_FORMAT_INVALID;  //TODO: verify this
-
-        pos += len;  //consume length of size of element
-
-        const long long unknown_size = (1LL << (7 * len)) - 1;
-
-        if (size != unknown_size)
-            cluster_size = size;
+  {
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
     }
 
-    //pos points to start of payload
+    long long result = GetUIntLength(pReader, pos, len);
+
+    if (result < 0)  // error or underflow
+      return static_cast<long>(result);
+
+    if (result > 0)  // underflow (weird)
+      return E_BUFFER_NOT_FULL;
+
+    // if ((pos + len) > segment_stop)
+    //    return E_FILE_FORMAT_INVALID;
+
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
+
+    const long long id_ = ReadUInt(pReader, pos, len);
+
+    if (id_ < 0)  // error
+      return static_cast<long>(id_);
+
+    if (id_ != 0x0F43B675)  // Cluster ID
+      return E_FILE_FORMAT_INVALID;
+
+    pos += len;  // consume id
+
+    // read cluster size
+
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
+    }
+
+    result = GetUIntLength(pReader, pos, len);
+
+    if (result < 0)  // error
+      return static_cast<long>(result);
+
+    if (result > 0)  // weird
+      return E_BUFFER_NOT_FULL;
+
+    // if ((pos + len) > segment_stop)
+    //    return E_FILE_FORMAT_INVALID;
+
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
+
+    const long long size = ReadUInt(pReader, pos, len);
+
+    if (size < 0)  // error
+      return static_cast<long>(cluster_size);
+
+    if (size == 0)
+      return E_FILE_FORMAT_INVALID;  // TODO: verify this
+
+    pos += len;  // consume length of size of element
+
+    const long long unknown_size = (1LL << (7 * len)) - 1;
+
+    if (size != unknown_size)
+      cluster_size = size;
+  }
+
+// pos points to start of payload
 
 #if 0
     len = static_cast<long>(size_);
@@ -7086,403 +6127,376 @@

         return E_BUFFER_NOT_FULL;
 #endif
 
-    long long timecode = -1;
-    long long new_pos = -1;
-    bool bBlock = false;
+  long long timecode = -1;
+  long long new_pos = -1;
+  bool bBlock = false;
 
-    long long cluster_stop = (cluster_size < 0) ? -1 : pos + cluster_size;
+  long long cluster_stop = (cluster_size < 0) ? -1 : pos + cluster_size;
 
-    for (;;)
-    {
-        if ((cluster_stop >= 0) && (pos >= cluster_stop))
-            break;
+  for (;;) {
+    if ((cluster_stop >= 0) && (pos >= cluster_stop))
+      break;
 
-        //Parse ID
+    // Parse ID
 
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
-
-        long long result = GetUIntLength(pReader, pos, len);
-
-        if (result < 0)  //error
-            return static_cast<long>(result);
-
-        if (result > 0)  //weird
-            return E_BUFFER_NOT_FULL;
-
-        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
-
-        const long long id = ReadUInt(pReader, pos, len);
-
-        if (id < 0) //error
-            return static_cast<long>(id);
-
-        if (id == 0)
-            return E_FILE_FORMAT_INVALID;
-
-        //This is the distinguished set of ID's we use to determine
-        //that we have exhausted the sub-element's inside the cluster
-        //whose ID we parsed earlier.
-
-        if (id == 0x0F43B675)  //Cluster ID
-            break;
-
-        if (id == 0x0C53BB6B)  //Cues ID
-            break;
-
-        pos += len;  //consume ID field
-
-        //Parse Size
-
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
-
-        result = GetUIntLength(pReader, pos, len);
-
-        if (result < 0)  //error
-            return static_cast<long>(result);
-
-        if (result > 0)  //weird
-            return E_BUFFER_NOT_FULL;
-
-        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
-
-        const long long size = ReadUInt(pReader, pos, len);
-
-        if (size < 0)  //error
-            return static_cast<long>(size);
-
-        const long long unknown_size = (1LL << (7 * len)) - 1;
-
-        if (size == unknown_size)
-            return E_FILE_FORMAT_INVALID;
-
-        pos += len;  //consume size field
-
-        if ((cluster_stop >= 0) && (pos > cluster_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        //pos now points to start of payload
-
-        if (size == 0)  //weird
-            continue;
-
-        if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        if (id == 0x67)  //TimeCode ID
-        {
-            len = static_cast<long>(size);
-
-            if ((pos + size) > avail)
-                return E_BUFFER_NOT_FULL;
-
-            timecode = UnserializeUInt(pReader, pos, size);
-
-            if (timecode < 0)  //error (or underflow)
-                return static_cast<long>(timecode);
-
-            new_pos = pos + size;
-
-            if (bBlock)
-                break;
-        }
-        else if (id == 0x20)  //BlockGroup ID
-        {
-            bBlock = true;
-            break;
-        }
-        else if (id == 0x23)  //SimpleBlock ID
-        {
-            bBlock = true;
-            break;
-        }
-
-        pos += size;  //consume payload
-        assert((cluster_stop < 0) || (pos <= cluster_stop));
-    }
-
-    assert((cluster_stop < 0) || (pos <= cluster_stop));
-
-    if (timecode < 0)  //no timecode found
-        return E_FILE_FORMAT_INVALID;
-
-    if (!bBlock)
-        return E_FILE_FORMAT_INVALID;
-
-    m_pos = new_pos;  //designates position just beyond timecode payload
-    m_timecode = timecode;  // m_timecode >= 0 means we're partially loaded
-
-    if (cluster_size >= 0)
-        m_element_size = cluster_stop - m_element_start;
-
-    return 0;
-}
-
-
-long Cluster::Parse(long long& pos, long& len) const
-{
-    long status = Load(pos, len);
-
-    if (status < 0)
-        return status;
-
-    assert(m_pos >= m_element_start);
-    assert(m_timecode >= 0);
-    //assert(m_size > 0);
-    //assert(m_element_size > m_size);
-
-    const long long cluster_stop =
-        (m_element_size < 0) ? -1 : m_element_start + m_element_size;
-
-    if ((cluster_stop >= 0) && (m_pos >= cluster_stop))
-        return 1;  //nothing else to do
-
-    IMkvReader* const pReader = m_pSegment->m_pReader;
-
-    long long total, avail;
-
-    status = pReader->Length(&total, &avail);
-
-    if (status < 0)  //error
-        return status;
-
-    assert((total < 0) || (avail <= total));
-
-    pos = m_pos;
-
-    for (;;)
-    {
-        if ((cluster_stop >= 0) && (pos >= cluster_stop))
-            break;
-
-        if ((total >= 0) && (pos >= total))
-        {
-            if (m_element_size < 0)
-                m_element_size = pos - m_element_start;
-
-            break;
-        }
-
-        //Parse ID
-
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
-
-        long long result = GetUIntLength(pReader, pos, len);
-
-        if (result < 0)  //error
-            return static_cast<long>(result);
-
-        if (result > 0)  //weird
-            return E_BUFFER_NOT_FULL;
-
-        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
-
-        const long long id = ReadUInt(pReader, pos, len);
-
-        if (id < 0) //error
-            return static_cast<long>(id);
-
-        if (id == 0)  //weird
-            return E_FILE_FORMAT_INVALID;
-
-        //This is the distinguished set of ID's we use to determine
-        //that we have exhausted the sub-element's inside the cluster
-        //whose ID we parsed earlier.
-
-        if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) //Cluster or Cues ID
-        {
-            if (m_element_size < 0)
-                m_element_size = pos - m_element_start;
-
-            break;
-        }
-
-        pos += len;  //consume ID field
-
-        //Parse Size
-
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
-
-        result = GetUIntLength(pReader, pos, len);
-
-        if (result < 0)  //error
-            return static_cast<long>(result);
-
-        if (result > 0)  //weird
-            return E_BUFFER_NOT_FULL;
-
-        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
-
-        const long long size = ReadUInt(pReader, pos, len);
-
-        if (size < 0)  //error
-            return static_cast<long>(size);
-
-        const long long unknown_size = (1LL << (7 * len)) - 1;
-
-        if (size == unknown_size)
-            return E_FILE_FORMAT_INVALID;
-
-        pos += len;  //consume size field
-
-        if ((cluster_stop >= 0) && (pos > cluster_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        //pos now points to start of payload
-
-        if (size == 0)  //weird
-            continue;
-
-        //const long long block_start = pos;
-        const long long block_stop = pos + size;
-
-        if (cluster_stop >= 0)
-        {
-            if (block_stop > cluster_stop)
-            {
-                if ((id == 0x20) || (id == 0x23))
-                    return E_FILE_FORMAT_INVALID;
-
-                pos = cluster_stop;
-                break;
-            }
-        }
-        else if ((total >= 0) && (block_stop > total))
-        {
-            m_element_size = total - m_element_start;
-            pos = total;
-            break;
-        }
-        else if (block_stop > avail)
-        {
-            len = static_cast<long>(size);
-            return E_BUFFER_NOT_FULL;
-        }
-
-        Cluster* const this_ = const_cast<Cluster*>(this);
-
-        if (id == 0x20)  //BlockGroup
-            return this_->ParseBlockGroup(size, pos, len);
-
-        if (id == 0x23)  //SimpleBlock
-            return this_->ParseSimpleBlock(size, pos, len);
-
-        pos += size;  //consume payload
-        assert((cluster_stop < 0) || (pos <= cluster_stop));
-    }
-
-    assert(m_element_size > 0);
-
-    m_pos = pos;
-    assert((cluster_stop < 0) || (m_pos <= cluster_stop));
-
-    if (m_entries_count > 0)
-    {
-        const long idx = m_entries_count - 1;
-
-        const BlockEntry* const pLast = m_entries[idx];
-        assert(pLast);
-
-        const Block* const pBlock = pLast->GetBlock();
-        assert(pBlock);
-
-        const long long start = pBlock->m_start;
-
-        if ((total >= 0) && (start > total))
-            return -1;  //defend against trucated stream
-
-        const long long size = pBlock->m_size;
-
-        const long long stop = start + size;
-        assert((cluster_stop < 0) || (stop <= cluster_stop));
-
-        if ((total >= 0) && (stop > total))
-            return -1;  //defend against trucated stream
-    }
-
-    return 1;  //no more entries
-}
-
-
-long Cluster::ParseSimpleBlock(
-    long long block_size,
-    long long& pos,
-    long& len)
-{
-    const long long block_start = pos;
-    const long long block_stop = pos + block_size;
-
-    IMkvReader* const pReader = m_pSegment->m_pReader;
-
-    long long total, avail;
-
-    long status = pReader->Length(&total, &avail);
-
-    if (status < 0)  //error
-        return status;
-
-    assert((total < 0) || (avail <= total));
-
-    //parse track number
-
-    if ((pos + 1) > avail)
-    {
-        len = 1;
-        return E_BUFFER_NOT_FULL;
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
     }
 
     long long result = GetUIntLength(pReader, pos, len);
 
-    if (result < 0)  //error
-        return static_cast<long>(result);
+    if (result < 0)  // error
+      return static_cast<long>(result);
 
-    if (result > 0)  //weird
-        return E_BUFFER_NOT_FULL;
+    if (result > 0)  // weird
+      return E_BUFFER_NOT_FULL;
 
-    if ((pos + len) > block_stop)
-        return E_FILE_FORMAT_INVALID;
+    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
+      return E_FILE_FORMAT_INVALID;
 
     if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
+
+    const long long id = ReadUInt(pReader, pos, len);
+
+    if (id < 0)  // error
+      return static_cast<long>(id);
+
+    if (id == 0)
+      return E_FILE_FORMAT_INVALID;
+
+    // This is the distinguished set of ID's we use to determine
+    // that we have exhausted the sub-element's inside the cluster
+    // whose ID we parsed earlier.
+
+    if (id == 0x0F43B675)  // Cluster ID
+      break;
+
+    if (id == 0x0C53BB6B)  // Cues ID
+      break;
+
+    pos += len;  // consume ID field
+
+    // Parse Size
+
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
+    }
+
+    result = GetUIntLength(pReader, pos, len);
+
+    if (result < 0)  // error
+      return static_cast<long>(result);
+
+    if (result > 0)  // weird
+      return E_BUFFER_NOT_FULL;
+
+    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
+      return E_FILE_FORMAT_INVALID;
+
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
+
+    const long long size = ReadUInt(pReader, pos, len);
+
+    if (size < 0)  // error
+      return static_cast<long>(size);
+
+    const long long unknown_size = (1LL << (7 * len)) - 1;
+
+    if (size == unknown_size)
+      return E_FILE_FORMAT_INVALID;
+
+    pos += len;  // consume size field
+
+    if ((cluster_stop >= 0) && (pos > cluster_stop))
+      return E_FILE_FORMAT_INVALID;
+
+    // pos now points to start of payload
+
+    if (size == 0)  // weird
+      continue;
+
+    if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))
+      return E_FILE_FORMAT_INVALID;
+
+    if (id == 0x67) {  // TimeCode ID
+      len = static_cast<long>(size);
+
+      if ((pos + size) > avail)
         return E_BUFFER_NOT_FULL;
 
-    const long long track = ReadUInt(pReader, pos, len);
+      timecode = UnserializeUInt(pReader, pos, size);
 
-    if (track < 0) //error
-        return static_cast<long>(track);
+      if (timecode < 0)  // error (or underflow)
+        return static_cast<long>(timecode);
 
-    if (track == 0)
-        return E_FILE_FORMAT_INVALID;
+      new_pos = pos + size;
+
+      if (bBlock)
+        break;
+    } else if (id == 0x20) {  // BlockGroup ID
+      bBlock = true;
+      break;
+    } else if (id == 0x23) {  // SimpleBlock ID
+      bBlock = true;
+      break;
+    }
+
+    pos += size;  // consume payload
+    assert((cluster_stop < 0) || (pos <= cluster_stop));
+  }
+
+  assert((cluster_stop < 0) || (pos <= cluster_stop));
+
+  if (timecode < 0)  // no timecode found
+    return E_FILE_FORMAT_INVALID;
+
+  if (!bBlock)
+    return E_FILE_FORMAT_INVALID;
+
+  m_pos = new_pos;  // designates position just beyond timecode payload
+  m_timecode = timecode;  // m_timecode >= 0 means we're partially loaded
+
+  if (cluster_size >= 0)
+    m_element_size = cluster_stop - m_element_start;
+
+  return 0;
+}
+
+long Cluster::Parse(long long& pos, long& len) const {
+  long status = Load(pos, len);
+
+  if (status < 0)
+    return status;
+
+  assert(m_pos >= m_element_start);
+  assert(m_timecode >= 0);
+  // assert(m_size > 0);
+  // assert(m_element_size > m_size);
+
+  const long long cluster_stop =
+      (m_element_size < 0) ? -1 : m_element_start + m_element_size;
+
+  if ((cluster_stop >= 0) && (m_pos >= cluster_stop))
+    return 1;  // nothing else to do
+
+  IMkvReader* const pReader = m_pSegment->m_pReader;
+
+  long long total, avail;
+
+  status = pReader->Length(&total, &avail);
+
+  if (status < 0)  // error
+    return status;
+
+  assert((total < 0) || (avail <= total));
+
+  pos = m_pos;
+
+  for (;;) {
+    if ((cluster_stop >= 0) && (pos >= cluster_stop))
+      break;
+
+    if ((total >= 0) && (pos >= total)) {
+      if (m_element_size < 0)
+        m_element_size = pos - m_element_start;
+
+      break;
+    }
+
+    // Parse ID
+
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
+    }
+
+    long long result = GetUIntLength(pReader, pos, len);
+
+    if (result < 0)  // error
+      return static_cast<long>(result);
+
+    if (result > 0)  // weird
+      return E_BUFFER_NOT_FULL;
+
+    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
+      return E_FILE_FORMAT_INVALID;
+
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
+
+    const long long id = ReadUInt(pReader, pos, len);
+
+    if (id < 0)  // error
+      return static_cast<long>(id);
+
+    if (id == 0)  // weird
+      return E_FILE_FORMAT_INVALID;
+
+    // This is the distinguished set of ID's we use to determine
+    // that we have exhausted the sub-element's inside the cluster
+    // whose ID we parsed earlier.
+
+    if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) {  // Cluster or Cues ID
+      if (m_element_size < 0)
+        m_element_size = pos - m_element_start;
+
+      break;
+    }
+
+    pos += len;  // consume ID field
+
+    // Parse Size
+
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
+    }
+
+    result = GetUIntLength(pReader, pos, len);
+
+    if (result < 0)  // error
+      return static_cast<long>(result);
+
+    if (result > 0)  // weird
+      return E_BUFFER_NOT_FULL;
+
+    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
+      return E_FILE_FORMAT_INVALID;
+
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
+
+    const long long size = ReadUInt(pReader, pos, len);
+
+    if (size < 0)  // error
+      return static_cast<long>(size);
+
+    const long long unknown_size = (1LL << (7 * len)) - 1;
+
+    if (size == unknown_size)
+      return E_FILE_FORMAT_INVALID;
+
+    pos += len;  // consume size field
+
+    if ((cluster_stop >= 0) && (pos > cluster_stop))
+      return E_FILE_FORMAT_INVALID;
+
+    // pos now points to start of payload
+
+    if (size == 0)  // weird
+      continue;
+
+    // const long long block_start = pos;
+    const long long block_stop = pos + size;
+
+    if (cluster_stop >= 0) {
+      if (block_stop > cluster_stop) {
+        if ((id == 0x20) || (id == 0x23))
+          return E_FILE_FORMAT_INVALID;
+
+        pos = cluster_stop;
+        break;
+      }
+    } else if ((total >= 0) && (block_stop > total)) {
+      m_element_size = total - m_element_start;
+      pos = total;
+      break;
+    } else if (block_stop > avail) {
+      len = static_cast<long>(size);
+      return E_BUFFER_NOT_FULL;
+    }
+
+    Cluster* const this_ = const_cast<Cluster*>(this);
+
+    if (id == 0x20)  // BlockGroup
+      return this_->ParseBlockGroup(size, pos, len);
+
+    if (id == 0x23)  // SimpleBlock
+      return this_->ParseSimpleBlock(size, pos, len);
+
+    pos += size;  // consume payload
+    assert((cluster_stop < 0) || (pos <= cluster_stop));
+  }
+
+  assert(m_element_size > 0);
+
+  m_pos = pos;
+  assert((cluster_stop < 0) || (m_pos <= cluster_stop));
+
+  if (m_entries_count > 0) {
+    const long idx = m_entries_count - 1;
+
+    const BlockEntry* const pLast = m_entries[idx];
+    assert(pLast);
+
+    const Block* const pBlock = pLast->GetBlock();
+    assert(pBlock);
+
+    const long long start = pBlock->m_start;
+
+    if ((total >= 0) && (start > total))
+      return -1;  // defend against trucated stream
+
+    const long long size = pBlock->m_size;
+
+    const long long stop = start + size;
+    assert((cluster_stop < 0) || (stop <= cluster_stop));
+
+    if ((total >= 0) && (stop > total))
+      return -1;  // defend against trucated stream
+  }
+
+  return 1;  // no more entries
+}
+
+long Cluster::ParseSimpleBlock(long long block_size, long long& pos,
+                               long& len) {
+  const long long block_start = pos;
+  const long long block_stop = pos + block_size;
+
+  IMkvReader* const pReader = m_pSegment->m_pReader;
+
+  long long total, avail;
+
+  long status = pReader->Length(&total, &avail);
+
+  if (status < 0)  // error
+    return status;
+
+  assert((total < 0) || (avail <= total));
+
+  // parse track number
+
+  if ((pos + 1) > avail) {
+    len = 1;
+    return E_BUFFER_NOT_FULL;
+  }
+
+  long long result = GetUIntLength(pReader, pos, len);
+
+  if (result < 0)  // error
+    return static_cast<long>(result);
+
+  if (result > 0)  // weird
+    return E_BUFFER_NOT_FULL;
+
+  if ((pos + len) > block_stop)
+    return E_FILE_FORMAT_INVALID;
+
+  if ((pos + len) > avail)
+    return E_BUFFER_NOT_FULL;
+
+  const long long track = ReadUInt(pReader, pos, len);
+
+  if (track < 0)  // error
+    return static_cast<long>(track);
+
+  if (track == 0)
+    return E_FILE_FORMAT_INVALID;
 
 #if 0
     //TODO(matthewjheaney)
@@ -7514,228 +6528,208 @@

         return E_FILE_FORMAT_INVALID;
 #endif
 
-    pos += len;  //consume track number
+  pos += len;  // consume track number
 
-    if ((pos + 2) > block_stop)
-        return E_FILE_FORMAT_INVALID;
+  if ((pos + 2) > block_stop)
+    return E_FILE_FORMAT_INVALID;
 
-    if ((pos + 2) > avail)
-    {
-        len = 2;
-        return E_BUFFER_NOT_FULL;
-    }
+  if ((pos + 2) > avail) {
+    len = 2;
+    return E_BUFFER_NOT_FULL;
+  }
 
-    pos += 2;  //consume timecode
+  pos += 2;  // consume timecode
 
-    if ((pos + 1) > block_stop)
-        return E_FILE_FORMAT_INVALID;
+  if ((pos + 1) > block_stop)
+    return E_FILE_FORMAT_INVALID;
 
-    if ((pos + 1) > avail)
-    {
-        len = 1;
-        return E_BUFFER_NOT_FULL;
-    }
+  if ((pos + 1) > avail) {
+    len = 1;
+    return E_BUFFER_NOT_FULL;
+  }
 
-    unsigned char flags;
+  unsigned char flags;
 
-    status = pReader->Read(pos, 1, &flags);
+  status = pReader->Read(pos, 1, &flags);
 
-    if (status < 0)  //error or underflow
-    {
-        len = 1;
-        return status;
-    }
+  if (status < 0) {  // error or underflow
+    len = 1;
+    return status;
+  }
 
-    ++pos;  //consume flags byte
-    assert(pos <= avail);
+  ++pos;  // consume flags byte
+  assert(pos <= avail);
 
-    if (pos >= block_stop)
-        return E_FILE_FORMAT_INVALID;
+  if (pos >= block_stop)
+    return E_FILE_FORMAT_INVALID;
 
-    const int lacing = int(flags & 0x06) >> 1;
+  const int lacing = int(flags & 0x06) >> 1;
 
-    if ((lacing != 0) && (block_stop > avail))
-    {
-        len = static_cast<long>(block_stop - pos);
-        return E_BUFFER_NOT_FULL;
-    }
+  if ((lacing != 0) && (block_stop > avail)) {
+    len = static_cast<long>(block_stop - pos);
+    return E_BUFFER_NOT_FULL;
+  }
 
-    status = CreateBlock(0x23,  //simple block id
-                         block_start, block_size,
-                         0);  //DiscardPadding
+  status = CreateBlock(0x23,  // simple block id
+                       block_start, block_size,
+                       0);  // DiscardPadding
 
-    if (status != 0)
-        return status;
+  if (status != 0)
+    return status;
 
-    m_pos = block_stop;
+  m_pos = block_stop;
 
-    return 0;  //success
+  return 0;  // success
 }
 
+long Cluster::ParseBlockGroup(long long payload_size, long long& pos,
+                              long& len) {
+  const long long payload_start = pos;
+  const long long payload_stop = pos + payload_size;
 
-long Cluster::ParseBlockGroup(
-    long long payload_size,
-    long long& pos,
-    long& len)
-{
-    const long long payload_start = pos;
-    const long long payload_stop = pos + payload_size;
+  IMkvReader* const pReader = m_pSegment->m_pReader;
 
-    IMkvReader* const pReader = m_pSegment->m_pReader;
+  long long total, avail;
 
-    long long total, avail;
+  long status = pReader->Length(&total, &avail);
 
-    long status = pReader->Length(&total, &avail);
+  if (status < 0)  // error
+    return status;
 
-    if (status < 0)  //error
-        return status;
+  assert((total < 0) || (avail <= total));
 
-    assert((total < 0) || (avail <= total));
+  if ((total >= 0) && (payload_stop > total))
+    return E_FILE_FORMAT_INVALID;
 
-    if ((total >= 0) && (payload_stop > total))
-        return E_FILE_FORMAT_INVALID;
+  if (payload_stop > avail) {
+    len = static_cast<long>(payload_size);
+    return E_BUFFER_NOT_FULL;
+  }
 
-    if (payload_stop > avail)
-    {
-         len = static_cast<long>(payload_size);
-         return E_BUFFER_NOT_FULL;
+  long long discard_padding = 0;
+
+  while (pos < payload_stop) {
+    // parse sub-block element ID
+
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
     }
 
-    long long discard_padding = 0;
+    long long result = GetUIntLength(pReader, pos, len);
 
-    while (pos < payload_stop)
-    {
-        //parse sub-block element ID
+    if (result < 0)  // error
+      return static_cast<long>(result);
 
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
+    if (result > 0)  // weird
+      return E_BUFFER_NOT_FULL;
 
-        long long result = GetUIntLength(pReader, pos, len);
+    if ((pos + len) > payload_stop)
+      return E_FILE_FORMAT_INVALID;
 
-        if (result < 0)  //error
-            return static_cast<long>(result);
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
 
-        if (result > 0)  //weird
-            return E_BUFFER_NOT_FULL;
+    const long long id = ReadUInt(pReader, pos, len);
 
-        if ((pos + len) > payload_stop)
-            return E_FILE_FORMAT_INVALID;
+    if (id < 0)  // error
+      return static_cast<long>(id);
 
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
+    if (id == 0)  // not a value ID
+      return E_FILE_FORMAT_INVALID;
 
-        const long long id = ReadUInt(pReader, pos, len);
+    pos += len;  // consume ID field
 
-        if (id < 0) //error
-            return static_cast<long>(id);
+    // Parse Size
 
-        if (id == 0)  //not a value ID
-            return E_FILE_FORMAT_INVALID;
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
+    }
 
-        pos += len;  //consume ID field
+    result = GetUIntLength(pReader, pos, len);
 
-        //Parse Size
+    if (result < 0)  // error
+      return static_cast<long>(result);
 
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
+    if (result > 0)  // weird
+      return E_BUFFER_NOT_FULL;
 
-        result = GetUIntLength(pReader, pos, len);
+    if ((pos + len) > payload_stop)
+      return E_FILE_FORMAT_INVALID;
 
-        if (result < 0)  //error
-            return static_cast<long>(result);
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
 
-        if (result > 0)  //weird
-            return E_BUFFER_NOT_FULL;
+    const long long size = ReadUInt(pReader, pos, len);
 
-        if ((pos + len) > payload_stop)
-            return E_FILE_FORMAT_INVALID;
+    if (size < 0)  // error
+      return static_cast<long>(size);
 
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
+    pos += len;  // consume size field
 
-        const long long size = ReadUInt(pReader, pos, len);
+    // pos now points to start of sub-block group payload
 
-        if (size < 0)  //error
-            return static_cast<long>(size);
+    if (pos > payload_stop)
+      return E_FILE_FORMAT_INVALID;
 
-        pos += len;  //consume size field
+    if (size == 0)  // weird
+      continue;
 
-        //pos now points to start of sub-block group payload
+    const long long unknown_size = (1LL << (7 * len)) - 1;
 
-        if (pos > payload_stop)
-            return E_FILE_FORMAT_INVALID;
+    if (size == unknown_size)
+      return E_FILE_FORMAT_INVALID;
 
-        if (size == 0)  //weird
-            continue;
+    if (id == 0x35A2) {  // DiscardPadding
+      status = UnserializeInt(pReader, pos, size, discard_padding);
 
-        const long long unknown_size = (1LL << (7 * len)) - 1;
+      if (status < 0)  // error
+        return status;
+    }
 
-        if (size == unknown_size)
-            return E_FILE_FORMAT_INVALID;
+    if (id != 0x21) {  // sub-part of BlockGroup is not a Block
+      pos += size;  // consume sub-part of block group
 
-        if (id == 0x35A2)  //DiscardPadding
-        {
-            result = GetUIntLength(pReader, pos, len);
+      if (pos > payload_stop)
+        return E_FILE_FORMAT_INVALID;
 
-            if (result < 0)  //error
-                return static_cast<long>(result);
+      continue;
+    }
 
-            status = UnserializeInt(pReader, pos, len, discard_padding);
+    const long long block_stop = pos + size;
 
-            if (status < 0)  //error
-                return status;
-        }
+    if (block_stop > payload_stop)
+      return E_FILE_FORMAT_INVALID;
 
-        if (id != 0x21)  //sub-part of BlockGroup is not a Block
-        {
-            pos += size;  //consume sub-part of block group
+    // parse track number
 
-            if (pos > payload_stop)
-                return E_FILE_FORMAT_INVALID;
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
+    }
 
-            continue;
-        }
+    result = GetUIntLength(pReader, pos, len);
 
-        const long long block_stop = pos + size;
+    if (result < 0)  // error
+      return static_cast<long>(result);
 
-        if (block_stop > payload_stop)
-            return E_FILE_FORMAT_INVALID;
+    if (result > 0)  // weird
+      return E_BUFFER_NOT_FULL;
 
-        //parse track number
+    if ((pos + len) > block_stop)
+      return E_FILE_FORMAT_INVALID;
 
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
 
-        result = GetUIntLength(pReader, pos, len);
+    const long long track = ReadUInt(pReader, pos, len);
 
-        if (result < 0)  //error
-            return static_cast<long>(result);
+    if (track < 0)  // error
+      return static_cast<long>(track);
 
-        if (result > 0)  //weird
-            return E_BUFFER_NOT_FULL;
-
-        if ((pos + len) > block_stop)
-            return E_FILE_FORMAT_INVALID;
-
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
-
-        const long long track = ReadUInt(pReader, pos, len);
-
-        if (track < 0) //error
-            return static_cast<long>(track);
-
-        if (track == 0)
-            return E_FILE_FORMAT_INVALID;
+    if (track == 0)
+      return E_FILE_FORMAT_INVALID;
 
 #if 0
         //TODO(matthewjheaney)
@@ -7767,213 +6761,173 @@

             return E_FILE_FORMAT_INVALID;
 #endif
 
-        pos += len;  //consume track number
+    pos += len;  // consume track number
 
-        if ((pos + 2) > block_stop)
-            return E_FILE_FORMAT_INVALID;
+    if ((pos + 2) > block_stop)
+      return E_FILE_FORMAT_INVALID;
 
-        if ((pos + 2) > avail)
-        {
-            len = 2;
-            return E_BUFFER_NOT_FULL;
-        }
-
-        pos += 2;  //consume timecode
-
-        if ((pos + 1) > block_stop)
-            return E_FILE_FORMAT_INVALID;
-
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
-
-        unsigned char flags;
-
-        status = pReader->Read(pos, 1, &flags);
-
-        if (status < 0)  //error or underflow
-        {
-            len = 1;
-            return status;
-        }
-
-        ++pos;  //consume flags byte
-        assert(pos <= avail);
-
-        if (pos >= block_stop)
-            return E_FILE_FORMAT_INVALID;
-
-        const int lacing = int(flags & 0x06) >> 1;
-
-        if ((lacing != 0) && (block_stop > avail))
-        {
-            len = static_cast<long>(block_stop - pos);
-            return E_BUFFER_NOT_FULL;
-        }
-
-        pos = block_stop;  //consume block-part of block group
-        assert(pos <= payload_stop);
+    if ((pos + 2) > avail) {
+      len = 2;
+      return E_BUFFER_NOT_FULL;
     }
 
-    assert(pos == payload_stop);
+    pos += 2;  // consume timecode
 
-    status = CreateBlock(0x20,  //BlockGroup ID
-                         payload_start, payload_size,
-                         discard_padding);
-    if (status != 0)
-        return status;
+    if ((pos + 1) > block_stop)
+      return E_FILE_FORMAT_INVALID;
 
-    m_pos = payload_stop;
-
-    return 0;  //success
-}
-
-
-long Cluster::GetEntry(long index, const mkvparser::BlockEntry*& pEntry) const
-{
-    assert(m_pos >= m_element_start);
-
-    pEntry = NULL;
-
-    if (index < 0)
-        return -1;  //generic error
-
-    if (m_entries_count < 0)
-        return E_BUFFER_NOT_FULL;
-
-    assert(m_entries);
-    assert(m_entries_size > 0);
-    assert(m_entries_count <= m_entries_size);
-
-    if (index < m_entries_count)
-    {
-        pEntry = m_entries[index];
-        assert(pEntry);
-
-        return 1;  //found entry
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
     }
 
-    if (m_element_size < 0)        //we don't know cluster end yet
-        return E_BUFFER_NOT_FULL;  //underflow
+    unsigned char flags;
 
-    const long long element_stop = m_element_start + m_element_size;
+    status = pReader->Read(pos, 1, &flags);
 
-    if (m_pos >= element_stop)
-        return 0;  //nothing left to parse
-
-    return E_BUFFER_NOT_FULL;  //underflow, since more remains to be parsed
-}
-
-
-Cluster* Cluster::Create(
-    Segment* pSegment,
-    long idx,
-    long long off)
-    //long long element_size)
-{
-    assert(pSegment);
-    assert(off >= 0);
-
-    const long long element_start = pSegment->m_start + off;
-
-    Cluster* const pCluster = new Cluster(pSegment,
-                                          idx,
-                                          element_start);
-                                          //element_size);
-    assert(pCluster);
-
-    return pCluster;
-}
-
-
-Cluster::Cluster() :
-    m_pSegment(NULL),
-    m_element_start(0),
-    m_index(0),
-    m_pos(0),
-    m_element_size(0),
-    m_timecode(0),
-    m_entries(NULL),
-    m_entries_size(0),
-    m_entries_count(0)  //means ""no entries""
-{
-}
-
-
-Cluster::Cluster(
-    Segment* pSegment,
-    long idx,
-    long long element_start
-    /* long long element_size */ ) :
-    m_pSegment(pSegment),
-    m_element_start(element_start),
-    m_index(idx),
-    m_pos(element_start),
-    m_element_size(-1 /* element_size */ ),
-    m_timecode(-1),
-    m_entries(NULL),
-    m_entries_size(0),
-    m_entries_count(-1)  //means ""has not been parsed yet""
-{
-}
-
-
-Cluster::~Cluster()
-{
-    if (m_entries_count <= 0)
-        return;
-
-    BlockEntry** i = m_entries;
-    BlockEntry** const j = m_entries + m_entries_count;
-
-    while (i != j)
-    {
-         BlockEntry* p = *i++;
-         assert(p);
-
-         delete p;
+    if (status < 0) {  // error or underflow
+      len = 1;
+      return status;
     }
 
-    delete[] m_entries;
+    ++pos;  // consume flags byte
+    assert(pos <= avail);
+
+    if (pos >= block_stop)
+      return E_FILE_FORMAT_INVALID;
+
+    const int lacing = int(flags & 0x06) >> 1;
+
+    if ((lacing != 0) && (block_stop > avail)) {
+      len = static_cast<long>(block_stop - pos);
+      return E_BUFFER_NOT_FULL;
+    }
+
+    pos = block_stop;  // consume block-part of block group
+    assert(pos <= payload_stop);
+  }
+
+  assert(pos == payload_stop);
+
+  status = CreateBlock(0x20,  // BlockGroup ID
+                       payload_start, payload_size, discard_padding);
+  if (status != 0)
+    return status;
+
+  m_pos = payload_stop;
+
+  return 0;  // success
 }
 
+long Cluster::GetEntry(long index, const mkvparser::BlockEntry*& pEntry) const {
+  assert(m_pos >= m_element_start);
 
-bool Cluster::EOS() const
+  pEntry = NULL;
+
+  if (index < 0)
+    return -1;  // generic error
+
+  if (m_entries_count < 0)
+    return E_BUFFER_NOT_FULL;
+
+  assert(m_entries);
+  assert(m_entries_size > 0);
+  assert(m_entries_count <= m_entries_size);
+
+  if (index < m_entries_count) {
+    pEntry = m_entries[index];
+    assert(pEntry);
+
+    return 1;  // found entry
+  }
+
+  if (m_element_size < 0)  // we don't know cluster end yet
+    return E_BUFFER_NOT_FULL;  // underflow
+
+  const long long element_stop = m_element_start + m_element_size;
+
+  if (m_pos >= element_stop)
+    return 0;  // nothing left to parse
+
+  return E_BUFFER_NOT_FULL;  // underflow, since more remains to be parsed
+}
+
+Cluster* Cluster::Create(Segment* pSegment, long idx, long long off)
+// long long element_size)
 {
-    return (m_pSegment == NULL);
+  assert(pSegment);
+  assert(off >= 0);
+
+  const long long element_start = pSegment->m_start + off;
+
+  Cluster* const pCluster = new Cluster(pSegment, idx, element_start);
+  // element_size);
+  assert(pCluster);
+
+  return pCluster;
 }
 
+Cluster::Cluster()
+    : m_pSegment(NULL),
+      m_element_start(0),
+      m_index(0),
+      m_pos(0),
+      m_element_size(0),
+      m_timecode(0),
+      m_entries(NULL),
+      m_entries_size(0),
+      m_entries_count(0)  // means ""no entries""
+{}
 
-long Cluster::GetIndex() const
-{
-    return m_index;
+Cluster::Cluster(Segment* pSegment, long idx, long long element_start
+                 /* long long element_size */)
+    : m_pSegment(pSegment),
+      m_element_start(element_start),
+      m_index(idx),
+      m_pos(element_start),
+      m_element_size(-1 /* element_size */),
+      m_timecode(-1),
+      m_entries(NULL),
+      m_entries_size(0),
+      m_entries_count(-1)  // means ""has not been parsed yet""
+{}
+
+Cluster::~Cluster() {
+  if (m_entries_count <= 0)
+    return;
+
+  BlockEntry** i = m_entries;
+  BlockEntry** const j = m_entries + m_entries_count;
+
+  while (i != j) {
+    BlockEntry* p = *i++;
+    assert(p);
+
+    delete p;
+  }
+
+  delete[] m_entries;
 }
 
+bool Cluster::EOS() const { return (m_pSegment == NULL); }
 
-long long Cluster::GetPosition() const
-{
-    const long long pos = m_element_start - m_pSegment->m_start;
-    assert(pos >= 0);
+long Cluster::GetIndex() const { return m_index; }
 
-    return pos;
+long long Cluster::GetPosition() const {
+  const long long pos = m_element_start - m_pSegment->m_start;
+  assert(pos >= 0);
+
+  return pos;
 }
 
-
-long long Cluster::GetElementSize() const
-{
-    return m_element_size;
-}
-
+long long Cluster::GetElementSize() const { return m_element_size; }
 
 #if 0
 bool Cluster::HasBlockEntries(
     const Segment* pSegment,
-    long long off)  //relative to start of segment payload
-{
+    long long off) {
     assert(pSegment);
-    assert(off >= 0);  //relative to segment
+    assert(off >= 0);  //relative to start of segment payload
 
     IMkvReader* const pReader = pSegment->m_pReader;
 
@@ -8030,631 +6984,558 @@

 }
 #endif
 
-
 long Cluster::HasBlockEntries(
     const Segment* pSegment,
-    long long off,  //relative to start of segment payload
-    long long& pos,
-    long& len)
-{
-    assert(pSegment);
-    assert(off >= 0);  //relative to segment
+    long long off,  // relative to start of segment payload
+    long long& pos, long& len) {
+  assert(pSegment);
+  assert(off >= 0);  // relative to segment
 
-    IMkvReader* const pReader = pSegment->m_pReader;
+  IMkvReader* const pReader = pSegment->m_pReader;
 
-    long long total, avail;
+  long long total, avail;
 
-    long status = pReader->Length(&total, &avail);
+  long status = pReader->Length(&total, &avail);
 
-    if (status < 0)  //error
-        return status;
+  if (status < 0)  // error
+    return status;
 
-    assert((total < 0) || (avail <= total));
+  assert((total < 0) || (avail <= total));
 
-    pos = pSegment->m_start + off;  //absolute
+  pos = pSegment->m_start + off;  // absolute
 
-    if ((total >= 0) && (pos >= total))
-        return 0;  //we don't even have a complete cluster
+  if ((total >= 0) && (pos >= total))
+    return 0;  // we don't even have a complete cluster
 
-    const long long segment_stop =
-        (pSegment->m_size < 0) ? -1 : pSegment->m_start + pSegment->m_size;
+  const long long segment_stop =
+      (pSegment->m_size < 0) ? -1 : pSegment->m_start + pSegment->m_size;
 
-    long long cluster_stop = -1;  //interpreted later to mean ""unknown size""
+  long long cluster_stop = -1;  // interpreted later to mean ""unknown size""
 
-    {
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
-
-        long long result = GetUIntLength(pReader, pos, len);
-
-        if (result < 0)  //error
-            return static_cast<long>(result);
-
-        if (result > 0)  //need more data
-            return E_BUFFER_NOT_FULL;
-
-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        if ((total >= 0) && ((pos + len) > total))
-            return 0;
-
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
-
-        const long long id = ReadUInt(pReader, pos, len);
-
-        if (id < 0)  //error
-            return static_cast<long>(id);
-
-        if (id != 0x0F43B675)  //weird: not cluster ID
-            return -1;         //generic error
-
-        pos += len;  //consume Cluster ID field
-
-        //read size field
-
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
-
-        result = GetUIntLength(pReader, pos, len);
-
-        if (result < 0)  //error
-            return static_cast<long>(result);
-
-        if (result > 0)  //weird
-            return E_BUFFER_NOT_FULL;
-
-        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        if ((total >= 0) && ((pos + len) > total))
-            return 0;
-
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
-
-        const long long size = ReadUInt(pReader, pos, len);
-
-        if (size < 0)  //error
-            return static_cast<long>(size);
-
-        if (size == 0)
-            return 0;  //cluster does not have entries
-
-        pos += len;  //consume size field
-
-        //pos now points to start of payload
-
-        const long long unknown_size = (1LL << (7 * len)) - 1;
-
-        if (size != unknown_size)
-        {
-            cluster_stop = pos + size;
-            assert(cluster_stop >= 0);
-
-            if ((segment_stop >= 0) && (cluster_stop > segment_stop))
-                return E_FILE_FORMAT_INVALID;
-
-            if ((total >= 0) && (cluster_stop > total))
-                //return E_FILE_FORMAT_INVALID;  //too conservative
-                return 0;  //cluster does not have any entries
-        }
+  {
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
     }
 
-    for (;;)
-    {
-        if ((cluster_stop >= 0) && (pos >= cluster_stop))
-            return 0;  //no entries detected
+    long long result = GetUIntLength(pReader, pos, len);
 
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
+    if (result < 0)  // error
+      return static_cast<long>(result);
 
-        long long result = GetUIntLength(pReader, pos, len);
+    if (result > 0)  // need more data
+      return E_BUFFER_NOT_FULL;
 
-        if (result < 0)  //error
-            return static_cast<long>(result);
+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
+      return E_FILE_FORMAT_INVALID;
 
-        if (result > 0)  //need more data
-            return E_BUFFER_NOT_FULL;
+    if ((total >= 0) && ((pos + len) > total))
+      return 0;
 
-        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
-            return E_FILE_FORMAT_INVALID;
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
 
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
+    const long long id = ReadUInt(pReader, pos, len);
 
-        const long long id = ReadUInt(pReader, pos, len);
+    if (id < 0)  // error
+      return static_cast<long>(id);
 
-        if (id < 0)  //error
-            return static_cast<long>(id);
+    if (id != 0x0F43B675)  // weird: not cluster ID
+      return -1;  // generic error
 
-        //This is the distinguished set of ID's we use to determine
-        //that we have exhausted the sub-element's inside the cluster
-        //whose ID we parsed earlier.
+    pos += len;  // consume Cluster ID field
 
-        if (id == 0x0F43B675)  //Cluster ID
-            return 0;  //no entries found
+    // read size field
 
-        if (id == 0x0C53BB6B)  //Cues ID
-            return 0;  //no entries found
-
-        pos += len;  //consume id field
-
-        if ((cluster_stop >= 0) && (pos >= cluster_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        //read size field
-
-        if ((pos + 1) > avail)
-        {
-            len = 1;
-            return E_BUFFER_NOT_FULL;
-        }
-
-        result = GetUIntLength(pReader, pos, len);
-
-        if (result < 0)  //error
-            return static_cast<long>(result);
-
-        if (result > 0)  //underflow
-            return E_BUFFER_NOT_FULL;
-
-        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        if ((pos + len) > avail)
-            return E_BUFFER_NOT_FULL;
-
-        const long long size = ReadUInt(pReader, pos, len);
-
-        if (size < 0)  //error
-            return static_cast<long>(size);
-
-        pos += len;  //consume size field
-
-        //pos now points to start of payload
-
-        if ((cluster_stop >= 0) && (pos > cluster_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        if (size == 0)  //weird
-            continue;
-
-        const long long unknown_size = (1LL << (7 * len)) - 1;
-
-        if (size == unknown_size)
-            return E_FILE_FORMAT_INVALID;  //not supported inside cluster
-
-        if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))
-            return E_FILE_FORMAT_INVALID;
-
-        if (id == 0x20)  //BlockGroup ID
-            return 1;    //have at least one entry
-
-        if (id == 0x23)  //SimpleBlock ID
-            return 1;    //have at least one entry
-
-        pos += size;  //consume payload
-        assert((cluster_stop < 0) || (pos <= cluster_stop));
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
     }
+
+    result = GetUIntLength(pReader, pos, len);
+
+    if (result < 0)  // error
+      return static_cast<long>(result);
+
+    if (result > 0)  // weird
+      return E_BUFFER_NOT_FULL;
+
+    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
+      return E_FILE_FORMAT_INVALID;
+
+    if ((total >= 0) && ((pos + len) > total))
+      return 0;
+
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
+
+    const long long size = ReadUInt(pReader, pos, len);
+
+    if (size < 0)  // error
+      return static_cast<long>(size);
+
+    if (size == 0)
+      return 0;  // cluster does not have entries
+
+    pos += len;  // consume size field
+
+    // pos now points to start of payload
+
+    const long long unknown_size = (1LL << (7 * len)) - 1;
+
+    if (size != unknown_size) {
+      cluster_stop = pos + size;
+      assert(cluster_stop >= 0);
+
+      if ((segment_stop >= 0) && (cluster_stop > segment_stop))
+        return E_FILE_FORMAT_INVALID;
+
+      if ((total >= 0) && (cluster_stop > total))
+        // return E_FILE_FORMAT_INVALID;  //too conservative
+        return 0;  // cluster does not have any entries
+    }
+  }
+
+  for (;;) {
+    if ((cluster_stop >= 0) && (pos >= cluster_stop))
+      return 0;  // no entries detected
+
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
+    }
+
+    long long result = GetUIntLength(pReader, pos, len);
+
+    if (result < 0)  // error
+      return static_cast<long>(result);
+
+    if (result > 0)  // need more data
+      return E_BUFFER_NOT_FULL;
+
+    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
+      return E_FILE_FORMAT_INVALID;
+
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
+
+    const long long id = ReadUInt(pReader, pos, len);
+
+    if (id < 0)  // error
+      return static_cast<long>(id);
+
+    // This is the distinguished set of ID's we use to determine
+    // that we have exhausted the sub-element's inside the cluster
+    // whose ID we parsed earlier.
+
+    if (id == 0x0F43B675)  // Cluster ID
+      return 0;  // no entries found
+
+    if (id == 0x0C53BB6B)  // Cues ID
+      return 0;  // no entries found
+
+    pos += len;  // consume id field
+
+    if ((cluster_stop >= 0) && (pos >= cluster_stop))
+      return E_FILE_FORMAT_INVALID;
+
+    // read size field
+
+    if ((pos + 1) > avail) {
+      len = 1;
+      return E_BUFFER_NOT_FULL;
+    }
+
+    result = GetUIntLength(pReader, pos, len);
+
+    if (result < 0)  // error
+      return static_cast<long>(result);
+
+    if (result > 0)  // underflow
+      return E_BUFFER_NOT_FULL;
+
+    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
+      return E_FILE_FORMAT_INVALID;
+
+    if ((pos + len) > avail)
+      return E_BUFFER_NOT_FULL;
+
+    const long long size = ReadUInt(pReader, pos, len);
+
+    if (size < 0)  // error
+      return static_cast<long>(size);
+
+    pos += len;  // consume size field
+
+    // pos now points to start of payload
+
+    if ((cluster_stop >= 0) && (pos > cluster_stop))
+      return E_FILE_FORMAT_INVALID;
+
+    if (size == 0)  // weird
+      continue;
+
+    const long long unknown_size = (1LL << (7 * len)) - 1;
+
+    if (size == unknown_size)
+      return E_FILE_FORMAT_INVALID;  // not supported inside cluster
+
+    if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))
+      return E_FILE_FORMAT_INVALID;
+
+    if (id == 0x20)  // BlockGroup ID
+      return 1;  // have at least one entry
+
+    if (id == 0x23)  // SimpleBlock ID
+      return 1;  // have at least one entry
+
+    pos += size;  // consume payload
+    assert((cluster_stop < 0) || (pos <= cluster_stop));
+  }
 }
 
+long long Cluster::GetTimeCode() const {
+  long long pos;
+  long len;
 
-long long Cluster::GetTimeCode() const
-{
+  const long status = Load(pos, len);
+
+  if (status < 0)  // error
+    return status;
+
+  return m_timecode;
+}
+
+long long Cluster::GetTime() const {
+  const long long tc = GetTimeCode();
+
+  if (tc < 0)
+    return tc;
+
+  const SegmentInfo* const pInfo = m_pSegment->GetInfo();
+  assert(pInfo);
+
+  const long long scale = pInfo->GetTimeCodeScale();
+  assert(scale >= 1);
+
+  const long long t = m_timecode * scale;
+
+  return t;
+}
+
+long long Cluster::GetFirstTime() const {
+  const BlockEntry* pEntry;
+
+  const long status = GetFirst(pEntry);
+
+  if (status < 0)  // error
+    return status;
+
+  if (pEntry == NULL)  // empty cluster
+    return GetTime();
+
+  const Block* const pBlock = pEntry->GetBlock();
+  assert(pBlock);
+
+  return pBlock->GetTime(this);
+}
+
+long long Cluster::GetLastTime() const {
+  const BlockEntry* pEntry;
+
+  const long status = GetLast(pEntry);
+
+  if (status < 0)  // error
+    return status;
+
+  if (pEntry == NULL)  // empty cluster
+    return GetTime();
+
+  const Block* const pBlock = pEntry->GetBlock();
+  assert(pBlock);
+
+  return pBlock->GetTime(this);
+}
+
+long Cluster::CreateBlock(long long id,
+                          long long pos,  // absolute pos of payload
+                          long long size, long long discard_padding) {
+  assert((id == 0x20) || (id == 0x23));  // BlockGroup or SimpleBlock
+
+  if (m_entries_count < 0) {  // haven't parsed anything yet
+    assert(m_entries == NULL);
+    assert(m_entries_size == 0);
+
+    m_entries_size = 1024;
+    m_entries = new BlockEntry* [m_entries_size];
+
+    m_entries_count = 0;
+  } else {
+    assert(m_entries);
+    assert(m_entries_size > 0);
+    assert(m_entries_count <= m_entries_size);
+
+    if (m_entries_count >= m_entries_size) {
+      const long entries_size = 2 * m_entries_size;
+
+      BlockEntry** const entries = new BlockEntry* [entries_size];
+      assert(entries);
+
+      BlockEntry** src = m_entries;
+      BlockEntry** const src_end = src + m_entries_count;
+
+      BlockEntry** dst = entries;
+
+      while (src != src_end)
+        *dst++ = *src++;
+
+      delete[] m_entries;
+
+      m_entries = entries;
+      m_entries_size = entries_size;
+    }
+  }
+
+  if (id == 0x20)  // BlockGroup ID
+    return CreateBlockGroup(pos, size, discard_padding);
+  else  // SimpleBlock ID
+    return CreateSimpleBlock(pos, size);
+}
+
+long Cluster::CreateBlockGroup(long long start_offset, long long size,
+                               long long discard_padding) {
+  assert(m_entries);
+  assert(m_entries_size > 0);
+  assert(m_entries_count >= 0);
+  assert(m_entries_count < m_entries_size);
+
+  IMkvReader* const pReader = m_pSegment->m_pReader;
+
+  long long pos = start_offset;
+  const long long stop = start_offset + size;
+
+  // For WebM files, there is a bias towards previous reference times
+  //(in order to support alt-ref frames, which refer back to the previous
+  // keyframe).  Normally a 0 value is not possible, but here we tenatively
+  // allow 0 as the value of a reference frame, with the interpretation
+  // that this is a ""previous"" reference time.
+
+  long long prev = 1;  // nonce
+  long long next = 0;  // nonce
+  long long duration = -1;  // really, this is unsigned
+
+  long long bpos = -1;
+  long long bsize = -1;
+
+  while (pos < stop) {
+    long len;
+    const long long id = ReadUInt(pReader, pos, len);
+    assert(id >= 0);  // TODO
+    assert((pos + len) <= stop);
+
+    pos += len;  // consume ID
+
+    const long long size = ReadUInt(pReader, pos, len);
+    assert(size >= 0);  // TODO
+    assert((pos + len) <= stop);
+
+    pos += len;  // consume size
+
+    if (id == 0x21) {  // Block ID
+      if (bpos < 0) {  // Block ID
+        bpos = pos;
+        bsize = size;
+      }
+    } else if (id == 0x1B) {  // Duration ID
+      assert(size <= 8);
+
+      duration = UnserializeUInt(pReader, pos, size);
+      assert(duration >= 0);  // TODO
+    } else if (id == 0x7B) {  // ReferenceBlock
+      assert(size <= 8);
+      const long size_ = static_cast<long>(size);
+
+      long long time;
+
+      long status = UnserializeInt(pReader, pos, size_, time);
+      assert(status == 0);
+      if (status != 0)
+        return -1;
+
+      if (time <= 0)  // see note above
+        prev = time;
+      else  // weird
+        next = time;
+    }
+
+    pos += size;  // consume payload
+    assert(pos <= stop);
+  }
+
+  assert(pos == stop);
+  assert(bpos >= 0);
+  assert(bsize >= 0);
+
+  const long idx = m_entries_count;
+
+  BlockEntry** const ppEntry = m_entries + idx;
+  BlockEntry*& pEntry = *ppEntry;
+
+  pEntry = new (std::nothrow)
+      BlockGroup(this, idx, bpos, bsize, prev, next, duration, discard_padding);
+
+  if (pEntry == NULL)
+    return -1;  // generic error
+
+  BlockGroup* const p = static_cast<BlockGroup*>(pEntry);
+
+  const long status = p->Parse();
+
+  if (status == 0) {  // success
+    ++m_entries_count;
+    return 0;
+  }
+
+  delete pEntry;
+  pEntry = 0;
+
+  return status;
+}
+
+long Cluster::CreateSimpleBlock(long long st, long long sz) {
+  assert(m_entries);
+  assert(m_entries_size > 0);
+  assert(m_entries_count >= 0);
+  assert(m_entries_count < m_entries_size);
+
+  const long idx = m_entries_count;
+
+  BlockEntry** const ppEntry = m_entries + idx;
+  BlockEntry*& pEntry = *ppEntry;
+
+  pEntry = new (std::nothrow) SimpleBlock(this, idx, st, sz);
+
+  if (pEntry == NULL)
+    return -1;  // generic error
+
+  SimpleBlock* const p = static_cast<SimpleBlock*>(pEntry);
+
+  const long status = p->Parse();
+
+  if (status == 0) {
+    ++m_entries_count;
+    return 0;
+  }
+
+  delete pEntry;
+  pEntry = 0;
+
+  return status;
+}
+
+long Cluster::GetFirst(const BlockEntry*& pFirst) const {
+  if (m_entries_count <= 0) {
     long long pos;
     long len;
 
-    const long status = Load(pos, len);
+    const long status = Parse(pos, len);
 
-    if (status < 0) //error
-        return status;
-
-    return m_timecode;
-}
-
-
-long long Cluster::GetTime() const
-{
-    const long long tc = GetTimeCode();
-
-    if (tc < 0)
-        return tc;
-
-    const SegmentInfo* const pInfo = m_pSegment->GetInfo();
-    assert(pInfo);
-
-    const long long scale = pInfo->GetTimeCodeScale();
-    assert(scale >= 1);
-
-    const long long t = m_timecode * scale;
-
-    return t;
-}
-
-
-long long Cluster::GetFirstTime() const
-{
-    const BlockEntry* pEntry;
-
-    const long status = GetFirst(pEntry);
-
-    if (status < 0)  //error
-        return status;
-
-    if (pEntry == NULL)  //empty cluster
-        return GetTime();
-
-    const Block* const pBlock = pEntry->GetBlock();
-    assert(pBlock);
-
-    return pBlock->GetTime(this);
-}
-
-
-long long Cluster::GetLastTime() const
-{
-    const BlockEntry* pEntry;
-
-    const long status = GetLast(pEntry);
-
-    if (status < 0)  //error
-        return status;
-
-    if (pEntry == NULL)  //empty cluster
-        return GetTime();
-
-    const Block* const pBlock = pEntry->GetBlock();
-    assert(pBlock);
-
-    return pBlock->GetTime(this);
-}
-
-
-long Cluster::CreateBlock(
-    long long id,
-    long long pos,   //absolute pos of payload
-    long long size,
-    long long discard_padding)
-{
-    assert((id == 0x20) || (id == 0x23));  //BlockGroup or SimpleBlock
-
-    if (m_entries_count < 0)  //haven't parsed anything yet
-    {
-        assert(m_entries == NULL);
-        assert(m_entries_size == 0);
-
-        m_entries_size = 1024;
-        m_entries = new BlockEntry*[m_entries_size];
-
-        m_entries_count = 0;
-    }
-    else
-    {
-        assert(m_entries);
-        assert(m_entries_size > 0);
-        assert(m_entries_count <= m_entries_size);
-
-        if (m_entries_count >= m_entries_size)
-        {
-            const long entries_size = 2 * m_entries_size;
-
-            BlockEntry** const entries = new BlockEntry*[entries_size];
-            assert(entries);
-
-            BlockEntry** src = m_entries;
-            BlockEntry** const src_end = src + m_entries_count;
-
-            BlockEntry** dst = entries;
-
-            while (src != src_end)
-                *dst++ = *src++;
-
-            delete[] m_entries;
-
-            m_entries = entries;
-            m_entries_size = entries_size;
-        }
+    if (status < 0) {  // error
+      pFirst = NULL;
+      return status;
     }
 
-    if (id == 0x20)  //BlockGroup ID
-        return CreateBlockGroup(pos, size, discard_padding);
-    else  //SimpleBlock ID
-        return CreateSimpleBlock(pos, size);
+    if (m_entries_count <= 0) {  // empty cluster
+      pFirst = NULL;
+      return 0;
+    }
+  }
+
+  assert(m_entries);
+
+  pFirst = m_entries[0];
+  assert(pFirst);
+
+  return 0;  // success
 }
 
+long Cluster::GetLast(const BlockEntry*& pLast) const {
+  for (;;) {
+    long long pos;
+    long len;
 
-long Cluster::CreateBlockGroup(
-    long long start_offset,
-    long long size,
-    long long discard_padding)
-{
-    assert(m_entries);
-    assert(m_entries_size > 0);
-    assert(m_entries_count >= 0);
-    assert(m_entries_count < m_entries_size);
+    const long status = Parse(pos, len);
 
-    IMkvReader* const pReader = m_pSegment->m_pReader;
-
-    long long pos = start_offset;
-    const long long stop = start_offset + size;
-
-    //For WebM files, there is a bias towards previous reference times
-    //(in order to support alt-ref frames, which refer back to the previous
-    //keyframe).  Normally a 0 value is not possible, but here we tenatively
-    //allow 0 as the value of a reference frame, with the interpretation
-    //that this is a ""previous"" reference time.
-
-    long long prev = 1;  //nonce
-    long long next = 0;  //nonce
-    long long duration = -1;  //really, this is unsigned
-
-    long long bpos = -1;
-    long long bsize = -1;
-
-    while (pos < stop)
-    {
-        long len;
-        const long long id = ReadUInt(pReader, pos, len);
-        assert(id >= 0);  //TODO
-        assert((pos + len) <= stop);
-
-        pos += len;  //consume ID
-
-        const long long size = ReadUInt(pReader, pos, len);
-        assert(size >= 0);  //TODO
-        assert((pos + len) <= stop);
-
-        pos += len;  //consume size
-
-        if (id == 0x21) //Block ID
-        {
-            if (bpos < 0) //Block ID
-            {
-                bpos = pos;
-                bsize = size;
-            }
-        }
-        else if (id == 0x1B)  //Duration ID
-        {
-            assert(size <= 8);
-
-            duration = UnserializeUInt(pReader, pos, size);
-            assert(duration >= 0);  //TODO
-        }
-        else if (id == 0x7B)  //ReferenceBlock
-        {
-            assert(size <= 8);
-            const long size_ = static_cast<long>(size);
-
-            long long time;
-
-            long status = UnserializeInt(pReader, pos, size_, time);
-            assert(status == 0);
-            if (status != 0)
-                return -1;
-
-            if (time <= 0)  //see note above
-                prev = time;
-            else  //weird
-                next = time;
-        }
-
-        pos += size;  //consume payload
-        assert(pos <= stop);
+    if (status < 0) {  // error
+      pLast = NULL;
+      return status;
     }
 
-    assert(pos == stop);
-    assert(bpos >= 0);
-    assert(bsize >= 0);
+    if (status > 0)  // no new block
+      break;
+  }
 
-    const long idx = m_entries_count;
-
-    BlockEntry** const ppEntry = m_entries + idx;
-    BlockEntry*& pEntry = *ppEntry;
-
-    pEntry = new (std::nothrow) BlockGroup(
-                                  this,
-                                  idx,
-                                  bpos,
-                                  bsize,
-                                  prev,
-                                  next,
-                                  duration,
-                                  discard_padding);
-
-    if (pEntry == NULL)
-        return -1;  //generic error
-
-    BlockGroup* const p = static_cast<BlockGroup*>(pEntry);
-
-    const long status = p->Parse();
-
-    if (status == 0)  //success
-    {
-        ++m_entries_count;
-        return 0;
-    }
-
-    delete pEntry;
-    pEntry = 0;
-
-    return status;
-}
-
-
-
-long Cluster::CreateSimpleBlock(
-    long long st,
-    long long sz)
-{
-    assert(m_entries);
-    assert(m_entries_size > 0);
-    assert(m_entries_count >= 0);
-    assert(m_entries_count < m_entries_size);
-
-    const long idx = m_entries_count;
-
-    BlockEntry** const ppEntry = m_entries + idx;
-    BlockEntry*& pEntry = *ppEntry;
-
-    pEntry = new (std::nothrow) SimpleBlock(this, idx, st, sz);
-
-    if (pEntry == NULL)
-        return -1;  //generic error
-
-    SimpleBlock* const p = static_cast<SimpleBlock*>(pEntry);
-
-    const long status = p->Parse();
-
-    if (status == 0)
-    {
-        ++m_entries_count;
-        return 0;
-    }
-
-    delete pEntry;
-    pEntry = 0;
-
-    return status;
-}
-
-
-long Cluster::GetFirst(const BlockEntry*& pFirst) const
-{
-    if (m_entries_count <= 0)
-    {
-        long long pos;
-        long len;
-
-        const long status = Parse(pos, len);
-
-        if (status < 0)  //error
-        {
-            pFirst = NULL;
-            return status;
-        }
-
-        if (m_entries_count <= 0)  //empty cluster
-        {
-            pFirst = NULL;
-            return 0;
-        }
-    }
-
-    assert(m_entries);
-
-    pFirst = m_entries[0];
-    assert(pFirst);
-
-    return 0;  //success
-}
-
-long Cluster::GetLast(const BlockEntry*& pLast) const
-{
-    for (;;)
-    {
-        long long pos;
-        long len;
-
-        const long status = Parse(pos, len);
-
-        if (status < 0)  //error
-        {
-            pLast = NULL;
-            return status;
-        }
-
-        if (status > 0)  //no new block
-            break;
-    }
-
-    if (m_entries_count <= 0)
-    {
-        pLast = NULL;
-        return 0;
-    }
-
-    assert(m_entries);
-
-    const long idx = m_entries_count - 1;
-
-    pLast = m_entries[idx];
-    assert(pLast);
-
+  if (m_entries_count <= 0) {
+    pLast = NULL;
     return 0;
+  }
+
+  assert(m_entries);
+
+  const long idx = m_entries_count - 1;
+
+  pLast = m_entries[idx];
+  assert(pLast);
+
+  return 0;
 }
 
+long Cluster::GetNext(const BlockEntry* pCurr, const BlockEntry*& pNext) const {
+  assert(pCurr);
+  assert(m_entries);
+  assert(m_entries_count > 0);
 
-long Cluster::GetNext(
-    const BlockEntry* pCurr,
-    const BlockEntry*& pNext) const
-{
-    assert(pCurr);
+  size_t idx = pCurr->GetIndex();
+  assert(idx < size_t(m_entries_count));
+  assert(m_entries[idx] == pCurr);
+
+  ++idx;
+
+  if (idx >= size_t(m_entries_count)) {
+    long long pos;
+    long len;
+
+    const long status = Parse(pos, len);
+
+    if (status < 0) {  // error
+      pNext = NULL;
+      return status;
+    }
+
+    if (status > 0) {
+      pNext = NULL;
+      return 0;
+    }
+
     assert(m_entries);
     assert(m_entries_count > 0);
-
-    size_t idx = pCurr->GetIndex();
     assert(idx < size_t(m_entries_count));
-    assert(m_entries[idx] == pCurr);
+  }
 
-    ++idx;
+  pNext = m_entries[idx];
+  assert(pNext);
 
-    if (idx >= size_t(m_entries_count))
-    {
-        long long pos;
-        long len;
-
-        const long status = Parse(pos, len);
-
-        if (status < 0)  //error
-        {
-            pNext = NULL;
-            return status;
-        }
-
-        if (status > 0)
-        {
-            pNext = NULL;
-            return 0;
-        }
-
-        assert(m_entries);
-        assert(m_entries_count > 0);
-        assert(idx < size_t(m_entries_count));
-    }
-
-    pNext = m_entries[idx];
-    assert(pNext);
-
-    return 0;
+  return 0;
 }
 
+long Cluster::GetEntryCount() const { return m_entries_count; }
 
-long Cluster::GetEntryCount() const
-{
-    return m_entries_count;
-}
+const BlockEntry* Cluster::GetEntry(const Track* pTrack,
+                                    long long time_ns) const {
+  assert(pTrack);
 
-
-const BlockEntry* Cluster::GetEntry(
-    const Track* pTrack,
-    long long time_ns) const
-{
-    assert(pTrack);
-
-    if (m_pSegment == NULL)  //this is the special EOS cluster
-        return pTrack->GetEOS();
+  if (m_pSegment == NULL)  // this is the special EOS cluster
+    return pTrack->GetEOS();
 
 #if 0
 
@@ -8707,76 +7588,66 @@

 
 #else
 
-    const BlockEntry* pResult = pTrack->GetEOS();
+  const BlockEntry* pResult = pTrack->GetEOS();
 
-    long index = 0;
+  long index = 0;
 
-    for (;;)
-    {
-        if (index >= m_entries_count)
-        {
-            long long pos;
-            long len;
+  for (;;) {
+    if (index >= m_entries_count) {
+      long long pos;
+      long len;
 
-            const long status = Parse(pos, len);
-            assert(status >= 0);
+      const long status = Parse(pos, len);
+      assert(status >= 0);
 
-            if (status > 0)  //completely parsed, and no more entries
-                return pResult;
+      if (status > 0)  // completely parsed, and no more entries
+        return pResult;
 
-            if (status < 0)  //should never happen
-                return 0;
+      if (status < 0)  // should never happen
+        return 0;
 
-            assert(m_entries);
-            assert(index < m_entries_count);
-        }
-
-        const BlockEntry* const pEntry = m_entries[index];
-        assert(pEntry);
-        assert(!pEntry->EOS());
-
-        const Block* const pBlock = pEntry->GetBlock();
-        assert(pBlock);
-
-        if (pBlock->GetTrackNumber() != pTrack->GetNumber())
-        {
-            ++index;
-            continue;
-        }
-
-        if (pTrack->VetEntry(pEntry))
-        {
-            if (time_ns < 0)  //just want first candidate block
-                return pEntry;
-
-            const long long ns = pBlock->GetTime(this);
-
-            if (ns > time_ns)
-                return pResult;
-
-            pResult = pEntry;  //have a candidate
-        }
-        else if (time_ns >= 0)
-        {
-            const long long ns = pBlock->GetTime(this);
-
-            if (ns > time_ns)
-                return pResult;
-        }
-
-        ++index;
+      assert(m_entries);
+      assert(index < m_entries_count);
     }
 
+    const BlockEntry* const pEntry = m_entries[index];
+    assert(pEntry);
+    assert(!pEntry->EOS());
+
+    const Block* const pBlock = pEntry->GetBlock();
+    assert(pBlock);
+
+    if (pBlock->GetTrackNumber() != pTrack->GetNumber()) {
+      ++index;
+      continue;
+    }
+
+    if (pTrack->VetEntry(pEntry)) {
+      if (time_ns < 0)  // just want first candidate block
+        return pEntry;
+
+      const long long ns = pBlock->GetTime(this);
+
+      if (ns > time_ns)
+        return pResult;
+
+      pResult = pEntry;  // have a candidate
+    } else if (time_ns >= 0) {
+      const long long ns = pBlock->GetTime(this);
+
+      if (ns > time_ns)
+        return pResult;
+    }
+
+    ++index;
+  }
+
 #endif
 }
 
-
-const BlockEntry*
-Cluster::GetEntry(
-    const CuePoint& cp,
-    const CuePoint::TrackPosition& tp) const
-{
-    assert(m_pSegment);
+const BlockEntry* Cluster::GetEntry(const CuePoint& cp,
+                                    const CuePoint::TrackPosition& tp) const {
+  assert(m_pSegment);
 
 #if 0
 
@@ -8867,114 +7738,105 @@

 
 #else
 
-    const long long tc = cp.GetTimeCode();
+  const long long tc = cp.GetTimeCode();
 
-    if (tp.m_block > 0)
-    {
-        const long block = static_cast<long>(tp.m_block);
-        const long index = block - 1;
+  if (tp.m_block > 0) {
+    const long block = static_cast<long>(tp.m_block);
+    const long index = block - 1;
 
-        while (index >= m_entries_count)
-        {
-            long long pos;
-            long len;
+    while (index >= m_entries_count) {
+      long long pos;
+      long len;
 
-            const long status = Parse(pos, len);
+      const long status = Parse(pos, len);
 
-            if (status < 0)  //TODO: can this happen?
-                return NULL;
+      if (status < 0)  // TODO: can this happen?
+        return NULL;
 
-            if (status > 0)  //nothing remains to be parsed
-                return NULL;
-        }
-
-        const BlockEntry* const pEntry = m_entries[index];
-        assert(pEntry);
-        assert(!pEntry->EOS());
-
-        const Block* const pBlock = pEntry->GetBlock();
-        assert(pBlock);
-
-        if ((pBlock->GetTrackNumber() == tp.m_track) &&
-            (pBlock->GetTimeCode(this) == tc))
-        {
-            return pEntry;
-        }
+      if (status > 0)  // nothing remains to be parsed
+        return NULL;
     }
 
-    long index = 0;
+    const BlockEntry* const pEntry = m_entries[index];
+    assert(pEntry);
+    assert(!pEntry->EOS());
 
-    for (;;)
-    {
-        if (index >= m_entries_count)
-        {
-            long long pos;
-            long len;
+    const Block* const pBlock = pEntry->GetBlock();
+    assert(pBlock);
 
-            const long status = Parse(pos, len);
-
-            if (status < 0)  //TODO: can this happen?
-                return NULL;
-
-            if (status > 0)  //nothing remains to be parsed
-                return NULL;
-
-            assert(m_entries);
-            assert(index < m_entries_count);
-        }
-
-        const BlockEntry* const pEntry = m_entries[index];
-        assert(pEntry);
-        assert(!pEntry->EOS());
-
-        const Block* const pBlock = pEntry->GetBlock();
-        assert(pBlock);
-
-        if (pBlock->GetTrackNumber() != tp.m_track)
-        {
-            ++index;
-            continue;
-        }
-
-        const long long tc_ = pBlock->GetTimeCode(this);
-
-        if (tc_ < tc)
-        {
-            ++index;
-            continue;
-        }
-
-        if (tc_ > tc)
-            return NULL;
-
-        const Tracks* const pTracks = m_pSegment->GetTracks();
-        assert(pTracks);
-
-        const long tn = static_cast<long>(tp.m_track);
-        const Track* const pTrack = pTracks->GetTrackByNumber(tn);
-
-        if (pTrack == NULL)
-            return NULL;
-
-        const long long type = pTrack->GetType();
-
-        if (type == 2)  //audio
-            return pEntry;
-
-        if (type != 1)  //not video
-            return NULL;
-
-        if (!pBlock->IsKey())
-            return NULL;
-
-        return pEntry;
+    if ((pBlock->GetTrackNumber() == tp.m_track) &&
+        (pBlock->GetTimeCode(this) == tc)) {
+      return pEntry;
     }
+  }
+
+  long index = 0;
+
+  for (;;) {
+    if (index >= m_entries_count) {
+      long long pos;
+      long len;
+
+      const long status = Parse(pos, len);
+
+      if (status < 0)  // TODO: can this happen?
+        return NULL;
+
+      if (status > 0)  // nothing remains to be parsed
+        return NULL;
+
+      assert(m_entries);
+      assert(index < m_entries_count);
+    }
+
+    const BlockEntry* const pEntry = m_entries[index];
+    assert(pEntry);
+    assert(!pEntry->EOS());
+
+    const Block* const pBlock = pEntry->GetBlock();
+    assert(pBlock);
+
+    if (pBlock->GetTrackNumber() != tp.m_track) {
+      ++index;
+      continue;
+    }
+
+    const long long tc_ = pBlock->GetTimeCode(this);
+
+    if (tc_ < tc) {
+      ++index;
+      continue;
+    }
+
+    if (tc_ > tc)
+      return NULL;
+
+    const Tracks* const pTracks = m_pSegment->GetTracks();
+    assert(pTracks);
+
+    const long tn = static_cast<long>(tp.m_track);
+    const Track* const pTrack = pTracks->GetTrackByNumber(tn);
+
+    if (pTrack == NULL)
+      return NULL;
+
+    const long long type = pTrack->GetType();
+
+    if (type == 2)  // audio
+      return pEntry;
+
+    if (type != 1)  // not video
+      return NULL;
+
+    if (!pBlock->IsKey())
+      return NULL;
+
+    return pEntry;
+  }
 
 #endif
-
 }
 
-
 #if 0
 const BlockEntry* Cluster::GetMaxKey(const VideoTrack* pTrack) const
 {
@@ -9011,97 +7873,46 @@

 }
 #endif
 
+BlockEntry::BlockEntry(Cluster* p, long idx) : m_pCluster(p), m_index(idx) {}
 
-BlockEntry::BlockEntry(Cluster* p, long idx) :
-    m_pCluster(p),
-    m_index(idx)
-{
+BlockEntry::~BlockEntry() {}
+
+bool BlockEntry::EOS() const { return (GetKind() == kBlockEOS); }
+
+const Cluster* BlockEntry::GetCluster() const { return m_pCluster; }
+
+long BlockEntry::GetIndex() const { return m_index; }
+
+SimpleBlock::SimpleBlock(Cluster* pCluster, long idx, long long start,
+                         long long size)
+    : BlockEntry(pCluster, idx), m_block(start, size, 0) {}
+
+long SimpleBlock::Parse() { return m_block.Parse(m_pCluster); }
+
+BlockEntry::Kind SimpleBlock::GetKind() const { return kBlockSimple; }
+
+const Block* SimpleBlock::GetBlock() const { return &m_block; }
+
+BlockGroup::BlockGroup(Cluster* pCluster, long idx, long long block_start,
+                       long long block_size, long long prev, long long next,
+                       long long duration, long long discard_padding)
+    : BlockEntry(pCluster, idx),
+      m_block(block_start, block_size, discard_padding),
+      m_prev(prev),
+      m_next(next),
+      m_duration(duration) {}
+
+long BlockGroup::Parse() {
+  const long status = m_block.Parse(m_pCluster);
+
+  if (status)
+    return status;
+
+  m_block.SetKey((m_prev > 0) && (m_next <= 0));
+
+  return 0;
 }
 
-
-BlockEntry::~BlockEntry()
-{
-}
-
-
-bool BlockEntry::EOS() const
-{
-    return (GetKind() == kBlockEOS);
-}
-
-
-const Cluster* BlockEntry::GetCluster() const
-{
-    return m_pCluster;
-}
-
-
-long BlockEntry::GetIndex() const
-{
-    return m_index;
-}
-
-
-SimpleBlock::SimpleBlock(
-    Cluster* pCluster,
-    long idx,
-    long long start,
-    long long size) :
-    BlockEntry(pCluster, idx),
-    m_block(start, size, 0)
-{
-}
-
-
-long SimpleBlock::Parse()
-{
-    return m_block.Parse(m_pCluster);
-}
-
-
-BlockEntry::Kind SimpleBlock::GetKind() const
-{
-    return kBlockSimple;
-}
-
-
-const Block* SimpleBlock::GetBlock() const
-{
-    return &m_block;
-}
-
-
-BlockGroup::BlockGroup(
-    Cluster* pCluster,
-    long idx,
-    long long block_start,
-    long long block_size,
-    long long prev,
-    long long next,
-    long long duration,
-    long long discard_padding) :
-    BlockEntry(pCluster, idx),
-    m_block(block_start, block_size, discard_padding),
-    m_prev(prev),
-    m_next(next),
-    m_duration(duration)
-{
-}
-
-
-long BlockGroup::Parse()
-{
-    const long status = m_block.Parse(m_pCluster);
-
-    if (status)
-        return status;
-
-    m_block.SetKey((m_prev > 0) && (m_next <= 0));
-
-    return 0;
-}
-
-
 #if 0
 void BlockGroup::ParseBlock(long long start, long long size)
 {
@@ -9118,496 +7929,428 @@

 }
 #endif
 
+BlockEntry::Kind BlockGroup::GetKind() const { return kBlockGroup; }
 
-BlockEntry::Kind BlockGroup::GetKind() const
-{
-    return kBlockGroup;
-}
+const Block* BlockGroup::GetBlock() const { return &m_block; }
 
+long long BlockGroup::GetPrevTimeCode() const { return m_prev; }
 
-const Block* BlockGroup::GetBlock() const
-{
-    return &m_block;
-}
+long long BlockGroup::GetNextTimeCode() const { return m_next; }
 
+long long BlockGroup::GetDurationTimeCode() const { return m_duration; }
 
-long long BlockGroup::GetPrevTimeCode() const
-{
-    return m_prev;
-}
+Block::Block(long long start, long long size_, long long discard_padding)
+    : m_start(start),
+      m_size(size_),
+      m_track(0),
+      m_timecode(-1),
+      m_flags(0),
+      m_frames(NULL),
+      m_frame_count(-1),
+      m_discard_padding(discard_padding) {}
 
+Block::~Block() { delete[] m_frames; }
 
-long long BlockGroup::GetNextTimeCode() const
-{
-    return m_next;
-}
+long Block::Parse(const Cluster* pCluster) {
+  if (pCluster == NULL)
+    return -1;
 
-long long BlockGroup::GetDurationTimeCode() const
-{
-    return m_duration;
-}
+  if (pCluster->m_pSegment == NULL)
+    return -1;
 
-Block::Block(long long start, long long size_, long long discard_padding) :
-    m_start(start),
-    m_size(size_),
-    m_track(0),
-    m_timecode(-1),
-    m_flags(0),
-    m_frames(NULL),
-    m_frame_count(-1),
-    m_discard_padding(discard_padding)
-{
-}
+  assert(m_start >= 0);
+  assert(m_size >= 0);
+  assert(m_track <= 0);
+  assert(m_frames == NULL);
+  assert(m_frame_count <= 0);
 
+  long long pos = m_start;
+  const long long stop = m_start + m_size;
 
-Block::~Block()
-{
-    delete[] m_frames;
-}
+  long len;
 
+  IMkvReader* const pReader = pCluster->m_pSegment->m_pReader;
 
-long Block::Parse(const Cluster* pCluster)
-{
-    if (pCluster == NULL)
-        return -1;
+  m_track = ReadUInt(pReader, pos, len);
 
-    if (pCluster->m_pSegment == NULL)
-        return -1;
+  if (m_track <= 0)
+    return E_FILE_FORMAT_INVALID;
 
-    assert(m_start >= 0);
-    assert(m_size >= 0);
-    assert(m_track <= 0);
-    assert(m_frames == NULL);
-    assert(m_frame_count <= 0);
+  if ((pos + len) > stop)
+    return E_FILE_FORMAT_INVALID;
 
-    long long pos = m_start;
-    const long long stop = m_start + m_size;
+  pos += len;  // consume track number
 
-    long len;
+  if ((stop - pos) < 2)
+    return E_FILE_FORMAT_INVALID;
 
-    IMkvReader* const pReader = pCluster->m_pSegment->m_pReader;
+  long status;
+  long long value;
 
-    m_track = ReadUInt(pReader, pos, len);
+  status = UnserializeInt(pReader, pos, 2, value);
 
-    if (m_track <= 0)
-        return E_FILE_FORMAT_INVALID;
+  if (status)
+    return E_FILE_FORMAT_INVALID;
 
-    if ((pos + len) > stop)
-        return E_FILE_FORMAT_INVALID;
+  if (value < SHRT_MIN)
+    return E_FILE_FORMAT_INVALID;
 
-    pos += len;  //consume track number
+  if (value > SHRT_MAX)
+    return E_FILE_FORMAT_INVALID;
 
-    if ((stop - pos) < 2)
-        return E_FILE_FORMAT_INVALID;
+  m_timecode = static_cast<short>(value);
 
-    long status;
-    long long value;
+  pos += 2;
 
-    status = UnserializeInt(pReader, pos, 2, value);
+  if ((stop - pos) <= 0)
+    return E_FILE_FORMAT_INVALID;
 
-    if (status)
-        return E_FILE_FORMAT_INVALID;
+  status = pReader->Read(pos, 1, &m_flags);
 
-    if (value < SHRT_MIN)
-        return E_FILE_FORMAT_INVALID;
+  if (status)
+    return E_FILE_FORMAT_INVALID;
 
-    if (value > SHRT_MAX)
-        return E_FILE_FORMAT_INVALID;
+  const int lacing = int(m_flags & 0x06) >> 1;
 
-    m_timecode = static_cast<short>(value);
+  ++pos;  // consume flags byte
 
-    pos += 2;
+  if (lacing == 0) {  // no lacing
+    if (pos > stop)
+      return E_FILE_FORMAT_INVALID;
 
-    if ((stop - pos) <= 0)
-        return E_FILE_FORMAT_INVALID;
-
-    status = pReader->Read(pos, 1, &m_flags);
-
-    if (status)
-        return E_FILE_FORMAT_INVALID;
-
-    const int lacing = int(m_flags & 0x06) >> 1;
-
-    ++pos;  //consume flags byte
-
-    if (lacing == 0)  //no lacing
-    {
-        if (pos > stop)
-            return E_FILE_FORMAT_INVALID;
-
-        m_frame_count = 1;
-        m_frames = new Frame[m_frame_count];
-
-        Frame& f = m_frames[0];
-        f.pos = pos;
-
-        const long long frame_size = stop - pos;
-
-        if (frame_size > LONG_MAX)
-            return E_FILE_FORMAT_INVALID;
-
-        f.len = static_cast<long>(frame_size);
-
-        return 0;  //success
-    }
-
-    if (pos >= stop)
-        return E_FILE_FORMAT_INVALID;
-
-    unsigned char biased_count;
-
-    status = pReader->Read(pos, 1, &biased_count);
-
-    if (status)
-        return E_FILE_FORMAT_INVALID;
-
-    ++pos;  //consume frame count
-    assert(pos <= stop);
-
-    m_frame_count = int(biased_count) + 1;
-
+    m_frame_count = 1;
     m_frames = new Frame[m_frame_count];
-    assert(m_frames);
 
-    if (lacing == 1)  //Xiph
-    {
-        Frame* pf = m_frames;
-        Frame* const pf_end = pf + m_frame_count;
+    Frame& f = m_frames[0];
+    f.pos = pos;
 
-        long size = 0;
-        int frame_count = m_frame_count;
+    const long long frame_size = stop - pos;
 
-        while (frame_count > 1)
-        {
-            long frame_size = 0;
+    if (frame_size > LONG_MAX)
+      return E_FILE_FORMAT_INVALID;
 
-            for (;;)
-            {
-                unsigned char val;
+    f.len = static_cast<long>(frame_size);
 
-                if (pos >= stop)
-                    return E_FILE_FORMAT_INVALID;
+    return 0;  // success
+  }
 
-                status = pReader->Read(pos, 1, &val);
+  if (pos >= stop)
+    return E_FILE_FORMAT_INVALID;
 
-                if (status)
-                    return E_FILE_FORMAT_INVALID;
+  unsigned char biased_count;
 
-                ++pos;  //consume xiph size byte
+  status = pReader->Read(pos, 1, &biased_count);
 
-                frame_size += val;
+  if (status)
+    return E_FILE_FORMAT_INVALID;
 
-                if (val < 255)
-                    break;
-            }
+  ++pos;  // consume frame count
+  assert(pos <= stop);
 
-            Frame& f = *pf++;
-            assert(pf < pf_end);
+  m_frame_count = int(biased_count) + 1;
 
-            f.pos = 0;  //patch later
+  m_frames = new Frame[m_frame_count];
+  assert(m_frames);
 
-            f.len = frame_size;
-            size += frame_size;  //contribution of this frame
+  if (lacing == 1) {  // Xiph
+    Frame* pf = m_frames;
+    Frame* const pf_end = pf + m_frame_count;
 
-            --frame_count;
-        }
+    long size = 0;
+    int frame_count = m_frame_count;
 
-        assert(pf < pf_end);
-        assert(pos <= stop);
+    while (frame_count > 1) {
+      long frame_size = 0;
 
-        {
-            Frame& f = *pf++;
-
-            if (pf != pf_end)
-                return E_FILE_FORMAT_INVALID;
-
-            f.pos = 0;  //patch later
-
-            const long long total_size = stop - pos;
-
-            if (total_size < size)
-                return E_FILE_FORMAT_INVALID;
-
-            const long long frame_size = total_size - size;
-
-            if (frame_size > LONG_MAX)
-                return E_FILE_FORMAT_INVALID;
-
-            f.len = static_cast<long>(frame_size);
-        }
-
-        pf = m_frames;
-        while (pf != pf_end)
-        {
-            Frame& f = *pf++;
-            assert((pos + f.len) <= stop);
-
-            f.pos = pos;
-            pos += f.len;
-        }
-
-        assert(pos == stop);
-    }
-    else if (lacing == 2)  //fixed-size lacing
-    {
-        const long long total_size = stop - pos;
-
-        if ((total_size % m_frame_count) != 0)
-            return E_FILE_FORMAT_INVALID;
-
-        const long long frame_size = total_size / m_frame_count;
-
-        if (frame_size > LONG_MAX)
-            return E_FILE_FORMAT_INVALID;
-
-        Frame* pf = m_frames;
-        Frame* const pf_end = pf + m_frame_count;
-
-        while (pf != pf_end)
-        {
-            assert((pos + frame_size) <= stop);
-
-            Frame& f = *pf++;
-
-            f.pos = pos;
-            f.len = static_cast<long>(frame_size);
-
-            pos += frame_size;
-        }
-
-        assert(pos == stop);
-    }
-    else
-    {
-        assert(lacing == 3);  //EBML lacing
+      for (;;) {
+        unsigned char val;
 
         if (pos >= stop)
-            return E_FILE_FORMAT_INVALID;
+          return E_FILE_FORMAT_INVALID;
 
-        long size = 0;
-        int frame_count = m_frame_count;
+        status = pReader->Read(pos, 1, &val);
 
-        long long frame_size = ReadUInt(pReader, pos, len);
+        if (status)
+          return E_FILE_FORMAT_INVALID;
 
-        if (frame_size < 0)
-            return E_FILE_FORMAT_INVALID;
+        ++pos;  // consume xiph size byte
 
-        if (frame_size > LONG_MAX)
-            return E_FILE_FORMAT_INVALID;
+        frame_size += val;
 
-        if ((pos + len) > stop)
-            return E_FILE_FORMAT_INVALID;
+        if (val < 255)
+          break;
+      }
 
-        pos += len; //consume length of size of first frame
+      Frame& f = *pf++;
+      assert(pf < pf_end);
 
-        if ((pos + frame_size) > stop)
-            return E_FILE_FORMAT_INVALID;
+      f.pos = 0;  // patch later
 
-        Frame* pf = m_frames;
-        Frame* const pf_end = pf + m_frame_count;
+      f.len = frame_size;
+      size += frame_size;  // contribution of this frame
 
-        {
-            Frame& curr = *pf;
-
-            curr.pos = 0;  //patch later
-
-            curr.len = static_cast<long>(frame_size);
-            size += curr.len;  //contribution of this frame
-        }
-
-        --frame_count;
-
-        while (frame_count > 1)
-        {
-            if (pos >= stop)
-                return E_FILE_FORMAT_INVALID;
-
-            assert(pf < pf_end);
-
-            const Frame& prev = *pf++;
-            assert(prev.len == frame_size);
-            if (prev.len != frame_size)
-                return E_FILE_FORMAT_INVALID;
-
-            assert(pf < pf_end);
-
-            Frame& curr = *pf;
-
-            curr.pos = 0;  //patch later
-
-            const long long delta_size_ = ReadUInt(pReader, pos, len);
-
-            if (delta_size_ < 0)
-                return E_FILE_FORMAT_INVALID;
-
-            if ((pos + len) > stop)
-                return E_FILE_FORMAT_INVALID;
-
-            pos += len;  //consume length of (delta) size
-            assert(pos <= stop);
-
-            const int exp = 7*len - 1;
-            const long long bias = (1LL << exp) - 1LL;
-            const long long delta_size = delta_size_ - bias;
-
-            frame_size += delta_size;
-
-            if (frame_size < 0)
-                return E_FILE_FORMAT_INVALID;
-
-            if (frame_size > LONG_MAX)
-                return E_FILE_FORMAT_INVALID;
-
-            curr.len = static_cast<long>(frame_size);
-            size += curr.len;  //contribution of this frame
-
-            --frame_count;
-        }
-
-        {
-            assert(pos <= stop);
-            assert(pf < pf_end);
-
-            const Frame& prev = *pf++;
-            assert(prev.len == frame_size);
-            if (prev.len != frame_size)
-                return E_FILE_FORMAT_INVALID;
-
-            assert(pf < pf_end);
-
-            Frame& curr = *pf++;
-            assert(pf == pf_end);
-
-            curr.pos = 0;  //patch later
-
-            const long long total_size = stop - pos;
-
-            if (total_size < size)
-                return E_FILE_FORMAT_INVALID;
-
-            frame_size = total_size - size;
-
-            if (frame_size > LONG_MAX)
-                return E_FILE_FORMAT_INVALID;
-
-            curr.len = static_cast<long>(frame_size);
-        }
-
-        pf = m_frames;
-        while (pf != pf_end)
-        {
-            Frame& f = *pf++;
-            assert((pos + f.len) <= stop);
-
-            f.pos = pos;
-            pos += f.len;
-        }
-
-        assert(pos == stop);
+      --frame_count;
     }
 
-    return 0;  //success
+    assert(pf < pf_end);
+    assert(pos <= stop);
+
+    {
+      Frame& f = *pf++;
+
+      if (pf != pf_end)
+        return E_FILE_FORMAT_INVALID;
+
+      f.pos = 0;  // patch later
+
+      const long long total_size = stop - pos;
+
+      if (total_size < size)
+        return E_FILE_FORMAT_INVALID;
+
+      const long long frame_size = total_size - size;
+
+      if (frame_size > LONG_MAX)
+        return E_FILE_FORMAT_INVALID;
+
+      f.len = static_cast<long>(frame_size);
+    }
+
+    pf = m_frames;
+    while (pf != pf_end) {
+      Frame& f = *pf++;
+      assert((pos + f.len) <= stop);
+
+      f.pos = pos;
+      pos += f.len;
+    }
+
+    assert(pos == stop);
+  } else if (lacing == 2) {  // fixed-size lacing
+    const long long total_size = stop - pos;
+
+    if ((total_size % m_frame_count) != 0)
+      return E_FILE_FORMAT_INVALID;
+
+    const long long frame_size = total_size / m_frame_count;
+
+    if (frame_size > LONG_MAX)
+      return E_FILE_FORMAT_INVALID;
+
+    Frame* pf = m_frames;
+    Frame* const pf_end = pf + m_frame_count;
+
+    while (pf != pf_end) {
+      assert((pos + frame_size) <= stop);
+
+      Frame& f = *pf++;
+
+      f.pos = pos;
+      f.len = static_cast<long>(frame_size);
+
+      pos += frame_size;
+    }
+
+    assert(pos == stop);
+  } else {
+    assert(lacing == 3);  // EBML lacing
+
+    if (pos >= stop)
+      return E_FILE_FORMAT_INVALID;
+
+    long size = 0;
+    int frame_count = m_frame_count;
+
+    long long frame_size = ReadUInt(pReader, pos, len);
+
+    if (frame_size < 0)
+      return E_FILE_FORMAT_INVALID;
+
+    if (frame_size > LONG_MAX)
+      return E_FILE_FORMAT_INVALID;
+
+    if ((pos + len) > stop)
+      return E_FILE_FORMAT_INVALID;
+
+    pos += len;  // consume length of size of first frame
+
+    if ((pos + frame_size) > stop)
+      return E_FILE_FORMAT_INVALID;
+
+    Frame* pf = m_frames;
+    Frame* const pf_end = pf + m_frame_count;
+
+    {
+      Frame& curr = *pf;
+
+      curr.pos = 0;  // patch later
+
+      curr.len = static_cast<long>(frame_size);
+      size += curr.len;  // contribution of this frame
+    }
+
+    --frame_count;
+
+    while (frame_count > 1) {
+      if (pos >= stop)
+        return E_FILE_FORMAT_INVALID;
+
+      assert(pf < pf_end);
+
+      const Frame& prev = *pf++;
+      assert(prev.len == frame_size);
+      if (prev.len != frame_size)
+        return E_FILE_FORMAT_INVALID;
+
+      assert(pf < pf_end);
+
+      Frame& curr = *pf;
+
+      curr.pos = 0;  // patch later
+
+      const long long delta_size_ = ReadUInt(pReader, pos, len);
+
+      if (delta_size_ < 0)
+        return E_FILE_FORMAT_INVALID;
+
+      if ((pos + len) > stop)
+        return E_FILE_FORMAT_INVALID;
+
+      pos += len;  // consume length of (delta) size
+      assert(pos <= stop);
+
+      const int exp = 7 * len - 1;
+      const long long bias = (1LL << exp) - 1LL;
+      const long long delta_size = delta_size_ - bias;
+
+      frame_size += delta_size;
+
+      if (frame_size < 0)
+        return E_FILE_FORMAT_INVALID;
+
+      if (frame_size > LONG_MAX)
+        return E_FILE_FORMAT_INVALID;
+
+      curr.len = static_cast<long>(frame_size);
+      size += curr.len;  // contribution of this frame
+
+      --frame_count;
+    }
+
+    {
+      assert(pos <= stop);
+      assert(pf < pf_end);
+
+      const Frame& prev = *pf++;
+      assert(prev.len == frame_size);
+      if (prev.len != frame_size)
+        return E_FILE_FORMAT_INVALID;
+
+      assert(pf < pf_end);
+
+      Frame& curr = *pf++;
+      assert(pf == pf_end);
+
+      curr.pos = 0;  // patch later
+
+      const long long total_size = stop - pos;
+
+      if (total_size < size)
+        return E_FILE_FORMAT_INVALID;
+
+      frame_size = total_size - size;
+
+      if (frame_size > LONG_MAX)
+        return E_FILE_FORMAT_INVALID;
+
+      curr.len = static_cast<long>(frame_size);
+    }
+
+    pf = m_frames;
+    while (pf != pf_end) {
+      Frame& f = *pf++;
+      assert((pos + f.len) <= stop);
+
+      f.pos = pos;
+      pos += f.len;
+    }
+
+    assert(pos == stop);
+  }
+
+  return 0;  // success
 }
 
+long long Block::GetTimeCode(const Cluster* pCluster) const {
+  if (pCluster == 0)
+    return m_timecode;
 
-long long Block::GetTimeCode(const Cluster* pCluster) const
-{
-    if (pCluster == 0)
-        return m_timecode;
+  const long long tc0 = pCluster->GetTimeCode();
+  assert(tc0 >= 0);
 
-    const long long tc0 = pCluster->GetTimeCode();
-    assert(tc0 >= 0);
+  const long long tc = tc0 + m_timecode;
 
-    const long long tc = tc0 + m_timecode;
-
-    return tc;  //unscaled timecode units
+  return tc;  // unscaled timecode units
 }
 
+long long Block::GetTime(const Cluster* pCluster) const {
+  assert(pCluster);
 
-long long Block::GetTime(const Cluster* pCluster) const
-{
-    assert(pCluster);
+  const long long tc = GetTimeCode(pCluster);
 
-    const long long tc = GetTimeCode(pCluster);
+  const Segment* const pSegment = pCluster->m_pSegment;
+  const SegmentInfo* const pInfo = pSegment->GetInfo();
+  assert(pInfo);
 
-    const Segment* const pSegment = pCluster->m_pSegment;
-    const SegmentInfo* const pInfo = pSegment->GetInfo();
-    assert(pInfo);
+  const long long scale = pInfo->GetTimeCodeScale();
+  assert(scale >= 1);
 
-    const long long scale = pInfo->GetTimeCodeScale();
-    assert(scale >= 1);
+  const long long ns = tc * scale;
 
-    const long long ns = tc * scale;
-
-    return ns;
+  return ns;
 }
 
+long long Block::GetTrackNumber() const { return m_track; }
 
-long long Block::GetTrackNumber() const
-{
-    return m_track;
+bool Block::IsKey() const {
+  return ((m_flags & static_cast<unsigned char>(1 << 7)) != 0);
 }
 
-
-bool Block::IsKey() const
-{
-    return ((m_flags & static_cast<unsigned char>(1 << 7)) != 0);
+void Block::SetKey(bool bKey) {
+  if (bKey)
+    m_flags |= static_cast<unsigned char>(1 << 7);
+  else
+    m_flags &= 0x7F;
 }
 
+bool Block::IsInvisible() const { return bool(int(m_flags & 0x08) != 0); }
 
-void Block::SetKey(bool bKey)
-{
-    if (bKey)
-        m_flags |= static_cast<unsigned char>(1 << 7);
-    else
-        m_flags &= 0x7F;
+Block::Lacing Block::GetLacing() const {
+  const int value = int(m_flags & 0x06) >> 1;
+  return static_cast<Lacing>(value);
 }
 
+int Block::GetFrameCount() const { return m_frame_count; }
 
-bool Block::IsInvisible() const
-{
-    return bool(int(m_flags & 0x08) != 0);
+const Block::Frame& Block::GetFrame(int idx) const {
+  assert(idx >= 0);
+  assert(idx < m_frame_count);
+
+  const Frame& f = m_frames[idx];
+  assert(f.pos > 0);
+  assert(f.len > 0);
+
+  return f;
 }
 
+long Block::Frame::Read(IMkvReader* pReader, unsigned char* buf) const {
+  assert(pReader);
+  assert(buf);
 
-Block::Lacing Block::GetLacing() const
-{
-    const int value = int(m_flags & 0x06) >> 1;
-    return static_cast<Lacing>(value);
+  const long status = pReader->Read(pos, len, buf);
+  return status;
 }
 
+long long Block::GetDiscardPadding() const { return m_discard_padding; }
 
-int Block::GetFrameCount() const
-{
-    return m_frame_count;
-}
-
-
-const Block::Frame& Block::GetFrame(int idx) const
-{
-    assert(idx >= 0);
-    assert(idx < m_frame_count);
-
-    const Frame& f = m_frames[idx];
-    assert(f.pos > 0);
-    assert(f.len > 0);
-
-    return f;
-}
-
-
-long Block::Frame::Read(IMkvReader* pReader, unsigned char* buf) const
-{
-    assert(pReader);
-    assert(buf);
-
-    const long status = pReader->Read(pos, len, buf);
-    return status;
-}
-
-long long Block::GetDiscardPadding() const
-{
-    return m_discard_padding;
-}
-
-}  //end namespace mkvparser
+}  // end namespace mkvparser
","long long BlockGroup::GetPrevTimeCode() const
{
    return m_prev;
}
",Android,https://android.googlesource.com/platform/external/libvpx/+/04839626ed859623901ebd3a5fd483982186b59d/,https://android.googlesource.com/platform/external/libvpx/+/04839626ed859623901ebd3a5fd483982186b59d%5E/,1.0,"long long BlockGroup::GetPrevTimeCode() const
//flaw_line_below:
{
//flaw_line_below:
    return m_prev;
//flaw_line_below:
}
"
352,None,Remote,Not required,None,CVE-2017-5107,https://www.cvedetails.com/cve/CVE-2017-5107/,CWE-200,High,Partial,None,,2017-10-27,2.6,"A timing attack in SVG rendering in Google Chrome prior to 60.0.3112.78 for Linux, Windows, and Mac allowed a remote attacker to extract pixel values from a cross-origin page being iframe'd via a crafted HTML page.",2018-01-04,+Info ,0.0,https://github.com/chromium/chromium/commit/c25b198675380f713a56649c857b4367601d4a3d,c25b198675380f713a56649c857b4367601d4a3d,"[Lock Screen Media Controls] Tweak UI based on new mocks

This CL rearranges the different components of the CrOS lock screen
media controls based on the newest mocks. This involves resizing most
of the child views and their spacings. The artwork was also resized
and re-positioned. Additionally, the close button was moved from the
main view to the header row child view.

Artist and title data about the current session will eventually be
placed to the right of the artwork, but right now this space is empty.

See the bug for before and after pictures.

Bug: 991647
Change-Id: I7b97f31982ccf2912bd2564d5241bfd849d21d92
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1746554
Reviewed-by: Xiyuan Xia <xiyuan@chromium.org>
Reviewed-by: Becca Hughes <beccahughes@chromium.org>
Commit-Queue: Mia Bergeron <miaber@google.com>
Cr-Commit-Position: refs/heads/master@{#686253}",2.0,ash/login/ui/lock_screen_media_controls_view_unittest.cc,"{""sha"": ""43b2398c50edef650cff5c5639eb71f7e287c7ed"", ""filename"": ""ash/login/ui/lock_screen_media_controls_view.cc"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 61, ""changes"": 85, ""blob_url"": ""https://github.com/chromium/chromium/blob/c25b198675380f713a56649c857b4367601d4a3d/ash/login/ui/lock_screen_media_controls_view.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c25b198675380f713a56649c857b4367601d4a3d/ash/login/ui/lock_screen_media_controls_view.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/login/ui/lock_screen_media_controls_view.cc?ref=c25b198675380f713a56649c857b4367601d4a3d"", ""patch"": ""@@ -12,7 +12,6 @@\n #include \""ash/strings/grit/ash_strings.h\""\n #include \""components/media_message_center/media_controls_progress_view.h\""\n #include \""components/media_message_center/media_notification_util.h\""\n-#include \""components/vector_icons/vector_icons.h\""\n #include \""services/media_session/public/cpp/util.h\""\n #include \""services/media_session/public/mojom/constants.mojom.h\""\n #include \""services/media_session/public/mojom/media_session.mojom.h\""\n@@ -27,43 +26,36 @@\n #include \""ui/views/controls/button/image_button_factory.h\""\n #include \""ui/views/controls/image_view.h\""\n #include \""ui/views/layout/box_layout.h\""\n-#include \""ui/views/layout/grid_layout.h\""\n \n namespace ash {\n \n using media_session::mojom::MediaSessionAction;\n \n namespace {\n \n-constexpr SkColor kMediaControlsBackground = SkColorSetA(SK_ColorDKGRAY, 100);\n+constexpr SkColor kMediaControlsBackground = SkColorSetA(SK_ColorDKGRAY, 150);\n constexpr SkColor kMediaButtonColor = SK_ColorWHITE;\n \n // Maximum number of actions that should be displayed on |button_row_|.\n constexpr size_t kMaxActions = 5;\n \n // Dimensions.\n-constexpr int kMediaControlsTotalWidthDp = 320;\n-constexpr int kMediaControlsTotalHeightDp = 400;\n+constexpr gfx::Insets kMediaControlsInsets = gfx::Insets(15, 15, 15, 15);\n constexpr int kMediaControlsCornerRadius = 8;\n constexpr int kMinimumIconSize = 16;\n constexpr int kDesiredIconSize = 20;\n constexpr int kIconSize = 20;\n-constexpr gfx::Insets kArtworkInsets = gfx::Insets(0, 25, 20, 25);\n-constexpr int kMinimumArtworkSize = 200;\n-constexpr int kDesiredArtworkSize = 300;\n-constexpr int kArtworkViewWidth = 270;\n-constexpr int kArtworkViewHeight = 200;\n-constexpr gfx::Size kMediaButtonSize = gfx::Size(45, 45);\n-constexpr int kMediaButtonRowSeparator = 10;\n-constexpr gfx::Insets kButtonRowInsets = gfx::Insets(10, 25, 25, 25);\n-constexpr int kPlayPauseIconSize = 32;\n-constexpr int kChangeTrackIconSize = 16;\n-constexpr int kSeekingIconsSize = 28;\n+constexpr int kMinimumArtworkSize = 50;\n+constexpr int kDesiredArtworkSize = 80;\n+constexpr gfx::Size kArtworkSize = gfx::Size(80, 80);\n+constexpr gfx::Size kMediaButtonSize = gfx::Size(38, 38);\n+constexpr int kMediaButtonRowSeparator = 24;\n+constexpr gfx::Insets kButtonRowInsets = gfx::Insets(10, 0, 0, 0);\n+constexpr int kPlayPauseIconSize = 28;\n+constexpr int kChangeTrackIconSize = 14;\n+constexpr int kSeekingIconsSize = 26;\n constexpr gfx::Size kMediaControlsButtonRowSize =\n-    gfx::Size(270, kMediaButtonSize.height());\n-constexpr int kCloseButtonOffset = 290;\n-constexpr gfx::Size kCloseButtonSize = gfx::Size(24, 24);\n-constexpr int kCloseButtonIconSize = 20;\n+    gfx::Size(300, kMediaButtonSize.height());\n \n constexpr int kDragVelocityThreshold = -6;\n constexpr int kHeightDismissalThreshold = 20;\n@@ -151,46 +143,23 @@ LockScreenMediaControlsView::LockScreenMediaControlsView(\n \n   contents_view_ = AddChildView(std::make_unique<views::View>());\n   contents_view_->SetLayoutManager(std::make_unique<views::BoxLayout>(\n-      views::BoxLayout::Orientation::kVertical));\n+      views::BoxLayout::Orientation::kVertical, kMediaControlsInsets));\n   contents_view_->SetBackground(views::CreateRoundedRectBackground(\n       kMediaControlsBackground, kMediaControlsCornerRadius));\n \n   contents_view_->SetPaintToLayer();  // Needed for opacity animation.\n   contents_view_->layer()->SetFillsBoundsOpaquely(false);\n \n-  // |close_button_row| contains the close button to dismiss the controls.\n-  auto close_button_row = std::make_unique<NonAccessibleView>();\n-  views::GridLayout* close_button_layout =\n-      close_button_row->SetLayoutManager(std::make_unique<views::GridLayout>());\n-  views::ColumnSet* columns = close_button_layout->AddColumnSet(0);\n-\n-  columns->AddPaddingColumn(0, kCloseButtonOffset);\n-  columns->AddColumn(views::GridLayout::CENTER, views::GridLayout::CENTER, 0,\n-                     views::GridLayout::USE_PREF, 0, 0);\n-  close_button_layout->StartRowWithPadding(\n-      0, 0, 0, 5 /* padding between close button and top of view */);\n-\n-  auto close_button = CreateVectorImageButton(this);\n-  SetImageFromVectorIcon(close_button.get(), vector_icons::kCloseRoundedIcon,\n-                         kCloseButtonIconSize, gfx::kGoogleGrey700);\n-  close_button->SetPreferredSize(kCloseButtonSize);\n-  close_button->SetFocusBehavior(View::FocusBehavior::ALWAYS);\n-  base::string16 close_button_label(\n-      l10n_util::GetStringUTF16(IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_CLOSE));\n-  close_button->SetAccessibleName(close_button_label);\n-  close_button_ = close_button_layout->AddView(std::move(close_button));\n-  close_button_->SetVisible(false);\n-  contents_view_->AddChildView(std::move(close_button_row));\n-\n   // |header_row_| contains the app icon and source title of the current media\n-  // session.\n-  header_row_ =\n-      contents_view_->AddChildView(std::make_unique<MediaControlsHeaderView>());\n+  // session. It also contains the close button.\n+  header_row_ = contents_view_->AddChildView(\n+      std::make_unique<MediaControlsHeaderView>(base::BindOnce(\n+          &LockScreenMediaControlsView::Dismiss, base::Unretained(this))));\n \n   auto session_artwork = std::make_unique<views::ImageView>();\n-  session_artwork->SetPreferredSize(\n-      gfx::Size(kArtworkViewWidth, kArtworkViewHeight));\n-  session_artwork->SetBorder(views::CreateEmptyBorder(kArtworkInsets));\n+  session_artwork->SetPreferredSize(kArtworkSize);\n+  session_artwork->SetHorizontalAlignment(\n+      views::ImageView::Alignment::kLeading);\n   session_artwork_ = contents_view_->AddChildView(std::move(session_artwork));\n \n   progress_ = contents_view_->AddChildView(\n@@ -296,7 +265,7 @@ const char* LockScreenMediaControlsView::GetClassName() const {\n }\n \n gfx::Size LockScreenMediaControlsView::CalculatePreferredSize() const {\n-  return gfx::Size(kMediaControlsTotalWidthDp, kMediaControlsTotalHeightDp);\n+  return contents_view_->GetPreferredSize();\n }\n \n void LockScreenMediaControlsView::Layout() {\n@@ -319,14 +288,14 @@ void LockScreenMediaControlsView::OnMouseEntered(const ui::MouseEvent& event) {\n   if (is_in_drag_ || contents_view_->layer()->GetAnimator()->is_animating())\n     return;\n \n-  close_button_->SetVisible(true);\n+  header_row_->SetCloseButtonVisibility(true);\n }\n \n void LockScreenMediaControlsView::OnMouseExited(const ui::MouseEvent& event) {\n   if (is_in_drag_ || contents_view_->layer()->GetAnimator()->is_animating())\n     return;\n \n-  close_button_->SetVisible(false);\n+  header_row_->SetCloseButtonVisibility(false);\n }\n \n views::View* LockScreenMediaControlsView::GetMiddleSpacingView() {\n@@ -473,11 +442,6 @@ void LockScreenMediaControlsView::OnImplicitAnimationsCompleted() {\n \n void LockScreenMediaControlsView::ButtonPressed(views::Button* sender,\n                                                 const ui::Event& event) {\n-  if (sender == close_button_) {\n-    Dismiss();\n-    return;\n-  }\n-\n   if (!base::Contains(enabled_actions_,\n                       media_message_center::GetActionFromButtonTag(*sender)) ||\n       !media_session_id_.has_value()) {\n@@ -593,8 +557,7 @@ void LockScreenMediaControlsView::SetArtwork(\n     return;\n   }\n \n-  session_artwork_->SetImageSize(ScaleSizeToFitView(\n-      img->size(), gfx::Size(kArtworkViewWidth, kArtworkViewHeight)));\n+  session_artwork_->SetImageSize(ScaleSizeToFitView(img->size(), kArtworkSize));\n   session_artwork_->SetImage(*img);\n }\n ""}<_**next**_>{""sha"": ""32ba818664da6f8f702f56ade884652ef058ddb8"", ""filename"": ""ash/login/ui/lock_screen_media_controls_view.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c25b198675380f713a56649c857b4367601d4a3d/ash/login/ui/lock_screen_media_controls_view.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c25b198675380f713a56649c857b4367601d4a3d/ash/login/ui/lock_screen_media_controls_view.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/login/ui/lock_screen_media_controls_view.h?ref=c25b198675380f713a56649c857b4367601d4a3d"", ""patch"": ""@@ -22,7 +22,6 @@ class Connector;\n namespace views {\n class ImageView;\n class ToggleImageButton;\n-class ImageButton;\n }  // namespace views\n \n namespace media_message_center {\n@@ -203,7 +202,6 @@ class ASH_EXPORT LockScreenMediaControlsView\n   views::ImageView* session_artwork_ = nullptr;\n   NonAccessibleView* button_row_ = nullptr;\n   views::ToggleImageButton* play_pause_button_ = nullptr;\n-  views::ImageButton* close_button_ = nullptr;\n   media_message_center::MediaControlsProgressView* progress_ = nullptr;\n \n   // Callbacks.""}<_**next**_>{""sha"": ""297ef3efa95f4ee0cd3059f2a4d5dd61ea3dc967"", ""filename"": ""ash/login/ui/lock_screen_media_controls_view_unittest.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c25b198675380f713a56649c857b4367601d4a3d/ash/login/ui/lock_screen_media_controls_view_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c25b198675380f713a56649c857b4367601d4a3d/ash/login/ui/lock_screen_media_controls_view_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/login/ui/lock_screen_media_controls_view_unittest.cc?ref=c25b198675380f713a56649c857b4367601d4a3d"", ""patch"": ""@@ -30,8 +30,8 @@ using media_session::test::TestMediaController;\n namespace {\n \n const int kAppIconSize = 20;\n-constexpr int kArtworkViewWidth = 270;\n-constexpr int kArtworkViewHeight = 200;\n+constexpr int kArtworkViewWidth = 80;\n+constexpr int kArtworkViewHeight = 80;\n \n const base::string16 kTestAppName = base::ASCIIToUTF16(\""Test app\"");\n \n@@ -202,14 +202,14 @@ class LockScreenMediaControlsViewTest : public LoginTestBase {\n     return media_controls_view_->session_artwork_;\n   }\n \n-  views::ImageButton* close_button() const {\n-    return media_controls_view_->close_button_;\n-  }\n-\n   media_message_center::MediaControlsProgressView* progress_view() const {\n     return media_controls_view_->progress_;\n   }\n \n+  views::ImageButton* close_button() const {\n+    return header_row()->close_button_for_testing();\n+  }\n+\n   const views::ImageView* icon_view() const {\n     return header_row()->app_icon_for_testing();\n   }\n@@ -590,7 +590,7 @@ TEST_F(LockScreenMediaControlsViewTest, UpdateArtwork) {\n \n   // Create artwork that must be scaled down to fit the view.\n   SkBitmap artwork;\n-  artwork.allocN32Pixels(540, 300);\n+  artwork.allocN32Pixels(200, 100);\n \n   media_controls_view_->MediaControllerImageChanged(\n       media_session::mojom::MediaSessionImageType::kArtwork, artwork);\n@@ -599,30 +599,30 @@ TEST_F(LockScreenMediaControlsViewTest, UpdateArtwork) {\n \n   // Verify that the provided artwork is correctly scaled down.\n   EXPECT_EQ(kArtworkViewWidth, artwork_bounds.width());\n-  EXPECT_EQ(150, artwork_bounds.height());\n+  EXPECT_EQ(40, artwork_bounds.height());\n \n   // Create artwork that must be scaled up to fit the view.\n-  artwork.allocN32Pixels(200, 190);\n+  artwork.allocN32Pixels(40, 70);\n \n   media_controls_view_->MediaControllerImageChanged(\n       media_session::mojom::MediaSessionImageType::kArtwork, artwork);\n \n   artwork_bounds = artwork_view()->GetImageBounds();\n \n   // Verify that the provided artwork is correctly scaled up.\n-  EXPECT_EQ(210, artwork_bounds.width());\n+  EXPECT_EQ(45, artwork_bounds.width());\n   EXPECT_EQ(kArtworkViewHeight, artwork_bounds.height());\n \n   // Create artwork that already fits the view size.\n-  artwork.allocN32Pixels(250, kArtworkViewHeight);\n+  artwork.allocN32Pixels(70, kArtworkViewHeight);\n \n   media_controls_view_->MediaControllerImageChanged(\n       media_session::mojom::MediaSessionImageType::kArtwork, artwork);\n \n   artwork_bounds = artwork_view()->GetImageBounds();\n \n   // Verify that the provided artwork size doesn't change.\n-  EXPECT_EQ(250, artwork_bounds.width());\n+  EXPECT_EQ(70, artwork_bounds.width());\n   EXPECT_EQ(kArtworkViewHeight, artwork_bounds.height());\n }\n ""}<_**next**_>{""sha"": ""bb98d2fdd80d657f823d0ab7f9bbca48cfd5715a"", ""filename"": ""ash/login/ui/media_controls_header_view.cc"", ""status"": ""modified"", ""additions"": 61, ""deletions"": 11, ""changes"": 72, ""blob_url"": ""https://github.com/chromium/chromium/blob/c25b198675380f713a56649c857b4367601d4a3d/ash/login/ui/media_controls_header_view.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c25b198675380f713a56649c857b4367601d4a3d/ash/login/ui/media_controls_header_view.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/login/ui/media_controls_header_view.cc?ref=c25b198675380f713a56649c857b4367601d4a3d"", ""patch"": ""@@ -4,31 +4,44 @@\n \n #include \""ash/login/ui/media_controls_header_view.h\""\n \n+#include \""ash/login/ui/non_accessible_view.h\""\n+#include \""ash/strings/grit/ash_strings.h\""\n+#include \""components/vector_icons/vector_icons.h\""\n #include \""ui/accessibility/ax_node_data.h\""\n+#include \""ui/base/l10n/l10n_util.h\""\n #include \""ui/gfx/font_list.h\""\n+#include \""ui/gfx/paint_vector_icon.h\""\n #include \""ui/views/background.h\""\n #include \""ui/views/border.h\""\n+#include \""ui/views/controls/button/image_button.h\""\n+#include \""ui/views/controls/button/image_button_factory.h\""\n #include \""ui/views/controls/image_view.h\""\n #include \""ui/views/controls/label.h\""\n-#include \""ui/views/layout/box_layout.h\""\n+#include \""ui/views/layout/flex_layout.h\""\n+#include \""ui/views/layout/flex_layout_types.h\""\n+#include \""ui/views/view_class_properties.h\""\n \n namespace ash {\n \n namespace {\n \n-constexpr gfx::Insets kMediaControlsHeaderInsets = gfx::Insets(0, 25, 25, 25);\n-constexpr int kIconSize = 20;\n-constexpr int kHeaderTextFontSize = 14;\n-constexpr int kMediaControlsHeaderChildSpacing = 10;\n+constexpr gfx::Insets kHeaderViewInsets = gfx::Insets(0, 0, 15, 0);\n+constexpr int kIconSize = 18;\n+constexpr int kHeaderTextFontSize = 12;\n constexpr gfx::Insets kIconPadding = gfx::Insets(1, 1, 1, 1);\n-constexpr int kIconCornerRadius = 2;\n+constexpr gfx::Insets kAppNamePadding = gfx::Insets(0, 10, 0, 0);\n+constexpr int kIconCornerRadius = 1;\n+constexpr gfx::Size kCloseButtonSize = gfx::Size(20, 20);\n+constexpr int kCloseButtonIconSize = 18;\n+constexpr gfx::Size kSpacerPreferredSize = gfx::Size(10, 5);\n \n }  // namespace\n \n-MediaControlsHeaderView::MediaControlsHeaderView() {\n-  SetLayoutManager(std::make_unique<views::BoxLayout>(\n-      views::BoxLayout::Orientation::kHorizontal, kMediaControlsHeaderInsets,\n-      kMediaControlsHeaderChildSpacing));\n+MediaControlsHeaderView::MediaControlsHeaderView(\n+    base::OnceClosure close_button_cb)\n+    : close_button_cb_(std::move(close_button_cb)) {\n+  auto* layout = SetLayoutManager(std::make_unique<views::FlexLayout>());\n+  layout->SetInteriorMargin(kHeaderViewInsets);\n \n   auto app_icon_view = std::make_unique<views::ImageView>();\n   app_icon_view->SetImageSize(gfx::Size(kIconSize, kIconSize));\n@@ -51,7 +64,28 @@ MediaControlsHeaderView::MediaControlsHeaderView() {\n   app_name_view->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   app_name_view->SetEnabledColor(SK_ColorWHITE);\n   app_name_view->SetAutoColorReadabilityEnabled(false);\n+  app_name_view->SetBorder(views::CreateEmptyBorder(kAppNamePadding));\n   app_name_view_ = AddChildView(std::move(app_name_view));\n+\n+  // Space between app name and close button.\n+  auto spacer = std::make_unique<NonAccessibleView>();\n+  spacer->SetPreferredSize(kSpacerPreferredSize);\n+  spacer->SetProperty(views::kFlexBehaviorKey,\n+                      views::FlexSpecification::ForSizeRule(\n+                          views::MinimumFlexSizeRule::kScaleToMinimum,\n+                          views::MaximumFlexSizeRule::kUnbounded));\n+  AddChildView(std::move(spacer));\n+\n+  auto close_button = CreateVectorImageButton(this);\n+  SetImageFromVectorIcon(close_button.get(), vector_icons::kCloseRoundedIcon,\n+                         kCloseButtonIconSize, gfx::kGoogleGrey700);\n+  close_button->SetPreferredSize(kCloseButtonSize);\n+  close_button->SetFocusBehavior(View::FocusBehavior::ALWAYS);\n+  base::string16 close_button_label(\n+      l10n_util::GetStringUTF16(IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_CLOSE));\n+  close_button->SetAccessibleName(close_button_label);\n+  close_button->SetVisible(false);\n+  close_button_ = AddChildView(std::move(close_button));\n }\n \n MediaControlsHeaderView::~MediaControlsHeaderView() = default;\n@@ -64,10 +98,22 @@ void MediaControlsHeaderView::SetAppName(const base::string16& name) {\n   app_name_view_->SetText(name);\n }\n \n+void MediaControlsHeaderView::SetCloseButtonVisibility(bool visible) {\n+  if (visible != close_button_->GetVisible()) {\n+    close_button_->SetVisible(visible);\n+    Layout();\n+  }\n+}\n+\n void MediaControlsHeaderView::GetAccessibleNodeData(ui::AXNodeData* node_data) {\n   node_data->SetName(app_name_view_->GetText());\n }\n \n+void MediaControlsHeaderView::ButtonPressed(views::Button* sender,\n+                                            const ui::Event& event) {\n+  std::move(close_button_cb_).Run();\n+}\n+\n const base::string16& MediaControlsHeaderView::app_name_for_testing() const {\n   return app_name_view_->GetText();\n }\n@@ -76,4 +122,8 @@ const views::ImageView* MediaControlsHeaderView::app_icon_for_testing() const {\n   return app_icon_view_;\n }\n \n-}  // namespace ash\n\\ No newline at end of file\n+views::ImageButton* MediaControlsHeaderView::close_button_for_testing() const {\n+  return close_button_;\n+}\n+\n+}  // namespace ash""}<_**next**_>{""sha"": ""fb24fc709b944db11e220e840c5e8cd53fc7491f"", ""filename"": ""ash/login/ui/media_controls_header_view.h"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 3, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/c25b198675380f713a56649c857b4367601d4a3d/ash/login/ui/media_controls_header_view.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c25b198675380f713a56649c857b4367601d4a3d/ash/login/ui/media_controls_header_view.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/login/ui/media_controls_header_view.h?ref=c25b198675380f713a56649c857b4367601d4a3d"", ""patch"": ""@@ -6,36 +6,48 @@\n #define ASH_LOGIN_UI_MEDIA_CONTROLS_HEADER_VIEW_H_\n \n #include \""ash/ash_export.h\""\n+#include \""ui/views/controls/button/button.h\""\n #include \""ui/views/view.h\""\n \n namespace views {\n class ImageView;\n class Label;\n+class ImageButton;\n }  // namespace views\n \n namespace ash {\n \n-class ASH_EXPORT MediaControlsHeaderView : public views::View {\n+class ASH_EXPORT MediaControlsHeaderView : public views::View,\n+                                           public views::ButtonListener {\n  public:\n-  MediaControlsHeaderView();\n+  explicit MediaControlsHeaderView(base::OnceClosure close_button_cb);\n   ~MediaControlsHeaderView() override;\n \n   void SetAppIcon(const gfx::ImageSkia& img);\n   void SetAppName(const base::string16& name);\n \n+  void SetCloseButtonVisibility(bool visible);\n+\n   // views::View:\n   void GetAccessibleNodeData(ui::AXNodeData* node_data) override;\n \n+  // views::ButtonListener:\n+  void ButtonPressed(views::Button* sender, const ui::Event& event) override;\n+\n   const base::string16& app_name_for_testing() const;\n   const views::ImageView* app_icon_for_testing() const;\n+  views::ImageButton* close_button_for_testing() const;\n \n  private:\n   views::ImageView* app_icon_view_;\n   views::Label* app_name_view_;\n+  views::ImageButton* close_button_ = nullptr;\n+\n+  base::OnceClosure close_button_cb_;\n \n   DISALLOW_COPY_AND_ASSIGN(MediaControlsHeaderView);\n };\n \n }  // namespace ash\n \n-#endif  // ASH_LOGIN_UI_MEDIA_CONTROLS_HEADER_VIEW_H_\n\\ No newline at end of file\n+#endif  // ASH_LOGIN_UI_MEDIA_CONTROLS_HEADER_VIEW_H_""}<_**next**_>{""sha"": ""af87e06f8f38d5a8ccc02459b742d7554574e3d7"", ""filename"": ""components/media_message_center/media_controls_progress_view.cc"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 20, ""changes"": 40, ""blob_url"": ""https://github.com/chromium/chromium/blob/c25b198675380f713a56649c857b4367601d4a3d/components/media_message_center/media_controls_progress_view.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c25b198675380f713a56649c857b4367601d4a3d/components/media_message_center/media_controls_progress_view.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/media_message_center/media_controls_progress_view.cc?ref=c25b198675380f713a56649c857b4367601d4a3d"", ""patch"": ""@@ -19,21 +19,25 @@ namespace media_message_center {\n \n namespace {\n \n-constexpr int kProgressTimeFontSize = 12;\n+constexpr int kProgressBarAndTimeSpacing = 3;\n+constexpr int kProgressTimeFontSize = 11;\n+constexpr int kProgressBarHeight = 4;\n+constexpr int kMinClickHeight = 14;\n+constexpr int kMaxClickHeight = 24;\n constexpr gfx::Size kTimeSpacingSize = gfx::Size(150, 10);\n-constexpr gfx::Insets kProgressViewInsets = gfx::Insets(15, 25, 0, 25);\n-constexpr gfx::Insets kProgressBarInsets = gfx::Insets(5, 0, 5, 0);\n+constexpr gfx::Insets kProgressViewInsets = gfx::Insets(15, 0, 0, 0);\n \n }  // namespace\n \n MediaControlsProgressView::MediaControlsProgressView(\n     base::RepeatingCallback<void(double)> seek_callback)\n     : seek_callback_(std::move(seek_callback)) {\n   SetLayoutManager(std::make_unique<views::BoxLayout>(\n-      views::BoxLayout::Orientation::kVertical, kProgressViewInsets));\n+      views::BoxLayout::Orientation::kVertical, kProgressViewInsets,\n+      kProgressBarAndTimeSpacing));\n \n-  progress_bar_ = AddChildView(std::make_unique<views::ProgressBar>(5, false));\n-  progress_bar_->SetBorder(views::CreateEmptyBorder(kProgressBarInsets));\n+  progress_bar_ = AddChildView(\n+      std::make_unique<views::ProgressBar>(kProgressBarHeight, false));\n \n   // Font list for text views.\n   gfx::Font default_font;\n@@ -127,28 +131,22 @@ void MediaControlsProgressView::UpdateProgress(\n }\n \n bool MediaControlsProgressView::OnMousePressed(const ui::MouseEvent& event) {\n-  gfx::Point location_in_bar(event.location());\n-  ConvertPointToTarget(this, this->progress_bar_, &location_in_bar);\n-\n-  if (!event.IsOnlyLeftMouseButton() ||\n-      !progress_bar_->GetLocalBounds().Contains(location_in_bar)) {\n+  if (!event.IsOnlyLeftMouseButton() || event.y() < kMinClickHeight ||\n+      event.y() > kMaxClickHeight) {\n     return false;\n   }\n \n-  HandleSeeking(location_in_bar);\n+  HandleSeeking(event.location());\n   return true;\n }\n \n void MediaControlsProgressView::OnGestureEvent(ui::GestureEvent* event) {\n-  gfx::Point location_in_bar(event->location());\n-  ConvertPointToTarget(this, this->progress_bar_, &location_in_bar);\n-\n-  if (event->type() != ui::ET_GESTURE_TAP ||\n-      !progress_bar_->GetLocalBounds().Contains(location_in_bar)) {\n+  if (event->type() != ui::ET_GESTURE_TAP || event->y() < kMinClickHeight ||\n+      event->y() > kMaxClickHeight) {\n     return;\n   }\n \n-  HandleSeeking(location_in_bar);\n+  HandleSeeking(event->location());\n   event->SetHandled();\n }\n \n@@ -178,8 +176,10 @@ void MediaControlsProgressView::SetDuration(const base::string16& duration) {\n   duration_->SetText(duration);\n }\n \n-void MediaControlsProgressView::HandleSeeking(\n-    const gfx::Point& location_in_bar) {\n+void MediaControlsProgressView::HandleSeeking(const gfx::Point& location) {\n+  gfx::Point location_in_bar(location);\n+  ConvertPointToTarget(this, progress_bar_, &location_in_bar);\n+\n   double seek_to_progress =\n       static_cast<double>(location_in_bar.x()) / progress_bar_->width();\n   seek_callback_.Run(seek_to_progress);""}<_**next**_>{""sha"": ""8f5ac64c5a1ddb04455275d3905f09c04ea93d65"", ""filename"": ""components/media_message_center/media_controls_progress_view.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c25b198675380f713a56649c857b4367601d4a3d/components/media_message_center/media_controls_progress_view.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c25b198675380f713a56649c857b4367601d4a3d/components/media_message_center/media_controls_progress_view.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/media_message_center/media_controls_progress_view.h?ref=c25b198675380f713a56649c857b4367601d4a3d"", ""patch"": ""@@ -38,7 +38,7 @@ class COMPONENT_EXPORT(MEDIA_MESSAGE_CENTER) MediaControlsProgressView\n   void SetProgressTime(const base::string16& time);\n   void SetDuration(const base::string16& duration);\n \n-  void HandleSeeking(const gfx::Point& location_in_bar);\n+  void HandleSeeking(const gfx::Point& location);\n \n   views::ProgressBar* progress_bar_;\n   views::Label* progress_time_;""}",    return media_controls_view_->close_button_;/~/  },"1,2","  views::ImageButton* close_button() const {
","  views::ImageButton* close_button() const {
    return media_controls_view_->close_button_;
  }
",186311.0,C,,"    return media_controls_view_->close_button_;
  }
",,"@@ -30,8 +30,8 @@ using media_session::test::TestMediaController;
 namespace {
 
 const int kAppIconSize = 20;
-constexpr int kArtworkViewWidth = 270;
-constexpr int kArtworkViewHeight = 200;
+constexpr int kArtworkViewWidth = 80;
+constexpr int kArtworkViewHeight = 80;
 
 const base::string16 kTestAppName = base::ASCIIToUTF16(""Test app"");
 
@@ -202,14 +202,14 @@ class LockScreenMediaControlsViewTest : public LoginTestBase {
     return media_controls_view_->session_artwork_;
   }
 
-  views::ImageButton* close_button() const {
-    return media_controls_view_->close_button_;
-  }
-
   media_message_center::MediaControlsProgressView* progress_view() const {
     return media_controls_view_->progress_;
   }
 
+  views::ImageButton* close_button() const {
+    return header_row()->close_button_for_testing();
+  }
+
   const views::ImageView* icon_view() const {
     return header_row()->app_icon_for_testing();
   }
@@ -590,7 +590,7 @@ TEST_F(LockScreenMediaControlsViewTest, UpdateArtwork) {
 
   // Create artwork that must be scaled down to fit the view.
   SkBitmap artwork;
-  artwork.allocN32Pixels(540, 300);
+  artwork.allocN32Pixels(200, 100);
 
   media_controls_view_->MediaControllerImageChanged(
       media_session::mojom::MediaSessionImageType::kArtwork, artwork);
@@ -599,30 +599,30 @@ TEST_F(LockScreenMediaControlsViewTest, UpdateArtwork) {
 
   // Verify that the provided artwork is correctly scaled down.
   EXPECT_EQ(kArtworkViewWidth, artwork_bounds.width());
-  EXPECT_EQ(150, artwork_bounds.height());
+  EXPECT_EQ(40, artwork_bounds.height());
 
   // Create artwork that must be scaled up to fit the view.
-  artwork.allocN32Pixels(200, 190);
+  artwork.allocN32Pixels(40, 70);
 
   media_controls_view_->MediaControllerImageChanged(
       media_session::mojom::MediaSessionImageType::kArtwork, artwork);
 
   artwork_bounds = artwork_view()->GetImageBounds();
 
   // Verify that the provided artwork is correctly scaled up.
-  EXPECT_EQ(210, artwork_bounds.width());
+  EXPECT_EQ(45, artwork_bounds.width());
   EXPECT_EQ(kArtworkViewHeight, artwork_bounds.height());
 
   // Create artwork that already fits the view size.
-  artwork.allocN32Pixels(250, kArtworkViewHeight);
+  artwork.allocN32Pixels(70, kArtworkViewHeight);
 
   media_controls_view_->MediaControllerImageChanged(
       media_session::mojom::MediaSessionImageType::kArtwork, artwork);
 
   artwork_bounds = artwork_view()->GetImageBounds();
 
   // Verify that the provided artwork size doesn't change.
-  EXPECT_EQ(250, artwork_bounds.width());
+  EXPECT_EQ(70, artwork_bounds.width());
   EXPECT_EQ(kArtworkViewHeight, artwork_bounds.height());
 }
 ","views::ImageButton* close_button() const {
    return media_controls_view_->close_button_;
  }
",Chrome,c25b198675380f713a56649c857b4367601d4a3d,c0ab70c63fa82d88146a766767bc6baad8b36089,1.0,"  views::ImageButton* close_button() const {
//flaw_line_below:
    return media_controls_view_->close_button_;
//flaw_line_below:
  }
"
367,None,Local,Not required,Partial,CVE-2014-4978,https://www.cvedetails.com/cve/CVE-2014-4978/,CWE-59,Low,None,Partial,,2017-12-29,3.6,The rs_filter_graph function in librawstudio/rs-filter.c in rawstudio might allow local users to truncate arbitrary files via a symlink attack on (1) /tmp/rs-filter-graph.png or (2) /tmp/rs-filter-graph.,2018-01-10,,18.0,https://github.com/rawstudio/rawstudio/commit/9c2cd3c93c05d009a91d84eedbb85873b0cb505d,9c2cd3c93c05d009a91d84eedbb85873b0cb505d,Fixes insecure use of temporary file (CVE-2014-4978).,3.0,librawstudio/rs-filter.c,"{""sha"": ""352b23c51a00b32c4993732b1534ff5a988ee763"", ""filename"": ""librawstudio/rs-filter.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 3, ""changes"": 21, ""blob_url"": ""https://github.com/rawstudio/rawstudio/blob/9c2cd3c93c05d009a91d84eedbb85873b0cb505d/librawstudio/rs-filter.c"", ""raw_url"": ""https://github.com/rawstudio/rawstudio/raw/9c2cd3c93c05d009a91d84eedbb85873b0cb505d/librawstudio/rs-filter.c"", ""contents_url"": ""https://api.github.com/repos/rawstudio/rawstudio/contents/librawstudio/rs-filter.c?ref=9c2cd3c93c05d009a91d84eedbb85873b0cb505d"", ""patch"": ""@@ -772,17 +772,32 @@ void\n rs_filter_graph(RSFilter *filter)\n {\n \tg_return_if_fail(RS_IS_FILTER(filter));\n+\tgchar *dot_filename;\n+\tgchar *png_filename;\n+\tgchar *command_line;\n \tGString *str = g_string_new(\""digraph G {\\n\"");\n \n \trs_filter_graph_helper(str, filter);\n \n \tg_string_append_printf(str, \""}\\n\"");\n-\tg_file_set_contents(\""/tmp/rs-filter-graph\"", str->str, str->len, NULL);\n \n-\tif (0 != system(\""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\""))\n+\t/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */\n+\tdot_filename = g_strdup_printf(\""/tmp/rs-filter-graph.%u\"", g_random_int());\n+\tpng_filename = g_strdup_printf(\""%s.%u.png\"", dot_filename, g_random_int());\n+\n+\tg_file_set_contents(dot_filename, str->str, str->len, NULL);\n+\n+\tcommand_line = g_strdup_printf(\""dot -Tpng >%s <%s\"", png_filename, dot_filename);\n+\tif (0 != system(command_line))\n \t\tg_warning(\""Calling dot failed\"");\n-\tif (0 != system(\""gnome-open /tmp/rs-filter-graph.png\""))\n+\tg_free(command_line);\n+\n+\tcommand_line = g_strdup_printf(\""gnome-open %s\"", png_filename);\n+\tif (0 != system(command_line))\n \t\tg_warning(\""Calling gnome-open failed.\"");\n+\tg_free(command_line);\n \n+\tg_free(dot_filename);\n+\tg_free(png_filename);\n \tg_string_free(str, TRUE);\n }""}","	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);/~/	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))/~/	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))","8,10,12"," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
	gchar *dot_filename;
	gchar *png_filename;
	gchar *command_line;
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
 
	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());

	g_file_set_contents(dot_filename, str->str, str->len, NULL);

	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
	if (0 != system(command_line))
 		g_warning(""Calling dot failed"");
	g_free(command_line);

	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
	if (0 != system(command_line))
 		g_warning(""Calling gnome-open failed."");
	g_free(command_line);
 
	g_free(dot_filename);
	g_free(png_filename);
 	g_string_free(str, TRUE);
 }
"," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 
 	g_string_free(str, TRUE);
 }
",182086.0,C,"	gchar *dot_filename;
	gchar *png_filename;
	gchar *command_line;
	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());

	g_file_set_contents(dot_filename, str->str, str->len, NULL);

	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
	if (0 != system(command_line))
	g_free(command_line);

	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
	if (0 != system(command_line))
	g_free(command_line);
	g_free(dot_filename);
	g_free(png_filename);
","	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
",,"@@ -772,17 +772,32 @@ void
 rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
+	gchar *dot_filename;
+	gchar *png_filename;
+	gchar *command_line;
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
-	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
-	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
+	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
+	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
+	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());
+
+	g_file_set_contents(dot_filename, str->str, str->len, NULL);
+
+	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
+	if (0 != system(command_line))
 		g_warning(""Calling dot failed"");
-	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
+	g_free(command_line);
+
+	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
+	if (0 != system(command_line))
 		g_warning(""Calling gnome-open failed."");
+	g_free(command_line);
 
+	g_free(dot_filename);
+	g_free(png_filename);
 	g_string_free(str, TRUE);
 }","rs_filter_graph(RSFilter *filter)
{
g_return_if_fail(RS_IS_FILTER(filter));
GString *str = g_string_new(""digraph G {\n"");

rs_filter_graph_helper(str, filter);

g_string_append_printf(str, ""}\n"");
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);

	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
g_warning(""Calling gnome-open failed."");

g_string_free(str, TRUE);
}
",rawstudio,9c2cd3c93c05d009a91d84eedbb85873b0cb505d,70f2da78b575ea1105eae865c7e49465b838bdfd,1.0," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
//fix_flaw_line_below:
//	gchar *dot_filename;
//fix_flaw_line_below:
//	gchar *png_filename;
//fix_flaw_line_below:
//	gchar *command_line;
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
//flaw_line_below:
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
//flaw_line_below:
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
//fix_flaw_line_below:
//	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
//fix_flaw_line_below:
//	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
//fix_flaw_line_below:
//	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	g_file_set_contents(dot_filename, str->str, str->len, NULL);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
//fix_flaw_line_below:
//	if (0 != system(command_line))
 		g_warning(""Calling dot failed"");
//flaw_line_below:
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
//fix_flaw_line_below:
//	g_free(command_line);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
//fix_flaw_line_below:
//	if (0 != system(command_line))
 		g_warning(""Calling gnome-open failed."");
//fix_flaw_line_below:
//	g_free(command_line);
 
//fix_flaw_line_below:
//	g_free(dot_filename);
//fix_flaw_line_below:
//	g_free(png_filename);
 	g_string_free(str, TRUE);
 }
"
378,None,Remote,Not required,None,CVE-2011-2795,https://www.cvedetails.com/cve/CVE-2011-2795/,CWE-264,Medium,Partial,Partial,,2011-08-02,5.8,"Google Chrome before 13.0.782.107 does not prevent calls to functions in other frames, which allows remote attackers to bypass intended access restrictions via a crafted web site, related to a *cross-frame function leak.*",2017-09-18,Bypass ,0.0,https://github.com/chromium/chromium/commit/73edae623529f04c668268de49d00324b96166a2,73edae623529f04c668268de49d00324b96166a2,"There are too many poorly named functions to create a fragment from markup
https://bugs.webkit.org/show_bug.cgi?id=87339

Reviewed by Eric Seidel.

Source/WebCore:

Moved all functions that create a fragment from markup to markup.h/cpp.
There should be no behavioral change.

* dom/Range.cpp:
(WebCore::Range::createContextualFragment):
* dom/Range.h: Removed createDocumentFragmentForElement.
* dom/ShadowRoot.cpp:
(WebCore::ShadowRoot::setInnerHTML):
* editing/markup.cpp:
(WebCore::createFragmentFromMarkup):
(WebCore::createFragmentForInnerOuterHTML): Renamed from createFragmentFromSource.
(WebCore::createFragmentForTransformToFragment): Moved from XSLTProcessor.
(WebCore::removeElementPreservingChildren): Moved from Range.
(WebCore::createContextualFragment): Ditto.
* editing/markup.h:
* html/HTMLElement.cpp:
(WebCore::HTMLElement::setInnerHTML):
(WebCore::HTMLElement::setOuterHTML):
(WebCore::HTMLElement::insertAdjacentHTML):
* inspector/DOMPatchSupport.cpp:
(WebCore::DOMPatchSupport::patchNode): Added a FIXME since this code should be using
one of the functions listed in markup.h
* xml/XSLTProcessor.cpp:
(WebCore::XSLTProcessor::transformToFragment):

Source/WebKit/qt:

Replace calls to Range::createDocumentFragmentForElement by calls to
createContextualDocumentFragment.

* Api/qwebelement.cpp:
(QWebElement::appendInside):
(QWebElement::prependInside):
(QWebElement::prependOutside):
(QWebElement::appendOutside):
(QWebElement::encloseContentsWith):
(QWebElement::encloseWith):


git-svn-id: svn://svn.chromium.org/blink/trunk@118414 bbb929c8-8fbe-4397-9dbb-9b2b20218538",13.0,third_party/WebKit/Source/WebCore/dom/Range.cpp,"{""sha"": ""9702de37fce3917431ac182122fefad351b064e9"", ""filename"": ""third_party/WebKit/Source/WebCore/ChangeLog"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 0, ""changes"": 32, ""blob_url"": ""https://github.com/chromium/chromium/blob/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/ChangeLog"", ""raw_url"": ""https://github.com/chromium/chromium/raw/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/ChangeLog?ref=73edae623529f04c668268de49d00324b96166a2"", ""patch"": ""@@ -1,3 +1,35 @@\n+2012-05-24  Ryosuke Niwa  <rniwa@webkit.org>\n+\n+        There are too many poorly named functions to create a fragment from markup\n+        https://bugs.webkit.org/show_bug.cgi?id=87339\n+\n+        Reviewed by Eric Seidel.\n+\n+        Moved all functions that create a fragment from markup to markup.h/cpp.\n+        There should be no behavioral change.\n+\n+        * dom/Range.cpp:\n+        (WebCore::Range::createContextualFragment):\n+        * dom/Range.h: Removed createDocumentFragmentForElement.\n+        * dom/ShadowRoot.cpp:\n+        (WebCore::ShadowRoot::setInnerHTML):\n+        * editing/markup.cpp:\n+        (WebCore::createFragmentFromMarkup):\n+        (WebCore::createFragmentForInnerOuterHTML): Renamed from createFragmentFromSource.\n+        (WebCore::createFragmentForTransformToFragment): Moved from XSLTProcessor.\n+        (WebCore::removeElementPreservingChildren): Moved from Range.\n+        (WebCore::createContextualFragment): Ditto.\n+        * editing/markup.h:\n+        * html/HTMLElement.cpp:\n+        (WebCore::HTMLElement::setInnerHTML):\n+        (WebCore::HTMLElement::setOuterHTML):\n+        (WebCore::HTMLElement::insertAdjacentHTML):\n+        * inspector/DOMPatchSupport.cpp:\n+        (WebCore::DOMPatchSupport::patchNode): Added a FIXME since this code should be using\n+        one of the functions listed in markup.h\n+        * xml/XSLTProcessor.cpp:\n+        (WebCore::XSLTProcessor::transformToFragment):\n+\n 2012-05-24  Jer Noble  <jer.noble@apple.com>\n \n         MediaControlTimelineElement is adjusting time 3 times per click""}<_**next**_>{""sha"": ""2d86fcfa9a9d471313ddc08c38b8a3d1f67f6ded"", ""filename"": ""third_party/WebKit/Source/WebCore/dom/Range.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 52, ""changes"": 53, ""blob_url"": ""https://github.com/chromium/chromium/blob/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/dom/Range.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/dom/Range.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/dom/Range.cpp?ref=73edae623529f04c668268de49d00324b96166a2"", ""patch"": ""@@ -1111,57 +1111,6 @@ String Range::text() const\n     return plainText(this);\n }\n \n-static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)\n-{\n-    ExceptionCode ignoredExceptionCode;\n-\n-    RefPtr<Node> nextChild;\n-    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {\n-        nextChild = child->nextSibling();\n-        element->removeChild(child.get(), ignoredExceptionCode);\n-        ASSERT(!ignoredExceptionCode);\n-        fragment->insertBefore(child, element, ignoredExceptionCode);\n-        ASSERT(!ignoredExceptionCode);\n-    }\n-    fragment->removeChild(element, ignoredExceptionCode);\n-    ASSERT(!ignoredExceptionCode);\n-}\n-\n-PassRefPtr<DocumentFragment> Range::createDocumentFragmentForElement(const String& markup, Element* element,  FragmentScriptingPermission scriptingPermission)\n-{\n-    ASSERT(element);\n-    HTMLElement* htmlElement = toHTMLElement(element);\n-    if (htmlElement->ieForbidsInsertHTML())\n-        return 0;\n-\n-    if (htmlElement->hasLocalName(colTag) || htmlElement->hasLocalName(colgroupTag) || htmlElement->hasLocalName(framesetTag)\n-        || htmlElement->hasLocalName(headTag) || htmlElement->hasLocalName(styleTag) || htmlElement->hasLocalName(titleTag))\n-        return 0;\n-\n-    RefPtr<DocumentFragment> fragment = element->document()->createDocumentFragment();\n-\n-    if (element->document()->isHTMLDocument())\n-        fragment->parseHTML(markup, element, scriptingPermission);\n-    else if (!fragment->parseXML(markup, element, scriptingPermission))\n-        return 0; // FIXME: We should propagate a syntax error exception out here.\n-\n-    // We need to pop <html> and <body> elements and remove <head> to\n-    // accommodate folks passing complete HTML documents to make the\n-    // child of an element.\n-\n-    RefPtr<Node> nextNode;\n-    for (RefPtr<Node> node = fragment->firstChild(); node; node = nextNode) {\n-        nextNode = node->nextSibling();\n-        if (node->hasTagName(htmlTag) || node->hasTagName(headTag) || node->hasTagName(bodyTag)) {\n-            HTMLElement* element = toHTMLElement(node.get());\n-            if (Node* firstChild = element->firstChild())\n-                nextNode = firstChild;\n-            removeElementPreservingChildren(fragment, element);\n-        }\n-    }\n-    return fragment.release();\n-}\n-\n PassRefPtr<DocumentFragment> Range::createContextualFragment(const String& markup, ExceptionCode& ec)\n {\n     if (!m_start.container()) {\n@@ -1175,7 +1124,7 @@ PassRefPtr<DocumentFragment> Range::createContextualFragment(const String& marku\n         return 0;\n     }\n \n-    RefPtr<DocumentFragment> fragment = createDocumentFragmentForElement(markup, toElement(element), AllowScriptingContentAndDoNotMarkAlreadyStarted);\n+    RefPtr<DocumentFragment> fragment = WebCore::createContextualFragment(markup, toElement(element), AllowScriptingContentAndDoNotMarkAlreadyStarted);\n \n     if (!fragment) {\n         ec = NOT_SUPPORTED_ERR;""}<_**next**_>{""sha"": ""8f0e98b478086a95284e503b2c307c9c49ff2ef0"", ""filename"": ""third_party/WebKit/Source/WebCore/dom/Range.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/dom/Range.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/dom/Range.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/dom/Range.h?ref=73edae623529f04c668268de49d00324b96166a2"", ""patch"": ""@@ -90,7 +90,6 @@ class Range : public RefCounted<Range> {\n     String text() const;\n \n     PassRefPtr<DocumentFragment> createContextualFragment(const String& html, ExceptionCode&);\n-    static PassRefPtr<DocumentFragment> createDocumentFragmentForElement(const String& markup, Element*,  FragmentScriptingPermission = AllowScriptingContent);\n \n     void detach(ExceptionCode&);\n     PassRefPtr<Range> cloneRange(ExceptionCode&) const;""}<_**next**_>{""sha"": ""86a10cdc075e60312b3605ff408d69b0b9427177"", ""filename"": ""third_party/WebKit/Source/WebCore/dom/ShadowRoot.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/dom/ShadowRoot.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/dom/ShadowRoot.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/dom/ShadowRoot.cpp?ref=73edae623529f04c668268de49d00324b96166a2"", ""patch"": ""@@ -144,8 +144,7 @@ String ShadowRoot::innerHTML() const\n \n void ShadowRoot::setInnerHTML(const String& markup, ExceptionCode& ec)\n {\n-    RefPtr<DocumentFragment> fragment = createFragmentFromSource(markup, host(), ec);\n-    if (fragment)\n+    if (RefPtr<DocumentFragment> fragment = createFragmentForInnerOuterHTML(markup, host(), ec))\n         replaceChildrenWithFragment(this, fragment.release(), ec);\n }\n ""}<_**next**_>{""sha"": ""4983dcd4da0b09c982d22ba489ea0d70c4a773cc"", ""filename"": ""third_party/WebKit/Source/WebCore/editing/markup.cpp"", ""status"": ""modified"", ""additions"": 78, ""deletions"": 2, ""changes"": 80, ""blob_url"": ""https://github.com/chromium/chromium/blob/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/editing/markup.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/editing/markup.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/editing/markup.cpp?ref=73edae623529f04c668268de49d00324b96166a2"", ""patch"": ""@@ -665,7 +665,7 @@ PassRefPtr<DocumentFragment> createFragmentFromMarkup(Document* document, const\n {\n     // We use a fake body element here to trick the HTML parser to using the InBody insertion mode.\n     RefPtr<HTMLBodyElement> fakeBody = HTMLBodyElement::create(document);\n-    RefPtr<DocumentFragment> fragment =  Range::createDocumentFragmentForElement(markup, fakeBody.get(), scriptingPermission);\n+    RefPtr<DocumentFragment> fragment = createContextualFragment(markup, fakeBody.get(), scriptingPermission);\n \n     if (fragment && !baseURL.isEmpty() && baseURL != blankURL() && baseURL != document->baseURL())\n         completeURLs(fragment.get(), baseURL);\n@@ -992,7 +992,7 @@ String urlToMarkup(const KURL& url, const String& title)\n     return markup.toString();\n }\n \n-PassRefPtr<DocumentFragment> createFragmentFromSource(const String& markup, Element* contextElement, ExceptionCode& ec)\n+PassRefPtr<DocumentFragment> createFragmentForInnerOuterHTML(const String& markup, Element* contextElement, ExceptionCode& ec)\n {\n     Document* document = contextElement->document();\n     RefPtr<DocumentFragment> fragment = DocumentFragment::create(document);\n@@ -1010,6 +1010,82 @@ PassRefPtr<DocumentFragment> createFragmentFromSource(const String& markup, Elem\n     return fragment.release();\n }\n \n+PassRefPtr<DocumentFragment> createFragmentForTransformToFragment(const String& sourceString, const String& sourceMIMEType, Document* outputDoc)\n+{\n+    RefPtr<DocumentFragment> fragment = outputDoc->createDocumentFragment();\n+    \n+    if (sourceMIMEType == \""text/html\"") {\n+        // As far as I can tell, there isn't a spec for how transformToFragment is supposed to work.\n+        // Based on the documentation I can find, it looks like we want to start parsing the fragment in the InBody insertion mode.\n+        // Unfortunately, that's an implementation detail of the parser.\n+        // We achieve that effect here by passing in a fake body element as context for the fragment.\n+        RefPtr<HTMLBodyElement> fakeBody = HTMLBodyElement::create(outputDoc);\n+        fragment->parseHTML(sourceString, fakeBody.get());\n+    } else if (sourceMIMEType == \""text/plain\"")\n+        fragment->parserAddChild(Text::create(outputDoc, sourceString));\n+    else {\n+        bool successfulParse = fragment->parseXML(sourceString, 0);\n+        if (!successfulParse)\n+            return 0;\n+    }\n+    \n+    // FIXME: Do we need to mess with URLs here?\n+    \n+    return fragment.release();\n+}\n+\n+static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)\n+{\n+    ExceptionCode ignoredExceptionCode;\n+\n+    RefPtr<Node> nextChild;\n+    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {\n+        nextChild = child->nextSibling();\n+        element->removeChild(child.get(), ignoredExceptionCode);\n+        ASSERT(!ignoredExceptionCode);\n+        fragment->insertBefore(child, element, ignoredExceptionCode);\n+        ASSERT(!ignoredExceptionCode);\n+    }\n+    fragment->removeChild(element, ignoredExceptionCode);\n+    ASSERT(!ignoredExceptionCode);\n+}\n+\n+PassRefPtr<DocumentFragment> createContextualFragment(const String& markup, Element* element,  FragmentScriptingPermission scriptingPermission)\n+{\n+    ASSERT(element);\n+    HTMLElement* htmlElement = toHTMLElement(element);\n+    if (htmlElement->ieForbidsInsertHTML())\n+        return 0;\n+\n+    if (htmlElement->hasLocalName(colTag) || htmlElement->hasLocalName(colgroupTag) || htmlElement->hasLocalName(framesetTag)\n+        || htmlElement->hasLocalName(headTag) || htmlElement->hasLocalName(styleTag) || htmlElement->hasLocalName(titleTag))\n+        return 0;\n+\n+    // FIXME: This code is almost identical to createFragmentForInnerOuterHTML except this code doesn't handle exceptions.\n+    RefPtr<DocumentFragment> fragment = element->document()->createDocumentFragment();\n+\n+    if (element->document()->isHTMLDocument())\n+        fragment->parseHTML(markup, element, scriptingPermission);\n+    else if (!fragment->parseXML(markup, element, scriptingPermission))\n+        return 0; // FIXME: We should propagate a syntax error exception out here.\n+\n+    // We need to pop <html> and <body> elements and remove <head> to\n+    // accommodate folks passing complete HTML documents to make the\n+    // child of an element.\n+\n+    RefPtr<Node> nextNode;\n+    for (RefPtr<Node> node = fragment->firstChild(); node; node = nextNode) {\n+        nextNode = node->nextSibling();\n+        if (node->hasTagName(htmlTag) || node->hasTagName(headTag) || node->hasTagName(bodyTag)) {\n+            HTMLElement* element = toHTMLElement(node.get());\n+            if (Node* firstChild = element->firstChild())\n+                nextNode = firstChild;\n+            removeElementPreservingChildren(fragment, element);\n+        }\n+    }\n+    return fragment.release();\n+}\n+\n static inline bool hasOneChild(ContainerNode* node)\n {\n     Node* firstChild = node->firstChild();""}<_**next**_>{""sha"": ""a36cb350aa134030585b41a6295e0e6342127d29"", ""filename"": ""third_party/WebKit/Source/WebCore/editing/markup.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/editing/markup.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/editing/markup.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/editing/markup.h?ref=73edae623529f04c668268de49d00324b96166a2"", ""patch"": ""@@ -51,7 +51,9 @@ namespace WebCore {\n     PassRefPtr<DocumentFragment> createFragmentFromMarkup(Document*, const String& markup, const String& baseURL, FragmentScriptingPermission = AllowScriptingContent);\n     PassRefPtr<DocumentFragment> createFragmentFromMarkupWithContext(Document*, const String& markup, unsigned fragmentStart, unsigned fragmentEnd, const String& baseURL, FragmentScriptingPermission);\n     PassRefPtr<DocumentFragment> createFragmentFromNodes(Document*, const Vector<Node*>&);\n-    PassRefPtr<DocumentFragment> createFragmentFromSource(const String&, Element*, ExceptionCode&);\n+    PassRefPtr<DocumentFragment> createFragmentForInnerOuterHTML(const String&, Element*, ExceptionCode&);\n+    PassRefPtr<DocumentFragment> createFragmentForTransformToFragment(const String&, const String& sourceMIMEType, Document* outputDoc);\n+    PassRefPtr<DocumentFragment> createContextualFragment(const String&, Element*,  FragmentScriptingPermission);\n \n     bool isPlainTextMarkup(Node *node);\n ""}<_**next**_>{""sha"": ""b420c342bb1fcb7e39409e81a0dc7bdff31aea28"", ""filename"": ""third_party/WebKit/Source/WebCore/html/HTMLElement.cpp"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 13, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/html/HTMLElement.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/html/HTMLElement.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/html/HTMLElement.cpp?ref=73edae623529f04c668268de49d00324b96166a2"", ""patch"": ""@@ -342,8 +342,7 @@ String HTMLElement::outerHTML() const\n \n void HTMLElement::setInnerHTML(const String& html, ExceptionCode& ec)\n {\n-    RefPtr<DocumentFragment> fragment = createFragmentFromSource(html, this, ec);\n-    if (fragment)\n+    if (RefPtr<DocumentFragment> fragment = createFragmentForInnerOuterHTML(html, this, ec))\n         replaceChildrenWithFragment(this, fragment.release(), ec);\n }\n \n@@ -374,7 +373,7 @@ void HTMLElement::setOuterHTML(const String& html, ExceptionCode& ec)\n     RefPtr<Node> prev = previousSibling();\n     RefPtr<Node> next = nextSibling();\n \n-    RefPtr<DocumentFragment> fragment = createFragmentFromSource(html, parent.get(), ec);\n+    RefPtr<DocumentFragment> fragment = createFragmentForInnerOuterHTML(html, parent.get(), ec);\n     if (ec)\n         return;\n       \n@@ -576,19 +575,13 @@ static Element* contextElementForInsertion(const String& where, Element* element\n \n void HTMLElement::insertAdjacentHTML(const String& where, const String& markup, ExceptionCode& ec)\n {\n-    RefPtr<DocumentFragment> fragment = document()->createDocumentFragment();\n     Element* contextElement = contextElementForInsertion(where, this, ec);\n     if (!contextElement)\n         return;\n-\n-    if (document()->isHTMLDocument())\n-         fragment->parseHTML(markup, contextElement);\n-    else {\n-        if (!fragment->parseXML(markup, contextElement))\n-            // FIXME: We should propagate a syntax error exception out here.\n-            return;\n-    }\n-\n+    ExceptionCode ignoredEc = 0; // FIXME: We should propagate a syntax error exception out here.\n+    RefPtr<DocumentFragment> fragment = createFragmentForInnerOuterHTML(markup, this, ignoredEc);\n+    if (ignoredEc)\n+        return;\n     insertAdjacent(where, fragment.get(), ec);\n }\n ""}<_**next**_>{""sha"": ""ba0d8c86c558c8fa8e253ee961b008bd0653e250"", ""filename"": ""third_party/WebKit/Source/WebCore/inspector/DOMPatchSupport.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/inspector/DOMPatchSupport.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/inspector/DOMPatchSupport.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/inspector/DOMPatchSupport.cpp?ref=73edae623529f04c668268de49d00324b96166a2"", ""patch"": ""@@ -114,6 +114,7 @@ Node* DOMPatchSupport::patchNode(Node* node, const String& markup, ExceptionCode\n     }\n \n     Node* previousSibling = node->previousSibling();\n+    // FIXME: This code should use one of createFragment* in markup.h\n     RefPtr<DocumentFragment> fragment = DocumentFragment::create(m_document);\n     fragment->parseHTML(markup, node->parentElement() ? node->parentElement() : m_document->documentElement());\n ""}<_**next**_>{""sha"": ""c5c84e7f603da3200da547b11dbe0a48fba9ab2b"", ""filename"": ""third_party/WebKit/Source/WebCore/xml/XSLTProcessor.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 27, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/xml/XSLTProcessor.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebCore/xml/XSLTProcessor.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/xml/XSLTProcessor.cpp?ref=73edae623529f04c668268de49d00324b96166a2"", ""patch"": ""@@ -107,32 +107,6 @@ PassRefPtr<Document> XSLTProcessor::createDocumentFromSource(const String& sourc\n     return result.release();\n }\n \n-static inline RefPtr<DocumentFragment> createFragmentFromSource(const String& sourceString, const String& sourceMIMEType, Document* outputDoc)\n-{\n-    RefPtr<DocumentFragment> fragment = outputDoc->createDocumentFragment();\n-\n-    if (sourceMIMEType == \""text/html\"") {\n-        // As far as I can tell, there isn't a spec for how transformToFragment\n-        // is supposed to work.  Based on the documentation I can find, it looks\n-        // like we want to start parsing the fragment in the InBody insertion\n-        // mode.  Unfortunately, that's an implementation detail of the parser.\n-        // We achieve that effect here by passing in a fake body element as\n-        // context for the fragment.\n-        RefPtr<HTMLBodyElement> fakeBody = HTMLBodyElement::create(outputDoc);\n-        fragment->parseHTML(sourceString, fakeBody.get());\n-    } else if (sourceMIMEType == \""text/plain\"")\n-        fragment->parserAddChild(Text::create(outputDoc, sourceString));\n-    else {\n-        bool successfulParse = fragment->parseXML(sourceString, 0);\n-        if (!successfulParse)\n-            return 0;\n-    }\n-\n-    // FIXME: Do we need to mess with URLs here?\n-\n-    return fragment;\n-}\n-\n PassRefPtr<Document> XSLTProcessor::transformToDocument(Node* sourceNode)\n {\n     String resultMIMEType;\n@@ -155,7 +129,7 @@ PassRefPtr<DocumentFragment> XSLTProcessor::transformToFragment(Node* sourceNode\n \n     if (!transformToString(sourceNode, resultMIMEType, resultString, resultEncoding))\n         return 0;\n-    return createFragmentFromSource(resultString, resultMIMEType, outputDoc);\n+    return createFragmentForTransformToFragment(resultString, resultMIMEType, outputDoc);\n }\n \n void XSLTProcessor::setParameter(const String& /*namespaceURI*/, const String& localName, const String& value)""}<_**next**_>{""sha"": ""1d020e11c6b313a306c271bcd6f38f297695cefe"", ""filename"": ""third_party/WebKit/Source/WebKit/qt/Api/qwebelement.cpp"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 6, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebKit/qt/Api/qwebelement.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebKit/qt/Api/qwebelement.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebKit/qt/Api/qwebelement.cpp?ref=73edae623529f04c668268de49d00324b96166a2"", ""patch"": ""@@ -51,6 +51,7 @@\n #include \""ScriptState.h\""\n #include \""StaticNodeList.h\""\n #include \""StyleResolver.h\""\n+#include \""markup.h\""\n #include \""qwebframe.h\""\n #include \""qwebframe_p.h\""\n #if USE(JSC)\n@@ -1010,7 +1011,7 @@ void QWebElement::appendInside(const QString &markup)\n     if (!m_element->isHTMLElement())\n         return;\n \n-    RefPtr<DocumentFragment> fragment =  Range::createDocumentFragmentForElement(markup, toHTMLElement(m_element));\n+    RefPtr<DocumentFragment> fragment =  createContextualFragment(markup, toHTMLElement(m_element), AllowScriptingContent);\n \n     ExceptionCode exception = 0;\n     m_element->appendChild(fragment, exception);\n@@ -1055,7 +1056,7 @@ void QWebElement::prependInside(const QString &markup)\n     if (!m_element->isHTMLElement())\n         return;\n \n-    RefPtr<DocumentFragment> fragment =  Range::createDocumentFragmentForElement(markup, toHTMLElement(m_element));\n+    RefPtr<DocumentFragment> fragment =  createContextualFragment(markup, toHTMLElement(m_element), AllowScriptingContent);\n \n     ExceptionCode exception = 0;\n \n@@ -1107,7 +1108,7 @@ void QWebElement::prependOutside(const QString &markup)\n     if (!parent->isHTMLElement())\n         return;\n \n-    RefPtr<DocumentFragment> fragment = Range::createDocumentFragmentForElement(markup, toHTMLElement(parent));\n+    RefPtr<DocumentFragment> fragment = createContextualFragment(markup, toHTMLElement(parent), AllowScriptingContent);\n \n     ExceptionCode exception = 0;\n     parent->insertBefore(fragment, m_element, exception);\n@@ -1157,7 +1158,7 @@ void QWebElement::appendOutside(const QString &markup)\n     if (!parent->isHTMLElement())\n         return;\n \n-    RefPtr<DocumentFragment> fragment = Range::createDocumentFragmentForElement(markup, toHTMLElement(parent));\n+    RefPtr<DocumentFragment> fragment = createContextualFragment(markup, toHTMLElement(parent), AllowScriptingContent);\n \n     ExceptionCode exception = 0;\n     if (!m_element->nextSibling())\n@@ -1303,7 +1304,7 @@ void QWebElement::encloseContentsWith(const QString &markup)\n     if (!m_element->isHTMLElement())\n         return;\n \n-    RefPtr<DocumentFragment> fragment =  Range::createDocumentFragmentForElement(markup, toHTMLElement(m_element));\n+    RefPtr<DocumentFragment> fragment =  createContextualFragment(markup, toHTMLElement(m_element), AllowScriptingContent);\n \n     if (!fragment || !fragment->firstChild())\n         return;\n@@ -1378,7 +1379,7 @@ void QWebElement::encloseWith(const QString &markup)\n     if (!parent->isHTMLElement())\n         return;\n \n-    RefPtr<DocumentFragment> fragment = Range::createDocumentFragmentForElement(markup, toHTMLElement(parent));\n+    RefPtr<DocumentFragment> fragment = createContextualFragment(markup, toHTMLElement(parent), AllowScriptingContent);\n \n     if (!fragment || !fragment->firstChild())\n         return;""}<_**next**_>{""sha"": ""e1e50497a4bf2249beaf9d7ce36bb5bcfecf09b4"", ""filename"": ""third_party/WebKit/Source/WebKit/qt/ChangeLog"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebKit/qt/ChangeLog"", ""raw_url"": ""https://github.com/chromium/chromium/raw/73edae623529f04c668268de49d00324b96166a2/third_party/WebKit/Source/WebKit/qt/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebKit/qt/ChangeLog?ref=73edae623529f04c668268de49d00324b96166a2"", ""patch"": ""@@ -1,3 +1,21 @@\n+2012-05-24  Ryosuke Niwa  <rniwa@webkit.org>\n+\n+        There are too many poorly named functions to create a fragment from markup\n+        https://bugs.webkit.org/show_bug.cgi?id=87339\n+\n+        Reviewed by Eric Seidel.\n+\n+        Replace calls to Range::createDocumentFragmentForElement by calls to\n+        createContextualDocumentFragment.\n+\n+        * Api/qwebelement.cpp:\n+        (QWebElement::appendInside):\n+        (QWebElement::prependInside):\n+        (QWebElement::prependOutside):\n+        (QWebElement::appendOutside):\n+        (QWebElement::encloseContentsWith):\n+        (QWebElement::encloseWith):\n+\n 2012-05-24  Gabor Ballabas  <gaborb@inf.u-szeged.hu>\n \n         [Qt]  Fix Webkit1 + V8 build.""}","{/~/    ExceptionCode ignoredExceptionCode;/~/    RefPtr<Node> nextChild;/~/    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {/~/        nextChild = child->nextSibling();/~/        element->removeChild(child.get(), ignoredExceptionCode);/~/        ASSERT(!ignoredExceptionCode);/~/        fragment->insertBefore(child, element, ignoredExceptionCode);/~/        ASSERT(!ignoredExceptionCode);/~/    }/~/    fragment->removeChild(element, ignoredExceptionCode);/~/    ASSERT(!ignoredExceptionCode);/~/}","1,2,3,4,5,6,7,8,9,10,11,12,13","static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)
","static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)
{
    ExceptionCode ignoredExceptionCode;
    RefPtr<Node> nextChild;
    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {
        nextChild = child->nextSibling();
        element->removeChild(child.get(), ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
        fragment->insertBefore(child, element, ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
    }
    fragment->removeChild(element, ignoredExceptionCode);
    ASSERT(!ignoredExceptionCode);
}
",183893.0,C,,"{
    ExceptionCode ignoredExceptionCode;
    RefPtr<Node> nextChild;
    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {
        nextChild = child->nextSibling();
        element->removeChild(child.get(), ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
        fragment->insertBefore(child, element, ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
    }
    fragment->removeChild(element, ignoredExceptionCode);
    ASSERT(!ignoredExceptionCode);
}
",,"@@ -1111,57 +1111,6 @@ String Range::text() const
     return plainText(this);
 }
 
-static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)
-{
-    ExceptionCode ignoredExceptionCode;
-
-    RefPtr<Node> nextChild;
-    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {
-        nextChild = child->nextSibling();
-        element->removeChild(child.get(), ignoredExceptionCode);
-        ASSERT(!ignoredExceptionCode);
-        fragment->insertBefore(child, element, ignoredExceptionCode);
-        ASSERT(!ignoredExceptionCode);
-    }
-    fragment->removeChild(element, ignoredExceptionCode);
-    ASSERT(!ignoredExceptionCode);
-}
-
-PassRefPtr<DocumentFragment> Range::createDocumentFragmentForElement(const String& markup, Element* element,  FragmentScriptingPermission scriptingPermission)
-{
-    ASSERT(element);
-    HTMLElement* htmlElement = toHTMLElement(element);
-    if (htmlElement->ieForbidsInsertHTML())
-        return 0;
-
-    if (htmlElement->hasLocalName(colTag) || htmlElement->hasLocalName(colgroupTag) || htmlElement->hasLocalName(framesetTag)
-        || htmlElement->hasLocalName(headTag) || htmlElement->hasLocalName(styleTag) || htmlElement->hasLocalName(titleTag))
-        return 0;
-
-    RefPtr<DocumentFragment> fragment = element->document()->createDocumentFragment();
-
-    if (element->document()->isHTMLDocument())
-        fragment->parseHTML(markup, element, scriptingPermission);
-    else if (!fragment->parseXML(markup, element, scriptingPermission))
-        return 0; // FIXME: We should propagate a syntax error exception out here.
-
-    // We need to pop <html> and <body> elements and remove <head> to
-    // accommodate folks passing complete HTML documents to make the
-    // child of an element.
-
-    RefPtr<Node> nextNode;
-    for (RefPtr<Node> node = fragment->firstChild(); node; node = nextNode) {
-        nextNode = node->nextSibling();
-        if (node->hasTagName(htmlTag) || node->hasTagName(headTag) || node->hasTagName(bodyTag)) {
-            HTMLElement* element = toHTMLElement(node.get());
-            if (Node* firstChild = element->firstChild())
-                nextNode = firstChild;
-            removeElementPreservingChildren(fragment, element);
-        }
-    }
-    return fragment.release();
-}
-
 PassRefPtr<DocumentFragment> Range::createContextualFragment(const String& markup, ExceptionCode& ec)
 {
     if (!m_start.container()) {
@@ -1175,7 +1124,7 @@ PassRefPtr<DocumentFragment> Range::createContextualFragment(const String& marku
         return 0;
     }
 
-    RefPtr<DocumentFragment> fragment = createDocumentFragmentForElement(markup, toElement(element), AllowScriptingContentAndDoNotMarkAlreadyStarted);
+    RefPtr<DocumentFragment> fragment = WebCore::createContextualFragment(markup, toElement(element), AllowScriptingContentAndDoNotMarkAlreadyStarted);
 
     if (!fragment) {
         ec = NOT_SUPPORTED_ERR;","static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)
{
    ExceptionCode ignoredExceptionCode;
    RefPtr<Node> nextChild;
    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {
        nextChild = child->nextSibling();
        element->removeChild(child.get(), ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
        fragment->insertBefore(child, element, ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
    }
    fragment->removeChild(element, ignoredExceptionCode);
    ASSERT(!ignoredExceptionCode);
}
",Chrome,73edae623529f04c668268de49d00324b96166a2,11e6b7bcad1ce8daa8aa73ae5b185bc1e6608e70,1.0,"static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)
//flaw_line_below:
{
//flaw_line_below:
    ExceptionCode ignoredExceptionCode;
//flaw_line_below:

//flaw_line_below:
    RefPtr<Node> nextChild;
//flaw_line_below:
    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {
//flaw_line_below:
        nextChild = child->nextSibling();
//flaw_line_below:
        element->removeChild(child.get(), ignoredExceptionCode);
//flaw_line_below:
        ASSERT(!ignoredExceptionCode);
//flaw_line_below:
        fragment->insertBefore(child, element, ignoredExceptionCode);
//flaw_line_below:
        ASSERT(!ignoredExceptionCode);
//flaw_line_below:
    }
//flaw_line_below:
    fragment->removeChild(element, ignoredExceptionCode);
//flaw_line_below:
    ASSERT(!ignoredExceptionCode);
//flaw_line_below:
}
"
410,,,,,,,,,,,,,,,2010-03,,7.0,https://github.com/chromium/chromium/commit/ea3d1d84be3d6f97bf50e76511c9e26af6895533,ea3d1d84be3d6f97bf50e76511c9e26af6895533,"Fix passing pointers between processes.

BUG=31880
Review URL: http://codereview.chromium.org/558036

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@37555 0039d316-1c4b-4281-b951-d872f2087c98",12.0,webkit/glue/plugins/webplugin_delegate_impl.cc,"{""sha"": ""74de33f85ed2506f6309cec420c932b871c2ebe7"", ""filename"": ""chrome/common/plugin_messages.h"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 65, ""changes"": 74, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/common/plugin_messages.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/common/plugin_messages.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/plugin_messages.h?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -42,25 +42,14 @@ struct PluginMsg_Init_Params {\n };\n \n struct PluginHostMsg_URLRequest_Params {\n+  std::string url;\n   std::string method;\n-  bool is_javascript_url;\n   std::string target;\n   std::vector<char> buffer;\n-  bool is_file_data;\n-  bool notify;\n-  std::string url;\n-  intptr_t notify_data;\n+  int notify_id;\n   bool popups_allowed;\n };\n \n-struct PluginMsg_URLRequestReply_Params {\n-  unsigned long resource_id;\n-  GURL url;\n-  bool notify_needed;\n-  intptr_t notify_data;\n-  intptr_t stream;\n-};\n-\n struct PluginMsg_DidReceiveResponseParams {\n   unsigned long id;\n   std::string mime_type;\n@@ -163,84 +152,39 @@ template <>\n struct ParamTraits<PluginHostMsg_URLRequest_Params> {\n   typedef PluginHostMsg_URLRequest_Params param_type;\n   static void Write(Message* m, const param_type& p) {\n+    WriteParam(m, p.url);\n     WriteParam(m, p.method);\n-    WriteParam(m, p.is_javascript_url);\n     WriteParam(m, p.target);\n     WriteParam(m, p.buffer);\n-    WriteParam(m, p.is_file_data);\n-    WriteParam(m, p.notify);\n-    WriteParam(m, p.url);\n-    WriteParam(m, p.notify_data);\n+    WriteParam(m, p.notify_id);\n     WriteParam(m, p.popups_allowed);\n   }\n   static bool Read(const Message* m, void** iter, param_type* p) {\n     return\n+      ReadParam(m, iter, &p->url) &&\n       ReadParam(m, iter, &p->method) &&\n-      ReadParam(m, iter, &p->is_javascript_url) &&\n       ReadParam(m, iter, &p->target) &&\n       ReadParam(m, iter, &p->buffer) &&\n-      ReadParam(m, iter, &p->is_file_data) &&\n-      ReadParam(m, iter, &p->notify) &&\n-      ReadParam(m, iter, &p->url) &&\n-      ReadParam(m, iter, &p->notify_data) &&\n+      ReadParam(m, iter, &p->notify_id) &&\n       ReadParam(m, iter, &p->popups_allowed);\n   }\n   static void Log(const param_type& p, std::wstring* l) {\n     l->append(L\""(\"");\n-    LogParam(p.method, l);\n+    LogParam(p.url, l);\n     l->append(L\"", \"");\n-    LogParam(p.is_javascript_url, l);\n+    LogParam(p.method, l);\n     l->append(L\"", \"");\n     LogParam(p.target, l);\n     l->append(L\"", \"");\n     LogParam(p.buffer, l);\n     l->append(L\"", \"");\n-    LogParam(p.is_file_data, l);\n-    l->append(L\"", \"");\n-    LogParam(p.notify, l);\n-    l->append(L\"", \"");\n-    LogParam(p.url, l);\n-    l->append(L\"", \"");\n-    LogParam(p.notify_data, l);\n+    LogParam(p.notify_id, l);\n     l->append(L\"", \"");\n     LogParam(p.popups_allowed, l);\n     l->append(L\"")\"");\n   }\n };\n \n-template <>\n-struct ParamTraits<PluginMsg_URLRequestReply_Params> {\n-  typedef PluginMsg_URLRequestReply_Params param_type;\n-  static void Write(Message* m, const param_type& p) {\n-    WriteParam(m, p.resource_id);\n-    WriteParam(m, p.url);\n-    WriteParam(m, p.notify_needed);\n-    WriteParam(m, p.notify_data);\n-    WriteParam(m, p.stream);\n-  }\n-  static bool Read(const Message* m, void** iter, param_type* p) {\n-    return\n-      ReadParam(m, iter, &p->resource_id) &&\n-      ReadParam(m, iter, &p->url) &&\n-      ReadParam(m, iter, &p->notify_needed) &&\n-      ReadParam(m, iter, &p->notify_data) &&\n-      ReadParam(m, iter, &p->stream);\n-  }\n-  static void Log(const param_type& p, std::wstring* l) {\n-    l->append(L\""(\"");\n-    LogParam(p.resource_id, l);\n-    l->append(L\"", \"");\n-    LogParam(p.url, l);\n-    l->append(L\"", \"");\n-    LogParam(p.notify_needed, l);\n-    l->append(L\"", \"");\n-    LogParam(p.notify_data, l);\n-    l->append(L\"", \"");\n-    LogParam(p.stream, l);\n-    l->append(L\"")\"");\n-  }\n-};\n-\n template <>\n struct ParamTraits<PluginMsg_DidReceiveResponseParams> {\n   typedef PluginMsg_DidReceiveResponseParams param_type;""}<_**next**_>{""sha"": ""f65816c4de7fb55a99700db1e1d0140c3c9ff804"", ""filename"": ""chrome/common/plugin_messages_internal.h"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 22, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/common/plugin_messages_internal.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/common/plugin_messages_internal.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/plugin_messages_internal.h?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -202,14 +202,13 @@ IPC_BEGIN_MESSAGES(Plugin)\n                              base::SharedMemoryHandle /* shared_memory*/,\n                              size_t /* size */)\n \n-  IPC_SYNC_MESSAGE_ROUTED0_2(PluginMsg_GetPluginScriptableObject,\n-                             int /* route_id */,\n-                             intptr_t /* npobject_ptr */)\n+  IPC_SYNC_MESSAGE_ROUTED0_1(PluginMsg_GetPluginScriptableObject,\n+                             int /* route_id */)\n \n-  IPC_SYNC_MESSAGE_ROUTED3_0(PluginMsg_DidFinishLoadWithReason,\n-                             GURL /* url */,\n-                             int /* reason */,\n-                             intptr_t /* notify_data */)\n+  IPC_MESSAGE_ROUTED3(PluginMsg_DidFinishLoadWithReason,\n+                      GURL /* url */,\n+                      int /* reason */,\n+                      int /* notify_id */)\n \n   // Updates the plugin location.\n   IPC_MESSAGE_ROUTED1(PluginMsg_UpdateGeometry,\n@@ -244,12 +243,11 @@ IPC_BEGIN_MESSAGES(Plugin)\n   IPC_MESSAGE_ROUTED1(PluginMsg_DidFail,\n                       unsigned long /* id */)\n \n-  IPC_MESSAGE_ROUTED5(PluginMsg_SendJavaScriptStream,\n+  IPC_MESSAGE_ROUTED4(PluginMsg_SendJavaScriptStream,\n                       GURL /* url */,\n                       std::string /* result */,\n                       bool /* success */,\n-                      bool /* notify required */,\n-                      intptr_t /* notify data */)\n+                      int /* notify_id */)\n \n   IPC_MESSAGE_ROUTED2(PluginMsg_DidReceiveManualResponse,\n                       GURL /* url */,\n@@ -264,8 +262,14 @@ IPC_BEGIN_MESSAGES(Plugin)\n \n   IPC_MESSAGE_ROUTED0(PluginMsg_InstallMissingPlugin)\n \n-  IPC_SYNC_MESSAGE_ROUTED1_0(PluginMsg_HandleURLRequestReply,\n-                             PluginMsg_URLRequestReply_Params)\n+  IPC_MESSAGE_ROUTED3(PluginMsg_HandleURLRequestReply,\n+                      unsigned long /* resource_id */,\n+                      GURL /* url */,\n+                      int /* notify_id */)\n+\n+  IPC_MESSAGE_ROUTED2(PluginMsg_HTTPRangeRequestReply,\n+                      unsigned long /* resource_id */,\n+                      int /* range_request_id */)\n \n   IPC_SYNC_MESSAGE_ROUTED0_1(PluginMsg_CreateCommandBuffer,\n                              int /* route_id */)\n@@ -307,15 +311,13 @@ IPC_BEGIN_MESSAGES(PluginHost)\n   IPC_MESSAGE_ROUTED1(PluginHostMsg_InvalidateRect,\n                       gfx::Rect /* rect */)\n \n-  IPC_SYNC_MESSAGE_ROUTED1_2(PluginHostMsg_GetWindowScriptNPObject,\n+  IPC_SYNC_MESSAGE_ROUTED1_1(PluginHostMsg_GetWindowScriptNPObject,\n                              int /* route id */,\n-                             bool /* success */,\n-                             intptr_t /* npobject_ptr */)\n+                             bool /* success */)\n \n-  IPC_SYNC_MESSAGE_ROUTED1_2(PluginHostMsg_GetPluginElement,\n+  IPC_SYNC_MESSAGE_ROUTED1_1(PluginHostMsg_GetPluginElement,\n                              int /* route id */,\n-                             bool /* success */,\n-                             intptr_t /* npobject_ptr */)\n+                             bool /* success */)\n \n   IPC_MESSAGE_ROUTED3(PluginHostMsg_SetCookie,\n                       GURL /* url */,\n@@ -356,12 +358,10 @@ IPC_BEGIN_MESSAGES(PluginHost)\n \n   IPC_MESSAGE_ROUTED0(PluginHostMsg_CancelDocumentLoad)\n \n-  IPC_MESSAGE_ROUTED5(PluginHostMsg_InitiateHTTPRangeRequest,\n+  IPC_MESSAGE_ROUTED3(PluginHostMsg_InitiateHTTPRangeRequest,\n                       std::string /* url */,\n                       std::string /* range_info */,\n-                      intptr_t    /* existing_stream */,\n-                      bool        /* notify_needed */,\n-                      intptr_t    /* notify_data */)\n+                      int         /* range_request_id */)\n \n   IPC_MESSAGE_ROUTED2(PluginHostMsg_DeferResourceLoading,\n                       unsigned long /* resource_id */,""}<_**next**_>{""sha"": ""1764366072348c6603d4d2d31f0a77f03c8d81ea"", ""filename"": ""chrome/plugin/webplugin_delegate_stub.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 16, ""changes"": 33, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/plugin/webplugin_delegate_stub.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/plugin/webplugin_delegate_stub.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/plugin/webplugin_delegate_stub.cc?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -130,6 +130,8 @@ void WebPluginDelegateStub::OnMessageReceived(const IPC::Message& msg) {\n     IPC_MESSAGE_HANDLER(PluginMsg_InstallMissingPlugin, OnInstallMissingPlugin)\n     IPC_MESSAGE_HANDLER(PluginMsg_HandleURLRequestReply,\n                         OnHandleURLRequestReply)\n+    IPC_MESSAGE_HANDLER(PluginMsg_HTTPRangeRequestReply,\n+                        OnHTTPRangeRequestReply)\n     IPC_MESSAGE_HANDLER(PluginMsg_CreateCommandBuffer,\n                         OnCreateCommandBuffer)\n     IPC_MESSAGE_UNHANDLED_ERROR()\n@@ -237,8 +239,8 @@ void WebPluginDelegateStub::OnDidFail(int id) {\n }\n \n void WebPluginDelegateStub::OnDidFinishLoadWithReason(\n-    const GURL& url, int reason, intptr_t notify_data) {\n-  delegate_->DidFinishLoadWithReason(url, reason, notify_data);\n+    const GURL& url, int reason, int notify_id) {\n+  delegate_->DidFinishLoadWithReason(url, reason, notify_id);\n }\n \n void WebPluginDelegateStub::OnSetFocus() {\n@@ -304,17 +306,14 @@ void WebPluginDelegateStub::OnUpdateGeometry(\n       );\n }\n \n-void WebPluginDelegateStub::OnGetPluginScriptableObject(\n-    int* route_id,\n-    intptr_t* npobject_ptr) {\n+void WebPluginDelegateStub::OnGetPluginScriptableObject(int* route_id) {\n   NPObject* object = delegate_->GetPluginScriptableObject();\n   if (!object) {\n     *route_id = MSG_ROUTING_NONE;\n     return;\n   }\n \n   *route_id = channel_->GenerateRouteID();\n-  *npobject_ptr = reinterpret_cast<intptr_t>(object);\n   // The stub will delete itself when the proxy tells it that it's released, or\n   // otherwise when the channel is closed.\n   new NPObjectStub(\n@@ -328,10 +327,8 @@ void WebPluginDelegateStub::OnGetPluginScriptableObject(\n void WebPluginDelegateStub::OnSendJavaScriptStream(const GURL& url,\n                                                    const std::string& result,\n                                                    bool success,\n-                                                   bool notify_needed,\n-                                                   intptr_t notify_data) {\n-  delegate_->SendJavaScriptStream(url, result, success, notify_needed,\n-                                  notify_data);\n+                                                   int notify_id) {\n+  delegate_->SendJavaScriptStream(url, result, success, notify_id);\n }\n \n void WebPluginDelegateStub::OnDidReceiveManualResponse(\n@@ -404,11 +401,15 @@ void WebPluginDelegateStub::CreateSharedBuffer(\n }\n \n void WebPluginDelegateStub::OnHandleURLRequestReply(\n-    const PluginMsg_URLRequestReply_Params& params) {\n+    unsigned long resource_id, const GURL& url, int notify_id) {\n   WebPluginResourceClient* resource_client =\n-      delegate_->CreateResourceClient(params.resource_id, params.url,\n-                                      params.notify_needed,\n-                                      params.notify_data,\n-                                      params.stream);\n-  webplugin_->OnResourceCreated(params.resource_id, resource_client);\n+      delegate_->CreateResourceClient(resource_id, url, notify_id);\n+  webplugin_->OnResourceCreated(resource_id, resource_client);\n+}\n+\n+void WebPluginDelegateStub::OnHTTPRangeRequestReply(\n+    unsigned long resource_id, int range_request_id) {\n+  WebPluginResourceClient* resource_client =\n+      delegate_->CreateSeekableResourceClient(resource_id, range_request_id);\n+  webplugin_->OnResourceCreated(resource_id, resource_client);\n }""}<_**next**_>{""sha"": ""ddc863272ae09485bdc48f364c4250d798b1b967"", ""filename"": ""chrome/plugin/webplugin_delegate_stub.h"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 17, ""changes"": 25, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/plugin/webplugin_delegate_stub.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/plugin/webplugin_delegate_stub.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/plugin/webplugin_delegate_stub.h?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -24,7 +24,6 @@ class WebPluginProxy;\n struct PluginMsg_Init_Params;\n struct PluginMsg_DidReceiveResponseParams;\n struct PluginMsg_UpdateGeometry_Param;\n-struct PluginMsg_URLRequestReply_Params;\n class WebCursor;\n \n namespace WebKit {\n@@ -59,45 +58,37 @@ class WebPluginDelegateStub : public IPC::Channel::Listener,\n   // Message handlers for the WebPluginDelegate calls that are proxied from the\n   // renderer over the IPC channel.\n   void OnInit(const PluginMsg_Init_Params& params, bool* result);\n-\n   void OnWillSendRequest(int id, const GURL& url);\n   void OnDidReceiveResponse(const PluginMsg_DidReceiveResponseParams& params);\n   void OnDidReceiveData(int id, const std::vector<char>& buffer,\n                         int data_offset);\n   void OnDidFinishLoading(int id);\n   void OnDidFail(int id);\n-\n-  void OnDidFinishLoadWithReason(const GURL& url, int reason,\n-                                 intptr_t notify_data);\n+  void OnDidFinishLoadWithReason(const GURL& url, int reason, int notify_id);\n   void OnSetFocus();\n   void OnHandleInputEvent(const WebKit::WebInputEvent* event,\n                           bool* handled, WebCursor* cursor);\n-\n   void OnPaint(const gfx::Rect& damaged_rect);\n   void OnDidPaint();\n-\n   void OnPrint(base::SharedMemoryHandle* shared_memory, size_t* size);\n-\n   void OnUpdateGeometry(const PluginMsg_UpdateGeometry_Param& param);\n-  void OnGetPluginScriptableObject(int* route_id, intptr_t* npobject_ptr);\n+  void OnGetPluginScriptableObject(int* route_id);\n   void OnSendJavaScriptStream(const GURL& url,\n                               const std::string& result,\n-                              bool success, bool notify_needed,\n-                              intptr_t notify_data);\n-\n+                              bool success,\n+                              int notify_id);\n   void OnDidReceiveManualResponse(\n       const GURL& url,\n       const PluginMsg_DidReceiveResponseParams& params);\n   void OnDidReceiveManualData(const std::vector<char>& buffer);\n   void OnDidFinishManualLoading();\n   void OnDidManualLoadFail();\n   void OnInstallMissingPlugin();\n-\n-  void OnHandleURLRequestReply(\n-      const PluginMsg_URLRequestReply_Params& params);\n-\n+  void OnHandleURLRequestReply(unsigned long resource_id,\n+                               const GURL& url,\n+                               int notify_id);\n+  void OnHTTPRangeRequestReply(unsigned long resource_id, int range_request_id);\n   void OnCreateCommandBuffer(int* route_id);\n-\n   void CreateSharedBuffer(size_t size,\n                           base::SharedMemory* shared_buf,\n                           base::SharedMemoryHandle* remote_handle);""}<_**next**_>{""sha"": ""a05113b1051cee88a65635578c19405011442f54"", ""filename"": ""chrome/plugin/webplugin_proxy.cc"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 41, ""changes"": 59, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/plugin/webplugin_proxy.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/plugin/webplugin_proxy.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/plugin/webplugin_proxy.cc?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -26,7 +26,6 @@\n #include \""chrome/plugin/npobject_util.h\""\n #include \""chrome/plugin/plugin_channel.h\""\n #include \""chrome/plugin/plugin_thread.h\""\n-#include \""chrome/plugin/webplugin_delegate_stub.h\""\n #include \""skia/ext/platform_device.h\""\n #include \""third_party/WebKit/WebKit/chromium/public/WebBindings.h\""\n #include \""webkit/glue/plugins/webplugin_delegate_impl.h\""\n@@ -151,9 +150,8 @@ NPObject* WebPluginProxy::GetWindowScriptNPObject() {\n \n   int npobject_route_id = channel_->GenerateRouteID();\n   bool success = false;\n-  intptr_t npobject_ptr = NULL;\n   Send(new PluginHostMsg_GetWindowScriptNPObject(\n-      route_id_, npobject_route_id, &success, &npobject_ptr));\n+      route_id_, npobject_route_id, &success));\n   if (!success)\n     return NULL;\n \n@@ -169,9 +167,7 @@ NPObject* WebPluginProxy::GetPluginElement() {\n \n   int npobject_route_id = channel_->GenerateRouteID();\n   bool success = false;\n-  intptr_t npobject_ptr = NULL;\n-  Send(new PluginHostMsg_GetPluginElement(\n-      route_id_, npobject_route_id, &success, &npobject_ptr));\n+  Send(new PluginHostMsg_GetPluginElement(route_id_, npobject_route_id, &success));\n   if (!success)\n     return NULL;\n \n@@ -254,31 +250,20 @@ void WebPluginProxy::DidPaint() {\n     InvalidateRect(damaged_rect_);\n }\n \n-void WebPluginProxy::OnResourceCreated(int resource_id, HANDLE cookie) {\n-  WebPluginResourceClient* resource_client =\n-      reinterpret_cast<WebPluginResourceClient*>(cookie);\n-  if (!resource_client) {\n-    NOTREACHED();\n-    return;\n-  }\n-\n+void WebPluginProxy::OnResourceCreated(int resource_id,\n+                                       WebPluginResourceClient* client) {\n   DCHECK(resource_clients_.find(resource_id) == resource_clients_.end());\n-  resource_clients_[resource_id] = resource_client;\n+  resource_clients_[resource_id] = client;\n }\n \n-void WebPluginProxy::HandleURLRequest(const char *method,\n-                                      bool is_javascript_url,\n-                                      const char* target, unsigned int len,\n-                                      const char* buf, bool is_file_data,\n-                                      bool notify, const char* url,\n-                                      intptr_t notify_data,\n+void WebPluginProxy::HandleURLRequest(const char* url,\n+                                      const char *method,\n+                                      const char* target,\n+                                      const char* buf,\n+                                      unsigned int len,\n+                                      int notify_id,\n                                       bool popups_allowed) {\n-  if (!url) {\n-    NOTREACHED();\n-    return;\n-  }\n-\n-  if (!target && (0 == base::strcasecmp(method, \""GET\""))) {\n+ if (!target && (0 == base::strcasecmp(method, \""GET\""))) {\n     // Please refer to https://bugzilla.mozilla.org/show_bug.cgi?id=366082\n     // for more details on this.\n     if (delegate_->GetQuirks() &\n@@ -293,8 +278,8 @@ void WebPluginProxy::HandleURLRequest(const char *method,\n   }\n \n   PluginHostMsg_URLRequest_Params params;\n+  params.url = url;\n   params.method = method;\n-  params.is_javascript_url = is_javascript_url;\n   if (target)\n     params.target = std::string(target);\n \n@@ -303,10 +288,7 @@ void WebPluginProxy::HandleURLRequest(const char *method,\n     memcpy(&params.buffer.front(), buf, len);\n   }\n \n-  params.is_file_data = is_file_data;\n-  params.notify = notify;\n-  params.url = url;\n-  params.notify_data = notify_data;\n+  params.notify_id = notify_id;\n   params.popups_allowed = popups_allowed;\n \n   Send(new PluginHostMsg_URLRequest(route_id_, params));\n@@ -567,15 +549,10 @@ void WebPluginProxy::CancelDocumentLoad() {\n   Send(new PluginHostMsg_CancelDocumentLoad(route_id_));\n }\n \n-void WebPluginProxy::InitiateHTTPRangeRequest(const char* url,\n-                                              const char* range_info,\n-                                              intptr_t existing_stream,\n-                                              bool notify_needed,\n-                                              intptr_t notify_data) {\n-\n-  Send(new PluginHostMsg_InitiateHTTPRangeRequest(route_id_, url,\n-                                                  range_info, existing_stream,\n-                                                  notify_needed, notify_data));\n+void WebPluginProxy::InitiateHTTPRangeRequest(\n+    const char* url, const char* range_info, int range_request_id) {\n+  Send(new PluginHostMsg_InitiateHTTPRangeRequest(\n+      route_id_, url, range_info, range_request_id));\n }\n \n void WebPluginProxy::SetDeferResourceLoading(unsigned long resource_id,""}<_**next**_>{""sha"": ""5fc699c31ed1a9dab14293f52732b3be4fdfced1"", ""filename"": ""chrome/plugin/webplugin_proxy.h"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 22, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/plugin/webplugin_proxy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/plugin/webplugin_proxy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/plugin/webplugin_proxy.h?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -103,17 +103,17 @@ class WebPluginProxy : public webkit_glue::WebPlugin {\n   // Callback from the renderer to let us know that a paint occurred.\n   void DidPaint();\n \n-  // Notification received on a plugin issued resource request\n-  // creation.\n-  void OnResourceCreated(int resource_id, HANDLE cookie);\n-\n-  void HandleURLRequest(const char *method,\n-                        bool is_javascript_url,\n-                        const char* target, unsigned int len,\n-                        const char* buf, bool is_file_data,\n-                        bool notify, const char* url,\n-                        intptr_t notify_data, bool popups_allowed);\n-\n+  // Notification received on a plugin issued resource request creation.\n+  void OnResourceCreated(int resource_id,\n+                         webkit_glue::WebPluginResourceClient* client);\n+\n+  void HandleURLRequest(const char* url,\n+                        const char *method,\n+                        const char* target,\n+                        const char* buf,\n+                        unsigned int len,\n+                        int notify_id,\n+                        bool popups_allowed);\n   void UpdateGeometry(const gfx::Rect& window_rect,\n                       const gfx::Rect& clip_rect,\n                       const TransportDIB::Handle& windowless_buffer,\n@@ -123,22 +123,13 @@ class WebPluginProxy : public webkit_glue::WebPlugin {\n                       int ack_key\n #endif\n                       );\n-\n   void CancelDocumentLoad();\n-\n-  void InitiateHTTPRangeRequest(const char* url,\n-                                const char* range_info,\n-                                intptr_t existing_stream,\n-                                bool notify_needed,\n-                                intptr_t notify_data);\n-\n+  void InitiateHTTPRangeRequest(\n+      const char* url, const char* range_info, int range_request_id);\n   void SetDeferResourceLoading(unsigned long resource_id, bool defer);\n-\n   bool IsOffTheRecord();\n-\n   void ResourceClientDeleted(\n       webkit_glue::WebPluginResourceClient* resource_client);\n-\n   gfx::NativeViewId containing_window() { return containing_window_; }\n \n  private:""}<_**next**_>{""sha"": ""b9b61fe98ebfcfec92c2cd5f4a66e3943fa8793c"", ""filename"": ""chrome/renderer/webplugin_delegate_pepper.cc"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 24, ""changes"": 34, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/renderer/webplugin_delegate_pepper.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/renderer/webplugin_delegate_pepper.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/webplugin_delegate_pepper.cc?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -173,11 +173,8 @@ NPObject* WebPluginDelegatePepper::GetPluginScriptableObject() {\n }\n \n void WebPluginDelegatePepper::DidFinishLoadWithReason(\n-    const GURL& url,\n-    NPReason reason,\n-    intptr_t notify_data) {\n-  instance()->DidFinishLoadWithReason(\n-      url, reason, reinterpret_cast<void*>(notify_data));\n+    const GURL& url, NPReason reason, int notify_id) {\n+  instance()->DidFinishLoadWithReason(url, reason, notify_id);\n }\n \n int WebPluginDelegatePepper::GetProcessId() {\n@@ -189,10 +186,8 @@ void WebPluginDelegatePepper::SendJavaScriptStream(\n     const GURL& url,\n     const std::string& result,\n     bool success,\n-    bool notify_needed,\n-    intptr_t notify_data) {\n-  instance()->SendJavaScriptStream(url, result, success, notify_needed,\n-                                   notify_data);\n+    int notify_id) {\n+  instance()->SendJavaScriptStream(url, result, success, notify_id);\n }\n \n void WebPluginDelegatePepper::DidReceiveManualResponse(\n@@ -220,22 +215,13 @@ FilePath WebPluginDelegatePepper::GetPluginPath() {\n }\n \n WebPluginResourceClient* WebPluginDelegatePepper::CreateResourceClient(\n-    unsigned long resource_id, const GURL& url, bool notify_needed,\n-    intptr_t notify_data, intptr_t existing_stream) {\n-  // Stream already exists. This typically happens for range requests\n-  // initiated via NPN_RequestRead.\n-  if (existing_stream) {\n-    NPAPI::PluginStream* plugin_stream =\n-        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);\n-\n-    return plugin_stream->AsResourceClient();\n-  }\n+    unsigned long resource_id, const GURL& url, int notify_id) {\n+  return instance()->CreateStream(resource_id, url, std::string(), notify_id);\n+}\n \n-  std::string mime_type;\n-  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(\n-      resource_id, url, mime_type, notify_needed,\n-      reinterpret_cast<void*>(notify_data));\n-  return stream;\n+WebPluginResourceClient* WebPluginDelegatePepper::CreateSeekableResourceClient(\n+    unsigned long resource_id, int range_request_id) {\n+  return instance()->GetRangeRequest(range_request_id);\n }\n \n NPError WebPluginDelegatePepper::Device2DQueryCapability(int32 capability,""}<_**next**_>{""sha"": ""b316789866c9a3155d4aa5ebce7e06d5f672f921"", ""filename"": ""chrome/renderer/webplugin_delegate_pepper.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 8, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/renderer/webplugin_delegate_pepper.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/renderer/webplugin_delegate_pepper.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/webplugin_delegate_pepper.h?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -53,12 +53,12 @@ class WebPluginDelegatePepper : public webkit_glue::WebPluginDelegate {\n                                 WebKit::WebCursorInfo* cursor);\n   virtual NPObject* GetPluginScriptableObject();\n   virtual void DidFinishLoadWithReason(const GURL& url, NPReason reason,\n-                                       intptr_t notify_data);\n+                                       int notify_id);\n   virtual int GetProcessId();\n   virtual void SendJavaScriptStream(const GURL& url,\n                                     const std::string& result,\n-                                    bool success, bool notify_needed,\n-                                    intptr_t notify_data);\n+                                    bool success,\n+                                    int notify_id);\n   virtual void DidReceiveManualResponse(const GURL& url,\n                                         const std::string& mime_type,\n                                         const std::string& headers,\n@@ -69,11 +69,9 @@ class WebPluginDelegatePepper : public webkit_glue::WebPluginDelegate {\n   virtual void DidManualLoadFail();\n   virtual void InstallMissingPlugin();\n   virtual webkit_glue::WebPluginResourceClient* CreateResourceClient(\n-      unsigned long resource_id,\n-      const GURL& url,\n-      bool notify_needed,\n-      intptr_t notify_data,\n-      intptr_t stream);\n+      unsigned long resource_id, const GURL& url, int notify_id);\n+  virtual webkit_glue::WebPluginResourceClient* CreateSeekableResourceClient(\n+      unsigned long resource_id, int range_request_id);\n \n   // WebPlugin2DDeviceDelegate implementation.\n   virtual NPError Device2DQueryCapability(int32 capability, int32* value);""}<_**next**_>{""sha"": ""83666d516735f6b418e7fbbe3f0c08abe8f213d3"", ""filename"": ""chrome/renderer/webplugin_delegate_proxy.cc"", ""status"": ""modified"", ""additions"": 41, ""deletions"": 51, ""changes"": 92, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/renderer/webplugin_delegate_proxy.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/renderer/webplugin_delegate_proxy.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/webplugin_delegate_proxy.cc?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -66,31 +66,24 @@ class ResourceClientProxy : public webkit_glue::WebPluginResourceClient {\n  public:\n   ResourceClientProxy(PluginChannelHost* channel, int instance_id)\n     : channel_(channel), instance_id_(instance_id), resource_id_(0),\n-      notify_needed_(false), notify_data_(0),\n       multibyte_response_expected_(false) {\n   }\n \n   ~ResourceClientProxy() {\n   }\n \n-  void Initialize(unsigned long resource_id, const GURL& url,\n-                  bool notify_needed, intptr_t notify_data,\n-                  intptr_t existing_stream) {\n+  void Initialize(unsigned long resource_id, const GURL& url, int notify_id) {\n     resource_id_ = resource_id;\n-    url_ = url;\n-    notify_needed_ = notify_needed;\n-    notify_data_ = notify_data;\n-\n-    PluginMsg_URLRequestReply_Params params;\n-    params.resource_id = resource_id;\n-    params.url = url_;\n-    params.notify_needed = notify_needed_;\n-    params.notify_data = notify_data_;\n-    params.stream = existing_stream;\n-\n-    multibyte_response_expected_ = (existing_stream != 0);\n+    channel_->Send(new PluginMsg_HandleURLRequestReply(\n+        instance_id_, resource_id, url, notify_id));\n+  }\n \n-    channel_->Send(new PluginMsg_HandleURLRequestReply(instance_id_, params));\n+  void InitializeForSeekableStream(unsigned long resource_id,\n+                                   int range_request_id) {\n+    resource_id_ = resource_id;\n+    multibyte_response_expected_ = true;\n+    channel_->Send(new PluginMsg_HTTPRangeRequestReply(\n+        instance_id_, resource_id, range_request_id));\n   }\n \n   // PluginResourceClient implementation:\n@@ -154,9 +147,6 @@ class ResourceClientProxy : public webkit_glue::WebPluginResourceClient {\n   scoped_refptr<PluginChannelHost> channel_;\n   int instance_id_;\n   unsigned long resource_id_;\n-  GURL url_;\n-  bool notify_needed_;\n-  intptr_t notify_data_;\n   // Set to true if the response expected is a multibyte response.\n   // For e.g. response for a HTTP byte range request.\n   bool multibyte_response_expected_;\n@@ -314,13 +304,9 @@ bool WebPluginDelegateProxy::Send(IPC::Message* msg) {\n void WebPluginDelegateProxy::SendJavaScriptStream(const GURL& url,\n                                                   const std::string& result,\n                                                   bool success,\n-                                                  bool notify_needed,\n-                                                  intptr_t notify_data) {\n-  PluginMsg_SendJavaScriptStream* msg =\n-      new PluginMsg_SendJavaScriptStream(instance_id_, url, result,\n-                                         success, notify_needed,\n-                                         notify_data);\n-  Send(msg);\n+                                                  int notify_id) {\n+  Send(new PluginMsg_SendJavaScriptStream(\n+      instance_id_, url, result, success, notify_id));\n }\n \n void WebPluginDelegateProxy::DidReceiveManualResponse(\n@@ -823,9 +809,7 @@ NPObject* WebPluginDelegateProxy::GetPluginScriptableObject() {\n     return WebBindings::retainObject(npobject_);\n \n   int route_id = MSG_ROUTING_NONE;\n-  intptr_t npobject_ptr;\n-  Send(new PluginMsg_GetPluginScriptableObject(\n-      instance_id_, &route_id, &npobject_ptr));\n+  Send(new PluginMsg_GetPluginScriptableObject(instance_id_, &route_id));\n   if (route_id == MSG_ROUTING_NONE)\n     return NULL;\n \n@@ -836,9 +820,9 @@ NPObject* WebPluginDelegateProxy::GetPluginScriptableObject() {\n }\n \n void WebPluginDelegateProxy::DidFinishLoadWithReason(\n-    const GURL& url, NPReason reason, intptr_t notify_data) {\n+    const GURL& url, NPReason reason, int notify_id) {\n   Send(new PluginMsg_DidFinishLoadWithReason(\n-      instance_id_, url, reason, notify_data));\n+      instance_id_, url, reason, notify_id));\n }\n \n void WebPluginDelegateProxy::SetFocus() {\n@@ -909,7 +893,7 @@ void WebPluginDelegateProxy::OnInvalidateRect(const gfx::Rect& rect) {\n }\n \n void WebPluginDelegateProxy::OnGetWindowScriptNPObject(\n-    int route_id, bool* success, intptr_t* npobject_ptr) {\n+    int route_id, bool* success) {\n   *success = false;\n   NPObject* npobject = NULL;\n   if (plugin_)\n@@ -923,11 +907,9 @@ void WebPluginDelegateProxy::OnGetWindowScriptNPObject(\n   window_script_object_ = (new NPObjectStub(\n       npobject, channel_host_.get(), route_id, 0, page_url_))->AsWeakPtr();\n   *success = true;\n-  *npobject_ptr = reinterpret_cast<intptr_t>(npobject);\n }\n \n-void WebPluginDelegateProxy::OnGetPluginElement(\n-    int route_id, bool* success, intptr_t* npobject_ptr) {\n+void WebPluginDelegateProxy::OnGetPluginElement(int route_id, bool* success) {\n   *success = false;\n   NPObject* npobject = NULL;\n   if (plugin_)\n@@ -940,7 +922,6 @@ void WebPluginDelegateProxy::OnGetPluginElement(\n   new NPObjectStub(\n       npobject, channel_host_.get(), route_id, 0, page_url_);\n   *success = true;\n-  *npobject_ptr = reinterpret_cast<intptr_t>(npobject);\n }\n \n void WebPluginDelegateProxy::OnSetCookie(const GURL& url,\n@@ -1155,24 +1136,33 @@ void WebPluginDelegateProxy::OnHandleURLRequest(\n   if (params.target.length())\n     target = params.target.c_str();\n \n-  plugin_->HandleURLRequest(params.method.c_str(),\n-                            params.is_javascript_url, target,\n-                            static_cast<unsigned int>(params.buffer.size()),\n-                            data, params.is_file_data, params.notify,\n-                            params.url.c_str(), params.notify_data,\n-                            params.popups_allowed);\n+  plugin_->HandleURLRequest(\n+      params.url.c_str(), params.method.c_str(), target, data,\n+      static_cast<unsigned int>(params.buffer.size()), params.notify_id,\n+      params.popups_allowed);\n }\n \n webkit_glue::WebPluginResourceClient*\n WebPluginDelegateProxy::CreateResourceClient(\n-    unsigned long resource_id, const GURL& url, bool notify_needed,\n-    intptr_t notify_data, intptr_t npstream) {\n+    unsigned long resource_id, const GURL& url, int notify_id) {\n+  if (!channel_host_)\n+    return NULL;\n+\n+  ResourceClientProxy* proxy = new ResourceClientProxy(channel_host_,\n+                                                       instance_id_);\n+  proxy->Initialize(resource_id, url, notify_id);\n+  return proxy;\n+}\n+\n+webkit_glue::WebPluginResourceClient*\n+WebPluginDelegateProxy::CreateSeekableResourceClient(\n+    unsigned long resource_id, int range_request_id) {\n   if (!channel_host_)\n     return NULL;\n \n   ResourceClientProxy* proxy = new ResourceClientProxy(channel_host_,\n                                                        instance_id_);\n-  proxy->Initialize(resource_id, url, notify_needed, notify_data, npstream);\n+  proxy->InitializeForSeekableStream(resource_id, range_request_id);\n   return proxy;\n }\n \n@@ -1195,11 +1185,11 @@ void WebPluginDelegateProxy::OnCancelDocumentLoad() {\n }\n \n void WebPluginDelegateProxy::OnInitiateHTTPRangeRequest(\n-    const std::string& url, const std::string& range_info,\n-    intptr_t existing_stream, bool notify_needed, intptr_t notify_data) {\n-  plugin_->InitiateHTTPRangeRequest(url.c_str(), range_info.c_str(),\n-                                    existing_stream, notify_needed,\n-                                    notify_data);\n+    const std::string& url,\n+    const std::string& range_info,\n+    int range_request_id) {\n+  plugin_->InitiateHTTPRangeRequest(\n+      url.c_str(), range_info.c_str(), range_request_id);\n }\n \n void WebPluginDelegateProxy::OnDeferResourceLoading(unsigned long resource_id,""}<_**next**_>{""sha"": ""510f9772123ecb860b4be6d4e9950c071b784f68"", ""filename"": ""chrome/renderer/webplugin_delegate_proxy.h"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 14, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/renderer/webplugin_delegate_proxy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/chrome/renderer/webplugin_delegate_proxy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/webplugin_delegate_proxy.h?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -65,7 +65,7 @@ class WebPluginDelegateProxy\n   virtual void Print(gfx::NativeDrawingContext context);\n   virtual NPObject* GetPluginScriptableObject();\n   virtual void DidFinishLoadWithReason(const GURL& url, NPReason reason,\n-                                       intptr_t notify_data);\n+                                       int notify_id);\n   virtual void SetFocus();\n   virtual bool HandleInputEvent(const WebKit::WebInputEvent& event,\n                                 WebKit::WebCursorInfo* cursor);\n@@ -80,8 +80,8 @@ class WebPluginDelegateProxy\n \n   virtual void SendJavaScriptStream(const GURL& url,\n                                     const std::string& result,\n-                                    bool success, bool notify_needed,\n-                                    intptr_t notify_data);\n+                                    bool success,\n+                                    int notify_id);\n \n   virtual void DidReceiveManualResponse(const GURL& url,\n                                         const std::string& mime_type,\n@@ -93,11 +93,9 @@ class WebPluginDelegateProxy\n   virtual void DidManualLoadFail();\n   virtual void InstallMissingPlugin();\n   virtual webkit_glue::WebPluginResourceClient* CreateResourceClient(\n-      unsigned long resource_id,\n-      const GURL& url,\n-      bool notify_needed,\n-      intptr_t notify_data,\n-      intptr_t existing_stream);\n+      unsigned long resource_id, const GURL& url, int notify_id);\n+  virtual webkit_glue::WebPluginResourceClient* CreateSeekableResourceClient(\n+      unsigned long resource_id, int range_request_id);\n \n   CommandBufferProxy* CreateCommandBuffer();\n \n@@ -117,9 +115,8 @@ class WebPluginDelegateProxy\n   void OnHandleURLRequest(const PluginHostMsg_URLRequest_Params& params);\n   void OnCancelResource(int id);\n   void OnInvalidateRect(const gfx::Rect& rect);\n-  void OnGetWindowScriptNPObject(int route_id, bool* success,\n-                                 intptr_t* npobject_ptr);\n-  void OnGetPluginElement(int route_id, bool* success, intptr_t* npobject_ptr);\n+  void OnGetWindowScriptNPObject(int route_id, bool* success);\n+  void OnGetPluginElement(int route_id, bool* success);\n   void OnSetCookie(const GURL& url,\n                    const GURL& first_party_for_cookies,\n                    const std::string& cookie);\n@@ -137,9 +134,7 @@ class WebPluginDelegateProxy\n   void OnCancelDocumentLoad();\n   void OnInitiateHTTPRangeRequest(const std::string& url,\n                                   const std::string& range_info,\n-                                  intptr_t existing_stream,\n-                                  bool notify_needed,\n-                                  intptr_t notify_data);\n+                                  int range_request_id);\n   void OnDeferResourceLoading(unsigned long resource_id, bool defer);\n \n #if defined(OS_MACOSX)""}<_**next**_>{""sha"": ""c8c652dc7e97780b98520748d5c5a1367d844e7e"", ""filename"": ""webkit/glue/plugins/plugin_host.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 21, ""changes"": 27, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/plugins/plugin_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/plugins/plugin_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/glue/plugins/plugin_host.cc?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -313,12 +313,7 @@ NPError NPN_RequestRead(NPStream* stream, NPByteRange* range_list) {\n   return NPERR_NO_ERROR;\n }\n \n-static bool IsJavaScriptUrl(const std::string& url) {\n-  return StartsWithASCII(url, \""javascript:\"", false);\n-}\n-\n-// Generic form of GetURL for common code between\n-// GetURL() and GetURLNotify().\n+// Generic form of GetURL for common code between GetURL and GetURLNotify.\n static NPError GetURLNotify(NPP id,\n                             const char* url,\n                             const char* target,\n@@ -327,18 +322,13 @@ static NPError GetURLNotify(NPP id,\n   if (!url)\n     return NPERR_INVALID_URL;\n \n-  bool is_javascript_url = IsJavaScriptUrl(url);\n-\n   scoped_refptr<NPAPI::PluginInstance> plugin = FindInstance(id);\n-  if (plugin.get()) {\n-    plugin->webplugin()->HandleURLRequest(\n-        \""GET\"", is_javascript_url, target, 0, 0, false,\n-        notify, url, reinterpret_cast<intptr_t>(notify_data),\n-        plugin->popups_allowed());\n-  } else {\n+  if (!plugin.get()) {\n     NOTREACHED();\n     return NPERR_GENERIC_ERROR;\n   }\n+\n+  plugin->RequestURL(url, \""GET\"", target, NULL, 0, notify, notify_data);\n   return NPERR_NO_ERROR;\n }\n \n@@ -385,8 +375,7 @@ NPError NPN_GetURL(NPP id, const char* url, const char* target) {\n   return GetURLNotify(id, url, target, false, 0);\n }\n \n-// Generic form of PostURL for common code between\n-// PostURL() and PostURLNotify().\n+// Generic form of PostURL for common code between PostURL and PostURLNotify.\n static NPError PostURLNotify(NPP id,\n                              const char* url,\n                              const char* target,\n@@ -460,8 +449,6 @@ static NPError PostURLNotify(NPP id,\n     len = post_file_contents.size();\n   }\n \n-  bool is_javascript_url = IsJavaScriptUrl(url);\n-\n   // The post data sent by a plugin contains both headers\n   // and post data.  Example:\n   //      Content-type: text/html\n@@ -472,9 +459,7 @@ static NPError PostURLNotify(NPP id,\n   // Unfortunately, our stream needs these broken apart,\n   // so we need to parse the data and set headers and data\n   // separately.\n-  plugin->webplugin()->HandleURLRequest(\n-      \""POST\"", is_javascript_url, target, len, buf, false, notify, url,\n-      reinterpret_cast<intptr_t>(notify_data), plugin->popups_allowed());\n+  plugin->RequestURL(url, \""POST\"", target, buf, len, notify, notify_data);\n   return NPERR_NO_ERROR;\n }\n ""}<_**next**_>{""sha"": ""1d01f8e7d5cfc1fe4ebc2feaa769adb8f608bcd8"", ""filename"": ""webkit/glue/plugins/plugin_instance.cc"", ""status"": ""modified"", ""additions"": 88, ""deletions"": 40, ""changes"": 128, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/plugins/plugin_instance.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/plugins/plugin_instance.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/glue/plugins/plugin_instance.cc?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -40,16 +40,16 @@ PluginInstance::PluginInstance(PluginLib *plugin, const std::string &mime_type)\n       event_model_(0),\n       currently_handled_event_(NULL),\n #endif\n-      message_loop_(MessageLoop::current()),\n       load_manually_(false),\n       in_close_streams_(false),\n-      next_timer_id_(1) {\n+      next_timer_id_(1),\n+      next_notify_id_(0),\n+      next_range_request_id_(0) {\n   npp_ = new NPP_t();\n   npp_->ndata = 0;\n   npp_->pdata = 0;\n \n   memset(&zero_padding_, 0, sizeof(zero_padding_));\n-  DCHECK(message_loop_);\n }\n \n PluginInstance::~PluginInstance() {\n@@ -67,10 +67,13 @@ PluginInstance::~PluginInstance() {\n PluginStreamUrl* PluginInstance::CreateStream(unsigned long resource_id,\n                                               const GURL& url,\n                                               const std::string& mime_type,\n-                                              bool notify_needed,\n-                                              void* notify_data) {\n+                                              int notify_id) {\n+\n+  bool notify;\n+  void* notify_data;\n+  GetNotifyData(notify_id, &notify, &notify_data);\n   PluginStreamUrl* stream = new PluginStreamUrl(\n-      resource_id, url, this, notify_needed, notify_data);\n+      resource_id, url, this, notify, notify_data);\n \n   AddStream(stream);\n   return stream;\n@@ -115,6 +118,19 @@ void PluginInstance::CloseStreams() {\n   in_close_streams_ = false;\n }\n \n+webkit_glue::WebPluginResourceClient* PluginInstance::GetRangeRequest(\n+    int id) {\n+  PendingRangeRequestMap::iterator iter = pending_range_requests_.find(id);\n+  if (iter == pending_range_requests_.end()) {\n+    NOTREACHED();\n+    return NULL;\n+  }\n+\n+  webkit_glue::WebPluginResourceClient* rv = iter->second->AsResourceClient();\n+  pending_range_requests_.erase(iter);\n+  return rv;\n+}\n+\n bool PluginInstance::Start(const GURL& url,\n                            char** const param_names,\n                            char** const param_values,\n@@ -138,8 +154,16 @@ NPObject *PluginInstance::GetPluginScriptableObject() {\n }\n \n // WebPluginLoadDelegate methods\n-void PluginInstance::DidFinishLoadWithReason(const GURL& url, NPReason reason,\n-                                             void* notify_data) {\n+void PluginInstance::DidFinishLoadWithReason(\n+    const GURL& url, NPReason reason, int notify_id) {\n+  bool notify;\n+  void* notify_data;\n+  GetNotifyData(notify_id, &notify, &notify_data);\n+  if (!notify) {\n+    NOTREACHED();\n+    return;\n+  }\n+\n   NPP_URLNotify(url.spec().c_str(), reason, notify_data);\n }\n \n@@ -305,21 +329,21 @@ bool PluginInstance::NPP_Print(NPPrint* platform_print) {\n void PluginInstance::SendJavaScriptStream(const GURL& url,\n                                           const std::string& result,\n                                           bool success,\n-                                          bool notify_needed,\n-                                          intptr_t notify_data) {\n+                                          int notify_id) {\n+  bool notify;\n+  void* notify_data;\n+  GetNotifyData(notify_id, &notify, &notify_data);\n+\n   if (success) {\n     PluginStringStream *stream =\n-      new PluginStringStream(this, url, notify_needed,\n-                             reinterpret_cast<void*>(notify_data));\n+        new PluginStringStream(this, url, notify, notify_data);\n     AddStream(stream);\n     stream->SendToPlugin(result, \""text/html\"");\n   } else {\n     // NOTE: Sending an empty stream here will crash MacroMedia\n     // Flash 9.  Just send the URL Notify.\n-    if (notify_needed) {\n-      this->NPP_URLNotify(url.spec().c_str(), NPRES_DONE,\n-                          reinterpret_cast<void*>(notify_data));\n-    }\n+    if (notify)\n+      NPP_URLNotify(url.spec().c_str(), NPRES_DONE, notify_data);\n   }\n }\n \n@@ -330,8 +354,7 @@ void PluginInstance::DidReceiveManualResponse(const GURL& url,\n                                               uint32 last_modified) {\n   DCHECK(load_manually_);\n \n-  plugin_data_stream_ = CreateStream(-1, url, mime_type, false, NULL);\n-\n+  plugin_data_stream_ = CreateStream(-1, url, mime_type, 0);\n   plugin_data_stream_->DidReceiveResponse(mime_type, headers, expected_length,\n                                           last_modified, true);\n }\n@@ -362,8 +385,9 @@ void PluginInstance::DidManualLoadFail() {\n \n void PluginInstance::PluginThreadAsyncCall(void (*func)(void *),\n                                            void *user_data) {\n-  message_loop_->PostTask(FROM_HERE, NewRunnableMethod(\n-      this, &PluginInstance::OnPluginThreadAsyncCall, func, user_data));\n+  MessageLoop::current()->PostTask(\n+      FROM_HERE, NewRunnableMethod(\n+          this, &PluginInstance::OnPluginThreadAsyncCall, func, user_data));\n }\n \n void PluginInstance::OnPluginThreadAsyncCall(void (*func)(void *),\n@@ -389,13 +413,11 @@ uint32 PluginInstance::ScheduleTimer(uint32 interval,\n   timers_[timer_id] = info;\n \n   // Schedule the callback.\n-  message_loop_->PostDelayedTask(FROM_HERE,\n-                                 NewRunnableMethod(this,\n-                                                   &PluginInstance::OnTimerCall,\n-                                                   func,\n-                                                   npp_,\n-                                                   timer_id),\n-                                 interval);\n+  MessageLoop::current()->PostDelayedTask(\n+      FROM_HERE,\n+      NewRunnableMethod(\n+          this, &PluginInstance::OnTimerCall, func, npp_, timer_id),\n+      interval);\n   return timer_id;\n }\n \n@@ -434,14 +456,11 @@ void PluginInstance::OnTimerCall(void (*func)(NPP id, uint32 timer_id),\n   // Reschedule repeating timers after invoking the callback so callback is not\n   // re-entered if it pumps the messager loop.\n   if (info.repeat) {\n-    message_loop_->PostDelayedTask(FROM_HERE,\n-                                   NewRunnableMethod(\n-                                       this,\n-                                       &PluginInstance::OnTimerCall,\n-                                       func,\n-                                       npp_,\n-                                       timer_id),\n-                                   info.interval);\n+    MessageLoop::current()->PostDelayedTask(\n+        FROM_HERE,\n+        NewRunnableMethod(\n+            this, &PluginInstance::OnTimerCall, func, npp_, timer_id),\n+        info.interval);\n   } else {\n     timers_.erase(it);\n   }\n@@ -490,14 +509,30 @@ void PluginInstance::RequestRead(NPStream* stream, NPByteRange* range_list) {\n       // is called on it.\n       plugin_stream->set_seekable(true);\n \n+      pending_range_requests_[++next_range_request_id_] = plugin_stream;\n       webplugin_->InitiateHTTPRangeRequest(\n-          stream->url, range_info.c_str(),\n-          reinterpret_cast<intptr_t>(plugin_stream),\n-          plugin_stream->notify_needed(),\n-          reinterpret_cast<intptr_t>(plugin_stream->notify_data()));\n-      break;\n+          stream->url, range_info.c_str(), next_range_request_id_);\n+      return;\n     }\n   }\n+  NOTREACHED();\n+}\n+\n+void PluginInstance::RequestURL(const char* url,\n+                                const char* method,\n+                                const char* target,\n+                                const char* buf,\n+                                unsigned int len,\n+                                bool notify,\n+                                void* notify_data) {\n+  int notify_id = 0;\n+  if (notify) {\n+    notify_id = ++next_notify_id_;\n+    pending_requests_[notify_id] = notify_data;\n+  }\n+\n+  webplugin_->HandleURLRequest(\n+      url, method, target, buf, len, notify_id, popups_allowed());\n }\n \n bool PluginInstance::ConvertPoint(double source_x, double source_y,\n@@ -566,4 +601,17 @@ bool PluginInstance::ConvertPoint(double source_x, double source_y,\n #endif\n }\n \n+void PluginInstance::GetNotifyData(\n+    int notify_id, bool* notify, void** notify_data) {\n+  PendingRequestMap::iterator iter = pending_requests_.find(notify_id);\n+  if (iter != pending_requests_.end()) {\n+    *notify = true;\n+    *notify_data = iter->second;\n+    pending_requests_.erase(iter);\n+  } else {\n+    *notify = false;\n+    *notify_data = NULL;\n+  }\n+}\n+\n }  // namespace NPAPI""}<_**next**_>{""sha"": ""7cb72aa60d884ab8e0300a56821cbac5195176a3"", ""filename"": ""webkit/glue/plugins/plugin_instance.h"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 22, ""changes"": 64, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/plugins/plugin_instance.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/plugins/plugin_instance.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/glue/plugins/plugin_instance.h?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -24,10 +24,10 @@\n #include \""googleurl/src/gurl.h\""\n #include \""third_party/npapi/bindings/npapi.h\""\n \n-class MessageLoop;\n \n namespace webkit_glue {\n class WebPlugin;\n+class WebPluginResourceClient;\n }\n \n namespace NPAPI\n@@ -116,17 +116,15 @@ class PluginInstance : public base::RefCountedThreadSafe<PluginInstance> {\n   void set_plugin_origin(gfx::Point origin) { plugin_origin_ = origin; }\n #endif\n \n-  // Creates a stream for sending an URL.  If notify_needed\n-  // is true, it will send a notification to the plugin\n-  // when the stream is complete; otherwise it will not.\n-  // Set object_url to true if the load is for the object tag's\n-  // url, or false if it's for a url that the plugin\n-  // fetched through NPN_GetUrl[Notify].\n+  // Creates a stream for sending an URL.  If notify_id is non-zero, it will\n+  // send a notification to the plugin when the stream is complete; otherwise it\n+  // will not.  Set object_url to true if the load is for the object tag's url,\n+  // or false if it's for a url that the plugin fetched through\n+  // NPN_GetUrl[Notify].\n   PluginStreamUrl* CreateStream(unsigned long resource_id,\n                                 const GURL& url,\n                                 const std::string& mime_type,\n-                                bool notify_needed,\n-                                void* notify_data);\n+                                int notify_id);\n \n   // For each instance, we track all streams.  When the\n   // instance closes, all remaining streams are also\n@@ -142,13 +140,16 @@ class PluginInstance : public base::RefCountedThreadSafe<PluginInstance> {\n   // Closes all open streams on this instance.\n   void CloseStreams();\n \n+  // Returns the WebPluginResourceClient object for a stream that has become\n+  // seekable.\n+  webkit_glue::WebPluginResourceClient* GetRangeRequest(int id);\n+\n   // Have the plugin create it's script object.\n   NPObject *GetPluginScriptableObject();\n \n   // WebViewDelegate methods that we implement. This is for handling\n   // callbacks during getURLNotify.\n-  virtual void DidFinishLoadWithReason(const GURL& url, NPReason reason,\n-                                       void* notify_data);\n+  void DidFinishLoadWithReason(const GURL& url, NPReason reason, int notify_id);\n \n   // If true, send the Mozilla user agent instead of Chrome's to the plugin.\n   bool use_mozilla_user_agent() { return use_mozilla_user_agent_; }\n@@ -188,9 +189,10 @@ class PluginInstance : public base::RefCountedThreadSafe<PluginInstance> {\n   void NPP_Destroy();\n   bool NPP_Print(NPPrint* platform_print);\n \n-  void SendJavaScriptStream(const GURL& url, const std::string& result,\n-                            bool success, bool notify_needed,\n-                            intptr_t notify_data);\n+  void SendJavaScriptStream(const GURL& url,\n+                            const std::string& result,\n+                            bool success,\n+                            int notify_id);\n \n   void DidReceiveManualResponse(const GURL& url,\n                                 const std::string& mime_type,\n@@ -211,6 +213,16 @@ class PluginInstance : public base::RefCountedThreadSafe<PluginInstance> {\n   // Initiates byte range reads for plugins.\n   void RequestRead(NPStream* stream, NPByteRange* range_list);\n \n+  // Handles GetURL/GetURLNotify/PostURL/PostURLNotify requests initiated\n+  // by plugins.\n+  void RequestURL(const char* url,\n+                  const char* method,\n+                  const char* target,\n+                  const char* buf,\n+                  unsigned int len,\n+                  bool notify,\n+                  void* notify_data);\n+\n  private:\n   friend class base::RefCountedThreadSafe<PluginInstance>;\n \n@@ -225,15 +237,12 @@ class PluginInstance : public base::RefCountedThreadSafe<PluginInstance> {\n   }\n #endif\n \n-  virtual ~PluginInstance();\n-\n-  void OnPluginThreadAsyncCall(void (*func)(void *),\n-                               void *userData);\n+  ~PluginInstance();\n+  void OnPluginThreadAsyncCall(void (*func)(void *), void *userData);\n   void OnTimerCall(void (*func)(NPP id, uint32 timer_id),\n-                   NPP id,\n-                   uint32 timer_id);\n-\n+                   NPP id, uint32 timer_id);\n   bool IsValidStream(const NPStream* stream);\n+  void GetNotifyData(int notify_id, bool* notify, void** notify_data);\n \n   // This is a hack to get the real player plugin to work with chrome\n   // The real player plugin dll(nppl3260) when loaded by firefox is loaded via\n@@ -275,7 +284,6 @@ class PluginInstance : public base::RefCountedThreadSafe<PluginInstance> {\n   gfx::Point                               plugin_origin_;\n   NPCocoaEvent*                            currently_handled_event_;  // weak\n #endif\n-  MessageLoop*                             message_loop_;\n   scoped_refptr<PluginStreamUrl>           plugin_data_stream_;\n \n   // This flag if true indicates that the plugin data would be passed from\n@@ -304,6 +312,18 @@ class PluginInstance : public base::RefCountedThreadSafe<PluginInstance> {\n   typedef std::map<uint32, TimerInfo> TimerMap;\n   TimerMap timers_;\n \n+  // Tracks pending GET/POST requests so that the plugin-given data doesn't\n+  // cross process boundaries to an untrusted process.\n+  typedef std::map<int, void*> PendingRequestMap;\n+  PendingRequestMap pending_requests_;\n+  int next_notify_id_;\n+\n+  // Used to track pending range requests so that when WebPlugin replies to us\n+  // we can match the reply to the stream.\n+  typedef std::map<int, scoped_refptr<PluginStream> > PendingRangeRequestMap;\n+  PendingRangeRequestMap pending_range_requests_;\n+  int next_range_request_id_;\n+\n   DISALLOW_EVIL_CONSTRUCTORS(PluginInstance);\n };\n ""}<_**next**_>{""sha"": ""d2ecbc712f74dfb8a4a8a2a0a3e239e670bf8aa6"", ""filename"": ""webkit/glue/plugins/webplugin_delegate_impl.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 22, ""changes"": 33, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/plugins/webplugin_delegate_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/plugins/webplugin_delegate_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/glue/plugins/webplugin_delegate_impl.cc?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -143,15 +143,14 @@ NPObject* WebPluginDelegateImpl::GetPluginScriptableObject() {\n \n void WebPluginDelegateImpl::DidFinishLoadWithReason(const GURL& url,\n                                                     NPReason reason,\n-                                                    intptr_t notify_data) {\n+                                                    int notify_id) {\n   if (quirks_ & PLUGIN_QUIRK_ALWAYS_NOTIFY_SUCCESS &&\n       reason == NPRES_NETWORK_ERR) {\n     // Flash needs this or otherwise it unloads the launching swf object.\n     reason = NPRES_DONE;\n   }\n \n-  instance()->DidFinishLoadWithReason(\n-      url, reason, reinterpret_cast<void*>(notify_data));\n+  instance()->DidFinishLoadWithReason(url, reason, notify_id);\n }\n \n int WebPluginDelegateImpl::GetProcessId() {\n@@ -162,10 +161,8 @@ int WebPluginDelegateImpl::GetProcessId() {\n void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,\n                                                  const std::string& result,\n                                                  bool success,\n-                                                 bool notify_needed,\n-                                                 intptr_t notify_data) {\n-  instance()->SendJavaScriptStream(url, result, success, notify_needed,\n-                                   notify_data);\n+                                                 int notify_id) {\n+  instance()->SendJavaScriptStream(url, result, success, notify_id);\n }\n \n void WebPluginDelegateImpl::DidReceiveManualResponse(\n@@ -209,20 +206,12 @@ void WebPluginDelegateImpl::WindowedUpdateGeometry(\n }\n \n WebPluginResourceClient* WebPluginDelegateImpl::CreateResourceClient(\n-    unsigned long resource_id, const GURL& url, bool notify_needed,\n-    intptr_t notify_data, intptr_t existing_stream) {\n-  // Stream already exists. This typically happens for range requests\n-  // initiated via NPN_RequestRead.\n-  if (existing_stream) {\n-    NPAPI::PluginStream* plugin_stream =\n-        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);\n-\n-    return plugin_stream->AsResourceClient();\n-  }\n+    unsigned long resource_id, const GURL& url, int notify_id) {\n+  return instance()->CreateStream(\n+      resource_id, url, std::string(), notify_id);\n+}\n \n-  std::string mime_type;\n-  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(\n-      resource_id, url, mime_type, notify_needed,\n-      reinterpret_cast<void*>(notify_data));\n-  return stream;\n+WebPluginResourceClient* WebPluginDelegateImpl::CreateSeekableResourceClient(\n+    unsigned long resource_id, int range_request_id) {\n+  return instance()->GetRangeRequest(range_request_id);\n }""}<_**next**_>{""sha"": ""ce19bb5b220e3ac1e0156ae3313bc57dd1af798d"", ""filename"": ""webkit/glue/plugins/webplugin_delegate_impl.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 9, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/plugins/webplugin_delegate_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/plugins/webplugin_delegate_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/glue/plugins/webplugin_delegate_impl.h?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -79,13 +79,13 @@ class WebPluginDelegateImpl : public webkit_glue::WebPluginDelegate {\n   virtual bool HandleInputEvent(const WebKit::WebInputEvent& event,\n                                 WebKit::WebCursorInfo* cursor);\n   virtual NPObject* GetPluginScriptableObject();\n-  virtual void DidFinishLoadWithReason(const GURL& url, NPReason reason,\n-                                       intptr_t notify_data);\n+  virtual void DidFinishLoadWithReason(\n+      const GURL& url, NPReason reason, int notify_id);\n   virtual int GetProcessId();\n   virtual void SendJavaScriptStream(const GURL& url,\n                                     const std::string& result,\n-                                    bool success, bool notify_needed,\n-                                    intptr_t notify_data);\n+                                    bool success,\n+                                    int notify_id);\n   virtual void DidReceiveManualResponse(const GURL& url,\n                                         const std::string& mime_type,\n                                         const std::string& headers,\n@@ -96,11 +96,9 @@ class WebPluginDelegateImpl : public webkit_glue::WebPluginDelegate {\n   virtual void DidManualLoadFail();\n   virtual void InstallMissingPlugin();\n   virtual webkit_glue::WebPluginResourceClient* CreateResourceClient(\n-      unsigned long resource_id,\n-      const GURL& url,\n-      bool notify_needed,\n-      intptr_t notify_data,\n-      intptr_t stream);\n+      unsigned long resource_id, const GURL& url, int notify_id);\n+  virtual webkit_glue::WebPluginResourceClient* CreateSeekableResourceClient(\n+      unsigned long resource_id, int range_request_id);\n   // End of WebPluginDelegate implementation.\n \n   bool IsWindowless() const { return windowless_ ; }""}<_**next**_>{""sha"": ""051eb2c40648050f1199f9c185fd0a94b20f5dbd"", ""filename"": ""webkit/glue/webplugin.h"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 11, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/webplugin.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/webplugin.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/glue/webplugin.h?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -105,23 +105,23 @@ class WebPlugin {\n   virtual void OnMissingPluginStatus(int status) = 0;\n \n   // Handles GetURL/GetURLNotify/PostURL/PostURLNotify requests initiated\n-  // by plugins.\n-  virtual void HandleURLRequest(const char *method,\n-                                bool is_javascript_url,\n-                                const char* target, unsigned int len,\n-                                const char* buf, bool is_file_data,\n-                                bool notify, const char* url,\n-                                intptr_t notify_data, bool popups_allowed) = 0;\n+  // by plugins.  If the plugin wants notification of the result, notify_id will\n+  // be non-zero.\n+  virtual void HandleURLRequest(const char* url,\n+                                const char *method,\n+                                const char* target,\n+                                const char* buf,\n+                                unsigned int len,\n+                                int notify_id,\n+                                bool popups_allowed) = 0;\n \n   // Cancels document load.\n   virtual void CancelDocumentLoad() = 0;\n \n-  // Initiates a HTTP range request.\n+  // Initiates a HTTP range request for an existing stream.\n   virtual void InitiateHTTPRangeRequest(const char* url,\n                                         const char* range_info,\n-                                        intptr_t existing_stream,\n-                                        bool notify_needed,\n-                                        intptr_t notify_data) = 0;\n+                                        int range_request_id) = 0;\n \n   // Returns true iff in off the record (Incognito) mode.\n   virtual bool IsOffTheRecord() = 0;""}<_**next**_>{""sha"": ""52c71861fe8e2c2f19478806ff0de12ce37979a6"", ""filename"": ""webkit/glue/webplugin_delegate.h"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 6, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/webplugin_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/webplugin_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/glue/webplugin_delegate.h?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -94,7 +94,7 @@ class WebPluginDelegate : public WebPlugin2DDeviceDelegate,\n   // Receives notification about a resource load that the plugin initiated\n   // for a frame.\n   virtual void DidFinishLoadWithReason(const GURL& url, NPReason reason,\n-                                       intptr_t notify_data) = 0;\n+                                       int notify_id) = 0;\n \n   // Returns the process id of the process that is running the plugin.\n   virtual int GetProcessId() = 0;\n@@ -103,8 +103,8 @@ class WebPluginDelegate : public WebPlugin2DDeviceDelegate,\n   // function.\n   virtual void SendJavaScriptStream(const GURL& url,\n                                     const std::string& result,\n-                                    bool success, bool notify_needed,\n-                                    intptr_t notify_data) = 0;\n+                                    bool success,\n+                                    int notify_id) = 0;\n \n   // Receives notification about data being available.\n   virtual void DidReceiveManualResponse(const GURL& url,\n@@ -129,9 +129,12 @@ class WebPluginDelegate : public WebPlugin2DDeviceDelegate,\n   virtual WebPluginResourceClient* CreateResourceClient(\n       unsigned long resource_id,\n       const GURL& url,\n-      bool notify_needed,\n-      intptr_t notify_data,\n-      intptr_t stream) = 0;\n+      int notify_id) = 0;\n+\n+  // Creates a WebPluginResourceClient instance for an existing stream that is\n+  // has become seekable.\n+  virtual WebPluginResourceClient* CreateSeekableResourceClient(\n+      unsigned long resource_id, int range_request_id) = 0;\n };\n \n }  // namespace webkit_glue""}<_**next**_>{""sha"": ""f032340d1bc86868f18548a5dfc609283ebe544d"", ""filename"": ""webkit/glue/webplugin_impl.cc"", ""status"": ""modified"", ""additions"": 69, ""deletions"": 77, ""changes"": 146, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/webplugin_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/webplugin_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/glue/webplugin_impl.cc?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -354,7 +354,7 @@ void WebPluginImpl::didFinishLoadingFrameRequest(\n     const WebURL& url, void* notify_data) {\n   if (delegate_) {\n     delegate_->DidFinishLoadWithReason(\n-        url, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));\n+        url, NPRES_DONE, reinterpret_cast<int>(notify_data));\n   }\n }\n \n@@ -366,7 +366,7 @@ void WebPluginImpl::didFailLoadingFrameRequest(\n   NPReason reason =\n       error.reason == net::ERR_ABORTED ? NPRES_USER_BREAK : NPRES_NETWORK_ERR;\n   delegate_->DidFinishLoadWithReason(\n-      url, reason, reinterpret_cast<intptr_t>(notify_data));\n+      url, reason, reinterpret_cast<int>(notify_data));\n }\n \n // -----------------------------------------------------------------------------\n@@ -478,15 +478,13 @@ bool WebPluginImpl::SetPostData(WebURLRequest* request,\n }\n \n WebPluginImpl::RoutingStatus WebPluginImpl::RouteToFrame(\n-    const char *method,\n+    const char* url,\n     bool is_javascript_url,\n+    const char* method,\n     const char* target,\n-    unsigned int len,\n     const char* buf,\n-    bool is_file_data,\n-    bool notify_needed,\n-    intptr_t notify_data,\n-    const char* url,\n+    unsigned int len,\n+    int notify_id,\n     Referrer referrer_flag) {\n   // If there is no target, there is nothing to do\n   if (!target)\n@@ -534,23 +532,16 @@ WebPluginImpl::RoutingStatus WebPluginImpl::RouteToFrame(\n \n   request.setHTTPMethod(WebString::fromUTF8(method));\n   if (len > 0) {\n-    if (!is_file_data) {\n-      if (!SetPostData(&request, buf, len)) {\n-        // Uhoh - we're in trouble.  There isn't a good way\n-        // to recover at this point.  Break out.\n-        NOTREACHED();\n-        return ROUTED;\n-      }\n-    } else {\n-      // TODO: Support \""file\"" mode.  For now, just break out\n-      // since proceeding may do something unintentional.\n+    if (!SetPostData(&request, buf, len)) {\n+      // Uhoh - we're in trouble.  There isn't a good way\n+      // to recover at this point.  Break out.\n       NOTREACHED();\n       return ROUTED;\n     }\n   }\n \n-  container_->loadFrameRequest(request, target_str, notify_needed,\n-                               reinterpret_cast<void*>(notify_data));\n+  container_->loadFrameRequest(\n+      request, target_str, notify_id != 0, reinterpret_cast<void*>(notify_id));\n   return ROUTED;\n }\n \n@@ -603,9 +594,8 @@ void WebPluginImpl::InvalidateRect(const gfx::Rect& rect) {\n }\n \n void WebPluginImpl::OnDownloadPluginSrcUrl() {\n-  HandleURLRequestInternal(\""GET\"", false, NULL, 0, NULL, false, false,\n-                           plugin_url_.spec().c_str(), NULL, false,\n-                           DOCUMENT_URL);\n+  HandleURLRequestInternal(\n+      plugin_url_.spec().c_str(), \""GET\"", NULL, NULL, 0, 0, false, DOCUMENT_URL);\n }\n \n WebPluginResourceClient* WebPluginImpl::GetClientFromLoader(\n@@ -683,8 +673,7 @@ void WebPluginImpl::didReceiveResponse(WebURLLoader* loader,\n       for (size_t i = 0; i < clients_.size(); ++i) {\n         if (clients_[i].loader.get() == loader) {\n           WebPluginResourceClient* resource_client =\n-              delegate_->CreateResourceClient(clients_[i].id, plugin_url_,\n-                                              false, 0, NULL);\n+              delegate_->CreateResourceClient(clients_[i].id, plugin_url_, 0);\n           clients_[i].client = resource_client;\n           client = resource_client;\n           break;\n@@ -816,34 +805,38 @@ void WebPluginImpl::SetContainer(WebPluginContainer* container) {\n   container_ = container;\n }\n \n-void WebPluginImpl::HandleURLRequest(const char *method,\n-                                     bool is_javascript_url,\n-                                     const char* target, unsigned int len,\n-                                     const char* buf, bool is_file_data,\n-                                     bool notify, const char* url,\n-                                     intptr_t notify_data, bool popups_allowed) {\n+void WebPluginImpl::HandleURLRequest(const char* url,\n+                                     const char *method,\n+                                     const char* target,\n+                                     const char* buf,\n+                                     unsigned int len,\n+                                     int notify_id,\n+                                     bool popups_allowed) {\n   // GetURL/PostURL requests initiated explicitly by plugins should specify the\n   // plugin SRC url as the referrer if it is available.\n-  HandleURLRequestInternal(method, is_javascript_url, target, len, buf,\n-                           is_file_data, notify, url, notify_data,\n-                           popups_allowed, PLUGIN_SRC);\n+  HandleURLRequestInternal(\n+      url, method, target, buf, len, notify_id, popups_allowed, PLUGIN_SRC);\n }\n \n-void WebPluginImpl::HandleURLRequestInternal(\n-    const char *method, bool is_javascript_url, const char* target,\n-    unsigned int len, const char* buf, bool is_file_data, bool notify,\n-    const char* url, intptr_t notify_data, bool popups_allowed,\n-    Referrer referrer_flag) {\n+void WebPluginImpl::HandleURLRequestInternal(const char* url,\n+                                             const char *method,\n+                                             const char* target,\n+                                             const char* buf,\n+                                             unsigned int len,\n+                                             int notify_id,\n+                                             bool popups_allowed,\n+                                             Referrer referrer_flag) {\n   // For this request, we either route the output to a frame\n   // because a target has been specified, or we handle the request\n   // here, i.e. by executing the script if it is a javascript url\n   // or by initiating a download on the URL, etc. There is one special\n   // case in that the request is a javascript url and the target is \""_self\"",\n   // in which case we route the output to the plugin rather than routing it\n   // to the plugin's frame.\n-  RoutingStatus routing_status =\n-      RouteToFrame(method, is_javascript_url, target, len, buf, is_file_data,\n-                   notify, notify_data, url, referrer_flag);\n+  bool is_javascript_url = StartsWithASCII(url, \""javascript:\"", false);\n+  RoutingStatus routing_status = RouteToFrame(\n+      url, is_javascript_url, method, target, buf, len, notify_id,\n+      referrer_flag);\n   if (routing_status == ROUTED)\n     return;\n \n@@ -855,37 +848,38 @@ void WebPluginImpl::HandleURLRequestInternal(\n     // be deleted.\n     if (delegate_) {\n       delegate_->SendJavaScriptStream(\n-          gurl, result.utf8(), !result.isNull(), notify, notify_data);\n+          gurl, result.utf8(), !result.isNull(), notify_id);\n     }\n-  } else {\n-    GURL complete_url = CompleteURL(url);\n \n-    unsigned long resource_id = GetNextResourceId();\n-    if (!resource_id)\n-      return;\n-\n-    WebPluginResourceClient* resource_client = delegate_->CreateResourceClient(\n-        resource_id, complete_url, notify, notify_data, NULL);\n-    if (!resource_client)\n-      return;\n+    return;\n+  }\n \n-    // If the RouteToFrame call returned a failure then inform the result\n-    // back to the plugin asynchronously.\n-    if ((routing_status == INVALID_URL) ||\n-        (routing_status == GENERAL_FAILURE)) {\n-      resource_client->DidFail();\n-      return;\n-    }\n+  unsigned long resource_id = GetNextResourceId();\n+  if (!resource_id)\n+    return;\n \n-    // CreateResourceClient() sends a synchronous IPC message so it's possible\n-    // that TearDownPluginInstance() may have been called in the nested\n-    // message loop.  If so, don't start the request.\n-    if (!delegate_)\n-      return;\n+  GURL complete_url = CompleteURL(url);\n+  WebPluginResourceClient* resource_client = delegate_->CreateResourceClient(\n+      resource_id, complete_url, notify_id);\n+  if (!resource_client)\n+    return;\n \n-    InitiateHTTPRequest(resource_id, resource_client, method, buf, len,\n-                        complete_url, NULL, referrer_flag);\n+  // If the RouteToFrame call returned a failure then inform the result\n+  // back to the plugin asynchronously.\n+  if ((routing_status == INVALID_URL) ||\n+      (routing_status == GENERAL_FAILURE)) {\n+    resource_client->DidFail();\n+    return;\n   }\n+\n+  // CreateResourceClient() sends a synchronous IPC message so it's possible\n+  // that TearDownPluginInstance() may have been called in the nested\n+  // message loop.  If so, don't start the request.\n+  if (!delegate_)\n+    return;\n+\n+  InitiateHTTPRequest(resource_id, resource_client, complete_url, method, buf,\n+                      len, NULL, referrer_flag);\n }\n \n unsigned long WebPluginImpl::GetNextResourceId() {\n@@ -899,9 +893,10 @@ unsigned long WebPluginImpl::GetNextResourceId() {\n \n bool WebPluginImpl::InitiateHTTPRequest(unsigned long resource_id,\n                                         WebPluginResourceClient* client,\n-                                        const char* method, const char* buf,\n-                                        int buf_len,\n                                         const GURL& url,\n+                                        const char* method,\n+                                        const char* buf,\n+                                        int buf_len,\n                                         const char* range_info,\n                                         Referrer referrer_flag) {\n   if (!client) {\n@@ -956,21 +951,18 @@ void WebPluginImpl::CancelDocumentLoad() {\n   }\n }\n \n-void WebPluginImpl::InitiateHTTPRangeRequest(const char* url,\n-                                             const char* range_info,\n-                                             intptr_t existing_stream,\n-                                             bool notify_needed,\n-                                             intptr_t notify_data) {\n+void WebPluginImpl::InitiateHTTPRangeRequest(\n+    const char* url, const char* range_info, int range_request_id) {\n   unsigned long resource_id = GetNextResourceId();\n   if (!resource_id)\n     return;\n \n   GURL complete_url = CompleteURL(url);\n \n-  WebPluginResourceClient* resource_client = delegate_->CreateResourceClient(\n-      resource_id, complete_url, notify_needed, notify_data, existing_stream);\n+  WebPluginResourceClient* resource_client =\n+      delegate_->CreateSeekableResourceClient(resource_id, range_request_id);\n   InitiateHTTPRequest(\n-      resource_id, resource_client, \""GET\"", NULL, 0, complete_url, range_info,\n+      resource_id, resource_client, complete_url, \""GET\"", NULL, 0, range_info,\n       load_manually_ ? NO_REFERRER : PLUGIN_SRC);\n }\n ""}<_**next**_>{""sha"": ""fbe9ff6ee11b978c59aad1bdc3499bd9384468f6"", ""filename"": ""webkit/glue/webplugin_impl.h"", ""status"": ""modified"", ""additions"": 29, ""deletions"": 21, ""changes"": 50, ""blob_url"": ""https://github.com/chromium/chromium/blob/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/webplugin_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ea3d1d84be3d6f97bf50e76511c9e26af6895533/webkit/glue/webplugin_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/glue/webplugin_impl.h?ref=ea3d1d84be3d6f97bf50e76511c9e26af6895533"", ""patch"": ""@@ -128,11 +128,14 @@ class WebPluginImpl : public WebPlugin,\n   // Given a download request, check if we need to route the output to a frame.\n   // Returns ROUTED if the load is done and routed to a frame, NOT_ROUTED or\n   // corresponding error codes otherwise.\n-  RoutingStatus RouteToFrame(const char* method, bool is_javascript_url,\n-                             const char* target, unsigned int len,\n-                             const char* buf, bool is_file_data,\n-                             bool notify_needed, intptr_t notify_data,\n-                             const char* url, Referrer referrer_flag);\n+  RoutingStatus RouteToFrame(const char* url,\n+                             bool is_javascript_url,\n+                             const char* method,\n+                             const char* target,\n+                             const char* buf,\n+                             unsigned int len,\n+                             int notify_id,\n+                             Referrer referrer_flag);\n \n   // Cancels a pending request.\n   void CancelResource(unsigned long id);\n@@ -145,8 +148,11 @@ class WebPluginImpl : public WebPlugin,\n   // Returns true on success.\n   bool InitiateHTTPRequest(unsigned long resource_id,\n                            WebPluginResourceClient* client,\n-                           const char* method, const char* buf, int buf_len,\n-                           const GURL& url, const char* range_info,\n+                           const GURL& url,\n+                           const char* method,\n+                           const char* buf,\n+                           int len,\n+                           const char* range_info,\n                            Referrer referrer_flag);\n \n   gfx::Rect GetWindowClipRect(const gfx::Rect& rect);\n@@ -199,18 +205,18 @@ class WebPluginImpl : public WebPlugin,\n   // request given a handle.\n   void RemoveClient(WebKit::WebURLLoader* loader);\n \n-  void HandleURLRequest(const char *method,\n-                        bool is_javascript_url,\n-                        const char* target, unsigned int len,\n-                        const char* buf, bool is_file_data,\n-                        bool notify, const char* url,\n-                        intptr_t notify_data, bool popups_allowed);\n+  void HandleURLRequest(const char* url,\n+                        const char *method,\n+                        const char* target,\n+                        const char* buf,\n+                        unsigned int len,\n+                        int notify_id,\n+                        bool popups_allowed);\n \n   void CancelDocumentLoad();\n \n-  void InitiateHTTPRangeRequest(const char* url, const char* range_info,\n-                                intptr_t existing_stream, bool notify_needed,\n-                                intptr_t notify_data);\n+  void InitiateHTTPRangeRequest(\n+      const char* url, const char* range_info, int pending_request_id);\n \n   void SetDeferResourceLoading(unsigned long resource_id, bool defer);\n \n@@ -222,11 +228,13 @@ class WebPluginImpl : public WebPlugin,\n   void HandleHttpMultipartResponse(const WebKit::WebURLResponse& response,\n                                    WebPluginResourceClient* client);\n \n-  void HandleURLRequestInternal(const char *method, bool is_javascript_url,\n-                                const char* target, unsigned int len,\n-                                const char* buf, bool is_file_data,\n-                                bool notify, const char* url,\n-                                intptr_t notify_data, bool popups_allowed,\n+  void HandleURLRequestInternal(const char* url,\n+                                const char *method,\n+                                const char* target,\n+                                const char* buf,\n+                                unsigned int len,\n+                                int notify_id,\n+                                bool popups_allowed,\n                                 Referrer referrer_flag);\n \n   // Tears down the existing plugin instance and creates a new plugin instance""}","    unsigned long resource_id, const GURL& url, bool notify_needed,/~/    intptr_t notify_data, intptr_t existing_stream) {/~/  // Stream already exists. This typically happens for range requests/~/  // initiated via NPN_RequestRead./~/  if (existing_stream) {/~/    NPAPI::PluginStream* plugin_stream =/~/        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);/~/    return plugin_stream->AsResourceClient();/~/  }/~/  std::string mime_type;/~/  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(/~/      resource_id, url, mime_type, notify_needed,/~/      reinterpret_cast<void*>(notify_data));/~/  return stream;","1,2,3,4,5,6,7,8,9,11,12,13,14,15"," WebPluginResourceClient* WebPluginDelegateImpl::CreateResourceClient(
    unsigned long resource_id, const GURL& url, int notify_id) {
  return instance()->CreateStream(
      resource_id, url, std::string(), notify_id);
}
 
WebPluginResourceClient* WebPluginDelegateImpl::CreateSeekableResourceClient(
    unsigned long resource_id, int range_request_id) {
  return instance()->GetRangeRequest(range_request_id);
 }
"," WebPluginResourceClient* WebPluginDelegateImpl::CreateResourceClient(
    unsigned long resource_id, const GURL& url, bool notify_needed,
    intptr_t notify_data, intptr_t existing_stream) {
  if (existing_stream) {
    NPAPI::PluginStream* plugin_stream =
        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);
    return plugin_stream->AsResourceClient();
  }
 
  std::string mime_type;
  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(
      resource_id, url, mime_type, notify_needed,
      reinterpret_cast<void*>(notify_data));
  return stream;
 }
",183593.0,C,"    unsigned long resource_id, const GURL& url, int notify_id) {
  return instance()->CreateStream(
      resource_id, url, std::string(), notify_id);
}
WebPluginResourceClient* WebPluginDelegateImpl::CreateSeekableResourceClient(
    unsigned long resource_id, int range_request_id) {
  return instance()->GetRangeRequest(range_request_id);
","    unsigned long resource_id, const GURL& url, bool notify_needed,
    intptr_t notify_data, intptr_t existing_stream) {
  if (existing_stream) {
    NPAPI::PluginStream* plugin_stream =
        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);
    return plugin_stream->AsResourceClient();
  }
  std::string mime_type;
  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(
      resource_id, url, mime_type, notify_needed,
      reinterpret_cast<void*>(notify_data));
  return stream;
",,"@@ -143,15 +143,14 @@ NPObject* WebPluginDelegateImpl::GetPluginScriptableObject() {
 
 void WebPluginDelegateImpl::DidFinishLoadWithReason(const GURL& url,
                                                     NPReason reason,
-                                                    intptr_t notify_data) {
+                                                    int notify_id) {
   if (quirks_ & PLUGIN_QUIRK_ALWAYS_NOTIFY_SUCCESS &&
       reason == NPRES_NETWORK_ERR) {
     // Flash needs this or otherwise it unloads the launching swf object.
     reason = NPRES_DONE;
   }
 
-  instance()->DidFinishLoadWithReason(
-      url, reason, reinterpret_cast<void*>(notify_data));
+  instance()->DidFinishLoadWithReason(url, reason, notify_id);
 }
 
 int WebPluginDelegateImpl::GetProcessId() {
@@ -162,10 +161,8 @@ int WebPluginDelegateImpl::GetProcessId() {
 void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,
                                                  const std::string& result,
                                                  bool success,
-                                                 bool notify_needed,
-                                                 intptr_t notify_data) {
-  instance()->SendJavaScriptStream(url, result, success, notify_needed,
-                                   notify_data);
+                                                 int notify_id) {
+  instance()->SendJavaScriptStream(url, result, success, notify_id);
 }
 
 void WebPluginDelegateImpl::DidReceiveManualResponse(
@@ -209,20 +206,12 @@ void WebPluginDelegateImpl::WindowedUpdateGeometry(
 }
 
 WebPluginResourceClient* WebPluginDelegateImpl::CreateResourceClient(
-    unsigned long resource_id, const GURL& url, bool notify_needed,
-    intptr_t notify_data, intptr_t existing_stream) {
-  // Stream already exists. This typically happens for range requests
-  // initiated via NPN_RequestRead.
-  if (existing_stream) {
-    NPAPI::PluginStream* plugin_stream =
-        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);
-
-    return plugin_stream->AsResourceClient();
-  }
+    unsigned long resource_id, const GURL& url, int notify_id) {
+  return instance()->CreateStream(
+      resource_id, url, std::string(), notify_id);
+}
 
-  std::string mime_type;
-  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(
-      resource_id, url, mime_type, notify_needed,
-      reinterpret_cast<void*>(notify_data));
-  return stream;
+WebPluginResourceClient* WebPluginDelegateImpl::CreateSeekableResourceClient(
+    unsigned long resource_id, int range_request_id) {
+  return instance()->GetRangeRequest(range_request_id);
 }","WebPluginResourceClient* WebPluginDelegateImpl::CreateResourceClient(
    unsigned long resource_id, const GURL& url, bool notify_needed,
    intptr_t notify_data, intptr_t existing_stream) {
  // Stream already exists. This typically happens for range requests
  // initiated via NPN_RequestRead.
  if (existing_stream) {
    NPAPI::PluginStream* plugin_stream =
        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);
    return plugin_stream->AsResourceClient();
  }

  std::string mime_type;
  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(
      resource_id, url, mime_type, notify_needed,
      reinterpret_cast<void*>(notify_data));
  return stream;
}
",Chrome,ea3d1d84be3d6f97bf50e76511c9e26af6895533,403e46333b43009776a08273501e4ca8c5c06e12,1.0," WebPluginResourceClient* WebPluginDelegateImpl::CreateResourceClient(
//flaw_line_below:
    unsigned long resource_id, const GURL& url, bool notify_needed,
//flaw_line_below:
    intptr_t notify_data, intptr_t existing_stream) {
//flaw_line_below:
  // Stream already exists. This typically happens for range requests
//flaw_line_below:
  // initiated via NPN_RequestRead.
//flaw_line_below:
  if (existing_stream) {
//flaw_line_below:
    NPAPI::PluginStream* plugin_stream =
//flaw_line_below:
        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);
//flaw_line_below:

//flaw_line_below:
    return plugin_stream->AsResourceClient();
//flaw_line_below:
  }
//fix_flaw_line_below:
//    unsigned long resource_id, const GURL& url, int notify_id) {
//fix_flaw_line_below:
//  return instance()->CreateStream(
//fix_flaw_line_below:
//      resource_id, url, std::string(), notify_id);
//fix_flaw_line_below:
//}
 
//flaw_line_below:
  std::string mime_type;
//flaw_line_below:
  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(
//flaw_line_below:
      resource_id, url, mime_type, notify_needed,
//flaw_line_below:
      reinterpret_cast<void*>(notify_data));
//flaw_line_below:
  return stream;
//fix_flaw_line_below:
//WebPluginResourceClient* WebPluginDelegateImpl::CreateSeekableResourceClient(
//fix_flaw_line_below:
//    unsigned long resource_id, int range_request_id) {
//fix_flaw_line_below:
//  return instance()->GetRangeRequest(range_request_id);
 }
"
442,,,,,"CVE-2014-3176, CVE-2014-3177",,,,,,,,,,2014-08,,5.0,https://github.com/chromium/chromium/commit/2f663de43634c1197a7a2ed8afc12cb6dc565bd0,2f663de43634c1197a7a2ed8afc12cb6dc565bd0,"ozone: fix crash when running video decode unittests.

In GLSurfaceOzoneSurfacelessSurfaceImpl::Destroy, if the previous
context was NULL, do not make it current.

BUG=chromium:602921
TEST=Run vda unittests on oak.

Review URL: https://codereview.chromium.org/1887563002

Cr-Commit-Position: refs/heads/master@{#386988}",3.0,ui/gl/gl_surface_ozone.cc,"{""sha"": ""d4d2fe1ca4beb3f11397b95fa53b1ad2971c441b"", ""filename"": ""ui/gl/gl_surface_ozone.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/2f663de43634c1197a7a2ed8afc12cb6dc565bd0/ui/gl/gl_surface_ozone.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2f663de43634c1197a7a2ed8afc12cb6dc565bd0/ui/gl/gl_surface_ozone.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/gl/gl_surface_ozone.cc?ref=2f663de43634c1197a7a2ed8afc12cb6dc565bd0"", ""patch"": ""@@ -603,9 +603,11 @@ void GLSurfaceOzoneSurfacelessSurfaceImpl::Destroy() {\n   }\n \n   if (!was_current) {\n-    previous_context->MakeCurrent(previous_surface.get());\n-  } else {\n-    context_->ReleaseCurrent(this);\n+    if (previous_context) {\n+      previous_context->MakeCurrent(previous_surface.get());\n+    } else {\n+      context_->ReleaseCurrent(this);\n+    }\n   }\n }\n ""}",    previous_context->MakeCurrent(previous_surface.get());/~/  } else {/~/    context_->ReleaseCurrent(this);,"29,30,31","void GLSurfaceOzoneSurfacelessSurfaceImpl::Destroy() {
  if (!context_)
    return;
  scoped_refptr<gfx::GLContext> previous_context = gfx::GLContext::GetCurrent();
  scoped_refptr<gfx::GLSurface> previous_surface;

  bool was_current = previous_context && previous_context->IsCurrent(nullptr) &&
                     gfx::GLSurface::GetCurrent() == this;
  if (!was_current) {
    previous_surface = gfx::GLSurface::GetCurrent();
    context_->MakeCurrent(this);
  }

  glBindFramebufferEXT(GL_FRAMEBUFFER, 0);
  if (fbo_) {
    glDeleteTextures(arraysize(textures_), textures_);
    for (auto& texture : textures_)
      texture = 0;
    glDeleteFramebuffersEXT(1, &fbo_);
    fbo_ = 0;
  }
  for (auto image : images_) {
    if (image)
      image->Destroy(true);
   }
 
   if (!was_current) {
    if (previous_context) {
      previous_context->MakeCurrent(previous_surface.get());
    } else {
      context_->ReleaseCurrent(this);
    }
   }
 }
","void GLSurfaceOzoneSurfacelessSurfaceImpl::Destroy() {
  if (!context_)
    return;
  scoped_refptr<gfx::GLContext> previous_context = gfx::GLContext::GetCurrent();
  scoped_refptr<gfx::GLSurface> previous_surface;

  bool was_current = previous_context && previous_context->IsCurrent(nullptr) &&
                     gfx::GLSurface::GetCurrent() == this;
  if (!was_current) {
    previous_surface = gfx::GLSurface::GetCurrent();
    context_->MakeCurrent(this);
  }

  glBindFramebufferEXT(GL_FRAMEBUFFER, 0);
  if (fbo_) {
    glDeleteTextures(arraysize(textures_), textures_);
    for (auto& texture : textures_)
      texture = 0;
    glDeleteFramebuffersEXT(1, &fbo_);
    fbo_ = 0;
  }
  for (auto image : images_) {
    if (image)
      image->Destroy(true);
   }
 
   if (!was_current) {
    previous_context->MakeCurrent(previous_surface.get());
  } else {
    context_->ReleaseCurrent(this);
   }
 }
",185352.0,C,"    if (previous_context) {
      previous_context->MakeCurrent(previous_surface.get());
    } else {
      context_->ReleaseCurrent(this);
    }
","    previous_context->MakeCurrent(previous_surface.get());
  } else {
    context_->ReleaseCurrent(this);
",,"@@ -603,9 +603,11 @@ void GLSurfaceOzoneSurfacelessSurfaceImpl::Destroy() {
   }
 
   if (!was_current) {
-    previous_context->MakeCurrent(previous_surface.get());
-  } else {
-    context_->ReleaseCurrent(this);
+    if (previous_context) {
+      previous_context->MakeCurrent(previous_surface.get());
+    } else {
+      context_->ReleaseCurrent(this);
+    }
   }
 }
 ","void GLSurfaceOzoneSurfacelessSurfaceImpl::Destroy() {
if (!context_)
return;
scoped_refptr<gfx::GLContext> previous_context = gfx::GLContext::GetCurrent();
scoped_refptr<gfx::GLSurface> previous_surface;

bool was_current = previous_context && previous_context->IsCurrent(nullptr) &&
gfx::GLSurface::GetCurrent() == this;
if (!was_current) {
// Only take a reference to previous surface if it's not |this|
// because otherwise we can take a self reference from our own dtor.
previous_surface = gfx::GLSurface::GetCurrent();
context_->MakeCurrent(this);
}

glBindFramebufferEXT(GL_FRAMEBUFFER, 0);
if (fbo_) {
glDeleteTextures(arraysize(textures_), textures_);
for (auto& texture : textures_)
texture = 0;
glDeleteFramebuffersEXT(1, &fbo_);
fbo_ = 0;
}
for (auto image : images_) {
if (image)
image->Destroy(true);
}

if (!was_current) {
    previous_context->MakeCurrent(previous_surface.get());
  } else {
    context_->ReleaseCurrent(this);
}
}
",Chrome,2f663de43634c1197a7a2ed8afc12cb6dc565bd0,e35a5d8d7063a1feb552a3d517f600a071277285,1.0,"void GLSurfaceOzoneSurfacelessSurfaceImpl::Destroy() {
  if (!context_)
    return;
  scoped_refptr<gfx::GLContext> previous_context = gfx::GLContext::GetCurrent();
  scoped_refptr<gfx::GLSurface> previous_surface;

  bool was_current = previous_context && previous_context->IsCurrent(nullptr) &&
                     gfx::GLSurface::GetCurrent() == this;
  if (!was_current) {
    // Only take a reference to previous surface if it's not |this|
    // because otherwise we can take a self reference from our own dtor.
    previous_surface = gfx::GLSurface::GetCurrent();
    context_->MakeCurrent(this);
  }

  glBindFramebufferEXT(GL_FRAMEBUFFER, 0);
  if (fbo_) {
    glDeleteTextures(arraysize(textures_), textures_);
    for (auto& texture : textures_)
      texture = 0;
    glDeleteFramebuffersEXT(1, &fbo_);
    fbo_ = 0;
  }
  for (auto image : images_) {
    if (image)
      image->Destroy(true);
   }
 
   if (!was_current) {
//flaw_line_below:
    previous_context->MakeCurrent(previous_surface.get());
//flaw_line_below:
  } else {
//flaw_line_below:
    context_->ReleaseCurrent(this);
//fix_flaw_line_below:
//    if (previous_context) {
//fix_flaw_line_below:
//      previous_context->MakeCurrent(previous_surface.get());
//fix_flaw_line_below:
//    } else {
//fix_flaw_line_below:
//      context_->ReleaseCurrent(this);
//fix_flaw_line_below:
//    }
   }
 }
"
462,None,Local,Not required,Complete,CVE-2016-3137,https://www.cvedetails.com/cve/CVE-2016-3137/,,Low,None,None,,2016-05-02,4.9,"drivers/usb/serial/cypress_m8.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a USB device without both an interrupt-in and an interrupt-out endpoint descriptor, related to the cypress_generic_port_probe and cypress_open functions.",2016-11-30,DoS ,0.0,https://github.com/torvalds/linux/commit/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754,c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754,"USB: cypress_m8: add endpoint sanity check

An attack using missing endpoints exists.

CVE-2016-3137

Signed-off-by: Oliver Neukum <ONeukum@suse.com>
CC: stable@vger.kernel.org
Signed-off-by: Johan Hovold <johan@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",5.0,drivers/usb/serial/cypress_m8.c,"{""sha"": ""bbeeb2bd55a83cebf4cfec9b4b8f2876edde1ca0"", ""filename"": ""drivers/usb/serial/cypress_m8.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 6, ""changes"": 11, ""blob_url"": ""https://github.com/torvalds/linux/blob/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754/drivers/usb/serial/cypress_m8.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754/drivers/usb/serial/cypress_m8.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/serial/cypress_m8.c?ref=c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754"", ""patch"": ""@@ -447,6 +447,11 @@ static int cypress_generic_port_probe(struct usb_serial_port *port)\n \tstruct usb_serial *serial = port->serial;\n \tstruct cypress_private *priv;\n \n+\tif (!port->interrupt_out_urb || !port->interrupt_in_urb) {\n+\t\tdev_err(&port->dev, \""required endpoint is missing\\n\"");\n+\t\treturn -ENODEV;\n+\t}\n+\n \tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n \tif (!priv)\n \t\treturn -ENOMEM;\n@@ -606,12 +611,6 @@ static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)\n \t\tcypress_set_termios(tty, port, &priv->tmp_termios);\n \n \t/* setup the port and start reading from the device */\n-\tif (!port->interrupt_in_urb) {\n-\t\tdev_err(&port->dev, \""%s - interrupt_in_urb is empty!\\n\"",\n-\t\t\t__func__);\n-\t\treturn -1;\n-\t}\n-\n \tusb_fill_int_urb(port->interrupt_in_urb, serial->dev,\n \t\tusb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),\n \t\tport->interrupt_in_urb->transfer_buffer,""}","	if (!port->interrupt_in_urb) {/~/		dev_err(&port->dev, ""%s - interrupt_in_urb is empty!\n"",/~/			__func__);/~/		return -1;/~/	}","29,30,31,32,33","static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct cypress_private *priv = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;
	unsigned long flags;
	int result = 0;

	if (!priv->comm_is_ok)
		return -EIO;

	/* clear halts before open */
	usb_clear_halt(serial->dev, 0x81);
	usb_clear_halt(serial->dev, 0x02);

	spin_lock_irqsave(&priv->lock, flags);
	/* reset read/write statistics */
	priv->bytes_in = 0;
	priv->bytes_out = 0;
	priv->cmd_count = 0;
	priv->rx_flags = 0;
	spin_unlock_irqrestore(&priv->lock, flags);

	/* Set termios */
	cypress_send(port);

	if (tty)
 		cypress_set_termios(tty, port, &priv->tmp_termios);
 
 	/* setup the port and start reading from the device */
 	usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
 		usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
 		port->interrupt_in_urb->transfer_buffer,
		port->interrupt_in_urb->transfer_buffer_length,
		cypress_read_int_callback, port, priv->read_urb_interval);
	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);

	if (result) {
		dev_err(&port->dev,
			""%s - failed submitting read urb, error %d\n"",
							__func__, result);
		cypress_set_dead(port);
	}

	return result;
} /* cypress_open */
","static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct cypress_private *priv = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;
	unsigned long flags;
	int result = 0;

	if (!priv->comm_is_ok)
		return -EIO;

	/* clear halts before open */
	usb_clear_halt(serial->dev, 0x81);
	usb_clear_halt(serial->dev, 0x02);

	spin_lock_irqsave(&priv->lock, flags);
	/* reset read/write statistics */
	priv->bytes_in = 0;
	priv->bytes_out = 0;
	priv->cmd_count = 0;
	priv->rx_flags = 0;
	spin_unlock_irqrestore(&priv->lock, flags);

	/* Set termios */
	cypress_send(port);

	if (tty)
 		cypress_set_termios(tty, port, &priv->tmp_termios);
 
 	/* setup the port and start reading from the device */
	if (!port->interrupt_in_urb) {
		dev_err(&port->dev, ""%s - interrupt_in_urb is empty!\n"",
			__func__);
		return -1;
	}
 	usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
 		usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
 		port->interrupt_in_urb->transfer_buffer,
		port->interrupt_in_urb->transfer_buffer_length,
		cypress_read_int_callback, port, priv->read_urb_interval);
	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);

	if (result) {
		dev_err(&port->dev,
			""%s - failed submitting read urb, error %d\n"",
							__func__, result);
		cypress_set_dead(port);
	}

	return result;
} /* cypress_open */
",180532.0,C,,"	if (!port->interrupt_in_urb) {
		dev_err(&port->dev, ""%s - interrupt_in_urb is empty!\n"",
			__func__);
		return -1;
	}
",,"@@ -447,6 +447,11 @@ static int cypress_generic_port_probe(struct usb_serial_port *port)
 	struct usb_serial *serial = port->serial;
 	struct cypress_private *priv;
 
+	if (!port->interrupt_out_urb || !port->interrupt_in_urb) {
+		dev_err(&port->dev, ""required endpoint is missing\n"");
+		return -ENODEV;
+	}
+
 	priv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
@@ -606,12 +611,6 @@ static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
 		cypress_set_termios(tty, port, &priv->tmp_termios);
 
 	/* setup the port and start reading from the device */
-	if (!port->interrupt_in_urb) {
-		dev_err(&port->dev, ""%s - interrupt_in_urb is empty!\n"",
-			__func__);
-		return -1;
-	}
-
 	usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
 		usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
 		port->interrupt_in_urb->transfer_buffer,","static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
{
struct cypress_private *priv = usb_get_serial_port_data(port);
struct usb_serial *serial = port->serial;
unsigned long flags;
int result = 0;

if (!priv->comm_is_ok)
return -EIO;

/* clear halts before open */
usb_clear_halt(serial->dev, 0x81);
usb_clear_halt(serial->dev, 0x02);

spin_lock_irqsave(&priv->lock, flags);
/* reset read/write statistics */
priv->bytes_in = 0;
priv->bytes_out = 0;
priv->cmd_count = 0;
priv->rx_flags = 0;
spin_unlock_irqrestore(&priv->lock, flags);

/* Set termios */
cypress_send(port);

if (tty)
cypress_set_termios(tty, port, &priv->tmp_termios);

/* setup the port and start reading from the device */
	if (!port->interrupt_in_urb) {
		dev_err(&port->dev, ""%s - interrupt_in_urb is empty!\n"",
			__func__);
		return -1;
	}
usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
port->interrupt_in_urb->transfer_buffer,
port->interrupt_in_urb->transfer_buffer_length,
cypress_read_int_callback, port, priv->read_urb_interval);
result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);

if (result) {
dev_err(&port->dev,
""%s - failed submitting read urb, error %d\n"",
__func__, result);
cypress_set_dead(port);
}

return result;
} /* cypress_open */
",linux,c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754,4e9a0b05257f29cf4b75f3209243ed71614d062e,1.0,"static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct cypress_private *priv = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;
	unsigned long flags;
	int result = 0;

	if (!priv->comm_is_ok)
		return -EIO;

	/* clear halts before open */
	usb_clear_halt(serial->dev, 0x81);
	usb_clear_halt(serial->dev, 0x02);

	spin_lock_irqsave(&priv->lock, flags);
	/* reset read/write statistics */
	priv->bytes_in = 0;
	priv->bytes_out = 0;
	priv->cmd_count = 0;
	priv->rx_flags = 0;
	spin_unlock_irqrestore(&priv->lock, flags);

	/* Set termios */
	cypress_send(port);

	if (tty)
 		cypress_set_termios(tty, port, &priv->tmp_termios);
 
 	/* setup the port and start reading from the device */
//flaw_line_below:
	if (!port->interrupt_in_urb) {
//flaw_line_below:
		dev_err(&port->dev, ""%s - interrupt_in_urb is empty!\n"",
//flaw_line_below:
			__func__);
//flaw_line_below:
		return -1;
//flaw_line_below:
	}
//flaw_line_below:

 	usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
 		usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
 		port->interrupt_in_urb->transfer_buffer,
		port->interrupt_in_urb->transfer_buffer_length,
		cypress_read_int_callback, port, priv->read_urb_interval);
	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);

	if (result) {
		dev_err(&port->dev,
			""%s - failed submitting read urb, error %d\n"",
							__func__, result);
		cypress_set_dead(port);
	}

	return result;
} /* cypress_open */
"
499,None,Local,Not required,Partial,CVE-2010-1172,https://www.cvedetails.com/cve/CVE-2010-1172/,CWE-264,Low,None,Partial,,2010-08-20,3.6,"DBus-GLib 0.73 disregards the access flag of exported GObject properties, which allows local users to bypass intended access restrictions and possibly cause a denial of service by modifying properties, as demonstrated by properties of the (1) DeviceKit-Power, (2) NetworkManager, and (3) ModemManager services.",2017-08-16,DoS Bypass,0.0,https://cgit.freedesktop.org/dbus/dbus-glib/commit/?h=rhel5&id=9a6bce9b615abca6068348c1606ba8eaf13d9ae0,9a6bce9b615abca6068348c1606ba8eaf13d9ae0,,8.0,,,"                                GHashTable **out, GError **error)/~/{/~/  *out = g_hash_table_new_full (g_str_hash, g_str_equal,/~/				(GDestroyNotify) g_free,/~/                                (GDestroyNotify) g_hash_table_destroy);/~/  g_hash_table_foreach (in, hash_foreach_mangle_dict_of_strings, *out);/~/  return TRUE;/~/}","1,2,3,4,5,6,7,8","my_object_dict_of_dicts (MyObject *obj, GHashTable *in,
","my_object_dict_of_dicts (MyObject *obj, GHashTable *in,
                                GHashTable **out, GError **error)
{
  *out = g_hash_table_new_full (g_str_hash, g_str_equal,
				(GDestroyNotify) g_free,
                                (GDestroyNotify) g_hash_table_destroy);
  g_hash_table_foreach (in, hash_foreach_mangle_dict_of_strings, *out);
  return TRUE;
}
",178263.0,C,,"                                GHashTable **out, GError **error)
{
  *out = g_hash_table_new_full (g_str_hash, g_str_equal,
				(GDestroyNotify) g_free,
                                (GDestroyNotify) g_hash_table_destroy);
  g_hash_table_foreach (in, hash_foreach_mangle_dict_of_strings, *out);
  return TRUE;
}
",9ebe54e7ec35b5781ab48b3a9efbc4bef5867eeb,"@@ -10,837 +10,12 @@
 #include <glib/gi18n.h>
 #include <glib-object.h>
 #include <glib/gquark.h>
-#include ""my-object-marshal.h""
 
-typedef struct MyObject MyObject;
-typedef struct MyObjectClass MyObjectClass;
-
-GType my_object_get_type (void);
-
-struct MyObject
-{
-  GObject parent;
-  char *this_is_a_string;
-  guint val;
-};
-
-struct MyObjectClass
-{
-  GObjectClass parent;
-};
-
-#define MY_TYPE_OBJECT              (my_object_get_type ())
-#define MY_OBJECT(object)           (G_TYPE_CHECK_INSTANCE_CAST ((object), MY_TYPE_OBJECT, MyObject))
-#define MY_OBJECT_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), MY_TYPE_OBJECT, MyObjectClass))
-#define MY_IS_OBJECT(object)        (G_TYPE_CHECK_INSTANCE_TYPE ((object), MY_TYPE_OBJECT))
-#define MY_IS_OBJECT_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), MY_TYPE_OBJECT))
-#define MY_OBJECT_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS ((obj), MY_TYPE_OBJECT, MyObjectClass))
-
-G_DEFINE_TYPE(MyObject, my_object, G_TYPE_OBJECT)
-
-typedef enum
-{
-  MY_OBJECT_ERROR_FOO,
-  MY_OBJECT_ERROR_BAR
-} MyObjectError;
-
-#define MY_OBJECT_ERROR (my_object_error_quark ())
-
-#define MY_TYPE_ERROR (my_object_error_get_type ()) 
-
-gboolean my_object_do_nothing (MyObject *obj, GError **error);
-
-gboolean my_object_increment (MyObject *obj, gint32 x, gint32 *ret, GError **error);
-
-gint32   my_object_increment_retval (MyObject *obj, gint32 x);
-
-gint32   my_object_increment_retval_error (MyObject *obj, gint32 x, GError **error);
-
-gboolean my_object_throw_error (MyObject *obj, GError **error);
-
-gboolean my_object_uppercase (MyObject *obj, const char *str, char **ret, GError **error);
-
-gboolean my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **str_ret, GError **error);
-
-gboolean my_object_many_return (MyObject *obj, guint32 *arg0, char **arg1, gint32 *arg2, guint32 *arg3, guint32 *arg4, const char **arg5, GError **error);
-
-gboolean my_object_recursive1 (MyObject *obj, GArray *array, guint32 *len_ret, GError **error);
-gboolean my_object_recursive2 (MyObject *obj, guint32 reqlen, GArray **array, GError **error);
-
-gboolean my_object_many_stringify (MyObject *obj, GHashTable *vals, GHashTable **ret, GError **error);
-
-gboolean my_object_rec_arrays (MyObject *obj, GPtrArray *in, GPtrArray **ret, GError **error);
-
-gboolean my_object_objpath (MyObject *obj, const char *in, const char **arg1, GError **error);
-
-gboolean my_object_get_objs (MyObject *obj, GPtrArray **objs, GError **error);
-
-gboolean my_object_stringify (MyObject *obj, GValue *value, char **ret, GError **error);
-gboolean my_object_unstringify (MyObject *obj, const char *str, GValue *value, GError **error);
-
-gboolean my_object_many_uppercase (MyObject *obj, const char * const *in, char ***out, GError **error);
-
-gboolean my_object_str_hash_len (MyObject *obj, GHashTable *table, guint *len, GError **error);
-
-gboolean my_object_send_car (MyObject *obj, GValueArray *invals, GValueArray **outvals, GError **error);
-
-gboolean my_object_get_hash (MyObject *obj, GHashTable **table, GError **error);
-
-gboolean my_object_increment_val (MyObject *obj, GError **error);
-
-gboolean my_object_get_val (MyObject *obj, guint *ret, GError **error);
-
-gboolean my_object_get_value (MyObject *obj, guint *ret, GError **error);
-
-gboolean my_object_emit_signals (MyObject *obj, GError **error);
-gboolean my_object_emit_signal2 (MyObject *obj, GError **error);
-
-gboolean my_object_emit_frobnicate (MyObject *obj, GError **error);
-
-gboolean my_object_echo_variant (MyObject *obj, GValue *variant, GValue *ret, GError **error);
-
-gboolean my_object_process_variant_of_array_of_ints123 (MyObject *obj, GValue *variant, GError **error);
-
-gboolean my_object_dict_of_dicts (MyObject *obj, GHashTable *dict, GHashTable **ret, GError **error);
-
-gboolean my_object_terminate (MyObject *obj, GError **error);
-
-void my_object_async_increment (MyObject *obj, gint32 x, DBusGMethodInvocation *context);
-
-void my_object_async_throw_error (MyObject *obj, DBusGMethodInvocation *context);
-
-#include ""test-service-glib-glue.h""
-
-GQuark my_object_error_quark (void);
-
-GType my_object_error_get_type (void);
-
-/* Properties */
-enum
-{
-  PROP_0,
-  PROP_THIS_IS_A_STRING
-};
-
-enum
-{
-  FROBNICATE,
-  SIG0,
-  SIG1,
-  SIG2,
-  LAST_SIGNAL
-};
-
-static guint signals[LAST_SIGNAL] = { 0 };
-
-static void
-my_object_finalize (GObject *object)
-{
-  MyObject *mobject = MY_OBJECT (object);
-
-  g_free (mobject->this_is_a_string);
-
-  (G_OBJECT_CLASS (my_object_parent_class)->finalize) (object);
-}
-
-static void
-my_object_set_property (GObject      *object,
-                        guint         prop_id,
-                        const GValue *value,
-                        GParamSpec   *pspec)
-{
-  MyObject *mobject;
-
-  mobject = MY_OBJECT (object);
-  
-  switch (prop_id)
-    {
-    case PROP_THIS_IS_A_STRING:
-      g_free (mobject->this_is_a_string);
-      mobject->this_is_a_string = g_value_dup_string (value);
-      break;
-      
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-    }
-}
-
-static void
-my_object_get_property (GObject      *object,
-                        guint         prop_id,
-                        GValue       *value,
-                        GParamSpec   *pspec)
-{
-  MyObject *mobject;
-
-  mobject = MY_OBJECT (object);
-  
-  switch (prop_id)
-    {
-    case PROP_THIS_IS_A_STRING:
-      g_value_set_string (value, mobject->this_is_a_string);
-      break;
-      
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-    }
-}
-
-static void
-my_object_init (MyObject *obj)
-{
-  obj->val = 0;
-}
-
-static void
-my_object_class_init (MyObjectClass *mobject_class)
-{
-  GObjectClass *gobject_class = G_OBJECT_CLASS (mobject_class);
-
-  gobject_class->finalize = my_object_finalize;
-  gobject_class->set_property = my_object_set_property;
-  gobject_class->get_property = my_object_get_property;
-  
-  g_object_class_install_property (gobject_class,
-				   PROP_THIS_IS_A_STRING,
-				   g_param_spec_string (""this_is_a_string"",
-                                                        _(""Sample string""),
-                                                        _(""Example of a string property""),
-                                                        ""default value"",
-                                                        G_PARAM_READWRITE));
-  signals[FROBNICATE] =
-    g_signal_new (""frobnicate"",
-		  G_OBJECT_CLASS_TYPE (mobject_class),
-                  G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
-                  0,
-                  NULL, NULL,
-                  g_cclosure_marshal_VOID__INT,
-                  G_TYPE_NONE, 1, G_TYPE_INT);
-
-  signals[SIG0] =
-    g_signal_new (""sig0"",
-		  G_OBJECT_CLASS_TYPE (mobject_class),
-                  G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
-                  0,
-                  NULL, NULL,
-                  my_object_marshal_VOID__STRING_INT_STRING,
-                  G_TYPE_NONE, 3, G_TYPE_STRING, G_TYPE_INT, G_TYPE_STRING);
-
-  signals[SIG1] =
-    g_signal_new (""sig1"",
-		  G_OBJECT_CLASS_TYPE (mobject_class),
-                  G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
-                  0,
-                  NULL, NULL,
-                  my_object_marshal_VOID__STRING_BOXED,
-                  G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_VALUE);
-
-  signals[SIG2] =
-    g_signal_new (""sig2"",
-		  G_OBJECT_CLASS_TYPE (mobject_class),
-                  G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
-                  0,
-                  NULL, NULL,
-                  g_cclosure_marshal_VOID__BOXED,
-                  G_TYPE_NONE, 1, DBUS_TYPE_G_STRING_STRING_HASHTABLE);
-}
-
-GQuark
-my_object_error_quark (void)
-{
-  static GQuark quark = 0;
-  if (!quark)
-    quark = g_quark_from_static_string (""my_object_error"");
-
-  return quark;
-}
-
-/* This should really be standard. */
-#define ENUM_ENTRY(NAME, DESC) { NAME, """" #NAME """", DESC }
-
-GType
-my_object_error_get_type (void)
-{
-	static GType etype = 0;
-
-	if (etype == 0)
-	{
-		static const GEnumValue values[] =
-		{
-
-			ENUM_ENTRY (MY_OBJECT_ERROR_FOO, ""Foo""),
-			ENUM_ENTRY (MY_OBJECT_ERROR_BAR, ""Bar""),
-			{ 0, 0, 0 }
-		};
-
-		etype = g_enum_register_static (""MyObjectError"", values);
-	}
-
-	return etype;
-}
+#include ""my-object.h""
 
 static GObject *obj;
 static GObject *obj2;
-
-gboolean
-my_object_do_nothing (MyObject *obj, GError **error)
-{
-  return TRUE;
-}
-
-gboolean
-my_object_increment (MyObject *obj, gint32 x, gint32 *ret, GError **error)
-{
-  *ret = x +1;
-  return TRUE;
-}
-
-gint32
-my_object_increment_retval (MyObject *obj, gint32 x)
-{
-  return x + 1;
-}
-
-gint32
-my_object_increment_retval_error (MyObject *obj, gint32 x, GError **error)
-{
-  if (x + 1 > 10)
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   ""%s"",
-		   ""x is bigger than 9"");    
-      return FALSE;
-    }
-  return x + 1;
-}
-
-gboolean
-my_object_throw_error (MyObject *obj, GError **error)
-{
-  g_set_error (error,
-	       MY_OBJECT_ERROR,
-	       MY_OBJECT_ERROR_FOO,
-	       ""%s"",
-	       ""this method always loses"");    
-  return FALSE;
-}
-
-gboolean
-my_object_uppercase (MyObject *obj, const char *str, char **ret, GError **error)
-{
-  *ret = g_ascii_strup (str, -1);
-  return TRUE;
-}
-
-gboolean
-my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **str_ret, GError **error)
-{
-  *d_ret = trouble + (x * 2);
-  *str_ret = g_ascii_strup (str, -1);
-  return TRUE;
-}
-
-gboolean
-my_object_many_return (MyObject *obj, guint32 *arg0, char **arg1, gint32 *arg2, guint32 *arg3, guint32 *arg4, const char **arg5, GError **error)
-{
-  *arg0 = 42;
-  *arg1 = g_strdup (""42"");
-  *arg2 = -67;
-  *arg3 = 2;
-  *arg4 = 26;
-  *arg5 = ""hello world""; /* Annotation specifies as const */
-  return TRUE;
-}
-
-gboolean
-my_object_stringify (MyObject *obj, GValue *value, char **ret, GError **error)
-{
-  GValue valstr = {0, };
-
-  g_value_init (&valstr, G_TYPE_STRING);
-  if (!g_value_transform (value, &valstr))
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   ""couldn't transform value"");
-      return FALSE;
-    }
-  *ret = g_value_dup_string (&valstr);
-  g_value_unset (&valstr);
-  return TRUE;
-}
-
-gboolean
-my_object_unstringify (MyObject *obj, const char *str, GValue *value, GError **error)
-{
-  if (str[0] == '\0' || !g_ascii_isdigit (str[0])) {
-    g_value_init (value, G_TYPE_STRING);
-    g_value_set_string (value, str);
-  } else {
-    g_value_init (value, G_TYPE_INT);
-    g_value_set_int (value, (int) g_ascii_strtoull (str, NULL, 10));
-  } 
-  return TRUE;
-}
-
-gboolean
-my_object_recursive1 (MyObject *obj, GArray *array, guint32 *len_ret, GError **error)
-{
-  *len_ret = array->len;
-  return TRUE;
-}
-
-gboolean
-my_object_recursive2 (MyObject *obj, guint32 reqlen, GArray **ret, GError **error)
-{
-  guint32 val;
-  GArray *array;
-  
-  array = g_array_new (FALSE, TRUE, sizeof (guint32));
-
-  while (reqlen > 0) {
-    val = 42;
-    g_array_append_val (array, val);
-    val = 26;
-    g_array_append_val (array, val);
-    reqlen--;
-  }
-  val = 2;
-  g_array_append_val (array, val);
-  *ret = array;
-  return TRUE;
-}
-
-gboolean
-my_object_many_uppercase (MyObject *obj, const char * const *in, char ***out, GError **error)
-{
-  int len;
-  int i;
-
-  len = g_strv_length ((char**) in);
-
-  *out = g_new0 (char *, len + 1);
-  for (i = 0; i < len; i++)
-    {
-      (*out)[i] = g_ascii_strup (in[i], -1);
-    }
-  (*out)[i] = NULL;
-  
-  return TRUE;
-}
-
-static void
-hash_foreach_stringify (gpointer key, gpointer val, gpointer user_data)
-{
-  const char *keystr = key;
-  const GValue *value = val;
-  GValue *sval;
-  GHashTable *ret = user_data;
-
-  sval = g_new0 (GValue, 1);
-  g_value_init (sval, G_TYPE_STRING);
-  if (!g_value_transform (value, sval))
-    g_assert_not_reached ();
-
-  g_hash_table_insert (ret, g_strdup (keystr), sval);
-}
-
-static void
-unset_and_free_gvalue (gpointer val)
-{
-  g_value_unset (val);
-  g_free (val);
-}
-
-gboolean
-my_object_many_stringify (MyObject *obj, GHashTable /* char * -> GValue * */ *vals, GHashTable /* char * -> GValue * */ **ret, GError **error)
-{
-  *ret = g_hash_table_new_full (g_str_hash, g_str_equal,
-				g_free, unset_and_free_gvalue);
-  g_hash_table_foreach (vals, hash_foreach_stringify, *ret);
-  return TRUE;
-}
-
-gboolean
-my_object_rec_arrays (MyObject *obj, GPtrArray *in, GPtrArray **ret, GError **error)
-{
-  char **strs;
-  GArray *ints;
-  guint v_UINT;
-  
-  if (in->len != 2)
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   ""invalid array len"");
-      return FALSE;
-    }
-  
-  strs = g_ptr_array_index (in, 0);
-  if (!*strs || strcmp (*strs, ""foo""))
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   ""invalid string 0"");
-      return FALSE;
-    }
-  strs++;
-  if (!*strs || strcmp (*strs, ""bar""))
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   ""invalid string 1"");
-      return FALSE;
-    }
-  strs++;
-  if (*strs)
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   ""invalid string array len in pos 0"");
-      return FALSE;
-    }
-  strs = g_ptr_array_index (in, 1);
-  if (!*strs || strcmp (*strs, ""baz""))
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   ""invalid string 0"");
-      return FALSE;
-    }
-  strs++;
-  if (!*strs || strcmp (*strs, ""whee""))
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   ""invalid string 1"");
-      return FALSE;
-    }
-  strs++;
-  if (!*strs || strcmp (*strs, ""moo""))
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   ""invalid string 2"");
-      return FALSE;
-    }
-  strs++;
-  if (*strs)
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   ""invalid string array len in pos 1"");
-      return FALSE;
-    }
-
-  *ret = g_ptr_array_new ();
-
-  ints = g_array_new (TRUE, TRUE, sizeof (guint));
-  v_UINT = 10;
-  g_array_append_val (ints, v_UINT);
-  v_UINT = 42;
-  g_array_append_val (ints, v_UINT);
-  v_UINT = 27;
-  g_array_append_val (ints, v_UINT);
-  g_ptr_array_add (*ret, ints);
-
-  ints = g_array_new (TRUE, TRUE, sizeof (guint));
-  v_UINT = 30;
-  g_array_append_val (ints, v_UINT);
-  g_ptr_array_add (*ret, ints);
-  return TRUE;
-}
-
-gboolean
-my_object_objpath (MyObject *obj, const char *incoming, const char **outgoing, GError **error)
-{
-  if (strcmp (incoming, ""/org/freedesktop/DBus/GLib/Tests/MyTestObject""))
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   ""invalid incoming object"");
-      return FALSE;
-    }
-  *outgoing = ""/org/freedesktop/DBus/GLib/Tests/MyTestObject2"";
-  return TRUE;
-}
-
-gboolean
-my_object_get_objs (MyObject *obj, GPtrArray **objs, GError **error)
-{
-  *objs = g_ptr_array_new ();
-
-  g_ptr_array_add (*objs, g_strdup (""/org/freedesktop/DBus/GLib/Tests/MyTestObject""));
-  g_ptr_array_add (*objs, g_strdup (""/org/freedesktop/DBus/GLib/Tests/MyTestObject2""));
-
-  return TRUE;
-}
-
-static void
-hash_foreach (gpointer key, gpointer val, gpointer user_data)
-{
-  const char *keystr = key;
-  const char *valstr = val;
-  guint *count = user_data;
-
-  *count += (strlen (keystr) + strlen (valstr));
-  g_print (""%s -> %s\n"", keystr, valstr);
-}
-
-gboolean
-my_object_str_hash_len (MyObject *obj, GHashTable *table, guint *len, GError **error)
-{
-  *len = 0;
-  g_hash_table_foreach (table, hash_foreach, len);
-  return TRUE;
-}
-
-gboolean
-my_object_send_car (MyObject *obj, GValueArray *invals, GValueArray **outvals, GError **error)
-{
-  if (invals->n_values != 3
-      || G_VALUE_TYPE (g_value_array_get_nth (invals, 0)) != G_TYPE_STRING
-      || G_VALUE_TYPE (g_value_array_get_nth (invals, 1)) != G_TYPE_UINT
-      || G_VALUE_TYPE (g_value_array_get_nth (invals, 2)) != G_TYPE_VALUE)
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   ""invalid incoming values"");
-      return FALSE;
-    }
-  *outvals = g_value_array_new (2);
-  g_value_array_append (*outvals, NULL);
-  g_value_init (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1), G_TYPE_UINT);
-  g_value_set_uint (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1),
-		    g_value_get_uint (g_value_array_get_nth (invals, 1)) + 1);
-  g_value_array_append (*outvals, NULL);
-  g_value_init (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1), DBUS_TYPE_G_OBJECT_PATH);
-  g_value_set_boxed (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1),
-		     g_strdup (""/org/freedesktop/DBus/GLib/Tests/MyTestObject2""));
-  return TRUE;
-}
-
-gboolean
-my_object_get_hash (MyObject *obj, GHashTable **ret, GError **error)
-{
-  GHashTable *table;
-
-  table = g_hash_table_new (g_str_hash, g_str_equal);
-  g_hash_table_insert (table, ""foo"", ""bar"");
-  g_hash_table_insert (table, ""baz"", ""whee"");
-  g_hash_table_insert (table, ""cow"", ""crack"");
-  *ret = table;
-  return TRUE;
-}
-
-gboolean
-my_object_increment_val (MyObject *obj, GError **error)
-{
-  obj->val++;
-  return TRUE;
-}
-
-gboolean
-my_object_get_val (MyObject *obj, guint *ret, GError **error)
-{
-  *ret = obj->val;
-  return TRUE;
-}
-
-gboolean
-my_object_get_value (MyObject *obj, guint *ret, GError **error)
-{
-  *ret = obj->val;
-  return TRUE;
-}
-
-gboolean
-my_object_echo_variant (MyObject *obj, GValue *variant, GValue *ret, GError **error)
-{
-    GType t;
-    t = G_VALUE_TYPE(variant);
-    g_value_init (ret, t);
-    g_value_copy (variant, ret);
-
-    return TRUE;
-}
-
-gboolean 
-my_object_process_variant_of_array_of_ints123 (MyObject *obj, GValue *variant, GError **error)
-{
-  GArray *array;
-  int i;
-  int j;
-
-  j = 0;
-
-  array = (GArray *)g_value_get_boxed (variant);
-
-  for (i = 0; i <= 2; i++)
-    {
-      j = g_array_index (array, int, i);
-      if (j != i + 1)
-        goto error;
-    }
-
-  return TRUE;
-
-error:
-  *error = g_error_new (MY_OBJECT_ERROR,
-		       MY_OBJECT_ERROR_FOO,
-		       ""Error decoding a variant of type ai (i + 1 = %i, j = %i)"",
-		       i, j + 1);
-  return FALSE;
-}
-
-
-typedef struct _HashAndString HashAndString;
-
-struct _HashAndString
-{
-  GHashTable *hash;
-  gchar* string;
-};
-
-static void
-hash_foreach_prepend_string (gpointer key, gpointer val, gpointer user_data)
-{
-  HashAndString *data = (HashAndString*) user_data;
-  gchar *in = (gchar*) val;
-  g_hash_table_insert (data->hash, g_strdup ((gchar*) key),
-                       g_strjoin ("" "", data->string, in, NULL));
-}
-
-
-static void
-hash_foreach_mangle_dict_of_strings (gpointer key, gpointer val, gpointer user_data)
-{
-  GHashTable *out = (GHashTable*) user_data;
-  GHashTable *in_dict = (GHashTable *) val;
-  HashAndString *data = g_new0 (HashAndString, 1);
-
-  data->string = (gchar*) key;
-  data->hash = g_hash_table_new_full (g_str_hash, g_str_equal,
-                                            g_free, g_free);
-  g_hash_table_foreach (in_dict, hash_foreach_prepend_string, data);
-
-  g_hash_table_insert(out, g_strdup ((gchar*) key), data->hash);
-}
-
-gboolean
-my_object_dict_of_dicts (MyObject *obj, GHashTable *in,
-                                GHashTable **out, GError **error)
-{
-  *out = g_hash_table_new_full (g_str_hash, g_str_equal,
-				(GDestroyNotify) g_free,
-                                (GDestroyNotify) g_hash_table_destroy);
-  g_hash_table_foreach (in, hash_foreach_mangle_dict_of_strings, *out);
-  return TRUE;
-}
-
-gboolean
-my_object_emit_frobnicate (MyObject *obj, GError **error)
-{
-  g_signal_emit (obj, signals[FROBNICATE], 0, 42);
-  return TRUE;
-}
-
-gboolean
-my_object_emit_signals (MyObject *obj, GError **error)
-{
-  GValue val = {0, };
-
-  g_signal_emit (obj, signals[SIG0], 0, ""foo"", 22, ""moo"");
-
-  g_value_init (&val, G_TYPE_STRING);
-  g_value_set_string (&val, ""bar"");
-  g_signal_emit (obj, signals[SIG1], 0, ""baz"", &val);
-  g_value_unset (&val);
-
-  return TRUE;
-}
-
-gboolean
-my_object_emit_signal2 (MyObject *obj, GError **error)
-{
-  GHashTable *table;
-
-  table = g_hash_table_new (g_str_hash, g_str_equal);
-  g_hash_table_insert (table, ""baz"", ""cow"");
-  g_hash_table_insert (table, ""bar"", ""foo"");
-  g_signal_emit (obj, signals[SIG2], 0, table);
-  g_hash_table_destroy (table);
-  return TRUE;
-}
-
-typedef struct {
-  gint32 x;
-  DBusGMethodInvocation *context;
-} IncrementData;
-
-static gboolean
-do_async_increment (IncrementData *data)
-{
-  gint32 newx = data->x + 1;
-  dbus_g_method_return (data->context, newx);
-  g_free (data);
-  return FALSE;
-}
-
-void
-my_object_async_increment (MyObject *obj, gint32 x, DBusGMethodInvocation *context)
-{
-  IncrementData *data = g_new0 (IncrementData, 1);
-  data->x = x;
-  data->context = context;
-  g_idle_add ((GSourceFunc)do_async_increment, data);
-}
-
-static gboolean
-do_async_error (IncrementData *data)
-{
-  GError *error;
-  error = g_error_new (MY_OBJECT_ERROR,
-		       MY_OBJECT_ERROR_FOO,
-		       ""%s"",
-		       ""this method always loses"");
-  dbus_g_method_return_error (data->context, error);
-  g_free (data);
-  return FALSE;
-}
-
-void
-my_object_async_throw_error (MyObject *obj, DBusGMethodInvocation *context)
-{
-  IncrementData *data = g_new0(IncrementData, 1);
-  data->context = context;
-  g_idle_add ((GSourceFunc)do_async_error,  data);
-}
-
-
-static GMainLoop *loop;
-
-gboolean
-my_object_terminate (MyObject *obj, GError **error)
-{
-  g_main_loop_quit (loop);
-  return TRUE;
-}
+GMainLoop *loop;
 
 #define TEST_SERVICE_NAME ""org.freedesktop.DBus.GLib.TestService""
 
@@ -855,9 +30,6 @@ main (int argc, char **argv)
   g_type_init ();
   g_thread_init (NULL); dbus_g_thread_init ();
 
-  dbus_g_object_type_install_info (MY_TYPE_OBJECT,
-				   &dbus_glib_my_object_object_info);
-
   dbus_g_error_domain_register (MY_OBJECT_ERROR,
 				NULL,
 				MY_TYPE_ERROR);","my_object_dict_of_dicts (MyObject *obj, GHashTable *in,
                                GHashTable **out, GError **error)
{
  *out = g_hash_table_new_full (g_str_hash, g_str_equal,
				(GDestroyNotify) g_free,
                                (GDestroyNotify) g_hash_table_destroy);
  g_hash_table_foreach (in, hash_foreach_mangle_dict_of_strings, *out);
  return TRUE;
}
",dbus,https://cgit.freedesktop.org/dbus/dbus-glib/tree/test/core/test-service-glib.c?h=rhel5&id=9a6bce9b615abca6068348c1606ba8eaf13d9ae0,https://cgit.freedesktop.org/dbus/dbus-glib/tree/test/core/test-service-glib.c?h=rhel5&id=9ebe54e7ec35b5781ab48b3a9efbc4bef5867eeb,1.0,"my_object_dict_of_dicts (MyObject *obj, GHashTable *in,
//flaw_line_below:
                                GHashTable **out, GError **error)
//flaw_line_below:
{
//flaw_line_below:
  *out = g_hash_table_new_full (g_str_hash, g_str_equal,
//flaw_line_below:
				(GDestroyNotify) g_free,
//flaw_line_below:
                                (GDestroyNotify) g_hash_table_destroy);
//flaw_line_below:
  g_hash_table_foreach (in, hash_foreach_mangle_dict_of_strings, *out);
//flaw_line_below:
  return TRUE;
//flaw_line_below:
}
"
562,None,Local,Not required,Complete,CVE-2015-8539,https://www.cvedetails.com/cve/CVE-2015-8539/,CWE-264,Low,Complete,Complete,,2016-02-07,7.2,"The KEYS subsystem in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (BUG) via crafted keyctl commands that negatively instantiate a key, related to security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c, and security/keys/user_defined.c.",2018-10-30,DoS +Priv ,4.0,https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd,096fe9eaea40a17e125569f9e657e34cdb6d73bd,"KEYS: Fix handling of stored error in a negatively instantiated user key

If a user key gets negatively instantiated, an error code is cached in the
payload area.  A negatively instantiated key may be then be positively
instantiated by updating it with valid data.  However, the ->update key
type method must be aware that the error code may be there.

The following may be used to trigger the bug in the user key type:

    keyctl request2 user user """" @u
    keyctl add user user ""a"" @u

which manifests itself as:

	BUG: unable to handle kernel paging request at 00000000ffffff8a
	IP: [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	PGD 7cc30067 PUD 0
	Oops: 0002 [#1] SMP
	Modules linked in:
	CPU: 3 PID: 2644 Comm: a.out Not tainted 4.3.0+ #49
	Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
	task: ffff88003ddea700 ti: ffff88003dd88000 task.ti: ffff88003dd88000
	RIP: 0010:[<ffffffff810a376f>]  [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280
	 [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	RSP: 0018:ffff88003dd8bdb0  EFLAGS: 00010246
	RAX: 00000000ffffff82 RBX: 0000000000000000 RCX: 0000000000000001
	RDX: ffffffff81e3fe40 RSI: 0000000000000000 RDI: 00000000ffffff82
	RBP: ffff88003dd8bde0 R08: ffff88007d2d2da0 R09: 0000000000000000
	R10: 0000000000000000 R11: ffff88003e8073c0 R12: 00000000ffffff82
	R13: ffff88003dd8be68 R14: ffff88007d027600 R15: ffff88003ddea700
	FS:  0000000000b92880(0063) GS:ffff88007fd00000(0000) knlGS:0000000000000000
	CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
	CR2: 00000000ffffff8a CR3: 000000007cc5f000 CR4: 00000000000006e0
	Stack:
	 ffff88003dd8bdf0 ffffffff81160a8a 0000000000000000 00000000ffffff82
	 ffff88003dd8be68 ffff88007d027600 ffff88003dd8bdf0 ffffffff810a39e5
	 ffff88003dd8be20 ffffffff812a31ab ffff88007d027600 ffff88007d027620
	Call Trace:
	 [<ffffffff810a39e5>] kfree_call_rcu+0x15/0x20 kernel/rcu/tree.c:3136
	 [<ffffffff812a31ab>] user_update+0x8b/0xb0 security/keys/user_defined.c:129
	 [<     inline     >] __key_update security/keys/key.c:730
	 [<ffffffff8129e5c1>] key_create_or_update+0x291/0x440 security/keys/key.c:908
	 [<     inline     >] SYSC_add_key security/keys/keyctl.c:125
	 [<ffffffff8129fc21>] SyS_add_key+0x101/0x1e0 security/keys/keyctl.c:60
	 [<ffffffff8185f617>] entry_SYSCALL_64_fastpath+0x12/0x6a arch/x86/entry/entry_64.S:185

Note the error code (-ENOKEY) in EDX.

A similar bug can be tripped by:

    keyctl request2 trusted user """" @u
    keyctl add trusted user ""a"" @u

This should also affect encrypted keys - but that has to be correctly
parameterised or it will fail with EINVAL before getting to the bit that
will crashes.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",1.0,security/keys/user_defined.c,"{""sha"": ""696ccfa08d103cd29ae56ac38c117bbd7725da06"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -845,6 +845,8 @@ static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n ""}<_**next**_>{""sha"": ""16dec53184b663f745c010d11e78128ca995bf58"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -1007,13 +1007,16 @@ static void trusted_rcu_free(struct rcu_head *rcu)\n  */\n static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n {\n-\tstruct trusted_key_payload *p = key->payload.data[0];\n+\tstruct trusted_key_payload *p;\n \tstruct trusted_key_payload *new_p;\n \tstruct trusted_key_options *new_o;\n \tsize_t datalen = prep->datalen;\n \tchar *datablob;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n+\tp = key->payload.data[0];\n \tif (!p->migratable)\n \t\treturn -EPERM;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)""}<_**next**_>{""sha"": ""8705d79b2c6f289736fde21fd38e6013a4e4ae3c"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -120,7 +120,10 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n \tif (ret == 0) {\n \t\t/* attach the new data, displacing the old */\n-\t\tzap = key->payload.data[0];\n+\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\t\tzap = key->payload.data[0];\n+\t\telse\n+\t\t\tzap = NULL;\n \t\trcu_assign_keypointer(key, upayload);\n \t\tkey->expiry = 0;\n \t}""}",		zap = key->payload.data[0];,26,"int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
			zap = key->payload.data[0];
		else
			zap = NULL;
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
","int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		zap = key->payload.data[0];
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
",180707.0,C,"		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
			zap = key->payload.data[0];
		else
			zap = NULL;
","		zap = key->payload.data[0];
",,"@@ -120,7 +120,10 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
-		zap = key->payload.data[0];
+		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
+			zap = key->payload.data[0];
+		else
+			zap = NULL;
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}","int user_update(struct key *key, struct key_preparsed_payload *prep)
{
struct user_key_payload *upayload, *zap;
size_t datalen = prep->datalen;
int ret;

ret = -EINVAL;
if (datalen <= 0 || datalen > 32767 || !prep->data)
goto error;

/* construct a replacement payload */
ret = -ENOMEM;
upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
if (!upayload)
goto error;

upayload->datalen = datalen;
memcpy(upayload->data, prep->data, datalen);

/* check the quota and attach the new data */
zap = upayload;

ret = key_payload_reserve(key, datalen);

if (ret == 0) {
/* attach the new data, displacing the old */
		zap = key->payload.data[0];
rcu_assign_keypointer(key, upayload);
key->expiry = 0;
}

if (zap)
kfree_rcu(zap, rcu);

error:
return ret;
}
",linux,096fe9eaea40a17e125569f9e657e34cdb6d73bd,6ffeba9607343f15303a399bc402a538800d89d9,1.0,"int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
//flaw_line_below:
		zap = key->payload.data[0];
//fix_flaw_line_below:
//		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
//fix_flaw_line_below:
//			zap = key->payload.data[0];
//fix_flaw_line_below:
//		else
//fix_flaw_line_below:
//			zap = NULL;
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
"
608,None,Remote,Not required,Partial,CVE-2016-0797,https://www.cvedetails.com/cve/CVE-2016-0797/,,Low,None,None,,2016-03-03,5.0,"Multiple integer overflows in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allow remote attackers to cause a denial of service (heap memory corruption or NULL pointer dereference) or possibly have unspecified other impact via a long digit string that is mishandled by the (1) BN_dec2bn or (2) BN_hex2bn function, related to crypto/bn/bn.h and crypto/bn/bn_print.c.",2018-01-04,DoS Overflow Mem. Corr.,5.0,https://git.openssl.org/?p=openssl.git;a=commit;h=c175308407858afff3fc8c2e5e085d94d12edc7d,c175308407858afff3fc8c2e5e085d94d12edc7d,,1.0,,,    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;,16,"int BN_hex2bn(BIGNUM **bn, const char *a)
{
    BIGNUM *ret = NULL;
    BN_ULONG l = 0;
    int neg = 0, h, m, i, j, k, c;
    int num;

    if ((a == NULL) || (*a == '\0'))
        return (0);

    if (*a == '-') {
        neg = 1;
        a++;
         a++;
     }
 
    for (i = 0; i <= (INT_MAX/4) && isxdigit((unsigned char)a[i]); i++)
        continue;

    if (i > INT_MAX/4)
        goto err;
 
     num = i + neg;
     if (bn == NULL)
            return (0);
    } else {
        ret = *bn;
        BN_zero(ret);
    }
","int BN_hex2bn(BIGNUM **bn, const char *a)
{
    BIGNUM *ret = NULL;
    BN_ULONG l = 0;
    int neg = 0, h, m, i, j, k, c;
    int num;

    if ((a == NULL) || (*a == '\0'))
        return (0);

    if (*a == '-') {
        neg = 1;
        a++;
         a++;
     }
 
    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;
 
     num = i + neg;
     if (bn == NULL)
            return (0);
    } else {
        ret = *bn;
        BN_zero(ret);
    }
",178422.0,C,"    for (i = 0; i <= (INT_MAX/4) && isxdigit((unsigned char)a[i]); i++)
        continue;

    if (i > INT_MAX/4)
        goto err;
","    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;
",29305f4edc886db349f2beedb345f9dd93311c09,"@@ -58,6 +58,7 @@
 
 #include <stdio.h>
 #include <ctype.h>
+#include <limits.h>
 #include ""cryptlib.h""
 #include <openssl/buffer.h>
 #include ""bn_lcl.h""
@@ -189,7 +190,11 @@ int BN_hex2bn(BIGNUM **bn, const char *a)
         a++;
     }
 
-    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;
+    for (i = 0; i <= (INT_MAX/4) && isxdigit((unsigned char)a[i]); i++)
+        continue;
+
+    if (i > INT_MAX/4)
+        goto err;
 
     num = i + neg;
     if (bn == NULL)
@@ -204,7 +209,7 @@ int BN_hex2bn(BIGNUM **bn, const char *a)
         BN_zero(ret);
     }
 
-    /* i is the number of hex digests; */
+    /* i is the number of hex digits */
     if (bn_expand(ret, i * 4) == NULL)
         goto err;
 
@@ -260,7 +265,11 @@ int BN_dec2bn(BIGNUM **bn, const char *a)
         a++;
     }
 
-    for (i = 0; isdigit((unsigned char)a[i]); i++) ;
+    for (i = 0; i <= (INT_MAX/4) && isdigit((unsigned char)a[i]); i++)
+        continue;
+
+    if (i > INT_MAX/4)
+        goto err;
 
     num = i + neg;
     if (bn == NULL)
@@ -278,7 +287,7 @@ int BN_dec2bn(BIGNUM **bn, const char *a)
         BN_zero(ret);
     }
 
-    /* i is the number of digests, a bit of an over expand; */
+    /* i is the number of digits, a bit of an over expand */
     if (bn_expand(ret, i * 4) == NULL)
         goto err;","int BN_hex2bn(BIGNUM **bn, const char *a)
{
BIGNUM *ret = NULL;
BN_ULONG l = 0;
int neg = 0, h, m, i, j, k, c;
int num;

if ((a == NULL) || (*a == '\0'))
return (0);

if (*a == '-') {
neg = 1;
a++;
a++;
}

    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;

num = i + neg;
if (bn == NULL)
return (0);
} else {
ret = *bn;
BN_zero(ret);
}
",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/bn/bn_print.c;h=bfa31efc56216b24456e1b640882461cf5750861;hb=c175308407858afff3fc8c2e5e085d94d12edc7d,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/bn/bn_print.c;h=ab10b957ba27d4cd558483e2e5e05aaaa0cacd08,1.0,"int BN_hex2bn(BIGNUM **bn, const char *a)
{
    BIGNUM *ret = NULL;
    BN_ULONG l = 0;
    int neg = 0, h, m, i, j, k, c;
    int num;

    if ((a == NULL) || (*a == '\0'))
        return (0);

    if (*a == '-') {
        neg = 1;
        a++;
         a++;
     }
 
//flaw_line_below:
    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;
//fix_flaw_line_below:
//    for (i = 0; i <= (INT_MAX/4) && isxdigit((unsigned char)a[i]); i++)
//fix_flaw_line_below:
//        continue;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (i > INT_MAX/4)
//fix_flaw_line_below:
//        goto err;
 
     num = i + neg;
     if (bn == NULL)
            return (0);
    } else {
        ret = *bn;
        BN_zero(ret);
    }
"
615,None,Remote,Not required,Partial,CVE-2013-7294,https://www.cvedetails.com/cve/CVE-2013-7294/,CWE-20,Low,None,None,,2014-01-16,5.0,The ikev2parent_inI1outR1 function in pluto/ikev2_parent.c in libreswan before 3.7 allows remote attackers to cause a denial of service (restart) via an IKEv2 I1 notification without a KE payload.,2018-01-02,DoS ,0.0,https://github.com/libreswan/libreswan/commit/2899351224fe2940aec37d7656e1e392c0fe07f0,2899351224fe2940aec37d7656e1e392c0fe07f0,SECURITY: Properly handle IKEv2 I1 notification packet without KE payload,1.0,programs/pluto/ikev2_parent.c,"{""sha"": ""ce67cc3c030a9316ef4281028aeb4e80598d2155"", ""filename"": ""programs/pluto/ikev2_parent.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 13, ""changes"": 31, ""blob_url"": ""https://github.com/libreswan/libreswan/blob/2899351224fe2940aec37d7656e1e392c0fe07f0/programs/pluto/ikev2_parent.c"", ""raw_url"": ""https://github.com/libreswan/libreswan/raw/2899351224fe2940aec37d7656e1e392c0fe07f0/programs/pluto/ikev2_parent.c"", ""contents_url"": ""https://api.github.com/repos/libreswan/libreswan/contents/programs/pluto/ikev2_parent.c?ref=2899351224fe2940aec37d7656e1e392c0fe07f0"", ""patch"": ""@@ -306,8 +306,6 @@ static void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,\n \t}\n \treset_cur_state();\n \treset_globals();\n-\n-\tpassert(GLOBALS_ARE_RESET());\n }\n \n /*\n@@ -729,18 +727,31 @@ stf_status ikev2parent_inI1outR1(struct msg_digest *md)\n \t */\n \t{\n \t\tstruct ikev2_ke *ke;\n+\t\tchar fromname[ADDRTOT_BUF];\n+\t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);\n+\n+\t\tif (!md->chain[ISAKMP_NEXT_v2KE]) {\n+\t\t\t/* is this a notify? If so, log it */\n+\t\t\tif(md->chain[ISAKMP_NEXT_v2N]) {\n+\t\t\t\tlibreswan_log(\""Received Notify(%d): %s\"",\n+\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type,\n+\t\t\t\t\tenum_name(&ikev2_notify_names,\n+\t\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type));\n+\t\t\t}\n+\t\t\tlibreswan_log(\n+\t\t\t\t\""rejecting I1 from %s:%u, no KE payload present\"",\n+\t\t\t\tfromname, md->sender_port);\n+\t\t\treturn STF_FAIL + v2N_INVALID_KE_PAYLOAD;\n+\t\t}\n \t\tke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;\n \n \t\tst->st_oakley.group = lookup_group(ke->isak_group);\n \t\tif (st->st_oakley.group == NULL) {\n-\t\t\tchar fromname[ADDRTOT_BUF];\n-\n-\t\t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);\n \t\t\tlibreswan_log(\n \t\t\t\t\""rejecting I1 from %s:%u, invalid DH group=%u\"",\n \t\t\t\tfromname, md->sender_port,\n \t\t\t\tke->isak_group);\n-\t\t\treturn v2N_INVALID_KE_PAYLOAD;\n+\t\t\treturn STF_FAIL + v2N_INVALID_KE_PAYLOAD;\n \t\t}\n \t}\n \n@@ -819,8 +830,6 @@ static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n \t\t\trelease_md(ke->md);\n \t}\n \treset_globals();\n-\n-\tpassert(GLOBALS_ARE_RESET());\n }\n \n static stf_status ikev2_parent_inI1outR1_tail(\n@@ -1145,8 +1154,6 @@ static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n \t\t\trelease_md(dh->md);\n \t}\n \treset_globals();\n-\n-\tpassert(GLOBALS_ARE_RESET());\n }\n \n static void ikev2_padup_pre_encrypt(struct msg_digest *md,\n@@ -1714,7 +1721,7 @@ stf_status ikev2parent_inI2outR2(struct msg_digest *md)\n \t/* verify that there is in fact an encrypted payload */\n \tif (!md->chain[ISAKMP_NEXT_v2E]) {\n \t\tlibreswan_log(\""R2 state should receive an encrypted payload\"");\n-\t\treset_globals();\n+\t\treset_globals(); /* XXX suspicious - why was this deemed neccessary? */\n \t\treturn STF_FATAL;\n \t}\n \n@@ -1794,8 +1801,6 @@ static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,\n \t\t\trelease_md(dh->md);\n \t}\n \treset_globals();\n-\n-\tpassert(GLOBALS_ARE_RESET());\n }\n \n static stf_status ikev2_parent_inI2outR2_tail(""}",	passert(GLOBALS_ARE_RESET());,51,"static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,
					    struct pluto_crypto_req *r,
					    err_t ugh)
{
	struct dh_continuation *dh = (struct dh_continuation *)pcrc;
	struct msg_digest *md = dh->md;
	struct state *const st = md->st;
	stf_status e;

	DBG(DBG_CONTROLMORE,
	    DBG_log(""ikev2 parent inI2outR2: calculating g^{xy}, sending R2""));

	if (st == NULL) {
		loglog(RC_LOG_SERIOUS,
		       ""%s: Request was disconnected from state"",
		       __FUNCTION__);
		if (dh->md)
			release_md(dh->md);
		return;
	}

	/* XXX should check out ugh */
	passert(ugh == NULL);
	passert(cur_state == NULL);
	passert(st != NULL);

	passert(st->st_suspended_md == dh->md);
	set_suspended(st, NULL); /* no longer connected or suspended */

	set_cur_state(st);

	st->st_calculating = FALSE;

	e = ikev2_parent_inI2outR2_tail(pcrc, r);
	if ( e > STF_FAIL) {
		/* we do not send a notify because we are the initiator that could be responding to an error notification */
		int v2_notify_num = e - STF_FAIL;
		DBG_log(
			""ikev2_parent_inI2outR2_tail returned STF_FAIL with %s"",
			enum_name(&ikev2_notify_names, v2_notify_num));
	} else if ( e != STF_OK) {
		DBG_log(""ikev2_parent_inI2outR2_tail returned %s"",
			enum_name(&stfstatus_name, e));
	}

	if (dh->md != NULL) {
		complete_v2_state_transition(&dh->md, e);
		if (dh->md)
 			release_md(dh->md);
 	}
 	reset_globals();
 }
","static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,
					    struct pluto_crypto_req *r,
					    err_t ugh)
{
	struct dh_continuation *dh = (struct dh_continuation *)pcrc;
	struct msg_digest *md = dh->md;
	struct state *const st = md->st;
	stf_status e;

	DBG(DBG_CONTROLMORE,
	    DBG_log(""ikev2 parent inI2outR2: calculating g^{xy}, sending R2""));

	if (st == NULL) {
		loglog(RC_LOG_SERIOUS,
		       ""%s: Request was disconnected from state"",
		       __FUNCTION__);
		if (dh->md)
			release_md(dh->md);
		return;
	}

	/* XXX should check out ugh */
	passert(ugh == NULL);
	passert(cur_state == NULL);
	passert(st != NULL);

	passert(st->st_suspended_md == dh->md);
	set_suspended(st, NULL); /* no longer connected or suspended */

	set_cur_state(st);

	st->st_calculating = FALSE;

	e = ikev2_parent_inI2outR2_tail(pcrc, r);
	if ( e > STF_FAIL) {
		/* we do not send a notify because we are the initiator that could be responding to an error notification */
		int v2_notify_num = e - STF_FAIL;
		DBG_log(
			""ikev2_parent_inI2outR2_tail returned STF_FAIL with %s"",
			enum_name(&ikev2_notify_names, v2_notify_num));
	} else if ( e != STF_OK) {
		DBG_log(""ikev2_parent_inI2outR2_tail returned %s"",
			enum_name(&stfstatus_name, e));
	}

	if (dh->md != NULL) {
		complete_v2_state_transition(&dh->md, e);
		if (dh->md)
 			release_md(dh->md);
 	}
 	reset_globals();
	passert(GLOBALS_ARE_RESET());
 }
",179643.0,C,,"	passert(GLOBALS_ARE_RESET());
",,"@@ -306,8 +306,6 @@ static void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,
 	}
 	reset_cur_state();
 	reset_globals();
-
-	passert(GLOBALS_ARE_RESET());
 }
 
 /*
@@ -729,18 +727,31 @@ stf_status ikev2parent_inI1outR1(struct msg_digest *md)
 	 */
 	{
 		struct ikev2_ke *ke;
+		char fromname[ADDRTOT_BUF];
+		addrtot(&md->sender, 0, fromname, ADDRTOT_BUF);
+
+		if (!md->chain[ISAKMP_NEXT_v2KE]) {
+			/* is this a notify? If so, log it */
+			if(md->chain[ISAKMP_NEXT_v2N]) {
+				libreswan_log(""Received Notify(%d): %s"",
+					md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type,
+					enum_name(&ikev2_notify_names,
+						md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type));
+			}
+			libreswan_log(
+				""rejecting I1 from %s:%u, no KE payload present"",
+				fromname, md->sender_port);
+			return STF_FAIL + v2N_INVALID_KE_PAYLOAD;
+		}
 		ke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;
 
 		st->st_oakley.group = lookup_group(ke->isak_group);
 		if (st->st_oakley.group == NULL) {
-			char fromname[ADDRTOT_BUF];
-
-			addrtot(&md->sender, 0, fromname, ADDRTOT_BUF);
 			libreswan_log(
 				""rejecting I1 from %s:%u, invalid DH group=%u"",
 				fromname, md->sender_port,
 				ke->isak_group);
-			return v2N_INVALID_KE_PAYLOAD;
+			return STF_FAIL + v2N_INVALID_KE_PAYLOAD;
 		}
 	}
 
@@ -819,8 +830,6 @@ static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,
 			release_md(ke->md);
 	}
 	reset_globals();
-
-	passert(GLOBALS_ARE_RESET());
 }
 
 static stf_status ikev2_parent_inI1outR1_tail(
@@ -1145,8 +1154,6 @@ static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,
 			release_md(dh->md);
 	}
 	reset_globals();
-
-	passert(GLOBALS_ARE_RESET());
 }
 
 static void ikev2_padup_pre_encrypt(struct msg_digest *md,
@@ -1714,7 +1721,7 @@ stf_status ikev2parent_inI2outR2(struct msg_digest *md)
 	/* verify that there is in fact an encrypted payload */
 	if (!md->chain[ISAKMP_NEXT_v2E]) {
 		libreswan_log(""R2 state should receive an encrypted payload"");
-		reset_globals();
+		reset_globals(); /* XXX suspicious - why was this deemed neccessary? */
 		return STF_FATAL;
 	}
 
@@ -1794,8 +1801,6 @@ static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,
 			release_md(dh->md);
 	}
 	reset_globals();
-
-	passert(GLOBALS_ARE_RESET());
 }
 
 static stf_status ikev2_parent_inI2outR2_tail(","static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,
struct pluto_crypto_req *r,
err_t ugh)
{
struct dh_continuation *dh = (struct dh_continuation *)pcrc;
struct msg_digest *md = dh->md;
struct state *const st = md->st;
stf_status e;

DBG(DBG_CONTROLMORE,
DBG_log(""ikev2 parent inI2outR2: calculating g^{xy}, sending R2""));

if (st == NULL) {
loglog(RC_LOG_SERIOUS,
""%s: Request was disconnected from state"",
__FUNCTION__);
if (dh->md)
release_md(dh->md);
return;
}

/* XXX should check out ugh */
passert(ugh == NULL);
passert(cur_state == NULL);
passert(st != NULL);

passert(st->st_suspended_md == dh->md);
set_suspended(st, NULL); /* no longer connected or suspended */

set_cur_state(st);

st->st_calculating = FALSE;

e = ikev2_parent_inI2outR2_tail(pcrc, r);
if ( e > STF_FAIL) {
/* we do not send a notify because we are the initiator that could be responding to an error notification */
int v2_notify_num = e - STF_FAIL;
DBG_log(
""ikev2_parent_inI2outR2_tail returned STF_FAIL with %s"",
enum_name(&ikev2_notify_names, v2_notify_num));
} else if ( e != STF_OK) {
DBG_log(""ikev2_parent_inI2outR2_tail returned %s"",
enum_name(&stfstatus_name, e));
}

if (dh->md != NULL) {
complete_v2_state_transition(&dh->md, e);
if (dh->md)
release_md(dh->md);
}
reset_globals();
	passert(GLOBALS_ARE_RESET());
}
",libreswan,2899351224fe2940aec37d7656e1e392c0fe07f0,daf45e1b7e22c9346778af9a89bc6e7cd197db94,1.0,"static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,
					    struct pluto_crypto_req *r,
					    err_t ugh)
{
	struct dh_continuation *dh = (struct dh_continuation *)pcrc;
	struct msg_digest *md = dh->md;
	struct state *const st = md->st;
	stf_status e;

	DBG(DBG_CONTROLMORE,
	    DBG_log(""ikev2 parent inI2outR2: calculating g^{xy}, sending R2""));

	if (st == NULL) {
		loglog(RC_LOG_SERIOUS,
		       ""%s: Request was disconnected from state"",
		       __FUNCTION__);
		if (dh->md)
			release_md(dh->md);
		return;
	}

	/* XXX should check out ugh */
	passert(ugh == NULL);
	passert(cur_state == NULL);
	passert(st != NULL);

	passert(st->st_suspended_md == dh->md);
	set_suspended(st, NULL); /* no longer connected or suspended */

	set_cur_state(st);

	st->st_calculating = FALSE;

	e = ikev2_parent_inI2outR2_tail(pcrc, r);
	if ( e > STF_FAIL) {
		/* we do not send a notify because we are the initiator that could be responding to an error notification */
		int v2_notify_num = e - STF_FAIL;
		DBG_log(
			""ikev2_parent_inI2outR2_tail returned STF_FAIL with %s"",
			enum_name(&ikev2_notify_names, v2_notify_num));
	} else if ( e != STF_OK) {
		DBG_log(""ikev2_parent_inI2outR2_tail returned %s"",
			enum_name(&stfstatus_name, e));
	}

	if (dh->md != NULL) {
		complete_v2_state_transition(&dh->md, e);
		if (dh->md)
 			release_md(dh->md);
 	}
 	reset_globals();
//flaw_line_below:

//flaw_line_below:
	passert(GLOBALS_ARE_RESET());
 }
"
617,,,,,,,,,,,,,,,2014-01,,2.0,https://github.com/chromium/chromium/commit/a0fe4d88137213aa24fbb16fd7eec34533345c9b,a0fe4d88137213aa24fbb16fd7eec34533345c9b,"Move supports-high-dpi flag into registry.

Calls to SetProcessDpiAwareness need to happen immediately when the app starts. Specifically, before user profile settings have been initialized.

This patch moves the --supports-high-dpi into the registry.

BUG=339152, 149881, 160457

Review URL: https://codereview.chromium.org/153403003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@256811 0039d316-1c4b-4281-b951-d872f2087c98",4.0,ui/gfx/win/dpi.cc,"{""sha"": ""e331ce46cc6cd9839fc19f0becfdb4b386d1aab3"", ""filename"": ""chrome/app/generated_resources.grd"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 6, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/a0fe4d88137213aa24fbb16fd7eec34533345c9b/chrome/app/generated_resources.grd"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a0fe4d88137213aa24fbb16fd7eec34533345c9b/chrome/app/generated_resources.grd"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/app/generated_resources.grd?ref=a0fe4d88137213aa24fbb16fd7eec34533345c9b"", ""patch"": ""@@ -6822,12 +6822,6 @@ Keep your key file in a safe place. You will need it to create new versions of y\n           If enabled, transitions during first-run tutorial are animated.\n         </message>\n       </if>\n-      <message name=\""IDS_FLAGS_HIDPI_NAME\"" desc=\""Name of flag to enable/disable HiDPI Support.\"">\n-        HiDPI Support\n-      </message>\n-      <message name=\""IDS_FLAGS_HIDPI_DESCRIPTION\"" desc=\""Description of flag to enable/disable HiDPI Support.\"">\n-        If enabled, application size and layout will adapt to the operating system's DPI settings.\n-      </message>\n       <message name=\""IDS_FLAGS_ENABLE_ACCELERATED_SCROLLABLE_FRAMES_NAME\"" desc=\""Name of the flag to enable accelerated scrollable frames.\"">\n         Enable accelerated scrollable frames.\n       </message>""}<_**next**_>{""sha"": ""61a1fbfce7089f817ae6b461acdb10f46b2840c7"", ""filename"": ""chrome/browser/about_flags.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 8, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/a0fe4d88137213aa24fbb16fd7eec34533345c9b/chrome/browser/about_flags.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a0fe4d88137213aa24fbb16fd7eec34533345c9b/chrome/browser/about_flags.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/about_flags.cc?ref=a0fe4d88137213aa24fbb16fd7eec34533345c9b"", ""patch"": ""@@ -1541,14 +1541,6 @@ const Experiment kExperiments[] = {\n     kOsAll,\n     SINGLE_VALUE_TYPE(switches::kEnableHTMLImports)\n   },\n-  {\n-    \""high-dpi-support\"",\n-    IDS_FLAGS_HIDPI_NAME,\n-    IDS_FLAGS_HIDPI_DESCRIPTION,\n-    kOsWin,\n-    ENABLE_DISABLE_VALUE_TYPE_AND_VALUE(switches::kHighDPISupport, \""1\"",\n-                                        switches::kHighDPISupport, \""0\"")\n-  },\n   {\n     \""enable-web-midi\"",\n     IDS_FLAGS_ENABLE_WEB_MIDI_NAME,""}<_**next**_>{""sha"": ""c02e0939e1108b798f7a6e785dd4de2497c3f230"", ""filename"": ""content/browser/renderer_host/render_widget_host_view_browsertest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/a0fe4d88137213aa24fbb16fd7eec34533345c9b/content/browser/renderer_host/render_widget_host_view_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a0fe4d88137213aa24fbb16fd7eec34533345c9b/content/browser/renderer_host/render_widget_host_view_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/render_widget_host_view_browsertest.cc?ref=a0fe4d88137213aa24fbb16fd7eec34533345c9b"", ""patch"": ""@@ -877,7 +877,7 @@ class CompositingRenderWidgetHostViewTabCaptureHighDPI\n     cmd->AppendSwitchASCII(switches::kForceDeviceScaleFactor,\n                            base::StringPrintf(\""%f\"", scale()));\n #if defined(OS_WIN)\n-    cmd->AppendSwitchASCII(switches::kHighDPISupport, \""1\"");\n+    gfx::ForceHighDPISupportForTesting(scale());\n     gfx::EnableHighDPISupport();\n #endif\n   }""}<_**next**_>{""sha"": ""986375c07859170b4dac34fdeeaf634ede374648"", ""filename"": ""ui/gfx/win/dpi.cc"", ""status"": ""modified"", ""additions"": 33, ""deletions"": 10, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/a0fe4d88137213aa24fbb16fd7eec34533345c9b/ui/gfx/win/dpi.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a0fe4d88137213aa24fbb16fd7eec34533345c9b/ui/gfx/win/dpi.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/gfx/win/dpi.cc?ref=a0fe4d88137213aa24fbb16fd7eec34533345c9b"", ""patch"": ""@@ -20,6 +20,11 @@ namespace {\n int kDefaultDPIX = 96;\n int kDefaultDPIY = 96;\n \n+const wchar_t kRegistryProfilePath[] = L\""SOFTWARE\\\\Google\\\\Chrome\\\\Profile\"";\n+const wchar_t kHighDPISupportW[] = L\""high-dpi-support\"";\n+\n+bool force_highdpi_for_testing = false;\n+\n BOOL IsProcessDPIAwareWrapper() {\n   typedef BOOL(WINAPI *IsProcessDPIAwarePtr)(VOID);\n   IsProcessDPIAwarePtr is_process_dpi_aware_func =\n@@ -98,6 +103,21 @@ BOOL SetProcessDPIAwareWrapper() {\n     set_process_dpi_aware_func();\n }\n \n+DWORD ReadRegistryValue(HKEY root,\n+                        const wchar_t* base_key,\n+                        const wchar_t* value_name,\n+                        DWORD default_value) {\n+  base::win::RegKey reg_key(HKEY_CURRENT_USER,\n+                            base_key,\n+                            KEY_QUERY_VALUE);\n+  DWORD value;\n+  if (reg_key.Valid() &&\n+      reg_key.ReadValueDW(value_name, &value) == ERROR_SUCCESS) {\n+    return value;\n+  }\n+  return default_value;\n+}\n+\n }  // namespace\n \n namespace gfx {\n@@ -137,14 +157,19 @@ float GetDPIScale() {\n   return 1.0;\n }\n \n+void ForceHighDPISupportForTesting(float scale) {\n+  force_highdpi_for_testing = true;\n+  g_device_scale_factor = scale;\n+}\n+\n bool IsHighDPIEnabled() {\n+  // Flag stored in HKEY_CURRENT_USER\\SOFTWARE\\\\Google\\\\Chrome\\\\Profile,\n+  // under the DWORD value high-dpi-support.\n   // Default is disabled.\n-  if (CommandLine::ForCurrentProcess()->HasSwitch(\n-      switches::kHighDPISupport)) {\n-    return CommandLine::ForCurrentProcess()->GetSwitchValueASCII(\n-        switches::kHighDPISupport).compare(\""1\"") == 0;\n-  }\n-  return false;\n+  static DWORD value = ReadRegistryValue(\n+      HKEY_CURRENT_USER, kRegistryProfilePath,\n+      kHighDPISupportW, FALSE);\n+  return force_highdpi_for_testing || (value == 1);\n }\n \n bool IsInHighDPIMode() {\n@@ -153,10 +178,8 @@ bool IsInHighDPIMode() {\n \n void EnableHighDPISupport() {\n   if (IsHighDPIEnabled() &&\n-      (base::win::GetVersion() < base::win::VERSION_WIN8_1)) {\n-    if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {\n-      SetProcessDPIAwareWrapper();\n-    }\n+      !SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {\n+    SetProcessDPIAwareWrapper();\n   }\n }\n ""}<_**next**_>{""sha"": ""b66da590d893bec20248aae247e5d5b60cd63839"", ""filename"": ""ui/gfx/win/dpi.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/a0fe4d88137213aa24fbb16fd7eec34533345c9b/ui/gfx/win/dpi.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a0fe4d88137213aa24fbb16fd7eec34533345c9b/ui/gfx/win/dpi.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/gfx/win/dpi.h?ref=a0fe4d88137213aa24fbb16fd7eec34533345c9b"", ""patch"": ""@@ -37,6 +37,8 @@ GFX_EXPORT bool IsInHighDPIMode();\n \n GFX_EXPORT void EnableHighDPISupport();\n \n+GFX_EXPORT void ForceHighDPISupportForTesting(float scale);\n+\n // TODO(kevers|girard):  Move above methods into win namespace.\n \n namespace win {""}",      (base::win::GetVersion() < base::win::VERSION_WIN8_1)) {/~/    if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {/~/      SetProcessDPIAwareWrapper();/~/    },"2,3,4,5"," void EnableHighDPISupport() {
   if (IsHighDPIEnabled() &&
      !SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {
    SetProcessDPIAwareWrapper();
   }
 }
"," void EnableHighDPISupport() {
   if (IsHighDPIEnabled() &&
      (base::win::GetVersion() < base::win::VERSION_WIN8_1)) {
    if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {
      SetProcessDPIAwareWrapper();
    }
   }
 }
",185602.0,C,"      !SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {
    SetProcessDPIAwareWrapper();
","      (base::win::GetVersion() < base::win::VERSION_WIN8_1)) {
    if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {
      SetProcessDPIAwareWrapper();
    }
",,"@@ -20,6 +20,11 @@ namespace {
 int kDefaultDPIX = 96;
 int kDefaultDPIY = 96;
 
+const wchar_t kRegistryProfilePath[] = L""SOFTWARE\\Google\\Chrome\\Profile"";
+const wchar_t kHighDPISupportW[] = L""high-dpi-support"";
+
+bool force_highdpi_for_testing = false;
+
 BOOL IsProcessDPIAwareWrapper() {
   typedef BOOL(WINAPI *IsProcessDPIAwarePtr)(VOID);
   IsProcessDPIAwarePtr is_process_dpi_aware_func =
@@ -98,6 +103,21 @@ BOOL SetProcessDPIAwareWrapper() {
     set_process_dpi_aware_func();
 }
 
+DWORD ReadRegistryValue(HKEY root,
+                        const wchar_t* base_key,
+                        const wchar_t* value_name,
+                        DWORD default_value) {
+  base::win::RegKey reg_key(HKEY_CURRENT_USER,
+                            base_key,
+                            KEY_QUERY_VALUE);
+  DWORD value;
+  if (reg_key.Valid() &&
+      reg_key.ReadValueDW(value_name, &value) == ERROR_SUCCESS) {
+    return value;
+  }
+  return default_value;
+}
+
 }  // namespace
 
 namespace gfx {
@@ -137,14 +157,19 @@ float GetDPIScale() {
   return 1.0;
 }
 
+void ForceHighDPISupportForTesting(float scale) {
+  force_highdpi_for_testing = true;
+  g_device_scale_factor = scale;
+}
+
 bool IsHighDPIEnabled() {
+  // Flag stored in HKEY_CURRENT_USER\SOFTWARE\\Google\\Chrome\\Profile,
+  // under the DWORD value high-dpi-support.
   // Default is disabled.
-  if (CommandLine::ForCurrentProcess()->HasSwitch(
-      switches::kHighDPISupport)) {
-    return CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
-        switches::kHighDPISupport).compare(""1"") == 0;
-  }
-  return false;
+  static DWORD value = ReadRegistryValue(
+      HKEY_CURRENT_USER, kRegistryProfilePath,
+      kHighDPISupportW, FALSE);
+  return force_highdpi_for_testing || (value == 1);
 }
 
 bool IsInHighDPIMode() {
@@ -153,10 +178,8 @@ bool IsInHighDPIMode() {
 
 void EnableHighDPISupport() {
   if (IsHighDPIEnabled() &&
-      (base::win::GetVersion() < base::win::VERSION_WIN8_1)) {
-    if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {
-      SetProcessDPIAwareWrapper();
-    }
+      !SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {
+    SetProcessDPIAwareWrapper();
   }
 }
 ","void EnableHighDPISupport() {
if (IsHighDPIEnabled() &&
      (base::win::GetVersion() < base::win::VERSION_WIN8_1)) {
    if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {
      SetProcessDPIAwareWrapper();
    }
}
}
",Chrome,a0fe4d88137213aa24fbb16fd7eec34533345c9b,a0e757938bc87ced6761e6934c6469fff7366248,1.0," void EnableHighDPISupport() {
   if (IsHighDPIEnabled() &&
//flaw_line_below:
      (base::win::GetVersion() < base::win::VERSION_WIN8_1)) {
//flaw_line_below:
    if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {
//flaw_line_below:
      SetProcessDPIAwareWrapper();
//flaw_line_below:
    }
//fix_flaw_line_below:
//      !SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {
//fix_flaw_line_below:
//    SetProcessDPIAwareWrapper();
   }
 }
"
691,None,Remote,Not required,Partial,CVE-2016-5770,https://www.cvedetails.com/cve/CVE-2016-5770/,CWE-190,Low,Partial,Partial,,2016-08-07,7.5,"Integer overflow in the SplFileObject::fread function in spl_directory.c in the SPL extension in PHP before 5.5.37 and 5.6.x before 5.6.23 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large integer argument, a related issue to CVE-2016-5096.",2018-01-04,DoS Overflow ,4.0,https://github.com/php/php-src/commit/7245bff300d3fa8bacbef7897ff080a6f1c23eba?w=1,7245bff300d3fa8bacbef7897ff080a6f1c23eba?w=1,Fix bug #72262 - do not overflow int,1.0,ext/spl/spl_directory.c,"{""sha"": ""7718fe42d7fa9515244bf56a232c33728ecc6fcc"", ""filename"": ""ext/spl/spl_directory.c"", ""status"": ""modified"", ""additions"": 111, ""deletions"": 107, ""changes"": 218, ""blob_url"": ""https://github.com/php/php-src/blob/7245bff300d3fa8bacbef7897ff080a6f1c23eba/ext/spl/spl_directory.c"", ""raw_url"": ""https://github.com/php/php-src/raw/7245bff300d3fa8bacbef7897ff080a6f1c23eba/ext/spl/spl_directory.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/spl/spl_directory.c?ref=7245bff300d3fa8bacbef7897ff080a6f1c23eba"", ""patch"": ""@@ -79,9 +79,9 @@ static void spl_filesystem_object_free_storage(void *object TSRMLS_DC) /* {{{ */\n \tif (intern->oth_handler && intern->oth_handler->dtor) {\n \t\tintern->oth_handler->dtor(intern TSRMLS_CC);\n \t}\n-\t\n+\n \tzend_object_std_dtor(&intern->std TSRMLS_CC);\n-\t\n+\n \tif (intern->_path) {\n \t\tefree(intern->_path);\n \t}\n@@ -98,7 +98,7 @@ static void spl_filesystem_object_free_storage(void *object TSRMLS_DC) /* {{{ */\n \t\t}\n \t\tif (intern->u.dir.sub_path) {\n \t\t\tefree(intern->u.dir.sub_path);\n-\t\t}\t\t\n+\t\t}\n \t\tbreak;\n \tcase SPL_FS_FILE:\n \t\tif (intern->u.file.stream) {\n@@ -134,13 +134,13 @@ static void spl_filesystem_object_free_storage(void *object TSRMLS_DC) /* {{{ */\n } /* }}} */\n \n /* {{{ spl_ce_dir_object_new */\n-/* creates the object by \n-   - allocating memory \n+/* creates the object by\n+   - allocating memory\n    - initializing the object members\n    - storing the object\n    - setting it's handlers\n \n-   called from \n+   called from\n    - clone\n    - new\n  */\n@@ -313,7 +313,7 @@ static int spl_filesystem_file_open(spl_filesystem_object *intern, int use_inclu\n \t/* avoid reference counting in debug mode, thus do it manually */\n \tZVAL_RESOURCE(&intern->u.file.zresource, php_stream_get_resource_id(intern->u.file.stream));\n \tZ_SET_REFCOUNT(intern->u.file.zresource, 1);\n-\t\n+\n \tintern->u.file.delimiter = ',';\n \tintern->u.file.enclosure = '\""';\n \tintern->u.file.escape = '\\\\';\n@@ -325,7 +325,7 @@ static int spl_filesystem_file_open(spl_filesystem_object *intern, int use_inclu\n \n /* {{{ spl_filesystem_object_clone */\n /* Local zend_object_value creation (on stack)\n-   Load the 'other' object \n+   Load the 'other' object\n    Create a new empty object (See spl_filesystem_object_new_ex)\n    Open the directory\n    Clone other members (properties)\n@@ -370,7 +370,7 @@ static zend_object_value spl_filesystem_object_clone(zval *zobject TSRMLS_DC)\n \t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \""An object of class %s cannot be cloned\"", old_object->ce->name);\n \t\tbreak;\n \t}\n-\t\n+\n \tintern->file_class = source->file_class;\n \tintern->info_class = source->info_class;\n \tintern->oth = source->oth;\n@@ -389,7 +389,7 @@ static zend_object_value spl_filesystem_object_clone(zval *zobject TSRMLS_DC)\n void spl_filesystem_info_set_filename(spl_filesystem_object *intern, char *path, int len, int use_copy TSRMLS_DC) /* {{{ */\n {\n \tchar *p1, *p2;\n-\t\n+\n \tif (intern->file_name) {\n \t\tefree(intern->file_name);\n \t}\n@@ -413,7 +413,7 @@ void spl_filesystem_info_set_filename(spl_filesystem_object *intern, char *path,\n \t} else {\n \t\tintern->_path_len = 0;\n \t}\n-\t\n+\n \tif (intern->_path) {\n \t\tefree(intern->_path);\n \t}\n@@ -459,7 +459,7 @@ static spl_filesystem_object * spl_filesystem_object_create_info(spl_filesystem_\n \t} else {\n \t\tspl_filesystem_info_set_filename(intern, file_path, file_path_len, use_copy TSRMLS_CC);\n \t}\n-\t\n+\n \tzend_restore_error_handling(&error_handling TSRMLS_CC);\n \treturn intern;\n } /* }}} */\n@@ -514,7 +514,7 @@ static spl_filesystem_object * spl_filesystem_object_create_type(int ht, spl_fil\n \n \t\treturn_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC);\n \t\tZ_TYPE_P(return_value) = IS_OBJECT;\n-\t\n+\n \t\tspl_filesystem_object_get_file_name(source TSRMLS_CC);\n \n \t\tif (ce->constructor->common.scope != spl_ce_SplFileObject) {\n@@ -530,12 +530,12 @@ static spl_filesystem_object * spl_filesystem_object_create_type(int ht, spl_fil\n \t\t\tintern->file_name_len = source->file_name_len;\n \t\t\tintern->_path = spl_filesystem_object_get_path(source, &intern->_path_len TSRMLS_CC);\n \t\t\tintern->_path = estrndup(intern->_path, intern->_path_len);\n-\t\t\n+\n \t\t\tintern->u.file.open_mode = \""r\"";\n \t\t\tintern->u.file.open_mode_len = 1;\n-\t\t\n-\t\t\tif (ht && zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""|sbr\"", \n-\t\t\t\t\t&intern->u.file.open_mode, &intern->u.file.open_mode_len, \n+\n+\t\t\tif (ht && zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""|sbr\"",\n+\t\t\t\t\t&intern->u.file.open_mode, &intern->u.file.open_mode_len,\n \t\t\t\t\t&use_include_path, &intern->u.file.zcontext) == FAILURE) {\n \t\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n \t\t\t\tintern->u.file.open_mode = NULL;\n@@ -544,7 +544,7 @@ static spl_filesystem_object * spl_filesystem_object_create_type(int ht, spl_fil\n \t\t\t\tZ_TYPE_P(return_value) = IS_NULL;\n \t\t\t\treturn NULL;\n \t\t\t}\n-\t\t\n+\n \t\t\tif (spl_filesystem_file_open(intern, use_include_path, 0 TSRMLS_CC) == FAILURE) {\n \t\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n \t\t\t\tzval_dtor(return_value);\n@@ -553,7 +553,7 @@ static spl_filesystem_object * spl_filesystem_object_create_type(int ht, spl_fil\n \t\t\t}\n \t\t}\n \t\tbreak;\n-\tcase SPL_FS_DIR:\t\n+\tcase SPL_FS_DIR:\n \t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n \t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \""Operation not supported\"");\n \t\treturn NULL;\n@@ -617,7 +617,7 @@ static HashTable* spl_filesystem_object_get_debug_info(zval *obj, int *is_temp T\n \tif (intern->file_name) {\n \t\tpnstr = spl_gen_private_prop_name(spl_ce_SplFileInfo, \""fileName\"", sizeof(\""fileName\"")-1, &pnlen TSRMLS_CC);\n \t\tspl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n-\t\t\n+\n \t\tif (path_len && path_len < intern->file_name_len) {\n \t\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, intern->file_name + path_len + 1, intern->file_name_len - (path_len + 1), 1);\n \t\t} else {\n@@ -665,13 +665,13 @@ static HashTable* spl_filesystem_object_get_debug_info(zval *obj, int *is_temp T\n zend_function *spl_filesystem_object_get_method_check(zval **object_ptr, char *method, int method_len, const struct _zend_literal *key TSRMLS_DC) /* {{{ */\n {\n \tspl_filesystem_object *fsobj = zend_object_store_get_object(*object_ptr TSRMLS_CC);\n-\t\n+\n \tif (fsobj->u.dir.entry.d_name[0] == '\\0' && fsobj->orig_path == NULL) {\n \t\tmethod = \""_bad_state_ex\"";\n \t\tmethod_len = sizeof(\""_bad_state_ex\"") - 1;\n \t\tkey = NULL;\n \t}\n-\t\n+\n \treturn zend_get_std_object_handlers()->get_method(object_ptr, method, method_len, key TSRMLS_CC);\n }\n /* }}} */\n@@ -751,7 +751,7 @@ SPL_METHOD(DirectoryIterator, __construct)\n SPL_METHOD(DirectoryIterator, rewind)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -769,7 +769,7 @@ SPL_METHOD(DirectoryIterator, rewind)\n SPL_METHOD(DirectoryIterator, key)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -799,7 +799,7 @@ SPL_METHOD(DirectoryIterator, next)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tint skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -859,7 +859,7 @@ SPL_METHOD(DirectoryIterator, seek)\n SPL_METHOD(DirectoryIterator, valid)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -875,7 +875,7 @@ SPL_METHOD(SplFileInfo, getPath)\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tchar *path;\n \tint path_len;\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -891,13 +891,13 @@ SPL_METHOD(SplFileInfo, getFilename)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tint path_len;\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n \n \tspl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n-\t\n+\n \tif (path_len && path_len < intern->file_name_len) {\n \t\tRETURN_STRINGL(intern->file_name + path_len + 1, intern->file_name_len - (path_len + 1), 1);\n \t} else {\n@@ -911,7 +911,7 @@ SPL_METHOD(SplFileInfo, getFilename)\n SPL_METHOD(DirectoryIterator, getFilename)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -1019,7 +1019,7 @@ SPL_METHOD(SplFileInfo, getBasename)\n \n \tRETURN_STRINGL(fname, flen, 0);\n }\n-/* }}}*/   \n+/* }}}*/\n \n /* {{{ proto string DirectoryIterator::getBasename([string $suffix]) U\n    Returns filename component of current dir entry */\n@@ -1029,7 +1029,7 @@ SPL_METHOD(DirectoryIterator, getBasename)\n \tchar *suffix = 0, *fname;\n \tint slen = 0;\n \tsize_t flen;\n-\t\n+\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""|s\"", &suffix, &slen) == FAILURE) {\n \t\treturn;\n \t}\n@@ -1065,7 +1065,7 @@ SPL_METHOD(SplFileInfo, getPathname)\n SPL_METHOD(FilesystemIterator, key)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -1084,7 +1084,7 @@ SPL_METHOD(FilesystemIterator, key)\n SPL_METHOD(FilesystemIterator, current)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -1107,7 +1107,7 @@ SPL_METHOD(FilesystemIterator, current)\n SPL_METHOD(DirectoryIterator, isDot)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -1121,8 +1121,8 @@ SPL_METHOD(DirectoryIterator, isDot)\n /* zend_replace_error_handling() is used to throw exceptions in case\n    the constructor fails. Here we use this to ensure the object\n    has a valid directory resource.\n-   \n-   When the constructor gets called the object is already created \n+\n+   When the constructor gets called the object is already created\n    by the engine, so we must only call 'additional' initializations.\n  */\n SPL_METHOD(SplFileInfo, __construct)\n@@ -1140,11 +1140,11 @@ SPL_METHOD(SplFileInfo, __construct)\n \t}\n \n \tintern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tspl_filesystem_info_set_filename(intern, path, len, 1 TSRMLS_CC);\n \n \tzend_restore_error_handling(&error_handling TSRMLS_CC);\n-\t\n+\n \t/* intern->type = SPL_FS_INFO; already set */\n }\n /* }}} */\n@@ -1249,7 +1249,7 @@ SPL_METHOD(SplFileInfo, getLinkTarget)\n \tint ret;\n \tchar buff[MAXPATHLEN];\n \tzend_error_handling error_handling;\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -1297,7 +1297,7 @@ SPL_METHOD(SplFileInfo, getRealPath)\n \tchar buff[MAXPATHLEN];\n \tchar *filename;\n \tzend_error_handling error_handling;\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -1307,10 +1307,10 @@ SPL_METHOD(SplFileInfo, getRealPath)\n \tif (intern->type == SPL_FS_DIR && !intern->file_name && intern->u.dir.entry.d_name[0]) {\n \t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n \t}\n-\t\n+\n \tif (intern->orig_path) {\n \t\tfilename = intern->orig_path;\n-\t} else { \n+\t} else {\n \t\tfilename = intern->file_name;\n \t}\n \n@@ -1348,7 +1348,7 @@ SPL_METHOD(SplFileInfo, setFileClass)\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tzend_class_entry *ce = spl_ce_SplFileObject;\n \tzend_error_handling error_handling;\n-\t\n+\n \tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""|C\"", &ce) == SUCCESS) {\n@@ -1366,7 +1366,7 @@ SPL_METHOD(SplFileInfo, setInfoClass)\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tzend_class_entry *ce = spl_ce_SplFileInfo;\n \tzend_error_handling error_handling;\n-\t\n+\n \tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling  TSRMLS_CC);\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""|C\"", &ce) == SUCCESS) {\n@@ -1384,7 +1384,7 @@ SPL_METHOD(SplFileInfo, getFileInfo)\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tzend_class_entry *ce = intern->info_class;\n \tzend_error_handling error_handling;\n-\t\n+\n \tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""|C\"", &ce) == SUCCESS) {\n@@ -1402,7 +1402,7 @@ SPL_METHOD(SplFileInfo, getPathInfo)\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tzend_class_entry *ce = intern->info_class;\n \tzend_error_handling error_handling;\n-\t\n+\n \tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""|C\"", &ce) == SUCCESS) {\n@@ -1463,7 +1463,7 @@ SPL_METHOD(FilesystemIterator, rewind)\n SPL_METHOD(FilesystemIterator, getFlags)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -1519,11 +1519,11 @@ SPL_METHOD(RecursiveDirectoryIterator, getChildren)\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tspl_filesystem_object *subdir;\n \tchar slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n \n \tMAKE_STD_ZVAL(zflags);\n@@ -1554,7 +1554,7 @@ SPL_METHOD(RecursiveDirectoryIterator, getChildren)\n SPL_METHOD(RecursiveDirectoryIterator, getSubPath)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -1575,7 +1575,7 @@ SPL_METHOD(RecursiveDirectoryIterator, getSubPathname)\n \tchar *sub_name;\n \tint len;\n \tchar slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -1611,7 +1611,7 @@ SPL_METHOD(GlobIterator, __construct)\n SPL_METHOD(GlobIterator, count)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -1666,7 +1666,7 @@ zend_object_iterator *spl_filesystem_dir_get_iterator(zend_class_entry *ce, zval\n \t\titerator->current = object;\n \t}\n \tzval_add_ref(&object);\n-\t\n+\n \treturn (zend_object_iterator*)iterator;\n }\n /* }}} */\n@@ -1701,7 +1701,7 @@ static int spl_filesystem_dir_it_valid(zend_object_iterator *iter TSRMLS_DC)\n static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n {\n \tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n-\t\n+\n \t*data = &iterator->current;\n }\n /* }}} */\n@@ -1719,7 +1719,7 @@ static void spl_filesystem_dir_it_current_key(zend_object_iterator *iter, zval *\n static void spl_filesystem_dir_it_move_forward(zend_object_iterator *iter TSRMLS_DC)\n {\n \tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n-\t\n+\n \tobject->u.dir.index++;\n \tspl_filesystem_dir_read(object TSRMLS_CC);\n \tif (object->file_name) {\n@@ -1733,7 +1733,7 @@ static void spl_filesystem_dir_it_move_forward(zend_object_iterator *iter TSRMLS\n static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n {\n \tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n-\t\n+\n \tobject->u.dir.index = 0;\n \tif (object->u.dir.dirp) {\n \t\tphp_stream_rewinddir(object->u.dir.dirp);\n@@ -1803,7 +1803,7 @@ static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRML\n {\n \tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n \tspl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);\n-\t\n+\n \tobject->u.dir.index++;\n \tdo {\n \t\tspl_filesystem_dir_read(object TSRMLS_CC);\n@@ -1824,7 +1824,7 @@ static void spl_filesystem_tree_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n {\n \tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n \tspl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);\n-\t\n+\n \tobject->u.dir.index = 0;\n \tif (object->u.dir.dirp) {\n \t\tphp_stream_rewinddir(object->u.dir.dirp);\n@@ -1868,7 +1868,7 @@ zend_object_iterator *spl_filesystem_tree_get_iterator(zend_class_entry *ce, zva\n \t\titerator->intern.funcs = &spl_filesystem_tree_it_funcs;\n \t}\n \tzval_add_ref(&object);\n-\t\n+\n \treturn (zend_object_iterator*)iterator;\n }\n /* }}} */\n@@ -1924,7 +1924,7 @@ static int spl_filesystem_object_cast(zval *readobj, zval *writeobj, int type TS\n \n /* {{{ declare method parameters */\n /* supply a name and default to call by parameter */\n-ZEND_BEGIN_ARG_INFO(arginfo_info___construct, 0) \n+ZEND_BEGIN_ARG_INFO(arginfo_info___construct, 0)\n \tZEND_ARG_INFO(0, file_name)\n ZEND_END_ARG_INFO()\n \n@@ -1983,11 +1983,11 @@ static const zend_function_entry spl_SplFileInfo_functions[] = {\n \tPHP_FE_END\n };\n \n-ZEND_BEGIN_ARG_INFO(arginfo_dir___construct, 0) \n+ZEND_BEGIN_ARG_INFO(arginfo_dir___construct, 0)\n \tZEND_ARG_INFO(0, path)\n ZEND_END_ARG_INFO()\n \n-ZEND_BEGIN_ARG_INFO(arginfo_dir_it_seek, 0) \n+ZEND_BEGIN_ARG_INFO(arginfo_dir_it_seek, 0)\n \tZEND_ARG_INFO(0, position)\n ZEND_END_ARG_INFO();\n \n@@ -2009,7 +2009,7 @@ static const zend_function_entry spl_DirectoryIterator_functions[] = {\n \tPHP_FE_END\n };\n \n-ZEND_BEGIN_ARG_INFO_EX(arginfo_r_dir___construct, 0, 0, 1) \n+ZEND_BEGIN_ARG_INFO_EX(arginfo_r_dir___construct, 0, 0, 1)\n \tZEND_ARG_INFO(0, path)\n \tZEND_ARG_INFO(0, flags)\n ZEND_END_ARG_INFO()\n@@ -2058,7 +2058,7 @@ static int spl_filesystem_file_read(spl_filesystem_object *intern, int silent TS\n \tlong line_add = (intern->u.file.current_line || intern->u.file.current_zval) ? 1 : 0;\n \n \tspl_filesystem_file_free_line(intern TSRMLS_CC);\n-\t\n+\n \tif (php_stream_eof(intern->u.file.stream)) {\n \t\tif (!silent) {\n \t\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \""Cannot read from file %s\"", intern->file_name);\n@@ -2086,7 +2086,7 @@ static int spl_filesystem_file_read(spl_filesystem_object *intern, int silent TS\n \t\t\tline_len = strcspn(buf, \""\\r\\n\"");\n \t\t\tbuf[line_len] = '\\0';\n \t\t}\n-\t\n+\n \t\tintern->u.file.current_line = buf;\n \t\tintern->u.file.current_line_len = line_len;\n \t}\n@@ -2107,7 +2107,7 @@ static int spl_filesystem_file_call(spl_filesystem_object *intern, zend_function\n \tzval ***params = (zval***)safe_emalloc(num_args, sizeof(zval**), 0);\n \n \tparams[0] = &zresource_ptr;\n-\t\n+\n \tif (arg2) {\n \t\tparams[1] = &arg2;\n \t}\n@@ -2133,7 +2133,7 @@ static int spl_filesystem_file_call(spl_filesystem_object *intern, zend_function\n \tfcic.object_ptr = NULL;\n \n \tresult = zend_call_function(&fci, &fcic TSRMLS_CC);\n-\t\n+\n \tif (result == FAILURE) {\n \t\tRETVAL_FALSE;\n \t} else {\n@@ -2159,11 +2159,11 @@ static int spl_filesystem_file_call(spl_filesystem_object *intern, zend_function\n static int spl_filesystem_file_read_csv(spl_filesystem_object *intern, char delimiter, char enclosure, char escape, zval *return_value TSRMLS_DC) /* {{{ */\n {\n \tint ret = SUCCESS;\n-\t\n+\n \tdo {\n \t\tret = spl_filesystem_file_read(intern, 1 TSRMLS_CC);\n \t} while (ret == SUCCESS && !intern->u.file.current_line_len && SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY));\n-\t\n+\n \tif (ret == SUCCESS) {\n \t\tsize_t buf_len = intern->u.file.current_line_len;\n \t\tchar *buf = estrndup(intern->u.file.current_line, buf_len);\n@@ -2237,7 +2237,7 @@ static int spl_filesystem_file_is_empty_line(spl_filesystem_object *intern TSRML\n \t\t\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)\n \t\t\t&& zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 1) {\n \t\t\t\tzval ** first = Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;\n-\t\t\t\t\t\n+\n \t\t\t\treturn Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;\n \t\t\t}\n \t\t\treturn zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;\n@@ -2260,7 +2260,7 @@ static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object\n \t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n \t\tret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n \t}\n-\t\n+\n \treturn ret;\n }\n /* }}} */\n@@ -2294,16 +2294,16 @@ SPL_METHOD(SplFileObject, __construct)\n \tintern->u.file.open_mode = NULL;\n \tintern->u.file.open_mode_len = 0;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""p|sbr!\"", \n+\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""p|sbr!\"",\n \t\t\t&intern->file_name, &intern->file_name_len,\n-\t\t\t&intern->u.file.open_mode, &intern->u.file.open_mode_len, \n-\t\t\t&use_include_path, &intern->u.file.zcontext) == FAILURE) {\t\t\n+\t\t\t&intern->u.file.open_mode, &intern->u.file.open_mode_len,\n+\t\t\t&use_include_path, &intern->u.file.zcontext) == FAILURE) {\n \t\tintern->u.file.open_mode = NULL;\n \t\tintern->file_name = NULL;\n \t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n \t\treturn;\n \t}\n-\t\n+\n \tif (intern->u.file.open_mode == NULL) {\n \t\tintern->u.file.open_mode = \""r\"";\n \t\tintern->u.file.open_mode_len = 1;\n@@ -2368,7 +2368,7 @@ SPL_METHOD(SplTempFileObject, __construct)\n \tintern->u.file.open_mode = \""wb\"";\n \tintern->u.file.open_mode_len = 1;\n \tintern->u.file.zcontext = NULL;\n-\t\n+\n \tif (spl_filesystem_file_open(intern, 0, 0 TSRMLS_CC) == SUCCESS) {\n \t\tintern->_path_len = 0;\n \t\tintern->_path = estrndup(\""\"", 0);\n@@ -2381,7 +2381,7 @@ SPL_METHOD(SplTempFileObject, __construct)\n SPL_METHOD(SplFileObject, rewind)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -2394,7 +2394,7 @@ SPL_METHOD(SplFileObject, rewind)\n SPL_METHOD(SplFileObject, eof)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -2407,7 +2407,7 @@ SPL_METHOD(SplFileObject, eof)\n SPL_METHOD(SplFileObject, valid)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -2424,7 +2424,7 @@ SPL_METHOD(SplFileObject, valid)\n SPL_METHOD(SplFileObject, fgets)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -2440,7 +2440,7 @@ SPL_METHOD(SplFileObject, fgets)\n SPL_METHOD(SplFileObject, current)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -2461,7 +2461,7 @@ SPL_METHOD(SplFileObject, current)\n SPL_METHOD(SplFileObject, key)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -2478,7 +2478,7 @@ SPL_METHOD(SplFileObject, key)\n SPL_METHOD(SplFileObject, next)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -2530,7 +2530,7 @@ SPL_METHOD(SplFileObject, setMaxLineLen)\n \t\tzend_throw_exception_ex(spl_ce_DomainException, 0 TSRMLS_CC, \""Maximum line length must be greater than or equal zero\"");\n \t\treturn;\n \t}\n-\t\n+\n \tintern->u.file.max_line_len = max_len;\n } /* }}} */\n \n@@ -2539,7 +2539,7 @@ SPL_METHOD(SplFileObject, setMaxLineLen)\n SPL_METHOD(SplFileObject, getMaxLineLen)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -2554,7 +2554,7 @@ SPL_METHOD(SplFileObject, hasChildren)\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tRETURN_FALSE;\n } /* }}} */\n \n@@ -2585,7 +2585,7 @@ SPL_METHOD(SplFileObject, fgetcsv)\n \tchar delimiter = intern->u.file.delimiter, enclosure = intern->u.file.enclosure, escape = intern->u.file.escape;\n \tchar *delim = NULL, *enclo = NULL, *esc = NULL;\n \tint d_len = 0, e_len = 0, esc_len = 0;\n-\t\n+\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""|sss\"", &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {\n \t\tswitch(ZEND_NUM_ARGS())\n \t\t{\n@@ -2627,7 +2627,7 @@ SPL_METHOD(SplFileObject, fputcsv)\n \tchar *delim = NULL, *enclo = NULL, *esc = NULL;\n \tint d_len = 0, e_len = 0, esc_len = 0, ret;\n \tzval *fields = NULL;\n-\t\n+\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""a|sss\"", &fields, &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {\n \t\tswitch(ZEND_NUM_ARGS())\n \t\t{\n@@ -2670,7 +2670,7 @@ SPL_METHOD(SplFileObject, setCsvControl)\n \tchar delimiter = ',', enclosure = '\""', escape='\\\\';\n \tchar *delim = NULL, *enclo = NULL, *esc = NULL;\n \tint d_len = 0, e_len = 0, esc_len = 0;\n-\t\n+\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""|sss\"", &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {\n \t\tswitch(ZEND_NUM_ARGS())\n \t\t{\n@@ -2713,7 +2713,7 @@ SPL_METHOD(SplFileObject, getCsvControl)\n \tchar delimiter[2], enclosure[2];\n \n \tarray_init(return_value);\n-\t\n+\n \tdelimiter[0] = intern->u.file.delimiter;\n \tdelimiter[1] = '\\0';\n \tenclosure[0] = intern->u.file.enclosure;\n@@ -2742,7 +2742,7 @@ SPL_METHOD(SplFileObject, fflush)\n    Return current file position */\n SPL_METHOD(SplFileObject, ftell)\n {\n-\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\t\n+\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tlong ret = php_stream_tell(intern->u.file.stream);\n \n \tif (ret == -1) {\n@@ -2872,6 +2872,10 @@ SPL_METHOD(SplFileObject, fread)\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Length parameter must be greater than 0\"");\n \t\tRETURN_FALSE;\n \t}\n+\tif (length > INT_MAX) {\n+\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Length parameter must be no more than %d\"", INT_MAX);\n+\t\tRETURN_FALSE;\n+\t}\n \n \tZ_STRVAL_P(return_value) = emalloc(length + 1);\n \tZ_STRLEN_P(return_value) = php_stream_read(intern->u.file.stream, Z_STRVAL_P(return_value), length);\n@@ -2892,7 +2896,7 @@ SPL_METHOD(SplFileObject, ftruncate)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tlong size;\n-\t\n+\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""l\"", &size) == FAILURE) {\n \t\treturn;\n \t}\n@@ -2901,7 +2905,7 @@ SPL_METHOD(SplFileObject, ftruncate)\n \t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \""Can't truncate file %s\"", intern->file_name);\n \t\tRETURN_FALSE;\n \t}\n-\t\n+\n \tRETURN_BOOL(0 == php_stream_truncate_set_size(intern->u.file.stream, size));\n } /* }}} */\n \n@@ -2911,17 +2915,17 @@ SPL_METHOD(SplFileObject, seek)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tlong line_pos;\n-\t\n+\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""l\"", &line_pos) == FAILURE) {\n \t\treturn;\n \t}\n \tif (line_pos < 0) {\n \t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \""Can't seek file %s to negative line %ld\"", intern->file_name, line_pos);\n-\t\tRETURN_FALSE;\t\t\n+\t\tRETURN_FALSE;\n \t}\n-\t\n+\n \tspl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n-\t\n+\n \twhile(intern->u.file.current_line_num < line_pos) {\n \t\tif (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {\n \t\t\tbreak;\n@@ -2958,25 +2962,25 @@ ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fputcsv, 0, 0, 1)\n \tZEND_ARG_INFO(0, escape)\n ZEND_END_ARG_INFO()\n \n-ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_flock, 0, 0, 1) \n+ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_flock, 0, 0, 1)\n \tZEND_ARG_INFO(0, operation)\n \tZEND_ARG_INFO(1, wouldblock)\n ZEND_END_ARG_INFO()\n \n-ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fseek, 0, 0, 1) \n+ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fseek, 0, 0, 1)\n \tZEND_ARG_INFO(0, pos)\n \tZEND_ARG_INFO(0, whence)\n ZEND_END_ARG_INFO()\n \n-ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fgetss, 0, 0, 0) \n+ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fgetss, 0, 0, 0)\n \tZEND_ARG_INFO(0, allowable_tags)\n ZEND_END_ARG_INFO()\n \n-ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fscanf, 1, 0, 1) \n+ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fscanf, 1, 0, 1)\n \tZEND_ARG_INFO(0, format)\n ZEND_END_ARG_INFO()\n \n-ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fwrite, 0, 0, 1) \n+ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fwrite, 0, 0, 1)\n \tZEND_ARG_INFO(0, str)\n \tZEND_ARG_INFO(0, length)\n ZEND_END_ARG_INFO()\n@@ -2985,11 +2989,11 @@ ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fread, 0, 0, 1)\n \tZEND_ARG_INFO(0, length)\n ZEND_END_ARG_INFO()\n \n-ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_ftruncate, 0, 0, 1) \n+ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_ftruncate, 0, 0, 1)\n \tZEND_ARG_INFO(0, size)\n ZEND_END_ARG_INFO()\n \n-ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_seek, 0, 0, 1) \n+ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_seek, 0, 0, 1)\n \tZEND_ARG_INFO(0, line_pos)\n ZEND_END_ARG_INFO()\n \n@@ -3078,7 +3082,7 @@ PHP_MINIT_FUNCTION(spl_directory)\n \n \tREGISTER_SPL_SUB_CLASS_EX(RecursiveDirectoryIterator, FilesystemIterator, spl_filesystem_object_new, spl_RecursiveDirectoryIterator_functions);\n \tREGISTER_SPL_IMPLEMENTS(RecursiveDirectoryIterator, RecursiveIterator);\n-\t\n+\n \tmemcpy(&spl_filesystem_object_check_handlers, &spl_filesystem_object_handlers, sizeof(zend_object_handlers));\n \tspl_filesystem_object_check_handlers.get_method = spl_filesystem_object_get_method_check;\n \n@@ -3095,7 +3099,7 @@ PHP_MINIT_FUNCTION(spl_directory)\n \tREGISTER_SPL_CLASS_CONST_LONG(SplFileObject, \""READ_AHEAD\"",    SPL_FILE_OBJECT_READ_AHEAD);\n \tREGISTER_SPL_CLASS_CONST_LONG(SplFileObject, \""SKIP_EMPTY\"",    SPL_FILE_OBJECT_SKIP_EMPTY);\n \tREGISTER_SPL_CLASS_CONST_LONG(SplFileObject, \""READ_CSV\"",      SPL_FILE_OBJECT_READ_CSV);\n-\t\n+\n \tREGISTER_SPL_SUB_CLASS_EX(SplTempFileObject, SplFileObject, spl_filesystem_object_new_check, spl_SplTempFileObject_functions);\n \treturn SUCCESS;\n }""}",	/~/		RETURN_FALSE;		/~/	/~/	,"4,10,12,14","SPL_METHOD(SplFileObject, seek)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	long line_pos;

 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &line_pos) == FAILURE) {
 		return;
 	}
 	if (line_pos < 0) {
 		zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, ""Can't seek file %s to negative line %ld"", intern->file_name, line_pos);
		RETURN_FALSE;
 	}

 	spl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);

 	while(intern->u.file.current_line_num < line_pos) {
 		if (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {
 			break;
		}
	}
} /* }}} */

/* {{{ Function/Class/Method definitions */
","SPL_METHOD(SplFileObject, seek)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	long line_pos;
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &line_pos) == FAILURE) {
 		return;
 	}
 	if (line_pos < 0) {
 		zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, ""Can't seek file %s to negative line %ld"", intern->file_name, line_pos);
		RETURN_FALSE;		
 	}
 	spl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);
 	while(intern->u.file.current_line_num < line_pos) {
 		if (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {
 			break;
		}
	}
} /* }}} */

/* {{{ Function/Class/Method definitions */
",180240.0,C,"
		RETURN_FALSE;


","		RETURN_FALSE;		
",,"@@ -79,9 +79,9 @@ static void spl_filesystem_object_free_storage(void *object TSRMLS_DC) /* {{{ */
 	if (intern->oth_handler && intern->oth_handler->dtor) {
 		intern->oth_handler->dtor(intern TSRMLS_CC);
 	}
-	
+
 	zend_object_std_dtor(&intern->std TSRMLS_CC);
-	
+
 	if (intern->_path) {
 		efree(intern->_path);
 	}
@@ -98,7 +98,7 @@ static void spl_filesystem_object_free_storage(void *object TSRMLS_DC) /* {{{ */
 		}
 		if (intern->u.dir.sub_path) {
 			efree(intern->u.dir.sub_path);
-		}		
+		}
 		break;
 	case SPL_FS_FILE:
 		if (intern->u.file.stream) {
@@ -134,13 +134,13 @@ static void spl_filesystem_object_free_storage(void *object TSRMLS_DC) /* {{{ */
 } /* }}} */
 
 /* {{{ spl_ce_dir_object_new */
-/* creates the object by 
-   - allocating memory 
+/* creates the object by
+   - allocating memory
    - initializing the object members
    - storing the object
    - setting it's handlers
 
-   called from 
+   called from
    - clone
    - new
  */
@@ -313,7 +313,7 @@ static int spl_filesystem_file_open(spl_filesystem_object *intern, int use_inclu
 	/* avoid reference counting in debug mode, thus do it manually */
 	ZVAL_RESOURCE(&intern->u.file.zresource, php_stream_get_resource_id(intern->u.file.stream));
 	Z_SET_REFCOUNT(intern->u.file.zresource, 1);
-	
+
 	intern->u.file.delimiter = ',';
 	intern->u.file.enclosure = '""';
 	intern->u.file.escape = '\\';
@@ -325,7 +325,7 @@ static int spl_filesystem_file_open(spl_filesystem_object *intern, int use_inclu
 
 /* {{{ spl_filesystem_object_clone */
 /* Local zend_object_value creation (on stack)
-   Load the 'other' object 
+   Load the 'other' object
    Create a new empty object (See spl_filesystem_object_new_ex)
    Open the directory
    Clone other members (properties)
@@ -370,7 +370,7 @@ static zend_object_value spl_filesystem_object_clone(zval *zobject TSRMLS_DC)
 		php_error_docref(NULL TSRMLS_CC, E_ERROR, ""An object of class %s cannot be cloned"", old_object->ce->name);
 		break;
 	}
-	
+
 	intern->file_class = source->file_class;
 	intern->info_class = source->info_class;
 	intern->oth = source->oth;
@@ -389,7 +389,7 @@ static zend_object_value spl_filesystem_object_clone(zval *zobject TSRMLS_DC)
 void spl_filesystem_info_set_filename(spl_filesystem_object *intern, char *path, int len, int use_copy TSRMLS_DC) /* {{{ */
 {
 	char *p1, *p2;
-	
+
 	if (intern->file_name) {
 		efree(intern->file_name);
 	}
@@ -413,7 +413,7 @@ void spl_filesystem_info_set_filename(spl_filesystem_object *intern, char *path,
 	} else {
 		intern->_path_len = 0;
 	}
-	
+
 	if (intern->_path) {
 		efree(intern->_path);
 	}
@@ -459,7 +459,7 @@ static spl_filesystem_object * spl_filesystem_object_create_info(spl_filesystem_
 	} else {
 		spl_filesystem_info_set_filename(intern, file_path, file_path_len, use_copy TSRMLS_CC);
 	}
-	
+
 	zend_restore_error_handling(&error_handling TSRMLS_CC);
 	return intern;
 } /* }}} */
@@ -514,7 +514,7 @@ static spl_filesystem_object * spl_filesystem_object_create_type(int ht, spl_fil
 
 		return_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC);
 		Z_TYPE_P(return_value) = IS_OBJECT;
-	
+
 		spl_filesystem_object_get_file_name(source TSRMLS_CC);
 
 		if (ce->constructor->common.scope != spl_ce_SplFileObject) {
@@ -530,12 +530,12 @@ static spl_filesystem_object * spl_filesystem_object_create_type(int ht, spl_fil
 			intern->file_name_len = source->file_name_len;
 			intern->_path = spl_filesystem_object_get_path(source, &intern->_path_len TSRMLS_CC);
 			intern->_path = estrndup(intern->_path, intern->_path_len);
-		
+
 			intern->u.file.open_mode = ""r"";
 			intern->u.file.open_mode_len = 1;
-		
-			if (ht && zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|sbr"", 
-					&intern->u.file.open_mode, &intern->u.file.open_mode_len, 
+
+			if (ht && zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|sbr"",
+					&intern->u.file.open_mode, &intern->u.file.open_mode_len,
 					&use_include_path, &intern->u.file.zcontext) == FAILURE) {
 				zend_restore_error_handling(&error_handling TSRMLS_CC);
 				intern->u.file.open_mode = NULL;
@@ -544,7 +544,7 @@ static spl_filesystem_object * spl_filesystem_object_create_type(int ht, spl_fil
 				Z_TYPE_P(return_value) = IS_NULL;
 				return NULL;
 			}
-		
+
 			if (spl_filesystem_file_open(intern, use_include_path, 0 TSRMLS_CC) == FAILURE) {
 				zend_restore_error_handling(&error_handling TSRMLS_CC);
 				zval_dtor(return_value);
@@ -553,7 +553,7 @@ static spl_filesystem_object * spl_filesystem_object_create_type(int ht, spl_fil
 			}
 		}
 		break;
-	case SPL_FS_DIR:	
+	case SPL_FS_DIR:
 		zend_restore_error_handling(&error_handling TSRMLS_CC);
 		zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, ""Operation not supported"");
 		return NULL;
@@ -617,7 +617,7 @@ static HashTable* spl_filesystem_object_get_debug_info(zval *obj, int *is_temp T
 	if (intern->file_name) {
 		pnstr = spl_gen_private_prop_name(spl_ce_SplFileInfo, ""fileName"", sizeof(""fileName"")-1, &pnlen TSRMLS_CC);
 		spl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);
-		
+
 		if (path_len && path_len < intern->file_name_len) {
 			add_assoc_stringl_ex(&zrv, pnstr, pnlen+1, intern->file_name + path_len + 1, intern->file_name_len - (path_len + 1), 1);
 		} else {
@@ -665,13 +665,13 @@ static HashTable* spl_filesystem_object_get_debug_info(zval *obj, int *is_temp T
 zend_function *spl_filesystem_object_get_method_check(zval **object_ptr, char *method, int method_len, const struct _zend_literal *key TSRMLS_DC) /* {{{ */
 {
 	spl_filesystem_object *fsobj = zend_object_store_get_object(*object_ptr TSRMLS_CC);
-	
+
 	if (fsobj->u.dir.entry.d_name[0] == '\0' && fsobj->orig_path == NULL) {
 		method = ""_bad_state_ex"";
 		method_len = sizeof(""_bad_state_ex"") - 1;
 		key = NULL;
 	}
-	
+
 	return zend_get_std_object_handlers()->get_method(object_ptr, method, method_len, key TSRMLS_CC);
 }
 /* }}} */
@@ -751,7 +751,7 @@ SPL_METHOD(DirectoryIterator, __construct)
 SPL_METHOD(DirectoryIterator, rewind)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -769,7 +769,7 @@ SPL_METHOD(DirectoryIterator, rewind)
 SPL_METHOD(DirectoryIterator, key)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -799,7 +799,7 @@ SPL_METHOD(DirectoryIterator, next)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -859,7 +859,7 @@ SPL_METHOD(DirectoryIterator, seek)
 SPL_METHOD(DirectoryIterator, valid)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -875,7 +875,7 @@ SPL_METHOD(SplFileInfo, getPath)
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	char *path;
 	int path_len;
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -891,13 +891,13 @@ SPL_METHOD(SplFileInfo, getFilename)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	int path_len;
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
 
 	spl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);
-	
+
 	if (path_len && path_len < intern->file_name_len) {
 		RETURN_STRINGL(intern->file_name + path_len + 1, intern->file_name_len - (path_len + 1), 1);
 	} else {
@@ -911,7 +911,7 @@ SPL_METHOD(SplFileInfo, getFilename)
 SPL_METHOD(DirectoryIterator, getFilename)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -1019,7 +1019,7 @@ SPL_METHOD(SplFileInfo, getBasename)
 
 	RETURN_STRINGL(fname, flen, 0);
 }
-/* }}}*/   
+/* }}}*/
 
 /* {{{ proto string DirectoryIterator::getBasename([string $suffix]) U
    Returns filename component of current dir entry */
@@ -1029,7 +1029,7 @@ SPL_METHOD(DirectoryIterator, getBasename)
 	char *suffix = 0, *fname;
 	int slen = 0;
 	size_t flen;
-	
+
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|s"", &suffix, &slen) == FAILURE) {
 		return;
 	}
@@ -1065,7 +1065,7 @@ SPL_METHOD(SplFileInfo, getPathname)
 SPL_METHOD(FilesystemIterator, key)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -1084,7 +1084,7 @@ SPL_METHOD(FilesystemIterator, key)
 SPL_METHOD(FilesystemIterator, current)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -1107,7 +1107,7 @@ SPL_METHOD(FilesystemIterator, current)
 SPL_METHOD(DirectoryIterator, isDot)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -1121,8 +1121,8 @@ SPL_METHOD(DirectoryIterator, isDot)
 /* zend_replace_error_handling() is used to throw exceptions in case
    the constructor fails. Here we use this to ensure the object
    has a valid directory resource.
-   
-   When the constructor gets called the object is already created 
+
+   When the constructor gets called the object is already created
    by the engine, so we must only call 'additional' initializations.
  */
 SPL_METHOD(SplFileInfo, __construct)
@@ -1140,11 +1140,11 @@ SPL_METHOD(SplFileInfo, __construct)
 	}
 
 	intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	spl_filesystem_info_set_filename(intern, path, len, 1 TSRMLS_CC);
 
 	zend_restore_error_handling(&error_handling TSRMLS_CC);
-	
+
 	/* intern->type = SPL_FS_INFO; already set */
 }
 /* }}} */
@@ -1249,7 +1249,7 @@ SPL_METHOD(SplFileInfo, getLinkTarget)
 	int ret;
 	char buff[MAXPATHLEN];
 	zend_error_handling error_handling;
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -1297,7 +1297,7 @@ SPL_METHOD(SplFileInfo, getRealPath)
 	char buff[MAXPATHLEN];
 	char *filename;
 	zend_error_handling error_handling;
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -1307,10 +1307,10 @@ SPL_METHOD(SplFileInfo, getRealPath)
 	if (intern->type == SPL_FS_DIR && !intern->file_name && intern->u.dir.entry.d_name[0]) {
 		spl_filesystem_object_get_file_name(intern TSRMLS_CC);
 	}
-	
+
 	if (intern->orig_path) {
 		filename = intern->orig_path;
-	} else { 
+	} else {
 		filename = intern->file_name;
 	}
 
@@ -1348,7 +1348,7 @@ SPL_METHOD(SplFileInfo, setFileClass)
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	zend_class_entry *ce = spl_ce_SplFileObject;
 	zend_error_handling error_handling;
-	
+
 	zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|C"", &ce) == SUCCESS) {
@@ -1366,7 +1366,7 @@ SPL_METHOD(SplFileInfo, setInfoClass)
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	zend_class_entry *ce = spl_ce_SplFileInfo;
 	zend_error_handling error_handling;
-	
+
 	zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling  TSRMLS_CC);
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|C"", &ce) == SUCCESS) {
@@ -1384,7 +1384,7 @@ SPL_METHOD(SplFileInfo, getFileInfo)
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	zend_class_entry *ce = intern->info_class;
 	zend_error_handling error_handling;
-	
+
 	zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|C"", &ce) == SUCCESS) {
@@ -1402,7 +1402,7 @@ SPL_METHOD(SplFileInfo, getPathInfo)
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	zend_class_entry *ce = intern->info_class;
 	zend_error_handling error_handling;
-	
+
 	zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|C"", &ce) == SUCCESS) {
@@ -1463,7 +1463,7 @@ SPL_METHOD(FilesystemIterator, rewind)
 SPL_METHOD(FilesystemIterator, getFlags)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -1519,11 +1519,11 @@ SPL_METHOD(RecursiveDirectoryIterator, getChildren)
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	spl_filesystem_object *subdir;
 	char slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
-	
+
 	spl_filesystem_object_get_file_name(intern TSRMLS_CC);
 
 	MAKE_STD_ZVAL(zflags);
@@ -1554,7 +1554,7 @@ SPL_METHOD(RecursiveDirectoryIterator, getChildren)
 SPL_METHOD(RecursiveDirectoryIterator, getSubPath)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -1575,7 +1575,7 @@ SPL_METHOD(RecursiveDirectoryIterator, getSubPathname)
 	char *sub_name;
 	int len;
 	char slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -1611,7 +1611,7 @@ SPL_METHOD(GlobIterator, __construct)
 SPL_METHOD(GlobIterator, count)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -1666,7 +1666,7 @@ zend_object_iterator *spl_filesystem_dir_get_iterator(zend_class_entry *ce, zval
 		iterator->current = object;
 	}
 	zval_add_ref(&object);
-	
+
 	return (zend_object_iterator*)iterator;
 }
 /* }}} */
@@ -1701,7 +1701,7 @@ static int spl_filesystem_dir_it_valid(zend_object_iterator *iter TSRMLS_DC)
 static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)
 {
 	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
-	
+
 	*data = &iterator->current;
 }
 /* }}} */
@@ -1719,7 +1719,7 @@ static void spl_filesystem_dir_it_current_key(zend_object_iterator *iter, zval *
 static void spl_filesystem_dir_it_move_forward(zend_object_iterator *iter TSRMLS_DC)
 {
 	spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
-	
+
 	object->u.dir.index++;
 	spl_filesystem_dir_read(object TSRMLS_CC);
 	if (object->file_name) {
@@ -1733,7 +1733,7 @@ static void spl_filesystem_dir_it_move_forward(zend_object_iterator *iter TSRMLS
 static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)
 {
 	spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
-	
+
 	object->u.dir.index = 0;
 	if (object->u.dir.dirp) {
 		php_stream_rewinddir(object->u.dir.dirp);
@@ -1803,7 +1803,7 @@ static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRML
 {
 	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
 	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);
-	
+
 	object->u.dir.index++;
 	do {
 		spl_filesystem_dir_read(object TSRMLS_CC);
@@ -1824,7 +1824,7 @@ static void spl_filesystem_tree_it_rewind(zend_object_iterator *iter TSRMLS_DC)
 {
 	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
 	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);
-	
+
 	object->u.dir.index = 0;
 	if (object->u.dir.dirp) {
 		php_stream_rewinddir(object->u.dir.dirp);
@@ -1868,7 +1868,7 @@ zend_object_iterator *spl_filesystem_tree_get_iterator(zend_class_entry *ce, zva
 		iterator->intern.funcs = &spl_filesystem_tree_it_funcs;
 	}
 	zval_add_ref(&object);
-	
+
 	return (zend_object_iterator*)iterator;
 }
 /* }}} */
@@ -1924,7 +1924,7 @@ static int spl_filesystem_object_cast(zval *readobj, zval *writeobj, int type TS
 
 /* {{{ declare method parameters */
 /* supply a name and default to call by parameter */
-ZEND_BEGIN_ARG_INFO(arginfo_info___construct, 0) 
+ZEND_BEGIN_ARG_INFO(arginfo_info___construct, 0)
 	ZEND_ARG_INFO(0, file_name)
 ZEND_END_ARG_INFO()
 
@@ -1983,11 +1983,11 @@ static const zend_function_entry spl_SplFileInfo_functions[] = {
 	PHP_FE_END
 };
 
-ZEND_BEGIN_ARG_INFO(arginfo_dir___construct, 0) 
+ZEND_BEGIN_ARG_INFO(arginfo_dir___construct, 0)
 	ZEND_ARG_INFO(0, path)
 ZEND_END_ARG_INFO()
 
-ZEND_BEGIN_ARG_INFO(arginfo_dir_it_seek, 0) 
+ZEND_BEGIN_ARG_INFO(arginfo_dir_it_seek, 0)
 	ZEND_ARG_INFO(0, position)
 ZEND_END_ARG_INFO();
 
@@ -2009,7 +2009,7 @@ static const zend_function_entry spl_DirectoryIterator_functions[] = {
 	PHP_FE_END
 };
 
-ZEND_BEGIN_ARG_INFO_EX(arginfo_r_dir___construct, 0, 0, 1) 
+ZEND_BEGIN_ARG_INFO_EX(arginfo_r_dir___construct, 0, 0, 1)
 	ZEND_ARG_INFO(0, path)
 	ZEND_ARG_INFO(0, flags)
 ZEND_END_ARG_INFO()
@@ -2058,7 +2058,7 @@ static int spl_filesystem_file_read(spl_filesystem_object *intern, int silent TS
 	long line_add = (intern->u.file.current_line || intern->u.file.current_zval) ? 1 : 0;
 
 	spl_filesystem_file_free_line(intern TSRMLS_CC);
-	
+
 	if (php_stream_eof(intern->u.file.stream)) {
 		if (!silent) {
 			zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, ""Cannot read from file %s"", intern->file_name);
@@ -2086,7 +2086,7 @@ static int spl_filesystem_file_read(spl_filesystem_object *intern, int silent TS
 			line_len = strcspn(buf, ""\r\n"");
 			buf[line_len] = '\0';
 		}
-	
+
 		intern->u.file.current_line = buf;
 		intern->u.file.current_line_len = line_len;
 	}
@@ -2107,7 +2107,7 @@ static int spl_filesystem_file_call(spl_filesystem_object *intern, zend_function
 	zval ***params = (zval***)safe_emalloc(num_args, sizeof(zval**), 0);
 
 	params[0] = &zresource_ptr;
-	
+
 	if (arg2) {
 		params[1] = &arg2;
 	}
@@ -2133,7 +2133,7 @@ static int spl_filesystem_file_call(spl_filesystem_object *intern, zend_function
 	fcic.object_ptr = NULL;
 
 	result = zend_call_function(&fci, &fcic TSRMLS_CC);
-	
+
 	if (result == FAILURE) {
 		RETVAL_FALSE;
 	} else {
@@ -2159,11 +2159,11 @@ static int spl_filesystem_file_call(spl_filesystem_object *intern, zend_function
 static int spl_filesystem_file_read_csv(spl_filesystem_object *intern, char delimiter, char enclosure, char escape, zval *return_value TSRMLS_DC) /* {{{ */
 {
 	int ret = SUCCESS;
-	
+
 	do {
 		ret = spl_filesystem_file_read(intern, 1 TSRMLS_CC);
 	} while (ret == SUCCESS && !intern->u.file.current_line_len && SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY));
-	
+
 	if (ret == SUCCESS) {
 		size_t buf_len = intern->u.file.current_line_len;
 		char *buf = estrndup(intern->u.file.current_line, buf_len);
@@ -2237,7 +2237,7 @@ static int spl_filesystem_file_is_empty_line(spl_filesystem_object *intern TSRML
 			if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)
 			&& zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 1) {
 				zval ** first = Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;
-					
+
 				return Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;
 			}
 			return zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;
@@ -2260,7 +2260,7 @@ static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object
 		spl_filesystem_file_free_line(intern TSRMLS_CC);
 		ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);
 	}
-	
+
 	return ret;
 }
 /* }}} */
@@ -2294,16 +2294,16 @@ SPL_METHOD(SplFileObject, __construct)
 	intern->u.file.open_mode = NULL;
 	intern->u.file.open_mode_len = 0;
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|sbr!"", 
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|sbr!"",
 			&intern->file_name, &intern->file_name_len,
-			&intern->u.file.open_mode, &intern->u.file.open_mode_len, 
-			&use_include_path, &intern->u.file.zcontext) == FAILURE) {		
+			&intern->u.file.open_mode, &intern->u.file.open_mode_len,
+			&use_include_path, &intern->u.file.zcontext) == FAILURE) {
 		intern->u.file.open_mode = NULL;
 		intern->file_name = NULL;
 		zend_restore_error_handling(&error_handling TSRMLS_CC);
 		return;
 	}
-	
+
 	if (intern->u.file.open_mode == NULL) {
 		intern->u.file.open_mode = ""r"";
 		intern->u.file.open_mode_len = 1;
@@ -2368,7 +2368,7 @@ SPL_METHOD(SplTempFileObject, __construct)
 	intern->u.file.open_mode = ""wb"";
 	intern->u.file.open_mode_len = 1;
 	intern->u.file.zcontext = NULL;
-	
+
 	if (spl_filesystem_file_open(intern, 0, 0 TSRMLS_CC) == SUCCESS) {
 		intern->_path_len = 0;
 		intern->_path = estrndup("""", 0);
@@ -2381,7 +2381,7 @@ SPL_METHOD(SplTempFileObject, __construct)
 SPL_METHOD(SplFileObject, rewind)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -2394,7 +2394,7 @@ SPL_METHOD(SplFileObject, rewind)
 SPL_METHOD(SplFileObject, eof)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -2407,7 +2407,7 @@ SPL_METHOD(SplFileObject, eof)
 SPL_METHOD(SplFileObject, valid)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -2424,7 +2424,7 @@ SPL_METHOD(SplFileObject, valid)
 SPL_METHOD(SplFileObject, fgets)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -2440,7 +2440,7 @@ SPL_METHOD(SplFileObject, fgets)
 SPL_METHOD(SplFileObject, current)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -2461,7 +2461,7 @@ SPL_METHOD(SplFileObject, current)
 SPL_METHOD(SplFileObject, key)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -2478,7 +2478,7 @@ SPL_METHOD(SplFileObject, key)
 SPL_METHOD(SplFileObject, next)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -2530,7 +2530,7 @@ SPL_METHOD(SplFileObject, setMaxLineLen)
 		zend_throw_exception_ex(spl_ce_DomainException, 0 TSRMLS_CC, ""Maximum line length must be greater than or equal zero"");
 		return;
 	}
-	
+
 	intern->u.file.max_line_len = max_len;
 } /* }}} */
 
@@ -2539,7 +2539,7 @@ SPL_METHOD(SplFileObject, setMaxLineLen)
 SPL_METHOD(SplFileObject, getMaxLineLen)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
-	
+
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
@@ -2554,7 +2554,7 @@ SPL_METHOD(SplFileObject, hasChildren)
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
-	
+
 	RETURN_FALSE;
 } /* }}} */
 
@@ -2585,7 +2585,7 @@ SPL_METHOD(SplFileObject, fgetcsv)
 	char delimiter = intern->u.file.delimiter, enclosure = intern->u.file.enclosure, escape = intern->u.file.escape;
 	char *delim = NULL, *enclo = NULL, *esc = NULL;
 	int d_len = 0, e_len = 0, esc_len = 0;
-	
+
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|sss"", &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {
 		switch(ZEND_NUM_ARGS())
 		{
@@ -2627,7 +2627,7 @@ SPL_METHOD(SplFileObject, fputcsv)
 	char *delim = NULL, *enclo = NULL, *esc = NULL;
 	int d_len = 0, e_len = 0, esc_len = 0, ret;
 	zval *fields = NULL;
-	
+
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""a|sss"", &fields, &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {
 		switch(ZEND_NUM_ARGS())
 		{
@@ -2670,7 +2670,7 @@ SPL_METHOD(SplFileObject, setCsvControl)
 	char delimiter = ',', enclosure = '""', escape='\\';
 	char *delim = NULL, *enclo = NULL, *esc = NULL;
 	int d_len = 0, e_len = 0, esc_len = 0;
-	
+
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|sss"", &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {
 		switch(ZEND_NUM_ARGS())
 		{
@@ -2713,7 +2713,7 @@ SPL_METHOD(SplFileObject, getCsvControl)
 	char delimiter[2], enclosure[2];
 
 	array_init(return_value);
-	
+
 	delimiter[0] = intern->u.file.delimiter;
 	delimiter[1] = '\0';
 	enclosure[0] = intern->u.file.enclosure;
@@ -2742,7 +2742,7 @@ SPL_METHOD(SplFileObject, fflush)
    Return current file position */
 SPL_METHOD(SplFileObject, ftell)
 {
-	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);	
+	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	long ret = php_stream_tell(intern->u.file.stream);
 
 	if (ret == -1) {
@@ -2872,6 +2872,10 @@ SPL_METHOD(SplFileObject, fread)
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Length parameter must be greater than 0"");
 		RETURN_FALSE;
 	}
+	if (length > INT_MAX) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Length parameter must be no more than %d"", INT_MAX);
+		RETURN_FALSE;
+	}
 
 	Z_STRVAL_P(return_value) = emalloc(length + 1);
 	Z_STRLEN_P(return_value) = php_stream_read(intern->u.file.stream, Z_STRVAL_P(return_value), length);
@@ -2892,7 +2896,7 @@ SPL_METHOD(SplFileObject, ftruncate)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	long size;
-	
+
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &size) == FAILURE) {
 		return;
 	}
@@ -2901,7 +2905,7 @@ SPL_METHOD(SplFileObject, ftruncate)
 		zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, ""Can't truncate file %s"", intern->file_name);
 		RETURN_FALSE;
 	}
-	
+
 	RETURN_BOOL(0 == php_stream_truncate_set_size(intern->u.file.stream, size));
 } /* }}} */
 
@@ -2911,17 +2915,17 @@ SPL_METHOD(SplFileObject, seek)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	long line_pos;
-	
+
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &line_pos) == FAILURE) {
 		return;
 	}
 	if (line_pos < 0) {
 		zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, ""Can't seek file %s to negative line %ld"", intern->file_name, line_pos);
-		RETURN_FALSE;		
+		RETURN_FALSE;
 	}
-	
+
 	spl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);
-	
+
 	while(intern->u.file.current_line_num < line_pos) {
 		if (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {
 			break;
@@ -2958,25 +2962,25 @@ ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fputcsv, 0, 0, 1)
 	ZEND_ARG_INFO(0, escape)
 ZEND_END_ARG_INFO()
 
-ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_flock, 0, 0, 1) 
+ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_flock, 0, 0, 1)
 	ZEND_ARG_INFO(0, operation)
 	ZEND_ARG_INFO(1, wouldblock)
 ZEND_END_ARG_INFO()
 
-ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fseek, 0, 0, 1) 
+ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fseek, 0, 0, 1)
 	ZEND_ARG_INFO(0, pos)
 	ZEND_ARG_INFO(0, whence)
 ZEND_END_ARG_INFO()
 
-ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fgetss, 0, 0, 0) 
+ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fgetss, 0, 0, 0)
 	ZEND_ARG_INFO(0, allowable_tags)
 ZEND_END_ARG_INFO()
 
-ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fscanf, 1, 0, 1) 
+ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fscanf, 1, 0, 1)
 	ZEND_ARG_INFO(0, format)
 ZEND_END_ARG_INFO()
 
-ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fwrite, 0, 0, 1) 
+ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fwrite, 0, 0, 1)
 	ZEND_ARG_INFO(0, str)
 	ZEND_ARG_INFO(0, length)
 ZEND_END_ARG_INFO()
@@ -2985,11 +2989,11 @@ ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fread, 0, 0, 1)
 	ZEND_ARG_INFO(0, length)
 ZEND_END_ARG_INFO()
 
-ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_ftruncate, 0, 0, 1) 
+ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_ftruncate, 0, 0, 1)
 	ZEND_ARG_INFO(0, size)
 ZEND_END_ARG_INFO()
 
-ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_seek, 0, 0, 1) 
+ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_seek, 0, 0, 1)
 	ZEND_ARG_INFO(0, line_pos)
 ZEND_END_ARG_INFO()
 
@@ -3078,7 +3082,7 @@ PHP_MINIT_FUNCTION(spl_directory)
 
 	REGISTER_SPL_SUB_CLASS_EX(RecursiveDirectoryIterator, FilesystemIterator, spl_filesystem_object_new, spl_RecursiveDirectoryIterator_functions);
 	REGISTER_SPL_IMPLEMENTS(RecursiveDirectoryIterator, RecursiveIterator);
-	
+
 	memcpy(&spl_filesystem_object_check_handlers, &spl_filesystem_object_handlers, sizeof(zend_object_handlers));
 	spl_filesystem_object_check_handlers.get_method = spl_filesystem_object_get_method_check;
 
@@ -3095,7 +3099,7 @@ PHP_MINIT_FUNCTION(spl_directory)
 	REGISTER_SPL_CLASS_CONST_LONG(SplFileObject, ""READ_AHEAD"",    SPL_FILE_OBJECT_READ_AHEAD);
 	REGISTER_SPL_CLASS_CONST_LONG(SplFileObject, ""SKIP_EMPTY"",    SPL_FILE_OBJECT_SKIP_EMPTY);
 	REGISTER_SPL_CLASS_CONST_LONG(SplFileObject, ""READ_CSV"",      SPL_FILE_OBJECT_READ_CSV);
-	
+
 	REGISTER_SPL_SUB_CLASS_EX(SplTempFileObject, SplFileObject, spl_filesystem_object_new_check, spl_SplTempFileObject_functions);
 	return SUCCESS;
 }","SPL_METHOD(SplFileObject, seek)
{
spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
long line_pos;
	
if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &line_pos) == FAILURE) {
return;
}
if (line_pos < 0) {
zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, ""Can't seek file %s to negative line %ld"", intern->file_name, line_pos);
		RETURN_FALSE;		
}
	
spl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);
	
while(intern->u.file.current_line_num < line_pos) {
if (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {
break;
}
}
} /* }}} */

/* {{{ Function/Class/Method definitions */
",php-src,7245bff300d3fa8bacbef7897ff080a6f1c23eba?w=1,88746d60ab3ad51797612ee62603bb3e08d4aac4,1.0,"SPL_METHOD(SplFileObject, seek)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	long line_pos;
//flaw_line_below:
	
//fix_flaw_line_below:
//
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &line_pos) == FAILURE) {
 		return;
 	}
 	if (line_pos < 0) {
 		zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, ""Can't seek file %s to negative line %ld"", intern->file_name, line_pos);
//flaw_line_below:
		RETURN_FALSE;		
//fix_flaw_line_below:
//		RETURN_FALSE;
 	}
//flaw_line_below:
	
//fix_flaw_line_below:
//
 	spl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);
//flaw_line_below:
	
//fix_flaw_line_below:
//
 	while(intern->u.file.current_line_num < line_pos) {
 		if (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {
 			break;
		}
	}
} /* }}} */

/* {{{ Function/Class/Method definitions */
"
735,None,Remote,Not required,None,CVE-2015-1285,https://www.cvedetails.com/cve/CVE-2015-1285/,CWE-200,Low,Partial,None,,2015-07-22,5.0,"The XSSAuditor::canonicalize function in core/html/parser/XSSAuditor.cpp in the XSS auditor in Blink, as used in Google Chrome before 44.0.2403.89, does not properly choose a truncation point, which makes it easier for remote attackers to obtain sensitive information via an unspecified linear-time attack.",2018-10-30,XSS +Info ,1.0,https://github.com/chromium/chromium/commit/39595f8d4dffcb644d438106dcb64a30c139ff0e,39595f8d4dffcb644d438106dcb64a30c139ff0e,"[reland] Do not set default wallpaper unless it should do so.

TBR=bshe@chromium.org, alemate@chromium.org

Bug: 751382
Change-Id: Id0793dfe467f737526a95b1e66ed01fbb8860bda
Reviewed-on: https://chromium-review.googlesource.com/619754
Commit-Queue: Xiaoqian Dai <xdai@chromium.org>
Reviewed-by: Alexander Alekseev <alemate@chromium.org>
Reviewed-by: Biao She <bshe@chromium.org>
Cr-Original-Commit-Position: refs/heads/master@{#498325}
Reviewed-on: https://chromium-review.googlesource.com/646430
Cr-Commit-Position: refs/heads/master@{#498982}",2.0,chrome/browser/chromeos/login/users/wallpaper/wallpaper_manager.cc,"{""sha"": ""38ad4b2bef917214e3eaccfe55915878343aac18"", ""filename"": ""chrome/browser/chromeos/login/users/wallpaper/wallpaper_manager.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 20, ""changes"": 50, ""blob_url"": ""https://github.com/chromium/chromium/blob/39595f8d4dffcb644d438106dcb64a30c139ff0e/chrome/browser/chromeos/login/users/wallpaper/wallpaper_manager.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/39595f8d4dffcb644d438106dcb64a30c139ff0e/chrome/browser/chromeos/login/users/wallpaper/wallpaper_manager.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chromeos/login/users/wallpaper/wallpaper_manager.cc?ref=39595f8d4dffcb644d438106dcb64a30c139ff0e"", ""patch"": ""@@ -334,7 +334,8 @@ class WallpaperManager::PendingWallpaper :\n     started_load_at_ = base::Time::Now();\n \n     if (default_) {\n-      manager->DoSetDefaultWallpaper(account_id_, std::move(on_finish_));\n+      manager->DoSetDefaultWallpaper(account_id_, true /* update_wallpaper */,\n+                                     std::move(on_finish_));\n     } else if (!user_wallpaper_.isNull()) {\n       SetWallpaper(user_wallpaper_, info_);\n     } else if (!wallpaper_path_.empty()) {\n@@ -347,7 +348,8 @@ class WallpaperManager::PendingWallpaper :\n                          base::Passed(std::move(on_finish_)),\n                          manager->weak_factory_.GetWeakPtr()));\n     } else if (!info_.location.empty()) {\n-      manager->LoadWallpaper(account_id_, info_, true, std::move(on_finish_));\n+      manager->LoadWallpaper(account_id_, info_, true /* update_wallpaper */,\n+                             std::move(on_finish_));\n     } else {\n       // PendingWallpaper was created and never initialized?\n       NOTREACHED();\n@@ -696,6 +698,7 @@ void WallpaperManager::SetDefaultWallpaperDelayed(const AccountId& account_id) {\n \n void WallpaperManager::DoSetDefaultWallpaper(\n     const AccountId& account_id,\n+    bool update_wallpaper,\n     MovableOnDestroyCallbackHolder on_finish) {\n   // There is no visible wallpaper in kiosk mode.\n   if (user_manager::UserManager::Get()->IsLoggedInAsKioskApp())\n@@ -729,21 +732,26 @@ void WallpaperManager::DoSetDefaultWallpaper(\n     default_wallpaper_image_.reset();\n     if (!file->empty()) {\n       loaded_wallpapers_for_test_++;\n-      StartLoadAndSetDefaultWallpaper(*file, layout, std::move(on_finish),\n+      StartLoadAndSetDefaultWallpaper(*file, layout, update_wallpaper,\n+                                      std::move(on_finish),\n                                       &default_wallpaper_image_);\n       return;\n     }\n \n     CreateSolidDefaultWallpaper();\n   }\n-  // 1x1 wallpaper is actually solid color, so it should be stretched.\n-  if (default_wallpaper_image_->image().width() == 1 &&\n-      default_wallpaper_image_->image().height() == 1)\n-    layout = wallpaper::WALLPAPER_LAYOUT_STRETCH;\n-\n-  WallpaperInfo info(default_wallpaper_image_->file_path().value(), layout,\n-                     wallpaper::DEFAULT, base::Time::Now().LocalMidnight());\n-  SetWallpaper(default_wallpaper_image_->image(), info);\n+\n+  if (update_wallpaper) {\n+    // 1x1 wallpaper is actually solid color, so it should be stretched.\n+    if (default_wallpaper_image_->image().width() == 1 &&\n+        default_wallpaper_image_->image().height() == 1) {\n+      layout = wallpaper::WALLPAPER_LAYOUT_STRETCH;\n+    }\n+\n+    WallpaperInfo info(default_wallpaper_image_->file_path().value(), layout,\n+                       wallpaper::DEFAULT, base::Time::Now().LocalMidnight());\n+    SetWallpaper(default_wallpaper_image_->image(), info);\n+  }\n }\n \n void WallpaperManager::SetUserWallpaperInfo(const AccountId& account_id,\n@@ -1263,9 +1271,7 @@ void WallpaperManager::OnWallpaperDecoded(\n         \""\"", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::DEFAULT,\n         base::Time::Now().LocalMidnight());\n     SetUserWallpaperInfo(account_id, default_info, true);\n-\n-    if (update_wallpaper)\n-      DoSetDefaultWallpaper(account_id, std::move(on_finish));\n+    DoSetDefaultWallpaper(account_id, update_wallpaper, std::move(on_finish));\n     return;\n   }\n \n@@ -1404,6 +1410,7 @@ void WallpaperManager::SetDefaultWallpaperPathsFromCommandLine(\n void WallpaperManager::OnDefaultWallpaperDecoded(\n     const base::FilePath& path,\n     const wallpaper::WallpaperLayout layout,\n+    bool update_wallpaper,\n     std::unique_ptr<user_manager::UserImage>* result_out,\n     MovableOnDestroyCallbackHolder on_finish,\n     std::unique_ptr<user_manager::UserImage> user_image) {\n@@ -1413,21 +1420,24 @@ void WallpaperManager::OnDefaultWallpaperDecoded(\n   }\n \n   *result_out = std::move(user_image);\n-  WallpaperInfo info(path.value(), layout, wallpaper::DEFAULT,\n-                     base::Time::Now().LocalMidnight());\n-  SetWallpaper((*result_out)->image(), info);\n+  if (update_wallpaper) {\n+    WallpaperInfo info(path.value(), layout, wallpaper::DEFAULT,\n+                       base::Time::Now().LocalMidnight());\n+    SetWallpaper((*result_out)->image(), info);\n+  }\n }\n \n void WallpaperManager::StartLoadAndSetDefaultWallpaper(\n     const base::FilePath& path,\n     const wallpaper::WallpaperLayout layout,\n+    bool update_wallpaper,\n     MovableOnDestroyCallbackHolder on_finish,\n     std::unique_ptr<user_manager::UserImage>* result_out) {\n   user_image_loader::StartWithFilePath(\n       task_runner_, path, ImageDecoder::ROBUST_JPEG_CODEC,\n       0,  // Do not crop.\n       base::Bind(&WallpaperManager::OnDefaultWallpaperDecoded,\n-                 weak_factory_.GetWeakPtr(), path, layout,\n+                 weak_factory_.GetWeakPtr(), path, layout, update_wallpaper,\n                  base::Unretained(result_out),\n                  base::Passed(std::move(on_finish))));\n }\n@@ -1469,8 +1479,8 @@ void WallpaperManager::SetDefaultWallpaperPath(\n     }\n   }\n \n-  if (need_update_screen)\n-    DoSetDefaultWallpaper(EmptyAccountId(), MovableOnDestroyCallbackHolder());\n+  DoSetDefaultWallpaper(EmptyAccountId(), need_update_screen,\n+                        MovableOnDestroyCallbackHolder());\n }\n \n void WallpaperManager::RecordWallpaperAppType() {""}<_**next**_>{""sha"": ""87154399b67f11057daaa1ff257482d5778577ad"", ""filename"": ""chrome/browser/chromeos/login/users/wallpaper/wallpaper_manager.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/39595f8d4dffcb644d438106dcb64a30c139ff0e/chrome/browser/chromeos/login/users/wallpaper/wallpaper_manager.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/39595f8d4dffcb644d438106dcb64a30c139ff0e/chrome/browser/chromeos/login/users/wallpaper/wallpaper_manager.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chromeos/login/users/wallpaper/wallpaper_manager.h?ref=39595f8d4dffcb644d438106dcb64a30c139ff0e"", ""patch"": ""@@ -82,6 +82,7 @@ class WallpaperManager\n   void SetDefaultWallpaperDelayed(const AccountId& account_id) override;\n   void DoSetDefaultWallpaper(\n       const AccountId& account_id,\n+      bool update_wallpaper,\n       wallpaper::MovableOnDestroyCallbackHolder on_finish) override;\n   void SetUserWallpaperInfo(const AccountId& account_id,\n                             const wallpaper::WallpaperInfo& info,\n@@ -200,12 +201,14 @@ class WallpaperManager\n   void OnDefaultWallpaperDecoded(\n       const base::FilePath& path,\n       const wallpaper::WallpaperLayout layout,\n+      bool update_wallpaper,\n       std::unique_ptr<user_manager::UserImage>* result,\n       wallpaper::MovableOnDestroyCallbackHolder on_finish,\n       std::unique_ptr<user_manager::UserImage> user_image) override;\n   void StartLoadAndSetDefaultWallpaper(\n       const base::FilePath& path,\n       const wallpaper::WallpaperLayout layout,\n+      bool update_wallpaper,\n       wallpaper::MovableOnDestroyCallbackHolder on_finish,\n       std::unique_ptr<user_manager::UserImage>* result_out) override;\n   void SetDefaultWallpaperPath(""}<_**next**_>{""sha"": ""124958b5f54fb941a48a7a13476f37e5b1fc772e"", ""filename"": ""chrome/browser/chromeos/login/users/wallpaper/wallpaper_manager_browsertest.cc"", ""status"": ""modified"", ""additions"": 58, ""deletions"": 0, ""changes"": 58, ""blob_url"": ""https://github.com/chromium/chromium/blob/39595f8d4dffcb644d438106dcb64a30c139ff0e/chrome/browser/chromeos/login/users/wallpaper/wallpaper_manager_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/39595f8d4dffcb644d438106dcb64a30c139ff0e/chrome/browser/chromeos/login/users/wallpaper/wallpaper_manager_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chromeos/login/users/wallpaper/wallpaper_manager_browsertest.cc?ref=39595f8d4dffcb644d438106dcb64a30c139ff0e"", ""patch"": ""@@ -851,4 +851,62 @@ IN_PROC_BROWSER_TEST_F(WallpaperManagerBrowserTest, IsPendingWallpaper) {\n   EXPECT_FALSE(WallpaperManager::Get()->IsPendingWallpaper(\n       wallpaper::WallpaperResizer::GetImageId(image)));\n }\n+\n+// Tests that if there are multiple users on the device and if one user lost his\n+// wallpaper somehow, the wallpapers should still show correctly on lock/login\n+// screen.\n+IN_PROC_BROWSER_TEST_F(WallpaperManagerBrowserTest, CustomWallpaperLostTest) {\n+  UpdateDisplay(\""640x480\"");\n+  WallpaperManager* wallpaper_manager = WallpaperManager::Get();\n+\n+  LogIn(test_account_id1_, kTestUser1Hash);\n+  wallpaper_manager_test_utils::WaitAsyncWallpaperLoadFinished();\n+\n+  // Now log in |test_account_id2_| to make it the current active user.\n+  LogIn(test_account_id2_, kTestUser2Hash);\n+  wallpaper_manager_test_utils::WaitAsyncWallpaperLoadFinished();\n+  EXPECT_EQ(user_manager::UserManager::Get()->GetActiveUser()->GetAccountId(),\n+            test_account_id2_);\n+\n+  // Set a different wallpaper for |test_account_id2_|.\n+  std::string id = std::to_string(\n+      std::abs((base::Time::Now() - base::Time::Now().LocalMidnight())\n+                   .InMilliseconds()));\n+  base::FilePath small_wallpaper_path = GetCustomWallpaperPath(\n+      wallpaper::kSmallWallpaperSubDir, test_account2_wallpaper_files_id_, id);\n+  ASSERT_TRUE(wallpaper_manager_test_utils::WriteJPEGFile(\n+      small_wallpaper_path, kSmallWallpaperWidth, kSmallWallpaperHeight,\n+      wallpaper_manager_test_utils::kCustomWallpaperColor));\n+  std::string relative_path2 =\n+      base::FilePath(test_account2_wallpaper_files_id_.id()).Append(id).value();\n+  WallpaperInfo info2 = {relative_path2, WALLPAPER_LAYOUT_CENTER_CROPPED,\n+                         wallpaper::CUSTOMIZED,\n+                         base::Time::Now().LocalMidnight()};\n+  wallpaper_manager->SetUserWallpaperInfo(test_account_id2_, info2, true);\n+  wallpaper_manager->SetUserWallpaperNow(test_account_id2_);\n+  wallpaper_manager_test_utils::WaitAsyncWallpaperLoadFinished();\n+  EXPECT_TRUE(wallpaper_manager_test_utils::ImageIsNearColor(\n+      controller_->GetWallpaper(),\n+      wallpaper_manager_test_utils::kCustomWallpaperColor));\n+\n+  // Now simulate the lost of |test_account_id1_|'s wallpaper by only updating\n+  // its WallpaperInfo but not providing its wallpaper. In this case we just\n+  // fallback to the default wallpaper.\n+  std::string relative_path =\n+      base::FilePath(test_account1_wallpaper_files_id_.id()).Append(id).value();\n+  // Saves wallpaper info to local state for user |test_account_id1_|.\n+  WallpaperInfo info = {relative_path, WALLPAPER_LAYOUT_CENTER_CROPPED,\n+                        wallpaper::CUSTOMIZED,\n+                        base::Time::Now().LocalMidnight()};\n+  wallpaper_manager->SetUserWallpaperInfo(test_account_id1_, info, true);\n+\n+  // Now simulate lock/login screen. On lock/login screen all users' wallpapers\n+  // will be cached. Test that caching |test_account_id1_| wallpaper won't\n+  // change the current wallpaper (|teset_account_id2_|'s wallpaper).\n+  CacheUserWallpaper(test_account_id1_);\n+  EXPECT_TRUE(wallpaper_manager_test_utils::ImageIsNearColor(\n+      controller_->GetWallpaper(),\n+      wallpaper_manager_test_utils::kCustomWallpaperColor));\n+}\n+\n }  // namespace chromeos""}<_**next**_>{""sha"": ""aed3b01ee7cea005ced36887425f954bad2ee074"", ""filename"": ""components/wallpaper/wallpaper_manager_base.cc"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 8, ""changes"": 33, ""blob_url"": ""https://github.com/chromium/chromium/blob/39595f8d4dffcb644d438106dcb64a30c139ff0e/components/wallpaper/wallpaper_manager_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/39595f8d4dffcb644d438106dcb64a30c139ff0e/components/wallpaper/wallpaper_manager_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/wallpaper/wallpaper_manager_base.cc?ref=39595f8d4dffcb644d438106dcb64a30c139ff0e"", ""patch"": ""@@ -565,22 +565,18 @@ void WallpaperManagerBase::GetCustomWallpaperInternal(\n     // Falls back to custom wallpaper that uses AccountId as part of its file\n     // path.\n     // Note that account id is used instead of wallpaper_files_id here.\n-    LOG(ERROR) << \""Failed to load custom wallpaper from its original fallback \""\n-                  \""file path: \"" << valid_path.value();\n     const std::string& old_path = account_id.GetUserEmail();  // Migrated\n     valid_path = GetCustomWallpaperPath(kOriginalWallpaperSubDir,\n                                         WallpaperFilesId::FromString(old_path),\n                                         info.location);\n   }\n \n   if (!base::PathExists(valid_path)) {\n-    LOG(ERROR) << \""Failed to load previously selected custom wallpaper. \""\n-               << \""Fallback to default wallpaper. Expected wallpaper path: \""\n-               << wallpaper_path.value();\n     reply_task_runner->PostTask(\n         FROM_HERE,\n-        base::Bind(&WallpaperManagerBase::DoSetDefaultWallpaper, weak_ptr,\n-                   account_id, base::Passed(std::move(on_finish))));\n+        base::Bind(&WallpaperManagerBase::OnCustomWallpaperFileNotFound,\n+                   weak_ptr, account_id, wallpaper_path, update_wallpaper,\n+                   base::Passed(std::move(on_finish))));\n   } else {\n     reply_task_runner->PostTask(\n         FROM_HERE, base::Bind(&WallpaperManagerBase::StartLoad, weak_ptr,\n@@ -831,7 +827,7 @@ void WallpaperManagerBase::LoadWallpaper(\n     // In unexpected cases, revert to default wallpaper to fail safely. See\n     // crosbug.com/38429.\n     LOG(ERROR) << \""Wallpaper reverts to default unexpected.\"";\n-    DoSetDefaultWallpaper(account_id, std::move(on_finish));\n+    DoSetDefaultWallpaper(account_id, update_wallpaper, std::move(on_finish));\n   }\n }\n \n@@ -1010,4 +1006,25 @@ void WallpaperManagerBase::CreateSolidDefaultWallpaper() {\n   default_wallpaper_image_.reset(new user_manager::UserImage(image));\n }\n \n+void WallpaperManagerBase::OnCustomWallpaperFileNotFound(\n+    const AccountId& account_id,\n+    const base::FilePath& expected_path,\n+    bool update_wallpaper,\n+    MovableOnDestroyCallbackHolder on_finish) {\n+  user_manager::UserManager* user_manager = user_manager::UserManager::Get();\n+  const user_manager::User* user = user_manager->FindUser(account_id);\n+  LOG(ERROR) << \""Failed to load previously selected custom wallpaper. \""\n+             << \""Fallback to default wallpaper. Expected wallpaper path: \""\n+             << expected_path.value() << \"". Number of users on the device: \""\n+             << user_manager->GetUsers().size()\n+             << \"", Number of logged in users on the device: \""\n+             << user_manager->GetLoggedInUsers().size()\n+             << \"". Current user type: \"" << user->GetType()\n+             << \"", IsActiveUser=\"" << (user_manager->GetActiveUser() == user)\n+             << \"", IsPrimaryUser=\"" << (user_manager->GetPrimaryUser() == user)\n+             << \"".\"";\n+\n+  DoSetDefaultWallpaper(account_id, update_wallpaper, std::move(on_finish));\n+}\n+\n }  // namespace wallpaper""}<_**next**_>{""sha"": ""0bcfbf0f10114b5b6d19b93631d5e4a3acc5695d"", ""filename"": ""components/wallpaper/wallpaper_manager_base.h"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 3, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/39595f8d4dffcb644d438106dcb64a30c139ff0e/components/wallpaper/wallpaper_manager_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/39595f8d4dffcb644d438106dcb64a30c139ff0e/components/wallpaper/wallpaper_manager_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/wallpaper/wallpaper_manager_base.h?ref=39595f8d4dffcb644d438106dcb64a30c139ff0e"", ""patch"": ""@@ -481,9 +481,11 @@ class WALLPAPER_EXPORT WallpaperManagerBase {\n   virtual void ScheduleSetUserWallpaper(const AccountId& account_id,\n                                         bool delayed) = 0;\n \n-  // Sets wallpaper to default.\n+  // Sets wallpaper to default if |update_wallpaper| is true. Otherwise just\n+  // load defaut wallpaper to cache.\n   virtual void DoSetDefaultWallpaper(\n       const AccountId& account_id,\n+      bool update_wallpaper,\n       MovableOnDestroyCallbackHolder on_finish) = 0;\n \n   // Starts to load wallpaper at |wallpaper_path|. If |wallpaper_path| is\n@@ -533,18 +535,21 @@ class WALLPAPER_EXPORT WallpaperManagerBase {\n   virtual void SetDefaultWallpaperPathsFromCommandLine(\n       base::CommandLine* command_line) = 0;\n \n-  // Sets wallpaper to decoded default.\n+  // Sets wallpaper to decoded default if |update_wallpaper| is true.\n   virtual void OnDefaultWallpaperDecoded(\n       const base::FilePath& path,\n       const WallpaperLayout layout,\n+      bool update_wallpaper,\n       std::unique_ptr<user_manager::UserImage>* result,\n       MovableOnDestroyCallbackHolder on_finish,\n       std::unique_ptr<user_manager::UserImage> user_image) = 0;\n \n-  // Start decoding given default wallpaper.\n+  // Start decoding given default wallpaper and set it as wallpaper if\n+  // |update_wallpaper| is true.\n   virtual void StartLoadAndSetDefaultWallpaper(\n       const base::FilePath& path,\n       const WallpaperLayout layout,\n+      bool update_wallpaper,\n       MovableOnDestroyCallbackHolder on_finish,\n       std::unique_ptr<user_manager::UserImage>* result_out) = 0;\n \n@@ -557,6 +562,12 @@ class WALLPAPER_EXPORT WallpaperManagerBase {\n   // Init default_wallpaper_image_ with 1x1 image of default color.\n   virtual void CreateSolidDefaultWallpaper();\n \n+  // Callback function for WallpaperManagerBase::GetCustomWallpaperInternal().\n+  void OnCustomWallpaperFileNotFound(const AccountId& account_id,\n+                                     const base::FilePath& expected_path,\n+                                     bool update_wallpaper,\n+                                     MovableOnDestroyCallbackHolder on_finish);\n+\n   // The number of loaded wallpapers.\n   int loaded_wallpapers_for_test_;\n ""}","    if (update_wallpaper)/~/      DoSetDefaultWallpaper(account_id, std::move(on_finish));","17,18","void WallpaperManager::OnWallpaperDecoded(
    const AccountId& account_id,
    const wallpaper::WallpaperInfo& info,
    bool update_wallpaper,
    MovableOnDestroyCallbackHolder on_finish,
    std::unique_ptr<user_manager::UserImage> user_image) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  TRACE_EVENT_ASYNC_END0(""ui"", ""LoadAndDecodeWallpaper"", this);

  if (user_image->image().isNull()) {
    wallpaper::WallpaperInfo default_info(
         """", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::DEFAULT,
         base::Time::Now().LocalMidnight());
     SetUserWallpaperInfo(account_id, default_info, true);
    DoSetDefaultWallpaper(account_id, update_wallpaper, std::move(on_finish));
     return;
   }
 
  wallpaper_cache_[account_id].second = user_image->image();

  if (update_wallpaper)
    SetWallpaper(user_image->image(), info);
}
","void WallpaperManager::OnWallpaperDecoded(
    const AccountId& account_id,
    const wallpaper::WallpaperInfo& info,
    bool update_wallpaper,
    MovableOnDestroyCallbackHolder on_finish,
    std::unique_ptr<user_manager::UserImage> user_image) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  TRACE_EVENT_ASYNC_END0(""ui"", ""LoadAndDecodeWallpaper"", this);

  if (user_image->image().isNull()) {
    wallpaper::WallpaperInfo default_info(
         """", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::DEFAULT,
         base::Time::Now().LocalMidnight());
     SetUserWallpaperInfo(account_id, default_info, true);
    if (update_wallpaper)
      DoSetDefaultWallpaper(account_id, std::move(on_finish));
     return;
   }
 
  wallpaper_cache_[account_id].second = user_image->image();

  if (update_wallpaper)
    SetWallpaper(user_image->image(), info);
}
",185846.0,C,"    DoSetDefaultWallpaper(account_id, update_wallpaper, std::move(on_finish));
","    if (update_wallpaper)
      DoSetDefaultWallpaper(account_id, std::move(on_finish));
",,"@@ -334,7 +334,8 @@ class WallpaperManager::PendingWallpaper :
     started_load_at_ = base::Time::Now();
 
     if (default_) {
-      manager->DoSetDefaultWallpaper(account_id_, std::move(on_finish_));
+      manager->DoSetDefaultWallpaper(account_id_, true /* update_wallpaper */,
+                                     std::move(on_finish_));
     } else if (!user_wallpaper_.isNull()) {
       SetWallpaper(user_wallpaper_, info_);
     } else if (!wallpaper_path_.empty()) {
@@ -347,7 +348,8 @@ class WallpaperManager::PendingWallpaper :
                          base::Passed(std::move(on_finish_)),
                          manager->weak_factory_.GetWeakPtr()));
     } else if (!info_.location.empty()) {
-      manager->LoadWallpaper(account_id_, info_, true, std::move(on_finish_));
+      manager->LoadWallpaper(account_id_, info_, true /* update_wallpaper */,
+                             std::move(on_finish_));
     } else {
       // PendingWallpaper was created and never initialized?
       NOTREACHED();
@@ -696,6 +698,7 @@ void WallpaperManager::SetDefaultWallpaperDelayed(const AccountId& account_id) {
 
 void WallpaperManager::DoSetDefaultWallpaper(
     const AccountId& account_id,
+    bool update_wallpaper,
     MovableOnDestroyCallbackHolder on_finish) {
   // There is no visible wallpaper in kiosk mode.
   if (user_manager::UserManager::Get()->IsLoggedInAsKioskApp())
@@ -729,21 +732,26 @@ void WallpaperManager::DoSetDefaultWallpaper(
     default_wallpaper_image_.reset();
     if (!file->empty()) {
       loaded_wallpapers_for_test_++;
-      StartLoadAndSetDefaultWallpaper(*file, layout, std::move(on_finish),
+      StartLoadAndSetDefaultWallpaper(*file, layout, update_wallpaper,
+                                      std::move(on_finish),
                                       &default_wallpaper_image_);
       return;
     }
 
     CreateSolidDefaultWallpaper();
   }
-  // 1x1 wallpaper is actually solid color, so it should be stretched.
-  if (default_wallpaper_image_->image().width() == 1 &&
-      default_wallpaper_image_->image().height() == 1)
-    layout = wallpaper::WALLPAPER_LAYOUT_STRETCH;
-
-  WallpaperInfo info(default_wallpaper_image_->file_path().value(), layout,
-                     wallpaper::DEFAULT, base::Time::Now().LocalMidnight());
-  SetWallpaper(default_wallpaper_image_->image(), info);
+
+  if (update_wallpaper) {
+    // 1x1 wallpaper is actually solid color, so it should be stretched.
+    if (default_wallpaper_image_->image().width() == 1 &&
+        default_wallpaper_image_->image().height() == 1) {
+      layout = wallpaper::WALLPAPER_LAYOUT_STRETCH;
+    }
+
+    WallpaperInfo info(default_wallpaper_image_->file_path().value(), layout,
+                       wallpaper::DEFAULT, base::Time::Now().LocalMidnight());
+    SetWallpaper(default_wallpaper_image_->image(), info);
+  }
 }
 
 void WallpaperManager::SetUserWallpaperInfo(const AccountId& account_id,
@@ -1263,9 +1271,7 @@ void WallpaperManager::OnWallpaperDecoded(
         """", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::DEFAULT,
         base::Time::Now().LocalMidnight());
     SetUserWallpaperInfo(account_id, default_info, true);
-
-    if (update_wallpaper)
-      DoSetDefaultWallpaper(account_id, std::move(on_finish));
+    DoSetDefaultWallpaper(account_id, update_wallpaper, std::move(on_finish));
     return;
   }
 
@@ -1404,6 +1410,7 @@ void WallpaperManager::SetDefaultWallpaperPathsFromCommandLine(
 void WallpaperManager::OnDefaultWallpaperDecoded(
     const base::FilePath& path,
     const wallpaper::WallpaperLayout layout,
+    bool update_wallpaper,
     std::unique_ptr<user_manager::UserImage>* result_out,
     MovableOnDestroyCallbackHolder on_finish,
     std::unique_ptr<user_manager::UserImage> user_image) {
@@ -1413,21 +1420,24 @@ void WallpaperManager::OnDefaultWallpaperDecoded(
   }
 
   *result_out = std::move(user_image);
-  WallpaperInfo info(path.value(), layout, wallpaper::DEFAULT,
-                     base::Time::Now().LocalMidnight());
-  SetWallpaper((*result_out)->image(), info);
+  if (update_wallpaper) {
+    WallpaperInfo info(path.value(), layout, wallpaper::DEFAULT,
+                       base::Time::Now().LocalMidnight());
+    SetWallpaper((*result_out)->image(), info);
+  }
 }
 
 void WallpaperManager::StartLoadAndSetDefaultWallpaper(
     const base::FilePath& path,
     const wallpaper::WallpaperLayout layout,
+    bool update_wallpaper,
     MovableOnDestroyCallbackHolder on_finish,
     std::unique_ptr<user_manager::UserImage>* result_out) {
   user_image_loader::StartWithFilePath(
       task_runner_, path, ImageDecoder::ROBUST_JPEG_CODEC,
       0,  // Do not crop.
       base::Bind(&WallpaperManager::OnDefaultWallpaperDecoded,
-                 weak_factory_.GetWeakPtr(), path, layout,
+                 weak_factory_.GetWeakPtr(), path, layout, update_wallpaper,
                  base::Unretained(result_out),
                  base::Passed(std::move(on_finish))));
 }
@@ -1469,8 +1479,8 @@ void WallpaperManager::SetDefaultWallpaperPath(
     }
   }
 
-  if (need_update_screen)
-    DoSetDefaultWallpaper(EmptyAccountId(), MovableOnDestroyCallbackHolder());
+  DoSetDefaultWallpaper(EmptyAccountId(), need_update_screen,
+                        MovableOnDestroyCallbackHolder());
 }
 
 void WallpaperManager::RecordWallpaperAppType() {","void WallpaperManager::OnWallpaperDecoded(
const AccountId& account_id,
const wallpaper::WallpaperInfo& info,
bool update_wallpaper,
MovableOnDestroyCallbackHolder on_finish,
std::unique_ptr<user_manager::UserImage> user_image) {
DCHECK_CURRENTLY_ON(BrowserThread::UI);
TRACE_EVENT_ASYNC_END0(""ui"", ""LoadAndDecodeWallpaper"", this);

// If decoded wallpaper is empty, we have probably failed to decode the file.
// Use default wallpaper in this case.
if (user_image->image().isNull()) {
// Updates user pref to default wallpaper.
wallpaper::WallpaperInfo default_info(
"""", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::DEFAULT,
base::Time::Now().LocalMidnight());
SetUserWallpaperInfo(account_id, default_info, true);
    if (update_wallpaper)
      DoSetDefaultWallpaper(account_id, std::move(on_finish));
return;
}

// Update the image, but keep the path which was set earlier.
wallpaper_cache_[account_id].second = user_image->image();

if (update_wallpaper)
SetWallpaper(user_image->image(), info);
}
",Chrome,39595f8d4dffcb644d438106dcb64a30c139ff0e,ca8e04691368dfa970f201ad7c87c12dc3417301,1.0,"void WallpaperManager::OnWallpaperDecoded(
    const AccountId& account_id,
    const wallpaper::WallpaperInfo& info,
    bool update_wallpaper,
    MovableOnDestroyCallbackHolder on_finish,
    std::unique_ptr<user_manager::UserImage> user_image) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  TRACE_EVENT_ASYNC_END0(""ui"", ""LoadAndDecodeWallpaper"", this);

  // If decoded wallpaper is empty, we have probably failed to decode the file.
  // Use default wallpaper in this case.
  if (user_image->image().isNull()) {
    // Updates user pref to default wallpaper.
    wallpaper::WallpaperInfo default_info(
         """", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::DEFAULT,
         base::Time::Now().LocalMidnight());
     SetUserWallpaperInfo(account_id, default_info, true);
//flaw_line_below:

//flaw_line_below:
    if (update_wallpaper)
//flaw_line_below:
      DoSetDefaultWallpaper(account_id, std::move(on_finish));
//fix_flaw_line_below:
//    DoSetDefaultWallpaper(account_id, update_wallpaper, std::move(on_finish));
     return;
   }
 
  // Update the image, but keep the path which was set earlier.
  wallpaper_cache_[account_id].second = user_image->image();

  if (update_wallpaper)
    SetWallpaper(user_image->image(), info);
}
"
764,None,Remote,Not required,Partial,CVE-2014-3171,https://www.cvedetails.com/cve/CVE-2014-3171/,,Low,Partial,Partial,,2014-08-26,7.5,"Use-after-free vulnerability in the V8 bindings in Blink, as used in Google Chrome before 37.0.2062.94, allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging improper use of HashMap add operations instead of HashMap set operations, related to bindings/core/v8/DOMWrapperMap.h and bindings/core/v8/SerializedScriptValue.cpp.",2017-08-28,DoS ,1.0,https://github.com/chromium/chromium/commit/d10a8dac48d3a9467e81c62cb45208344f4542db,d10a8dac48d3a9467e81c62cb45208344f4542db,"Replace further questionable HashMap::add usages in bindings

BUG=390928
R=dcarney@chromium.org

Review URL: https://codereview.chromium.org/411273002

git-svn-id: svn://svn.chromium.org/blink/trunk@178823 bbb929c8-8fbe-4397-9dbb-9b2b20218538",1.0,third_party/WebKit/Source/bindings/core/v8/SerializedScriptValue.cpp,"{""sha"": ""75a962e2b0b2e13abed4cc0016044a5a7c26bd73"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/DOMWrapperMap.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d10a8dac48d3a9467e81c62cb45208344f4542db/third_party/WebKit/Source/bindings/core/v8/DOMWrapperMap.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d10a8dac48d3a9467e81c62cb45208344f4542db/third_party/WebKit/Source/bindings/core/v8/DOMWrapperMap.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/DOMWrapperMap.h?ref=d10a8dac48d3a9467e81c62cb45208344f4542db"", ""patch"": ""@@ -108,7 +108,7 @@ class DOMWrapperMap {\n             Impl* impl, KeyType* key, v8::PersistentContainerValue value)\n         {\n             v8::PersistentContainerValue oldValue = Get(impl, key);\n-            impl->add(key, value);\n+            impl->set(key, value);\n             return oldValue;\n         }\n         static v8::PersistentContainerValue Get(const Impl* impl, KeyType* key)""}<_**next**_>{""sha"": ""1d99c5df9c655ff6aecca5ba169a27b3d82ec439"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/SerializedScriptValue.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d10a8dac48d3a9467e81c62cb45208344f4542db/third_party/WebKit/Source/bindings/core/v8/SerializedScriptValue.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d10a8dac48d3a9467e81c62cb45208344f4542db/third_party/WebKit/Source/bindings/core/v8/SerializedScriptValue.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/SerializedScriptValue.cpp?ref=d10a8dac48d3a9467e81c62cb45208344f4542db"", ""patch"": ""@@ -1282,7 +1282,7 @@ class Serializer {\n         if (blob->hasBeenClosed())\n             return handleError(DataCloneError, \""A Blob object has been closed, and could therefore not be cloned.\"", next);\n         int blobIndex = -1;\n-        m_blobDataHandles.add(blob->uuid(), blob->blobDataHandle());\n+        m_blobDataHandles.set(blob->uuid(), blob->blobDataHandle());\n         if (appendBlobInfo(blob->uuid(), blob->type(), blob->size(), &blobIndex))\n             m_writer.writeBlobIndex(blobIndex);\n         else\n@@ -1309,7 +1309,7 @@ class Serializer {\n         if (file->hasBeenClosed())\n             return handleError(DataCloneError, \""A File object has been closed, and could therefore not be cloned.\"", next);\n         int blobIndex = -1;\n-        m_blobDataHandles.add(file->uuid(), file->blobDataHandle());\n+        m_blobDataHandles.set(file->uuid(), file->blobDataHandle());\n         if (appendFileInfo(file, &blobIndex)) {\n             ASSERT(blobIndex >= 0);\n             m_writer.writeFileIndex(blobIndex);\n@@ -1331,7 +1331,7 @@ class Serializer {\n             const File* file = fileList->item(i);\n             if (file->hasBeenClosed())\n                 return handleError(DataCloneError, \""A File object has been closed, and could therefore not be cloned.\"", next);\n-            m_blobDataHandles.add(file->uuid(), file->blobDataHandle());\n+            m_blobDataHandles.set(file->uuid(), file->blobDataHandle());\n             if (appendFileInfo(file, &blobIndex)) {\n                 ASSERT(!i || blobIndex > 0);\n                 ASSERT(blobIndex >= 0);""}","        m_blobDataHandles.add(blob->uuid(), blob->blobDataHandle());",8,"    StateBase* writeBlob(v8::Handle<v8::Value> value, StateBase* next)
    {
        Blob* blob = V8Blob::toNative(value.As<v8::Object>());
        if (!blob)
            return 0;
         if (blob->hasBeenClosed())
             return handleError(DataCloneError, ""A Blob object has been closed, and could therefore not be cloned."", next);
         int blobIndex = -1;
        m_blobDataHandles.set(blob->uuid(), blob->blobDataHandle());
         if (appendBlobInfo(blob->uuid(), blob->type(), blob->size(), &blobIndex))
             m_writer.writeBlobIndex(blobIndex);
         else
            m_writer.writeBlob(blob->uuid(), blob->type(), blob->size());
        return 0;
    }
","    StateBase* writeBlob(v8::Handle<v8::Value> value, StateBase* next)
    {
        Blob* blob = V8Blob::toNative(value.As<v8::Object>());
        if (!blob)
            return 0;
         if (blob->hasBeenClosed())
             return handleError(DataCloneError, ""A Blob object has been closed, and could therefore not be cloned."", next);
         int blobIndex = -1;
        m_blobDataHandles.add(blob->uuid(), blob->blobDataHandle());
         if (appendBlobInfo(blob->uuid(), blob->type(), blob->size(), &blobIndex))
             m_writer.writeBlobIndex(blobIndex);
         else
            m_writer.writeBlob(blob->uuid(), blob->type(), blob->size());
        return 0;
    }
",185354.0,C,"        m_blobDataHandles.set(blob->uuid(), blob->blobDataHandle());
","        m_blobDataHandles.add(blob->uuid(), blob->blobDataHandle());
",,"@@ -1282,7 +1282,7 @@ class Serializer {
         if (blob->hasBeenClosed())
             return handleError(DataCloneError, ""A Blob object has been closed, and could therefore not be cloned."", next);
         int blobIndex = -1;
-        m_blobDataHandles.add(blob->uuid(), blob->blobDataHandle());
+        m_blobDataHandles.set(blob->uuid(), blob->blobDataHandle());
         if (appendBlobInfo(blob->uuid(), blob->type(), blob->size(), &blobIndex))
             m_writer.writeBlobIndex(blobIndex);
         else
@@ -1309,7 +1309,7 @@ class Serializer {
         if (file->hasBeenClosed())
             return handleError(DataCloneError, ""A File object has been closed, and could therefore not be cloned."", next);
         int blobIndex = -1;
-        m_blobDataHandles.add(file->uuid(), file->blobDataHandle());
+        m_blobDataHandles.set(file->uuid(), file->blobDataHandle());
         if (appendFileInfo(file, &blobIndex)) {
             ASSERT(blobIndex >= 0);
             m_writer.writeFileIndex(blobIndex);
@@ -1331,7 +1331,7 @@ class Serializer {
             const File* file = fileList->item(i);
             if (file->hasBeenClosed())
                 return handleError(DataCloneError, ""A File object has been closed, and could therefore not be cloned."", next);
-            m_blobDataHandles.add(file->uuid(), file->blobDataHandle());
+            m_blobDataHandles.set(file->uuid(), file->blobDataHandle());
             if (appendFileInfo(file, &blobIndex)) {
                 ASSERT(!i || blobIndex > 0);
                 ASSERT(blobIndex >= 0);","StateBase* writeBlob(v8::Handle<v8::Value> value, StateBase* next)
{
Blob* blob = V8Blob::toNative(value.As<v8::Object>());
if (!blob)
return 0;
if (blob->hasBeenClosed())
return handleError(DataCloneError, ""A Blob object has been closed, and could therefore not be cloned."", next);
int blobIndex = -1;
        m_blobDataHandles.add(blob->uuid(), blob->blobDataHandle());
if (appendBlobInfo(blob->uuid(), blob->type(), blob->size(), &blobIndex))
m_writer.writeBlobIndex(blobIndex);
else
m_writer.writeBlob(blob->uuid(), blob->type(), blob->size());
return 0;
}
",Chrome,d10a8dac48d3a9467e81c62cb45208344f4542db,32b0cf12895a50d1be5962eaa393ec952fea1f4e,1.0,"    StateBase* writeBlob(v8::Handle<v8::Value> value, StateBase* next)
    {
        Blob* blob = V8Blob::toNative(value.As<v8::Object>());
        if (!blob)
            return 0;
         if (blob->hasBeenClosed())
             return handleError(DataCloneError, ""A Blob object has been closed, and could therefore not be cloned."", next);
         int blobIndex = -1;
//flaw_line_below:
        m_blobDataHandles.add(blob->uuid(), blob->blobDataHandle());
//fix_flaw_line_below:
//        m_blobDataHandles.set(blob->uuid(), blob->blobDataHandle());
         if (appendBlobInfo(blob->uuid(), blob->type(), blob->size(), &blobIndex))
             m_writer.writeBlobIndex(blobIndex);
         else
            m_writer.writeBlob(blob->uuid(), blob->type(), blob->size());
        return 0;
    }
"
834,None,Remote,Not required,Partial,CVE-2016-10061,https://www.cvedetails.com/cve/CVE-2016-10061/,CWE-20,Medium,None,None,,2017-03-03,4.3,"The ReadGROUP4Image function in coders/tiff.c in ImageMagick before 7.0.1-10 does not check the return value of the fputc function, which allows remote attackers to cause a denial of service (crash) via a crafted image file.",2017-03-04,DoS ,5.0,https://github.com/ImageMagick/ImageMagick/commit/4e914bbe371433f0590cefdf3bd5f3a5710069f9,4e914bbe371433f0590cefdf3bd5f3a5710069f9,https://github.com/ImageMagick/ImageMagick/issues/196,1.0,coders/tiff.c,"{""sha"": ""fa589d94f6eecaabc0c66fa62bfb0d0d0563716b"", ""filename"": ""coders/tiff.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/4e914bbe371433f0590cefdf3bd5f3a5710069f9/coders/tiff.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/4e914bbe371433f0590cefdf3bd5f3a5710069f9/coders/tiff.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/tiff.c?ref=4e914bbe371433f0590cefdf3bd5f3a5710069f9"", ""patch"": ""@@ -390,8 +390,10 @@ static Image *ReadGROUP4Image(const ImageInfo *image_info,\n   length=fwrite(\""\\000\\000\\000\\000\"",1,4,file);\n   length=WriteLSBLong(file,(long) image->resolution.x);\n   length=WriteLSBLong(file,1);\n+  status=MagickTrue;\n   for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n-    (void) fputc(c,file);\n+    if (fputc(c,file) != c)\n+      status=MagickFalse;\n   offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n   length=WriteLSBLong(file,(unsigned int) length);\n   (void) fclose(file);\n@@ -413,6 +415,8 @@ static Image *ReadGROUP4Image(const ImageInfo *image_info,\n       (void) CopyMagickString(image->magick,\""GROUP4\"",MagickPathExtent);\n     }\n   (void) RelinquishUniqueFileResource(filename);\n+  if (status == MagickFalse)\n+    image=DestroyImage(image);\n   return(image);\n }\n #endif""}","    (void) fputc(c,file);",83,"static Image *ReadGROUP4Image(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  char
    filename[MagickPathExtent];

  FILE
    *file;

  Image
    *image;

  ImageInfo
    *read_info;

  int
    c,
    unique_file;

  MagickBooleanType
    status;

  size_t
    length;

  ssize_t
    offset,
    strip_offset;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Write raw CCITT Group 4 wrapped as a TIFF image file.
  */
  file=(FILE *) NULL;
  unique_file=AcquireUniqueFileResource(filename);
  if (unique_file != -1)
    file=fdopen(unique_file,""wb"");
  if ((unique_file == -1) || (file == (FILE *) NULL))
    ThrowImageException(FileOpenError,""UnableToCreateTemporaryFile"");
  length=fwrite(""\111\111\052\000\010\000\000\000\016\000"",1,10,file);
  length=fwrite(""\376\000\003\000\001\000\000\000\000\000\000\000"",1,12,file);
  length=fwrite(""\000\001\004\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,image->columns);
  length=fwrite(""\001\001\004\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,image->rows);
  length=fwrite(""\002\001\003\000\001\000\000\000\001\000\000\000"",1,12,file);
  length=fwrite(""\003\001\003\000\001\000\000\000\004\000\000\000"",1,12,file);
  length=fwrite(""\006\001\003\000\001\000\000\000\000\000\000\000"",1,12,file);
  length=fwrite(""\021\001\003\000\001\000\000\000"",1,8,file);
  strip_offset=10+(12*14)+4+8;
  length=WriteLSBLong(file,(size_t) strip_offset);
  length=fwrite(""\022\001\003\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,(size_t) image_info->orientation);
  length=fwrite(""\025\001\003\000\001\000\000\000\001\000\000\000"",1,12,file);
  length=fwrite(""\026\001\004\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,image->rows);
  length=fwrite(""\027\001\004\000\001\000\000\000\000\000\000\000"",1,12,file);
  offset=(ssize_t) ftell(file)-4;
  length=fwrite(""\032\001\005\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,(size_t) (strip_offset-8));
  length=fwrite(""\033\001\005\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,(size_t) (strip_offset-8));
  length=fwrite(""\050\001\003\000\001\000\000\000\002\000\000\000"",1,12,file);
   length=fwrite(""\000\000\000\000"",1,4,file);
   length=WriteLSBLong(file,(long) image->resolution.x);
   length=WriteLSBLong(file,1);
  status=MagickTrue;
   for (length=0; (c=ReadBlobByte(image)) != EOF; length++)
    if (fputc(c,file) != c)
      status=MagickFalse;
   offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);
   length=WriteLSBLong(file,(unsigned int) length);
   (void) fclose(file);
  (void) CloseBlob(image);
  image=DestroyImage(image);
  /*
    Read TIFF image.
  */
  read_info=CloneImageInfo((ImageInfo *) NULL);
  (void) FormatLocaleString(read_info->filename,MagickPathExtent,""%s"",filename);
  image=ReadTIFFImage(read_info,exception);
  read_info=DestroyImageInfo(read_info);
  if (image != (Image *) NULL)
    {
      (void) CopyMagickString(image->filename,image_info->filename,
        MagickPathExtent);
      (void) CopyMagickString(image->magick_filename,image_info->filename,
        MagickPathExtent);
       (void) CopyMagickString(image->magick,""GROUP4"",MagickPathExtent);
     }
   (void) RelinquishUniqueFileResource(filename);
  if (status == MagickFalse)
    image=DestroyImage(image);
   return(image);
 }
","static Image *ReadGROUP4Image(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  char
    filename[MagickPathExtent];

  FILE
    *file;

  Image
    *image;

  ImageInfo
    *read_info;

  int
    c,
    unique_file;

  MagickBooleanType
    status;

  size_t
    length;

  ssize_t
    offset,
    strip_offset;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Write raw CCITT Group 4 wrapped as a TIFF image file.
  */
  file=(FILE *) NULL;
  unique_file=AcquireUniqueFileResource(filename);
  if (unique_file != -1)
    file=fdopen(unique_file,""wb"");
  if ((unique_file == -1) || (file == (FILE *) NULL))
    ThrowImageException(FileOpenError,""UnableToCreateTemporaryFile"");
  length=fwrite(""\111\111\052\000\010\000\000\000\016\000"",1,10,file);
  length=fwrite(""\376\000\003\000\001\000\000\000\000\000\000\000"",1,12,file);
  length=fwrite(""\000\001\004\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,image->columns);
  length=fwrite(""\001\001\004\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,image->rows);
  length=fwrite(""\002\001\003\000\001\000\000\000\001\000\000\000"",1,12,file);
  length=fwrite(""\003\001\003\000\001\000\000\000\004\000\000\000"",1,12,file);
  length=fwrite(""\006\001\003\000\001\000\000\000\000\000\000\000"",1,12,file);
  length=fwrite(""\021\001\003\000\001\000\000\000"",1,8,file);
  strip_offset=10+(12*14)+4+8;
  length=WriteLSBLong(file,(size_t) strip_offset);
  length=fwrite(""\022\001\003\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,(size_t) image_info->orientation);
  length=fwrite(""\025\001\003\000\001\000\000\000\001\000\000\000"",1,12,file);
  length=fwrite(""\026\001\004\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,image->rows);
  length=fwrite(""\027\001\004\000\001\000\000\000\000\000\000\000"",1,12,file);
  offset=(ssize_t) ftell(file)-4;
  length=fwrite(""\032\001\005\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,(size_t) (strip_offset-8));
  length=fwrite(""\033\001\005\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,(size_t) (strip_offset-8));
  length=fwrite(""\050\001\003\000\001\000\000\000\002\000\000\000"",1,12,file);
   length=fwrite(""\000\000\000\000"",1,4,file);
   length=WriteLSBLong(file,(long) image->resolution.x);
   length=WriteLSBLong(file,1);
   for (length=0; (c=ReadBlobByte(image)) != EOF; length++)
    (void) fputc(c,file);
   offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);
   length=WriteLSBLong(file,(unsigned int) length);
   (void) fclose(file);
  (void) CloseBlob(image);
  image=DestroyImage(image);
  /*
    Read TIFF image.
  */
  read_info=CloneImageInfo((ImageInfo *) NULL);
  (void) FormatLocaleString(read_info->filename,MagickPathExtent,""%s"",filename);
  image=ReadTIFFImage(read_info,exception);
  read_info=DestroyImageInfo(read_info);
  if (image != (Image *) NULL)
    {
      (void) CopyMagickString(image->filename,image_info->filename,
        MagickPathExtent);
      (void) CopyMagickString(image->magick_filename,image_info->filename,
        MagickPathExtent);
       (void) CopyMagickString(image->magick,""GROUP4"",MagickPathExtent);
     }
   (void) RelinquishUniqueFileResource(filename);
   return(image);
 }
",181799.0,C,"  status=MagickTrue;
    if (fputc(c,file) != c)
      status=MagickFalse;
  if (status == MagickFalse)
    image=DestroyImage(image);
","    (void) fputc(c,file);
",,"@@ -390,8 +390,10 @@ static Image *ReadGROUP4Image(const ImageInfo *image_info,
   length=fwrite(""\000\000\000\000"",1,4,file);
   length=WriteLSBLong(file,(long) image->resolution.x);
   length=WriteLSBLong(file,1);
+  status=MagickTrue;
   for (length=0; (c=ReadBlobByte(image)) != EOF; length++)
-    (void) fputc(c,file);
+    if (fputc(c,file) != c)
+      status=MagickFalse;
   offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);
   length=WriteLSBLong(file,(unsigned int) length);
   (void) fclose(file);
@@ -413,6 +415,8 @@ static Image *ReadGROUP4Image(const ImageInfo *image_info,
       (void) CopyMagickString(image->magick,""GROUP4"",MagickPathExtent);
     }
   (void) RelinquishUniqueFileResource(filename);
+  if (status == MagickFalse)
+    image=DestroyImage(image);
   return(image);
 }
 #endif","static Image *ReadGROUP4Image(const ImageInfo *image_info,
ExceptionInfo *exception)
{
char
filename[MagickPathExtent];

FILE
*file;

Image
*image;

ImageInfo
*read_info;

int
c,
unique_file;

MagickBooleanType
status;

size_t
length;

ssize_t
offset,
strip_offset;

/*
Open image file.
*/
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
/*
Write raw CCITT Group 4 wrapped as a TIFF image file.
*/
file=(FILE *) NULL;
unique_file=AcquireUniqueFileResource(filename);
if (unique_file != -1)
file=fdopen(unique_file,""wb"");
if ((unique_file == -1) || (file == (FILE *) NULL))
ThrowImageException(FileOpenError,""UnableToCreateTemporaryFile"");
length=fwrite(""\111\111\052\000\010\000\000\000\016\000"",1,10,file);
length=fwrite(""\376\000\003\000\001\000\000\000\000\000\000\000"",1,12,file);
length=fwrite(""\000\001\004\000\001\000\000\000"",1,8,file);
length=WriteLSBLong(file,image->columns);
length=fwrite(""\001\001\004\000\001\000\000\000"",1,8,file);
length=WriteLSBLong(file,image->rows);
length=fwrite(""\002\001\003\000\001\000\000\000\001\000\000\000"",1,12,file);
length=fwrite(""\003\001\003\000\001\000\000\000\004\000\000\000"",1,12,file);
length=fwrite(""\006\001\003\000\001\000\000\000\000\000\000\000"",1,12,file);
length=fwrite(""\021\001\003\000\001\000\000\000"",1,8,file);
strip_offset=10+(12*14)+4+8;
length=WriteLSBLong(file,(size_t) strip_offset);
length=fwrite(""\022\001\003\000\001\000\000\000"",1,8,file);
length=WriteLSBLong(file,(size_t) image_info->orientation);
length=fwrite(""\025\001\003\000\001\000\000\000\001\000\000\000"",1,12,file);
length=fwrite(""\026\001\004\000\001\000\000\000"",1,8,file);
length=WriteLSBLong(file,image->rows);
length=fwrite(""\027\001\004\000\001\000\000\000\000\000\000\000"",1,12,file);
offset=(ssize_t) ftell(file)-4;
length=fwrite(""\032\001\005\000\001\000\000\000"",1,8,file);
length=WriteLSBLong(file,(size_t) (strip_offset-8));
length=fwrite(""\033\001\005\000\001\000\000\000"",1,8,file);
length=WriteLSBLong(file,(size_t) (strip_offset-8));
length=fwrite(""\050\001\003\000\001\000\000\000\002\000\000\000"",1,12,file);
length=fwrite(""\000\000\000\000"",1,4,file);
length=WriteLSBLong(file,(long) image->resolution.x);
length=WriteLSBLong(file,1);
for (length=0; (c=ReadBlobByte(image)) != EOF; length++)
    (void) fputc(c,file);
offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);
length=WriteLSBLong(file,(unsigned int) length);
(void) fclose(file);
(void) CloseBlob(image);
image=DestroyImage(image);
/*
Read TIFF image.
*/
read_info=CloneImageInfo((ImageInfo *) NULL);
(void) FormatLocaleString(read_info->filename,MagickPathExtent,""%s"",filename);
image=ReadTIFFImage(read_info,exception);
read_info=DestroyImageInfo(read_info);
if (image != (Image *) NULL)
{
(void) CopyMagickString(image->filename,image_info->filename,
MagickPathExtent);
(void) CopyMagickString(image->magick_filename,image_info->filename,
MagickPathExtent);
(void) CopyMagickString(image->magick,""GROUP4"",MagickPathExtent);
}
(void) RelinquishUniqueFileResource(filename);
return(image);
}
",ImageMagick,4e914bbe371433f0590cefdf3bd5f3a5710069f9,933e96f01a8c889c7bf5ffd30020e86a02a046e7,1.0,"static Image *ReadGROUP4Image(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  char
    filename[MagickPathExtent];

  FILE
    *file;

  Image
    *image;

  ImageInfo
    *read_info;

  int
    c,
    unique_file;

  MagickBooleanType
    status;

  size_t
    length;

  ssize_t
    offset,
    strip_offset;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Write raw CCITT Group 4 wrapped as a TIFF image file.
  */
  file=(FILE *) NULL;
  unique_file=AcquireUniqueFileResource(filename);
  if (unique_file != -1)
    file=fdopen(unique_file,""wb"");
  if ((unique_file == -1) || (file == (FILE *) NULL))
    ThrowImageException(FileOpenError,""UnableToCreateTemporaryFile"");
  length=fwrite(""\111\111\052\000\010\000\000\000\016\000"",1,10,file);
  length=fwrite(""\376\000\003\000\001\000\000\000\000\000\000\000"",1,12,file);
  length=fwrite(""\000\001\004\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,image->columns);
  length=fwrite(""\001\001\004\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,image->rows);
  length=fwrite(""\002\001\003\000\001\000\000\000\001\000\000\000"",1,12,file);
  length=fwrite(""\003\001\003\000\001\000\000\000\004\000\000\000"",1,12,file);
  length=fwrite(""\006\001\003\000\001\000\000\000\000\000\000\000"",1,12,file);
  length=fwrite(""\021\001\003\000\001\000\000\000"",1,8,file);
  strip_offset=10+(12*14)+4+8;
  length=WriteLSBLong(file,(size_t) strip_offset);
  length=fwrite(""\022\001\003\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,(size_t) image_info->orientation);
  length=fwrite(""\025\001\003\000\001\000\000\000\001\000\000\000"",1,12,file);
  length=fwrite(""\026\001\004\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,image->rows);
  length=fwrite(""\027\001\004\000\001\000\000\000\000\000\000\000"",1,12,file);
  offset=(ssize_t) ftell(file)-4;
  length=fwrite(""\032\001\005\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,(size_t) (strip_offset-8));
  length=fwrite(""\033\001\005\000\001\000\000\000"",1,8,file);
  length=WriteLSBLong(file,(size_t) (strip_offset-8));
  length=fwrite(""\050\001\003\000\001\000\000\000\002\000\000\000"",1,12,file);
   length=fwrite(""\000\000\000\000"",1,4,file);
   length=WriteLSBLong(file,(long) image->resolution.x);
   length=WriteLSBLong(file,1);
//fix_flaw_line_below:
//  status=MagickTrue;
   for (length=0; (c=ReadBlobByte(image)) != EOF; length++)
//flaw_line_below:
    (void) fputc(c,file);
//fix_flaw_line_below:
//    if (fputc(c,file) != c)
//fix_flaw_line_below:
//      status=MagickFalse;
   offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);
   length=WriteLSBLong(file,(unsigned int) length);
   (void) fclose(file);
  (void) CloseBlob(image);
  image=DestroyImage(image);
  /*
    Read TIFF image.
  */
  read_info=CloneImageInfo((ImageInfo *) NULL);
  (void) FormatLocaleString(read_info->filename,MagickPathExtent,""%s"",filename);
  image=ReadTIFFImage(read_info,exception);
  read_info=DestroyImageInfo(read_info);
  if (image != (Image *) NULL)
    {
      (void) CopyMagickString(image->filename,image_info->filename,
        MagickPathExtent);
      (void) CopyMagickString(image->magick_filename,image_info->filename,
        MagickPathExtent);
       (void) CopyMagickString(image->magick,""GROUP4"",MagickPathExtent);
     }
   (void) RelinquishUniqueFileResource(filename);
//fix_flaw_line_below:
//  if (status == MagickFalse)
//fix_flaw_line_below:
//    image=DestroyImage(image);
   return(image);
 }
"
853,None,Remote,Not required,Partial,CVE-2012-2888,https://www.cvedetails.com/cve/CVE-2012-2888/,CWE-399,Low,Partial,Partial,,2012-09-26,7.5,Use-after-free vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving SVG text references.,2018-10-30,DoS ,1.0,https://github.com/chromium/chromium/commit/3b0d77670a0613f409110817455d2137576b485a,3b0d77670a0613f409110817455d2137576b485a,"Revert 143656 - Add an IPC channel between the NaCl loader process and the renderer.
BUG=116317
TEST=ppapi, nacl tests, manual testing for experimental IPC proxy.
Review URL: https://chromiumcodereview.appspot.com/10641016

TBR=bbudge@chromium.org
Review URL: https://chromiumcodereview.appspot.com/10625007

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143665 0039d316-1c4b-4281-b951-d872f2087c98",10.0,ppapi/native_client/src/trusted/plugin/plugin.cc,"{""sha"": ""1def1feeb05ae8bcdf429026b4f87d7eee2bbdd8"", ""filename"": ""chrome/browser/nacl_host/nacl_process_host.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 20, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/browser/nacl_host/nacl_process_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/browser/nacl_host/nacl_process_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/nacl_host/nacl_process_host.cc?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -145,9 +145,6 @@ NaClProcessHost::NaClProcessHost(const GURL& manifest_url, bool off_the_record)\n       getenv(\""NACL_UNTRUSTED_EXCEPTION_HANDLING\"") != NULL) {\n     enable_exception_handling_ = true;\n   }\n-\n-  enable_ipc_proxy_ = CommandLine::ForCurrentProcess()->HasSwitch(\n-      switches::kEnableNaClIPCProxy);\n }\n \n NaClProcessHost::~NaClProcessHost() {\n@@ -540,8 +537,6 @@ bool NaClProcessHost::OnMessageReceived(const IPC::Message& msg) {\n     IPC_MESSAGE_HANDLER_DELAY_REPLY(NaClProcessMsg_AttachDebugExceptionHandler,\n                                     OnAttachDebugExceptionHandler)\n #endif\n-    IPC_MESSAGE_HANDLER(NaClProcessHostMsg_PpapiChannelCreated,\n-                        OnPpapiChannelCreated)\n     IPC_MESSAGE_UNHANDLED(handled = false)\n   IPC_END_MESSAGE_MAP()\n   return handled;\n@@ -561,8 +556,7 @@ void NaClProcessHost::OnResourcesReady() {\n   }\n }\n \n-bool NaClProcessHost::ReplyToRenderer(\n-    const IPC::ChannelHandle& channel_handle) {\n+bool NaClProcessHost::ReplyToRenderer() {\n   std::vector<nacl::FileDescriptor> handles_for_renderer;\n   for (size_t i = 0; i < internal_->sockets_for_renderer.size(); i++) {\n #if defined(OS_WIN)\n@@ -606,7 +600,7 @@ bool NaClProcessHost::ReplyToRenderer(\n #endif\n \n   ChromeViewHostMsg_LaunchNaCl::WriteReplyParams(\n-      reply_msg_, handles_for_renderer, channel_handle);\n+      reply_msg_, handles_for_renderer);\n   chrome_render_message_filter_->Send(reply_msg_);\n   chrome_render_message_filter_ = NULL;\n   reply_msg_ = NULL;\n@@ -624,7 +618,6 @@ bool NaClProcessHost::StartNaClExecution() {\n   params.enable_exception_handling = enable_exception_handling_;\n   params.enable_debug_stub =\n       CommandLine::ForCurrentProcess()->HasSwitch(switches::kEnableNaClDebug);\n-  params.enable_ipc_proxy = enable_ipc_proxy_;\n \n   base::PlatformFile irt_file = nacl_browser->IrtFile();\n   CHECK_NE(irt_file, base::kInvalidPlatformFileValue);\n@@ -672,17 +665,7 @@ bool NaClProcessHost::StartNaClExecution() {\n }\n \n bool NaClProcessHost::SendStart() {\n-  if (!enable_ipc_proxy_) {\n-    if (!ReplyToRenderer(IPC::ChannelHandle()))\n-      return false;\n-  }\n-  return StartNaClExecution();\n-}\n-\n-void NaClProcessHost::OnPpapiChannelCreated(\n-    const IPC::ChannelHandle& channel_handle) {\n-  DCHECK(enable_ipc_proxy_);\n-  ReplyToRenderer(channel_handle);\n+  return ReplyToRenderer() && StartNaClExecution();\n }\n \n bool NaClProcessHost::StartWithLaunchedProcess() {""}<_**next**_>{""sha"": ""4ab9413ae469b1419383dbd00b86ea91d31c00d5"", ""filename"": ""chrome/browser/nacl_host/nacl_process_host.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 6, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/browser/nacl_host/nacl_process_host.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/browser/nacl_host/nacl_process_host.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/nacl_host/nacl_process_host.h?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -17,7 +17,6 @@\n #include \""chrome/common/nacl_types.h\""\n #include \""content/public/browser/browser_child_process_host_delegate.h\""\n #include \""googleurl/src/gurl.h\""\n-#include \""ipc/ipc_channel_handle.h\""\n \n class ChromeRenderMessageFilter;\n class CommandLine;\n@@ -87,7 +86,7 @@ class NaClProcessHost : public content::BrowserChildProcessHostDelegate {\n \n   // Sends the reply message to the renderer who is waiting for the plugin\n   // to load. Returns true on success.\n-  bool ReplyToRenderer(const IPC::ChannelHandle& channel_handle);\n+  bool ReplyToRenderer();\n \n   // Sends the message to the NaCl process to load the plugin. Returns true\n   // on success.\n@@ -114,8 +113,6 @@ class NaClProcessHost : public content::BrowserChildProcessHostDelegate {\n                                    IPC::Message* reply_msg);\n #endif\n \n-  void OnPpapiChannelCreated(const IPC::ChannelHandle& channel_handle);\n-\n   GURL manifest_url_;\n \n #if defined(OS_WIN)\n@@ -155,8 +152,6 @@ class NaClProcessHost : public content::BrowserChildProcessHostDelegate {\n \n   bool off_the_record_;\n \n-  bool enable_ipc_proxy_;\n-\n   DISALLOW_COPY_AND_ASSIGN(NaClProcessHost);\n };\n ""}<_**next**_>{""sha"": ""7a6f012902b76580de0dc77e463e7292d5f9d907"", ""filename"": ""chrome/common/nacl_messages.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 8, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/common/nacl_messages.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/common/nacl_messages.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/nacl_messages.h?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -7,7 +7,6 @@\n // Multiply-included message file, no traditional include guard.\n #include \""base/process.h\""\n #include \""chrome/common/nacl_types.h\""\n-#include \""ipc/ipc_channel_handle.h\""\n #include \""ipc/ipc_message_macros.h\""\n \n #define IPC_MESSAGE_START NaClMsgStart\n@@ -19,7 +18,6 @@ IPC_STRUCT_TRAITS_BEGIN(nacl::NaClStartParams)\n   IPC_STRUCT_TRAITS_MEMBER(version)\n   IPC_STRUCT_TRAITS_MEMBER(enable_exception_handling)\n   IPC_STRUCT_TRAITS_MEMBER(enable_debug_stub)\n-  IPC_STRUCT_TRAITS_MEMBER(enable_ipc_proxy)\n IPC_STRUCT_TRAITS_END()\n \n //-----------------------------------------------------------------------------\n@@ -74,9 +72,3 @@ IPC_SYNC_MESSAGE_CONTROL1_1(NaClProcessMsg_QueryKnownToValidate,\n // database in the browser.\n IPC_MESSAGE_CONTROL1(NaClProcessMsg_SetKnownToValidate,\n                      std::string /* A validation signature */)\n-\n-// Notify the browser process that the server side of the PPAPI channel was\n-// created successfully.\n-IPC_MESSAGE_CONTROL1(NaClProcessHostMsg_PpapiChannelCreated,\n-                     IPC::ChannelHandle /* channel_handle */)\n-""}<_**next**_>{""sha"": ""86ed0d0fe7c82f44c1685018d001a4b0256b02b6"", ""filename"": ""chrome/common/nacl_types.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/common/nacl_types.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/common/nacl_types.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/nacl_types.h?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -55,7 +55,6 @@ struct NaClStartParams {\n \n   bool enable_exception_handling;\n   bool enable_debug_stub;\n-  bool enable_ipc_proxy;\n };\n \n }  // namespace nacl""}<_**next**_>{""sha"": ""ff023cf748466c8f4dd1fd6d74cc9ccf75da3c10"", ""filename"": ""chrome/common/render_messages.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/common/render_messages.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/common/render_messages.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/render_messages.h?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -26,7 +26,6 @@\n #include \""chrome/common/translate_errors.h\""\n #include \""content/public/common/common_param_traits.h\""\n #include \""content/public/common/webkit_param_traits.h\""\n-#include \""ipc/ipc_channel_handle.h\""\n #include \""ipc/ipc_message_macros.h\""\n #include \""ipc/ipc_platform_file.h\""\n #include \""third_party/skia/include/core/SkBitmap.h\""\n@@ -486,14 +485,12 @@ IPC_MESSAGE_ROUTED3(ChromeViewHostMsg_ForwardMessageToExternalHost,\n \n // A renderer sends this to the browser process when it wants to start\n // a new instance of the Native Client process. The browser will launch\n-// the process and return an IPC channel handle. This handle will only\n-// be valid if the NaCl IPC proxy is enabled.\n-IPC_SYNC_MESSAGE_CONTROL2_2(ChromeViewHostMsg_LaunchNaCl,\n+// the process and return a handle to an IMC channel.\n+IPC_SYNC_MESSAGE_CONTROL2_1(ChromeViewHostMsg_LaunchNaCl,\n                             GURL /* manifest_url */,\n                             int /* socket count */,\n                             std::vector<nacl::FileDescriptor>\n-                                /* imc channel handles */,\n-                            IPC::ChannelHandle /* ipc_channel_handle */)\n+                                /* imc channel handles */)\n \n // Notification that the page has an OpenSearch description document\n // associated with it.""}<_**next**_>{""sha"": ""f76fa0dea06b15d754960c885bf4eaed531dbe13"", ""filename"": ""chrome/nacl/nacl_ipc_adapter.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/nacl/nacl_ipc_adapter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/nacl/nacl_ipc_adapter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/nacl/nacl_ipc_adapter.cc?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -74,7 +74,6 @@ ssize_t NaClDescCustomRecvMsg(void* handle, NaClImcTypedMsgHdr* msg,\n                               int /* flags */) {\n   if (msg->iov_length != 1)\n     return -1;\n-  msg->ndesc_length = 0;  // Messages with descriptors aren't supported yet.\n   return static_cast<ssize_t>(\n       ToAdapter(handle)->BlockingReceive(static_cast<char*>(msg->iov[0].base),\n                                          msg->iov[0].length));\n@@ -282,12 +281,6 @@ NaClDesc* NaClIPCAdapter::MakeNaClDesc() {\n   return MakeNaClDescCustom(this);\n }\n \n-#if defined(OS_POSIX)\n-int NaClIPCAdapter::TakeClientFileDescriptor() {\n-  return io_thread_data_.channel_->TakeClientFileDescriptor();\n-}\n-#endif\n-\n bool NaClIPCAdapter::OnMessageReceived(const IPC::Message& message) {\n   {\n     base::AutoLock lock(lock_);""}<_**next**_>{""sha"": ""12500cdc9a87c5f8dc504d24c9124232ce94e8b1"", ""filename"": ""chrome/nacl/nacl_ipc_adapter.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/nacl/nacl_ipc_adapter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/nacl/nacl_ipc_adapter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/nacl/nacl_ipc_adapter.h?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -77,10 +77,6 @@ class NaClIPCAdapter : public base::RefCountedThreadSafe<NaClIPCAdapter>,\n   // NaClDesc is reference-counted, and a reference is returned.\n   NaClDesc* MakeNaClDesc();\n \n-#if defined(OS_POSIX)\n-  int TakeClientFileDescriptor();\n-#endif\n-\n   // Listener implementation.\n   virtual bool OnMessageReceived(const IPC::Message& message) OVERRIDE;\n   virtual void OnChannelConnected(int32 peer_pid) OVERRIDE;""}<_**next**_>{""sha"": ""a5433dc284dfa4f04ffdd496378a203865be38d5"", ""filename"": ""chrome/nacl/nacl_listener.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 26, ""changes"": 27, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/nacl/nacl_listener.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/nacl/nacl_listener.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/nacl/nacl_listener.cc?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -13,19 +13,13 @@\n #include \""base/message_loop.h\""\n #include \""base/rand_util.h\""\n #include \""chrome/common/nacl_messages.h\""\n-#include \""chrome/nacl/nacl_ipc_adapter.h\""\n #include \""chrome/nacl/nacl_validation_db.h\""\n #include \""chrome/nacl/nacl_validation_query.h\""\n-#include \""ipc/ipc_channel_handle.h\""\n-#include \""ipc/ipc_switches.h\""\n #include \""ipc/ipc_sync_channel.h\""\n #include \""ipc/ipc_sync_message_filter.h\""\n+#include \""ipc/ipc_switches.h\""\n #include \""native_client/src/trusted/service_runtime/sel_main_chrome.h\""\n \n-#if defined(OS_POSIX)\n-#include \""base/file_descriptor_posix.h\""\n-#endif\n-\n #if defined(OS_LINUX)\n #include \""content/public/common/child_process_sandbox_support_linux.h\""\n #endif\n@@ -194,25 +188,6 @@ void NaClListener::OnMsgStart(const nacl::NaClStartParams& params) {\n     return;\n   }\n \n-  if (params.enable_ipc_proxy) {\n-    // Create the server side of the channel and notify the process host so it\n-    // can reply to the renderer, which will connect as client.\n-    IPC::ChannelHandle channel_handle =\n-        IPC::Channel::GenerateVerifiedChannelID(\""nacl\"");\n-\n-    scoped_refptr<NaClIPCAdapter> ipc_adapter(new NaClIPCAdapter(\n-        channel_handle, io_thread_.message_loop_proxy()));\n-    args->initial_ipc_desc = ipc_adapter.get()->MakeNaClDesc();\n-\n-#if defined(OS_POSIX)\n-    channel_handle.socket = base::FileDescriptor(\n-        ipc_adapter.get()->TakeClientFileDescriptor(), true);\n-#endif\n-\n-    if (!Send(new NaClProcessHostMsg_PpapiChannelCreated(channel_handle)))\n-      LOG(ERROR) << \""Failed to send IPC channel handle to renderer.\"";\n-  }\n-\n   std::vector<nacl::FileDescriptor> handles = params.handles;\n \n #if defined(OS_LINUX) || defined(OS_MACOSX)""}<_**next**_>{""sha"": ""b64606594702ea0baf7d5f900d4333fc77c34ceb"", ""filename"": ""chrome/renderer/pepper/ppb_nacl_private_impl.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 179, ""changes"": 184, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/chrome/renderer/pepper/ppb_nacl_private_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/chrome/renderer/pepper/ppb_nacl_private_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/pepper/ppb_nacl_private_impl.cc?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -9,74 +9,35 @@\n #include \""base/command_line.h\""\n #include \""base/lazy_instance.h\""\n #include \""base/logging.h\""\n-#include \""base/message_loop.h\""\n #include \""base/rand_util.h\""\n-#include \""chrome/common/chrome_switches.h\""\n #include \""chrome/common/render_messages.h\""\n-#include \""content/public/common/content_client.h\""\n #include \""content/public/common/content_switches.h\""\n-#include \""content/public/common/sandbox_init.h\""\n #include \""content/public/renderer/render_thread.h\""\n-#include \""content/public/renderer/render_view.h\""\n #include \""ipc/ipc_sync_message_filter.h\""\n #include \""ppapi/c/private/ppb_nacl_private.h\""\n #include \""ppapi/native_client/src/trusted/plugin/nacl_entry_points.h\""\n-#include \""ppapi/proxy/host_dispatcher.h\""\n-#include \""ppapi/proxy/proxy_channel.h\""\n-#include \""ppapi/shared_impl/ppapi_preferences.h\""\n-#include \""third_party/WebKit/Source/WebKit/chromium/public/WebDocument.h\""\n-#include \""third_party/WebKit/Source/WebKit/chromium/public/WebElement.h\""\n-#include \""third_party/WebKit/Source/WebKit/chromium/public/WebFrame.h\""\n-#include \""third_party/WebKit/Source/WebKit/chromium/public/WebPluginContainer.h\""\n-#include \""third_party/WebKit/Source/WebKit/chromium/public/WebView.h\""\n-#include \""webkit/plugins/ppapi/host_globals.h\""\n-#include \""webkit/plugins/ppapi/plugin_module.h\""\n-#include \""webkit/plugins/ppapi/ppapi_plugin_instance.h\""\n \n-using content::RenderThread;\n-using content::RenderView;\n-using webkit::ppapi::HostGlobals;\n-using webkit::ppapi::PluginInstance;\n-using webkit::ppapi::PluginDelegate;\n-using WebKit::WebView;\n+#if defined(OS_WIN)\n+#include \""content/public/common/sandbox_init.h\""\n+#endif\n \n namespace {\n \n base::LazyInstance<scoped_refptr<IPC::SyncMessageFilter> >\n     g_background_thread_sender = LAZY_INSTANCE_INITIALIZER;\n \n-typedef std::map<PP_Instance, IPC::ChannelHandle> ChannelHandleMap;\n-\n-base::LazyInstance<ChannelHandleMap> g_channel_handle_map =\n-    LAZY_INSTANCE_INITIALIZER;\n-\n // Launch NaCl's sel_ldr process.\n PP_Bool LaunchSelLdr(PP_Instance instance,\n-                     const char* alleged_url,\n-                     int socket_count,\n+                     const char* alleged_url, int socket_count,\n                      void* imc_handles) {\n   std::vector<nacl::FileDescriptor> sockets;\n   IPC::Sender* sender = content::RenderThread::Get();\n   if (sender == NULL)\n     sender = g_background_thread_sender.Pointer()->get();\n \n-  IPC::ChannelHandle channel_handle;\n   if (!sender->Send(new ChromeViewHostMsg_LaunchNaCl(\n-          GURL(alleged_url), socket_count, &sockets,\n-          &channel_handle))) {\n+          GURL(alleged_url), socket_count, &sockets)))\n     return PP_FALSE;\n-  }\n-\n-  // Don't save invalid channel handles.\n-  bool invalid_handle = channel_handle.name.empty();\n-\n-#if defined(OS_POSIX)\n-  if (!invalid_handle)\n-    invalid_handle = (channel_handle.socket.fd == -1);\n-#endif\n-\n-  if (!invalid_handle)\n-    g_channel_handle_map.Get()[instance] = channel_handle;\n \n   CHECK(static_cast<int>(sockets.size()) == socket_count);\n   for (int i = 0; i < socket_count; i++) {\n@@ -87,142 +48,7 @@ PP_Bool LaunchSelLdr(PP_Instance instance,\n   return PP_TRUE;\n }\n \n-class ProxyChannelDelegate\n-    : public ppapi::proxy::ProxyChannel::Delegate {\n- public:\n-  ProxyChannelDelegate();\n-  virtual ~ProxyChannelDelegate();\n-\n-  // ProxyChannel::Delegate implementation.\n-  virtual base::MessageLoopProxy* GetIPCMessageLoop() OVERRIDE;\n-  virtual base::WaitableEvent* GetShutdownEvent() OVERRIDE;\n-  virtual IPC::PlatformFileForTransit ShareHandleWithRemote(\n-      base::PlatformFile handle,\n-      const IPC::SyncChannel& channel,\n-      bool should_close_source) OVERRIDE;\n- private:\n-  // TODO(bbudge) Modify the content public API so we can get\n-  // the renderer process's shutdown event.\n-  base::WaitableEvent shutdown_event_;\n-};\n-\n-ProxyChannelDelegate::ProxyChannelDelegate()\n-    : shutdown_event_(true, false) {\n-}\n-\n-ProxyChannelDelegate::~ProxyChannelDelegate() {\n-}\n-\n-base::MessageLoopProxy* ProxyChannelDelegate::GetIPCMessageLoop() {\n-  return RenderThread::Get()->GetIOMessageLoopProxy().get();\n-}\n-\n-base::WaitableEvent* ProxyChannelDelegate::GetShutdownEvent() {\n-  return &shutdown_event_;\n-}\n-\n-IPC::PlatformFileForTransit ProxyChannelDelegate::ShareHandleWithRemote(\n-    base::PlatformFile handle,\n-    const IPC::SyncChannel& channel,\n-    bool should_close_source) {\n-  return content::BrokerGetFileHandleForProcess(handle, channel.peer_pid(),\n-                                                should_close_source);\n-}\n-\n-// Stubbed out SyncMessageStatusReceiver, required by HostDispatcher.\n-// TODO(bbudge) Use a content::PepperHungPluginFilter instead.\n-class SyncMessageStatusReceiver\n-    : public ppapi::proxy::HostDispatcher::SyncMessageStatusReceiver {\n- public:\n-  SyncMessageStatusReceiver() {}\n-\n-  // SyncMessageStatusReceiver implementation.\n-  virtual void BeginBlockOnSyncMessage() OVERRIDE {}\n-  virtual void EndBlockOnSyncMessage() OVERRIDE {}\n-\n- private:\n-  virtual ~SyncMessageStatusReceiver() {}\n-};\n-\n-class OutOfProcessProxy : public PluginDelegate::OutOfProcessProxy {\n- public:\n-  OutOfProcessProxy() {}\n-  virtual ~OutOfProcessProxy() {}\n-\n-  bool Init(const IPC::ChannelHandle& channel_handle,\n-            PP_Module pp_module,\n-            PP_GetInterface_Func local_get_interface,\n-            const ppapi::Preferences& preferences,\n-            SyncMessageStatusReceiver* status_receiver) {\n-    dispatcher_delegate_.reset(new ProxyChannelDelegate);\n-    dispatcher_.reset(new ppapi::proxy::HostDispatcher(\n-        pp_module, local_get_interface, status_receiver));\n-\n-    if (!dispatcher_->InitHostWithChannel(dispatcher_delegate_.get(),\n-                                          channel_handle,\n-                                          true,  // Client.\n-                                          preferences)) {\n-      dispatcher_.reset();\n-      dispatcher_delegate_.reset();\n-      return false;\n-    }\n-\n-    return true;\n-  }\n-\n-  // OutOfProcessProxy implementation.\n-  virtual const void* GetProxiedInterface(const char* name) OVERRIDE {\n-    return dispatcher_->GetProxiedInterface(name);\n-  }\n-  virtual void AddInstance(PP_Instance instance) OVERRIDE {\n-    ppapi::proxy::HostDispatcher::SetForInstance(instance, dispatcher_.get());\n-  }\n-  virtual void RemoveInstance(PP_Instance instance) OVERRIDE {\n-    ppapi::proxy::HostDispatcher::RemoveForInstance(instance);\n-  }\n-\n- private:\n-  scoped_ptr<ppapi::proxy::HostDispatcher> dispatcher_;\n-  scoped_ptr<ppapi::proxy::ProxyChannel::Delegate> dispatcher_delegate_;\n-};\n-\n PP_Bool StartPpapiProxy(PP_Instance instance) {\n-  if (CommandLine::ForCurrentProcess()->HasSwitch(\n-          switches::kEnableNaClIPCProxy)) {\n-    ChannelHandleMap& map = g_channel_handle_map.Get();\n-    ChannelHandleMap::iterator it = map.find(instance);\n-    if (it == map.end())\n-      return PP_FALSE;\n-    IPC::ChannelHandle channel_handle = it->second;\n-    map.erase(it);\n-\n-    webkit::ppapi::PluginInstance* plugin_instance =\n-        content::GetHostGlobals()->GetInstance(instance);\n-    if (!plugin_instance)\n-      return PP_FALSE;\n-\n-    WebView* web_view =\n-        plugin_instance->container()->element().document().frame()->view();\n-    RenderView* render_view = content::RenderView::FromWebView(web_view);\n-\n-    webkit::ppapi::PluginModule* plugin_module = plugin_instance->module();\n-\n-    scoped_refptr<SyncMessageStatusReceiver>\n-        status_receiver(new SyncMessageStatusReceiver());\n-    scoped_ptr<OutOfProcessProxy> out_of_process_proxy(new OutOfProcessProxy);\n-    if (out_of_process_proxy->Init(\n-            channel_handle,\n-            plugin_module->pp_module(),\n-            webkit::ppapi::PluginModule::GetLocalGetInterfaceFunc(),\n-            ppapi::Preferences(render_view->GetWebkitPreferences()),\n-            status_receiver.get())) {\n-      plugin_module->InitAsProxiedNaCl(\n-          out_of_process_proxy.PassAs<PluginDelegate::OutOfProcessProxy>(),\n-          instance);\n-      return PP_TRUE;\n-    }\n-  }\n-\n   return PP_FALSE;\n }\n ""}<_**next**_>{""sha"": ""37233944fac68aa18af52c66ca6a901cff9bb7a0"", ""filename"": ""ppapi/native_client/src/trusted/plugin/nacl_entry_points.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/ppapi/native_client/src/trusted/plugin/nacl_entry_points.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/ppapi/native_client/src/trusted/plugin/nacl_entry_points.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ppapi/native_client/src/trusted/plugin/nacl_entry_points.h?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -21,7 +21,10 @@ typedef bool (*LaunchNaClProcessFunc)(PP_Instance instance,\n                                       int socket_count,\n                                       nacl::Handle* result_sockets);\n \n+typedef bool (*StartPpapiProxyFunc)(PP_Instance instance);\n+\n \n extern LaunchNaClProcessFunc launch_nacl_process;\n+extern StartPpapiProxyFunc start_ppapi_proxy;\n \n #endif  // NATIVE_CLIENT_SRC_TRUSTED_PLUGIN_NACL_ENTRY_POINTS_H_""}<_**next**_>{""sha"": ""891df69100b5741bc66c53b161d217ef3237493e"", ""filename"": ""ppapi/native_client/src/trusted/plugin/plugin.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 30, ""changes"": 32, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/ppapi/native_client/src/trusted/plugin/plugin.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/ppapi/native_client/src/trusted/plugin/plugin.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ppapi/native_client/src/trusted/plugin/plugin.cc?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -34,7 +34,6 @@\n #include \""native_client/src/trusted/desc/nacl_desc_wrapper.h\""\n #include \""native_client/src/trusted/nonnacl_util/sel_ldr_launcher.h\""\n #include \""native_client/src/trusted/plugin/json_manifest.h\""\n-#include \""native_client/src/trusted/plugin/nacl_entry_points.h\""\n #include \""native_client/src/trusted/plugin/nacl_subprocess.h\""\n #include \""native_client/src/trusted/plugin/nexe_arch.h\""\n #include \""native_client/src/trusted/plugin/plugin_error.h\""\n@@ -55,7 +54,6 @@\n #include \""ppapi/c/ppp_input_event.h\""\n #include \""ppapi/c/ppp_instance.h\""\n #include \""ppapi/c/ppp_mouse_lock.h\""\n-#include \""ppapi/c/private/ppb_nacl_private.h\""\n #include \""ppapi/c/private/ppb_uma_private.h\""\n #include \""ppapi/cpp/dev/find_dev.h\""\n #include \""ppapi/cpp/dev/printing_dev.h\""\n@@ -122,13 +120,6 @@ const int64_t kSizeKBMin = 1;\n const int64_t kSizeKBMax = 512*1024;     // very large .nexe\n const uint32_t kSizeKBBuckets = 100;\n \n-const PPB_NaCl_Private* GetNaclInterface() {\n-  pp::Module *module = pp::Module::Get();\n-  CHECK(module);\n-  return static_cast<const PPB_NaCl_Private*>(\n-      module->GetBrowserInterface(PPB_NACL_PRIVATE_INTERFACE));\n-}\n-\n const PPB_UMA_Private* GetUMAInterface() {\n   pp::Module *module = pp::Module::Get();\n   CHECK(module);\n@@ -612,25 +603,12 @@ bool Plugin::LoadNaClModuleCommon(nacl::DescWrapper* wrapper,\n   }\n \n   bool service_runtime_started =\n-      new_service_runtime->Start(wrapper,\n-                                 error_info,\n-                                 manifest_base_url());\n+      new_service_runtime->Start(wrapper, error_info, manifest_base_url());\n   PLUGIN_PRINTF((\""Plugin::LoadNaClModuleCommon (service_runtime_started=%d)\\n\"",\n                  service_runtime_started));\n   if (!service_runtime_started) {\n     return false;\n   }\n-\n-  // Try to start the Chrome IPC-based proxy.\n-  const PPB_NaCl_Private* ppb_nacl = GetNaclInterface();\n-  if (ppb_nacl->StartPpapiProxy(pp_instance())) {\n-    using_ipc_proxy_ = true;\n-    // We need to explicitly schedule this here. It is normally called in\n-    // response to starting the SRPC proxy.\n-    CHECK(init_done_cb.pp_completion_callback().func != NULL);\n-    PLUGIN_PRINTF((\""Plugin::LoadNaClModuleCommon, started ipc proxy.\\n\""));\n-    pp::Module::Get()->core()->CallOnMainThread(0, init_done_cb, PP_OK);\n-  }\n   return true;\n }\n \n@@ -653,11 +631,6 @@ bool Plugin::LoadNaClModule(nacl::DescWrapper* wrapper,\n }\n \n bool Plugin::LoadNaClModuleContinuationIntern(ErrorInfo* error_info) {\n-  // If we are using the IPC proxy, StartSrpcServices and StartJSObjectProxy\n-  // don't makes sense. Return 'true' so that the plugin continues loading.\n-  if (using_ipc_proxy_)\n-    return true;\n-\n   if (!main_subprocess_.StartSrpcServices()) {\n     error_info->SetReport(ERROR_SRPC_CONNECTION_FAIL,\n                           \""SRPC connection failure for \"" +\n@@ -889,8 +862,7 @@ Plugin::Plugin(PP_Instance pp_instance)\n       init_time_(0),\n       ready_time_(0),\n       nexe_size_(0),\n-      time_of_last_progress_event_(0),\n-      using_ipc_proxy_(false) {\n+      time_of_last_progress_event_(0) {\n   PLUGIN_PRINTF((\""Plugin::Plugin (this=%p, pp_instance=%\""\n                  NACL_PRId32\"")\\n\"", static_cast<void*>(this), pp_instance));\n   callback_factory_.Initialize(this);""}<_**next**_>{""sha"": ""cd79517192aeef11df486a87ef294240105fffc9"", ""filename"": ""ppapi/native_client/src/trusted/plugin/plugin.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/ppapi/native_client/src/trusted/plugin/plugin.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/ppapi/native_client/src/trusted/plugin/plugin.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ppapi/native_client/src/trusted/plugin/plugin.h?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -517,9 +517,6 @@ class Plugin : public pp::InstancePrivate {\n   const FileDownloader* FindFileDownloader(PP_Resource url_loader) const;\n \n   int64_t time_of_last_progress_event_;\n-\n-  // Whether we are using IPC-based PPAPI proxy.\n-  bool using_ipc_proxy_;\n };\n \n }  // namespace plugin""}<_**next**_>{""sha"": ""a16f79aa0b470f3794100946649b62c4c6900c51"", ""filename"": ""webkit/plugins/ppapi/plugin_module.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 13, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/webkit/plugins/ppapi/plugin_module.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/webkit/plugins/ppapi/plugin_module.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/plugins/ppapi/plugin_module.cc?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -419,8 +419,7 @@ PluginModule::PluginModule(const std::string& name,\n       library_(NULL),\n       name_(name),\n       path_(path),\n-      reserve_instance_id_(NULL),\n-      nacl_ipc_proxy_(false) {\n+      reserve_instance_id_(NULL) {\n   // Ensure the globals object is created.\n   if (!host_globals)\n     host_globals = new HostGlobals;\n@@ -497,13 +496,9 @@ void PluginModule::InitAsProxied(\n }\n \n void PluginModule::InitAsProxiedNaCl(\n-    scoped_ptr<PluginDelegate::OutOfProcessProxy> out_of_process_proxy,\n+    PluginDelegate::OutOfProcessProxy* out_of_process_proxy,\n     PP_Instance instance) {\n-  // TODO(bbudge) We need to switch the mode of the PluginModule on a\n-  // per-instance basis. Fix this so out_of_process_proxy and other\n-  // state is stored in a map, indexed by instance.\n-  nacl_ipc_proxy_ = true;\n-  InitAsProxied(out_of_process_proxy.release());\n+  InitAsProxied(out_of_process_proxy);\n   // InitAsProxied (for the trusted/out-of-process case) initializes only the\n   // module, and one or more instances are added later. In this case, the\n   // PluginInstance was already created as in-process, so we missed the proxy\n@@ -565,11 +560,6 @@ void PluginModule::InstanceDeleted(PluginInstance* instance) {\n   if (out_of_process_proxy_.get())\n     out_of_process_proxy_->RemoveInstance(instance->pp_instance());\n   instances_.erase(instance);\n-\n-  if (nacl_ipc_proxy_) {\n-    out_of_process_proxy_.reset();\n-    reserve_instance_id_ = NULL;\n-  }\n }\n \n scoped_refptr< ::ppapi::CallbackTracker> PluginModule::GetCallbackTracker() {""}<_**next**_>{""sha"": ""d9b016234d991032f67d6d0eaaf42c99e95cc80f"", ""filename"": ""webkit/plugins/ppapi/plugin_module.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/3b0d77670a0613f409110817455d2137576b485a/webkit/plugins/ppapi/plugin_module.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3b0d77670a0613f409110817455d2137576b485a/webkit/plugins/ppapi/plugin_module.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/plugins/ppapi/plugin_module.h?ref=3b0d77670a0613f409110817455d2137576b485a"", ""patch"": ""@@ -90,7 +90,7 @@ class WEBKIT_PLUGINS_EXPORT PluginModule :\n   // Initializes this module for the given NaCl proxy. This takes\n   // ownership of the given pointer, even in the failure case.\n   void InitAsProxiedNaCl(\n-      scoped_ptr<PluginDelegate::OutOfProcessProxy> out_of_process_proxy,\n+      PluginDelegate::OutOfProcessProxy* out_of_process_proxy,\n       PP_Instance instance);\n \n   static const PPB_Core* GetCore();\n@@ -203,8 +203,6 @@ class WEBKIT_PLUGINS_EXPORT PluginModule :\n \n   PP_Bool (*reserve_instance_id_)(PP_Module, PP_Instance);\n \n-  bool nacl_ipc_proxy_;\n-\n   DISALLOW_COPY_AND_ASSIGN(PluginModule);\n };\n ""}","      new_service_runtime->Start(wrapper,/~/                                 error_info,/~/                                 manifest_base_url());/~/  // Try to start the Chrome IPC-based proxy./~/  const PPB_NaCl_Private* ppb_nacl = GetNaclInterface();/~/  if (ppb_nacl->StartPpapiProxy(pp_instance())) {/~/    using_ipc_proxy_ = true;/~/    // We need to explicitly schedule this here. It is normally called in/~/    // response to starting the SRPC proxy./~/    CHECK(init_done_cb.pp_completion_callback().func != NULL);/~/    PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon, started ipc proxy.\n""));/~/    pp::Module::Get()->core()->CallOnMainThread(0, init_done_cb, PP_OK);/~/  }","20,21,22,28,29,30,31,32,33,34,35,36,37","bool Plugin::LoadNaClModuleCommon(nacl::DescWrapper* wrapper,
                                  NaClSubprocess* subprocess,
                                  const Manifest* manifest,
                                  bool should_report_uma,
                                  ErrorInfo* error_info,
                                  pp::CompletionCallback init_done_cb,
                                  pp::CompletionCallback crash_cb) {
  ServiceRuntime* new_service_runtime =
      new ServiceRuntime(this, manifest, should_report_uma, init_done_cb,
                         crash_cb);
  subprocess->set_service_runtime(new_service_runtime);
  PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon (service_runtime=%p)\n"",
                 static_cast<void*>(new_service_runtime)));
  if (NULL == new_service_runtime) {
    error_info->SetReport(ERROR_SEL_LDR_INIT,
                          ""sel_ldr init failure "" + subprocess->description());
    return false;
   }
 
   bool service_runtime_started =
      new_service_runtime->Start(wrapper, error_info, manifest_base_url());
   PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon (service_runtime_started=%d)\n"",
                  service_runtime_started));
   if (!service_runtime_started) {
     return false;
   }
   return true;
 }
","bool Plugin::LoadNaClModuleCommon(nacl::DescWrapper* wrapper,
                                  NaClSubprocess* subprocess,
                                  const Manifest* manifest,
                                  bool should_report_uma,
                                  ErrorInfo* error_info,
                                  pp::CompletionCallback init_done_cb,
                                  pp::CompletionCallback crash_cb) {
  ServiceRuntime* new_service_runtime =
      new ServiceRuntime(this, manifest, should_report_uma, init_done_cb,
                         crash_cb);
  subprocess->set_service_runtime(new_service_runtime);
  PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon (service_runtime=%p)\n"",
                 static_cast<void*>(new_service_runtime)));
  if (NULL == new_service_runtime) {
    error_info->SetReport(ERROR_SEL_LDR_INIT,
                          ""sel_ldr init failure "" + subprocess->description());
    return false;
   }
 
   bool service_runtime_started =
      new_service_runtime->Start(wrapper,
                                 error_info,
                                 manifest_base_url());
   PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon (service_runtime_started=%d)\n"",
                  service_runtime_started));
   if (!service_runtime_started) {
     return false;
   }
  const PPB_NaCl_Private* ppb_nacl = GetNaclInterface();
  if (ppb_nacl->StartPpapiProxy(pp_instance())) {
    using_ipc_proxy_ = true;
    CHECK(init_done_cb.pp_completion_callback().func != NULL);
    PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon, started ipc proxy.\n""));
    pp::Module::Get()->core()->CallOnMainThread(0, init_done_cb, PP_OK);
  }
   return true;
 }
",184316.0,C,"      new_service_runtime->Start(wrapper, error_info, manifest_base_url());
","      new_service_runtime->Start(wrapper,
                                 error_info,
                                 manifest_base_url());
  const PPB_NaCl_Private* ppb_nacl = GetNaclInterface();
  if (ppb_nacl->StartPpapiProxy(pp_instance())) {
    using_ipc_proxy_ = true;
    CHECK(init_done_cb.pp_completion_callback().func != NULL);
    PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon, started ipc proxy.\n""));
    pp::Module::Get()->core()->CallOnMainThread(0, init_done_cb, PP_OK);
  }
",,"@@ -34,7 +34,6 @@
 #include ""native_client/src/trusted/desc/nacl_desc_wrapper.h""
 #include ""native_client/src/trusted/nonnacl_util/sel_ldr_launcher.h""
 #include ""native_client/src/trusted/plugin/json_manifest.h""
-#include ""native_client/src/trusted/plugin/nacl_entry_points.h""
 #include ""native_client/src/trusted/plugin/nacl_subprocess.h""
 #include ""native_client/src/trusted/plugin/nexe_arch.h""
 #include ""native_client/src/trusted/plugin/plugin_error.h""
@@ -55,7 +54,6 @@
 #include ""ppapi/c/ppp_input_event.h""
 #include ""ppapi/c/ppp_instance.h""
 #include ""ppapi/c/ppp_mouse_lock.h""
-#include ""ppapi/c/private/ppb_nacl_private.h""
 #include ""ppapi/c/private/ppb_uma_private.h""
 #include ""ppapi/cpp/dev/find_dev.h""
 #include ""ppapi/cpp/dev/printing_dev.h""
@@ -122,13 +120,6 @@ const int64_t kSizeKBMin = 1;
 const int64_t kSizeKBMax = 512*1024;     // very large .nexe
 const uint32_t kSizeKBBuckets = 100;
 
-const PPB_NaCl_Private* GetNaclInterface() {
-  pp::Module *module = pp::Module::Get();
-  CHECK(module);
-  return static_cast<const PPB_NaCl_Private*>(
-      module->GetBrowserInterface(PPB_NACL_PRIVATE_INTERFACE));
-}
-
 const PPB_UMA_Private* GetUMAInterface() {
   pp::Module *module = pp::Module::Get();
   CHECK(module);
@@ -612,25 +603,12 @@ bool Plugin::LoadNaClModuleCommon(nacl::DescWrapper* wrapper,
   }
 
   bool service_runtime_started =
-      new_service_runtime->Start(wrapper,
-                                 error_info,
-                                 manifest_base_url());
+      new_service_runtime->Start(wrapper, error_info, manifest_base_url());
   PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon (service_runtime_started=%d)\n"",
                  service_runtime_started));
   if (!service_runtime_started) {
     return false;
   }
-
-  // Try to start the Chrome IPC-based proxy.
-  const PPB_NaCl_Private* ppb_nacl = GetNaclInterface();
-  if (ppb_nacl->StartPpapiProxy(pp_instance())) {
-    using_ipc_proxy_ = true;
-    // We need to explicitly schedule this here. It is normally called in
-    // response to starting the SRPC proxy.
-    CHECK(init_done_cb.pp_completion_callback().func != NULL);
-    PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon, started ipc proxy.\n""));
-    pp::Module::Get()->core()->CallOnMainThread(0, init_done_cb, PP_OK);
-  }
   return true;
 }
 
@@ -653,11 +631,6 @@ bool Plugin::LoadNaClModule(nacl::DescWrapper* wrapper,
 }
 
 bool Plugin::LoadNaClModuleContinuationIntern(ErrorInfo* error_info) {
-  // If we are using the IPC proxy, StartSrpcServices and StartJSObjectProxy
-  // don't makes sense. Return 'true' so that the plugin continues loading.
-  if (using_ipc_proxy_)
-    return true;
-
   if (!main_subprocess_.StartSrpcServices()) {
     error_info->SetReport(ERROR_SRPC_CONNECTION_FAIL,
                           ""SRPC connection failure for "" +
@@ -889,8 +862,7 @@ Plugin::Plugin(PP_Instance pp_instance)
       init_time_(0),
       ready_time_(0),
       nexe_size_(0),
-      time_of_last_progress_event_(0),
-      using_ipc_proxy_(false) {
+      time_of_last_progress_event_(0) {
   PLUGIN_PRINTF((""Plugin::Plugin (this=%p, pp_instance=%""
                  NACL_PRId32"")\n"", static_cast<void*>(this), pp_instance));
   callback_factory_.Initialize(this);","bool Plugin::LoadNaClModuleCommon(nacl::DescWrapper* wrapper,
NaClSubprocess* subprocess,
const Manifest* manifest,
bool should_report_uma,
ErrorInfo* error_info,
pp::CompletionCallback init_done_cb,
pp::CompletionCallback crash_cb) {
ServiceRuntime* new_service_runtime =
new ServiceRuntime(this, manifest, should_report_uma, init_done_cb,
crash_cb);
subprocess->set_service_runtime(new_service_runtime);
PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon (service_runtime=%p)\n"",
static_cast<void*>(new_service_runtime)));
if (NULL == new_service_runtime) {
error_info->SetReport(ERROR_SEL_LDR_INIT,
""sel_ldr init failure "" + subprocess->description());
return false;
}

bool service_runtime_started =
      new_service_runtime->Start(wrapper,
                                 error_info,
                                 manifest_base_url());
PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon (service_runtime_started=%d)\n"",
service_runtime_started));
if (!service_runtime_started) {
return false;
}
  // Try to start the Chrome IPC-based proxy.
  const PPB_NaCl_Private* ppb_nacl = GetNaclInterface();
  if (ppb_nacl->StartPpapiProxy(pp_instance())) {
    using_ipc_proxy_ = true;
    // We need to explicitly schedule this here. It is normally called in
    // response to starting the SRPC proxy.
    CHECK(init_done_cb.pp_completion_callback().func != NULL);
    PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon, started ipc proxy.\n""));
    pp::Module::Get()->core()->CallOnMainThread(0, init_done_cb, PP_OK);
  }
return true;
}
",Chrome,3b0d77670a0613f409110817455d2137576b485a,4d4ee4c3db819fb3f46381e99608a156458e3ecb,1.0,"bool Plugin::LoadNaClModuleCommon(nacl::DescWrapper* wrapper,
                                  NaClSubprocess* subprocess,
                                  const Manifest* manifest,
                                  bool should_report_uma,
                                  ErrorInfo* error_info,
                                  pp::CompletionCallback init_done_cb,
                                  pp::CompletionCallback crash_cb) {
  ServiceRuntime* new_service_runtime =
      new ServiceRuntime(this, manifest, should_report_uma, init_done_cb,
                         crash_cb);
  subprocess->set_service_runtime(new_service_runtime);
  PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon (service_runtime=%p)\n"",
                 static_cast<void*>(new_service_runtime)));
  if (NULL == new_service_runtime) {
    error_info->SetReport(ERROR_SEL_LDR_INIT,
                          ""sel_ldr init failure "" + subprocess->description());
    return false;
   }
 
   bool service_runtime_started =
//flaw_line_below:
      new_service_runtime->Start(wrapper,
//flaw_line_below:
                                 error_info,
//flaw_line_below:
                                 manifest_base_url());
//fix_flaw_line_below:
//      new_service_runtime->Start(wrapper, error_info, manifest_base_url());
   PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon (service_runtime_started=%d)\n"",
                  service_runtime_started));
   if (!service_runtime_started) {
     return false;
   }
//flaw_line_below:

//flaw_line_below:
  // Try to start the Chrome IPC-based proxy.
//flaw_line_below:
  const PPB_NaCl_Private* ppb_nacl = GetNaclInterface();
//flaw_line_below:
  if (ppb_nacl->StartPpapiProxy(pp_instance())) {
//flaw_line_below:
    using_ipc_proxy_ = true;
//flaw_line_below:
    // We need to explicitly schedule this here. It is normally called in
//flaw_line_below:
    // response to starting the SRPC proxy.
//flaw_line_below:
    CHECK(init_done_cb.pp_completion_callback().func != NULL);
//flaw_line_below:
    PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon, started ipc proxy.\n""));
//flaw_line_below:
    pp::Module::Get()->core()->CallOnMainThread(0, init_done_cb, PP_OK);
//flaw_line_below:
  }
   return true;
 }
"
916,None,Remote,Not required,Complete,CVE-2011-3106,https://www.cvedetails.com/cve/CVE-2011-3106/,CWE-119,Low,Complete,Complete,,2012-05-24,10.0,"The WebSockets implementation in Google Chrome before 19.0.1084.52 does not properly handle use of SSL, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via unspecified vectors.",2017-09-18,DoS Exec Code Overflow Mem. Corr. ,1.0,https://github.com/chromium/chromium/commit/5385c44d9634d00b1cec2abf0fe7290d4205c7b0,5385c44d9634d00b1cec2abf0fe7290d4205c7b0,"Inherits SupportsWeakPtr<T> instead of having WeakPtrFactory<T>

This change refines r137676.

BUG=122654
TEST=browser_test


Review URL: https://chromiumcodereview.appspot.com/10332233

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@139771 0039d316-1c4b-4281-b951-d872f2087c98",1.0,content/browser/ssl/ssl_manager.cc,"{""sha"": ""ee6051b454c52c284eaf1890da3b1d228f5110f0"", ""filename"": ""content/browser/renderer_host/resource_dispatcher_host_impl.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 12, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/renderer_host/resource_dispatcher_host_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/renderer_host/resource_dispatcher_host_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/resource_dispatcher_host_impl.cc?ref=5385c44d9634d00b1cec2abf0fe7290d4205c7b0"", ""patch"": ""@@ -320,8 +320,6 @@ ResourceDispatcherHostImpl::ResourceDispatcherHostImpl()\n     : download_file_manager_(new DownloadFileManager(NULL)),\n       save_file_manager_(new SaveFileManager()),\n       request_id_(-1),\n-      ALLOW_THIS_IN_INITIALIZER_LIST(weak_factory_(this)),\n-      ALLOW_THIS_IN_INITIALIZER_LIST(ssl_delegate_weak_factory_(this)),\n       is_shutdown_(false),\n       max_outstanding_requests_cost_per_process_(\n           kMaxOutstandingRequestsCostPerProcess),\n@@ -1517,9 +1515,9 @@ void ResourceDispatcherHostImpl::OnSSLCertificateError(\n   int render_view_id;\n   if(!info->GetAssociatedRenderView(&render_process_id, &render_view_id))\n     NOTREACHED();\n-  SSLManager::OnSSLCertificateError(ssl_delegate_weak_factory_.GetWeakPtr(),\n-      request_id, info->GetResourceType(), request->url(), render_process_id,\n-      render_view_id, ssl_info, is_hsts_host);\n+  SSLManager::OnSSLCertificateError(\n+      AsWeakPtr(), request_id, info->GetResourceType(), request->url(),\n+      render_process_id, render_view_id, ssl_info, is_hsts_host);\n }\n \n void ResourceDispatcherHostImpl::OnResponseStarted(net::URLRequest* request) {\n@@ -1801,10 +1799,8 @@ void ResourceDispatcherHostImpl::PauseRequest(int child_id,\n   // asynchronously to avoid recursion problems.\n   if (info->pause_count() == 0) {\n     MessageLoop::current()->PostTask(FROM_HERE,\n-        base::Bind(\n-            &ResourceDispatcherHostImpl::ResumeRequest,\n-            weak_factory_.GetWeakPtr(),\n-            global_id));\n+        base::Bind(&ResourceDispatcherHostImpl::ResumeRequest,\n+                   AsWeakPtr(), global_id));\n   }\n }\n \n@@ -1919,9 +1915,8 @@ void ResourceDispatcherHostImpl::OnReadCompleted(net::URLRequest* request,\n         GlobalRequestID id(info->GetChildID(), info->GetRequestID());\n         MessageLoop::current()->PostTask(\n             FROM_HERE,\n-            base::Bind(\n-                &ResourceDispatcherHostImpl::ResumeRequest,\n-                weak_factory_.GetWeakPtr(), id));\n+            base::Bind(&ResourceDispatcherHostImpl::ResumeRequest,\n+                       AsWeakPtr(), id));\n         return;\n       }\n     }""}<_**next**_>{""sha"": ""f7c62743b1c7aaec8cdba6096d3f7c7eecf43d70"", ""filename"": ""content/browser/renderer_host/resource_dispatcher_host_impl.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 7, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/renderer_host/resource_dispatcher_host_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/renderer_host/resource_dispatcher_host_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/resource_dispatcher_host_impl.h?ref=5385c44d9634d00b1cec2abf0fe7290d4205c7b0"", ""patch"": ""@@ -62,7 +62,8 @@ struct Referrer;\n class CONTENT_EXPORT ResourceDispatcherHostImpl\n     : public ResourceDispatcherHost,\n       public net::URLRequest::Delegate,\n-      public SSLErrorHandler::Delegate {\n+      public SSLErrorHandler::Delegate,\n+      public base::SupportsWeakPtr<ResourceDispatcherHostImpl> {\n  public:\n   ResourceDispatcherHostImpl();\n   virtual ~ResourceDispatcherHostImpl();\n@@ -476,12 +477,6 @@ class CONTENT_EXPORT ResourceDispatcherHostImpl\n   // request_id_.\n   int request_id_;\n \n-  // For running tasks.\n-  base::WeakPtrFactory<ResourceDispatcherHostImpl> weak_factory_;\n-\n-  // For SSLErrorHandler::Delegate calls from SSLManager.\n-  base::WeakPtrFactory<SSLErrorHandler::Delegate> ssl_delegate_weak_factory_;\n-\n   // True if the resource dispatcher host has been shut down.\n   bool is_shutdown_;\n ""}<_**next**_>{""sha"": ""a947a1e66ee1b0c7f5e27ea1b2c9ce8b86c9eb73"", ""filename"": ""content/browser/renderer_host/socket_stream_dispatcher_host.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/renderer_host/socket_stream_dispatcher_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/renderer_host/socket_stream_dispatcher_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/socket_stream_dispatcher_host.cc?ref=5385c44d9634d00b1cec2abf0fe7290d4205c7b0"", ""patch"": ""@@ -21,8 +21,7 @@ SocketStreamDispatcherHost::SocketStreamDispatcherHost(\n     int render_process_id,\n     ResourceMessageFilter::URLRequestContextSelector* selector,\n     content::ResourceContext* resource_context)\n-    : ALLOW_THIS_IN_INITIALIZER_LIST(ssl_delegate_weak_factory_(this)),\n-      render_process_id_(render_process_id),\n+    : render_process_id_(render_process_id),\n       url_request_context_selector_(selector),\n       resource_context_(resource_context) {\n   DCHECK(selector);\n@@ -111,8 +110,8 @@ void SocketStreamDispatcherHost::OnSSLCertificateError(\n   SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);\n   DCHECK(socket_stream_host);\n   content::GlobalRequestID request_id(-1, socket_id);\n-  SSLManager::OnSSLCertificateError(ssl_delegate_weak_factory_.GetWeakPtr(),\n-      request_id, ResourceType::SUB_RESOURCE, socket->url(),\n+  SSLManager::OnSSLCertificateError(\n+      AsWeakPtr(), request_id, ResourceType::SUB_RESOURCE, socket->url(),\n       render_process_id_, socket_stream_host->render_view_id(), ssl_info,\n       fatal);\n }""}<_**next**_>{""sha"": ""e5cb99794c6e7e244edfb6052f691f210b2c6bdf"", ""filename"": ""content/browser/renderer_host/socket_stream_dispatcher_host.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 6, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/renderer_host/socket_stream_dispatcher_host.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/renderer_host/socket_stream_dispatcher_host.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/socket_stream_dispatcher_host.h?ref=5385c44d9634d00b1cec2abf0fe7290d4205c7b0"", ""patch"": ""@@ -29,9 +29,11 @@ class SSLInfo;\n // Dispatches ViewHostMsg_SocketStream_* messages sent from renderer.\n // It also acts as SocketStream::Delegate so that it sends\n // ViewMsg_SocketStream_* messages back to renderer.\n-class SocketStreamDispatcherHost : public content::BrowserMessageFilter,\n-                                   public net::SocketStream::Delegate,\n-                                   public SSLErrorHandler::Delegate {\n+class SocketStreamDispatcherHost\n+    : public content::BrowserMessageFilter,\n+      public net::SocketStream::Delegate,\n+      public SSLErrorHandler::Delegate,\n+      public base::SupportsWeakPtr<SocketStreamDispatcherHost> {\n  public:\n   SocketStreamDispatcherHost(\n       int render_process_id,\n@@ -81,9 +83,6 @@ class SocketStreamDispatcherHost : public content::BrowserMessageFilter,\n \n   net::URLRequestContext* GetURLRequestContext();\n \n-  // For SSLErrorHandler::Delegate calls from SSLManager.\n-  base::WeakPtrFactory<SSLErrorHandler::Delegate> ssl_delegate_weak_factory_;\n-\n   IDMap<SocketStreamHost> hosts_;\n   int render_process_id_;\n   const scoped_ptr<ResourceMessageFilter::URLRequestContextSelector>""}<_**next**_>{""sha"": ""740aa6bf1ba1e068929afeb10ef33e0c01b06486"", ""filename"": ""content/browser/ssl/ssl_cert_error_handler.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/ssl/ssl_cert_error_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/ssl/ssl_cert_error_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/ssl/ssl_cert_error_handler.cc?ref=5385c44d9634d00b1cec2abf0fe7290d4205c7b0"", ""patch"": ""@@ -13,7 +13,7 @@\n using content::ResourceDispatcherHostImpl;\n \n SSLCertErrorHandler::SSLCertErrorHandler(\n-    base::WeakPtr<Delegate> delegate,\n+    const base::WeakPtr<Delegate>& delegate,\n     const content::GlobalRequestID& id,\n     ResourceType::Type resource_type,\n     const GURL& url,""}<_**next**_>{""sha"": ""f290a9b4027c609739408789501b377fae3b5780"", ""filename"": ""content/browser/ssl/ssl_cert_error_handler.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/ssl/ssl_cert_error_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/ssl/ssl_cert_error_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/ssl/ssl_cert_error_handler.h?ref=5385c44d9634d00b1cec2abf0fe7290d4205c7b0"", ""patch"": ""@@ -18,7 +18,7 @@\n class SSLCertErrorHandler : public SSLErrorHandler {\n  public:\n   // Construct on the IO thread.\n-  SSLCertErrorHandler(base::WeakPtr<Delegate> delegate,\n+  SSLCertErrorHandler(const base::WeakPtr<Delegate>& delegate,\n                       const content::GlobalRequestID& id,\n                       ResourceType::Type resource_type,\n                       const GURL& url,""}<_**next**_>{""sha"": ""0db86227158dca755ef20cb28706867f4d5acd85"", ""filename"": ""content/browser/ssl/ssl_error_handler.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/ssl/ssl_error_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/ssl/ssl_error_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/ssl/ssl_error_handler.cc?ref=5385c44d9634d00b1cec2abf0fe7290d4205c7b0"", ""patch"": ""@@ -19,7 +19,7 @@ using content::RenderViewHostImpl;\n using content::WebContents;\n using net::SSLInfo;\n \n-SSLErrorHandler::SSLErrorHandler(base::WeakPtr<Delegate> delegate,\n+SSLErrorHandler::SSLErrorHandler(const base::WeakPtr<Delegate>& delegate,\n                                  const content::GlobalRequestID& id,\n                                  ResourceType::Type resource_type,\n                                  const GURL& url,""}<_**next**_>{""sha"": ""3063d1669d3d50aedbd7074bea8d5d85bb621103"", ""filename"": ""content/browser/ssl/ssl_error_handler.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/ssl/ssl_error_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/ssl/ssl_error_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/ssl/ssl_error_handler.h?ref=5385c44d9634d00b1cec2abf0fe7290d4205c7b0"", ""patch"": ""@@ -106,7 +106,7 @@ class SSLErrorHandler : public base::RefCountedThreadSafe<SSLErrorHandler> {\n   friend class base::RefCountedThreadSafe<SSLErrorHandler>;\n \n   // Construct on the IO thread.\n-  SSLErrorHandler(base::WeakPtr<Delegate> delegate,\n+  SSLErrorHandler(const base::WeakPtr<Delegate>& delegate,\n                   const content::GlobalRequestID& id,\n                   ResourceType::Type resource_type,\n                   const GURL& url,""}<_**next**_>{""sha"": ""753a5f4d90824b7509b96f86134a0ea3e1cc1ab9"", ""filename"": ""content/browser/ssl/ssl_manager.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/ssl/ssl_manager.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/ssl/ssl_manager.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/ssl/ssl_manager.cc?ref=5385c44d9634d00b1cec2abf0fe7290d4205c7b0"", ""patch"": ""@@ -36,7 +36,7 @@ using content::WebContents;\n \n // static\n void SSLManager::OnSSLCertificateError(\n-    base::WeakPtr<SSLErrorHandler::Delegate> delegate,\n+    const base::WeakPtr<SSLErrorHandler::Delegate>& delegate,\n     const content::GlobalRequestID& id,\n     const ResourceType::Type resource_type,\n     const GURL& url,""}<_**next**_>{""sha"": ""db5d5394476e619a39531315a789884ae5560f0e"", ""filename"": ""content/browser/ssl/ssl_manager.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/ssl/ssl_manager.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5385c44d9634d00b1cec2abf0fe7290d4205c7b0/content/browser/ssl/ssl_manager.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/ssl/ssl_manager.h?ref=5385c44d9634d00b1cec2abf0fe7290d4205c7b0"", ""patch"": ""@@ -52,7 +52,7 @@ class SSLManager : public content::NotificationObserver {\n   //\n   // Called on the IO thread.\n   static void OnSSLCertificateError(\n-      base::WeakPtr<SSLErrorHandler::Delegate> delegate,\n+      const base::WeakPtr<SSLErrorHandler::Delegate>& delegate,\n       const content::GlobalRequestID& id,\n       ResourceType::Type resource_type,\n       const GURL& url,""}","    base::WeakPtr<SSLErrorHandler::Delegate> delegate,",1," void SSLManager::OnSSLCertificateError(
    const base::WeakPtr<SSLErrorHandler::Delegate>& delegate,
     const content::GlobalRequestID& id,
     const ResourceType::Type resource_type,
     const GURL& url,
    int render_process_id,
    int render_view_id,
    const net::SSLInfo& ssl_info,
    bool fatal) {
  DCHECK(delegate);
  DVLOG(1) << ""OnSSLCertificateError() cert_error: ""
           << net::MapCertStatusToNetError(ssl_info.cert_status)
           << "" id: "" << id.child_id << "","" << id.request_id
           << "" resource_type: "" << resource_type
           << "" url: "" << url.spec()
           << "" render_process_id: "" << render_process_id
           << "" render_view_id: "" << render_view_id
           << "" cert_status: "" << std::hex << ssl_info.cert_status;

  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&SSLCertErrorHandler::Dispatch,
                 new SSLCertErrorHandler(delegate,
                                         id,
                                         resource_type,
                                         url,
                                         render_process_id,
                                         render_view_id,
                                         ssl_info,
                                         fatal)));
}
"," void SSLManager::OnSSLCertificateError(
    base::WeakPtr<SSLErrorHandler::Delegate> delegate,
     const content::GlobalRequestID& id,
     const ResourceType::Type resource_type,
     const GURL& url,
    int render_process_id,
    int render_view_id,
    const net::SSLInfo& ssl_info,
    bool fatal) {
  DCHECK(delegate);
  DVLOG(1) << ""OnSSLCertificateError() cert_error: ""
           << net::MapCertStatusToNetError(ssl_info.cert_status)
           << "" id: "" << id.child_id << "","" << id.request_id
           << "" resource_type: "" << resource_type
           << "" url: "" << url.spec()
           << "" render_process_id: "" << render_process_id
           << "" render_view_id: "" << render_view_id
           << "" cert_status: "" << std::hex << ssl_info.cert_status;

  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&SSLCertErrorHandler::Dispatch,
                 new SSLCertErrorHandler(delegate,
                                         id,
                                         resource_type,
                                         url,
                                         render_process_id,
                                         render_view_id,
                                         ssl_info,
                                         fatal)));
}
",184688.0,C,"    const base::WeakPtr<SSLErrorHandler::Delegate>& delegate,
","    base::WeakPtr<SSLErrorHandler::Delegate> delegate,
",,"@@ -36,7 +36,7 @@ using content::WebContents;
 
 // static
 void SSLManager::OnSSLCertificateError(
-    base::WeakPtr<SSLErrorHandler::Delegate> delegate,
+    const base::WeakPtr<SSLErrorHandler::Delegate>& delegate,
     const content::GlobalRequestID& id,
     const ResourceType::Type resource_type,
     const GURL& url,","void SSLManager::OnSSLCertificateError(
    base::WeakPtr<SSLErrorHandler::Delegate> delegate,
const content::GlobalRequestID& id,
const ResourceType::Type resource_type,
const GURL& url,
int render_process_id,
int render_view_id,
const net::SSLInfo& ssl_info,
bool fatal) {
DCHECK(delegate);
DVLOG(1) << ""OnSSLCertificateError() cert_error: ""
<< net::MapCertStatusToNetError(ssl_info.cert_status)
<< "" id: "" << id.child_id << "","" << id.request_id
<< "" resource_type: "" << resource_type
<< "" url: "" << url.spec()
<< "" render_process_id: "" << render_process_id
<< "" render_view_id: "" << render_view_id
<< "" cert_status: "" << std::hex << ssl_info.cert_status;

// A certificate error occurred.  Construct a SSLCertErrorHandler object and
// hand it over to the UI thread for processing.
BrowserThread::PostTask(
BrowserThread::UI, FROM_HERE,
base::Bind(&SSLCertErrorHandler::Dispatch,
new SSLCertErrorHandler(delegate,
id,
resource_type,
url,
render_process_id,
render_view_id,
ssl_info,
fatal)));
}
",Chrome,5385c44d9634d00b1cec2abf0fe7290d4205c7b0,300967cc6dd0335308d9e06d93720649e0403a26,1.0," void SSLManager::OnSSLCertificateError(
//flaw_line_below:
    base::WeakPtr<SSLErrorHandler::Delegate> delegate,
//fix_flaw_line_below:
//    const base::WeakPtr<SSLErrorHandler::Delegate>& delegate,
     const content::GlobalRequestID& id,
     const ResourceType::Type resource_type,
     const GURL& url,
    int render_process_id,
    int render_view_id,
    const net::SSLInfo& ssl_info,
    bool fatal) {
  DCHECK(delegate);
  DVLOG(1) << ""OnSSLCertificateError() cert_error: ""
           << net::MapCertStatusToNetError(ssl_info.cert_status)
           << "" id: "" << id.child_id << "","" << id.request_id
           << "" resource_type: "" << resource_type
           << "" url: "" << url.spec()
           << "" render_process_id: "" << render_process_id
           << "" render_view_id: "" << render_view_id
           << "" cert_status: "" << std::hex << ssl_info.cert_status;

  // A certificate error occurred.  Construct a SSLCertErrorHandler object and
  // hand it over to the UI thread for processing.
  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&SSLCertErrorHandler::Dispatch,
                 new SSLCertErrorHandler(delegate,
                                         id,
                                         resource_type,
                                         url,
                                         render_process_id,
                                         render_view_id,
                                         ssl_info,
                                         fatal)));
}
"
951,None,Remote,Not required,Complete,CVE-2012-2816,https://www.cvedetails.com/cve/CVE-2012-2816/,,Low,None,None,,2012-06-27,7.8,"Google Chrome before 20.0.1132.43 on Windows does not properly isolate sandboxed processes, which might allow remote attackers to cause a denial of service (process interference) via unspecified vectors.",2017-09-18,DoS ,2.0,https://github.com/chromium/chromium/commit/cd0bd79d6ebdb72183e6f0833673464cc10b3600,cd0bd79d6ebdb72183e6f0833673464cc10b3600,"Convert plugin and GPU process to brokered handle duplication.

BUG=119250
Review URL: https://chromiumcodereview.appspot.com/9958034

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@132303 0039d316-1c4b-4281-b951-d872f2087c98",5.0,content/renderer/render_thread_impl.cc,"{""sha"": ""cbb47ddf0c9cb496b29e6a45b27d0ad8d5ffa495"", ""filename"": ""chrome/common/chrome_content_client.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/chrome/common/chrome_content_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/chrome/common/chrome_content_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/chrome_content_client.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -402,6 +402,15 @@ bool ChromeContentClient::SandboxPlugin(CommandLine* command_line,\n     return false;\n   }\n \n+  // Add policy for the plugin proxy window pump event\n+  // used by WebPluginDelegateProxy::HandleInputEvent().\n+  if (policy->AddRule(sandbox::TargetPolicy::SUBSYS_HANDLES,\n+                      sandbox::TargetPolicy::HANDLES_DUP_ANY,\n+                      L\""Event\"") != sandbox::SBOX_ALL_OK) {\n+    NOTREACHED();\n+    return false;\n+  }\n+\n   // Add the policy for the pipes.\n   if (policy->AddRule(sandbox::TargetPolicy::SUBSYS_NAMED_PIPES,\n                       sandbox::TargetPolicy::NAMEDPIPES_ALLOW_ANY,""}<_**next**_>{""sha"": ""7cc192f7cd0efd3894822602652107a6253bc227"", ""filename"": ""content/browser/gpu/browser_gpu_channel_host_factory.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 21, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/browser/gpu/browser_gpu_channel_host_factory.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/browser/gpu/browser_gpu_channel_host_factory.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/gpu/browser_gpu_channel_host_factory.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -26,8 +26,7 @@ BrowserGpuChannelHostFactory::CreateRequest::~CreateRequest() {\n }\n \n BrowserGpuChannelHostFactory::EstablishRequest::EstablishRequest()\n-    : event(false, false),\n-      gpu_process_handle(base::kNullProcessHandle) {\n+    : event(false, false) {\n }\n \n BrowserGpuChannelHostFactory::EstablishRequest::~EstablishRequest() {\n@@ -153,10 +152,8 @@ void BrowserGpuChannelHostFactory::EstablishGpuChannelOnIO(\n void BrowserGpuChannelHostFactory::GpuChannelEstablishedOnIO(\n     EstablishRequest* request,\n     const IPC::ChannelHandle& channel_handle,\n-    base::ProcessHandle gpu_process_handle,\n     const GPUInfo& gpu_info) {\n   request->channel_handle = channel_handle;\n-  request->gpu_process_handle = gpu_process_handle;\n   request->gpu_info = gpu_info;\n   request->event.Signal();\n }\n@@ -187,30 +184,15 @@ GpuChannelHost* BrowserGpuChannelHostFactory::EstablishGpuChannelSync(\n   // TODO(piman): Make this asynchronous.\n   request.event.Wait();\n \n-  if (request.channel_handle.name.empty() ||\n-      request.gpu_process_handle == base::kNullProcessHandle)\n+  if (request.channel_handle.name.empty())\n     return NULL;\n \n-  base::ProcessHandle browser_process_for_gpu;\n-#if defined(OS_WIN)\n-  // Create a process handle that the GPU process can use to access our handles.\n-  DuplicateHandle(base::GetCurrentProcessHandle(),\n-      base::GetCurrentProcessHandle(),\n-      request.gpu_process_handle,\n-      &browser_process_for_gpu,\n-      PROCESS_DUP_HANDLE,\n-      FALSE,\n-      0);\n-#else\n-  browser_process_for_gpu = base::GetCurrentProcessHandle();\n-#endif\n-\n   gpu_channel_ = new GpuChannelHost(this, gpu_host_id_, gpu_client_id_);\n   gpu_channel_->set_gpu_info(request.gpu_info);\n   content::GetContentClient()->SetGpuInfo(request.gpu_info);\n \n   // Connect to the GPU process if a channel name was received.\n-  gpu_channel_->Connect(request.channel_handle, browser_process_for_gpu);\n+  gpu_channel_->Connect(request.channel_handle);\n \n   return gpu_channel_.get();\n }""}<_**next**_>{""sha"": ""f0a61b6437eec2eccccdf467e42d5f56acc915f3"", ""filename"": ""content/browser/gpu/browser_gpu_channel_host_factory.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/browser/gpu/browser_gpu_channel_host_factory.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/browser/gpu/browser_gpu_channel_host_factory.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/gpu/browser_gpu_channel_host_factory.h?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -48,7 +48,6 @@ class BrowserGpuChannelHostFactory : public GpuChannelHostFactory {\n     ~EstablishRequest();\n     base::WaitableEvent event;\n     IPC::ChannelHandle channel_handle;\n-    base::ProcessHandle gpu_process_handle;\n     GPUInfo gpu_info;\n   };\n \n@@ -65,7 +64,6 @@ class BrowserGpuChannelHostFactory : public GpuChannelHostFactory {\n   static void GpuChannelEstablishedOnIO(\n       EstablishRequest* request,\n       const IPC::ChannelHandle& channel_handle,\n-      base::ProcessHandle gpu_process_handle,\n       const GPUInfo& gpu_info);\n \n   int gpu_client_id_;""}<_**next**_>{""sha"": ""25461317316c1cbbcc921a6232dbb39580de77ff"", ""filename"": ""content/browser/gpu/gpu_process_host.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 31, ""changes"": 33, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/browser/gpu/gpu_process_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/browser/gpu/gpu_process_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/gpu/gpu_process_host.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -267,7 +267,6 @@ GpuProcessHost* GpuProcessHost::FromID(int host_id) {\n \n GpuProcessHost::GpuProcessHost(int host_id, GpuProcessKind kind)\n     : host_id_(host_id),\n-      gpu_process_(base::kNullProcessHandle),\n       in_process_(false),\n       software_rendering_(false),\n       kind_(kind),\n@@ -338,11 +337,6 @@ GpuProcessHost::~GpuProcessHost() {\n                               content::RESULT_CODE_LAST_CODE);\n   }\n \n-#if defined(OS_WIN)\n-  if (gpu_process_)\n-    CloseHandle(gpu_process_);\n-#endif\n-\n   // In case we never started, clean up.\n   while (!queued_messages_.empty()) {\n     delete queued_messages_.front();\n@@ -498,10 +492,6 @@ void GpuProcessHost::CreateViewCommandBuffer(\n \n void GpuProcessHost::OnChannelEstablished(\n     const IPC::ChannelHandle& channel_handle) {\n-  // The GPU process should have launched at this point and this object should\n-  // have been notified of its process handle.\n-  DCHECK(gpu_process_);\n-\n   EstablishChannelCallback callback = channel_requests_.front();\n   channel_requests_.pop();\n \n@@ -521,7 +511,7 @@ void GpuProcessHost::OnChannelEstablished(\n     return;\n   }\n \n-  callback.Run(channel_handle, gpu_process_,\n+  callback.Run(channel_handle,\n                GpuDataManagerImpl::GetInstance()->GetGPUInfo());\n }\n \n@@ -623,25 +613,6 @@ void GpuProcessHost::OnAcceleratedSurfaceRelease(\n #endif  // OS_WIN && !USE_AURA\n \n void GpuProcessHost::OnProcessLaunched() {\n-  // Send the GPU process handle to the UI thread before it has to\n-  // respond to any requests to establish a GPU channel. The response\n-  // to such requests require that the GPU process handle be known.\n-\n-  base::ProcessHandle child_handle = in_process_ ?\n-      base::GetCurrentProcessHandle() : process_->GetData().handle;\n-\n-#if defined(OS_WIN)\n-  DuplicateHandle(base::GetCurrentProcessHandle(),\n-                  child_handle,\n-                  base::GetCurrentProcessHandle(),\n-                  &gpu_process_,\n-                  PROCESS_DUP_HANDLE,\n-                  FALSE,\n-                  0);\n-#else\n-  gpu_process_ = child_handle;\n-#endif\n-\n   UMA_HISTOGRAM_TIMES(\""GPU.GPUProcessLaunchTime\"",\n                       base::TimeTicks::Now() - init_start_time_);\n }\n@@ -774,7 +745,7 @@ void GpuProcessHost::EstablishChannelError(\n     const IPC::ChannelHandle& channel_handle,\n     base::ProcessHandle renderer_process_for_gpu,\n     const content::GPUInfo& gpu_info) {\n-  callback.Run(channel_handle, renderer_process_for_gpu, gpu_info);\n+  callback.Run(channel_handle, gpu_info);\n }\n \n void GpuProcessHost::CreateCommandBufferError(""}<_**next**_>{""sha"": ""f101c6c3d4ff940708b24da479df589db44e1705"", ""filename"": ""content/browser/gpu/gpu_process_host.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/browser/gpu/gpu_process_host.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/browser/gpu/gpu_process_host.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/gpu/gpu_process_host.h?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -41,7 +41,6 @@ class GpuProcessHost : public content::BrowserChildProcessHostDelegate,\n   };\n \n   typedef base::Callback<void(const IPC::ChannelHandle&,\n-                              base::ProcessHandle,\n                               const content::GPUInfo&)>\n       EstablishChannelCallback;\n \n@@ -165,9 +164,6 @@ class GpuProcessHost : public content::BrowserChildProcessHostDelegate,\n   // Qeueud messages to send when the process launches.\n   std::queue<IPC::Message*> queued_messages_;\n \n-  // The handle for the GPU process or null if it is not known to be launched.\n-  base::ProcessHandle gpu_process_;\n-\n   // Whether we are running a GPU thread inside the browser process instead\n   // of a separate GPU process.\n   bool in_process_;""}<_**next**_>{""sha"": ""75ad4faf046eaea191be62ba00acfd17044ed419"", ""filename"": ""content/browser/renderer_host/gpu_message_filter.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 21, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/browser/renderer_host/gpu_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/browser/renderer_host/gpu_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/gpu_message_filter.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -173,31 +173,11 @@ void GpuMessageFilter::OnCreateViewCommandBuffer(\n void GpuMessageFilter::EstablishChannelCallback(\n     IPC::Message* reply,\n     const IPC::ChannelHandle& channel,\n-    base::ProcessHandle gpu_process_for_browser,\n     const content::GPUInfo& gpu_info) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n \n-  base::ProcessHandle renderer_process_for_gpu;\n-  if (gpu_process_for_browser != 0) {\n-#if defined(OS_WIN)\n-    // Create a process handle that the renderer process can give to the GPU\n-    // process to give it access to its handles.\n-    DuplicateHandle(base::GetCurrentProcessHandle(),\n-                    peer_handle(),\n-                    gpu_process_for_browser,\n-                    &renderer_process_for_gpu,\n-                    PROCESS_DUP_HANDLE,\n-                    FALSE,\n-                    0);\n-#else\n-    renderer_process_for_gpu = peer_handle();\n-#endif\n-  } else {\n-    renderer_process_for_gpu = 0;\n-  }\n-\n   GpuHostMsg_EstablishGpuChannel::WriteReplyParams(\n-      reply, render_process_id_, channel, renderer_process_for_gpu, gpu_info);\n+      reply, render_process_id_, channel, gpu_info);\n   Send(reply);\n }\n ""}<_**next**_>{""sha"": ""e7a73f1f895191389dabda0d5fc67926bc6e2083"", ""filename"": ""content/browser/renderer_host/gpu_message_filter.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/browser/renderer_host/gpu_message_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/browser/renderer_host/gpu_message_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/gpu_message_filter.h?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -58,7 +58,6 @@ class GpuMessageFilter : public content::BrowserMessageFilter,\n   // Helper callbacks for the message handlers.\n   void EstablishChannelCallback(IPC::Message* reply,\n                                 const IPC::ChannelHandle& channel,\n-                                base::ProcessHandle gpu_process_for_browser,\n                                 const content::GPUInfo& gpu_info);\n   void CreateCommandBufferCallback(IPC::Message* reply, int32 route_id);\n ""}<_**next**_>{""sha"": ""1bb1887a7bf6e153a658497fd0590083a0caddaf"", ""filename"": ""content/common/gpu/client/command_buffer_proxy_impl.cc"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 2, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/client/command_buffer_proxy_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/client/command_buffer_proxy_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/client/command_buffer_proxy_impl.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -20,6 +20,10 @@\n #include \""gpu/command_buffer/common/command_buffer_shared.h\""\n #include \""ui/gfx/size.h\""\n \n+#if defined(OS_WIN)\n+#include \""content/common/sandbox_policy.h\""\n+#endif\n+\n using gpu::Buffer;\n \n CommandBufferProxyImpl::CommandBufferProxyImpl(\n@@ -234,7 +238,13 @@ int32 CommandBufferProxyImpl::CreateTransferBuffer(\n     return -1;\n \n   base::SharedMemoryHandle handle = shm->handle();\n-#if defined(OS_POSIX)\n+#if defined(OS_WIN)\n+  // Windows needs to explicitly duplicate the handle out to another process.\n+  if (!sandbox::BrokerDuplicateHandle(handle, channel_->gpu_pid(),\n+                                      &handle, FILE_MAP_WRITE, 0)) {\n+    return -1;\n+  }\n+#elif defined(OS_POSIX)\n   DCHECK(!handle.auto_close);\n #endif\n \n@@ -257,10 +267,20 @@ int32 CommandBufferProxyImpl::RegisterTransferBuffer(\n   if (last_state_.error != gpu::error::kNoError)\n     return -1;\n \n+  // Returns FileDescriptor with auto_close off.\n+  base::SharedMemoryHandle handle = shared_memory->handle();\n+#if defined(OS_WIN)\n+  // Windows needs to explicitly duplicate the handle out to another process.\n+  if (!sandbox::BrokerDuplicateHandle(handle, channel_->gpu_pid(),\n+                                      &handle, FILE_MAP_WRITE, 0)) {\n+    return -1;\n+  }\n+#endif\n+\n   int32 id;\n   if (!Send(new GpuCommandBufferMsg_RegisterTransferBuffer(\n       route_id_,\n-      shared_memory->handle(),  // Returns FileDescriptor with auto_close off.\n+      handle,\n       size,\n       id_request,\n       &id))) {""}<_**next**_>{""sha"": ""cda0468e27eac788f2900a0bc7ccf6c9a926b0b5"", ""filename"": ""content/common/gpu/client/gpu_channel_host.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 8, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/client/gpu_channel_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/client/gpu_channel_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/client/gpu_channel_host.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -93,19 +93,18 @@ void GpuChannelHost::MessageFilter::OnChannelError() {\n }\n \n GpuChannelHost::GpuChannelHost(\n-    GpuChannelHostFactory* factory, int gpu_process_id, int client_id)\n+    GpuChannelHostFactory* factory, int gpu_host_id, int client_id)\n     : factory_(factory),\n-      gpu_process_id_(gpu_process_id),\n       client_id_(client_id),\n+      gpu_host_id_(gpu_host_id),\n       state_(kUnconnected) {\n }\n \n GpuChannelHost::~GpuChannelHost() {\n }\n \n void GpuChannelHost::Connect(\n-    const IPC::ChannelHandle& channel_handle,\n-    base::ProcessHandle client_process_for_gpu) {\n+    const IPC::ChannelHandle& channel_handle) {\n   DCHECK(factory_->IsMainThread());\n   // Open a channel to the GPU process. We pass NULL as the main listener here\n   // since we need to filter everything to route it to the right thread.\n@@ -130,10 +129,6 @@ void GpuChannelHost::Connect(\n   // and receives the hello message from the GPU process. The messages get\n   // cached.\n   state_ = kConnected;\n-\n-  // Notify the GPU process of our process handle. This gives it the ability\n-  // to map client handles into the GPU process.\n-  Send(new GpuChannelMsg_Initialize(client_process_for_gpu));\n }\n \n void GpuChannelHost::set_gpu_info(const content::GPUInfo& gpu_info) {""}<_**next**_>{""sha"": ""b82efe92764814d62fcb2606b088ce550a00a200"", ""filename"": ""content/common/gpu/client/gpu_channel_host.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 5, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/client/gpu_channel_host.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/client/gpu_channel_host.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/client/gpu_channel_host.h?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -13,6 +13,7 @@\n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/scoped_ptr.h\""\n #include \""base/memory/weak_ptr.h\""\n+#include \""base/process.h\""\n #include \""base/process_util.h\""\n #include \""base/synchronization/lock.h\""\n #include \""content/common/content_export.h\""\n@@ -83,13 +84,12 @@ class GpuChannelHost : public IPC::Message::Sender,\n \n   // Called on the render thread\n   GpuChannelHost(GpuChannelHostFactory* factory,\n-                 int gpu_process_id,\n+                 int gpu_host_id,\n                  int client_id);\n   virtual ~GpuChannelHost();\n \n   // Connect to GPU process channel.\n-  void Connect(const IPC::ChannelHandle& channel_handle,\n-               base::ProcessHandle client_process_for_gpu);\n+  void Connect(const IPC::ChannelHandle& channel_handle);\n \n   State state() const { return state_; }\n \n@@ -152,7 +152,8 @@ class GpuChannelHost : public IPC::Message::Sender,\n   void ForciblyCloseChannel();\n \n   GpuChannelHostFactory* factory() const { return factory_; }\n-  int gpu_process_id() const { return gpu_process_id_; }\n+  int gpu_host_id() const { return gpu_host_id_; }\n+  base::ProcessId gpu_pid() const { return channel_->peer_pid(); }\n   int client_id() const { return client_id_; }\n \n  private:\n@@ -180,8 +181,8 @@ class GpuChannelHost : public IPC::Message::Sender,\n   };\n \n   GpuChannelHostFactory* factory_;\n-  int gpu_process_id_;\n   int client_id_;\n+  int gpu_host_id_;\n \n   State state_;\n ""}<_**next**_>{""sha"": ""6fcce8a4014f5d56b32aeff0aa7a06136ec7d11c"", ""filename"": ""content/common/gpu/client/webgraphicscontext3d_command_buffer_impl.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/client/webgraphicscontext3d_command_buffer_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/client/webgraphicscontext3d_command_buffer_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/client/webgraphicscontext3d_command_buffer_impl.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -483,8 +483,9 @@ void WebGraphicsContext3DCommandBufferImpl::Destroy() {\n   host_ = NULL;\n }\n \n+// TODO(apatrick,piman): This should be renamed to something clearer.\n int WebGraphicsContext3DCommandBufferImpl::GetGPUProcessID() {\n-  return host_ ? host_->gpu_process_id() : 0;\n+  return host_ ? host_->gpu_host_id() : 0;\n }\n \n int WebGraphicsContext3DCommandBufferImpl::GetChannelID() {""}<_**next**_>{""sha"": ""96c3553010c5a84133af5f625ad8c03200a06799"", ""filename"": ""content/common/gpu/gpu_channel.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 20, ""changes"": 20, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/gpu_channel.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/gpu_channel.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/gpu_channel.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -40,8 +40,6 @@ GpuChannel::GpuChannel(GpuChannelManager* gpu_channel_manager,\n                        bool software)\n     : gpu_channel_manager_(gpu_channel_manager),\n       client_id_(client_id),\n-      renderer_process_(base::kNullProcessHandle),\n-      renderer_pid_(base::kNullProcessId),\n       share_group_(share_group ? share_group : new gfx::GLShareGroup),\n       watchdog_(watchdog),\n       software_(software),\n@@ -62,10 +60,6 @@ GpuChannel::GpuChannel(GpuChannelManager* gpu_channel_manager,\n }\n \n GpuChannel::~GpuChannel() {\n-#if defined(OS_WIN)\n-  if (renderer_process_)\n-    CloseHandle(renderer_process_);\n-#endif\n }\n \n bool GpuChannel::OnMessageReceived(const IPC::Message& message) {\n@@ -113,10 +107,6 @@ void GpuChannel::OnChannelError() {\n   gpu_channel_manager_->RemoveChannel(client_id_);\n }\n \n-void GpuChannel::OnChannelConnected(int32 peer_pid) {\n-  renderer_pid_ = peer_pid;\n-}\n-\n bool GpuChannel::Send(IPC::Message* message) {\n   // The GPU process must never send a synchronous IPC message to the renderer\n   // process. This could result in deadlock.\n@@ -211,7 +201,6 @@ bool GpuChannel::OnControlMessageReceived(const IPC::Message& msg) {\n   // here. This is so the reply can be delayed if the scheduler is unscheduled.\n   bool handled = true;\n   IPC_BEGIN_MESSAGE_MAP(GpuChannel, msg)\n-    IPC_MESSAGE_HANDLER(GpuChannelMsg_Initialize, OnInitialize)\n     IPC_MESSAGE_HANDLER_DELAY_REPLY(GpuChannelMsg_CreateOffscreenCommandBuffer,\n                                     OnCreateOffscreenCommandBuffer)\n     IPC_MESSAGE_HANDLER_DELAY_REPLY(GpuChannelMsg_DestroyCommandBuffer,\n@@ -312,15 +301,6 @@ bool GpuChannel::ShouldPreferDiscreteGpu() const {\n   return num_contexts_preferring_discrete_gpu_ > 0;\n }\n \n-void GpuChannel::OnInitialize(base::ProcessHandle renderer_process) {\n-  // Initialize should only happen once.\n-  DCHECK(!renderer_process_);\n-\n-  // Verify that the renderer has passed its own process handle.\n-  if (base::GetProcId(renderer_process) == renderer_pid_)\n-    renderer_process_ = renderer_process;\n-}\n-\n void GpuChannel::OnCreateOffscreenCommandBuffer(\n     const gfx::Size& size,\n     const GPUCreateCommandBufferConfig& init_params,""}<_**next**_>{""sha"": ""d9c51922c7153873401eef30fca646b20a5f98e5"", ""filename"": ""content/common/gpu/gpu_channel.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 11, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/gpu_channel.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/gpu_channel.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/gpu_channel.h?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -62,14 +62,11 @@ class GpuChannel : public IPC::Channel::Listener,\n   int TakeRendererFileDescriptor();\n #endif  // defined(OS_POSIX)\n \n-  base::ProcessHandle renderer_process() const {\n-    return renderer_process_;\n-  }\n+  base::ProcessId renderer_pid() const { return channel_->peer_pid(); }\n \n   // IPC::Channel::Listener implementation:\n   virtual bool OnMessageReceived(const IPC::Message& msg) OVERRIDE;\n   virtual void OnChannelError() OVERRIDE;\n-  virtual void OnChannelConnected(int32 peer_pid) OVERRIDE;\n \n   // IPC::Message::Sender implementation:\n   virtual bool Send(IPC::Message* msg) OVERRIDE;\n@@ -119,7 +116,6 @@ class GpuChannel : public IPC::Channel::Listener,\n   void ScheduleDelayedWork(GpuCommandBufferStub *stub, int64 delay);\n \n   // Message handlers.\n-  void OnInitialize(base::ProcessHandle renderer_process);\n   void OnCreateOffscreenCommandBuffer(\n       const gfx::Size& size,\n       const GPUCreateCommandBufferConfig& init_params,\n@@ -149,12 +145,6 @@ class GpuChannel : public IPC::Channel::Listener,\n   // Uniquely identifies the channel within this GPU process.\n   std::string channel_id_;\n \n-  // Handle to the renderer process that is on the other side of the channel.\n-  base::ProcessHandle renderer_process_;\n-\n-  // The process id of the renderer process.\n-  base::ProcessId renderer_pid_;\n-\n   // Used to implement message routing functionality to CommandBuffer objects\n   MessageRouter router_;\n ""}<_**next**_>{""sha"": ""1f22bce1c9c07493b816e428fe6956f16e9bd371"", ""filename"": ""content/common/gpu/gpu_command_buffer_stub.cc"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 19, ""changes"": 33, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/gpu_command_buffer_stub.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/gpu_command_buffer_stub.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/gpu_command_buffer_stub.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -23,6 +23,10 @@\n #include \""ui/gfx/gl/gl_bindings.h\""\n #include \""ui/gfx/gl/gl_switches.h\""\n \n+#if defined(OS_WIN)\n+#include \""content/common/sandbox_policy.h\""\n+#endif\n+\n GpuCommandBufferStub::SurfaceState::SurfaceState(int32 surface_id,\n                                                  bool visible,\n                                                  base::TimeTicks last_used_time)\n@@ -467,17 +471,7 @@ void GpuCommandBufferStub::OnRegisterTransferBuffer(\n     size_t size,\n     int32 id_request,\n     IPC::Message* reply_message) {\n-#if defined(OS_WIN)\n-  // Windows dups the shared memory handle it receives into the current process\n-  // and closes it when this variable goes out of scope.\n-  base::SharedMemory shared_memory(transfer_buffer,\n-                                   false,\n-                                   channel_->renderer_process());\n-#else\n-  // POSIX receives a dup of the shared memory handle and closes the dup when\n-  // this variable goes out of scope.\n   base::SharedMemory shared_memory(transfer_buffer, false);\n-#endif\n \n   if (command_buffer_.get()) {\n     int32 id = command_buffer_->RegisterTransferBuffer(&shared_memory,\n@@ -506,20 +500,22 @@ void GpuCommandBufferStub::OnDestroyTransferBuffer(\n void GpuCommandBufferStub::OnGetTransferBuffer(\n     int32 id,\n     IPC::Message* reply_message) {\n-  // Fail if the renderer process has not provided its process handle.\n-  if (!channel_->renderer_process())\n-    return;\n-\n   if (command_buffer_.get()) {\n     base::SharedMemoryHandle transfer_buffer = base::SharedMemoryHandle();\n     uint32 size = 0;\n \n     gpu::Buffer buffer = command_buffer_->GetTransferBuffer(id);\n     if (buffer.shared_memory) {\n-      // Assume service is responsible for duplicating the handle to the calling\n-      // process.\n-      buffer.shared_memory->ShareToProcess(channel_->renderer_process(),\n+#if defined(OS_WIN)\n+      transfer_buffer = NULL;\n+      sandbox::BrokerDuplicateHandle(buffer.shared_memory->handle(),\n+          channel_->renderer_pid(), &transfer_buffer, FILE_MAP_READ |\n+          FILE_MAP_WRITE, 0);\n+      CHECK(transfer_buffer != NULL);\n+#else\n+      buffer.shared_memory->ShareToProcess(channel_->renderer_pid(),\n                                            &transfer_buffer);\n+#endif\n       size = buffer.size;\n     }\n \n@@ -557,8 +553,7 @@ void GpuCommandBufferStub::OnCreateVideoDecoder(\n       new GpuVideoDecodeAccelerator(this, decoder_route_id, this);\n   video_decoders_.AddWithID(decoder, decoder_route_id);\n   channel_->AddRoute(decoder_route_id, decoder);\n-  decoder->Initialize(profile, reply_message,\n-                      channel_->renderer_process());\n+  decoder->Initialize(profile, reply_message);\n }\n \n void GpuCommandBufferStub::OnDestroyVideoDecoder(int decoder_route_id) {""}<_**next**_>{""sha"": ""d76491aa20e8179d37fd66e494bba6ba34026599"", ""filename"": ""content/common/gpu/gpu_messages.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 9, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/gpu_messages.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/gpu_messages.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/gpu_messages.h?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -216,11 +216,10 @@ IPC_MESSAGE_CONTROL0(GpuMsg_Hang)\n // A renderer sends this when it wants to create a connection to the GPU\n // process. The browser will create the GPU process if necessary, and will\n // return a handle to the channel via a GpuChannelEstablished message.\n-IPC_SYNC_MESSAGE_CONTROL1_4(GpuHostMsg_EstablishGpuChannel,\n+IPC_SYNC_MESSAGE_CONTROL1_3(GpuHostMsg_EstablishGpuChannel,\n                             content::CauseForGpuLaunch,\n                             int /* client id */,\n                             IPC::ChannelHandle /* handle to channel */,\n-                            base::ProcessHandle /* renderer_process_for_gpu */,\n                             content::GPUInfo /* stats about GPU process*/)\n \n // A renderer sends this to the browser process when it wants to\n@@ -292,13 +291,6 @@ IPC_MESSAGE_CONTROL1(GpuHostMsg_AcceleratedSurfaceSuspend,\n // GPU Channel Messages\n // These are messages from a renderer process to the GPU process.\n \n-// Initialize a channel between a renderer process and a GPU process. The\n-// renderer passes its process handle to the GPU process, which gives gives the\n-// GPU process the ability to map handles from the renderer process. This must\n-// be the first message sent on a newly connected channel.\n-IPC_MESSAGE_CONTROL1(GpuChannelMsg_Initialize,\n-                     base::ProcessHandle /* renderer_process_for_gpu */)\n-\n // Tells the GPU process to create a new command buffer that renders to an\n // offscreen frame buffer.\n IPC_SYNC_MESSAGE_CONTROL2_1(GpuChannelMsg_CreateOffscreenCommandBuffer,""}<_**next**_>{""sha"": ""05afbad9d9104fc41bfd35ab827930830eb2c2b0"", ""filename"": ""content/common/gpu/media/dxva_video_decode_accelerator.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 16, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/media/dxva_video_decode_accelerator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/media/dxva_video_decode_accelerator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/media/dxva_video_decode_accelerator.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -142,20 +142,9 @@ static IMFSample* CreateInputSample(const uint8* stream, int size,\n \n static IMFSample* CreateSampleFromInputBuffer(\n     const media::BitstreamBuffer& bitstream_buffer,\n-    base::ProcessHandle renderer_process,\n     DWORD stream_size,\n     DWORD alignment) {\n-  HANDLE shared_memory_handle = NULL;\n-  RETURN_ON_FAILURE(::DuplicateHandle(renderer_process,\n-                                      bitstream_buffer.handle(),\n-                                      base::GetCurrentProcessHandle(),\n-                                      &shared_memory_handle,\n-                                      0,\n-                                      FALSE,\n-                                      DUPLICATE_SAME_ACCESS),\n-                     \""Duplicate handle failed\"", NULL);\n-\n-  base::SharedMemory shm(shared_memory_handle, true);\n+  base::SharedMemory shm(bitstream_buffer.handle(), true);\n   RETURN_ON_FAILURE(shm.Map(bitstream_buffer.size()),\n                     \""Failed in base::SharedMemory::Map\"", NULL);\n \n@@ -505,13 +494,11 @@ bool DXVAVideoDecodeAccelerator::CreateD3DDevManager() {\n }\n \n DXVAVideoDecodeAccelerator::DXVAVideoDecodeAccelerator(\n-    media::VideoDecodeAccelerator::Client* client,\n-    base::ProcessHandle renderer_process)\n+    media::VideoDecodeAccelerator::Client* client)\n     : client_(client),\n       egl_config_(NULL),\n       state_(kUninitialized),\n       pictures_requested_(false),\n-      renderer_process_(renderer_process),\n       last_input_buffer_id_(-1),\n       inputs_before_decode_(0) {\n   memset(&input_stream_info_, 0, sizeof(input_stream_info_));\n@@ -560,7 +547,6 @@ void DXVAVideoDecodeAccelerator::Decode(\n \n   base::win::ScopedComPtr<IMFSample> sample;\n   sample.Attach(CreateSampleFromInputBuffer(bitstream_buffer,\n-                                            renderer_process_,\n                                             input_stream_info_.cbSize,\n                                             input_stream_info_.cbAlignment));\n   RETURN_AND_NOTIFY_ON_FAILURE(sample, \""Failed to create input sample\"",""}<_**next**_>{""sha"": ""876ea4ba0f42e62efd8d119c9032306f829608c2"", ""filename"": ""content/common/gpu/media/dxva_video_decode_accelerator.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 6, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/media/dxva_video_decode_accelerator.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/media/dxva_video_decode_accelerator.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/media/dxva_video_decode_accelerator.h?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -39,9 +39,8 @@ class CONTENT_EXPORT DXVAVideoDecodeAccelerator\n   };\n \n   // Does not take ownership of |client| which must outlive |*this|.\n-  DXVAVideoDecodeAccelerator(\n-      media::VideoDecodeAccelerator::Client* client,\n-      base::ProcessHandle renderer_process);\n+  explicit DXVAVideoDecodeAccelerator(\n+      media::VideoDecodeAccelerator::Client* client);\n   virtual ~DXVAVideoDecodeAccelerator();\n \n   // media::VideoDecodeAccelerator implementation.\n@@ -187,9 +186,6 @@ class CONTENT_EXPORT DXVAVideoDecodeAccelerator\n   // Contains the id of the last input buffer received from the client.\n   int32 last_input_buffer_id_;\n \n-  // Handle to the renderer process.\n-  base::ProcessHandle renderer_process_;\n-\n   // Ideally the reset token would be a stack variable which is used while\n   // creating the device manager. However it seems that the device manager\n   // holds onto the token and attempts to access it if the underlying device""}<_**next**_>{""sha"": ""0ef9d87a67eb3822d57712703c96e60fac187b2c"", ""filename"": ""content/common/gpu/media/gpu_video_decode_accelerator.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/media/gpu_video_decode_accelerator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/media/gpu_video_decode_accelerator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/media/gpu_video_decode_accelerator.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -116,8 +116,7 @@ void GpuVideoDecodeAccelerator::NotifyError(\n \n void GpuVideoDecodeAccelerator::Initialize(\n     const media::VideoCodecProfile profile,\n-    IPC::Message* init_done_msg,\n-    base::ProcessHandle renderer_process) {\n+    IPC::Message* init_done_msg) {\n   DCHECK(!video_decode_accelerator_.get());\n   DCHECK(!init_done_msg_);\n   DCHECK(init_done_msg);\n@@ -133,7 +132,7 @@ void GpuVideoDecodeAccelerator::Initialize(\n   }\n   DLOG(INFO) << \""Initializing DXVA HW decoder for windows.\"";\n   DXVAVideoDecodeAccelerator* video_decoder =\n-      new DXVAVideoDecodeAccelerator(this, renderer_process);\n+      new DXVAVideoDecodeAccelerator(this);\n #else  // OS_WIN\n   OmxVideoDecodeAccelerator* video_decoder =\n       new OmxVideoDecodeAccelerator(this);""}<_**next**_>{""sha"": ""2d2e559f5f2ccd54ea7c3e8883205739eaa20c4f"", ""filename"": ""content/common/gpu/media/gpu_video_decode_accelerator.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/media/gpu_video_decode_accelerator.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/media/gpu_video_decode_accelerator.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/media/gpu_video_decode_accelerator.h?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -47,8 +47,7 @@ class GpuVideoDecodeAccelerator\n   // The renderer process handle is valid as long as we have a channel between\n   // GPU process and the renderer.\n   void Initialize(const media::VideoCodecProfile profile,\n-                  IPC::Message* init_done_msg,\n-                  base::ProcessHandle renderer_process);\n+                  IPC::Message* init_done_msg);\n \n  private:\n ""}<_**next**_>{""sha"": ""9dc6325e748116fc70803915b4ce94a352574233"", ""filename"": ""content/common/gpu/media/video_decode_accelerator_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/media/video_decode_accelerator_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/gpu/media/video_decode_accelerator_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/media/video_decode_accelerator_unittest.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -655,7 +655,7 @@ void EglRenderingVDAClient::CreateDecoder() {\n   CHECK(decoder_deleted());\n #if defined(OS_WIN)\n   scoped_refptr<DXVAVideoDecodeAccelerator> decoder =\n-      new DXVAVideoDecodeAccelerator(this, base::GetCurrentProcessHandle());\n+      new DXVAVideoDecodeAccelerator(this);\n #else  // OS_WIN\n   scoped_refptr<OmxVideoDecodeAccelerator> decoder =\n       new OmxVideoDecodeAccelerator(this);""}<_**next**_>{""sha"": ""8bacac3abd06ef8ee88331ab05fa44448963af25"", ""filename"": ""content/common/np_channel_base.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/np_channel_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/np_channel_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/np_channel_base.h?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -12,6 +12,7 @@\n #include \""base/hash_tables.h\""\n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/scoped_ptr.h\""\n+#include \""base/process.h\""\n #include \""content/common/message_router.h\""\n #include \""content/common/npobject_base.h\""\n #include \""ipc/ipc_channel_handle.h\""\n@@ -75,7 +76,7 @@ class NPChannelBase : public IPC::Channel::Listener,\n   // IPC::Message::Sender implementation:\n   virtual bool Send(IPC::Message* msg) OVERRIDE;\n \n-  int peer_pid() { return peer_pid_; }\n+  base::ProcessId peer_pid() { return channel_->peer_pid(); }\n   IPC::ChannelHandle channel_handle() const { return channel_handle_; }\n \n   // Returns the number of open NPObject channels in this process.""}<_**next**_>{""sha"": ""dc07070154137b9fb34971eb0b9c455079c58776"", ""filename"": ""content/common/sandbox_policy.cc"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 24, ""changes"": 64, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/sandbox_policy.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/common/sandbox_policy.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/sandbox_policy.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -374,21 +374,33 @@ bool AddPolicyForGPU(CommandLine* cmd_line, sandbox::TargetPolicy* policy) {\n   if (result != sandbox::SBOX_ALL_OK)\n     return false;\n \n+  // GPU needs to copy sections to renderers.\n+  result = policy->AddRule(sandbox::TargetPolicy::SUBSYS_HANDLES,\n+                           sandbox::TargetPolicy::HANDLES_DUP_ANY,\n+                           L\""Section\"");\n+  if (result != sandbox::SBOX_ALL_OK)\n+    return false;\n+\n   AddGenericDllEvictionPolicy(policy);\n #endif\n   return true;\n }\n \n bool AddPolicyForRenderer(sandbox::TargetPolicy* policy) {\n-  // Renderers need to copy sections for plugin DIBs.\n+  // Renderers need to copy sections for plugin DIBs and GPU.\n   sandbox::ResultCode result;\n   result = policy->AddRule(sandbox::TargetPolicy::SUBSYS_HANDLES,\n                            sandbox::TargetPolicy::HANDLES_DUP_ANY,\n                            L\""Section\"");\n-  if (result != sandbox::SBOX_ALL_OK) {\n-    NOTREACHED();\n+  if (result != sandbox::SBOX_ALL_OK)\n+    return false;\n+\n+  // Renderers need to share events with plugins.\n+  result = policy->AddRule(sandbox::TargetPolicy::SUBSYS_HANDLES,\n+                           sandbox::TargetPolicy::HANDLES_DUP_ANY,\n+                           L\""Event\"");\n+  if (result != sandbox::SBOX_ALL_OK)\n     return false;\n-  }\n \n   policy->SetJobLevel(sandbox::JOB_LOCKDOWN, 0);\n \n@@ -451,30 +463,33 @@ bool BrokerDuplicateHandle(HANDLE source_handle,\n                            HANDLE* target_handle,\n                            DWORD desired_access,\n                            DWORD options) {\n-  // Just use DuplicateHandle() if we aren't in the sandbox.\n-  if (!g_target_services) {\n-    base::win::ScopedHandle target_process(::OpenProcess(PROCESS_DUP_HANDLE,\n-                                                         FALSE,\n-                                                         target_process_id));\n-    if (!target_process.IsValid())\n-      return false;\n-\n-    if (!::DuplicateHandle(::GetCurrentProcess(), source_handle,\n-                           target_process, target_handle,\n-                           desired_access, FALSE,\n-                           options)) {\n-      return false;\n-    }\n+  // If our process is the target just duplicate the handle.\n+  if (::GetCurrentProcessId() == target_process_id) {\n+    return !!::DuplicateHandle(::GetCurrentProcess(), source_handle,\n+                               ::GetCurrentProcess(), target_handle,\n+                               desired_access, FALSE, options);\n \n+  }\n+\n+  // Try the broker next\n+  if (g_target_services &&\n+      g_target_services->DuplicateHandle(source_handle, target_process_id,\n+                                         target_handle, desired_access,\n+                                         options) == SBOX_ALL_OK) {\n     return true;\n   }\n \n-  ResultCode result = g_target_services->DuplicateHandle(source_handle,\n-                                                         target_process_id,\n-                                                         target_handle,\n-                                                         desired_access,\n-                                                         options);\n-  return SBOX_ALL_OK == result;\n+  // Finally, see if we already have access to the process.\n+  base::win::ScopedHandle target_process;\n+  target_process.Set(::OpenProcess(PROCESS_DUP_HANDLE, FALSE,\n+                                    target_process_id));\n+  if (target_process.IsValid()) {\n+    return !!::DuplicateHandle(::GetCurrentProcess(), source_handle,\n+                                target_process, target_handle,\n+                                desired_access, FALSE, options);\n+  }\n+\n+  return false;\n }\n \n \n@@ -573,6 +588,7 @@ base::ProcessHandle StartProcessWithAccess(CommandLine* cmd_line,\n     policy->Release();\n     base::ProcessHandle process = 0;\n     base::LaunchProcess(*cmd_line, base::LaunchOptions(), &process);\n+    g_broker_services->AddTargetPeer(process);\n     return process;\n   }\n ""}<_**next**_>{""sha"": ""3f544dae39402c557969e747ea6328166ef4396e"", ""filename"": ""content/plugin/plugin_channel.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 16, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/plugin/plugin_channel.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/plugin/plugin_channel.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/plugin/plugin_channel.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -161,8 +161,7 @@ void PluginChannel::NotifyRenderersOfPendingShutdown() {\n }\n \n PluginChannel::PluginChannel()\n-    : renderer_handle_(0),\n-      renderer_id_(-1),\n+    : renderer_id_(-1),\n       in_send_(0),\n       incognito_(false),\n       filter_(new MessageFilter()) {\n@@ -173,9 +172,6 @@ PluginChannel::PluginChannel()\n }\n \n PluginChannel::~PluginChannel() {\n-  if (renderer_handle_)\n-    base::CloseProcessHandle(renderer_handle_);\n-\n   MessageLoop::current()->PostDelayedTask(\n       FROM_HERE,\n       base::Bind(&PluginReleaseCallback),\n@@ -285,18 +281,7 @@ base::WaitableEvent* PluginChannel::GetModalDialogEvent(\n   return filter_->GetModalDialogEvent(containing_window);\n }\n \n-void PluginChannel::OnChannelConnected(int32 peer_pid) {\n-  base::ProcessHandle handle;\n-  if (!base::OpenProcessHandle(peer_pid, &handle)) {\n-    NOTREACHED();\n-  }\n-  renderer_handle_ = handle;\n-  NPChannelBase::OnChannelConnected(peer_pid);\n-}\n-\n void PluginChannel::OnChannelError() {\n-  base::CloseProcessHandle(renderer_handle_);\n-  renderer_handle_ = 0;\n   NPChannelBase::OnChannelError();\n   CleanUp();\n }""}<_**next**_>{""sha"": ""7be4d91165ecec51a97c164e2b91594c028c3f70"", ""filename"": ""content/plugin/plugin_channel.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 6, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/plugin/plugin_channel.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/plugin/plugin_channel.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/plugin/plugin_channel.h?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -1,4 +1,4 @@\n-// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n@@ -36,7 +36,6 @@ class PluginChannel : public NPChannelBase {\n   virtual bool Send(IPC::Message* msg) OVERRIDE;\n   virtual bool OnMessageReceived(const IPC::Message& message) OVERRIDE;\n \n-  base::ProcessHandle renderer_handle() const { return renderer_handle_; }\n   int renderer_id() { return renderer_id_; }\n \n   virtual int GenerateRouteID() OVERRIDE;\n@@ -59,7 +58,6 @@ class PluginChannel : public NPChannelBase {\n \n  protected:\n   // IPC::Channel::Listener implementation:\n-  virtual void OnChannelConnected(int32 peer_pid) OVERRIDE;\n   virtual void OnChannelError() OVERRIDE;\n \n   virtual void CleanUp() OVERRIDE;\n@@ -88,9 +86,6 @@ class PluginChannel : public NPChannelBase {\n \n   std::vector<scoped_refptr<WebPluginDelegateStub> > plugin_stubs_;\n \n-  // Handle to the renderer process who is on the other side of the channel.\n-  base::ProcessHandle renderer_handle_;\n-\n   // The id of the renderer who is on the other side of the channel.\n   int renderer_id_;\n ""}<_**next**_>{""sha"": ""704058db933893a2e7cb4d5ba2687f3e9fca041c"", ""filename"": ""content/plugin/webplugin_proxy.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 14, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/plugin/webplugin_proxy.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/plugin/webplugin_proxy.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/plugin/webplugin_proxy.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -35,6 +35,10 @@\n #include \""ui/base/x/x11_util_internal.h\""\n #endif\n \n+#if defined(OS_WIN)\n+#include \""content/common/sandbox_policy.h\""\n+#endif\n+\n using WebKit::WebBindings;\n \n using webkit::npapi::WebPluginResourceClient;\n@@ -129,10 +133,9 @@ void WebPluginProxy::WillDestroyWindow(gfx::PluginWindowHandle window) {\n #if defined(OS_WIN)\n void WebPluginProxy::SetWindowlessPumpEvent(HANDLE pump_messages_event) {\n   HANDLE pump_messages_event_for_renderer = NULL;\n-  DuplicateHandle(GetCurrentProcess(), pump_messages_event,\n-                  channel_->renderer_handle(),\n-                  &pump_messages_event_for_renderer,\n-                  0, FALSE, DUPLICATE_SAME_ACCESS);\n+  sandbox::BrokerDuplicateHandle(pump_messages_event, channel_->peer_pid(),\n+                                 &pump_messages_event_for_renderer,\n+                                 SYNCHRONIZE | EVENT_MODIFY_STATE, 0);\n   DCHECK(pump_messages_event_for_renderer != NULL);\n   Send(new PluginHostMsg_SetWindowlessPumpEvent(\n       route_id_, pump_messages_event_for_renderer));\n@@ -470,25 +473,17 @@ void WebPluginProxy::CreateCanvasFromHandle(\n     const TransportDIB::Handle& dib_handle,\n     const gfx::Rect& window_rect,\n     scoped_ptr<skia::PlatformCanvas>* canvas_out) {\n-  // Create a canvas that will reference the shared bits. We have to handle\n-  // errors here since we're mapping a large amount of memory that may not fit\n-  // in our address space, or go wrong in some other way.\n-  HANDLE section;\n-  DuplicateHandle(channel_->renderer_handle(), dib_handle, GetCurrentProcess(),\n-                  &section,\n-                  STANDARD_RIGHTS_REQUIRED | FILE_MAP_READ | FILE_MAP_WRITE,\n-                  FALSE, 0);\n   scoped_ptr<skia::PlatformCanvas> canvas(new skia::PlatformCanvas);\n   if (!canvas->initialize(\n           window_rect.width(),\n           window_rect.height(),\n           true,\n-          section)) {\n+          dib_handle)) {\n     canvas_out->reset();\n   }\n   canvas_out->reset(canvas.release());\n   // The canvas does not own the section so we need to close it now.\n-  CloseHandle(section);\n+  CloseHandle(dib_handle);\n }\n \n void WebPluginProxy::SetWindowlessBuffers(""}<_**next**_>{""sha"": ""41132b061b897becdb0d16416f9e7696cdee0245"", ""filename"": ""content/renderer/render_thread_impl.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 5, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/renderer/render_thread_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/renderer/render_thread_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_thread_impl.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -910,18 +910,15 @@ GpuChannelHost* RenderThreadImpl::EstablishGpuChannelSync(\n   // Ask the browser for the channel name.\n   int client_id = 0;\n   IPC::ChannelHandle channel_handle;\n-  base::ProcessHandle renderer_process_for_gpu;\n   content::GPUInfo gpu_info;\n   if (!Send(new GpuHostMsg_EstablishGpuChannel(cause_for_gpu_launch,\n                                                &client_id,\n                                                &channel_handle,\n-                                               &renderer_process_for_gpu,\n                                                &gpu_info)) ||\n-      channel_handle.name.empty() ||\n #if defined(OS_POSIX)\n       channel_handle.socket.fd == -1 ||\n #endif\n-      renderer_process_for_gpu == base::kNullProcessHandle) {\n+      channel_handle.name.empty()) {\n     // Otherwise cancel the connection.\n     gpu_channel_ = NULL;\n     return NULL;\n@@ -932,7 +929,7 @@ GpuChannelHost* RenderThreadImpl::EstablishGpuChannelSync(\n   content::GetContentClient()->SetGpuInfo(gpu_info);\n \n   // Connect to the GPU process if a channel name was received.\n-  gpu_channel_->Connect(channel_handle, renderer_process_for_gpu);\n+  gpu_channel_->Connect(channel_handle);\n \n   return GetGpuChannel();\n }""}<_**next**_>{""sha"": ""b6ff54348395933d82a9b88cf1e7e5cbd2e50f52"", ""filename"": ""content/renderer/webplugin_delegate_proxy.cc"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 4, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/renderer/webplugin_delegate_proxy.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/cd0bd79d6ebdb72183e6f0833673464cc10b3600/content/renderer/webplugin_delegate_proxy.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/webplugin_delegate_proxy.cc?ref=cd0bd79d6ebdb72183e6f0833673464cc10b3600"", ""patch"": ""@@ -18,6 +18,7 @@\n #include \""base/logging.h\""\n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/scoped_ptr.h\""\n+#include \""base/process.h\""\n #include \""base/string_split.h\""\n #include \""base/string_util.h\""\n #include \""base/utf_string_conversions.h\""\n@@ -60,6 +61,10 @@\n #include \""base/mac/mac_util.h\""\n #endif\n \n+#if defined(OS_WIN)\n+#include \""content/common/sandbox_policy.h\""\n+#endif\n+\n using WebKit::WebBindings;\n using WebKit::WebCursorInfo;\n using WebKit::WebDragData;\n@@ -484,7 +489,8 @@ void WebPluginDelegateProxy::OnChannelError() {\n \n static void CopyTransportDIBHandleForMessage(\n     const TransportDIB::Handle& handle_in,\n-    TransportDIB::Handle* handle_out) {\n+    TransportDIB::Handle* handle_out,\n+    base::ProcessId peer_pid) {\n #if defined(OS_MACOSX)\n   // On Mac, TransportDIB::Handle is typedef'ed to FileDescriptor, and\n   // FileDescriptor message fields needs to remain valid until the message is\n@@ -494,6 +500,12 @@ static void CopyTransportDIBHandleForMessage(\n     return;\n   }\n   handle_out->auto_close = true;\n+#elif defined(OS_WIN)\n+  // On Windows we need to duplicate the handle for the plugin process.\n+  *handle_out = NULL;\n+  sandbox::BrokerDuplicateHandle(handle_in, peer_pid, handle_out,\n+                                 FILE_MAP_READ | FILE_MAP_WRITE, 0);\n+  CHECK(*handle_out != NULL);\n #else\n   // Don't need to do anything special for other platforms.\n   *handle_out = handle_in;\n@@ -520,15 +532,18 @@ void WebPluginDelegateProxy::SendUpdateGeometry(\n   {\n     if (transport_stores_[0].dib.get())\n       CopyTransportDIBHandleForMessage(transport_stores_[0].dib->handle(),\n-                                       &param.windowless_buffer0);\n+                                       &param.windowless_buffer0,\n+                                       channel_host_->peer_pid());\n \n     if (transport_stores_[1].dib.get())\n       CopyTransportDIBHandleForMessage(transport_stores_[1].dib->handle(),\n-                                       &param.windowless_buffer1);\n+                                       &param.windowless_buffer1,\n+                                       channel_host_->peer_pid());\n \n     if (background_store_.dib.get())\n       CopyTransportDIBHandleForMessage(background_store_.dib->handle(),\n-                                       &param.background_buffer);\n+                                       &param.background_buffer,\n+                                       channel_host_->peer_pid());\n   }\n \n   IPC::Message* msg;""}","  base::ProcessHandle renderer_process_for_gpu;/~/                                               &renderer_process_for_gpu,/~/      channel_handle.name.empty() ||/~/      renderer_process_for_gpu == base::kNullProcessHandle) {/~/  gpu_channel_->Connect(channel_handle, renderer_process_for_gpu);","16,21,23,27,38","GpuChannelHost* RenderThreadImpl::EstablishGpuChannelSync(
    content::CauseForGpuLaunch cause_for_gpu_launch) {
  if (gpu_channel_.get()) {
    if (gpu_channel_->state() == GpuChannelHost::kUnconnected ||
        gpu_channel_->state() == GpuChannelHost::kConnected)
      return GetGpuChannel();

    gpu_channel_ = NULL;
  }

   int client_id = 0;
   IPC::ChannelHandle channel_handle;
   content::GPUInfo gpu_info;
   if (!Send(new GpuHostMsg_EstablishGpuChannel(cause_for_gpu_launch,
                                                &client_id,
                                                &channel_handle,
                                                &gpu_info)) ||
 #if defined(OS_POSIX)
       channel_handle.socket.fd == -1 ||
 #endif
      channel_handle.name.empty()) {
     gpu_channel_ = NULL;
     return NULL;
  }

  gpu_channel_ = new GpuChannelHost(this, 0, client_id);
  gpu_channel_->set_gpu_info(gpu_info);
   content::GetContentClient()->SetGpuInfo(gpu_info);
 
  gpu_channel_->Connect(channel_handle);
 
   return GetGpuChannel();
 }
","GpuChannelHost* RenderThreadImpl::EstablishGpuChannelSync(
    content::CauseForGpuLaunch cause_for_gpu_launch) {
  if (gpu_channel_.get()) {
    if (gpu_channel_->state() == GpuChannelHost::kUnconnected ||
        gpu_channel_->state() == GpuChannelHost::kConnected)
      return GetGpuChannel();

    gpu_channel_ = NULL;
  }

   int client_id = 0;
   IPC::ChannelHandle channel_handle;
  base::ProcessHandle renderer_process_for_gpu;
   content::GPUInfo gpu_info;
   if (!Send(new GpuHostMsg_EstablishGpuChannel(cause_for_gpu_launch,
                                                &client_id,
                                                &channel_handle,
                                               &renderer_process_for_gpu,
                                                &gpu_info)) ||
      channel_handle.name.empty() ||
 #if defined(OS_POSIX)
       channel_handle.socket.fd == -1 ||
 #endif
      renderer_process_for_gpu == base::kNullProcessHandle) {
     gpu_channel_ = NULL;
     return NULL;
  }

  gpu_channel_ = new GpuChannelHost(this, 0, client_id);
  gpu_channel_->set_gpu_info(gpu_info);
   content::GetContentClient()->SetGpuInfo(gpu_info);
 
  gpu_channel_->Connect(channel_handle, renderer_process_for_gpu);
 
   return GetGpuChannel();
 }
",184581.0,C,"      channel_handle.name.empty()) {
  gpu_channel_->Connect(channel_handle);
","  base::ProcessHandle renderer_process_for_gpu;
                                               &renderer_process_for_gpu,
      channel_handle.name.empty() ||
      renderer_process_for_gpu == base::kNullProcessHandle) {
  gpu_channel_->Connect(channel_handle, renderer_process_for_gpu);
",,"@@ -910,18 +910,15 @@ GpuChannelHost* RenderThreadImpl::EstablishGpuChannelSync(
   // Ask the browser for the channel name.
   int client_id = 0;
   IPC::ChannelHandle channel_handle;
-  base::ProcessHandle renderer_process_for_gpu;
   content::GPUInfo gpu_info;
   if (!Send(new GpuHostMsg_EstablishGpuChannel(cause_for_gpu_launch,
                                                &client_id,
                                                &channel_handle,
-                                               &renderer_process_for_gpu,
                                                &gpu_info)) ||
-      channel_handle.name.empty() ||
 #if defined(OS_POSIX)
       channel_handle.socket.fd == -1 ||
 #endif
-      renderer_process_for_gpu == base::kNullProcessHandle) {
+      channel_handle.name.empty()) {
     // Otherwise cancel the connection.
     gpu_channel_ = NULL;
     return NULL;
@@ -932,7 +929,7 @@ GpuChannelHost* RenderThreadImpl::EstablishGpuChannelSync(
   content::GetContentClient()->SetGpuInfo(gpu_info);
 
   // Connect to the GPU process if a channel name was received.
-  gpu_channel_->Connect(channel_handle, renderer_process_for_gpu);
+  gpu_channel_->Connect(channel_handle);
 
   return GetGpuChannel();
 }","GpuChannelHost* RenderThreadImpl::EstablishGpuChannelSync(
content::CauseForGpuLaunch cause_for_gpu_launch) {
if (gpu_channel_.get()) {
// Do nothing if we already have a GPU channel or are already
// establishing one.
if (gpu_channel_->state() == GpuChannelHost::kUnconnected ||
gpu_channel_->state() == GpuChannelHost::kConnected)
return GetGpuChannel();

// Recreate the channel if it has been lost.
gpu_channel_ = NULL;
}

// Ask the browser for the channel name.
int client_id = 0;
IPC::ChannelHandle channel_handle;
  base::ProcessHandle renderer_process_for_gpu;
content::GPUInfo gpu_info;
if (!Send(new GpuHostMsg_EstablishGpuChannel(cause_for_gpu_launch,
&client_id,
&channel_handle,
                                               &renderer_process_for_gpu,
&gpu_info)) ||
      channel_handle.name.empty() ||
#if defined(OS_POSIX)
channel_handle.socket.fd == -1 ||
#endif
      renderer_process_for_gpu == base::kNullProcessHandle) {
// Otherwise cancel the connection.
gpu_channel_ = NULL;
return NULL;
}

gpu_channel_ = new GpuChannelHost(this, 0, client_id);
gpu_channel_->set_gpu_info(gpu_info);
content::GetContentClient()->SetGpuInfo(gpu_info);

// Connect to the GPU process if a channel name was received.
  gpu_channel_->Connect(channel_handle, renderer_process_for_gpu);

return GetGpuChannel();
}
",Chrome,cd0bd79d6ebdb72183e6f0833673464cc10b3600,612c5b8df2f2a72126c88765dc00ac876a2aa6ff,1.0,"GpuChannelHost* RenderThreadImpl::EstablishGpuChannelSync(
    content::CauseForGpuLaunch cause_for_gpu_launch) {
  if (gpu_channel_.get()) {
    // Do nothing if we already have a GPU channel or are already
    // establishing one.
    if (gpu_channel_->state() == GpuChannelHost::kUnconnected ||
        gpu_channel_->state() == GpuChannelHost::kConnected)
      return GetGpuChannel();

    // Recreate the channel if it has been lost.
    gpu_channel_ = NULL;
  }

   // Ask the browser for the channel name.
   int client_id = 0;
   IPC::ChannelHandle channel_handle;
//flaw_line_below:
  base::ProcessHandle renderer_process_for_gpu;
   content::GPUInfo gpu_info;
   if (!Send(new GpuHostMsg_EstablishGpuChannel(cause_for_gpu_launch,
                                                &client_id,
                                                &channel_handle,
//flaw_line_below:
                                               &renderer_process_for_gpu,
                                                &gpu_info)) ||
//flaw_line_below:
      channel_handle.name.empty() ||
 #if defined(OS_POSIX)
       channel_handle.socket.fd == -1 ||
 #endif
//flaw_line_below:
      renderer_process_for_gpu == base::kNullProcessHandle) {
//fix_flaw_line_below:
//      channel_handle.name.empty()) {
     // Otherwise cancel the connection.
     gpu_channel_ = NULL;
     return NULL;
  }

  gpu_channel_ = new GpuChannelHost(this, 0, client_id);
  gpu_channel_->set_gpu_info(gpu_info);
   content::GetContentClient()->SetGpuInfo(gpu_info);
 
   // Connect to the GPU process if a channel name was received.
//flaw_line_below:
  gpu_channel_->Connect(channel_handle, renderer_process_for_gpu);
//fix_flaw_line_below:
//  gpu_channel_->Connect(channel_handle);
 
   return GetGpuChannel();
 }
"
970,None,Local,Not required,Complete,CVE-2017-6346,https://www.cvedetails.com/cve/CVE-2017-6346/,CWE-416,Medium,Complete,Complete,,2017-03-01,6.9,Race condition in net/packet/af_packet.c in the Linux kernel before 4.9.13 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a multithreaded application that makes PACKET_FANOUT setsockopt system calls.,2017-11-03,DoS ,18.0,https://github.com/torvalds/linux/commit/d199fab63c11998a602205f7ee7ff7c05c97164b,d199fab63c11998a602205f7ee7ff7c05c97164b,"packet: fix races in fanout_add()

Multiple threads can call fanout_add() at the same time.

We need to grab fanout_mutex earlier to avoid races that could
lead to one thread freeing po->rollover that was set by another thread.

Do the same in fanout_release(), for peace of mind, and to help us
finding lockdep issues earlier.

Fixes: dc99f600698d (""packet: Add fanout support."")
Fixes: 0648ab70afe6 (""packet: rollover prepare: per-socket state"")
Signed-off-by: Eric Dumazet <edumazet@google.com>
Cc: Willem de Bruijn <willemb@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",12.0,net/packet/af_packet.c,"{""sha"": ""0f03f6a53b4ddb8093a2122914200c0738af8fb3"", ""filename"": ""net/packet/af_packet.c"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 25, ""changes"": 55, ""blob_url"": ""https://github.com/torvalds/linux/blob/d199fab63c11998a602205f7ee7ff7c05c97164b/net/packet/af_packet.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d199fab63c11998a602205f7ee7ff7c05c97164b/net/packet/af_packet.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/packet/af_packet.c?ref=d199fab63c11998a602205f7ee7ff7c05c97164b"", ""patch"": ""@@ -1619,6 +1619,7 @@ static void fanout_release_data(struct packet_fanout *f)\n \n static int fanout_add(struct sock *sk, u16 id, u16 type_flags)\n {\n+\tstruct packet_rollover *rollover = NULL;\n \tstruct packet_sock *po = pkt_sk(sk);\n \tstruct packet_fanout *f, *match;\n \tu8 type = type_flags & 0xff;\n@@ -1641,23 +1642,28 @@ static int fanout_add(struct sock *sk, u16 id, u16 type_flags)\n \t\treturn -EINVAL;\n \t}\n \n+\tmutex_lock(&fanout_mutex);\n+\n+\terr = -EINVAL;\n \tif (!po->running)\n-\t\treturn -EINVAL;\n+\t\tgoto out;\n \n+\terr = -EALREADY;\n \tif (po->fanout)\n-\t\treturn -EALREADY;\n+\t\tgoto out;\n \n \tif (type == PACKET_FANOUT_ROLLOVER ||\n \t    (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {\n-\t\tpo->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);\n-\t\tif (!po->rollover)\n-\t\t\treturn -ENOMEM;\n-\t\tatomic_long_set(&po->rollover->num, 0);\n-\t\tatomic_long_set(&po->rollover->num_huge, 0);\n-\t\tatomic_long_set(&po->rollover->num_failed, 0);\n+\t\terr = -ENOMEM;\n+\t\trollover = kzalloc(sizeof(*rollover), GFP_KERNEL);\n+\t\tif (!rollover)\n+\t\t\tgoto out;\n+\t\tatomic_long_set(&rollover->num, 0);\n+\t\tatomic_long_set(&rollover->num_huge, 0);\n+\t\tatomic_long_set(&rollover->num_failed, 0);\n+\t\tpo->rollover = rollover;\n \t}\n \n-\tmutex_lock(&fanout_mutex);\n \tmatch = NULL;\n \tlist_for_each_entry(f, &fanout_list, list) {\n \t\tif (f->id == id &&\n@@ -1704,11 +1710,11 @@ static int fanout_add(struct sock *sk, u16 id, u16 type_flags)\n \t\t}\n \t}\n out:\n-\tmutex_unlock(&fanout_mutex);\n-\tif (err) {\n-\t\tkfree(po->rollover);\n+\tif (err && rollover) {\n+\t\tkfree(rollover);\n \t\tpo->rollover = NULL;\n \t}\n+\tmutex_unlock(&fanout_mutex);\n \treturn err;\n }\n \n@@ -1717,23 +1723,22 @@ static void fanout_release(struct sock *sk)\n \tstruct packet_sock *po = pkt_sk(sk);\n \tstruct packet_fanout *f;\n \n-\tf = po->fanout;\n-\tif (!f)\n-\t\treturn;\n-\n \tmutex_lock(&fanout_mutex);\n-\tpo->fanout = NULL;\n+\tf = po->fanout;\n+\tif (f) {\n+\t\tpo->fanout = NULL;\n+\n+\t\tif (atomic_dec_and_test(&f->sk_ref)) {\n+\t\t\tlist_del(&f->list);\n+\t\t\tdev_remove_pack(&f->prot_hook);\n+\t\t\tfanout_release_data(f);\n+\t\t\tkfree(f);\n+\t\t}\n \n-\tif (atomic_dec_and_test(&f->sk_ref)) {\n-\t\tlist_del(&f->list);\n-\t\tdev_remove_pack(&f->prot_hook);\n-\t\tfanout_release_data(f);\n-\t\tkfree(f);\n+\t\tif (po->rollover)\n+\t\t\tkfree_rcu(po->rollover, rcu);\n \t}\n \tmutex_unlock(&fanout_mutex);\n-\n-\tif (po->rollover)\n-\t\tkfree_rcu(po->rollover, rcu);\n }\n \n static bool packet_extra_vlan_len_allowed(const struct net_device *dev,""}","		return -EINVAL;/~/		return -EALREADY;/~/		po->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);/~/		if (!po->rollover)/~/			return -ENOMEM;/~/		atomic_long_set(&po->rollover->num, 0);/~/		atomic_long_set(&po->rollover->num_huge, 0);/~/		atomic_long_set(&po->rollover->num_failed, 0);/~/	mutex_lock(&fanout_mutex);/~/	mutex_unlock(&fanout_mutex);/~/	if (err) {/~/		kfree(po->rollover);","25,28,32,33,34,35,36,37,40,87,88,89"," static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 {
	struct packet_rollover *rollover = NULL;
 	struct packet_sock *po = pkt_sk(sk);
 	struct packet_fanout *f, *match;
 	u8 type = type_flags & 0xff;
	u8 flags = type_flags >> 8;
	int err;

	switch (type) {
	case PACKET_FANOUT_ROLLOVER:
		if (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)
			return -EINVAL;
	case PACKET_FANOUT_HASH:
	case PACKET_FANOUT_LB:
	case PACKET_FANOUT_CPU:
	case PACKET_FANOUT_RND:
	case PACKET_FANOUT_QM:
	case PACKET_FANOUT_CBPF:
	case PACKET_FANOUT_EBPF:
		break;
	default:
 		return -EINVAL;
 	}
 
	mutex_lock(&fanout_mutex);

	err = -EINVAL;
 	if (!po->running)
		goto out;
 
	err = -EALREADY;
 	if (po->fanout)
		goto out;
 
 	if (type == PACKET_FANOUT_ROLLOVER ||
 	    (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {
		err = -ENOMEM;
		rollover = kzalloc(sizeof(*rollover), GFP_KERNEL);
		if (!rollover)
			goto out;
		atomic_long_set(&rollover->num, 0);
		atomic_long_set(&rollover->num_huge, 0);
		atomic_long_set(&rollover->num_failed, 0);
		po->rollover = rollover;
 	}
 
 	match = NULL;
 	list_for_each_entry(f, &fanout_list, list) {
 		if (f->id == id &&
		    read_pnet(&f->net) == sock_net(sk)) {
			match = f;
			break;
		}
	}
	err = -EINVAL;
	if (match && match->flags != flags)
		goto out;
	if (!match) {
		err = -ENOMEM;
		match = kzalloc(sizeof(*match), GFP_KERNEL);
		if (!match)
			goto out;
		write_pnet(&match->net, sock_net(sk));
		match->id = id;
		match->type = type;
		match->flags = flags;
		INIT_LIST_HEAD(&match->list);
		spin_lock_init(&match->lock);
		atomic_set(&match->sk_ref, 0);
		fanout_init_data(match);
		match->prot_hook.type = po->prot_hook.type;
		match->prot_hook.dev = po->prot_hook.dev;
		match->prot_hook.func = packet_rcv_fanout;
		match->prot_hook.af_packet_priv = match;
		match->prot_hook.id_match = match_fanout_group;
		dev_add_pack(&match->prot_hook);
		list_add(&match->list, &fanout_list);
	}
	err = -EINVAL;
	if (match->type == type &&
	    match->prot_hook.type == po->prot_hook.type &&
	    match->prot_hook.dev == po->prot_hook.dev) {
		err = -ENOSPC;
		if (atomic_read(&match->sk_ref) < PACKET_FANOUT_MAX) {
			__dev_remove_pack(&po->prot_hook);
			po->fanout = match;
			atomic_inc(&match->sk_ref);
			__fanout_link(sk, po);
			err = 0;
 		}
 	}
 out:
	if (err && rollover) {
		kfree(rollover);
 		po->rollover = NULL;
 	}
	mutex_unlock(&fanout_mutex);
 	return err;
 }
"," static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 {
 	struct packet_sock *po = pkt_sk(sk);
 	struct packet_fanout *f, *match;
 	u8 type = type_flags & 0xff;
	u8 flags = type_flags >> 8;
	int err;

	switch (type) {
	case PACKET_FANOUT_ROLLOVER:
		if (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)
			return -EINVAL;
	case PACKET_FANOUT_HASH:
	case PACKET_FANOUT_LB:
	case PACKET_FANOUT_CPU:
	case PACKET_FANOUT_RND:
	case PACKET_FANOUT_QM:
	case PACKET_FANOUT_CBPF:
	case PACKET_FANOUT_EBPF:
		break;
	default:
 		return -EINVAL;
 	}
 
 	if (!po->running)
		return -EINVAL;
 
 	if (po->fanout)
		return -EALREADY;
 
 	if (type == PACKET_FANOUT_ROLLOVER ||
 	    (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {
		po->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);
		if (!po->rollover)
			return -ENOMEM;
		atomic_long_set(&po->rollover->num, 0);
		atomic_long_set(&po->rollover->num_huge, 0);
		atomic_long_set(&po->rollover->num_failed, 0);
 	}
 
	mutex_lock(&fanout_mutex);
 	match = NULL;
 	list_for_each_entry(f, &fanout_list, list) {
 		if (f->id == id &&
		    read_pnet(&f->net) == sock_net(sk)) {
			match = f;
			break;
		}
	}
	err = -EINVAL;
	if (match && match->flags != flags)
		goto out;
	if (!match) {
		err = -ENOMEM;
		match = kzalloc(sizeof(*match), GFP_KERNEL);
		if (!match)
			goto out;
		write_pnet(&match->net, sock_net(sk));
		match->id = id;
		match->type = type;
		match->flags = flags;
		INIT_LIST_HEAD(&match->list);
		spin_lock_init(&match->lock);
		atomic_set(&match->sk_ref, 0);
		fanout_init_data(match);
		match->prot_hook.type = po->prot_hook.type;
		match->prot_hook.dev = po->prot_hook.dev;
		match->prot_hook.func = packet_rcv_fanout;
		match->prot_hook.af_packet_priv = match;
		match->prot_hook.id_match = match_fanout_group;
		dev_add_pack(&match->prot_hook);
		list_add(&match->list, &fanout_list);
	}
	err = -EINVAL;
	if (match->type == type &&
	    match->prot_hook.type == po->prot_hook.type &&
	    match->prot_hook.dev == po->prot_hook.dev) {
		err = -ENOSPC;
		if (atomic_read(&match->sk_ref) < PACKET_FANOUT_MAX) {
			__dev_remove_pack(&po->prot_hook);
			po->fanout = match;
			atomic_inc(&match->sk_ref);
			__fanout_link(sk, po);
			err = 0;
 		}
 	}
 out:
	mutex_unlock(&fanout_mutex);
	if (err) {
		kfree(po->rollover);
 		po->rollover = NULL;
 	}
 	return err;
 }
",181518.0,C,"	struct packet_rollover *rollover = NULL;
	mutex_lock(&fanout_mutex);

	err = -EINVAL;
		goto out;
	err = -EALREADY;
		goto out;
		err = -ENOMEM;
		rollover = kzalloc(sizeof(*rollover), GFP_KERNEL);
		if (!rollover)
			goto out;
		atomic_long_set(&rollover->num, 0);
		atomic_long_set(&rollover->num_huge, 0);
		atomic_long_set(&rollover->num_failed, 0);
		po->rollover = rollover;
	if (err && rollover) {
		kfree(rollover);
	mutex_unlock(&fanout_mutex);
","		return -EINVAL;
		return -EALREADY;
		po->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);
		if (!po->rollover)
			return -ENOMEM;
		atomic_long_set(&po->rollover->num, 0);
		atomic_long_set(&po->rollover->num_huge, 0);
		atomic_long_set(&po->rollover->num_failed, 0);
	mutex_lock(&fanout_mutex);
	mutex_unlock(&fanout_mutex);
	if (err) {
		kfree(po->rollover);
",,"@@ -1619,6 +1619,7 @@ static void fanout_release_data(struct packet_fanout *f)
 
 static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 {
+	struct packet_rollover *rollover = NULL;
 	struct packet_sock *po = pkt_sk(sk);
 	struct packet_fanout *f, *match;
 	u8 type = type_flags & 0xff;
@@ -1641,23 +1642,28 @@ static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 		return -EINVAL;
 	}
 
+	mutex_lock(&fanout_mutex);
+
+	err = -EINVAL;
 	if (!po->running)
-		return -EINVAL;
+		goto out;
 
+	err = -EALREADY;
 	if (po->fanout)
-		return -EALREADY;
+		goto out;
 
 	if (type == PACKET_FANOUT_ROLLOVER ||
 	    (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {
-		po->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);
-		if (!po->rollover)
-			return -ENOMEM;
-		atomic_long_set(&po->rollover->num, 0);
-		atomic_long_set(&po->rollover->num_huge, 0);
-		atomic_long_set(&po->rollover->num_failed, 0);
+		err = -ENOMEM;
+		rollover = kzalloc(sizeof(*rollover), GFP_KERNEL);
+		if (!rollover)
+			goto out;
+		atomic_long_set(&rollover->num, 0);
+		atomic_long_set(&rollover->num_huge, 0);
+		atomic_long_set(&rollover->num_failed, 0);
+		po->rollover = rollover;
 	}
 
-	mutex_lock(&fanout_mutex);
 	match = NULL;
 	list_for_each_entry(f, &fanout_list, list) {
 		if (f->id == id &&
@@ -1704,11 +1710,11 @@ static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 		}
 	}
 out:
-	mutex_unlock(&fanout_mutex);
-	if (err) {
-		kfree(po->rollover);
+	if (err && rollover) {
+		kfree(rollover);
 		po->rollover = NULL;
 	}
+	mutex_unlock(&fanout_mutex);
 	return err;
 }
 
@@ -1717,23 +1723,22 @@ static void fanout_release(struct sock *sk)
 	struct packet_sock *po = pkt_sk(sk);
 	struct packet_fanout *f;
 
-	f = po->fanout;
-	if (!f)
-		return;
-
 	mutex_lock(&fanout_mutex);
-	po->fanout = NULL;
+	f = po->fanout;
+	if (f) {
+		po->fanout = NULL;
+
+		if (atomic_dec_and_test(&f->sk_ref)) {
+			list_del(&f->list);
+			dev_remove_pack(&f->prot_hook);
+			fanout_release_data(f);
+			kfree(f);
+		}
 
-	if (atomic_dec_and_test(&f->sk_ref)) {
-		list_del(&f->list);
-		dev_remove_pack(&f->prot_hook);
-		fanout_release_data(f);
-		kfree(f);
+		if (po->rollover)
+			kfree_rcu(po->rollover, rcu);
 	}
 	mutex_unlock(&fanout_mutex);
-
-	if (po->rollover)
-		kfree_rcu(po->rollover, rcu);
 }
 
 static bool packet_extra_vlan_len_allowed(const struct net_device *dev,","static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
{
struct packet_sock *po = pkt_sk(sk);
struct packet_fanout *f, *match;
u8 type = type_flags & 0xff;
u8 flags = type_flags >> 8;
int err;

switch (type) {
case PACKET_FANOUT_ROLLOVER:
if (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)
return -EINVAL;
case PACKET_FANOUT_HASH:
case PACKET_FANOUT_LB:
case PACKET_FANOUT_CPU:
case PACKET_FANOUT_RND:
case PACKET_FANOUT_QM:
case PACKET_FANOUT_CBPF:
case PACKET_FANOUT_EBPF:
break;
default:
return -EINVAL;
}

if (!po->running)
		return -EINVAL;

if (po->fanout)
		return -EALREADY;

if (type == PACKET_FANOUT_ROLLOVER ||
(type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {
		po->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);
		if (!po->rollover)
			return -ENOMEM;
		atomic_long_set(&po->rollover->num, 0);
		atomic_long_set(&po->rollover->num_huge, 0);
		atomic_long_set(&po->rollover->num_failed, 0);
}

	mutex_lock(&fanout_mutex);
match = NULL;
list_for_each_entry(f, &fanout_list, list) {
if (f->id == id &&
read_pnet(&f->net) == sock_net(sk)) {
match = f;
break;
}
}
err = -EINVAL;
if (match && match->flags != flags)
goto out;
if (!match) {
err = -ENOMEM;
match = kzalloc(sizeof(*match), GFP_KERNEL);
if (!match)
goto out;
write_pnet(&match->net, sock_net(sk));
match->id = id;
match->type = type;
match->flags = flags;
INIT_LIST_HEAD(&match->list);
spin_lock_init(&match->lock);
atomic_set(&match->sk_ref, 0);
fanout_init_data(match);
match->prot_hook.type = po->prot_hook.type;
match->prot_hook.dev = po->prot_hook.dev;
match->prot_hook.func = packet_rcv_fanout;
match->prot_hook.af_packet_priv = match;
match->prot_hook.id_match = match_fanout_group;
dev_add_pack(&match->prot_hook);
list_add(&match->list, &fanout_list);
}
err = -EINVAL;
if (match->type == type &&
match->prot_hook.type == po->prot_hook.type &&
match->prot_hook.dev == po->prot_hook.dev) {
err = -ENOSPC;
if (atomic_read(&match->sk_ref) < PACKET_FANOUT_MAX) {
__dev_remove_pack(&po->prot_hook);
po->fanout = match;
atomic_inc(&match->sk_ref);
__fanout_link(sk, po);
err = 0;
}
}
out:
	mutex_unlock(&fanout_mutex);
	if (err) {
		kfree(po->rollover);
po->rollover = NULL;
}
return err;
}
",linux,d199fab63c11998a602205f7ee7ff7c05c97164b,f39f0d1e1e93145a0e91d9a7a639c42fd037ecc3,1.0," static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 {
//fix_flaw_line_below:
//	struct packet_rollover *rollover = NULL;
 	struct packet_sock *po = pkt_sk(sk);
 	struct packet_fanout *f, *match;
 	u8 type = type_flags & 0xff;
	u8 flags = type_flags >> 8;
	int err;

	switch (type) {
	case PACKET_FANOUT_ROLLOVER:
		if (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)
			return -EINVAL;
	case PACKET_FANOUT_HASH:
	case PACKET_FANOUT_LB:
	case PACKET_FANOUT_CPU:
	case PACKET_FANOUT_RND:
	case PACKET_FANOUT_QM:
	case PACKET_FANOUT_CBPF:
	case PACKET_FANOUT_EBPF:
		break;
	default:
 		return -EINVAL;
 	}
 
//fix_flaw_line_below:
//	mutex_lock(&fanout_mutex);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	err = -EINVAL;
 	if (!po->running)
//flaw_line_below:
		return -EINVAL;
//fix_flaw_line_below:
//		goto out;
 
//fix_flaw_line_below:
//	err = -EALREADY;
 	if (po->fanout)
//flaw_line_below:
		return -EALREADY;
//fix_flaw_line_below:
//		goto out;
 
 	if (type == PACKET_FANOUT_ROLLOVER ||
 	    (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {
//flaw_line_below:
		po->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);
//flaw_line_below:
		if (!po->rollover)
//flaw_line_below:
			return -ENOMEM;
//flaw_line_below:
		atomic_long_set(&po->rollover->num, 0);
//flaw_line_below:
		atomic_long_set(&po->rollover->num_huge, 0);
//flaw_line_below:
		atomic_long_set(&po->rollover->num_failed, 0);
//fix_flaw_line_below:
//		err = -ENOMEM;
//fix_flaw_line_below:
//		rollover = kzalloc(sizeof(*rollover), GFP_KERNEL);
//fix_flaw_line_below:
//		if (!rollover)
//fix_flaw_line_below:
//			goto out;
//fix_flaw_line_below:
//		atomic_long_set(&rollover->num, 0);
//fix_flaw_line_below:
//		atomic_long_set(&rollover->num_huge, 0);
//fix_flaw_line_below:
//		atomic_long_set(&rollover->num_failed, 0);
//fix_flaw_line_below:
//		po->rollover = rollover;
 	}
 
//flaw_line_below:
	mutex_lock(&fanout_mutex);
 	match = NULL;
 	list_for_each_entry(f, &fanout_list, list) {
 		if (f->id == id &&
		    read_pnet(&f->net) == sock_net(sk)) {
			match = f;
			break;
		}
	}
	err = -EINVAL;
	if (match && match->flags != flags)
		goto out;
	if (!match) {
		err = -ENOMEM;
		match = kzalloc(sizeof(*match), GFP_KERNEL);
		if (!match)
			goto out;
		write_pnet(&match->net, sock_net(sk));
		match->id = id;
		match->type = type;
		match->flags = flags;
		INIT_LIST_HEAD(&match->list);
		spin_lock_init(&match->lock);
		atomic_set(&match->sk_ref, 0);
		fanout_init_data(match);
		match->prot_hook.type = po->prot_hook.type;
		match->prot_hook.dev = po->prot_hook.dev;
		match->prot_hook.func = packet_rcv_fanout;
		match->prot_hook.af_packet_priv = match;
		match->prot_hook.id_match = match_fanout_group;
		dev_add_pack(&match->prot_hook);
		list_add(&match->list, &fanout_list);
	}
	err = -EINVAL;
	if (match->type == type &&
	    match->prot_hook.type == po->prot_hook.type &&
	    match->prot_hook.dev == po->prot_hook.dev) {
		err = -ENOSPC;
		if (atomic_read(&match->sk_ref) < PACKET_FANOUT_MAX) {
			__dev_remove_pack(&po->prot_hook);
			po->fanout = match;
			atomic_inc(&match->sk_ref);
			__fanout_link(sk, po);
			err = 0;
 		}
 	}
 out:
//flaw_line_below:
	mutex_unlock(&fanout_mutex);
//flaw_line_below:
	if (err) {
//flaw_line_below:
		kfree(po->rollover);
//fix_flaw_line_below:
//	if (err && rollover) {
//fix_flaw_line_below:
//		kfree(rollover);
 		po->rollover = NULL;
 	}
//fix_flaw_line_below:
//	mutex_unlock(&fanout_mutex);
 	return err;
 }
"
972,None,Remote,Not required,Partial,CVE-2015-8126,https://www.cvedetails.com/cve/CVE-2015-8126/,CWE-119,Low,Partial,Partial,,2015-11-12,7.5,"Multiple buffer overflows in the (1) png_set_PLTE and (2) png_get_PLTE functions in libpng before 1.0.64, 1.1.x and 1.2.x before 1.2.54, 1.3.x and 1.4.x before 1.4.17, 1.5.x before 1.5.24, and 1.6.x before 1.6.19 allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a small bit-depth value in an IHDR (aka image header) chunk in a PNG image.",2017-06-30,DoS Overflow ,0.0,https://github.com/chromium/chromium/commit/7f3d85b096f66870a15b37c2f40b219b2e292693,7f3d85b096f66870a15b37c2f40b219b2e292693,"third_party/libpng: update to 1.2.54

TBR=darin@chromium.org
BUG=560291

Review URL: https://codereview.chromium.org/1467263003

Cr-Commit-Position: refs/heads/master@{#362298}",7.0,third_party/libpng/pngwrite.c,"{""sha"": ""748a42945aea0508fb0ea64493503e0e2cea92ad"", ""filename"": ""third_party/libpng/LICENSE"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 27, ""changes"": 53, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/LICENSE"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/LICENSE"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libpng/LICENSE?ref=7f3d85b096f66870a15b37c2f40b219b2e292693"", ""patch"": ""@@ -12,20 +12,15 @@ pngusr.h is distributed under the MPL 1.1/GPL 2.0/LGPL 2.1 tri-license.\n \n This code is released under the libpng license.\n \n-libpng versions 1.2.6, August 15, 2004, through 1.2.52, November 20, 2014, are\n-Copyright (c) 2004, 2006-2014 Glenn Randers-Pehrson, and are\n-distributed according to the same disclaimer and license as libpng-1.2.5\n-with the following individual added to the list of Contributing Authors\n-\n-   Cosmin Truta\n-\n-libpng versions 1.0.7, July 1, 2000, through 1.2.5 - October 3, 2002, are\n-Copyright (c) 2000-2002 Glenn Randers-Pehrson, and are\n-distributed according to the same disclaimer and license as libpng-1.0.6\n-with the following individuals added to the list of Contributing Authors\n+libpng versions 1.0.7, July 1, 2000, through 1.2.54, November 12, 2015, are\n+Copyright (c) 2000-2002, 2004, 2006-2015 Glenn Randers-Pehrson, are\n+derived from libpng-1.0.6, and are distributed according to the same\n+disclaimer and license as libpng-1.0.6 with the following individuals\n+added to the list of Contributing Authors:\n \n    Simon-Pierre Cadieux\n    Eric S. Raymond\n+   Cosmin Truta\n    Gilles Vollant\n \n and with the following additions to the disclaimer:\n@@ -38,18 +33,20 @@ and with the following additions to the disclaimer:\n    the user.\n \n libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are\n-Copyright (c) 1998, 1999 Glenn Randers-Pehrson, and are\n-distributed according to the same disclaimer and license as libpng-0.96,\n-with the following individuals added to the list of Contributing Authors:\n+Copyright (c) 1998-2000 Glenn Randers-Pehrson, are derived from\n+libpng-0.96, and are distributed according to the same disclaimer and\n+license as libpng-0.96, with the following individuals added to the list\n+of Contributing Authors:\n \n    Tom Lane\n    Glenn Randers-Pehrson\n    Willem van Schaik\n \n libpng versions 0.89, June 1996, through 0.96, May 1997, are\n-Copyright (c) 1996, 1997 Andreas Dilger\n-Distributed according to the same disclaimer and license as libpng-0.88,\n-with the following individuals added to the list of Contributing Authors:\n+Copyright (c) 1996-1997 Andreas Dilger, are derived from libpng-0.88,\n+and are distributed according to the same disclaimer and license as\n+libpng-0.88, with the following individuals added to the list of\n+Contributing Authors:\n \n    John Bowler\n    Kevin Bracey\n@@ -59,7 +56,7 @@ with the following individuals added to the list of Contributing Authors:\n    Tom Tanner\n \n libpng versions 0.5, May 1995, through 0.88, January 1996, are\n-Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.\n+Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n \n For the purposes of this copyright and license, \""Contributing Authors\""\n is defined as the following set of individuals:\n@@ -82,32 +79,34 @@ Permission is hereby granted to use, copy, modify, and distribute this\n source code, or portions hereof, for any purpose, without fee, subject\n to the following restrictions:\n \n-1. The origin of this source code must not be misrepresented.\n+  1. The origin of this source code must not be misrepresented.\n \n-2. Altered versions must be plainly marked as such and must not\n-   be misrepresented as being the original source.\n+  2. Altered versions must be plainly marked as such and must not\n+     be misrepresented as being the original source.\n \n-3. This Copyright notice may not be removed or altered from any\n-   source or altered source distribution.\n+  3. This Copyright notice may not be removed or altered from any\n+     source or altered source distribution.\n \n The Contributing Authors and Group 42, Inc. specifically permit, without\n fee, and encourage the use of this source code as a component to\n supporting the PNG file format in commercial products.  If you use this\n source code in a product, acknowledgment is not required but would be\n appreciated.\n \n+END OF COPYRIGHT NOTICE, DISCLAIMER, and LICENSE.\n \n A \""png_get_copyright\"" function is available, for convenient use in \""about\""\n boxes and the like:\n \n-   printf(\""%s\"",png_get_copyright(NULL));\n+   printf(\""%s\"", png_get_copyright(NULL));\n \n Also, the PNG logo (in PNG format, of course) is supplied in the\n files \""pngbar.png\"" and \""pngbar.jpg (88x31) and \""pngnow.png\"" (98x31).\n \n-Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is a\n-certification mark of the Open Source Initiative.\n+Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is\n+a certification mark of the Open Source Initiative. OSI has not addressed\n+the additional disclaimers inserted at version 1.0.7.\n \n Glenn Randers-Pehrson\n glennrp at users.sourceforge.net\n-November 20, 2014\n+November 12, 2015""}<_**next**_>{""sha"": ""0c8ca72a9df01e271c5165b0a89dfde32c6f7a3c"", ""filename"": ""third_party/libpng/README"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/README"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/README"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libpng/README?ref=7f3d85b096f66870a15b37c2f40b219b2e292693"", ""patch"": ""@@ -1,4 +1,4 @@\n-README for libpng version 1.2.52 - November 20, 2014 (shared library 12.0)\n+README for libpng version 1.2.54 - November 12, 2015 (shared library 12.0)\n See the note about version numbers near the top of png.h\n \n See INSTALL for instructions on how to install libpng.\n@@ -135,7 +135,7 @@ and ...\"".  If in doubt, send questions to me.  I'll bounce them\n to others, if necessary.\n \n Please do not send suggestions on how to change PNG.  We have\n-been discussing PNG for nineteen years now, and it is official and\n+been discussing PNG for twenty years now, and it is official and\n finished.  If you have suggestions for libpng, however, I'll\n gladly listen.  Even if your suggestion is not used immediately,\n it may be used later.\n@@ -207,11 +207,11 @@ Files in this distribution:\n        makefile.std     =>  Generic UNIX makefile (cc, creates static\n                             libpng.a)\n        makefile.elf     =>  Linux/ELF gcc makefile symbol versioning,\n-                            creates libpng12.so.0.1.2.52)\n+                            creates libpng12.so.0.1.2.54)\n        makefile.linux   =>  Linux/ELF makefile (gcc, creates\n-                            libpng12.so.0.1.2.52)\n+                            libpng12.so.0.1.2.54)\n        makefile.gcmmx   =>  Linux/ELF makefile (gcc, creates\n-                            libpng12.so.0.1.2.52, previously\n+                            libpng12.so.0.1.2.54, previously\n                             used assembler code tuned for Intel MMX\n                             platform)\n        makefile.gcc     =>  Generic makefile (gcc, creates static\n@@ -236,12 +236,12 @@ Files in this distribution:\n        makefile.openbsd =>  OpenBSD makefile\n        makefile.sgi     =>  Silicon Graphics IRIX (cc, creates static lib)\n        makefile.sggcc   =>  Silicon Graphics\n-                            (gcc, creates libpng12.so.0.1.2.52)\n+                            (gcc, creates libpng12.so.0.1.2.54)\n        makefile.sunos   =>  Sun makefile\n        makefile.solaris =>  Solaris 2.X makefile\n-                            (gcc, creates libpng12.so.0.1.2.52)\n+                            (gcc, creates libpng12.so.0.1.2.54)\n        makefile.so9     =>  Solaris 9 makefile\n-                            (gcc, creates libpng12.so.0.1.2.52)\n+                            (gcc, creates libpng12.so.0.1.2.54)\n        makefile.32sunu  =>  Sun Ultra 32-bit makefile\n        makefile.64sunu  =>  Sun Ultra 64-bit makefile\n        makefile.sco     =>  For SCO OSr5  ELF and Unixware 7 with Native cc""}<_**next**_>{""sha"": ""2ac561575081def37287f1363f64ddae01f98a02"", ""filename"": ""third_party/libpng/README.chromium"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/README.chromium"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/README.chromium"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libpng/README.chromium?ref=7f3d85b096f66870a15b37c2f40b219b2e292693"", ""patch"": ""@@ -1,6 +1,6 @@\n Name: libpng\n URL: http://libpng.org/\n-Version: 1.2.52\n+Version: 1.2.54\n Security Critical: yes\n License: libpng license\n License Android Compatible: yes\n@@ -10,7 +10,7 @@ Our custom configuration options are defined in pngusr.h. This was previously\n called mozpngconf.h, which was copied from Mozilla and modified by Apple (hence\n the wk_* names).\n \n-Updated to 1.2.52, no changes to the source files but all unneeded files\n+Updated to 1.2.54, no changes to the source files but all unneeded files\n stripped.\n \n - Unset PNG_NO_READ_PACK on Android in pngusr.h, required by freetype to support""}<_**next**_>{""sha"": ""206219436509f87d4e153906640a41b9caa6d54e"", ""filename"": ""third_party/libpng/png.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 12, ""changes"": 31, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/png.c"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/png.c"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libpng/png.c?ref=7f3d85b096f66870a15b37c2f40b219b2e292693"", ""patch"": ""@@ -1,8 +1,8 @@\n \n /* png.c - location for general purpose libpng functions\n  *\n- * Last changed in libpng 1.2.51 [February 6, 2014]\n- * Copyright (c) 1998-2014 Glenn Randers-Pehrson\n+ * Last changed in libpng 1.2.54 [November 12, 2015]\n+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson\n  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\n  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\n  *\n@@ -17,7 +17,7 @@\n #include \""png.h\""\n \n /* Generate a compiler error if there is an old png.h in the search path. */\n-typedef version_1_2_52 Your_png_h_is_not_version_1_2_52;\n+typedef version_1_2_54 Your_png_h_is_not_version_1_2_54;\n \n /* Version information for C files.  This had better match the version\n  * string defined in png.h.\n@@ -158,12 +158,16 @@ voidpf /* PRIVATE */\n png_zalloc(voidpf png_ptr, uInt items, uInt size)\n {\n    png_voidp ptr;\n-   png_structp p=(png_structp)png_ptr;\n-   png_uint_32 save_flags=p->flags;\n+   png_structp p;\n+   png_uint_32 save_flags;\n    png_uint_32 num_bytes;\n \n    if (png_ptr == NULL)\n       return (NULL);\n+\n+   p=(png_structp)png_ptr;\n+   save_flags=p->flags;\n+\n    if (items > PNG_UINT_32_MAX/size)\n    {\n      png_warning (p, \""Potential overflow in png_zalloc()\"");\n@@ -328,6 +332,8 @@ png_info_init_3(png_infopp ptr_ptr, png_size_t png_info_struct_size)\n       png_destroy_struct(info_ptr);\n       info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);\n       *ptr_ptr = info_ptr;\n+      if (info_ptr == NULL)\n+         return;\n    }\n \n    /* Set everything to 0 */\n@@ -675,6 +681,7 @@ png_convert_to_rfc1123(png_structp png_ptr, png_timep ptime)\n \n    if (png_ptr == NULL)\n       return (NULL);\n+\n    if (png_ptr->time_buffer == NULL)\n    {\n       png_ptr->time_buffer = (png_charp)png_malloc(png_ptr, (png_uint_32)(29*\n@@ -685,7 +692,7 @@ png_convert_to_rfc1123(png_structp png_ptr, png_timep ptime)\n    {\n       wchar_t time_buf[29];\n       wsprintf(time_buf, TEXT(\""%d %S %d %02d:%02d:%02d +0000\""),\n-          ptime->day % 32, short_months[(ptime->month - 1) % 12],\n+          ptime->day % 32, short_months[(ptime->month - 1U) % 12],\n         ptime->year, ptime->hour % 24, ptime->minute % 60,\n           ptime->second % 61);\n       WideCharToMultiByte(CP_ACP, 0, time_buf, -1, png_ptr->time_buffer,\n@@ -696,15 +703,15 @@ png_convert_to_rfc1123(png_structp png_ptr, png_timep ptime)\n    {\n       char near_time_buf[29];\n       png_snprintf6(near_time_buf, 29, \""%d %s %d %02d:%02d:%02d +0000\"",\n-          ptime->day % 32, short_months[(ptime->month - 1) % 12],\n+          ptime->day % 32, short_months[(ptime->month - 1U) % 12],\n           ptime->year, ptime->hour % 24, ptime->minute % 60,\n           ptime->second % 61);\n       png_memcpy(png_ptr->time_buffer, near_time_buf,\n           29*png_sizeof(char));\n    }\n #else\n    png_snprintf6(png_ptr->time_buffer, 29, \""%d %s %d %02d:%02d:%02d +0000\"",\n-       ptime->day % 32, short_months[(ptime->month - 1) % 12],\n+       ptime->day % 32, short_months[(ptime->month - 1U) % 12],\n        ptime->year, ptime->hour % 24, ptime->minute % 60,\n        ptime->second % 61);\n #endif\n@@ -724,14 +731,14 @@ png_get_copyright(png_structp png_ptr)\n #else\n #ifdef __STDC__\n    return ((png_charp) PNG_STRING_NEWLINE \\\n-     \""libpng version 1.2.52 - November 20, 2014\"" PNG_STRING_NEWLINE \\\n-     \""Copyright (c) 1998-2014 Glenn Randers-Pehrson\"" PNG_STRING_NEWLINE \\\n+     \""libpng version 1.2.54 - November 12, 2015\"" PNG_STRING_NEWLINE \\\n+     \""Copyright (c) 1998-2015 Glenn Randers-Pehrson\"" PNG_STRING_NEWLINE \\\n      \""Copyright (c) 1996-1997 Andreas Dilger\"" PNG_STRING_NEWLINE \\\n      \""Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\"" \\\n      PNG_STRING_NEWLINE);\n #else\n-      return ((png_charp) \""libpng version 1.2.52 - November 20, 2014\\\n-      Copyright (c) 1998-2014 Glenn Randers-Pehrson\\\n+      return ((png_charp) \""libpng version 1.2.54 - November 12, 2015\\\n+      Copyright (c) 1998-2015 Glenn Randers-Pehrson\\\n       Copyright (c) 1996-1997 Andreas Dilger\\\n       Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\"");\n #endif""}<_**next**_>{""sha"": ""bbed688b73750c7f66bc26378c9b78c8f8486237"", ""filename"": ""third_party/libpng/png.h"", ""status"": ""modified"", ""additions"": 113, ""deletions"": 380, ""changes"": 493, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/png.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/png.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libpng/png.h?ref=7f3d85b096f66870a15b37c2f40b219b2e292693"", ""patch"": ""@@ -1,318 +1,19 @@\n+\n /* png.h - header file for PNG reference library\n  *\n- * libpng version 1.2.52 - November 20, 2014\n- * Copyright (c) 1998-2014 Glenn Randers-Pehrson\n+ * libpng version 1.2.54, November 12, 2015\n+ *\n+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson\n  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\n  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\n  *\n  * This code is released under the libpng license (See LICENSE, below)\n  *\n  * Authors and maintainers:\n  *  libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat\n- *  libpng versions 0.89c, June 1996, through 0.96, May 1997: Andreas Dilger\n- *  libpng versions 0.97, January 1998, through 1.2.52 - November 20, 2014: Glenn\n+ *  libpng versions 0.89, June 1996, through 0.96, May 1997: Andreas Dilger\n+ *  libpng versions 0.97, January 1998, through 1.2.54, November 12, 2015: Glenn\n  *  See also \""Contributing Authors\"", below.\n- *\n- * Note about libpng version numbers:\n- *\n- *    Due to various miscommunications, unforeseen code incompatibilities\n- *    and occasional factors outside the authors' control, version numbering\n- *    on the library has not always been consistent and straightforward.\n- *    The following table summarizes matters since version 0.89c, which was\n- *    the first widely used release:\n- *\n- *    source                 png.h  png.h  shared-lib\n- *    version                string   int  version\n- *    -------                ------ -----  ----------\n- *    0.89c \""1.0 beta 3\""     0.89      89  1.0.89\n- *    0.90  \""1.0 beta 4\""     0.90      90  0.90  [should have been 2.0.90]\n- *    0.95  \""1.0 beta 5\""     0.95      95  0.95  [should have been 2.0.95]\n- *    0.96  \""1.0 beta 6\""     0.96      96  0.96  [should have been 2.0.96]\n- *    0.97b \""1.00.97 beta 7\"" 1.00.97   97  1.0.1 [should have been 2.0.97]\n- *    0.97c                  0.97      97  2.0.97\n- *    0.98                   0.98      98  2.0.98\n- *    0.99                   0.99      98  2.0.99\n- *    0.99a-m                0.99      99  2.0.99\n- *    1.00                   1.00     100  2.1.0 [100 should be 10000]\n- *    1.0.0      (from here on, the   100  2.1.0 [100 should be 10000]\n- *    1.0.1       png.h string is   10001  2.1.0\n- *    1.0.1a-e    identical to the  10002  from here on, the shared library\n- *    1.0.2       source version)   10002  is 2.V where V is the source code\n- *    1.0.2a-b                      10003  version, except as noted.\n- *    1.0.3                         10003\n- *    1.0.3a-d                      10004\n- *    1.0.4                         10004\n- *    1.0.4a-f                      10005\n- *    1.0.5 (+ 2 patches)           10005\n- *    1.0.5a-d                      10006\n- *    1.0.5e-r                      10100 (not source compatible)\n- *    1.0.5s-v                      10006 (not binary compatible)\n- *    1.0.6 (+ 3 patches)           10006 (still binary incompatible)\n- *    1.0.6d-f                      10007 (still binary incompatible)\n- *    1.0.6g                        10007\n- *    1.0.6h                        10007  10.6h (testing xy.z so-numbering)\n- *    1.0.6i                        10007  10.6i\n- *    1.0.6j                        10007  2.1.0.6j (incompatible with 1.0.0)\n- *    1.0.7beta11-14        DLLNUM  10007  2.1.0.7beta11-14 (binary compatible)\n- *    1.0.7beta15-18           1    10007  2.1.0.7beta15-18 (binary compatible)\n- *    1.0.7rc1-2               1    10007  2.1.0.7rc1-2 (binary compatible)\n- *    1.0.7                    1    10007  (still compatible)\n- *    1.0.8beta1-4             1    10008  2.1.0.8beta1-4\n- *    1.0.8rc1                 1    10008  2.1.0.8rc1\n- *    1.0.8                    1    10008  2.1.0.8\n- *    1.0.9beta1-6             1    10009  2.1.0.9beta1-6\n- *    1.0.9rc1                 1    10009  2.1.0.9rc1\n- *    1.0.9beta7-10            1    10009  2.1.0.9beta7-10\n- *    1.0.9rc2                 1    10009  2.1.0.9rc2\n- *    1.0.9                    1    10009  2.1.0.9\n- *    1.0.10beta1              1    10010  2.1.0.10beta1\n- *    1.0.10rc1                1    10010  2.1.0.10rc1\n- *    1.0.10                   1    10010  2.1.0.10\n- *    1.0.11beta1-3            1    10011  2.1.0.11beta1-3\n- *    1.0.11rc1                1    10011  2.1.0.11rc1\n- *    1.0.11                   1    10011  2.1.0.11\n- *    1.0.12beta1-2            2    10012  2.1.0.12beta1-2\n- *    1.0.12rc1                2    10012  2.1.0.12rc1\n- *    1.0.12                   2    10012  2.1.0.12\n- *    1.1.0a-f                 -    10100  2.1.1.0a-f (branch abandoned)\n- *    1.2.0beta1-2             2    10200  2.1.2.0beta1-2\n- *    1.2.0beta3-5             3    10200  3.1.2.0beta3-5\n- *    1.2.0rc1                 3    10200  3.1.2.0rc1\n- *    1.2.0                    3    10200  3.1.2.0\n- *    1.2.1beta1-4             3    10201  3.1.2.1beta1-4\n- *    1.2.1rc1-2               3    10201  3.1.2.1rc1-2\n- *    1.2.1                    3    10201  3.1.2.1\n- *    1.2.2beta1-6            12    10202  12.so.0.1.2.2beta1-6\n- *    1.0.13beta1             10    10013  10.so.0.1.0.13beta1\n- *    1.0.13rc1               10    10013  10.so.0.1.0.13rc1\n- *    1.2.2rc1                12    10202  12.so.0.1.2.2rc1\n- *    1.0.13                  10    10013  10.so.0.1.0.13\n- *    1.2.2                   12    10202  12.so.0.1.2.2\n- *    1.2.3rc1-6              12    10203  12.so.0.1.2.3rc1-6\n- *    1.2.3                   12    10203  12.so.0.1.2.3\n- *    1.2.4beta1-3            13    10204  12.so.0.1.2.4beta1-3\n- *    1.0.14rc1               13    10014  10.so.0.1.0.14rc1\n- *    1.2.4rc1                13    10204  12.so.0.1.2.4rc1\n- *    1.0.14                  10    10014  10.so.0.1.0.14\n- *    1.2.4                   13    10204  12.so.0.1.2.4\n- *    1.2.5beta1-2            13    10205  12.so.0.1.2.5beta1-2\n- *    1.0.15rc1-3             10    10015  10.so.0.1.0.15rc1-3\n- *    1.2.5rc1-3              13    10205  12.so.0.1.2.5rc1-3\n- *    1.0.15                  10    10015  10.so.0.1.0.15\n- *    1.2.5                   13    10205  12.so.0.1.2.5\n- *    1.2.6beta1-4            13    10206  12.so.0.1.2.6beta1-4\n- *    1.0.16                  10    10016  10.so.0.1.0.16\n- *    1.2.6                   13    10206  12.so.0.1.2.6\n- *    1.2.7beta1-2            13    10207  12.so.0.1.2.7beta1-2\n- *    1.0.17rc1               10    10017  10.so.0.1.0.17rc1\n- *    1.2.7rc1                13    10207  12.so.0.1.2.7rc1\n- *    1.0.17                  10    10017  10.so.0.1.0.17\n- *    1.2.7                   13    10207  12.so.0.1.2.7\n- *    1.2.8beta1-5            13    10208  12.so.0.1.2.8beta1-5\n- *    1.0.18rc1-5             10    10018  10.so.0.1.0.18rc1-5\n- *    1.2.8rc1-5              13    10208  12.so.0.1.2.8rc1-5\n- *    1.0.18                  10    10018  10.so.0.1.0.18\n- *    1.2.8                   13    10208  12.so.0.1.2.8\n- *    1.2.9beta1-3            13    10209  12.so.0.1.2.9beta1-3\n- *    1.2.9beta4-11           13    10209  12.so.0.9[.0]\n- *    1.2.9rc1                13    10209  12.so.0.9[.0]\n- *    1.2.9                   13    10209  12.so.0.9[.0]\n- *    1.2.10beta1-8           13    10210  12.so.0.10[.0]\n- *    1.2.10rc1-3             13    10210  12.so.0.10[.0]\n- *    1.2.10                  13    10210  12.so.0.10[.0]\n- *    1.2.11beta1-4           13    10211  12.so.0.11[.0]\n- *    1.0.19rc1-5             10    10019  10.so.0.19[.0]\n- *    1.2.11rc1-5             13    10211  12.so.0.11[.0]\n- *    1.0.19                  10    10019  10.so.0.19[.0]\n- *    1.2.11                  13    10211  12.so.0.11[.0]\n- *    1.0.20                  10    10020  10.so.0.20[.0]\n- *    1.2.12                  13    10212  12.so.0.12[.0]\n- *    1.2.13beta1             13    10213  12.so.0.13[.0]\n- *    1.0.21                  10    10021  10.so.0.21[.0]\n- *    1.2.13                  13    10213  12.so.0.13[.0]\n- *    1.2.14beta1-2           13    10214  12.so.0.14[.0]\n- *    1.0.22rc1               10    10022  10.so.0.22[.0]\n- *    1.2.14rc1               13    10214  12.so.0.14[.0]\n- *    1.0.22                  10    10022  10.so.0.22[.0]\n- *    1.2.14                  13    10214  12.so.0.14[.0]\n- *    1.2.15beta1-6           13    10215  12.so.0.15[.0]\n- *    1.0.23rc1-5             10    10023  10.so.0.23[.0]\n- *    1.2.15rc1-5             13    10215  12.so.0.15[.0]\n- *    1.0.23                  10    10023  10.so.0.23[.0]\n- *    1.2.15                  13    10215  12.so.0.15[.0]\n- *    1.2.16beta1-2           13    10216  12.so.0.16[.0]\n- *    1.2.16rc1               13    10216  12.so.0.16[.0]\n- *    1.0.24                  10    10024  10.so.0.24[.0]\n- *    1.2.16                  13    10216  12.so.0.16[.0]\n- *    1.2.17beta1-2           13    10217  12.so.0.17[.0]\n- *    1.0.25rc1               10    10025  10.so.0.25[.0]\n- *    1.2.17rc1-3             13    10217  12.so.0.17[.0]\n- *    1.0.25                  10    10025  10.so.0.25[.0]\n- *    1.2.17                  13    10217  12.so.0.17[.0]\n- *    1.0.26                  10    10026  10.so.0.26[.0]\n- *    1.2.18                  13    10218  12.so.0.18[.0]\n- *    1.2.19beta1-31          13    10219  12.so.0.19[.0]\n- *    1.0.27rc1-6             10    10027  10.so.0.27[.0]\n- *    1.2.19rc1-6             13    10219  12.so.0.19[.0]\n- *    1.0.27                  10    10027  10.so.0.27[.0]\n- *    1.2.19                  13    10219  12.so.0.19[.0]\n- *    1.2.20beta01-04         13    10220  12.so.0.20[.0]\n- *    1.0.28rc1-6             10    10028  10.so.0.28[.0]\n- *    1.2.20rc1-6             13    10220  12.so.0.20[.0]\n- *    1.0.28                  10    10028  10.so.0.28[.0]\n- *    1.2.20                  13    10220  12.so.0.20[.0]\n- *    1.2.21beta1-2           13    10221  12.so.0.21[.0]\n- *    1.2.21rc1-3             13    10221  12.so.0.21[.0]\n- *    1.0.29                  10    10029  10.so.0.29[.0]\n- *    1.2.21                  13    10221  12.so.0.21[.0]\n- *    1.2.22beta1-4           13    10222  12.so.0.22[.0]\n- *    1.0.30rc1               10    10030  10.so.0.30[.0]\n- *    1.2.22rc1               13    10222  12.so.0.22[.0]\n- *    1.0.30                  10    10030  10.so.0.30[.0]\n- *    1.2.22                  13    10222  12.so.0.22[.0]\n- *    1.2.23beta01-05         13    10223  12.so.0.23[.0]\n- *    1.2.23rc01              13    10223  12.so.0.23[.0]\n- *    1.2.23                  13    10223  12.so.0.23[.0]\n- *    1.2.24beta01-02         13    10224  12.so.0.24[.0]\n- *    1.2.24rc01              13    10224  12.so.0.24[.0]\n- *    1.2.24                  13    10224  12.so.0.24[.0]\n- *    1.2.25beta01-06         13    10225  12.so.0.25[.0]\n- *    1.2.25rc01-02           13    10225  12.so.0.25[.0]\n- *    1.0.31                  10    10031  10.so.0.31[.0]\n- *    1.2.25                  13    10225  12.so.0.25[.0]\n- *    1.2.26beta01-06         13    10226  12.so.0.26[.0]\n- *    1.2.26rc01              13    10226  12.so.0.26[.0]\n- *    1.2.26                  13    10226  12.so.0.26[.0]\n- *    1.0.32                  10    10032  10.so.0.32[.0]\n- *    1.2.27beta01-06         13    10227  12.so.0.27[.0]\n- *    1.2.27rc01              13    10227  12.so.0.27[.0]\n- *    1.0.33                  10    10033  10.so.0.33[.0]\n- *    1.2.27                  13    10227  12.so.0.27[.0]\n- *    1.0.34                  10    10034  10.so.0.34[.0]\n- *    1.2.28                  13    10228  12.so.0.28[.0]\n- *    1.2.29beta01-03         13    10229  12.so.0.29[.0]\n- *    1.2.29rc01              13    10229  12.so.0.29[.0]\n- *    1.0.35                  10    10035  10.so.0.35[.0]\n- *    1.2.29                  13    10229  12.so.0.29[.0]\n- *    1.0.37                  10    10037  10.so.0.37[.0]\n- *    1.2.30beta01-04         13    10230  12.so.0.30[.0]\n- *    1.0.38rc01-08           10    10038  10.so.0.38[.0]\n- *    1.2.30rc01-08           13    10230  12.so.0.30[.0]\n- *    1.0.38                  10    10038  10.so.0.38[.0]\n- *    1.2.30                  13    10230  12.so.0.30[.0]\n- *    1.0.39rc01-03           10    10039  10.so.0.39[.0]\n- *    1.2.31rc01-03           13    10231  12.so.0.31[.0]\n- *    1.0.39                  10    10039  10.so.0.39[.0]\n- *    1.2.31                  13    10231  12.so.0.31[.0]\n- *    1.2.32beta01-02         13    10232  12.so.0.32[.0]\n- *    1.0.40rc01              10    10040  10.so.0.40[.0]\n- *    1.2.32rc01              13    10232  12.so.0.32[.0]\n- *    1.0.40                  10    10040  10.so.0.40[.0]\n- *    1.2.32                  13    10232  12.so.0.32[.0]\n- *    1.2.33beta01-02         13    10233  12.so.0.33[.0]\n- *    1.2.33rc01-02           13    10233  12.so.0.33[.0]\n- *    1.0.41rc01              10    10041  10.so.0.41[.0]\n- *    1.2.33                  13    10233  12.so.0.33[.0]\n- *    1.0.41                  10    10041  10.so.0.41[.0]\n- *    1.2.34beta01-07         13    10234  12.so.0.34[.0]\n- *    1.0.42rc01              10    10042  10.so.0.42[.0]\n- *    1.2.34rc01              13    10234  12.so.0.34[.0]\n- *    1.0.42                  10    10042  10.so.0.42[.0]\n- *    1.2.34                  13    10234  12.so.0.34[.0]\n- *    1.2.35beta01-03         13    10235  12.so.0.35[.0]\n- *    1.0.43rc01-02           10    10043  10.so.0.43[.0]\n- *    1.2.35rc01-02           13    10235  12.so.0.35[.0]\n- *    1.0.43                  10    10043  10.so.0.43[.0]\n- *    1.2.35                  13    10235  12.so.0.35[.0]\n- *    1.2.36beta01-05         13    10236  12.so.0.36[.0]\n- *    1.2.36rc01              13    10236  12.so.0.36[.0]\n- *    1.0.44                  10    10044  10.so.0.44[.0]\n- *    1.2.36                  13    10236  12.so.0.36[.0]\n- *    1.2.37beta01-03         13    10237  12.so.0.37[.0]\n- *    1.2.37rc01              13    10237  12.so.0.37[.0]\n- *    1.2.37                  13    10237  12.so.0.37[.0]\n- *    1.0.45                  10    10045  12.so.0.45[.0]\n- *    1.0.46                  10    10046  10.so.0.46[.0]\n- *    1.2.38beta01            13    10238  12.so.0.38[.0]\n- *    1.2.38rc01-03           13    10238  12.so.0.38[.0]\n- *    1.0.47                  10    10047  10.so.0.47[.0]\n- *    1.2.38                  13    10238  12.so.0.38[.0]\n- *    1.2.39beta01-05         13    10239  12.so.0.39[.0]\n- *    1.2.39rc01              13    10239  12.so.0.39[.0]\n- *    1.0.48                  10    10048  10.so.0.48[.0]\n- *    1.2.39                  13    10239  12.so.0.39[.0]\n- *    1.2.40beta01            13    10240  12.so.0.40[.0]\n- *    1.2.40rc01              13    10240  12.so.0.40[.0]\n- *    1.0.49                  10    10049  10.so.0.49[.0]\n- *    1.2.40                  13    10240  12.so.0.40[.0]\n- *    1.2.41beta01-18         13    10241  12.so.0.41[.0]\n- *    1.0.51rc01              10    10051  10.so.0.51[.0]\n- *    1.2.41rc01-03           13    10241  12.so.0.41[.0]\n- *    1.0.51                  10    10051  10.so.0.51[.0]\n- *    1.2.41                  13    10241  12.so.0.41[.0]\n- *    1.2.42beta01-02         13    10242  12.so.0.42[.0]\n- *    1.2.42rc01-05           13    10242  12.so.0.42[.0]\n- *    1.0.52                  10    10052  10.so.0.52[.0]\n- *    1.2.42                  13    10242  12.so.0.42[.0]\n- *    1.2.43beta01-05         13    10243  12.so.0.43[.0]\n- *    1.0.53rc01-02           10    10053  10.so.0.53[.0]\n- *    1.2.43rc01-02           13    10243  12.so.0.43[.0]\n- *    1.0.53                  10    10053  10.so.0.53[.0]\n- *    1.2.43                  13    10243  12.so.0.43[.0]\n- *    1.2.44beta01-03         13    10244  12.so.0.44[.0]\n- *    1.2.44rc01-03           13    10244  12.so.0.44[.0]\n- *    1.2.44                  13    10244  12.so.0.44[.0]\n- *    1.2.45beta01-03         13    10245  12.so.0.45[.0]\n- *    1.0.55rc01              10    10055  10.so.0.55[.0]\n- *    1.2.45rc01              13    10245  12.so.0.45[.0]\n- *    1.0.55                  10    10055  10.so.0.55[.0]\n- *    1.2.45                  13    10245  12.so.0.45[.0]\n- *    1.2.46rc01-02           13    10246  12.so.0.46[.0]\n- *    1.0.56                  10    10056  10.so.0.56[.0]\n- *    1.2.46                  13    10246  12.so.0.46[.0]\n- *    1.2.47beta01            13    10247  12.so.0.47[.0]\n- *    1.2.47rc01              13    10247  12.so.0.47[.0]\n- *    1.0.57rc01              10    10057  10.so.0.57[.0]\n- *    1.2.47                  13    10247  12.so.0.47[.0]\n- *    1.0.57                  10    10057  10.so.0.57[.0]\n- *    1.2.48beta01            13    10248  12.so.0.48[.0]\n- *    1.2.48rc01-02           13    10248  12.so.0.48[.0]\n- *    1.0.58                  10    10058  10.so.0.58[.0]\n- *    1.2.48                  13    10248  12.so.0.48[.0]\n- *    1.2.49rc01              13    10249  12.so.0.49[.0]\n- *    1.0.59                  10    10059  10.so.0.59[.0]\n- *    1.2.49                  13    10249  12.so.0.49[.0]\n- *    1.0.60                  10    10060  10.so.0.60[.0]\n- *    1.2.50                  13    10250  12.so.0.50[.0]\n- *    1.2.51beta01-05         13    10251  12.so.0.51[.0]\n- *    1.2.51rc01-04           13    10251  12.so.0.51[.0]\n- *    1.0.61                  10    10061  10.so.0.61[.0]\n- *    1.2.51                  13    10251  12.so.0.51[.0]\n- *    1.2.52beta01            13    10252  12.so.0.52[.0]\n- *    1.2.52rc01-02           13    10252  12.so.0.52[.0]\n- *    1.0.62                  10    10062  10.so.0.62[.0]\n- *    1.2.52                  13    10252  12.so.0.52[.0]\n- *\n- *    Henceforth the source version will match the shared-library major\n- *    and minor numbers; the shared-library major version number will be\n- *    used for changes in backward compatibility, as it is intended.  The\n- *    PNG_LIBPNG_VER macro, which is not used within libpng but is available\n- *    for applications, is an unsigned integer of the form xyyzz corresponding\n- *    to the source version x.y.z (leading zeros in y and z).  Beta versions\n- *    were given the previous public release number plus a letter, until\n- *    version 1.0.6j; from then on they were given the upcoming public\n- *    release number plus \""betaNN\"" or \""rcNN\"".\n- *\n- *    Binary incompatibility exists only when applications make direct access\n- *    to the info_ptr or png_ptr members through png.h, and the compiled\n- *    application is loaded with a different version of the library.\n- *\n- *    DLLNUM will change each time there are forward or backward changes\n- *    in binary compatibility (e.g., when a new feature is added).\n- *\n- * See libpng.txt or libpng.3 for more information.  The PNG specification\n- * is available as a W3C Recommendation and as an ISO Specification,\n- * <http://www.w3.org/TR/2003/REC-PNG-20031110/\n  */\n \n /*\n@@ -323,20 +24,15 @@\n  *\n  * This code is released under the libpng license.\n  *\n- * libpng versions 1.2.6, August 15, 2004, through 1.2.52, November 20, 2014, are\n- * Copyright (c) 2004, 2006-2013 Glenn Randers-Pehrson, and are\n- * distributed according to the same disclaimer and license as libpng-1.2.5\n- * with the following individual added to the list of Contributing Authors:\n- *\n- *    Cosmin Truta\n- *\n- * libpng versions 1.0.7, July 1, 2000, through 1.2.5, October 3, 2002, are\n- * Copyright (c) 2000-2002 Glenn Randers-Pehrson, and are\n- * distributed according to the same disclaimer and license as libpng-1.0.6\n- * with the following individuals added to the list of Contributing Authors:\n+ * libpng versions 1.0.7, July 1, 2000, through 1.2.54, November 12, 2015, are\n+ * Copyright (c) 2000-2002, 2004, 2006-2015 Glenn Randers-Pehrson, are\n+ * derived from libpng-1.0.6, and are distributed according to the same\n+ * disclaimer and license as libpng-1.0.6 with the following individuals\n+ * added to the list of Contributing Authors:\n  *\n  *    Simon-Pierre Cadieux\n  *    Eric S. Raymond\n+ *    Cosmin Truta\n  *    Gilles Vollant\n  *\n  * and with the following additions to the disclaimer:\n@@ -349,18 +45,20 @@\n  *    the user.\n  *\n  * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are\n- * Copyright (c) 1998, 1999, 2000 Glenn Randers-Pehrson, and are\n- * distributed according to the same disclaimer and license as libpng-0.96,\n- * with the following individuals added to the list of Contributing Authors:\n+ * Copyright (c) 1998-2000 Glenn Randers-Pehrson, are derived from\n+ * libpng-0.96, and are distributed according to the same disclaimer and\n+ * license as libpng-0.96, with the following individuals added to the list\n+ * of Contributing Authors:\n  *\n  *    Tom Lane\n  *    Glenn Randers-Pehrson\n  *    Willem van Schaik\n  *\n  * libpng versions 0.89, June 1996, through 0.96, May 1997, are\n- * Copyright (c) 1996, 1997 Andreas Dilger\n- * Distributed according to the same disclaimer and license as libpng-0.88,\n- * with the following individuals added to the list of Contributing Authors:\n+ * Copyright (c) 1996-1997 Andreas Dilger, are derived from libpng-0.88,\n+ * and are distributed according to the same disclaimer and license as\n+ * libpng-0.88, with the following individuals added to the list of\n+ * Contributing Authors:\n  *\n  *    John Bowler\n  *    Kevin Bracey\n@@ -370,7 +68,7 @@\n  *    Tom Tanner\n  *\n  * libpng versions 0.5, May 1995, through 0.88, January 1996, are\n- * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.\n+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n  *\n  * For the purposes of this copyright and license, \""Contributing Authors\""\n  * is defined as the following set of individuals:\n@@ -393,34 +91,37 @@\n  * source code, or portions hereof, for any purpose, without fee, subject\n  * to the following restrictions:\n  *\n- * 1. The origin of this source code must not be misrepresented.\n+ *   1. The origin of this source code must not be misrepresented.\n  *\n- * 2. Altered versions must be plainly marked as such and\n- * must not be misrepresented as being the original source.\n+ *   2. Altered versions must be plainly marked as such and must not\n+ *      be misrepresented as being the original source.\n  *\n- * 3. This Copyright notice may not be removed or altered from\n- *    any source or altered source distribution.\n+ *   3. This Copyright notice may not be removed or altered from any\n+ *      source or altered source distribution.\n  *\n  * The Contributing Authors and Group 42, Inc. specifically permit, without\n  * fee, and encourage the use of this source code as a component to\n  * supporting the PNG file format in commercial products.  If you use this\n  * source code in a product, acknowledgment is not required but would be\n  * appreciated.\n+ *\n+ * END OF COPYRIGHT NOTICE, DISCLAIMER, and LICENSE.\n  */\n \n /*\n  * A \""png_get_copyright\"" function is available, for convenient use in \""about\""\n  * boxes and the like:\n  *\n- * printf(\""%s\"",png_get_copyright(NULL));\n+ *    printf(\""%s\"", png_get_copyright(NULL));\n  *\n  * Also, the PNG logo (in PNG format, of course) is supplied in the\n  * files \""pngbar.png\"" and \""pngbar.jpg (88x31) and \""pngnow.png\"" (98x31).\n  */\n \n /*\n- * Libpng is OSI Certified Open Source Software.  OSI Certified is a\n- * certification mark of the Open Source Initiative.\n+ * Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is\n+ * a certification mark of the Open Source Initiative. OSI has not addressed\n+ * the additional disclaimers inserted at version 1.0.7.\n  */\n \n /*\n@@ -431,17 +132,89 @@\n  * Thanks to Frank J. T. Wojcik for helping with the documentation.\n  */\n \n+/* Note about libpng version numbers:\n+ *\n+ *    Due to various miscommunications, unforeseen code incompatibilities\n+ *    and occasional factors outside the authors' control, version numbering\n+ *    on the library has not always been consistent and straightforward.\n+ *    The following table summarizes matters since version 0.89c, which was\n+ *    the first widely used release:\n+ *\n+ *    source                 png.h  png.h  shared-lib\n+ *    version                string   int  version\n+ *    -------                ------ -----  ----------\n+ *    0.89c \""1.0 beta 3\""     0.89      89  1.0.89\n+ *    0.90  \""1.0 beta 4\""     0.90      90  0.90  [should have been 2.0.90]\n+ *    0.95  \""1.0 beta 5\""     0.95      95  0.95  [should have been 2.0.95]\n+ *    0.96  \""1.0 beta 6\""     0.96      96  0.96  [should have been 2.0.96]\n+ *    0.97b \""1.00.97 beta 7\"" 1.00.97   97  1.0.1 [should have been 2.0.97]\n+ *    0.97c                  0.97      97  2.0.97\n+ *    0.98                   0.98      98  2.0.98\n+ *    0.99                   0.99      98  2.0.99\n+ *    0.99a-m                0.99      99  2.0.99\n+ *    1.00                   1.00     100  2.1.0 [100 should be 10000]\n+ *    1.0.0      (from here on, the   100  2.1.0 [100 should be 10000]\n+ *    1.0.1       png.h string is   10001  2.1.0\n+ *    1.0.1a-e    identical to the  10002  from here on, the shared library\n+ *    1.0.2       source version)   10002  is 2.V where V is the source code\n+ *    1.0.2a-b                      10003  version, except as noted.\n+ *    1.0.3                         10003\n+ *    1.0.3a-d                      10004\n+ *    1.0.4                         10004\n+ *    1.0.4a-f                      10005\n+ *    1.0.5 (+ 2 patches)           10005\n+ *    1.0.5a-d                      10006\n+ *    1.0.5e-r                      10100 (not source compatible)\n+ *    1.0.5s-v                      10006 (not binary compatible)\n+ *    1.0.6 (+ 3 patches)           10006 (still binary incompatible)\n+ *    1.0.6d-f                      10007 (still binary incompatible)\n+ *    1.0.6g                        10007\n+ *    1.0.6h                        10007  10.6h (testing xy.z so-numbering)\n+ *    1.0.6i                        10007  10.6i\n+ *    1.0.6j                        10007  2.1.0.6j (incompatible with 1.0.0)\n+ *    1.0.7beta11-14        DLLNUM  10007  2.1.0.7beta11-14 (binary compatible)\n+ *    1.0.7beta15-18           1    10007  2.1.0.7beta15-18 (binary compatible)\n+ *    1.0.7rc1-2               1    10007  2.1.0.7rc1-2 (binary compatible)\n+ *    1.0.7                    1    10007  (still compatible)\n+ *    ...\n+ *    1.0.19                  10    10019  10.so.0.19[.0]\n+ *    ...\n+ *    1.0.64                  10    10064  10.so.0.64[.0]\n+ *    1.2.54                  13    10254  12.so.0.54[.0]\n+ *\n+ *    Henceforth the source version will match the shared-library major\n+ *    and minor numbers; the shared-library major version number will be\n+ *    used for changes in backward compatibility, as it is intended.  The\n+ *    PNG_LIBPNG_VER macro, which is not used within libpng but is available\n+ *    for applications, is an unsigned integer of the form xyyzz corresponding\n+ *    to the source version x.y.z (leading zeros in y and z).  Beta versions\n+ *    were given the previous public release number plus a letter, until\n+ *    version 1.0.6j; from then on they were given the upcoming public\n+ *    release number plus \""betaNN\"" or \""rcNN\"".\n+ *\n+ *    Binary incompatibility exists only when applications make direct access\n+ *    to the info_ptr or png_ptr members through png.h, and the compiled\n+ *    application is loaded with a different version of the library.\n+ *\n+ *    DLLNUM will change each time there are forward or backward changes\n+ *    in binary compatibility (e.g., when a new feature is added).\n+ *\n+ * See libpng.txt or libpng.3 for more information.  The PNG specification\n+ * is available as a W3C Recommendation and as an ISO Specification,\n+ * <http://www.w3.org/TR/2003/REC-PNG-20031110/\n+ */\n+\n /*\n  * Y2K compliance in libpng:\n  * =========================\n  *\n- *    November 20, 2014\n+ *    November 12, 2015\n  *\n  *    Since the PNG Development group is an ad-hoc body, we can't make\n  *    an official declaration.\n  *\n  *    This is your unofficial assurance that libpng from version 0.71 and\n- *    upward through 1.2.52 are Y2K compliant.  It is my belief that earlier\n+ *    upward through 1.2.54 are Y2K compliant.  It is my belief that earlier\n  *    versions were also Y2K compliant.\n  *\n  *    Libpng only has three year fields.  One is a 2-byte unsigned integer\n@@ -497,17 +270,17 @@\n  */\n \n /* Version information for png.h - this should match the version in png.c */\n-#define PNG_LIBPNG_VER_STRING \""1.2.52\""\n+#define PNG_LIBPNG_VER_STRING \""1.2.54\""\n #define PNG_HEADER_VERSION_STRING \\\n-   \"" libpng version 1.2.52 - November 20, 2014\\n\""\n+   \"" libpng version 1.2.54 - November 12, 2015\\n\""\n \n #define PNG_LIBPNG_VER_SONUM   0\n #define PNG_LIBPNG_VER_DLLNUM  13\n \n /* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */\n #define PNG_LIBPNG_VER_MAJOR   1\n #define PNG_LIBPNG_VER_MINOR   2\n-#define PNG_LIBPNG_VER_RELEASE 52\n+#define PNG_LIBPNG_VER_RELEASE 54\n /* This should match the numeric part of the final component of\n  * PNG_LIBPNG_VER_STRING, omitting any leading zero:\n  */\n@@ -537,7 +310,7 @@\n  * version 1.0.0 was mis-numbered 100 instead of 10000).  From\n  * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release\n  */\n-#define PNG_LIBPNG_VER 10252 /* 1.2.52 */\n+#define PNG_LIBPNG_VER 10254 /* 1.2.54 */\n \n #ifndef PNG_VERSION_INFO_ONLY\n /* Include the compression library's header */\n@@ -1453,16 +1226,6 @@ struct png_struct_def\n    png_uint_16p hist PNG_DEPSTRUCT;                /* histogram */\n #endif\n \n-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n-   png_byte heuristic_method PNG_DEPSTRUCT;        /* heuristic for row filter selection */\n-   png_byte num_prev_filters PNG_DEPSTRUCT;        /* number of weights for previous rows */\n-   png_bytep prev_filters PNG_DEPSTRUCT;           /* filter type(s) of previous row(s) */\n-   png_uint_16p filter_weights PNG_DEPSTRUCT;      /* weight(s) for previous line(s) */\n-   png_uint_16p inv_filter_weights PNG_DEPSTRUCT;  /* 1/weight(s) for previous line(s) */\n-   png_uint_16p filter_costs PNG_DEPSTRUCT;        /* relative filter calculation cost */\n-   png_uint_16p inv_filter_costs PNG_DEPSTRUCT;    /* 1/relative filter calculation cost */\n-#endif\n-\n #ifdef PNG_TIME_RFC1123_SUPPORTED\n    png_charp time_buffer PNG_DEPSTRUCT;            /* String to hold RFC 1123 time text */\n #endif\n@@ -1577,7 +1340,7 @@ struct png_struct_def\n /* This triggers a compiler error in png.c, if png.c and png.h\n  * do not agree upon the version number.\n  */\n-typedef png_structp version_1_2_52;\n+typedef png_structp version_1_2_54;\n \n typedef png_struct FAR * FAR * png_structpp;\n \n@@ -1978,45 +1741,15 @@ extern PNG_EXPORT(void,png_set_filter) PNGARG((png_structp png_ptr, int method,\n #define PNG_FILTER_VALUE_PAETH 4\n #define PNG_FILTER_VALUE_LAST  5\n \n-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED) /* EXPERIMENTAL */\n-/* The \""heuristic_method\"" is given by one of the PNG_FILTER_HEURISTIC_\n- * defines, either the default (minimum-sum-of-absolute-differences), or\n- * the experimental method (weighted-minimum-sum-of-absolute-differences).\n- *\n- * Weights are factors >= 1.0, indicating how important it is to keep the\n- * filter type consistent between rows.  Larger numbers mean the current\n- * filter is that many times as likely to be the same as the \""num_weights\""\n- * previous filters.  This is cumulative for each previous row with a weight.\n- * There needs to be \""num_weights\"" values in \""filter_weights\"", or it can be\n- * NULL if the weights aren't being specified.  Weights have no influence on\n- * the selection of the first row filter.  Well chosen weights can (in theory)\n- * improve the compression for a given image.\n- *\n- * Costs are factors >= 1.0 indicating the relative decoding costs of a\n- * filter type.  Higher costs indicate more decoding expense, and are\n- * therefore less likely to be selected over a filter with lower computational\n- * costs.  There needs to be a value in \""filter_costs\"" for each valid filter\n- * type (given by PNG_FILTER_VALUE_LAST), or it can be NULL if you aren't\n- * setting the costs.  Costs try to improve the speed of decompression without\n- * unduly increasing the compressed image size.\n- *\n- * A negative weight or cost indicates the default value is to be used, and\n- * values in the range [0.0, 1.0) indicate the value is to remain unchanged.\n- * The default values for both weights and costs are currently 1.0, but may\n- * change if good general weighting/cost heuristics can be found.  If both\n- * the weights and costs are set to 1.0, this degenerates the WEIGHTED method\n- * to the UNWEIGHTED method, but with added encoding time/computation.\n- */\n+#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED) /* DEPRECATED */\n #ifdef PNG_FLOATING_POINT_SUPPORTED\n extern PNG_EXPORT(void,png_set_filter_heuristics) PNGARG((png_structp png_ptr,\n    int heuristic_method, int num_weights, png_doublep filter_weights,\n    png_doublep filter_costs));\n #endif\n #endif /*  PNG_WRITE_WEIGHTED_FILTER_SUPPORTED */\n \n-/* Heuristic used for row filter selection.  These defines should NOT be\n- * changed.\n- */\n+/* The following are no longer used and will be removed from libpng-1.7: */\n #define PNG_FILTER_HEURISTIC_DEFAULT    0  /* Currently \""UNWEIGHTED\"" */\n #define PNG_FILTER_HEURISTIC_UNWEIGHTED 1  /* Used by libpng < 0.95 */\n #define PNG_FILTER_HEURISTIC_WEIGHTED   2  /* Experimental feature */""}<_**next**_>{""sha"": ""3d1be6b842dfe377dbe117f2e23b800e3173674a"", ""filename"": ""third_party/libpng/pngconf.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngconf.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngconf.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libpng/pngconf.h?ref=7f3d85b096f66870a15b37c2f40b219b2e292693"", ""patch"": ""@@ -1,17 +1,17 @@\n \n /* pngconf.h - machine configurable file for libpng\n  *\n- * libpng version 1.2.52 - November 20, 2014\n- * Copyright (c) 1998-2013 Glenn Randers-Pehrson\n+ * libpng version 1.2.54, November 12, 2015\n+ *\n+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson\n  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\n  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\n  *\n  * This code is released under the libpng license.\n  * For conditions of distribution and use, see the disclaimer\n  * and license in png.h\n- */\n-\n-/* Any machine specific code is near the front of this file, so if you\n+ *\n+ * Any machine specific code is near the front of this file, so if you\n  * are configuring libpng for a machine, you may want to read the section\n  * starting here down to where it starts to typedef png_color, png_text,\n  * and png_info.\n@@ -885,7 +885,7 @@\n \n /* Added at libpng-1.2.43 */\n #ifndef PNG_USER_CHUNK_MALLOC_MAX\n-#  define PNG_USER_CHUNK_MALLOC_MAX 0\n+#  define PNG_USER_CHUNK_MALLOC_MAX 8000000\n #endif\n \n #ifndef PNG_LITERAL_SHARP""}<_**next**_>{""sha"": ""78c3ea7842e8f0fc5a3c2c7481470afcf66f8ea0"", ""filename"": ""third_party/libpng/pngget.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 5, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngget.c"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngget.c"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libpng/pngget.c?ref=7f3d85b096f66870a15b37c2f40b219b2e292693"", ""patch"": ""@@ -1,8 +1,8 @@\n \n /* pngget.c - retrieval of values from info struct\n  *\n- * Last changed in libpng 1.2.51 [February 6, 2014]\n- * Copyright (c) 1998-2014 Glenn Randers-Pehrson\n+ * Last changed in libpng 1.2.53 [February 26, 2015]\n+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson\n  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\n  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\n  *\n@@ -885,7 +885,8 @@ png_uint_32 PNGAPI\n png_get_asm_flags (png_structp png_ptr)\n {\n     /* Obsolete, to be removed from libpng-1.4.0 */\n-    return (png_ptr? 0L: 0L);\n+    PNG_UNUSED(png_ptr)\n+    return 0L;\n }\n \n /* This function was added to libpng 1.2.0 and should exist by default */\n@@ -913,15 +914,17 @@ png_byte PNGAPI\n png_get_mmx_bitdepth_threshold (png_structp png_ptr)\n {\n     /* Obsolete, to be removed from libpng-1.4.0 */\n-    return (png_ptr? 0: 0);\n+    PNG_UNUSED(png_ptr)\n+    return 0L;\n }\n \n /* This function was added to libpng 1.2.0 */\n png_uint_32 PNGAPI\n png_get_mmx_rowbytes_threshold (png_structp png_ptr)\n {\n     /* Obsolete, to be removed from libpng-1.4.0 */\n-    return (png_ptr? 0L: 0L);\n+    PNG_UNUSED(png_ptr)\n+    return 0L;\n }\n #endif /* ?PNG_1_0_X */\n #endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */""}<_**next**_>{""sha"": ""419995eab9fc7ab04aa9bbc90e9122b3f514bcd0"", ""filename"": ""third_party/libpng/pngpread.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngpread.c"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngpread.c"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libpng/pngpread.c?ref=7f3d85b096f66870a15b37c2f40b219b2e292693"", ""patch"": ""@@ -685,9 +685,12 @@ png_push_save_buffer(png_structp png_ptr)\n         png_free(png_ptr, old_buffer);\n         png_error(png_ptr, \""Insufficient memory for save_buffer\"");\n       }\n-      png_memcpy(png_ptr->save_buffer, old_buffer, png_ptr->save_buffer_size);\n-      png_free(png_ptr, old_buffer);\n-      png_ptr->save_buffer_max = new_max;\n+      else\n+      {\n+        png_memcpy(png_ptr->save_buffer, old_buffer, png_ptr->save_buffer_size);\n+        png_free(png_ptr, old_buffer);\n+        png_ptr->save_buffer_max = new_max;\n+      }\n    }\n    if (png_ptr->current_buffer_size)\n    {""}<_**next**_>{""sha"": ""c597045fea684cd3c584227d006e663340547d4a"", ""filename"": ""third_party/libpng/pngread.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngread.c"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngread.c"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libpng/pngread.c?ref=7f3d85b096f66870a15b37c2f40b219b2e292693"", ""patch"": ""@@ -1,8 +1,8 @@\n \n /* pngread.c - read a PNG file\n  *\n- * Last changed in libpng 1.2.52 [November 20, 2014]\n- * Copyright (c) 1998-2014 Glenn Randers-Pehrson\n+ * Last changed in libpng 1.2.53 [February 26, 2015]\n+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson\n  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\n  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\n  *\n@@ -274,7 +274,7 @@ png_read_init_3(png_structpp ptr_ptr, png_const_charp user_png_ver,\n \n    do\n    {\n-      if (user_png_ver[i] != png_libpng_ver[i])\n+      if (user_png_ver == NULL || user_png_ver[i] != png_libpng_ver[i])\n       {\n #ifdef PNG_LEGACY_SUPPORTED\n         png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;\n@@ -597,10 +597,12 @@ png_start_read_image(png_structp png_ptr)\n void PNGAPI\n png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)\n {\n+#ifndef PNG_USE_GLOBAL_ARRAYS\n    PNG_CONST PNG_IDAT;\n    PNG_CONST int png_pass_dsp_mask[7] = {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55,\n       0xff};\n    PNG_CONST int png_pass_mask[7] = {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};\n+#endif\n    int ret;\n  \n    if (png_ptr == NULL)""}<_**next**_>{""sha"": ""348a8b13da5701176038666b5869923a490e3d0a"", ""filename"": ""third_party/libpng/pngrtran.c"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 12, ""changes"": 36, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngrtran.c"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngrtran.c"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libpng/pngrtran.c?ref=7f3d85b096f66870a15b37c2f40b219b2e292693"", ""patch"": ""@@ -1,8 +1,8 @@\n \n /* pngrtran.c - transforms the data in a row for PNG readers\n  *\n- * Last changed in libpng 1.2.51 [February 6, 2014]\n- * Copyright (c) 1998-2014 Glenn Randers-Pehrson\n+ * Last changed in libpng 1.2.53 [February 26, 2015]\n+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson\n  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\n  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\n  *\n@@ -2410,10 +2410,14 @@ png_do_rgb_to_gray(png_structp png_ptr, png_row_infop row_info, png_bytep row)\n                for (i = 0; i < row_width; i++)\n                {\n                   png_uint_16 red, green, blue, w;\n+                  png_byte hi,lo;\n \n-                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n-                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n-                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n+                  hi=*(sp)++; lo=*(sp)++;\n+                  red   = (png_uint_16)((hi << 8) | (lo));\n+                  hi=*(sp)++; lo=*(sp)++;\n+                  green = (png_uint_16)((hi << 8) | (lo));\n+                  hi=*(sp)++; lo=*(sp)++;\n+                  blue  = (png_uint_16)((hi << 8) | (lo));\n \n                   if (red == green && red == blue)\n                      w = red;\n@@ -2445,10 +2449,14 @@ png_do_rgb_to_gray(png_structp png_ptr, png_row_infop row_info, png_bytep row)\n                for (i = 0; i < row_width; i++)\n                {\n                   png_uint_16 red, green, blue, gray16;\n+                  png_byte hi,lo;\n \n-                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n-                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n-                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n+                  hi=*(sp)++; lo=*(sp)++;\n+                  red   = (png_uint_16)((hi << 8) | (lo));\n+                  hi=*(sp)++; lo=*(sp)++;\n+                  green = (png_uint_16)((hi << 8) | (lo));\n+                  hi=*(sp)++; lo=*(sp)++;\n+                  blue  = (png_uint_16)((hi << 8) | (lo));\n \n                   if (red != green || red != blue)\n                      rgb_error |= 1;\n@@ -2508,10 +2516,14 @@ png_do_rgb_to_gray(png_structp png_ptr, png_row_infop row_info, png_bytep row)\n                for (i = 0; i < row_width; i++)\n                {\n                   png_uint_16 red, green, blue, w;\n-\n-                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n-                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n-                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n+                  png_byte hi,lo;\n+\n+                  hi=*(sp)++; lo=*(sp)++;\n+                  red   = (png_uint_16)((hi << 8) | (lo));\n+                  hi=*(sp)++; lo=*(sp)++;\n+                  green = (png_uint_16)((hi << 8) | (lo));\n+                  hi=*(sp)++; lo=*(sp)++;\n+                  blue  = (png_uint_16)((hi << 8) | (lo));\n \n                   if (red == green && red == blue)\n                      w = red;""}<_**next**_>{""sha"": ""50cc97196cf8df284470508c23bbe94849f25390"", ""filename"": ""third_party/libpng/pngrutil.c"", ""status"": ""modified"", ""additions"": 46, ""deletions"": 23, ""changes"": 69, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngrutil.c"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngrutil.c"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libpng/pngrutil.c?ref=7f3d85b096f66870a15b37c2f40b219b2e292693"", ""patch"": ""@@ -1,8 +1,8 @@\n \n /* pngrutil.c - utilities to read a PNG file\n  *\n- * Last changed in libpng 1.2.51 [February 6, 2014]\n- * Copyright (c) 1998-2014 Glenn Randers-Pehrson\n+ * Last changed in libpng 1.2.54 [November 12, 2015]\n+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson\n  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\n  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\n  *\n@@ -57,24 +57,24 @@ png_get_uint_31(png_structp png_ptr, png_bytep buf)\n    png_uint_32 i = png_get_uint_32(buf);\n #else\n    /* Avoid an extra function call by inlining the result. */\n-   png_uint_32 i = ((png_uint_32)(*buf) << 24) +\n-      ((png_uint_32)(*(buf + 1)) << 16) +\n-      ((png_uint_32)(*(buf + 2)) << 8) +\n-      (png_uint_32)(*(buf + 3));\n+   png_uint_32 i = ((png_uint_32)((*(buf    )) & 0xff) << 24) +\n+                   ((png_uint_32)((*(buf + 1)) & 0xff) << 16) +\n+                   ((png_uint_32)((*(buf + 2)) & 0xff) <<  8) +\n+                   ((png_uint_32)((*(buf + 3)) & 0xff)      );\n #endif\n    if (i > PNG_UINT_31_MAX)\n-     png_error(png_ptr, \""PNG unsigned integer out of range.\"");\n+      png_error(png_ptr, \""PNG unsigned integer out of range.\"");\n    return (i);\n }\n #ifndef PNG_READ_BIG_ENDIAN_SUPPORTED\n /* Grab an unsigned 32-bit integer from a buffer in big-endian format. */\n png_uint_32 PNGAPI\n png_get_uint_32(png_bytep buf)\n {\n-   png_uint_32 i = ((png_uint_32)(*buf) << 24) +\n-      ((png_uint_32)(*(buf + 1)) << 16) +\n-      ((png_uint_32)(*(buf + 2)) << 8) +\n-      (png_uint_32)(*(buf + 3));\n+   png_uint_32 i = ((png_uint_32)((*(buf    )) & 0xff) << 24) +\n+                   ((png_uint_32)((*(buf + 1)) & 0xff) << 16) +\n+                   ((png_uint_32)((*(buf + 2)) & 0xff) <<  8) +\n+                   ((png_uint_32)((*(buf + 3)) & 0xff)      );\n \n    return (i);\n }\n@@ -86,10 +86,10 @@ png_get_uint_32(png_bytep buf)\n png_int_32 PNGAPI\n png_get_int_32(png_bytep buf)\n {\n-   png_int_32 i = ((png_int_32)(*buf) << 24) +\n-      ((png_int_32)(*(buf + 1)) << 16) +\n-      ((png_int_32)(*(buf + 2)) << 8) +\n-      (png_int_32)(*(buf + 3));\n+   png_int_32 i = ((png_int_32)((*(buf    )) & 0xff) << 24) +\n+                  ((png_int_32)((*(buf + 1)) & 0xff) << 16) +\n+                  ((png_int_32)((*(buf + 2)) & 0xff) <<  8) +\n+                  ((png_int_32)((*(buf + 3)) & 0xff)      );\n \n    return (i);\n }\n@@ -98,8 +98,8 @@ png_get_int_32(png_bytep buf)\n png_uint_16 PNGAPI\n png_get_uint_16(png_bytep buf)\n {\n-   png_uint_16 i = (png_uint_16)(((png_uint_16)(*buf) << 8) +\n-      (png_uint_16)(*(buf + 1)));\n+   png_uint_16 i = ((png_uint_16)((*(buf     )) & 0xff) << 8) +\n+                   ((png_uint_16)((*(buf +  1)) & 0xff)     );\n \n    return (i);\n }\n@@ -294,12 +294,15 @@ png_inflate(png_structp png_ptr, const png_byte *data, png_size_t size,\n \n             png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name);\n             msg = umsg;\n+            png_warning(png_ptr, msg);\n #else\n             msg = \""Damaged compressed datastream in chunk other than IDAT\"";\n #endif\n          }\n \n+#ifndef PNG_STDIO_SUPPORTED\n          png_warning(png_ptr, msg);\n+#endif\n       }\n \n       /* 0 means an error - notice that this code simple ignores\n@@ -503,7 +506,7 @@ void /* PRIVATE */\n png_handle_PLTE(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n {\n    png_color palette[PNG_MAX_PALETTE_LENGTH];\n-   int num, i;\n+   int max_palette_length, num, i;\n #ifdef PNG_POINTER_INDEXING_SUPPORTED\n    png_colorp pal_ptr;\n #endif\n@@ -555,8 +558,22 @@ png_handle_PLTE(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n       }\n    }\n \n+   /* The cast is safe because 'length' is less than 3*PNG_MAX_PALETTE_LENGTH */\n    num = (int)length / 3;\n \n+   /* If the palette has 256 or fewer entries but is too large for the bit\n+    * depth, we don't issue an error, to preserve the behavior of previous\n+    * libpng versions. We silently truncate the unused extra palette entries\n+    * here.\n+    */\n+   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n+      max_palette_length = (1 << png_ptr->bit_depth);\n+   else\n+      max_palette_length = PNG_MAX_PALETTE_LENGTH;\n+\n+   if (num > max_palette_length)\n+      num = max_palette_length;\n+\n #ifdef PNG_POINTER_INDEXING_SUPPORTED\n    for (i = 0, pal_ptr = palette; i < num; i++, pal_ptr++)\n    {\n@@ -589,7 +606,7 @@ png_handle_PLTE(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n    if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n #endif\n    {\n-      png_crc_finish(png_ptr, 0);\n+      png_crc_finish(png_ptr, (int) length - num * 3);\n    }\n #ifndef PNG_READ_OPT_PLTE_SUPPORTED\n    else if (png_crc_error(png_ptr))  /* Only if we have a CRC error */\n@@ -1130,10 +1147,10 @@ png_handle_iCCP(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n \n    /* Check the profile_size recorded in the first 32 bits of the ICC profile */\n    pC = (png_bytep)(png_ptr->chunkdata + prefix_length);\n-   profile_size = ((*(pC    ))<<24) |\n-                  ((*(pC + 1))<<16) |\n-                  ((*(pC + 2))<< 8) |\n-                  ((*(pC + 3))    );\n+   profile_size = ((png_uint_32) (*(pC    )<<24)) |\n+                  ((png_uint_32) (*(pC + 1)<<16)) |\n+                  ((png_uint_32) (*(pC + 2)<< 8)) |\n+                  ((png_uint_32) (*(pC + 3)    ));\n \n    if (profile_size < profile_length)\n       profile_length = profile_size;\n@@ -2714,7 +2731,9 @@ png_do_read_interlace(png_structp png_ptr)\n    png_uint_32 transformations = png_ptr->transformations;\n    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n    /* Offset to next interlace block */\n+#ifndef PNG_USE_GLOBAL_ARRAYS\n    PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n+#endif\n \n    png_debug(1, \""in png_do_read_interlace\"");\n    if (row != NULL && row_info != NULL)\n@@ -3054,6 +3073,7 @@ void /* PRIVATE */\n png_read_finish_row(png_structp png_ptr)\n {\n #ifdef PNG_READ_INTERLACING_SUPPORTED\n+#ifndef PNG_USE_GLOBAL_ARRAYS\n    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n \n    /* Start of interlace block */\n@@ -3067,6 +3087,7 @@ png_read_finish_row(png_structp png_ptr)\n \n    /* Offset to next interlace block in the y direction */\n    PNG_CONST int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n+#endif\n #endif /* PNG_READ_INTERLACING_SUPPORTED */\n \n    png_debug(1, \""in png_read_finish_row\"");\n@@ -3182,6 +3203,7 @@ void /* PRIVATE */\n png_read_start_row(png_structp png_ptr)\n {\n #ifdef PNG_READ_INTERLACING_SUPPORTED\n+#ifndef PNG_USE_GLOBAL_ARRAYS\n    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n \n    /* Start of interlace block */\n@@ -3195,6 +3217,7 @@ png_read_start_row(png_structp png_ptr)\n \n    /* Offset to next interlace block in the y direction */\n    PNG_CONST int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n+#endif\n #endif\n \n    int max_pixel_depth;""}<_**next**_>{""sha"": ""7735e608d221002cd6086e283c79f44d20ff7985"", ""filename"": ""third_party/libpng/pngset.c"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 7, ""changes"": 31, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngset.c"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngset.c"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libpng/pngset.c?ref=7f3d85b096f66870a15b37c2f40b219b2e292693"", ""patch"": ""@@ -1,8 +1,8 @@\n \n /* pngset.c - storage of image information into info struct\n  *\n- * Last changed in libpng 1.2.51 [February 6, 2014]\n- * Copyright (c) 1998-2014 Glenn Randers-Pehrson\n+ * Last changed in libpng 1.2.54 [November 12, 2015]\n+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson\n  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\n  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\n  *\n@@ -263,7 +263,10 @@ png_set_IHDR(png_structp png_ptr, png_infop info_ptr,\n                  - 1        /* filter byte */\n                  - 7*8      /* rounding of width to multiple of 8 pixels */\n                  - 8)       /* extra max_pixel_depth pad */\n+   {\n       info_ptr->rowbytes = (png_size_t)0;\n+      png_error(png_ptr, \""Image width is too large for this architecture\"");\n+   }\n    else\n       info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);\n }\n@@ -446,12 +449,17 @@ png_set_PLTE(png_structp png_ptr, png_infop info_ptr,\n    png_colorp palette, int num_palette)\n {\n \n+   png_uint_32 max_palette_length;\n+\n    png_debug1(1, \""in %s storage function\"", \""PLTE\"");\n \n    if (png_ptr == NULL || info_ptr == NULL)\n       return;\n \n-   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)\n+   max_palette_length = (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?\n+      (1 << png_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;\n+\n+   if (num_palette < 0 || num_palette > (int) max_palette_length)\n    {\n       if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n          png_error(png_ptr, \""Invalid palette length\"");\n@@ -471,8 +479,8 @@ png_set_PLTE(png_structp png_ptr, png_infop info_ptr,\n #endif\n \n    /* Changed in libpng-1.2.1 to allocate PNG_MAX_PALETTE_LENGTH instead\n-    * of num_palette entries, in case of an invalid PNG file that has\n-    * too-large sample values.\n+    * of num_palette entries, in case of an invalid PNG file or incorrect\n+    * call to png_set_PLTE() with too-large sample values.\n     */\n    png_ptr->palette = (png_colorp)png_calloc(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * png_sizeof(png_color));\n@@ -770,10 +778,10 @@ png_set_text_2(png_structp png_ptr, png_infop info_ptr, png_textp text_ptr,\n          (key_len + text_length + lang_len + lang_key_len + 4));\n       if (textp->key == NULL)\n          return(1);\n-      png_debug2(2, \""Allocated %lu bytes at %x in png_set_text\"",\n+      png_debug2(2, \""Allocated %lu bytes at %p in png_set_text\"",\n                  (png_uint_32)\n                  (key_len + lang_len + lang_key_len + text_length + 4),\n-                 (int)textp->key);\n+                 textp->key);\n \n       png_memcpy(textp->key, text_ptr[i].key,(png_size_t)(key_len));\n       *(textp->key + key_len) = '\\0';\n@@ -834,6 +842,15 @@ png_set_tIME(png_structp png_ptr, png_infop info_ptr, png_timep mod_time)\n        (png_ptr->mode & PNG_WROTE_tIME))\n       return;\n \n+   if (mod_time->month == 0   || mod_time->month > 12  ||\n+       mod_time->day   == 0   || mod_time->day   > 31  ||\n+       mod_time->hour  > 23   || mod_time->minute > 59 ||\n+       mod_time->second > 60)\n+   {\n+      png_warning(png_ptr, \""Ignoring invalid time value\"");\n+      return;\n+   }\n+\n    png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof(png_time));\n    info_ptr->valid |= PNG_INFO_tIME;\n }""}<_**next**_>{""sha"": ""2dffc589f8b41e5ca4a897fd2d073da52cf8dab2"", ""filename"": ""third_party/libpng/pngwrite.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 134, ""changes"": 145, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngwrite.c"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngwrite.c"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libpng/pngwrite.c?ref=7f3d85b096f66870a15b37c2f40b219b2e292693"", ""patch"": ""@@ -1,8 +1,8 @@\n \n /* pngwrite.c - general routines to write a PNG file\n  *\n- * Last changed in libpng 1.2.52 [November 20, 2014]\n- * Copyright (c) 1998-2014 Glenn Randers-Pehrson\n+ * Last changed in libpng 1.2.54 [November 12, 2015]\n+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson\n  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\n  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\n  *\n@@ -584,11 +584,6 @@ png_create_write_struct_2(png_const_charp user_png_ver, png_voidp error_ptr,\n    png_set_write_fn(png_ptr, png_voidp_NULL, png_rw_ptr_NULL,\n       png_flush_ptr_NULL);\n \n-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n-   png_set_filter_heuristics(png_ptr, PNG_FILTER_HEURISTIC_DEFAULT,\n-      1, png_doublep_NULL, png_doublep_NULL);\n-#endif\n-\n #ifdef PNG_SETJMP_SUPPORTED\n    /* Applications that neglect to set up their own setjmp() and then\n     * encounter a png_error() will longjmp here.  Since the jmpbuf is\n@@ -731,10 +726,6 @@ png_write_init_3(png_structpp ptr_ptr, png_const_charp user_png_ver,\n    png_ptr->zbuf_size = PNG_ZBUF_SIZE;\n    png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,\n      (png_uint_32)png_ptr->zbuf_size);\n-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n-   png_set_filter_heuristics(png_ptr, PNG_FILTER_HEURISTIC_DEFAULT,\n-      1, png_doublep_NULL, png_doublep_NULL);\n-#endif\n }\n \n /* Write a few rows of image data.  If the image is interlaced,\n@@ -1150,14 +1141,6 @@ png_write_destroy(png_structp png_ptr)\n    png_free(png_ptr, png_ptr->time_buffer);\n #endif\n \n-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n-   png_free(png_ptr, png_ptr->prev_filters);\n-   png_free(png_ptr, png_ptr->filter_weights);\n-   png_free(png_ptr, png_ptr->inv_filter_weights);\n-   png_free(png_ptr, png_ptr->filter_costs);\n-   png_free(png_ptr, png_ptr->inv_filter_costs);\n-#endif\n-\n #ifdef PNG_SETJMP_SUPPORTED\n    /* Reset structure */\n    png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));\n@@ -1201,14 +1184,13 @@ png_set_filter(png_structp png_ptr, int method, int filters)\n    {\n       switch (filters & (PNG_ALL_FILTERS | 0x07))\n       {\n+         case PNG_FILTER_VALUE_NONE:\n+              png_ptr->do_filter = PNG_FILTER_NONE; break;\n #ifdef PNG_WRITE_FILTER_SUPPORTED\n          case 5:\n          case 6:\n          case 7: png_warning(png_ptr, \""Unknown row filter for method 0\"");\n-#endif /* PNG_WRITE_FILTER_SUPPORTED */\n-         case PNG_FILTER_VALUE_NONE:\n-              png_ptr->do_filter = PNG_FILTER_NONE; break;\n-#ifdef PNG_WRITE_FILTER_SUPPORTED\n+                 break;\n          case PNG_FILTER_VALUE_SUB:\n               png_ptr->do_filter = PNG_FILTER_SUB; break;\n          case PNG_FILTER_VALUE_UP:\n@@ -1220,6 +1202,7 @@ png_set_filter(png_structp png_ptr, int method, int filters)\n          default: png_ptr->do_filter = (png_byte)filters; break;\n #else\n          default: png_warning(png_ptr, \""Unknown row filter for method 0\"");\n+                 break;\n #endif /* PNG_WRITE_FILTER_SUPPORTED */\n       }\n \n@@ -1310,117 +1293,11 @@ png_set_filter_heuristics(png_structp png_ptr, int heuristic_method,\n    int num_weights, png_doublep filter_weights,\n    png_doublep filter_costs)\n {\n-   int i;\n-\n-   png_debug(1, \""in png_set_filter_heuristics\"");\n-\n-   if (png_ptr == NULL)\n-      return;\n-   if (heuristic_method >= PNG_FILTER_HEURISTIC_LAST)\n-   {\n-      png_warning(png_ptr, \""Unknown filter heuristic method\"");\n-      return;\n-   }\n-\n-   if (heuristic_method == PNG_FILTER_HEURISTIC_DEFAULT)\n-   {\n-      heuristic_method = PNG_FILTER_HEURISTIC_UNWEIGHTED;\n-   }\n-\n-   if (num_weights < 0 || filter_weights == NULL ||\n-      heuristic_method == PNG_FILTER_HEURISTIC_UNWEIGHTED)\n-   {\n-      num_weights = 0;\n-   }\n-\n-   png_ptr->num_prev_filters = (png_byte)num_weights;\n-   png_ptr->heuristic_method = (png_byte)heuristic_method;\n-\n-   if (num_weights > 0)\n-   {\n-      if (png_ptr->prev_filters == NULL)\n-      {\n-         png_ptr->prev_filters = (png_bytep)png_malloc(png_ptr,\n-            (png_uint_32)(png_sizeof(png_byte) * num_weights));\n-\n-         /* To make sure that the weighting starts out fairly */\n-         for (i = 0; i < num_weights; i++)\n-         {\n-            png_ptr->prev_filters[i] = 255;\n-         }\n-      }\n-\n-      if (png_ptr->filter_weights == NULL)\n-      {\n-         png_ptr->filter_weights = (png_uint_16p)png_malloc(png_ptr,\n-            (png_uint_32)(png_sizeof(png_uint_16) * num_weights));\n-\n-         png_ptr->inv_filter_weights = (png_uint_16p)png_malloc(png_ptr,\n-            (png_uint_32)(png_sizeof(png_uint_16) * num_weights));\n-         for (i = 0; i < num_weights; i++)\n-         {\n-            png_ptr->inv_filter_weights[i] =\n-            png_ptr->filter_weights[i] = PNG_WEIGHT_FACTOR;\n-         }\n-      }\n-\n-      for (i = 0; i < num_weights; i++)\n-      {\n-         if (filter_weights[i] < 0.0)\n-         {\n-            png_ptr->inv_filter_weights[i] =\n-            png_ptr->filter_weights[i] = PNG_WEIGHT_FACTOR;\n-         }\n-         else\n-         {\n-            png_ptr->inv_filter_weights[i] =\n-               (png_uint_16)((double)PNG_WEIGHT_FACTOR*filter_weights[i]+0.5);\n-            png_ptr->filter_weights[i] =\n-               (png_uint_16)((double)PNG_WEIGHT_FACTOR/filter_weights[i]+0.5);\n-         }\n-      }\n-   }\n-\n-   /* If, in the future, there are other filter methods, this would\n-    * need to be based on png_ptr->filter.\n-    */\n-   if (png_ptr->filter_costs == NULL)\n-   {\n-      png_ptr->filter_costs = (png_uint_16p)png_malloc(png_ptr,\n-         (png_uint_32)(png_sizeof(png_uint_16) * PNG_FILTER_VALUE_LAST));\n-\n-      png_ptr->inv_filter_costs = (png_uint_16p)png_malloc(png_ptr,\n-         (png_uint_32)(png_sizeof(png_uint_16) * PNG_FILTER_VALUE_LAST));\n-\n-      for (i = 0; i < PNG_FILTER_VALUE_LAST; i++)\n-      {\n-         png_ptr->inv_filter_costs[i] =\n-         png_ptr->filter_costs[i] = PNG_COST_FACTOR;\n-      }\n-   }\n-\n-   /* Here is where we set the relative costs of the different filters.  We\n-    * should take the desired compression level into account when setting\n-    * the costs, so that Paeth, for instance, has a high relative cost at low\n-    * compression levels, while it has a lower relative cost at higher\n-    * compression settings.  The filter types are in order of increasing\n-    * relative cost, so it would be possible to do this with an algorithm.\n-    */\n-   for (i = 0; i < PNG_FILTER_VALUE_LAST; i++)\n-   {\n-      if (filter_costs == NULL || filter_costs[i] < 0.0)\n-      {\n-         png_ptr->inv_filter_costs[i] =\n-         png_ptr->filter_costs[i] = PNG_COST_FACTOR;\n-      }\n-      else if (filter_costs[i] >= 1.0)\n-      {\n-         png_ptr->inv_filter_costs[i] =\n-            (png_uint_16)((double)PNG_COST_FACTOR / filter_costs[i] + 0.5);\n-         png_ptr->filter_costs[i] =\n-            (png_uint_16)((double)PNG_COST_FACTOR * filter_costs[i] + 0.5);\n-      }\n-   }\n+   PNG_UNUSED(png_ptr)\n+   PNG_UNUSED(heuristic_method)\n+   PNG_UNUSED(num_weights)\n+   PNG_UNUSED(filter_weights)\n+   PNG_UNUSED(filter_costs)\n }\n #endif /* PNG_WRITE_WEIGHTED_FILTER_SUPPORTED */\n ""}<_**next**_>{""sha"": ""bc6c98669c5a0b31edf1f4a61559ba948477926b"", ""filename"": ""third_party/libpng/pngwutil.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 319, ""changes"": 333, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngwutil.c"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f3d85b096f66870a15b37c2f40b219b2e292693/third_party/libpng/pngwutil.c"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libpng/pngwutil.c?ref=7f3d85b096f66870a15b37c2f40b219b2e292693"", ""patch"": ""@@ -1,8 +1,8 @@\n \n /* pngwutil.c - utilities to write a PNG file\n  *\n- * Last changed in libpng 1.2.43 [February 25, 2010]\n- * Copyright (c) 1998-2010 Glenn Randers-Pehrson\n+ * Last changed in libpng 1.2.54 [November 12, 2015]\n+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson\n  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\n  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\n  *\n@@ -254,7 +254,7 @@ png_text_compress(png_structp png_ptr,\n                old_ptr = comp->output_ptr;\n                comp->output_ptr = (png_charpp)png_malloc(png_ptr,\n                   (png_uint_32)\n-                  (comp->max_output_ptr * png_sizeof(png_charpp)));\n+                  (comp->max_output_ptr * png_sizeof(png_charp)));\n                png_memcpy(comp->output_ptr, old_ptr, old_max\n                   * png_sizeof(png_charp));\n                png_free(png_ptr, old_ptr);\n@@ -575,17 +575,20 @@ png_write_PLTE(png_structp png_ptr, png_colorp palette, png_uint_32 num_pal)\n #ifdef PNG_USE_LOCAL_ARRAYS\n    PNG_PLTE;\n #endif\n-   png_uint_32 i;\n+   png_uint_32 max_palette_length, i;\n    png_colorp pal_ptr;\n    png_byte buf[3];\n \n    png_debug(1, \""in png_write_PLTE\"");\n \n+   max_palette_length = (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?\n+      (1 << png_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;\n+\n    if ((\n #ifdef PNG_MNG_FEATURES_SUPPORTED\n         !(png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) &&\n #endif\n-        num_pal == 0) || num_pal > 256)\n+       num_pal == 0) || num_pal > max_palette_length)\n    {\n      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n@@ -1759,6 +1762,7 @@ void /* PRIVATE */\n png_write_start_row(png_structp png_ptr)\n {\n #ifdef PNG_WRITE_INTERLACING_SUPPORTED\n+#ifndef PNG_USE_GLOBAL_ARRAYS\n    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n \n    /* Start of interlace block */\n@@ -1772,6 +1776,7 @@ png_write_start_row(png_structp png_ptr)\n \n    /* Offset to next interlace block in the y direction */\n    int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n+#endif\n #endif\n \n    png_size_t buf_size;\n@@ -1857,6 +1862,7 @@ void /* PRIVATE */\n png_write_finish_row(png_structp png_ptr)\n {\n #ifdef PNG_WRITE_INTERLACING_SUPPORTED\n+#ifndef PNG_USE_GLOBAL_ARRAYS\n    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n \n    /* Start of interlace block */\n@@ -1870,6 +1876,7 @@ png_write_finish_row(png_structp png_ptr)\n \n    /* Offset to next interlace block in the y direction */\n    int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n+#endif\n #endif\n \n    int ret;\n@@ -1976,11 +1983,13 @@ png_do_write_interlace(png_row_infop row_info, png_bytep row, int pass)\n {\n    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n \n+#ifndef PNG_USE_GLOBAL_ARRAYS\n    /* Start of interlace block */\n    int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\n \n    /* Offset to next interlace block */\n    int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n+#endif\n \n    png_debug(1, \""in png_do_write_interlace\"");\n \n@@ -2150,20 +2159,9 @@ png_write_find_filter(png_structp png_ptr, png_row_infop row_info)\n    png_uint_32 mins, bpp;\n    png_byte filter_to_do = png_ptr->do_filter;\n    png_uint_32 row_bytes = row_info->rowbytes;\n-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n-   int num_p_filters = (int)png_ptr->num_prev_filters;\n-#endif \n \n    png_debug(1, \""in png_write_find_filter\"");\n \n-#ifndef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n-  if (png_ptr->row_number == 0 && filter_to_do == PNG_ALL_FILTERS)\n-  {\n-      /* These will never be selected so we need not test them. */\n-      filter_to_do &= ~(PNG_FILTER_UP | PNG_FILTER_PAETH);\n-  }\n-#endif \n-\n    /* Find out how many bytes offset each pixel is */\n    bpp = (row_info->pixel_depth + 7) >> 3;\n \n@@ -2213,41 +2211,6 @@ png_write_find_filter(png_structp png_ptr, png_row_infop row_info)\n          sum += (v < 128) ? v : 256 - v;\n       }\n \n-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n-      {\n-         png_uint_32 sumhi, sumlo;\n-         int j;\n-         sumlo = sum & PNG_LOMASK;\n-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK; /* Gives us some footroom */\n-\n-         /* Reduce the sum if we match any of the previous rows */\n-         for (j = 0; j < num_p_filters; j++)\n-         {\n-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)\n-            {\n-               sumlo = (sumlo * png_ptr->filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-               sumhi = (sumhi * png_ptr->filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-            }\n-         }\n-\n-         /* Factor in the cost of this filter (this is here for completeness,\n-          * but it makes no sense to have a \""cost\"" for the NONE filter, as\n-          * it has the minimum possible computational cost - none).\n-          */\n-         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>\n-            PNG_COST_SHIFT;\n-         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>\n-            PNG_COST_SHIFT;\n-\n-         if (sumhi > PNG_HIMASK)\n-            sum = PNG_MAXSUM;\n-         else\n-            sum = (sumhi << PNG_HISHIFT) + sumlo;\n-      }\n-#endif\n       mins = sum;\n    }\n \n@@ -2277,41 +2240,6 @@ png_write_find_filter(png_structp png_ptr, png_row_infop row_info)\n       png_uint_32 i;\n       int v;\n \n-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n-      /* We temporarily increase the \""minimum sum\"" by the factor we\n-       * would reduce the sum of this filter, so that we can do the\n-       * early exit comparison without scaling the sum each time.\n-       */\n-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n-      {\n-         int j;\n-         png_uint_32 lmhi, lmlo;\n-         lmlo = lmins & PNG_LOMASK;\n-         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;\n-\n-         for (j = 0; j < num_p_filters; j++)\n-         {\n-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)\n-            {\n-               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-            }\n-         }\n-\n-         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>\n-            PNG_COST_SHIFT;\n-         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>\n-            PNG_COST_SHIFT;\n-\n-         if (lmhi > PNG_HIMASK)\n-            lmins = PNG_MAXSUM;\n-         else\n-            lmins = (lmhi << PNG_HISHIFT) + lmlo;\n-      }\n-#endif\n-\n       for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;\n            i++, rp++, dp++)\n       {\n@@ -2330,37 +2258,6 @@ png_write_find_filter(png_structp png_ptr, png_row_infop row_info)\n             break;\n       }\n \n-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n-      {\n-         int j;\n-         png_uint_32 sumhi, sumlo;\n-         sumlo = sum & PNG_LOMASK;\n-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;\n-\n-         for (j = 0; j < num_p_filters; j++)\n-         {\n-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)\n-            {\n-               sumlo = (sumlo * png_ptr->inv_filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-               sumhi = (sumhi * png_ptr->inv_filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-            }\n-         }\n-\n-         sumlo = (sumlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>\n-            PNG_COST_SHIFT;\n-         sumhi = (sumhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>\n-            PNG_COST_SHIFT;\n-\n-         if (sumhi > PNG_HIMASK)\n-            sum = PNG_MAXSUM;\n-         else\n-            sum = (sumhi << PNG_HISHIFT) + sumlo;\n-      }\n-#endif\n-\n       if (sum < mins)\n       {\n          mins = sum;\n@@ -2390,38 +2287,6 @@ png_write_find_filter(png_structp png_ptr, png_row_infop row_info)\n       png_uint_32 i;\n       int v;\n \n-\n-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n-      {\n-         int j;\n-         png_uint_32 lmhi, lmlo;\n-         lmlo = lmins & PNG_LOMASK;\n-         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;\n-\n-         for (j = 0; j < num_p_filters; j++)\n-         {\n-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)\n-            {\n-               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-            }\n-         }\n-\n-         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>\n-            PNG_COST_SHIFT;\n-         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>\n-            PNG_COST_SHIFT;\n-\n-         if (lmhi > PNG_HIMASK)\n-            lmins = PNG_MAXSUM;\n-         else\n-            lmins = (lmhi << PNG_HISHIFT) + lmlo;\n-      }\n-#endif\n-\n       for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,\n            pp = prev_row + 1; i < row_bytes; i++)\n       {\n@@ -2433,37 +2298,6 @@ png_write_find_filter(png_structp png_ptr, png_row_infop row_info)\n             break;\n       }\n \n-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n-      {\n-         int j;\n-         png_uint_32 sumhi, sumlo;\n-         sumlo = sum & PNG_LOMASK;\n-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;\n-\n-         for (j = 0; j < num_p_filters; j++)\n-         {\n-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)\n-            {\n-               sumlo = (sumlo * png_ptr->filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-               sumhi = (sumhi * png_ptr->filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-            }\n-         }\n-\n-         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>\n-            PNG_COST_SHIFT;\n-         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>\n-            PNG_COST_SHIFT;\n-\n-         if (sumhi > PNG_HIMASK)\n-            sum = PNG_MAXSUM;\n-         else\n-            sum = (sumhi << PNG_HISHIFT) + sumlo;\n-      }\n-#endif\n-\n       if (sum < mins)\n       {\n          mins = sum;\n@@ -2496,37 +2330,6 @@ png_write_find_filter(png_structp png_ptr, png_row_infop row_info)\n       png_uint_32 i;\n       int v;\n \n-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n-      {\n-         int j;\n-         png_uint_32 lmhi, lmlo;\n-         lmlo = lmins & PNG_LOMASK;\n-         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;\n-\n-         for (j = 0; j < num_p_filters; j++)\n-         {\n-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_AVG)\n-            {\n-               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-            }\n-         }\n-\n-         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>\n-            PNG_COST_SHIFT;\n-         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>\n-            PNG_COST_SHIFT;\n-\n-         if (lmhi > PNG_HIMASK)\n-            lmins = PNG_MAXSUM;\n-         else\n-            lmins = (lmhi << PNG_HISHIFT) + lmlo;\n-      }\n-#endif\n-\n       for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,\n            pp = prev_row + 1; i < bpp; i++)\n       {\n@@ -2545,37 +2348,6 @@ png_write_find_filter(png_structp png_ptr, png_row_infop row_info)\n             break;\n       }\n \n-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n-      {\n-         int j;\n-         png_uint_32 sumhi, sumlo;\n-         sumlo = sum & PNG_LOMASK;\n-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;\n-\n-         for (j = 0; j < num_p_filters; j++)\n-         {\n-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)\n-            {\n-               sumlo = (sumlo * png_ptr->filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-               sumhi = (sumhi * png_ptr->filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-            }\n-         }\n-\n-         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>\n-            PNG_COST_SHIFT;\n-         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>\n-            PNG_COST_SHIFT;\n-\n-         if (sumhi > PNG_HIMASK)\n-            sum = PNG_MAXSUM;\n-         else\n-            sum = (sumhi << PNG_HISHIFT) + sumlo;\n-      }\n-#endif\n-\n       if (sum < mins)\n       {\n          mins = sum;\n@@ -2629,37 +2401,6 @@ png_write_find_filter(png_structp png_ptr, png_row_infop row_info)\n       png_uint_32 i;\n       int v;\n \n-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n-      {\n-         int j;\n-         png_uint_32 lmhi, lmlo;\n-         lmlo = lmins & PNG_LOMASK;\n-         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;\n-\n-         for (j = 0; j < num_p_filters; j++)\n-         {\n-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)\n-            {\n-               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-            }\n-         }\n-\n-         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>\n-            PNG_COST_SHIFT;\n-         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>\n-            PNG_COST_SHIFT;\n-\n-         if (lmhi > PNG_HIMASK)\n-            lmins = PNG_MAXSUM;\n-         else\n-            lmins = (lmhi << PNG_HISHIFT) + lmlo;\n-      }\n-#endif\n-\n       for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,\n            pp = prev_row + 1; i < bpp; i++)\n       {\n@@ -2710,37 +2451,6 @@ png_write_find_filter(png_structp png_ptr, png_row_infop row_info)\n             break;\n       }\n \n-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n-      {\n-         int j;\n-         png_uint_32 sumhi, sumlo;\n-         sumlo = sum & PNG_LOMASK;\n-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;\n-\n-         for (j = 0; j < num_p_filters; j++)\n-         {\n-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)\n-            {\n-               sumlo = (sumlo * png_ptr->filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-               sumhi = (sumhi * png_ptr->filter_weights[j]) >>\n-                  PNG_WEIGHT_SHIFT;\n-            }\n-         }\n-\n-         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>\n-            PNG_COST_SHIFT;\n-         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>\n-            PNG_COST_SHIFT;\n-\n-         if (sumhi > PNG_HIMASK)\n-            sum = PNG_MAXSUM;\n-         else\n-            sum = (sumhi << PNG_HISHIFT) + sumlo;\n-      }\n-#endif\n-\n       if (sum < mins)\n       {\n          best_row = png_ptr->paeth_row;\n@@ -2750,21 +2460,6 @@ png_write_find_filter(png_structp png_ptr, png_row_infop row_info)\n    /* Do the actual writing of the filtered row data from the chosen filter. */\n \n    png_write_filtered_row(png_ptr, best_row);\n-\n-#ifdef PNG_WRITE_FILTER_SUPPORTED\n-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n-   /* Save the type of filter we picked this time for future calculations */\n-   if (png_ptr->num_prev_filters > 0)\n-   {\n-      int j;\n-      for (j = 1; j < num_p_filters; j++)\n-      {\n-         png_ptr->prev_filters[j] = png_ptr->prev_filters[j - 1];\n-      }\n-      png_ptr->prev_filters[j] = best_row[0];\n-   }\n-#endif\n-#endif /* PNG_WRITE_FILTER_SUPPORTED */\n }\n \n ""}","#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED/~/   png_free(png_ptr, png_ptr->prev_filters);/~/   png_free(png_ptr, png_ptr->filter_weights);/~/   png_free(png_ptr, png_ptr->inv_filter_weights);/~/   png_free(png_ptr, png_ptr->filter_costs);/~/   png_free(png_ptr, png_ptr->inv_filter_costs);/~/#endif","32,33,34,35,36,37,38","png_write_destroy(png_structp png_ptr)
{
#ifdef PNG_SETJMP_SUPPORTED
   jmp_buf tmp_jmp; /* Save jump buffer */
#endif
   png_error_ptr error_fn;
   png_error_ptr warning_fn;
   png_voidp error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   png_free_ptr free_fn;
#endif

   png_debug(1, ""in png_write_destroy"");

   /* Free any memory zlib uses */
   deflateEnd(&png_ptr->zstream);

   /* Free our memory.  png_free checks NULL for us. */
   png_free(png_ptr, png_ptr->zbuf);
   png_free(png_ptr, png_ptr->row_buf);
#ifdef PNG_WRITE_FILTER_SUPPORTED
   png_free(png_ptr, png_ptr->prev_row);
   png_free(png_ptr, png_ptr->sub_row);
   png_free(png_ptr, png_ptr->up_row);
   png_free(png_ptr, png_ptr->avg_row);
   png_free(png_ptr, png_ptr->paeth_row);
#endif

#ifdef PNG_TIME_RFC1123_SUPPORTED
    png_free(png_ptr, png_ptr->time_buffer);
 #endif
 
 #ifdef PNG_SETJMP_SUPPORTED
    /* Reset structure */
    png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));
#endif

   error_fn = png_ptr->error_fn;
   warning_fn = png_ptr->warning_fn;
   error_ptr = png_ptr->error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   free_fn = png_ptr->free_fn;
#endif

   png_memset(png_ptr, 0, png_sizeof(png_struct));

   png_ptr->error_fn = error_fn;
   png_ptr->warning_fn = warning_fn;
   png_ptr->error_ptr = error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   png_ptr->free_fn = free_fn;
#endif

#ifdef PNG_SETJMP_SUPPORTED
   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof(jmp_buf));
#endif
}
","png_write_destroy(png_structp png_ptr)
{
#ifdef PNG_SETJMP_SUPPORTED
   jmp_buf tmp_jmp; /* Save jump buffer */
#endif
   png_error_ptr error_fn;
   png_error_ptr warning_fn;
   png_voidp error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   png_free_ptr free_fn;
#endif

   png_debug(1, ""in png_write_destroy"");

   /* Free any memory zlib uses */
   deflateEnd(&png_ptr->zstream);

   /* Free our memory.  png_free checks NULL for us. */
   png_free(png_ptr, png_ptr->zbuf);
   png_free(png_ptr, png_ptr->row_buf);
#ifdef PNG_WRITE_FILTER_SUPPORTED
   png_free(png_ptr, png_ptr->prev_row);
   png_free(png_ptr, png_ptr->sub_row);
   png_free(png_ptr, png_ptr->up_row);
   png_free(png_ptr, png_ptr->avg_row);
   png_free(png_ptr, png_ptr->paeth_row);
#endif

#ifdef PNG_TIME_RFC1123_SUPPORTED
    png_free(png_ptr, png_ptr->time_buffer);
 #endif
 
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
   png_free(png_ptr, png_ptr->prev_filters);
   png_free(png_ptr, png_ptr->filter_weights);
   png_free(png_ptr, png_ptr->inv_filter_weights);
   png_free(png_ptr, png_ptr->filter_costs);
   png_free(png_ptr, png_ptr->inv_filter_costs);
#endif
 #ifdef PNG_SETJMP_SUPPORTED
    /* Reset structure */
    png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));
#endif

   error_fn = png_ptr->error_fn;
   warning_fn = png_ptr->warning_fn;
   error_ptr = png_ptr->error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   free_fn = png_ptr->free_fn;
#endif

   png_memset(png_ptr, 0, png_sizeof(png_struct));

   png_ptr->error_fn = error_fn;
   png_ptr->warning_fn = warning_fn;
   png_ptr->error_ptr = error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   png_ptr->free_fn = free_fn;
#endif

#ifdef PNG_SETJMP_SUPPORTED
   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof(jmp_buf));
#endif
}
",186157.0,C,,"#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
   png_free(png_ptr, png_ptr->prev_filters);
   png_free(png_ptr, png_ptr->filter_weights);
   png_free(png_ptr, png_ptr->inv_filter_weights);
   png_free(png_ptr, png_ptr->filter_costs);
   png_free(png_ptr, png_ptr->inv_filter_costs);
#endif
",,"@@ -1,8 +1,8 @@
 
 /* pngwrite.c - general routines to write a PNG file
  *
- * Last changed in libpng 1.2.52 [November 20, 2014]
- * Copyright (c) 1998-2014 Glenn Randers-Pehrson
+ * Last changed in libpng 1.2.54 [November 12, 2015]
+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -584,11 +584,6 @@ png_create_write_struct_2(png_const_charp user_png_ver, png_voidp error_ptr,
    png_set_write_fn(png_ptr, png_voidp_NULL, png_rw_ptr_NULL,
       png_flush_ptr_NULL);
 
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-   png_set_filter_heuristics(png_ptr, PNG_FILTER_HEURISTIC_DEFAULT,
-      1, png_doublep_NULL, png_doublep_NULL);
-#endif
-
 #ifdef PNG_SETJMP_SUPPORTED
    /* Applications that neglect to set up their own setjmp() and then
     * encounter a png_error() will longjmp here.  Since the jmpbuf is
@@ -731,10 +726,6 @@ png_write_init_3(png_structpp ptr_ptr, png_const_charp user_png_ver,
    png_ptr->zbuf_size = PNG_ZBUF_SIZE;
    png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,
      (png_uint_32)png_ptr->zbuf_size);
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-   png_set_filter_heuristics(png_ptr, PNG_FILTER_HEURISTIC_DEFAULT,
-      1, png_doublep_NULL, png_doublep_NULL);
-#endif
 }
 
 /* Write a few rows of image data.  If the image is interlaced,
@@ -1150,14 +1141,6 @@ png_write_destroy(png_structp png_ptr)
    png_free(png_ptr, png_ptr->time_buffer);
 #endif
 
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-   png_free(png_ptr, png_ptr->prev_filters);
-   png_free(png_ptr, png_ptr->filter_weights);
-   png_free(png_ptr, png_ptr->inv_filter_weights);
-   png_free(png_ptr, png_ptr->filter_costs);
-   png_free(png_ptr, png_ptr->inv_filter_costs);
-#endif
-
 #ifdef PNG_SETJMP_SUPPORTED
    /* Reset structure */
    png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));
@@ -1201,14 +1184,13 @@ png_set_filter(png_structp png_ptr, int method, int filters)
    {
       switch (filters & (PNG_ALL_FILTERS | 0x07))
       {
+         case PNG_FILTER_VALUE_NONE:
+              png_ptr->do_filter = PNG_FILTER_NONE; break;
 #ifdef PNG_WRITE_FILTER_SUPPORTED
          case 5:
          case 6:
          case 7: png_warning(png_ptr, ""Unknown row filter for method 0"");
-#endif /* PNG_WRITE_FILTER_SUPPORTED */
-         case PNG_FILTER_VALUE_NONE:
-              png_ptr->do_filter = PNG_FILTER_NONE; break;
-#ifdef PNG_WRITE_FILTER_SUPPORTED
+                 break;
          case PNG_FILTER_VALUE_SUB:
               png_ptr->do_filter = PNG_FILTER_SUB; break;
          case PNG_FILTER_VALUE_UP:
@@ -1220,6 +1202,7 @@ png_set_filter(png_structp png_ptr, int method, int filters)
          default: png_ptr->do_filter = (png_byte)filters; break;
 #else
          default: png_warning(png_ptr, ""Unknown row filter for method 0"");
+                 break;
 #endif /* PNG_WRITE_FILTER_SUPPORTED */
       }
 
@@ -1310,117 +1293,11 @@ png_set_filter_heuristics(png_structp png_ptr, int heuristic_method,
    int num_weights, png_doublep filter_weights,
    png_doublep filter_costs)
 {
-   int i;
-
-   png_debug(1, ""in png_set_filter_heuristics"");
-
-   if (png_ptr == NULL)
-      return;
-   if (heuristic_method >= PNG_FILTER_HEURISTIC_LAST)
-   {
-      png_warning(png_ptr, ""Unknown filter heuristic method"");
-      return;
-   }
-
-   if (heuristic_method == PNG_FILTER_HEURISTIC_DEFAULT)
-   {
-      heuristic_method = PNG_FILTER_HEURISTIC_UNWEIGHTED;
-   }
-
-   if (num_weights < 0 || filter_weights == NULL ||
-      heuristic_method == PNG_FILTER_HEURISTIC_UNWEIGHTED)
-   {
-      num_weights = 0;
-   }
-
-   png_ptr->num_prev_filters = (png_byte)num_weights;
-   png_ptr->heuristic_method = (png_byte)heuristic_method;
-
-   if (num_weights > 0)
-   {
-      if (png_ptr->prev_filters == NULL)
-      {
-         png_ptr->prev_filters = (png_bytep)png_malloc(png_ptr,
-            (png_uint_32)(png_sizeof(png_byte) * num_weights));
-
-         /* To make sure that the weighting starts out fairly */
-         for (i = 0; i < num_weights; i++)
-         {
-            png_ptr->prev_filters[i] = 255;
-         }
-      }
-
-      if (png_ptr->filter_weights == NULL)
-      {
-         png_ptr->filter_weights = (png_uint_16p)png_malloc(png_ptr,
-            (png_uint_32)(png_sizeof(png_uint_16) * num_weights));
-
-         png_ptr->inv_filter_weights = (png_uint_16p)png_malloc(png_ptr,
-            (png_uint_32)(png_sizeof(png_uint_16) * num_weights));
-         for (i = 0; i < num_weights; i++)
-         {
-            png_ptr->inv_filter_weights[i] =
-            png_ptr->filter_weights[i] = PNG_WEIGHT_FACTOR;
-         }
-      }
-
-      for (i = 0; i < num_weights; i++)
-      {
-         if (filter_weights[i] < 0.0)
-         {
-            png_ptr->inv_filter_weights[i] =
-            png_ptr->filter_weights[i] = PNG_WEIGHT_FACTOR;
-         }
-         else
-         {
-            png_ptr->inv_filter_weights[i] =
-               (png_uint_16)((double)PNG_WEIGHT_FACTOR*filter_weights[i]+0.5);
-            png_ptr->filter_weights[i] =
-               (png_uint_16)((double)PNG_WEIGHT_FACTOR/filter_weights[i]+0.5);
-         }
-      }
-   }
-
-   /* If, in the future, there are other filter methods, this would
-    * need to be based on png_ptr->filter.
-    */
-   if (png_ptr->filter_costs == NULL)
-   {
-      png_ptr->filter_costs = (png_uint_16p)png_malloc(png_ptr,
-         (png_uint_32)(png_sizeof(png_uint_16) * PNG_FILTER_VALUE_LAST));
-
-      png_ptr->inv_filter_costs = (png_uint_16p)png_malloc(png_ptr,
-         (png_uint_32)(png_sizeof(png_uint_16) * PNG_FILTER_VALUE_LAST));
-
-      for (i = 0; i < PNG_FILTER_VALUE_LAST; i++)
-      {
-         png_ptr->inv_filter_costs[i] =
-         png_ptr->filter_costs[i] = PNG_COST_FACTOR;
-      }
-   }
-
-   /* Here is where we set the relative costs of the different filters.  We
-    * should take the desired compression level into account when setting
-    * the costs, so that Paeth, for instance, has a high relative cost at low
-    * compression levels, while it has a lower relative cost at higher
-    * compression settings.  The filter types are in order of increasing
-    * relative cost, so it would be possible to do this with an algorithm.
-    */
-   for (i = 0; i < PNG_FILTER_VALUE_LAST; i++)
-   {
-      if (filter_costs == NULL || filter_costs[i] < 0.0)
-      {
-         png_ptr->inv_filter_costs[i] =
-         png_ptr->filter_costs[i] = PNG_COST_FACTOR;
-      }
-      else if (filter_costs[i] >= 1.0)
-      {
-         png_ptr->inv_filter_costs[i] =
-            (png_uint_16)((double)PNG_COST_FACTOR / filter_costs[i] + 0.5);
-         png_ptr->filter_costs[i] =
-            (png_uint_16)((double)PNG_COST_FACTOR * filter_costs[i] + 0.5);
-      }
-   }
+   PNG_UNUSED(png_ptr)
+   PNG_UNUSED(heuristic_method)
+   PNG_UNUSED(num_weights)
+   PNG_UNUSED(filter_weights)
+   PNG_UNUSED(filter_costs)
 }
 #endif /* PNG_WRITE_WEIGHTED_FILTER_SUPPORTED */
 ","png_write_destroy(png_structp png_ptr)
{
#ifdef PNG_SETJMP_SUPPORTED
jmp_buf tmp_jmp; /* Save jump buffer */
#endif
png_error_ptr error_fn;
png_error_ptr warning_fn;
png_voidp error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
png_free_ptr free_fn;
#endif

png_debug(1, ""in png_write_destroy"");

/* Free any memory zlib uses */
deflateEnd(&png_ptr->zstream);

/* Free our memory.  png_free checks NULL for us. */
png_free(png_ptr, png_ptr->zbuf);
png_free(png_ptr, png_ptr->row_buf);
#ifdef PNG_WRITE_FILTER_SUPPORTED
png_free(png_ptr, png_ptr->prev_row);
png_free(png_ptr, png_ptr->sub_row);
png_free(png_ptr, png_ptr->up_row);
png_free(png_ptr, png_ptr->avg_row);
png_free(png_ptr, png_ptr->paeth_row);
#endif

#ifdef PNG_TIME_RFC1123_SUPPORTED
png_free(png_ptr, png_ptr->time_buffer);
#endif

#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
   png_free(png_ptr, png_ptr->prev_filters);
   png_free(png_ptr, png_ptr->filter_weights);
   png_free(png_ptr, png_ptr->inv_filter_weights);
   png_free(png_ptr, png_ptr->filter_costs);
   png_free(png_ptr, png_ptr->inv_filter_costs);
#endif
#ifdef PNG_SETJMP_SUPPORTED
/* Reset structure */
png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));
#endif

error_fn = png_ptr->error_fn;
warning_fn = png_ptr->warning_fn;
error_ptr = png_ptr->error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
free_fn = png_ptr->free_fn;
#endif

png_memset(png_ptr, 0, png_sizeof(png_struct));

png_ptr->error_fn = error_fn;
png_ptr->warning_fn = warning_fn;
png_ptr->error_ptr = error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
png_ptr->free_fn = free_fn;
#endif

#ifdef PNG_SETJMP_SUPPORTED
png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof(jmp_buf));
#endif
}
",Chrome,7f3d85b096f66870a15b37c2f40b219b2e292693,b23c180344c5df1f3fbdc8c8387d30e9c9ef8a2f,1.0,"png_write_destroy(png_structp png_ptr)
{
#ifdef PNG_SETJMP_SUPPORTED
   jmp_buf tmp_jmp; /* Save jump buffer */
#endif
   png_error_ptr error_fn;
   png_error_ptr warning_fn;
   png_voidp error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   png_free_ptr free_fn;
#endif

   png_debug(1, ""in png_write_destroy"");

   /* Free any memory zlib uses */
   deflateEnd(&png_ptr->zstream);

   /* Free our memory.  png_free checks NULL for us. */
   png_free(png_ptr, png_ptr->zbuf);
   png_free(png_ptr, png_ptr->row_buf);
#ifdef PNG_WRITE_FILTER_SUPPORTED
   png_free(png_ptr, png_ptr->prev_row);
   png_free(png_ptr, png_ptr->sub_row);
   png_free(png_ptr, png_ptr->up_row);
   png_free(png_ptr, png_ptr->avg_row);
   png_free(png_ptr, png_ptr->paeth_row);
#endif

#ifdef PNG_TIME_RFC1123_SUPPORTED
    png_free(png_ptr, png_ptr->time_buffer);
 #endif
 
//flaw_line_below:
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
//flaw_line_below:
   png_free(png_ptr, png_ptr->prev_filters);
//flaw_line_below:
   png_free(png_ptr, png_ptr->filter_weights);
//flaw_line_below:
   png_free(png_ptr, png_ptr->inv_filter_weights);
//flaw_line_below:
   png_free(png_ptr, png_ptr->filter_costs);
//flaw_line_below:
   png_free(png_ptr, png_ptr->inv_filter_costs);
//flaw_line_below:
#endif
//flaw_line_below:

 #ifdef PNG_SETJMP_SUPPORTED
    /* Reset structure */
    png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));
#endif

   error_fn = png_ptr->error_fn;
   warning_fn = png_ptr->warning_fn;
   error_ptr = png_ptr->error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   free_fn = png_ptr->free_fn;
#endif

   png_memset(png_ptr, 0, png_sizeof(png_struct));

   png_ptr->error_fn = error_fn;
   png_ptr->warning_fn = warning_fn;
   png_ptr->error_ptr = error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   png_ptr->free_fn = free_fn;
#endif

#ifdef PNG_SETJMP_SUPPORTED
   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof(jmp_buf));
#endif
}
"
980,None,Remote,Not required,Partial,CVE-2016-7944,https://www.cvedetails.com/cve/CVE-2016-7944/,CWE-190,Low,Partial,Partial,,2016-12-13,7.5,"Integer overflow in X.org libXfixes before 5.0.3 on 32-bit platforms might allow remote X servers to gain privileges via a length value of INT_MAX, which triggers the client to stop reading data and get out of sync.",2017-06-30,Overflow +Priv,11.0,https://cgit.freedesktop.org/xorg/lib/libXfixes/commit/?id=61c1039ee23a2d1de712843bed3480654d7ef42e,61c1039ee23a2d1de712843bed3480654d7ef42e,,3.0,,,    nbytes = (long) rep.length << 2;/~/    nrects = rep.length >> 1;/~/    rects = Xmalloc (nrects * sizeof (XRectangle));,"31,32,33","XFixesFetchRegionAndBounds (Display	    *dpy,
			    XserverRegion   region,
			    int		    *nrectanglesRet,
			    XRectangle	    *bounds)
{
    XFixesExtDisplayInfo	*info = XFixesFindDisplay (dpy);
    xXFixesFetchRegionReq	*req;
    xXFixesFetchRegionReply	rep;
    XRectangle			*rects;
    int    			nrects;
    long    			nbytes;
    long			nread;

    XFixesCheckExtension (dpy, info, NULL);
    LockDisplay (dpy);
    GetReq (XFixesFetchRegion, req);
    req->reqType = info->codes->major_opcode;
    req->xfixesReqType = X_XFixesFetchRegion;
    req->region = region;
    *nrectanglesRet = 0;
    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))
    {
	UnlockDisplay (dpy);
	SyncHandle ();
	return NULL;
    }
    bounds->x = rep.x;
    bounds->y = rep.y;
     bounds->y = rep.y;
     bounds->width = rep.width;
     bounds->height = rep.height;

    if (rep.length < (INT_MAX >> 2)) {
	nbytes = (long) rep.length << 2;
	nrects = rep.length >> 1;
	rects = Xmalloc (nrects * sizeof (XRectangle));
    } else {
	nbytes = 0;
	nrects = 0;
	rects = NULL;
    }

     if (!rects)
     {
 	_XEatDataWords(dpy, rep.length);
	_XEatData (dpy, (unsigned long) (nbytes - nread));
    }
    UnlockDisplay (dpy);
    SyncHandle();
    *nrectanglesRet = nrects;
    return rects;
}
","XFixesFetchRegionAndBounds (Display	    *dpy,
			    XserverRegion   region,
			    int		    *nrectanglesRet,
			    XRectangle	    *bounds)
{
    XFixesExtDisplayInfo	*info = XFixesFindDisplay (dpy);
    xXFixesFetchRegionReq	*req;
    xXFixesFetchRegionReply	rep;
    XRectangle			*rects;
    int    			nrects;
    long    			nbytes;
    long			nread;

    XFixesCheckExtension (dpy, info, NULL);
    LockDisplay (dpy);
    GetReq (XFixesFetchRegion, req);
    req->reqType = info->codes->major_opcode;
    req->xfixesReqType = X_XFixesFetchRegion;
    req->region = region;
    *nrectanglesRet = 0;
    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))
    {
	UnlockDisplay (dpy);
	SyncHandle ();
	return NULL;
    }
    bounds->x = rep.x;
    bounds->y = rep.y;
     bounds->y = rep.y;
     bounds->width = rep.width;
     bounds->height = rep.height;
    nbytes = (long) rep.length << 2;
    nrects = rep.length >> 1;
    rects = Xmalloc (nrects * sizeof (XRectangle));
     if (!rects)
     {
 	_XEatDataWords(dpy, rep.length);
	_XEatData (dpy, (unsigned long) (nbytes - nread));
    }
    UnlockDisplay (dpy);
    SyncHandle();
    *nrectanglesRet = nrects;
    return rects;
}
",178094.0,C,"
    if (rep.length < (INT_MAX >> 2)) {
	nbytes = (long) rep.length << 2;
	nrects = rep.length >> 1;
	rects = Xmalloc (nrects * sizeof (XRectangle));
    } else {
	nbytes = 0;
	nrects = 0;
	rects = NULL;
    }

","    nbytes = (long) rep.length << 2;
    nrects = rep.length >> 1;
    rects = Xmalloc (nrects * sizeof (XRectangle));
",b2406ed9031991b7ddc5b76b308623afc8a590c5,"@@ -23,6 +23,7 @@
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
+#include <limits.h>
 #include ""Xfixesint.h""
 
 XserverRegion
@@ -333,9 +334,17 @@ XFixesFetchRegionAndBounds (Display	    *dpy,
     bounds->y = rep.y;
     bounds->width = rep.width;
     bounds->height = rep.height;
-    nbytes = (long) rep.length << 2;
-    nrects = rep.length >> 1;
-    rects = Xmalloc (nrects * sizeof (XRectangle));
+
+    if (rep.length < (INT_MAX >> 2)) {
+	nbytes = (long) rep.length << 2;
+	nrects = rep.length >> 1;
+	rects = Xmalloc (nrects * sizeof (XRectangle));
+    } else {
+	nbytes = 0;
+	nrects = 0;
+	rects = NULL;
+    }
+
     if (!rects)
     {
 	_XEatDataWords(dpy, rep.length);","XFixesFetchRegionAndBounds (Display	    *dpy,
XserverRegion   region,
int		    *nrectanglesRet,
XRectangle	    *bounds)
{
XFixesExtDisplayInfo	*info = XFixesFindDisplay (dpy);
xXFixesFetchRegionReq	*req;
xXFixesFetchRegionReply	rep;
XRectangle			*rects;
int    			nrects;
long    			nbytes;
long			nread;

XFixesCheckExtension (dpy, info, NULL);
LockDisplay (dpy);
GetReq (XFixesFetchRegion, req);
req->reqType = info->codes->major_opcode;
req->xfixesReqType = X_XFixesFetchRegion;
req->region = region;
*nrectanglesRet = 0;
if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))
{
UnlockDisplay (dpy);
SyncHandle ();
return NULL;
}
bounds->x = rep.x;
bounds->y = rep.y;
bounds->y = rep.y;
bounds->width = rep.width;
bounds->height = rep.height;
    nbytes = (long) rep.length << 2;
    nrects = rep.length >> 1;
    rects = Xmalloc (nrects * sizeof (XRectangle));
if (!rects)
{
_XEatDataWords(dpy, rep.length);
_XEatData (dpy, (unsigned long) (nbytes - nread));
}
UnlockDisplay (dpy);
SyncHandle();
*nrectanglesRet = nrects;
return rects;
}
",libXfixes,https://cgit.freedesktop.org/xorg/lib/libXfixes/tree/src/Region.c?id=61c1039ee23a2d1de712843bed3480654d7ef42e,https://cgit.freedesktop.org/xorg/lib/libXfixes/tree/src/Region.c?id=b2406ed9031991b7ddc5b76b308623afc8a590c5,1.0,"XFixesFetchRegionAndBounds (Display	    *dpy,
			    XserverRegion   region,
			    int		    *nrectanglesRet,
			    XRectangle	    *bounds)
{
    XFixesExtDisplayInfo	*info = XFixesFindDisplay (dpy);
    xXFixesFetchRegionReq	*req;
    xXFixesFetchRegionReply	rep;
    XRectangle			*rects;
    int    			nrects;
    long    			nbytes;
    long			nread;

    XFixesCheckExtension (dpy, info, NULL);
    LockDisplay (dpy);
    GetReq (XFixesFetchRegion, req);
    req->reqType = info->codes->major_opcode;
    req->xfixesReqType = X_XFixesFetchRegion;
    req->region = region;
    *nrectanglesRet = 0;
    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))
    {
	UnlockDisplay (dpy);
	SyncHandle ();
	return NULL;
    }
    bounds->x = rep.x;
    bounds->y = rep.y;
     bounds->y = rep.y;
     bounds->width = rep.width;
     bounds->height = rep.height;
//flaw_line_below:
    nbytes = (long) rep.length << 2;
//flaw_line_below:
    nrects = rep.length >> 1;
//flaw_line_below:
    rects = Xmalloc (nrects * sizeof (XRectangle));
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (rep.length < (INT_MAX >> 2)) {
//fix_flaw_line_below:
//	nbytes = (long) rep.length << 2;
//fix_flaw_line_below:
//	nrects = rep.length >> 1;
//fix_flaw_line_below:
//	rects = Xmalloc (nrects * sizeof (XRectangle));
//fix_flaw_line_below:
//    } else {
//fix_flaw_line_below:
//	nbytes = 0;
//fix_flaw_line_below:
//	nrects = 0;
//fix_flaw_line_below:
//	rects = NULL;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     if (!rects)
     {
 	_XEatDataWords(dpy, rep.length);
	_XEatData (dpy, (unsigned long) (nbytes - nread));
    }
    UnlockDisplay (dpy);
    SyncHandle();
    *nrectanglesRet = nrects;
    return rects;
}
"
